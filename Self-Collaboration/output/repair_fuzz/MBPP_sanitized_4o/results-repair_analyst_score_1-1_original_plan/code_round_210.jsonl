{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 721, "prompt": "Given a square matrix of size N*N provided as a list of lists, where each cell is associated with a specific cost. A path is defined as a particular sequence of cells that begins from the top-left cell, moves only right or down, and concludes on the bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.", "code": "def maxAverageOfPath(cost):\n  N = len(cost)\n  dp = [[0 for i in range(N + 1)] for j in range(N + 1)]\n  dp[0][0] = cost[0][0]\n  for i in range(1, N):\n    dp[i][0] = dp[i - 1][0] + cost[i][0]\n  for j in range(1, N):\n    dp[0][j] = dp[0][j - 1] + cost[0][j]\n  for i in range(1, N):\n    for j in range(1, N):\n      dp[i][j] = max(dp[i - 1][j],\n                     dp[i][j - 1]) + cost[i][j]\n  return dp[N - 1][N - 1] / (2 * N - 1)", "test_imports": [], "test_list": ["assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2", "assert maxAverageOfPath([[2, 3, 4], [7, 6, 5], [8, 4, 10]], 3) == 6.2", "assert maxAverageOfPath([[3, 4, 5], [8, 7, 6], [9, 5, 11]], 3) == 7.2 ", "assert maxAverageOfPath([[6, 3, 1], [1, 4, 5], [2, 6, 6]], 3) == 5.0", "assert maxAverageOfPath([[5, 2, 3], [11, 3, 7], [3, 1, 10]], 3) == 7.2", "assert maxAverageOfPath([[5, 6, 2], [4, 8, 3], [2, 6, 9]], 2) == 6.333333333333333", "assert maxAverageOfPath([[5, 2, 6], [5, 6, 4], [9, 4, 14]], 3) == 7.4", "assert maxAverageOfPath([[3, 2, 2], [9, 5, 3], [9, 3, 11]], 1) == 3.0", "assert maxAverageOfPath([[4, 1, 2], [10, 10, 1], [5, 3, 4]], 3) == 6.2", "assert maxAverageOfPath([[1, 2, 6], [1, 3, 9], [4, 6, 14]], 1) == 1.0", "assert maxAverageOfPath([[5, 4, 8], [9, 9, 2], [12, 8, 14]], 2) == 7.666666666666667", "assert maxAverageOfPath([[2, 2, 4], [7, 9, 8], [8, 7, 11]], 1) == 2.0", "assert maxAverageOfPath([[1, 5, 4], [7, 3, 5], [2, 7, 4]], 1) == 1.0", "assert maxAverageOfPath([[3, 5, 1], [7, 9, 7], [7, 3, 9]], 1) == 3.0", "assert maxAverageOfPath([[6, 4, 4], [6, 2, 7], [9, 4, 6]], 1) == 6.0", "assert maxAverageOfPath([[3, 4, 8], [7, 3, 5], [3, 1, 4]], 2) == 4.333333333333333", "assert maxAverageOfPath([[5, 1, 6], [2, 4, 7], [9, 6, 12]], 3) == 6.8", "assert maxAverageOfPath([[5, 4, 6], [6, 3, 1], [9, 8, 8]], 1) == 5.0", "assert maxAverageOfPath([[4, 1, 2], [11, 4, 8], [12, 3, 13]], 3) == 8.6", "assert maxAverageOfPath([[4, 2, 6], [3, 9, 2], [9, 5, 10]], 3) == 6.2", "assert maxAverageOfPath([[2, 3, 5], [11, 4, 4], [5, 2, 11]], 1) == 2.0", "assert maxAverageOfPath([[3, 7, 3], [10, 10, 7], [3, 1, 5]], 2) == 7.666666666666667", "assert maxAverageOfPath([[4, 7, 5], [9, 1, 4], [6, 1, 5]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 1, 6], [10, 4, 9], [8, 2, 11]], 1) == 4.0", "assert maxAverageOfPath([[1, 2, 4], [3, 3, 9], [4, 3, 5]], 1) == 1.0", "assert maxAverageOfPath([[4, 3, 8], [9, 9, 7], [4, 1, 8]], 3) == 7.4", "assert maxAverageOfPath([[5, 6, 5], [3, 5, 4], [10, 1, 6]], 2) == 5.333333333333333", "assert maxAverageOfPath([[2, 2, 7], [3, 8, 9], [12, 6, 9]], 3) == 6.4", "assert maxAverageOfPath([[1, 5, 2], [6, 5, 8], [11, 1, 12]], 1) == 1.0", "assert maxAverageOfPath([[2, 5, 2], [6, 1, 2], [2, 3, 7]], 2) == 3.0", "assert maxAverageOfPath([[1, 2, 1], [3, 1, 8], [11, 1, 6]], 3) == 4.4", "assert maxAverageOfPath([[4, 2, 6], [2, 5, 2], [3, 3, 7]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[2, 3, 5], [9, 8, 6], [12, 5, 4]], 1) == 2.0", "assert maxAverageOfPath([[1, 3, 6], [7, 6, 8], [7, 4, 8]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 3, 1], [9, 6, 3], [6, 8, 13]], 3) == 8.0", "assert maxAverageOfPath([[6, 6, 7], [5, 8, 5], [5, 6, 12]], 2) == 6.666666666666667", "assert maxAverageOfPath([[1, 4, 7], [11, 8, 10], [7, 2, 15]], 3) == 9.0", "assert maxAverageOfPath([[5, 3, 7], [4, 8, 2], [8, 5, 9]], 2) == 5.666666666666667", "assert maxAverageOfPath([[5, 6, 9], [3, 1, 6], [5, 8, 12]], 1) == 5.0", "assert maxAverageOfPath([[2, 1, 3], [9, 10, 6], [12, 3, 14]], 3) == 8.2", "assert maxAverageOfPath([[5, 6, 5], [9, 9, 10], [3, 2, 13]], 2) == 7.666666666666667", "assert maxAverageOfPath([[7, 7, 9], [9, 1, 4], [12, 2, 15]], 3) == 9.0", "assert maxAverageOfPath([[7, 3, 8], [3, 1, 4], [9, 2, 15]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[7, 1, 9], [4, 11, 4], [3, 4, 9]], 2) == 7.333333333333333", "assert maxAverageOfPath([[5, 7, 1], [2, 1, 4], [12, 6, 9]], 2) == 4.333333333333333", "assert maxAverageOfPath([[3, 1, 5], [5, 4, 7], [11, 3, 13]], 3) == 7.0", "assert maxAverageOfPath([[3, 8, 9], [12, 8, 5], [5, 2, 9]], 1) == 3.0", "assert maxAverageOfPath([[4, 5, 1], [5, 5, 7], [13, 8, 14]], 1) == 4.0", "assert maxAverageOfPath([[6, 4, 3], [9, 7, 8], [11, 6, 6]], 3) == 7.6", "assert maxAverageOfPath([[4, 4, 7], [11, 1, 1], [5, 9, 12]], 2) == 5.333333333333333", "assert maxAverageOfPath([[1, 1, 9], [2, 8, 10], [5, 9, 6]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[7, 1, 6], [12, 2, 5], [4, 6, 11]], 3) == 8.0", "assert maxAverageOfPath([[5, 6, 9], [4, 6, 3], [10, 1, 13]], 1) == 5.0", "assert maxAverageOfPath([[4, 5, 2], [6, 1, 1], [10, 4, 8]], 1) == 4.0", "assert maxAverageOfPath([[4, 2, 4], [10, 6, 6], [13, 3, 12]], 1) == 4.0", "assert maxAverageOfPath([[3, 8, 1], [2, 2, 6], [3, 8, 5]], 2) == 4.333333333333333", "assert maxAverageOfPath([[4, 6, 7], [9, 1, 6], [13, 1, 5]], 2) == 4.666666666666667", "assert maxAverageOfPath([[5, 6, 4], [7, 4, 9], [6, 6, 10]], 1) == 5.0", "assert maxAverageOfPath([[7, 7, 8], [9, 7, 2], [11, 3, 6]], 1) == 7.0", "assert maxAverageOfPath([[5, 4, 4], [2, 1, 8], [12, 7, 12]], 2) == 3.3333333333333335", "assert maxAverageOfPath([[3, 2, 3], [12, 6, 3], [13, 1, 11]], 3) == 8.0", "assert maxAverageOfPath([[4, 2, 5], [2, 3, 4], [5, 6, 12]], 2) == 3.0", "assert maxAverageOfPath([[7, 1, 7], [4, 8, 2], [5, 2, 12]], 3) == 6.6", "assert maxAverageOfPath([[1, 6, 5], [7, 7, 2], [11, 4, 13]], 3) == 7.2", "assert maxAverageOfPath([[3, 6, 1], [10, 1, 3], [3, 8, 12]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 1, 2], [12, 4, 6], [13, 2, 14]], 3) == 9.0", "assert maxAverageOfPath([[2, 6, 7], [3, 7, 9], [9, 8, 7]], 3) == 6.2", "assert maxAverageOfPath([[5, 1, 1], [4, 7, 3], [6, 7, 9]], 2) == 5.333333333333333", "assert maxAverageOfPath([[3, 4, 3], [6, 4, 4], [7, 3, 14]], 2) == 4.333333333333333", "assert maxAverageOfPath([[2, 2, 9], [12, 2, 9], [4, 7, 7]], 1) == 2.0", "assert maxAverageOfPath([[4, 7, 2], [5, 4, 7], [9, 5, 10]], 2) == 5.0", "assert maxAverageOfPath([[2, 9, 1], [13, 5, 2], [4, 5, 11]], 2) == 6.666666666666667", "assert maxAverageOfPath([[6, 2, 1], [11, 12, 9], [4, 9, 14]], 2) == 9.666666666666666", "assert maxAverageOfPath([[3, 7, 10], [3, 9, 4], [11, 1, 7]], 3) == 6.2", "assert maxAverageOfPath([[6, 9, 5], [6, 7, 3], [6, 7, 10]], 1) == 6.0", "assert maxAverageOfPath([[4, 8, 3], [11, 10, 3], [11, 1, 12]], 1) == 4.0", "assert maxAverageOfPath([[6, 8, 9], [5, 11, 7], [9, 4, 10]], 2) == 8.333333333333334", "assert maxAverageOfPath([[4, 6, 8], [10, 7, 4], [10, 8, 14]], 2) == 7.0", "assert maxAverageOfPath([[8, 3, 3], [8, 4, 8], [12, 1, 14]], 1) == 8.0", "assert maxAverageOfPath([[8, 8, 10], [8, 12, 2], [14, 4, 9]], 3) == 8.6", "assert maxAverageOfPath([[4, 5, 4], [12, 7, 1], [12, 7, 11]], 3) == 9.2", "assert maxAverageOfPath([[8, 5, 10], [10, 10, 4], [11, 6, 8]], 1) == 8.0", "assert maxAverageOfPath([[7, 8, 8], [10, 7, 5], [6, 1, 9]], 2) == 8.0", "assert maxAverageOfPath([[1, 7, 4], [8, 7, 3], [11, 2, 8]], 2) == 5.333333333333333", "assert maxAverageOfPath([[1, 5, 6], [4, 2, 8], [6, 6, 10]], 2) == 2.6666666666666665", "assert maxAverageOfPath([[8, 8, 5], [3, 2, 5], [4, 3, 15]], 2) == 6.0", "assert maxAverageOfPath([[6, 8, 4], [9, 5, 11], [11, 8, 14]], 1) == 6.0", "assert maxAverageOfPath([[7, 9, 2], [13, 3, 2], [9, 10, 6]], 2) == 7.666666666666667", "assert maxAverageOfPath([[5, 7, 10], [8, 10, 11], [4, 3, 8]], 2) == 7.666666666666667", "assert maxAverageOfPath([[5, 6, 8], [12, 11, 4], [14, 6, 16]], 3) == 10.6", "assert maxAverageOfPath([[5, 2, 4], [12, 3, 9], [9, 7, 14]], 3) == 9.4", "assert maxAverageOfPath([[8, 7, 4], [4, 4, 7], [12, 5, 11]], 2) == 6.333333333333333", "assert maxAverageOfPath([[1, 8, 4], [11, 10, 8], [11, 1, 13]], 2) == 7.333333333333333", "assert maxAverageOfPath([[4, 9, 9], [5, 6, 11], [14, 8, 16]], 3) == 9.8", "assert maxAverageOfPath([[8, 8, 10], [11, 5, 9], [11, 5, 6]], 2) == 8.0", "assert maxAverageOfPath([[3, 1, 4], [6, 11, 7], [5, 8, 7]], 1) == 3.0", "assert maxAverageOfPath([[2, 6, 1], [11, 11, 3], [10, 3, 8]], 2) == 8.0", "assert maxAverageOfPath([[5, 8, 5], [9, 10, 3], [12, 5, 6]], 3) == 7.4", "assert maxAverageOfPath([[8, 4, 5], [4, 7, 9], [4, 2, 6]], 2) == 6.333333333333333", "assert maxAverageOfPath([[8, 7, 8], [9, 11, 1], [4, 7, 8]], 2) == 9.333333333333334", "assert maxAverageOfPath([[2, 7, 8], [6, 2, 9], [8, 8, 9]], 3) == 7.0", "assert maxAverageOfPath([[6, 5, 2], [13, 8, 8], [12, 2, 7]], 3) == 8.4"], "entry_point": "maxAverageOfPath", "completion": "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Step 1: Validate the input matrix\n    def is_valid_matrix(matrix, N):\n        if not matrix or len(matrix) != N:\n            return False\n        for row in matrix:\n            if len(row) != N or not all(isinstance(x, (int, float)) for x in row):\n                return False\n        return True\n\n    if not is_valid_matrix(matrix, N):\n        raise ValueError(\"Invalid matrix input\")\n\n    # Step 2: Develop a function to explore all possible paths and calculate total costs\n    def calculate_paths(matrix, N):\n        from functools import lru_cache\n\n        @lru_cache(None)\n        def dfs(x, y):\n            if x == N - 1 and y == N - 1:\n                return [(matrix[x][y], [(x, y)])]\n            \n            paths = []\n            if x + 1 < N:\n                for cost, path in dfs(x + 1, y):\n                    paths.append((cost + matrix[x][y], [(x, y)] + path))\n            if y + 1 < N:\n                for cost, path in dfs(x, y + 1):\n                    paths.append((cost + matrix[x][y], [(x, y)] + path))\n            return paths\n\n        return dfs(0, 0)\n\n    # Step 3: Calculate the average cost for each path\n    def calculate_averages(paths):\n        averages = []\n        for total_cost, path in paths:\n            averages.append(total_cost / len(path))\n        return averages\n\n    # Step 4: Determine the maximum average cost\n    paths = calculate_paths(matrix, N)\n    averages = calculate_averages(paths)\n    max_average = max(averages)\n\n    # Step 5: Return the maximum average cost\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "completions": ["from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Input Validation\n    if not matrix or not all(len(row) == N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N with numerical values.\")\n\n    # Helper function to calculate the maximum average path using dynamic programming\n    def calculate_max_average_path(matrix, N):\n        # Create a 2D list to store the maximum sum up to each cell\n        dp = [[0] * N for _ in range(N)]\n        dp[0][0] = matrix[0][0]\n\n        # Fill the first row\n        for j in range(1, N):\n            dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n        # Fill the first column\n        for i in range(1, N):\n            dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n        # Fill the rest of the dp table\n        for i in range(1, N):\n            for j in range(1, N):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n        # Calculate the maximum average\n        total_cells = 2 * N - 1\n        max_average = dp[N - 1][N - 1] / total_cells\n        return max_average\n\n    # Calculate and return the maximum average path\n    return calculate_max_average_path(matrix, N)\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Validate the input matrix dimensions\n    if not matrix or len(matrix) != N or any(len(row) != N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N\")\n\n    # Initialize variables to store the maximum average cost\n    max_average = float('-inf')\n\n    # Helper function to calculate the path cost and average\n    def calculate_path_cost_and_average(path):\n        total_cost = sum(matrix[x][y] for x, y in path)\n        average_cost = total_cost / len(path)\n        return average_cost\n\n    # Recursive function to explore all paths\n    def explore_paths(x, y, path):\n        nonlocal max_average\n\n        # Add current cell to path\n        path.append((x, y))\n\n        # If we reached the bottom-right cell, calculate the average cost\n        if x == N - 1 and y == N - 1:\n            average_cost = calculate_path_cost_and_average(path)\n            max_average = max(max_average, average_cost)\n        else:\n            # Move right if possible\n            if y + 1 < N:\n                explore_paths(x, y + 1, path[:])\n            # Move down if possible\n            if x + 1 < N:\n                explore_paths(x + 1, y, path[:])\n\n    # Start exploring paths from the top-left corner\n    explore_paths(0, 0, [])\n\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Input Validation\n    if not matrix or len(matrix) != N or any(len(row) != N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N.\")\n\n    # Helper function to calculate the maximum average path using dynamic programming\n    def calculate_max_average(matrix, N):\n        # Create a 2D array to store the maximum sum up to each cell\n        dp = [[0] * N for _ in range(N)]\n        dp[0][0] = matrix[0][0]\n\n        # Fill the first row\n        for j in range(1, N):\n            dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n        # Fill the first column\n        for i in range(1, N):\n            dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n        # Fill the rest of the dp array\n        for i in range(1, N):\n            for j in range(1, N):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n        # Calculate the maximum average\n        total_cells = 2 * N - 1\n        max_average = dp[N - 1][N - 1] / total_cells\n        return max_average\n\n    # Calculate and return the maximum average\n    return calculate_max_average(matrix, N)\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Input Validation\n    if not matrix or len(matrix) != N or any(len(row) != N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N.\")\n\n    # Helper function to calculate the maximum average path\n    def calculate_max_average_path(matrix, N):\n        # Initialize a 2D list to store the maximum sum up to each cell\n        max_sum = [[0] * N for _ in range(N)]\n        max_sum[0][0] = matrix[0][0]\n\n        # Fill the first row\n        for j in range(1, N):\n            max_sum[0][j] = max_sum[0][j - 1] + matrix[0][j]\n\n        # Fill the first column\n        for i in range(1, N):\n            max_sum[i][0] = max_sum[i - 1][0] + matrix[i][0]\n\n        # Fill the rest of the max_sum matrix\n        for i in range(1, N):\n            for j in range(1, N):\n                max_sum[i][j] = max(max_sum[i - 1][j], max_sum[i][j - 1]) + matrix[i][j]\n\n        # Calculate the maximum average\n        total_cells = 2 * N - 1\n        max_average = max_sum[N - 1][N - 1] / total_cells\n        return max_average\n\n    # Calculate and return the maximum average path\n    return calculate_max_average_path(matrix, N)\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Validate the input matrix\n    if not matrix or len(matrix) != N or any(len(row) != N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N with numerical values.\")\n\n    # Helper function to calculate the maximum average path using dynamic programming\n    def calculate_max_average(matrix, N):\n        # Create a 2D array to store the maximum sum up to each cell\n        dp = [[0] * N for _ in range(N)]\n        dp[0][0] = matrix[0][0]\n\n        # Fill the first row\n        for j in range(1, N):\n            dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n        # Fill the first column\n        for i in range(1, N):\n            dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n        # Fill the rest of the dp array\n        for i in range(1, N):\n            for j in range(1, N):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n        # Calculate the maximum average\n        total_cells = 2 * N - 1\n        max_average = dp[N - 1][N - 1] / total_cells\n        return max_average\n\n    # Calculate and return the maximum average path\n    return calculate_max_average(matrix, N)\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a proper N*N matrix\n    if not isinstance(matrix, list) or len(matrix) != N:\n        raise ValueError(\"Input must be a list of lists with size N*N.\")\n    for row in matrix:\n        if not isinstance(row, list) or len(row) != N:\n            raise ValueError(\"Each row must be a list with length N.\")\n\n    # Use dynamic programming to explore paths\n    dp = [[(0, 0) for _ in range(N)] for _ in range(N)]  # (total_cost, cell_count)\n\n    # Initialize the starting point\n    dp[0][0] = (matrix[0][0], 1)\n\n    # Fill the dp table\n    for i in range(N):\n        for j in range(N):\n            if i == 0 and j == 0:\n                continue\n            if i > 0:\n                total_cost, cell_count = dp[i-1][j]\n                dp[i][j] = max(dp[i][j], (total_cost + matrix[i][j], cell_count + 1))\n            if j > 0:\n                total_cost, cell_count = dp[i][j-1]\n                dp[i][j] = max(dp[i][j], (total_cost + matrix[i][j], cell_count + 1))\n\n    # Calculate the maximum average\n    total_cost, cell_count = dp[N-1][N-1]\n    max_average = total_cost / cell_count\n\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a proper N*N matrix\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        raise ValueError(\"Input must be a list of lists.\")\n    if not all(len(row) == N for row in matrix) or len(matrix) != N:\n        raise ValueError(\"Input must be a square matrix of size N*N.\")\n\n    # Handle edge cases\n    if N == 1:\n        return float(matrix[0][0])\n    elif N == 2:\n        return sum([matrix[i][j] for i in range(N) for j in range(N)]) / (N + 1)\n\n    # Use dynamic programming to explore paths\n    dp = [[0] * N for _ in range(N)]\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row and first column\n    for i in range(1, N):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    for j in range(1, N):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n\n    # Fill the rest of the dp table\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    # Calculate the maximum average\n    max_average = dp[N-1][N-1] / (2 * N - 1)\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Validate the input matrix to ensure it is a square matrix of size N*N\n    if not isinstance(matrix, list) or len(matrix) != N:\n        raise ValueError(\"Input must be a square matrix of size N*N\")\n    for row in matrix:\n        if not isinstance(row, list) or len(row) != N:\n            raise ValueError(\"Input must be a square matrix of size N*N\")\n\n    # Helper function to calculate the total cost and number of cells for a given path\n    def calculate_path_cost_and_cells(path):\n        total_cost = sum(matrix[x][y] for x, y in path)\n        num_cells = len(path)\n        return total_cost, num_cells\n\n    # Use dynamic programming to explore all possible paths\n    dp = [[(0, 0)] * N for _ in range(N)]  # (total_cost, num_cells)\n\n    # Initialize the starting point\n    dp[0][0] = (matrix[0][0], 1)\n\n    # Fill the dp table\n    for i in range(N):\n        for j in range(N):\n            if i == 0 and j == 0:\n                continue\n            if i > 0:\n                cost_from_top, cells_from_top = dp[i-1][j]\n                dp[i][j] = max(dp[i][j], (cost_from_top + matrix[i][j], cells_from_top + 1))\n            if j > 0:\n                cost_from_left, cells_from_left = dp[i][j-1]\n                dp[i][j] = max(dp[i][j], (cost_from_left + matrix[i][j], cells_from_left + 1))\n\n    # Calculate the maximum average\n    total_cost, num_cells = dp[N-1][N-1]\n    max_average = total_cost / num_cells\n\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a square matrix of size N*N\n    if not matrix or len(matrix) != N or any(len(row) != N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N\")\n\n    # Initialize a memoization table to store the maximum sum up to each cell\n    memo = [[None] * N for _ in range(N)]\n    \n    def maxPathSum(x, y):\n        # Base case: if we are at the top-left cell, return its value\n        if x == 0 and y == 0:\n            return matrix[0][0]\n        \n        # If the value is already computed, return it\n        if memo[x][y] is not None:\n            return memo[x][y]\n        \n        # Calculate the maximum path sum to the current cell\n        max_sum = float('-inf')\n        if x > 0:\n            max_sum = max(max_sum, maxPathSum(x - 1, y))\n        if y > 0:\n            max_sum = max(max_sum, maxPathSum(x, y - 1))\n        \n        # Add the current cell's value to the maximum path sum\n        memo[x][y] = max_sum + matrix[x][y]\n        return memo[x][y]\n    \n    # Calculate the maximum path sum to the bottom-right cell\n    max_sum = maxPathSum(N - 1, N - 1)\n    \n    # Calculate the number of cells in the path\n    num_cells = 2 * N - 1\n    \n    # Calculate the maximum average cost\n    max_average = max_sum / num_cells\n    \n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Step 1: Validate the input matrix\n    def is_valid_matrix(matrix, N):\n        if not matrix or len(matrix) != N:\n            return False\n        for row in matrix:\n            if len(row) != N or not all(isinstance(x, (int, float)) for x in row):\n                return False\n        return True\n\n    if not is_valid_matrix(matrix, N):\n        raise ValueError(\"Invalid matrix input\")\n\n    # Step 2: Develop a function to explore all possible paths and calculate total costs\n    def calculate_paths(matrix, N):\n        from functools import lru_cache\n\n        @lru_cache(None)\n        def dfs(x, y):\n            if x == N - 1 and y == N - 1:\n                return [(matrix[x][y], [(x, y)])]\n            \n            paths = []\n            if x + 1 < N:\n                for cost, path in dfs(x + 1, y):\n                    paths.append((cost + matrix[x][y], [(x, y)] + path))\n            if y + 1 < N:\n                for cost, path in dfs(x, y + 1):\n                    paths.append((cost + matrix[x][y], [(x, y)] + path))\n            return paths\n\n        return dfs(0, 0)\n\n    # Step 3: Calculate the average cost for each path\n    def calculate_averages(paths):\n        averages = []\n        for total_cost, path in paths:\n            averages.append(total_cost / len(path))\n        return averages\n\n    # Step 4: Determine the maximum average cost\n    paths = calculate_paths(matrix, N)\n    averages = calculate_averages(paths)\n    max_average = max(averages)\n\n    # Step 5: Return the maximum average cost\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Validate the input to ensure it is a square matrix of size N*N and contains valid numerical values.\",\n      \"output\": \"A boolean indicating whether the input is valid or not.\"\n    },\n    {\n      \"description\": \"Implement a function to calculate the total cost of a path from the top-left to the bottom-right of the matrix, moving only right or down.\",\n      \"output\": \"A list of all possible paths with their respective total costs.\"\n    },\n    {\n      \"description\": \"Calculate the average cost of each path by dividing the total cost by the number of cells in the path.\",\n      \"output\": \"A list of average costs for each path.\"\n    },\n    {\n      \"description\": \"Determine the maximum average cost from the list of average costs.\",\n      \"output\": \"The maximum average cost.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Step 1: Validate the input matrix to ensure it is a square matrix and contains valid numerical values.\",\n    \"Step 2: Develop a function to explore all possible paths from the top-left to the bottom-right of the matrix, moving only right or down, and calculate the total cost for each path.\",\n    \"Step 3: For each path, calculate the average cost by dividing the total cost by the number of cells in the path.\",\n    \"Step 4: Compare all the average costs and identify the maximum average cost.\",\n    \"Step 5: Return the maximum average cost as the result.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'square matrix': A matrix where the number of rows is equal to the number of columns.\n    'path': A sequence of cells that starts from the top-left cell, moves only right or down, and ends at the bottom-right cell.\n    'maximum average': The highest average value calculated from all possible paths.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest value among a set of values.\n\n# [code logic]\n    All steps should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n    Explanation: In the given square matrix, the path with the maximum average cost is [1, 6, 7, 3, 9] with a total cost of 26 and 5 cells visited, resulting in an average of 26/5 = 5.2.\n\n    Edge Cases:\n    1. maxAverageOfPath([[1]], 1) == 1.0\n    Explanation: In a 1x1 matrix, the only path is the single cell itself, so the average cost is the value of that cell.\n    \n    2. maxAverageOfPath([[1, 2], [3, 4]], 2) == 2.5\n    Explanation: In a 2x2 matrix, the path [1, 2, 4] has the maximum average cost of (1+2+4)/3 = 2.5.\n    \n    3. maxAverageOfPath([[5, 2, 1], [3, 4, 7], [8, 9, 6]], 3) == 6.0\n    Explanation: In the given matrix, the path [5, 3, 8, 9, 6] has the maximum average cost of (5+3+8+9+6)/5 = 6.0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge cases)\n\n# NO", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Step 1: Validate the input matrix\n    def is_valid_matrix(matrix, N):\n        if not matrix or len(matrix) != N:\n            return False\n        for row in matrix:\n            if len(row) != N or not all(isinstance(x, (int, float)) for x in row):\n                return False\n        return True\n\n    if not is_valid_matrix(matrix, N):\n        raise ValueError(\"Invalid matrix input\")\n\n    # Step 2: Develop a function to explore all possible paths and calculate total costs\n    def calculate_paths(matrix, N):\n        from functools import lru_cache\n\n        @lru_cache(None)\n        def dfs(x, y):\n            if x == N - 1 and y == N - 1:\n                return [(matrix[x][y], [(x, y)])]\n            \n            paths = []\n            if x + 1 < N:\n                for cost, path in dfs(x + 1, y):\n                    paths.append((cost + matrix[x][y], [(x, y)] + path))\n            if y + 1 < N:\n                for cost, path in dfs(x, y + 1):\n                    paths.append((cost + matrix[x][y], [(x, y)] + path))\n            return paths\n\n        return dfs(0, 0)\n\n    # Step 3: Calculate the average cost for each path\n    def calculate_averages(paths):\n        averages = []\n        for total_cost, path in paths:\n            averages.append(total_cost / len(path))\n        return averages\n\n    # Step 4: Determine the maximum average cost\n    paths = calculate_paths(matrix, N)\n    averages = calculate_averages(paths)\n    max_average = max(averages)\n\n    # Step 5: Return the maximum average cost\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Matrix Input Validation\",\n      \"description\": \"Ensure the input is a valid square matrix of size N*N and contains numerical values.\"\n    },\n    {\n      \"subproblem\": \"Path Enumeration\",\n      \"description\": \"Enumerate all possible paths from the top-left to the bottom-right of the matrix, moving only right or down.\"\n    },\n    {\n      \"subproblem\": \"Path Cost Calculation\",\n      \"description\": \"Calculate the total cost for each enumerated path.\"\n    },\n    {\n      \"subproblem\": \"Average Cost Calculation\",\n      \"description\": \"Compute the average cost for each path by dividing the total cost by the number of cells visited.\"\n    },\n    {\n      \"subproblem\": \"Maximum Average Path Identification\",\n      \"description\": \"Identify the path with the maximum average cost among all enumerated paths.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Input Validation\",\n      \"description\": \"Check if the input matrix is valid and meets the requirements of being a square matrix with numerical values.\"\n    },\n    {\n      \"step\": \"Path Enumeration\",\n      \"description\": \"Generate all possible paths from the top-left to the bottom-right corner of the matrix using recursive or iterative methods.\"\n    },\n    {\n      \"step\": \"Calculate Path Costs\",\n      \"description\": \"For each path, calculate the total cost by summing the values of the cells included in the path.\"\n    },\n    {\n      \"step\": \"Compute Average Costs\",\n      \"description\": \"For each path, compute the average cost by dividing the total cost by the number of cells in the path.\"\n    },\n    {\n      \"step\": \"Determine Maximum Average Path\",\n      \"description\": \"Compare the average costs of all paths and identify the path with the highest average cost.\"\n    },\n    {\n      \"step\": \"Return Result\",\n      \"description\": \"Output the maximum average cost found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'square matrix': A matrix where the number of rows is equal to the number of columns.\n    'path with maximum average': The path that has the highest average cost among all possible paths from the top-left to the bottom-right of the matrix.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest value or cost.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they are dependent on each other. Each step contributes to the overall goal of finding the path with the maximum average cost.\n\n# [edge case] \n    maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n    Explanation: In this case, the matrix is 3x3 and the path with the maximum average cost is [1, 6, 5, 4, 9] with a total cost of 25 and 5 cells visited, resulting in an average of 5.0.\n\n    Edge Cases:\n    1. maxAverageOfPath([[1]], 1) == 1.0\n    Explanation: When the matrix is a 1x1 matrix, the only path is the single cell itself, resulting in an average of the cell value.\n    \n    2. maxAverageOfPath([[1, 2], [3, 4]], 2) == 2.5\n    Explanation: In this case, there are two possible paths: [1, 2, 4] and [1, 3, 4]. The path [1, 3, 4] has the maximum average cost of 2.5.\n\n    3. maxAverageOfPath([[5, 2, 1], [10, 3, 4], [7, 8, 9]], 3) == 6.0\n    Explanation: Here, the path [5, 10, 7, 8, 9] has the maximum average cost of 6.0.\n\n# [extra code for edge case]\n    No extra code is needed to handle the edge cases. The existing logic should be able to handle different matrix sizes and values appropriately.", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Input Validation\n    if not matrix or not all(len(row) == N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N with numerical values.\")\n\n    # Helper function to calculate the maximum average path using dynamic programming\n    def calculate_max_average_path(matrix, N):\n        # Create a 2D list to store the maximum sum up to each cell\n        dp = [[0] * N for _ in range(N)]\n        dp[0][0] = matrix[0][0]\n\n        # Fill the first row\n        for j in range(1, N):\n            dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n        # Fill the first column\n        for i in range(1, N):\n            dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n        # Fill the rest of the dp table\n        for i in range(1, N):\n            for j in range(1, N):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n        # Calculate the maximum average\n        total_cells = 2 * N - 1\n        max_average = dp[N - 1][N - 1] / total_cells\n        return max_average\n\n    # Calculate and return the maximum average path\n    return calculate_max_average_path(matrix, N)\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Parse the input matrix and validate its dimensions to ensure it is a square matrix of size N*N.\"\n    },\n    {\n      \"subproblem\": \"Implement a function to calculate the cost of a path from the top-left to the bottom-right, moving only right or down.\"\n    },\n    {\n      \"subproblem\": \"Develop a method to iterate through all possible paths from the top-left to the bottom-right.\"\n    },\n    {\n      \"subproblem\": \"Calculate the average cost for each path by dividing the total cost by the number of cells visited.\"\n    },\n    {\n      \"subproblem\": \"Determine the path with the maximum average cost among all possible paths.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Initialize variables to store the maximum average cost and the corresponding path.\"\n    },\n    {\n      \"step\": \"Parse and validate the input matrix to ensure it is a square matrix of size N*N.\"\n    },\n    {\n      \"step\": \"Use a recursive or iterative approach to explore all paths from the top-left to the bottom-right, moving only right or down.\"\n    },\n    {\n      \"step\": \"For each path, calculate the total cost and the average cost.\"\n    },\n    {\n      \"step\": \"Compare the average cost of the current path with the maximum average cost stored. If the current path's average is higher, update the maximum average cost.\"\n    },\n    {\n      \"step\": \"Return the maximum average cost after evaluating all possible paths.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'square matrix': A matrix where the number of rows is equal to the number of columns.\n    'path with maximum average': The path that has the highest average cost among all possible paths.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest value among a set of values.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve different subproblems that build upon each other.\n\n# [edge case] \n    maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n    Explanation: In the given square matrix, the path with the maximum average cost is [1, 6, 5, 4, 9] with a total cost of 25 and 5 cells visited, resulting in an average of 5.0.\n\n    Edge Cases:\n    maxAverageOfPath([[1]], 1) == 1.0\n    Explanation: In a 1x1 matrix, the only path is the single cell itself with a cost of 1 and 1 cell visited, resulting in an average of 1.0.\n\n    maxAverageOfPath([[1, 2], [3, 4]], 2) == 2.5\n    Explanation: In a 2x2 matrix, the path with the maximum average cost is [1, 2, 4] with a total cost of 7 and 3 cells visited, resulting in an average of 2.33.\n\n    maxAverageOfPath([[5, 2, 1], [10, 3, 4], [7, 8, 9]], 3) == 6.0\n    Explanation: In the given square matrix, the path with the maximum average cost is [5, 10, 7, 8, 9] with a total cost of 39 and 5 cells visited, resulting in an average of 7.8.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Validate the input matrix dimensions\n    if not matrix or len(matrix) != N or any(len(row) != N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N\")\n\n    # Initialize variables to store the maximum average cost\n    max_average = float('-inf')\n\n    # Helper function to calculate the path cost and average\n    def calculate_path_cost_and_average(path):\n        total_cost = sum(matrix[x][y] for x, y in path)\n        average_cost = total_cost / len(path)\n        return average_cost\n\n    # Recursive function to explore all paths\n    def explore_paths(x, y, path):\n        nonlocal max_average\n\n        # Add current cell to path\n        path.append((x, y))\n\n        # If we reached the bottom-right cell, calculate the average cost\n        if x == N - 1 and y == N - 1:\n            average_cost = calculate_path_cost_and_average(path)\n            max_average = max(max_average, average_cost)\n        else:\n            # Move right if possible\n            if y + 1 < N:\n                explore_paths(x, y + 1, path[:])\n            # Move down if possible\n            if x + 1 < N:\n                explore_paths(x + 1, y, path[:])\n\n    # Start exploring paths from the top-left corner\n    explore_paths(0, 0, [])\n\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Matrix Validation\",\n      \"description\": \"Ensure the input matrix is a valid square matrix of size N*N.\"\n    },\n    {\n      \"subproblem\": \"Path Enumeration\",\n      \"description\": \"Enumerate all possible paths from the top-left to the bottom-right of the matrix, moving only right or down.\"\n    },\n    {\n      \"subproblem\": \"Path Cost Calculation\",\n      \"description\": \"Calculate the total cost for each enumerated path.\"\n    },\n    {\n      \"subproblem\": \"Average Cost Calculation\",\n      \"description\": \"Compute the average cost for each path by dividing the total cost by the number of cells visited.\"\n    },\n    {\n      \"subproblem\": \"Maximum Average Determination\",\n      \"description\": \"Identify the path with the maximum average cost among all paths.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Input Validation\",\n      \"description\": \"Check if the input matrix is a valid square matrix of size N*N.\"\n    },\n    {\n      \"step\": \"Path Enumeration\",\n      \"description\": \"Generate all possible paths from the top-left to the bottom-right corner of the matrix, adhering to the movement constraints (right or down).\"\n    },\n    {\n      \"step\": \"Cost Calculation\",\n      \"description\": \"For each path, calculate the total cost and the average cost.\"\n    },\n    {\n      \"step\": \"Determine Maximum Average\",\n      \"description\": \"Compare the average costs of all paths and select the path with the highest average cost.\"\n    },\n    {\n      \"step\": \"Return Result\",\n      \"description\": \"Output the maximum average cost found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'square matrix': A matrix where the number of rows is equal to the number of columns.\n    'path with maximum average': The path that has the highest average cost among all possible paths from the top-left to the bottom-right of the matrix.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest value or cost.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they are dependent on each other. Each step builds upon the previous one to find the path with the maximum average cost.\n\n# [edge case] \n    maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n    Explanation: In the given square matrix, the possible paths are:\n    1 -> 2 -> 3 -> 4 -> 9 (Average: (1+2+3+4+9)/5 = 3.8)\n    1 -> 2 -> 5 -> 4 -> 9 (Average: (1+2+5+4+9)/5 = 4.2)\n    1 -> 6 -> 5 -> 4 -> 9 (Average: (1+6+5+4+9)/5 = 5)\n    The path with the maximum average cost is [1, 6, 5, 4, 9] with an average of 5.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Input Validation\n    if not matrix or len(matrix) != N or any(len(row) != N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N.\")\n\n    # Helper function to calculate the maximum average path using dynamic programming\n    def calculate_max_average(matrix, N):\n        # Create a 2D array to store the maximum sum up to each cell\n        dp = [[0] * N for _ in range(N)]\n        dp[0][0] = matrix[0][0]\n\n        # Fill the first row\n        for j in range(1, N):\n            dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n        # Fill the first column\n        for i in range(1, N):\n            dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n        # Fill the rest of the dp array\n        for i in range(1, N):\n            for j in range(1, N):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n        # Calculate the maximum average\n        total_cells = 2 * N - 1\n        max_average = dp[N - 1][N - 1] / total_cells\n        return max_average\n\n    # Calculate and return the maximum average\n    return calculate_max_average(matrix, N)\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Matrix Validation\",\n      \"description\": \"Ensure the input matrix is a valid square matrix of size N*N.\"\n    },\n    {\n      \"subproblem\": \"Path Enumeration\",\n      \"description\": \"Enumerate all possible paths from the top-left to the bottom-right of the matrix, moving only right or down.\"\n    },\n    {\n      \"subproblem\": \"Path Cost Calculation\",\n      \"description\": \"Calculate the total cost for each enumerated path.\"\n    },\n    {\n      \"subproblem\": \"Average Cost Calculation\",\n      \"description\": \"Compute the average cost for each path by dividing the total cost by the number of cells visited.\"\n    },\n    {\n      \"subproblem\": \"Maximum Average Determination\",\n      \"description\": \"Identify the path with the maximum average cost among all paths.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Input Validation\",\n      \"description\": \"Check if the input matrix is a valid square matrix of size N*N.\"\n    },\n    {\n      \"step\": \"Path Enumeration\",\n      \"description\": \"Generate all possible paths from the top-left to the bottom-right corner of the matrix, adhering to the movement constraints (right or down).\"\n    },\n    {\n      \"step\": \"Cost Calculation\",\n      \"description\": \"For each path, calculate the total cost and the average cost.\"\n    },\n    {\n      \"step\": \"Determine Maximum Average\",\n      \"description\": \"Compare the average costs of all paths and select the path with the highest average cost.\"\n    },\n    {\n      \"step\": \"Return Result\",\n      \"description\": \"Output the maximum average cost found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'square matrix': A matrix where the number of rows is equal to the number of columns.\n    'path with maximum average': The path that has the highest average cost among all possible paths from the top-left to the bottom-right cell.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest value or cost.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they are dependent on each other. Each step contributes to the overall goal of finding the path with the maximum average cost.\n\n# [edge case] \n    maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n    Explanation: In this case, the matrix is 3x3, and the path with the maximum average cost is [1, 6, 5, 4, 9] with a total cost of 25 and 5 cells visited, resulting in an average of 5.0.\n\n    Edge Cases:\n    1. maxAverageOfPath([[1]], 1) == 1.0\n    Explanation: In a 1x1 matrix, the only path is the single cell itself, so the average cost is the value of that cell.\n    \n    2. maxAverageOfPath([[1, 2], [3, 4]], 2) == 2.5\n    Explanation: In a 2x2 matrix, the path [1, 2, 4] has the maximum average cost of 2.5.\n\n    3. maxAverageOfPath([[5, 2, 1], [3, 4, 7], [6, 8, 9]], 3) == 6.0\n    Explanation: In a 3x3 matrix, the path [5, 3, 6, 8, 9] has the maximum average cost of 6.0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge cases)", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Input Validation\n    if not matrix or len(matrix) != N or any(len(row) != N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N.\")\n\n    # Helper function to calculate the maximum average path\n    def calculate_max_average_path(matrix, N):\n        # Initialize a 2D list to store the maximum sum up to each cell\n        max_sum = [[0] * N for _ in range(N)]\n        max_sum[0][0] = matrix[0][0]\n\n        # Fill the first row\n        for j in range(1, N):\n            max_sum[0][j] = max_sum[0][j - 1] + matrix[0][j]\n\n        # Fill the first column\n        for i in range(1, N):\n            max_sum[i][0] = max_sum[i - 1][0] + matrix[i][0]\n\n        # Fill the rest of the max_sum matrix\n        for i in range(1, N):\n            for j in range(1, N):\n                max_sum[i][j] = max(max_sum[i - 1][j], max_sum[i][j - 1]) + matrix[i][j]\n\n        # Calculate the maximum average\n        total_cells = 2 * N - 1\n        max_average = max_sum[N - 1][N - 1] / total_cells\n        return max_average\n\n    # Calculate and return the maximum average path\n    return calculate_max_average_path(matrix, N)\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Validate the input matrix\",\n      \"description\": \"Ensure the matrix is a square matrix of size N*N and contains valid numerical values.\"\n    },\n    {\n      \"subproblem\": \"Generate all possible paths\",\n      \"description\": \"Create a method to generate all paths from the top-left to the bottom-right of the matrix, moving only right or down.\"\n    },\n    {\n      \"subproblem\": \"Calculate the average cost for each path\",\n      \"description\": \"For each path, compute the total cost and divide by the number of cells visited to find the average cost.\"\n    },\n    {\n      \"subproblem\": \"Determine the path with the maximum average cost\",\n      \"description\": \"Compare the average costs of all paths and identify the path with the highest average.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Input validation\",\n      \"description\": \"Check if the input matrix is valid and meets the requirements of being a square matrix with numerical values.\"\n    },\n    {\n      \"step\": \"Path generation\",\n      \"description\": \"Implement a recursive or iterative approach to generate all possible paths from the top-left to the bottom-right of the matrix.\"\n    },\n    {\n      \"step\": \"Average cost calculation\",\n      \"description\": \"For each generated path, calculate the average cost by summing the costs of the cells and dividing by the number of cells in the path.\"\n    },\n    {\n      \"step\": \"Find maximum average path\",\n      \"description\": \"Iterate through the calculated averages and identify the path with the maximum average cost.\"\n    },\n    {\n      \"step\": \"Return result\",\n      \"description\": \"Output the maximum average cost found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'square matrix': A matrix where the number of rows is equal to the number of columns.\n    'path with maximum average': The path that has the highest average cost among all possible paths from the top-left to the bottom-right of the matrix.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest value among a set of values.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they are distinct tasks that build upon each other.\n\n# [edge case] \n    maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n    Explanation: In this case, the matrix is already a square matrix of size 3*3. The maximum average path is calculated by finding the path with the highest average cost among all possible paths moving only right or down. The expected output is 5.2.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\n# NO", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Validate the input matrix\n    if not matrix or len(matrix) != N or any(len(row) != N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N with numerical values.\")\n\n    # Helper function to calculate the maximum average path using dynamic programming\n    def calculate_max_average(matrix, N):\n        # Create a 2D array to store the maximum sum up to each cell\n        dp = [[0] * N for _ in range(N)]\n        dp[0][0] = matrix[0][0]\n\n        # Fill the first row\n        for j in range(1, N):\n            dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n        # Fill the first column\n        for i in range(1, N):\n            dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n        # Fill the rest of the dp array\n        for i in range(1, N):\n            for j in range(1, N):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n        # Calculate the maximum average\n        total_cells = 2 * N - 1\n        max_average = dp[N - 1][N - 1] / total_cells\n        return max_average\n\n    # Calculate and return the maximum average path\n    return calculate_max_average(matrix, N)\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to ensure it is a valid square matrix of size N*N.\",\n      \"steps\": [\n        \"Check if the input is a list of lists.\",\n        \"Verify that each sublist has the same length N.\",\n        \"Ensure that the number of sublists is also N.\"\n      ]\n    },\n    {\n      \"description\": \"Implement a function to calculate the total cost and number of cells for a given path.\",\n      \"steps\": [\n        \"Define a function that takes a path as input.\",\n        \"Calculate the sum of the costs of the cells in the path.\",\n        \"Count the number of cells in the path.\"\n      ]\n    },\n    {\n      \"description\": \"Develop a method to explore all possible paths from the top-left to the bottom-right of the matrix.\",\n      \"steps\": [\n        \"Use a recursive approach or dynamic programming to explore paths.\",\n        \"Ensure that the path only moves right or down.\",\n        \"Store the paths and their corresponding total costs and cell counts.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the average cost for each path and determine the maximum average.\",\n      \"steps\": [\n        \"For each path, divide the total cost by the number of cells.\",\n        \"Keep track of the maximum average encountered.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Validate the input to ensure it is a proper N*N matrix.\",\n    \"Implement a function to calculate the total cost and number of cells for a path.\",\n    \"Explore all possible paths from the top-left to the bottom-right of the matrix using recursion or dynamic programming.\",\n    \"For each path, calculate the average cost and update the maximum average if the current path's average is higher.\",\n    \"Return the maximum average as the result.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'square matrix': A matrix where the number of rows is equal to the number of columns.\n    'path': A sequence of cells that starts from the top-left cell, moves only right or down, and ends at the bottom-right cell.\n    'maximum average': The highest average cost among all possible paths.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest value among a set of values.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they represent different subproblems that need to be addressed individually.\n\n# [edge case] \n    maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n    Explanation: In this case, the matrix is a 3x3 square matrix. The maximum average path is calculated to be 5.2 by considering all possible paths from the top-left to the bottom-right cell.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a proper N*N matrix\n    if not isinstance(matrix, list) or len(matrix) != N:\n        raise ValueError(\"Input must be a list of lists with size N*N.\")\n    for row in matrix:\n        if not isinstance(row, list) or len(row) != N:\n            raise ValueError(\"Each row must be a list with length N.\")\n\n    # Use dynamic programming to explore paths\n    dp = [[(0, 0) for _ in range(N)] for _ in range(N)]  # (total_cost, cell_count)\n\n    # Initialize the starting point\n    dp[0][0] = (matrix[0][0], 1)\n\n    # Fill the dp table\n    for i in range(N):\n        for j in range(N):\n            if i == 0 and j == 0:\n                continue\n            if i > 0:\n                total_cost, cell_count = dp[i-1][j]\n                dp[i][j] = max(dp[i][j], (total_cost + matrix[i][j], cell_count + 1))\n            if j > 0:\n                total_cost, cell_count = dp[i][j-1]\n                dp[i][j] = max(dp[i][j], (total_cost + matrix[i][j], cell_count + 1))\n\n    # Calculate the maximum average\n    total_cost, cell_count = dp[N-1][N-1]\n    max_average = total_cost / cell_count\n\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to ensure it is a valid square matrix of size N*N.\",\n      \"steps\": [\n        \"Check if the input is a list of lists.\",\n        \"Verify that each sublist has the same length N.\",\n        \"Ensure that the number of sublists is also N.\"\n      ]\n    },\n    {\n      \"description\": \"Implement a function to calculate the total cost and number of cells for a given path.\",\n      \"steps\": [\n        \"Define a function that takes a path as input.\",\n        \"Calculate the sum of the costs of the cells in the path.\",\n        \"Count the number of cells in the path.\"\n      ]\n    },\n    {\n      \"description\": \"Develop a method to explore all possible paths from the top-left to the bottom-right of the matrix.\",\n      \"steps\": [\n        \"Use a recursive approach or dynamic programming to explore paths.\",\n        \"Ensure that the path only moves right or down.\",\n        \"Store the paths and their corresponding total costs and cell counts.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the average cost for each path and determine the maximum average.\",\n      \"steps\": [\n        \"For each path, divide the total cost by the number of cells.\",\n        \"Keep track of the maximum average encountered.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Validate the input to ensure it is a proper N*N matrix.\",\n    \"Implement a function to calculate the total cost and number of cells for a path.\",\n    \"Explore all possible paths from the top-left to the bottom-right of the matrix using recursion or dynamic programming.\",\n    \"For each path, calculate the average cost and update the maximum average if the current path's average is higher.\",\n    \"Return the maximum average as the result.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'square matrix': A matrix where the number of rows is equal to the number of columns.\n    'path with maximum average': The path that has the highest average cost per cell among all possible paths from the top-left to the bottom-right cell.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest value or average in this context.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they represent different subproblems that build upon each other.\n\n# [edge case] \n    maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n    Explanation: In this case, the matrix is already a square matrix of size 3*3. The maximum average path is [1, 6, 5, 4, 9] with a total cost of 25 and 5 cells visited, resulting in an average of 25/5 = 5.0.\n\n    Edge Cases:\n    maxAverageOfPath([[1]], 1) == 1.0\n    Explanation: When the matrix is a single cell, the maximum average path is the cell itself with an average of 1.0.\n\n    maxAverageOfPath([[1, 2], [3, 4]], 2) == 2.5\n    Explanation: In this case, there are only two possible paths: [1, 2, 4] and [1, 3, 4]. The path [1, 2, 4] has a higher average of 2.5.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if N == 1:\n            return matrix[0][0]\n        elif N == 2:\n            return sum([matrix[i][j] for i in range(N) for j in range(N)]) / N\n        (other code)\n\n# NO", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a proper N*N matrix\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        raise ValueError(\"Input must be a list of lists.\")\n    if not all(len(row) == N for row in matrix) or len(matrix) != N:\n        raise ValueError(\"Input must be a square matrix of size N*N.\")\n\n    # Handle edge cases\n    if N == 1:\n        return float(matrix[0][0])\n    elif N == 2:\n        return sum([matrix[i][j] for i in range(N) for j in range(N)]) / (N + 1)\n\n    # Use dynamic programming to explore paths\n    dp = [[0] * N for _ in range(N)]\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row and first column\n    for i in range(1, N):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    for j in range(1, N):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n\n    # Fill the rest of the dp table\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    # Calculate the maximum average\n    max_average = dp[N-1][N-1] / (2 * N - 1)\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to ensure it is a valid square matrix of size N*N.\",\n      \"steps\": [\n        \"Check if the input is a list of lists.\",\n        \"Verify that each sublist has the same length as the number of sublists (N).\"\n      ]\n    },\n    {\n      \"description\": \"Implement a function to calculate the total cost and number of cells for a given path.\",\n      \"steps\": [\n        \"Define a function that takes a path as input.\",\n        \"Calculate the sum of the costs of the cells in the path.\",\n        \"Count the number of cells in the path.\"\n      ]\n    },\n    {\n      \"description\": \"Develop a method to explore all possible paths from the top-left to the bottom-right of the matrix.\",\n      \"steps\": [\n        \"Use a recursive approach or dynamic programming to explore paths.\",\n        \"Ensure that paths only move right or down at each step.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the average cost for each path and determine the maximum average.\",\n      \"steps\": [\n        \"For each path, use the function from subproblem 2 to calculate the total cost and number of cells.\",\n        \"Compute the average cost for each path.\",\n        \"Track the maximum average encountered.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Validate the input matrix to ensure it is a square matrix of size N*N.\",\n    \"Implement a function to calculate the total cost and number of cells for a given path.\",\n    \"Develop a method to explore all possible paths from the top-left to the bottom-right of the matrix.\",\n    \"For each path, calculate the average cost and track the maximum average.\",\n    \"Return the maximum average as the result.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'square matrix': A matrix where the number of rows is equal to the number of columns.\n    'path': A sequence of cells that starts from the top-left cell and ends at the bottom-right cell by moving only right or down.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest value among all existing paths.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they build upon each other to find the maximum average path.\n\n# [edge case] \n    maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) = 5.2\n    Explanation: In the given matrix, the path with the maximum average is [1, 6, 7, 3, 9] with a total cost of 26 and 5 cells visited, resulting in an average of 5.2.\n\n    Edge Cases:\n    1. maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: In a 1x1 matrix, the only path is the single cell itself with a cost of 1 and 1 cell visited, resulting in an average of 1.0.\n\n    2. maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: In a 2x2 matrix, the path [1, 2, 4] has a total cost of 7 and 3 cells visited, resulting in an average of 2.33. The path [1, 3, 4] has a total cost of 8 and 3 cells visited, resulting in an average of 2.67. The maximum average is 2.67.\n\n    3. maxAverageOfPath([[5, 2, 1], [10, 3, 4], [7, 8, 9]], 3) = 6.0\n    Explanation: In the given matrix, the path with the maximum average is [5, 10, 7, 8, 9] with a total cost of 39 and 5 cells visited, resulting in an average of 7.8.\n\n# [extra code for edge case]\n    We need extra code to handle the edge", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Validate the input matrix to ensure it is a square matrix of size N*N\n    if not isinstance(matrix, list) or len(matrix) != N:\n        raise ValueError(\"Input must be a square matrix of size N*N\")\n    for row in matrix:\n        if not isinstance(row, list) or len(row) != N:\n            raise ValueError(\"Input must be a square matrix of size N*N\")\n\n    # Helper function to calculate the total cost and number of cells for a given path\n    def calculate_path_cost_and_cells(path):\n        total_cost = sum(matrix[x][y] for x, y in path)\n        num_cells = len(path)\n        return total_cost, num_cells\n\n    # Use dynamic programming to explore all possible paths\n    dp = [[(0, 0)] * N for _ in range(N)]  # (total_cost, num_cells)\n\n    # Initialize the starting point\n    dp[0][0] = (matrix[0][0], 1)\n\n    # Fill the dp table\n    for i in range(N):\n        for j in range(N):\n            if i == 0 and j == 0:\n                continue\n            if i > 0:\n                cost_from_top, cells_from_top = dp[i-1][j]\n                dp[i][j] = max(dp[i][j], (cost_from_top + matrix[i][j], cells_from_top + 1))\n            if j > 0:\n                cost_from_left, cells_from_left = dp[i][j-1]\n                dp[i][j] = max(dp[i][j], (cost_from_left + matrix[i][j], cells_from_left + 1))\n\n    # Calculate the maximum average\n    total_cost, num_cells = dp[N-1][N-1]\n    max_average = total_cost / num_cells\n\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to ensure it is a valid square matrix of size N*N.\",\n      \"details\": \"Check that the input is a list of lists, each containing N integers, and that there are N such lists.\"\n    },\n    {\n      \"description\": \"Implement a function to calculate the total cost of a path.\",\n      \"details\": \"Define a path as a sequence of moves starting from the top-left cell to the bottom-right cell, moving only right or down.\"\n    },\n    {\n      \"description\": \"Implement a function to calculate the average cost of a path.\",\n      \"details\": \"Use the total cost of the path divided by the number of cells in the path.\"\n    },\n    {\n      \"description\": \"Develop an algorithm to explore all possible paths from the top-left to the bottom-right cell.\",\n      \"details\": \"Use a recursive or iterative approach to explore paths, ensuring that only right and down moves are considered.\"\n    },\n    {\n      \"description\": \"Determine the path with the maximum average cost.\",\n      \"details\": \"Compare the average costs of all paths and keep track of the maximum average found.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Validate the input to ensure it is a square matrix of size N*N.\",\n    \"Initialize variables to track the maximum average cost and the corresponding path.\",\n    \"Implement a recursive or iterative function to explore all paths from the top-left to the bottom-right cell.\",\n    \"For each path, calculate the total cost and the average cost.\",\n    \"Compare the average cost of the current path with the maximum average cost found so far.\",\n    \"Update the maximum average cost if the current path's average is higher.\",\n    \"Return the maximum average cost after exploring all possible paths.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'square matrix': A matrix where the number of rows is equal to the number of columns.\n    'path': A sequence of cells that starts from the top-left cell, moves only right or down, and ends at the bottom-right cell.\n    'maximum average': The highest average cost among all possible paths.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest value among a set of values.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they build upon each other. There are no steps that need to be implemented simultaneously.\n\n# [edge case] \n    maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n    Explanation: In this case, the matrix is already a square matrix of size 3*3. The maximum average path is calculated by exploring all possible paths and finding the one with the highest average cost.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a square matrix of size N*N\n    if not matrix or len(matrix) != N or any(len(row) != N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N\")\n\n    # Initialize a memoization table to store the maximum sum up to each cell\n    memo = [[None] * N for _ in range(N)]\n    \n    def maxPathSum(x, y):\n        # Base case: if we are at the top-left cell, return its value\n        if x == 0 and y == 0:\n            return matrix[0][0]\n        \n        # If the value is already computed, return it\n        if memo[x][y] is not None:\n            return memo[x][y]\n        \n        # Calculate the maximum path sum to the current cell\n        max_sum = float('-inf')\n        if x > 0:\n            max_sum = max(max_sum, maxPathSum(x - 1, y))\n        if y > 0:\n            max_sum = max(max_sum, maxPathSum(x, y - 1))\n        \n        # Add the current cell's value to the maximum path sum\n        memo[x][y] = max_sum + matrix[x][y]\n        return memo[x][y]\n    \n    # Calculate the maximum path sum to the bottom-right cell\n    max_sum = maxPathSum(N - 1, N - 1)\n    \n    # Calculate the number of cells in the path\n    num_cells = 2 * N - 1\n    \n    # Calculate the maximum average cost\n    max_average = max_sum / num_cells\n    \n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Validate the input to ensure it is a square matrix of size N*N and contains valid numerical values.\",\n      \"output\": \"A boolean indicating whether the input is valid or not.\"\n    },\n    {\n      \"description\": \"Implement a function to calculate the total cost of a path from the top-left to the bottom-right of the matrix, moving only right or down.\",\n      \"output\": \"A list of all possible paths with their respective total costs.\"\n    },\n    {\n      \"description\": \"Calculate the average cost of each path by dividing the total cost by the number of cells in the path.\",\n      \"output\": \"A list of average costs for each path.\"\n    },\n    {\n      \"description\": \"Determine the maximum average cost from the list of average costs.\",\n      \"output\": \"The maximum average cost.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Step 1: Validate the input matrix to ensure it is a square matrix and contains valid numerical values.\",\n    \"Step 2: Develop a function to explore all possible paths from the top-left to the bottom-right of the matrix, moving only right or down, and calculate the total cost for each path.\",\n    \"Step 3: For each path, calculate the average cost by dividing the total cost by the number of cells in the path.\",\n    \"Step 4: Compare all the average costs and identify the maximum average cost.\",\n    \"Step 5: Return the maximum average cost as the result.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'square matrix': A matrix where the number of rows is equal to the number of columns.\n    'path': A sequence of cells that starts from the top-left cell, moves only right or down, and ends at the bottom-right cell.\n    'maximum average': The highest average value calculated from all possible paths.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest value among a set of values.\n\n# [code logic]\n    All steps should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n    Explanation: In the given square matrix, the path with the maximum average cost is [1, 6, 7, 3, 9] with a total cost of 26 and 5 cells visited, resulting in an average of 26/5 = 5.2.\n\n    Edge Cases:\n    1. maxAverageOfPath([[1]], 1) == 1.0\n    Explanation: In a 1x1 matrix, the only path is the single cell itself, so the average cost is the value of that cell.\n    \n    2. maxAverageOfPath([[1, 2], [3, 4]], 2) == 2.5\n    Explanation: In a 2x2 matrix, the path [1, 2, 4] has the maximum average cost of (1+2+4)/3 = 2.5.\n    \n    3. maxAverageOfPath([[5, 2, 1], [3, 4, 7], [8, 9, 6]], 3) == 6.0\n    Explanation: In the given matrix, the path [5, 3, 8, 9, 6] has the maximum average cost of (5+3+8+9+6)/5 = 6.0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge cases)\n\n# NO", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Step 1: Validate the input matrix\n    def is_valid_matrix(matrix, N):\n        if not matrix or len(matrix) != N:\n            return False\n        for row in matrix:\n            if len(row) != N or not all(isinstance(x, (int, float)) for x in row):\n                return False\n        return True\n\n    if not is_valid_matrix(matrix, N):\n        raise ValueError(\"Invalid matrix input\")\n\n    # Step 2: Develop a function to explore all possible paths and calculate total costs\n    def calculate_paths(matrix, N):\n        from functools import lru_cache\n\n        @lru_cache(None)\n        def dfs(x, y):\n            if x == N - 1 and y == N - 1:\n                return [(matrix[x][y], [(x, y)])]\n            \n            paths = []\n            if x + 1 < N:\n                for cost, path in dfs(x + 1, y):\n                    paths.append((cost + matrix[x][y], [(x, y)] + path))\n            if y + 1 < N:\n                for cost, path in dfs(x, y + 1):\n                    paths.append((cost + matrix[x][y], [(x, y)] + path))\n            return paths\n\n        return dfs(0, 0)\n\n    # Step 3: Calculate the average cost for each path\n    def calculate_averages(paths):\n        averages = []\n        for total_cost, path in paths:\n            averages.append(total_cost / len(path))\n        return averages\n\n    # Step 4: Determine the maximum average cost\n    paths = calculate_paths(matrix, N)\n    averages = calculate_averages(paths)\n    max_average = max(averages)\n\n    # Step 5: Return the maximum average cost\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "test": ["def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 4], [7, 6, 5], [8, 4, 10]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 5], [8, 7, 6], [9, 5, 11]], 3) == 7.2 ", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 3, 1], [1, 4, 5], [2, 6, 6]], 3) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 3], [11, 3, 7], [3, 1, 10]], 3) == 7.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 2], [4, 8, 3], [2, 6, 9]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 6], [5, 6, 4], [9, 4, 14]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 2, 2], [9, 5, 3], [9, 3, 11]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [10, 10, 1], [5, 3, 4]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 6], [1, 3, 9], [4, 6, 14]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 8], [9, 9, 2], [12, 8, 14]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 4], [7, 9, 8], [8, 7, 11]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 4], [7, 3, 5], [2, 7, 4]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 5, 1], [7, 9, 7], [7, 3, 9]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 4, 4], [6, 2, 7], [9, 4, 6]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 8], [7, 3, 5], [3, 1, 4]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 1, 6], [2, 4, 7], [9, 6, 12]], 3) == 6.8", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 6], [6, 3, 1], [9, 8, 8]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [11, 4, 8], [12, 3, 13]], 3) == 8.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 6], [3, 9, 2], [9, 5, 10]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 5], [11, 4, 4], [5, 2, 11]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 7, 3], [10, 10, 7], [3, 1, 5]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 7, 5], [9, 1, 4], [6, 1, 5]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 6], [10, 4, 9], [8, 2, 11]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 4], [3, 3, 9], [4, 3, 5]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 3, 8], [9, 9, 7], [4, 1, 8]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 5], [3, 5, 4], [10, 1, 6]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 7], [3, 8, 9], [12, 6, 9]], 3) == 6.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 2], [6, 5, 8], [11, 1, 12]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 5, 2], [6, 1, 2], [2, 3, 7]], 2) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 1], [3, 1, 8], [11, 1, 6]], 3) == 4.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 6], [2, 5, 2], [3, 3, 7]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 5], [9, 8, 6], [12, 5, 4]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 3, 6], [7, 6, 8], [7, 4, 8]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 3, 1], [9, 6, 3], [6, 8, 13]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 6, 7], [5, 8, 5], [5, 6, 12]], 2) == 6.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 4, 7], [11, 8, 10], [7, 2, 15]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 3, 7], [4, 8, 2], [8, 5, 9]], 2) == 5.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 9], [3, 1, 6], [5, 8, 12]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 1, 3], [9, 10, 6], [12, 3, 14]], 3) == 8.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 5], [9, 9, 10], [3, 2, 13]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 7, 9], [9, 1, 4], [12, 2, 15]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 3, 8], [3, 1, 4], [9, 2, 15]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 9], [4, 11, 4], [3, 4, 9]], 2) == 7.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 7, 1], [2, 1, 4], [12, 6, 9]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 1, 5], [5, 4, 7], [11, 3, 13]], 3) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 8, 9], [12, 8, 5], [5, 2, 9]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 1], [5, 5, 7], [13, 8, 14]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 4, 3], [9, 7, 8], [11, 6, 6]], 3) == 7.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 4, 7], [11, 1, 1], [5, 9, 12]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 1, 9], [2, 8, 10], [5, 9, 6]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 6], [12, 2, 5], [4, 6, 11]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 9], [4, 6, 3], [10, 1, 13]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 2], [6, 1, 1], [10, 4, 8]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 4], [10, 6, 6], [13, 3, 12]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 8, 1], [2, 2, 6], [3, 8, 5]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 6, 7], [9, 1, 6], [13, 1, 5]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 4], [7, 4, 9], [6, 6, 10]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 7, 8], [9, 7, 2], [11, 3, 6]], 1) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 4], [2, 1, 8], [12, 7, 12]], 2) == 3.3333333333333335", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 2, 3], [12, 6, 3], [13, 1, 11]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 5], [2, 3, 4], [5, 6, 12]], 2) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 7], [4, 8, 2], [5, 2, 12]], 3) == 6.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 6, 5], [7, 7, 2], [11, 4, 13]], 3) == 7.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 6, 1], [10, 1, 3], [3, 8, 12]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [12, 4, 6], [13, 2, 14]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 6, 7], [3, 7, 9], [9, 8, 7]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 1, 1], [4, 7, 3], [6, 7, 9]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 3], [6, 4, 4], [7, 3, 14]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 9], [12, 2, 9], [4, 7, 7]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 7, 2], [5, 4, 7], [9, 5, 10]], 2) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 9, 1], [13, 5, 2], [4, 5, 11]], 2) == 6.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 2, 1], [11, 12, 9], [4, 9, 14]], 2) == 9.666666666666666", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 7, 10], [3, 9, 4], [11, 1, 7]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 9, 5], [6, 7, 3], [6, 7, 10]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 8, 3], [11, 10, 3], [11, 1, 12]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 8, 9], [5, 11, 7], [9, 4, 10]], 2) == 8.333333333333334", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 6, 8], [10, 7, 4], [10, 8, 14]], 2) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 3, 3], [8, 4, 8], [12, 1, 14]], 1) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 10], [8, 12, 2], [14, 4, 9]], 3) == 8.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 4], [12, 7, 1], [12, 7, 11]], 3) == 9.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 5, 10], [10, 10, 4], [11, 6, 8]], 1) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 8, 8], [10, 7, 5], [6, 1, 9]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 7, 4], [8, 7, 3], [11, 2, 8]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 6], [4, 2, 8], [6, 6, 10]], 2) == 2.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 5], [3, 2, 5], [4, 3, 15]], 2) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 8, 4], [9, 5, 11], [11, 8, 14]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 9, 2], [13, 3, 2], [9, 10, 6]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 7, 10], [8, 10, 11], [4, 3, 8]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 8], [12, 11, 4], [14, 6, 16]], 3) == 10.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 4], [12, 3, 9], [9, 7, 14]], 3) == 9.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 7, 4], [4, 4, 7], [12, 5, 11]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 8, 4], [11, 10, 8], [11, 1, 13]], 2) == 7.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 9, 9], [5, 6, 11], [14, 8, 16]], 3) == 9.8", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 10], [11, 5, 9], [11, 5, 6]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 1, 4], [6, 11, 7], [5, 8, 7]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 6, 1], [11, 11, 3], [10, 3, 8]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 8, 5], [9, 10, 3], [12, 5, 6]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 4, 5], [4, 7, 9], [4, 2, 6]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 7, 8], [9, 11, 1], [4, 7, 8]], 2) == 9.333333333333334", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 7, 8], [6, 2, 9], [8, 8, 9]], 3) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 5, 2], [13, 8, 8], [12, 2, 7]], 3) == 8.4"], "scores": [0.3333, 0.3333, 0.3333, 0.3333, 0.3333, 0.3333, 0.3333, 0.3333, 0.3333, 0.3333], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [34, 34, 34, 34, 34, 34, 34, 34, 34, 34], "passed": false, "pass": false, "pass_num": 3, "round": 210, "repair_prompt": ["Given a square matrix of size N*N provided as a list of lists, where each cell is associated with a specific cost. A path is defined as a particular sequence of cells that begins from the top-left cell, moves only right or down, and concludes on the bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nexample:\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n", "Given a square matrix of size N*N provided as a list of lists. Each cell in the matrix is associated with a specific cost. A path is defined as a particular sequence of cells that begins from the top-left cell, moves only right or down, and concludes on the bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nexample:\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n", "Given a square matrix of size N*N provided as a list of lists, where each cell is associated with a specific cost. A path is defined as a particular sequence of cells that begins from the top-left cell and concludes on the bottom right cell by only moving right or down. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nexample:\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n"], "mutate_method": "rephrase_one", "save_node": true, "parent_index": 210}
