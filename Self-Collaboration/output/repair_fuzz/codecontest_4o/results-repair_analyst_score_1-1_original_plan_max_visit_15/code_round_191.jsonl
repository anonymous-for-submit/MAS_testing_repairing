{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "repair_prompt": ["Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements, which is the sum of elements divided by the number of these elements (i.e. sum divided by n), and Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the constraints are efficiently handled to optimize the solution.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements, which is the sum of elements divided by the number of these elements (i.e. sum divided by n). The value of k is calculated by summing all elements in the array and then dividing the sum by the total number of elements in the array. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the constraints are efficiently handled to optimize the solution.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp has got an array a consisting of n integers. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k, which is the sum of elements divided by the number of these elements (i.e. sum divided by n). Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the constraints are efficiently handled to optimize the solution.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        target_sum = total_sum - 2 * k\n        count = 0\n        freq = {}\n        \n        for num in a:\n            if target_sum - num in freq:\n                count += freq[target_sum - num]\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "completions": ["def find_valid_pairs(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        total_sum = sum(a)\n        mean_k = total_sum / n\n\n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) = mean_k\n        # Simplifying, we get: a[i] + a[j] = 2 * mean_k\n\n        target_sum = 2 * mean_k\n        count = 0\n        freq = {}\n\n        for num in a:\n            complement = target_sum - num\n            if complement in freq:\n                count += freq[complement]\n            \n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n\n        results.append(count)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def count_valid_pairs(n, a):\n    total_sum = sum(a)\n    required_sum = total_sum * (n - 2) / n\n    count = 0\n    freq = {}\n\n    for num in a:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if total_sum - a[i] - a[j] == required_sum:\n                count += 1\n\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = count_valid_pairs(n, a)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        target_sum = total_sum * 2 / n\n        count = 0\n        freq = {}\n\n        for num in a:\n            complement = target_sum - num\n            if complement in freq:\n                count += freq[complement]\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n\n        results.append(count)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Calculate the number of valid pairs\n        count = 0\n        target_sum = k * (n - 2)\n        \n        # Use a dictionary to count occurrences of elements\n        from collections import defaultdict\n        freq = defaultdict(int)\n        \n        for num in a:\n            freq[num] += 1\n        \n        for i in range(n):\n            freq[a[i]] -= 1\n            for j in range(i + 1, n):\n                freq[a[j]] -= 1\n                \n                # Check if the remaining sum equals target_sum\n                remaining_sum = total_sum - a[i] - a[j]\n                if remaining_sum == target_sum:\n                    count += 1\n                \n                freq[a[j]] += 1\n            freq[a[i]] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def count_valid_pairs(n, a):\n    total_sum = sum(a)\n    mean = total_sum / n\n    count = 0\n    element_count = {}\n\n    # Count occurrences of each element\n    for num in a:\n        element_count[num] = element_count.get(num, 0) + 1\n\n    # Iterate over each element to find valid pairs\n    for i in range(n):\n        # Decrease the count of the current element\n        element_count[a[i]] -= 1\n        for j in range(i + 1, n):\n            # Decrease the count of the second element\n            element_count[a[j]] -= 1\n\n            # Calculate the sum of the remaining elements\n            remaining_sum = total_sum - a[i] - a[j]\n            # Calculate the mean of the remaining elements\n            remaining_mean = remaining_sum / (n - 2)\n\n            # Check if the mean of the remaining elements is equal to the original mean\n            if remaining_mean == mean:\n                count += 1\n\n            # Restore the count of the second element\n            element_count[a[j]] += 1\n\n        # Restore the count of the current element\n        element_count[a[i]] += 1\n\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_valid_pairs(n, a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        # If all elements are the same, any pair can be removed\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean_k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean_k * (n - 2)\n        # a[i] + a[j] == total_sum - mean_k * (n - 2)\n        \n        target_sum = total_sum - mean_k * (n - 2)\n        \n        # Use a hashmap to count occurrences\n        from collections import defaultdict\n        count = defaultdict(int)\n        valid_pairs = 0\n        \n        for num in a:\n            # Check if there is a complement that forms the target_sum\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            \n            # Increment the count of the current number\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\n# Call the solve function to execute the solution\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            # If all elements are the same, any pair can be removed\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == k * (n - 2)\n        # a[i] + a[j] == total_sum - k * (n - 2)\n        \n        target_sum = total_sum - k * (n - 2)\n        \n        # Use a dictionary to count occurrences of elements\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        # Count the number of valid pairs\n        valid_pairs = 0\n        \n        for num in a:\n            # Check if there is a complement that forms the target_sum\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            \n            # Increment the count of the current number\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n        \n        # Use a hashmap to count occurrences of each element\n        count_map = {}\n        for num in a:\n            if num in count_map:\n                count_map[num] += 1\n            else:\n                count_map[num] = 1\n        \n        pair_count = 0\n        \n        # Iterate over each element and find pairs\n        for i in range(n):\n            count_map[a[i]] -= 1\n            for j in range(i + 1, n):\n                count_map[a[j]] -= 1\n                \n                # Check if the sum of the remaining elements equals target_sum\n                if total_sum - a[i] - a[j] == target_sum:\n                    pair_count += 1\n                \n                count_map[a[j]] += 1\n            count_map[a[i]] += 1\n        \n        results.append(pair_count)\n    \n    return results\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\ntest_cases = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    test_cases.append((n, a))\n\nresults = find_valid_pairs(t, test_cases)\n\nfor result in results:\n    print(result)\n\nmain()", "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            results.append(comb(n, 2))\n            continue\n        \n        # Calculate the number of valid pairs\n        count = 0\n        pair_sum_needed = 2 * mean_k * (n - 2)\n        pair_sum_needed -= total_sum\n        \n        # Use a dictionary to count occurrences\n        count_map = defaultdict(int)\n        \n        for num in a:\n            count_map[num] += 1\n        \n        for num in a:\n            count_map[num] -= 1\n            complement = pair_sum_needed - num\n            if complement in count_map:\n                count += count_map[complement]\n        \n        results.append(count // 2)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        target_sum = total_sum - 2 * k\n        count = 0\n        freq = {}\n        \n        for num in a:\n            if target_sum - num in freq:\n                count += freq[target_sum - num]\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"details\": \"Compute the sum of the array and divide it by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Efficiently count valid pairs.\",\n      \"details\": \"Use mathematical transformations and efficient data structures to count pairs without checking each pair explicitly.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the initial mean k for each test case.\",\n      \"details\": \"Compute the sum of the array and divide by n to get k.\"\n    },\n    {\n      \"step\": \"Iterate over each element to find valid pairs.\",\n      \"details\": \"For each element, calculate the required value that needs to be paired with it to maintain the mean and count such pairs using a hashmap or similar data structure.\"\n    },\n    {\n      \"step\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, print the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean (or average) is the sum of a collection of numbers divided by the count of numbers in the collection. In this requirement, it refers to the mean of the array before and after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'n - 2': This indicates the number of elements remaining after removing two elements.\n    'sum divided by n': This is the formula for calculating the mean of the array.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the initial mean k for each test case\" and \"Iterate over each element to find valid pairs\" should be considered simultaneously. \n    Explanation: While iterating over each element, we can simultaneously calculate the required value that needs to be paired with it to maintain the mean using the initial mean k.\n\n# [edge case]\n    1. Input: 3\n       3\n       1 1 1\n       Expected Output: 0\n       Explanation: With only three elements, removing any two will leave one element, which cannot maintain the original mean.\n       \n    2. Input: 4\n       4\n       0 0 0 0\n       Expected Output: 6\n       Explanation: Any pair of elements can be removed since all are zero, maintaining the mean of zero.\n       \n    3. Input: 5\n       5\n       10 10 10 10 10\n       Expected Output: 10\n       Explanation: Any pair of elements can be removed since all are equal, maintaining the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n is very small (e.g., n = 3) or all elements are the same.\n    ```\n    if n == 3:\n        print(0)\n        continue\n    if all(x == a[0] for x in a):\n        print(n * (n - 1) // 2)\n        continue\n    ```\n    \nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        target_sum = total_sum - 2 * k\n        count = 0\n        freq = {}\n        \n        for num in a:\n            if target_sum - num in freq:\n                count += freq[target_sum - num]\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Compute the sum of all elements in the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Efficiently count valid pairs.\",\n      \"details\": \"Use a hashmap or dictionary to store and count occurrences of elements to optimize the search for valid pairs.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the total sum and mean k for each test case\",\n      \"details\": \"For each test case, compute the sum of the array and derive the mean k.\"\n    },\n    {\n      \"step\": \"Iterate over each element to find valid pairs\",\n      \"details\": \"For each element a[i], calculate the required complement that would keep the mean unchanged if a[i] and a[j] are removed. Use a hashmap to track and count these complements efficiently.\"\n    },\n    {\n      \"step\": \"Count and output the number of valid pairs for each test case\",\n      \"details\": \"For each test case, output the total number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean, often referred to as the average, is calculated by dividing the sum of all elements by the number of elements. In this requirement, the mean of the array should remain unchanged even after removing two elements.\n\n# [phrase showing quantity relationship]\n    'sum divided by n': This indicates the calculation of the mean, which is the sum of elements divided by the number of elements.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to find pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the total sum and mean k for each test case\" and \"Iterate over each element to find valid pairs\" should be considered simultaneously. After calculating the mean, we can directly start checking for valid pairs using the hashmap to optimize the process.\n\n# [edge case]\n    Input: 3\n           3\n           1 1 1\n    Output: 3\n    Explanation: All elements are the same, so any pair can be removed without changing the mean.\n    \n    Input: 4\n           4\n           0 0 0 0\n    Output: 6\n    Explanation: All elements are zero, so any pair can be removed without changing the mean.\n    \n    Input: 5\n           5\n           10 10 10 10 10\n    Output: 10\n    Explanation: All elements are the same, so any pair can be removed without changing the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a hashmap to track complements will efficiently handle these scenarios.\n\nNO", "Round_0": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        total_sum = sum(a)\n        mean_k = total_sum / n\n\n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) = mean_k\n        # Simplifying, we get: a[i] + a[j] = 2 * mean_k\n\n        target_sum = 2 * mean_k\n        count = 0\n        freq = {}\n\n        for num in a:\n            complement = target_sum - num\n            if complement in freq:\n                count += freq[complement]\n            \n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n\n        results.append(count)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"steps\": [\n        \"Sum all elements of the array a.\",\n        \"Divide the sum by the number of elements n to get the mean k.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (a[i], a[j]) where i < j, calculate the sum of the remaining elements after removing a[i] and a[j].\",\n        \"Check if the mean of the remaining elements equals the initial mean k.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs to handle constraints efficiently.\",\n      \"steps\": [\n        \"Use a hashmap or dictionary to store and quickly access the frequency of elements or required values.\",\n        \"Iterate through the array to find pairs that satisfy the condition using the hashmap for efficient lookup.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following steps:\",\n    \"  Read the number of elements n and the array a.\",\n    \"  Calculate the initial mean k of the array.\",\n    \"  Initialize a counter to track the number of valid pairs.\",\n    \"  Use a hashmap to store the frequency of elements or required values.\",\n    \"  Iterate through the array to find pairs (i, j) such that removing them keeps the mean unchanged.\",\n    \"  For each valid pair found, increment the counter.\",\n    \"  Output the counter value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean is the average of a set of numbers, calculated by dividing the sum of the numbers by the count of numbers.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: This refers to selecting two distinct positions in the array such that the first position is less than the second.\n\n# [phrase showing quantity relationship]\n    'sum divided by n'\n    Explanation: This is the formula for calculating the mean, where the sum of elements is divided by the number of elements.\n    Implementation: `mean = sum(a) / n`\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the mean and identifying pairs should be considered simultaneously in terms of logic flow, but they are distinct operations. The optimization step using a hashmap should be integrated with the pair identification step to ensure efficient computation.\n\n# [edge case]\n    Case 1: n = 3, a = [1, 1, 1]\n    Expected output: 3\n    Explanation: Any pair of elements can be removed since all are equal, maintaining the mean.\n\n    Case 2: n = 4, a = [0, 0, 0, 0]\n    Expected output: 6\n    Explanation: Any pair of elements can be removed since all are equal, maintaining the mean.\n\n    Case 3: n = 5, a = [1, 2, 3, 4, 5]\n    Expected output: 0\n    Explanation: No pair of elements can be removed to maintain the mean because the elements are distinct and the mean changes.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    Code for handling edge cases:\n    ```python\n    def count_valid_pairs(n, a):\n        total_sum = sum(a)\n        mean = total_sum / n\n        required_sum = mean * (n - 2)\n        count = 0\n        freq = {}\n        \n        for num in a:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if total_sum - a[i] - a[j] == required_sum:\n                    count += 1\n        \n        return count\n    ```\n\nYES", "Round_0": {"code": "def count_valid_pairs(n, a):\n    total_sum = sum(a)\n    required_sum = total_sum * (n - 2) / n\n    count = 0\n    freq = {}\n\n    for num in a:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if total_sum - a[i] - a[j] == required_sum:\n                count += 1\n\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = count_valid_pairs(n, a)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Efficiently count valid pairs.\",\n      \"details\": \"Use mathematical properties and efficient data structures to count pairs without checking each pair explicitly.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the total sum of the array a.\",\n      \"details\": \"Compute the sum of all elements in a to determine the initial mean k.\"\n    },\n    {\n      \"step\": \"Iterate over each element to find valid pairs.\",\n      \"details\": \"For each element a[i], calculate the required complement a[j] such that removing a[i] and a[j] keeps the mean unchanged.\"\n    },\n    {\n      \"step\": \"Use a hashmap or dictionary to track occurrences.\",\n      \"details\": \"Store the frequency of each element in a hashmap to quickly find complements.\"\n    },\n    {\n      \"step\": \"Count valid pairs using the hashmap.\",\n      \"details\": \"For each element, use the hashmap to find how many valid complements exist and count the pairs.\"\n    },\n    {\n      \"step\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, print the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean (or average) of a set of numbers is the sum of the numbers divided by the count of numbers. In this requirement, it refers to the mean of the array elements before and after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that precisely two elements must be removed from the array.\n    'sum divided by n': This refers to the calculation of the mean, where the sum of elements is divided by the number of elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the total sum of the array a\" and \"Calculate the initial mean k of the array a\" should be implemented simultaneously. This can be done by computing the sum and mean in one step after reading the input data.\n\n# [edge case]\n    1. Input: 3\n       3\n       1 1 1\n       Expected Output: 0\n       Explanation: With only three elements, removing any two will leave one element, which cannot maintain the original mean.\n       \n    2. Input: 4\n       4\n       0 0 0 0\n       Expected Output: 6\n       Explanation: All elements are zero, so any pair can be removed without changing the mean.\n       \n    3. Input: 5\n       5\n       10 10 10 10 10\n       Expected Output: 10\n       Explanation: All elements are the same, so any pair can be removed without changing the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating the mean and checking pairs should naturally handle these scenarios.\n\nYES", "Round_0": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        target_sum = total_sum * 2 / n\n        count = 0\n        freq = {}\n\n        for num in a:\n            complement = target_sum - num\n            if complement in freq:\n                count += freq[complement]\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n\n        results.append(count)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"steps\": [\n        \"Sum all elements of the array a.\",\n        \"Divide the sum by the number of elements n to get the mean k.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (a[i], a[j]) where i < j, calculate the sum of the remaining elements after removing a[i] and a[j].\",\n        \"Check if the mean of the remaining elements equals the initial mean k.\"\n      ]\n    },\n    {\n      \"description\": \"Count the number of valid pairs (i, j) for each test case.\",\n      \"steps\": [\n        \"Initialize a counter to zero.\",\n        \"For each valid pair found in the previous step, increment the counter.\",\n        \"Store the counter value for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following:\",\n    \"  Read the integer n and the array a of n integers.\",\n    \"  Calculate the initial mean k of the array a.\",\n    \"  Initialize a counter to zero for counting valid pairs.\",\n    \"  Iterate over all pairs (i, j) with i < j:\",\n    \"    Calculate the sum of the array excluding a[i] and a[j].\",\n    \"    Check if the mean of the remaining elements equals k.\",\n    \"    If it does, increment the counter.\",\n    \"  Store the counter value for the current test case.\",\n    \"Output the stored counter values for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean is the average of the numbers, calculated as the sum of all elements divided by the number of elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: This refers to selecting two distinct positions in the array such that the first position is less than the second.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: This means that only two elements should be removed from the array to check if the mean remains unchanged.\n\n# [degree adverb] \n    'equal'\n    Explanation: The mean of the remaining elements after removing two should be exactly the same as the original mean.\n\n# [code logic]\n    The steps for calculating the initial mean and checking pairs should be implemented in a loop for each test case. The steps for checking pairs and counting valid pairs should be implemented simultaneously within the same loop to ensure efficiency.\n\n# [edge case] \n    1. Input: 3\n       3\n       1 1 1\n       Explanation: All elements are the same, so any pair removal will keep the mean unchanged. Expected output: 3 (all pairs are valid).\n       \n    2. Input: 3\n       3\n       1 2 3\n       Explanation: No pair removal will keep the mean unchanged. Expected output: 0.\n       \n    3. Input: 4\n       4\n       5 5 5 5\n       Explanation: All elements are the same, so any pair removal will keep the mean unchanged. Expected output: 6 (all pairs are valid).\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are the same, as this can be optimized by directly calculating the number of pairs using combinatorial logic.\n    ```python\n    if all(x == a[0] for x in a):\n        return (n * (n - 1)) // 2\n    ```\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Calculate the number of valid pairs\n        count = 0\n        target_sum = k * (n - 2)\n        \n        # Use a dictionary to count occurrences of elements\n        from collections import defaultdict\n        freq = defaultdict(int)\n        \n        for num in a:\n            freq[num] += 1\n        \n        for i in range(n):\n            freq[a[i]] -= 1\n            for j in range(i + 1, n):\n                freq[a[j]] -= 1\n                \n                # Check if the remaining sum equals target_sum\n                remaining_sum = total_sum - a[i] - a[j]\n                if remaining_sum == target_sum:\n                    count += 1\n                \n                freq[a[j]] += 1\n            freq[a[i]] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"details\": \"Compute the sum of the array and divide it by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Efficiently count valid pairs.\",\n      \"details\": \"Use a hashmap or similar data structure to track occurrences of elements and efficiently find pairs that satisfy the condition.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate initial mean\",\n      \"details\": \"For each test case, calculate the sum of the array and derive the mean k.\"\n    },\n    {\n      \"step\": \"Iterate over pairs\",\n      \"details\": \"For each test case, iterate over all pairs of elements (i, j) with i < j.\"\n    },\n    {\n      \"step\": \"Check mean condition\",\n      \"details\": \"For each pair, check if removing these elements results in the same mean for the remaining elements.\"\n    },\n    {\n      \"step\": \"Count valid pairs\",\n      \"details\": \"Use a hashmap to efficiently count and store valid pairs that satisfy the condition.\"\n    },\n    {\n      \"step\": \"Output results\",\n      \"details\": \"For each test case, output the count of valid pairs.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean is the average of a set of numbers, calculated by dividing the sum of the numbers by the count of numbers.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: This refers to selecting two distinct positions in the array such that the first position is less than the second.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: This means that precisely two elements must be removed from the array to check the condition.\n\n    'sum divided by n'\n    Explanation: This is the formula for calculating the mean, where the sum of elements is divided by the number of elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Iterate over pairs\" and \"Check mean condition\" should be implemented simultaneously.\n    Explanation: As you iterate over pairs, you should immediately check if removing them maintains the mean. This can be done within the same loop structure to optimize performance.\n\n# [edge case]\n    Test case with all elements equal: [8, 8, 8, 8] = 6\n    Explanation: Any pair of elements can be removed since all elements are equal, maintaining the mean.\n\n    Test case with no valid pairs: [50, 20, 10] = 0\n    Explanation: No pair of elements can be removed to maintain the mean, as the mean changes with any removal.\n\n    Test case with multiple valid pairs: [1, 4, 7, 3, 5] = 2\n    Explanation: Removing elements at positions 1 and 3 or positions 4 and 5 maintains the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: Efficiently handle cases where all elements are equal or where no valid pairs exist by using a hashmap to track occurrences and quickly identify valid pairs.\n\n    ```python\n    def count_valid_pairs(n, a):\n        mean = sum(a) / n\n        count = 0\n        element_count = {}\n        \n        for num in a:\n            element_count[num] = element_count.get(num, 0) + 1\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if (sum(a) - a[i] - a[j]) / (n - 2) == mean:\n                    count", "Round_0": {"code": "def count_valid_pairs(n, a):\n    total_sum = sum(a)\n    mean = total_sum / n\n    count = 0\n    element_count = {}\n\n    # Count occurrences of each element\n    for num in a:\n        element_count[num] = element_count.get(num, 0) + 1\n\n    # Iterate over each element to find valid pairs\n    for i in range(n):\n        # Decrease the count of the current element\n        element_count[a[i]] -= 1\n        for j in range(i + 1, n):\n            # Decrease the count of the second element\n            element_count[a[j]] -= 1\n\n            # Calculate the sum of the remaining elements\n            remaining_sum = total_sum - a[i] - a[j]\n            # Calculate the mean of the remaining elements\n            remaining_mean = remaining_sum / (n - 2)\n\n            # Check if the mean of the remaining elements is equal to the original mean\n            if remaining_mean == mean:\n                count += 1\n\n            # Restore the count of the second element\n            element_count[a[j]] += 1\n\n        # Restore the count of the current element\n        element_count[a[i]] += 1\n\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_valid_pairs(n, a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"details\": \"Compute the sum of the array and divide it by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if their removal keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Efficiently count valid pairs.\",\n      \"details\": \"Use a hashmap or similar data structure to track occurrences of elements and efficiently find pairs that satisfy the condition.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the mean k for each test case\",\n      \"details\": \"Compute the sum of the array and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Iterate over possible pairs\",\n      \"details\": \"For each pair of indices (i, j) with i < j, calculate the sum of the remaining elements and check if the mean remains k.\"\n    },\n    {\n      \"step\": \"Use a hashmap to optimize pair counting\",\n      \"details\": \"Store the frequency of each element and use it to quickly find pairs that satisfy the condition.\"\n    },\n    {\n      \"step\": \"Output the result for each test case\",\n      \"details\": \"For each test case, output the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean, or average, is the sum of a collection of numbers divided by the count of numbers in the collection. In this requirement, it refers to the mean of the array elements before and after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: This refers to selecting two distinct positions in the array such that the first position is less than the second.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: This means that precisely two elements must be removed from the array to check if the mean remains the same.\n\n    'sum divided by n'\n    Explanation: This is the formula for calculating the mean of the array, where 'sum' is the total of all elements and 'n' is the number of elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the mean k for each test case\" and \"Iterate over possible pairs\" should be considered simultaneously. \n    Explanation: While iterating over possible pairs, the mean k should be used to check if the removal of the pair maintains the mean. This can be done in a single loop where the mean is calculated once and used for all pair checks.\n\n# [edge case]\n    Case 1: n = 3, a = [1, 1, 1]\n    Expected output: 1\n    Explanation: Only one pair can be removed, and since all elements are the same, the mean remains unchanged.\n\n    Case 2: n = 4, a = [0, 0, 0, 0]\n    Expected output: 6\n    Explanation: Any pair of elements can be removed, and the mean remains 0.\n\n    Case 3: n = 5, a = [1, 2, 3, 4, 5]\n    Expected output: 0\n    Explanation: No pair of elements can be removed to maintain the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: Specifically, when all elements are the same, any pair can be removed. This can be handled by checking if all elements are equal and then calculating combinations of pairs.\n\n    ```python\n    if all(x == a[0] for x in a):\n        return (n * (n - 1)) // ", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        # If all elements are the same, any pair can be removed\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean_k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean_k * (n - 2)\n        # a[i] + a[j] == total_sum - mean_k * (n - 2)\n        \n        target_sum = total_sum - mean_k * (n - 2)\n        \n        # Use a hashmap to count occurrences\n        from collections import defaultdict\n        count = defaultdict(int)\n        valid_pairs = 0\n        \n        for num in a:\n            # Check if there is a complement that forms the target_sum\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            \n            # Increment the count of the current number\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\n# Call the solve function to execute the solution\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        # If all elements are the same, any pair can be removed\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean_k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean_k * (n - 2)\n        # a[i] + a[j] == total_sum - mean_k * (n - 2)\n        \n        target_sum = total_sum - mean_k * (n - 2)\n        \n        # Use a hashmap to count occurrences\n        from collections import defaultdict\n        count = defaultdict(int)\n        valid_pairs = 0\n        \n        for num in a:\n            # Check if there is a complement that forms the target_sum\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            \n            # Increment the count of the current number\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\n# Call the solve function to execute the solution\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array and divide by the number of elements n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean k.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical transformations and efficient data structures to reduce the complexity of finding valid pairs.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the total sum and mean k for each test case\",\n      \"details\": \"Compute the sum of the array and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Iterate over all possible pairs (i, j) to check the condition\",\n      \"details\": \"For each pair, calculate the sum of the remaining elements and check if the mean remains k.\"\n    },\n    {\n      \"step\": \"Count valid pairs\",\n      \"details\": \"Maintain a count of pairs (i, j) that satisfy the condition and store the result for each test case.\"\n    },\n    {\n      \"step\": \"Output the results\",\n      \"details\": \"Print the count of valid pairs for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean is calculated by summing all elements in the array and dividing by the number of elements. The task is to find pairs of elements whose removal keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'sum divided by n': This indicates the calculation of the mean, which is the total sum of elements divided by the number of elements.\n    Implementation: Calculate the mean using `mean = sum(a) / n`.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the total sum and mean k for each test case\" and \"Iterate over all possible pairs (i, j) to check the condition\" should be considered simultaneously.\n    Explanation: While iterating over pairs, the mean calculation should be used to check the condition for each pair. This can be done in a single loop where the mean is used to verify the condition for each pair.\n\n# [edge case]\n    Input: 3\n    3\n    1 1 1\n    Output: 3\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n    \n    Input: 4\n    1 2 3 4\n    Output: 0\n    Explanation: No pair can be removed to keep the mean unchanged because the elements are distinct.\n    \n    Input: 5\n    5 5 5 5 5\n    Output: 10\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    Explanation: To handle cases where all elements are equal, we can directly calculate combinations of pairs without iterating over each pair.\n    Code:\n    ```python\n    if all(x == a[0] for x in a):\n        return comb(n, 2)  # Calculate combinations of pairs directly\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            # If all elements are the same, any pair can be removed\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == k * (n - 2)\n        # a[i] + a[j] == total_sum - k * (n - 2)\n        \n        target_sum = total_sum - k * (n - 2)\n        \n        # Use a dictionary to count occurrences of elements\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        # Count the number of valid pairs\n        valid_pairs = 0\n        \n        for num in a:\n            # Check if there is a complement that forms the target_sum\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            \n            # Increment the count of the current number\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"steps\": [\n        \"Sum all elements of the array a.\",\n        \"Divide the sum by the number of elements n to get the mean k.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (a[i], a[j]), calculate the sum of the remaining elements after removing a[i] and a[j].\",\n        \"Check if the mean of the remaining elements equals the initial mean k.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"steps\": [\n        \"Use mathematical properties to simplify the condition for valid pairs.\",\n        \"Implement efficient data structures or algorithms to reduce the complexity of finding valid pairs.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate initial mean\",\n      \"details\": \"For each test case, compute the mean k of the array a.\"\n    },\n    {\n      \"step\": \"Find valid pairs\",\n      \"details\": \"For each test case, iterate over pairs of elements and check if their removal keeps the mean unchanged using optimized conditions.\"\n    },\n    {\n      \"step\": \"Output results\",\n      \"details\": \"For each test case, output the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean is the average of a set of numbers, calculated by dividing the sum of the numbers by the count of numbers.\n\n# [phrase showing quantity relationship]\n    'sum divided by n': This indicates the calculation of the mean, which is the sum of elements divided by the number of elements.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to find pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the initial mean and finding valid pairs should be considered simultaneously. Specifically, when checking pairs, the calculation of the sum of remaining elements and checking if the mean remains unchanged should be done in one logical block to optimize performance.\n\n# [edge case]\n    Input: 3\n    3\n    0 0 0\n    Output: 3\n    Explanation: Any pair of elements can be removed since all of them are equal, and the mean remains unchanged.\n    \n    Input: 4\n    4\n    1 1 1 1\n    Output: 6\n    Explanation: Any pair of elements can be removed since all of them are equal, and the mean remains unchanged.\n    \n    Input: 3\n    3\n    1 2 3\n    Output: 0\n    Explanation: No pair of elements can be removed to keep the mean unchanged.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    Consider using a hashmap to store the frequency of each element and use mathematical properties to check valid pairs without iterating over all possible pairs.\n\nYES", "Round_0": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n        \n        # Use a hashmap to count occurrences of each element\n        count_map = {}\n        for num in a:\n            if num in count_map:\n                count_map[num] += 1\n            else:\n                count_map[num] = 1\n        \n        pair_count = 0\n        \n        # Iterate over each element and find pairs\n        for i in range(n):\n            count_map[a[i]] -= 1\n            for j in range(i + 1, n):\n                count_map[a[j]] -= 1\n                \n                # Check if the sum of the remaining elements equals target_sum\n                if total_sum - a[i] - a[j] == target_sum:\n                    pair_count += 1\n                \n                count_map[a[j]] += 1\n            count_map[a[i]] += 1\n        \n        results.append(pair_count)\n    \n    return results\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\ntest_cases = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    test_cases.append((n, a))\n\nresults = find_valid_pairs(t, test_cases)\n\nfor result in results:\n    print(result)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n        \n        # Use a hashmap to count occurrences of each element\n        count_map = {}\n        for num in a:\n            if num in count_map:\n                count_map[num] += 1\n            else:\n                count_map[num] = 1\n        \n        pair_count = 0\n        \n        # Iterate over each element and find pairs\n        for i in range(n):\n            count_map[a[i]] -= 1\n            for j in range(i + 1, n):\n                count_map[a[j]] -= 1\n                \n                # Check if the sum of the remaining elements equals target_sum\n                if total_sum - a[i] - a[j] == target_sum:\n                    pair_count += 1\n                \n                count_map[a[j]] += 1\n            count_map[a[i]] += 1\n        \n        results.append(pair_count)\n    \n    return results\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\ntest_cases = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    test_cases.append((n, a))\n\nresults = find_valid_pairs(t, test_cases)\n\nfor result in results:\n    print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Compute the sum of all elements in the array and divide by the number of elements n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean k.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical transformations and efficient data structures to reduce the complexity of finding valid pairs.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the initial mean k\",\n      \"details\": \"For each test case, compute the sum of the array and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Find valid pairs\",\n      \"details\": \"Iterate over all possible pairs (i, j) with i < j and check if removing these elements keeps the mean unchanged. Use efficient methods to reduce the number of checks.\"\n    },\n    {\n      \"step\": \"Count and store results\",\n      \"details\": \"For each test case, count the number of valid pairs and store the result.\"\n    },\n    {\n      \"step\": \"Output results\",\n      \"details\": \"Print the results for each test case in the required format.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean, often referred to as the average, is calculated by summing all elements in a set and dividing by the number of elements. In this requirement, it is crucial to maintain the mean after removing two elements from the array.\n\n# [phrase showing quantity relationship]\n    'sum divided by n'\n    Explanation: This phrase indicates the calculation of the mean, which is the total sum of elements divided by the number of elements. In code, this is implemented as `mean = sum(a) / n`.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the initial mean k\" and \"Find valid pairs\" should be considered simultaneously. After calculating the mean, the logic to find valid pairs can be integrated into the same loop or function to optimize performance.\n\n# [edge case]\n    Input: 3\n    3\n    1 1 1\n    Expected Output: 3\n    Explanation: All elements are the same, so any pair can be removed without changing the mean.\n\n    Input: 4\n    4\n    0 0 0 0\n    Expected Output: 6\n    Explanation: All elements are zero, so any pair can be removed without changing the mean.\n\n    Input: 3\n    3\n    1000000000 1000000000 1000000000\n    Expected Output: 3\n    Explanation: All elements are the same large number, so any pair can be removed without changing the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are the same.\n    if all(x == a[0] for x in a):\n        return comb(n, 2)  # where comb(n, 2) calculates the number of ways to choose 2 elements from n\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            results.append(comb(n, 2))\n            continue\n        \n        # Calculate the number of valid pairs\n        count = 0\n        pair_sum_needed = 2 * mean_k * (n - 2)\n        pair_sum_needed -= total_sum\n        \n        # Use a dictionary to count occurrences\n        count_map = defaultdict(int)\n        \n        for num in a:\n            count_map[num] += 1\n        \n        for num in a:\n            count_map[num] -= 1\n            complement = pair_sum_needed - num\n            if complement in count_map:\n                count += count_map[complement]\n        \n        results.append(count // 2)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            results.append(comb(n, 2))\n            continue\n        \n        # Calculate the number of valid pairs\n        count = 0\n        pair_sum_needed = 2 * mean_k * (n - 2)\n        pair_sum_needed -= total_sum\n        \n        # Use a dictionary to count occurrences\n        count_map = defaultdict(int)\n        \n        for num in a:\n            count_map[num] += 1\n        \n        for num in a:\n            count_map[num] -= 1\n            complement = pair_sum_needed - num\n            if complement in count_map:\n                count += count_map[complement]\n        \n        results.append(count // 2)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"details\": \"Compute the sum of the array and divide it by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Efficiently count valid pairs.\",\n      \"details\": \"Use mathematical transformations and efficient data structures to count pairs without checking each pair explicitly.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the initial mean k for each test case.\",\n      \"details\": \"Compute the sum of the array and divide by n to get k.\"\n    },\n    {\n      \"step\": \"Iterate over each element to find valid pairs.\",\n      \"details\": \"For each element, calculate the required value that needs to be paired with it to maintain the mean and count such pairs using a hashmap or similar data structure.\"\n    },\n    {\n      \"step\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, print the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean (or average) is the sum of a collection of numbers divided by the count of numbers in the collection. In this requirement, it refers to the mean of the array before and after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'n - 2': This indicates the number of elements remaining after removing two elements.\n    'sum divided by n': This is the formula for calculating the mean of the array.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the initial mean k for each test case\" and \"Iterate over each element to find valid pairs\" should be considered simultaneously. \n    Explanation: While iterating over each element, we can simultaneously calculate the required value that needs to be paired with it to maintain the mean using the initial mean k.\n\n# [edge case]\n    1. Input: 3\n       3\n       1 1 1\n       Expected Output: 0\n       Explanation: With only three elements, removing any two will leave one element, which cannot maintain the original mean.\n       \n    2. Input: 4\n       4\n       0 0 0 0\n       Expected Output: 6\n       Explanation: Any pair of elements can be removed since all are zero, maintaining the mean of zero.\n       \n    3. Input: 5\n       5\n       10 10 10 10 10\n       Expected Output: 10\n       Explanation: Any pair of elements can be removed since all are equal, maintaining the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n is very small (e.g., n = 3) or all elements are the same.\n    ```\n    if n == 3:\n        print(0)\n        continue\n    if all(x == a[0] for x in a):\n        print(n * (n - 1) // 2)\n        continue\n    ```\n    \nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        target_sum = total_sum - 2 * k\n        count = 0\n        freq = {}\n        \n        for num in a:\n            if target_sum - num in freq:\n                count += freq[target_sum - num]\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 191, "prompt": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements, which is the sum of elements divided by the number of these elements (i.e. sum divided by n), and Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the constraints are efficiently handled to optimize the solution.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 105}
