{"name": "1607_F. Robot on the Board 2", "description": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nEach cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. \n\n  * If the robot moves beyond the edge of the board, it falls and breaks. \n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). \n\n\n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDetermine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "tags": ["brute force", "dfs and similar", "dp", "graphs", "implementation"], "difficulty": 12, "id": 1607, "sample_io": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n"]}], "test_list": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nUDUR\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRDRR\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 7\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDUD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 1 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 9\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nUUDR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n4 3 10\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDULD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 4\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nUDDL\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 4 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n1 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n1 2 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 13\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nUDLD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRDUU\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n1 1 5\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n2 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDRUU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n3 1 7\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 2\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n2 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n1 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 4\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nURLL\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 1 8\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n3 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}], "task_id": "codecontest/103", "repair_prompt": ["The input must include an integer n and an integer m, accompanied by a sequence of n strings each composed of m characters ('L', 'R', 'D', 'U'), showing the board configuration. Confirm that both n and m are positive integers.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The input must include an integer n and an integer m, accompanied by a sequence of n strings each composed of m characters ('L', 'R', 'D', 'U'), showing the board configuration. This sequence of n strings represents the board configuration using m characters. Each of these characters can be one of 'L', 'R', 'D', or 'U'. Confirm that both n and m are positive integers.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The input must include an integer n and an integer m, accompanied by a sequence of n strings each composed of m characters ('L', 'R', 'D', 'U'), showing the board configuration and confirm that both n and m are positive integers.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def simulate_robot_movement(n, m, board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move_robot(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            moves += 1\n            dr, dc = directions[board[r][c]]\n            r += dr\n            c += dc\n        return moves\n\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = move_robot(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_robot_movement(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    # Direction vectors for 'L', 'R', 'D', 'U'\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'D': (1, 0),\n        'U': (-1, 0)\n    }\n    \n    for _ in range(t):\n        # Read the blank line\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Function to simulate the robot's movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return moves\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Iterate over all starting positions\n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        test_cases.append((n, m, board))\n    \n    return test_cases\n\ndef simulate_movement(n, m, board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move(r, c):\n        visited = set()\n        steps = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            dr, dc = directions[board[r][c]]\n            r += dr\n            c += dc\n            steps += 1\n        return steps\n    \n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = move(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, m, board in test_cases:\n        r, c, d = simulate_movement(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import deque\n\ndef parse_input():\n    input_data = sys.stdin.read().strip().split('\\n')\n    index = 0\n    t = int(input_data[index].strip())\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        while index < len(input_data) and input_data[index].strip() == '':\n            index += 1\n        n, m = map(int, input_data[index].strip().split())\n        index += 1\n        board = []\n        for _ in range(n):\n            board.append(input_data[index].strip())\n            index += 1\n        test_cases.append((n, m, board))\n    \n    return test_cases\n\ndef simulate_movement(n, m, board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def bfs(start_r, start_c):\n        visited = set()\n        queue = deque([(start_r, start_c)])\n        moves = 0\n        \n        while queue:\n            r, c = queue.popleft()\n            if (r, c) in visited:\n                continue\n            visited.add((r, c))\n            moves += 1\n            direction = board[r][c]\n            dr, dc = directions[direction]\n            new_r, new_c = r + dr, c + dc\n            if 0 <= new_r < n and 0 <= new_c < m:\n                queue.append((new_r, new_c))\n        \n        return moves\n    \n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = bfs(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, m, board in test_cases:\n        r, c, d = simulate_movement(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_robot(board, n, m):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move_from(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            direction = board[r][c]\n            dr, dc = directions[direction]\n            r += dr\n            c += dc\n            moves += 1\n        return moves\n    \n    max_moves = 0\n    start_position = (1, 1)\n    \n    for r in range(n):\n        for c in range(m):\n            moves = move_from(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_position = (r + 1, c + 1)\n    \n    return start_position[0], start_position[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_robot(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def parse_input(data):\n    lines = data.strip().split('\\n')\n    t = int(lines[0].strip())\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        while index < len(lines) and lines[index].strip() == '':\n            index += 1\n        n, m = map(int, lines[index].strip().split())\n        index += 1\n        board = [lines[index + i].strip() for i in range(n)]\n        index += n\n        test_cases.append((n, m, board))\n    \n    return test_cases\n\ndef validate_test_case(n, m, board):\n    if not (1 <= n <= 2000 and 1 <= m <= 2000):\n        raise ValueError(\"Invalid board dimensions\")\n    if len(board) != n or any(len(row) != m for row in board):\n        raise ValueError(\"Invalid board configuration\")\n    return True\n\ndef simulate_robot(n, m, board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move_from(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited:\n            visited.add((r, c))\n            moves += 1\n            dr, dc = directions[board[r][c]]\n            r, c = r + dr, c + dc\n            if not (0 <= r < n and 0 <= c < m):\n                break\n        return moves\n    \n    max_moves = 0\n    start_position = (1, 1)\n    \n    for r in range(n):\n        for c in range(m):\n            moves = move_from(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_position = (r + 1, c + 1)\n    \n    return start_position[0], start_position[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input()\n    test_cases = parse_input(data)\n    results = []\n    \n    for n, m, board in test_cases:\n        validate_test_case(n, m, board)\n        r, c, d = simulate_robot(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    print(\"\\\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    # Direction vectors for L, R, D, U\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'D': (1, 0),\n        'U': (-1, 0)\n    }\n    \n    for _ in range(t):\n        # Skip the blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Function to simulate the robot's movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return moves\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Try starting from each cell\n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip the blank line\n        while data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Function to simulate the robot's movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                if board[r][c] == 'L':\n                    c -= 1\n                elif board[r][c] == 'R':\n                    c += 1\n                elif board[r][c] == 'U':\n                    r -= 1\n                elif board[r][c] == 'D':\n                    r += 1\n                \n                # Check bounds\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            \n            return moves\n        \n        # Find the starting position with the maximum moves\n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_movement(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n        moves += 1\n\n    return moves\n\ndef find_max_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    # Direction vectors for 'L', 'R', 'D', 'U'\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'D': (1, 0),\n        'U': (-1, 0)\n    }\n    \n    for _ in range(t):\n        # Read blank line\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Function to simulate the robot's movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return moves\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Try starting from each cell\n        for i in range(n):\n            for j in range(m):\n                moves = simulate(i, j)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = i + 1, j + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_robot_movement(n, m, board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move_robot(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            moves += 1\n            dr, dc = directions[board[r][c]]\n            r += dr\n            c += dc\n        return moves\n\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = move_robot(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_robot_movement(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing a string of m characters ('L', 'R', 'D', 'U') representing the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Validate the input to ensure that n and m are positive integers and within the specified limits.\",\n      \"details\": [\n        \"Check that 1 \u2264 n \u2264 2000 and 1 \u2264 m \u2264 2000.\",\n        \"Ensure that the sum of sizes of all boards does not exceed 4\u22c510^6.\"\n      ]\n    },\n    {\n      \"description\": \"Develop an algorithm to determine the starting position (r, c) and the maximum number of moves (d) for each test case.\",\n      \"details\": [\n        \"Simulate the movement of a robot starting from each cell on the board.\",\n        \"Track the number of moves made before the robot exits the board or revisits a cell.\",\n        \"Identify the starting position that results in the maximum number of moves.\",\n        \"If multiple starting positions yield the same number of moves, any of them can be chosen.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"details\": [\n        \"For each test case, output three integers r, c, and d.\",\n        \"Ensure the output format matches the requirement: 1 \u2264 r \u2264 n, 1 \u2264 c \u2264 m, and d \u2265 0.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize a loop to process each test case.\",\n    \"For each test case, parse the input to retrieve n, m, and the board configuration.\",\n    \"Validate the input constraints for n, m, and the board size.\",\n    \"Implement a function to simulate robot movement and calculate the maximum number of moves for each starting position.\",\n    \"Determine the starting position (r, c) that results in the maximum number of moves (d).\",\n    \"Store the result for the current test case.\",\n    \"After processing all test cases, output the results in the required format.\"\n  ]\n\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the possible movements of a robot.\n\n    'maximum number of moves'\n    Explanation: This is the highest number of moves a robot can make starting from a specific cell before it either exits the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    '1 \u2264 t \u2264 10000': This indicates that the number of test cases is between 1 and 10,000.\n    '1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000': This means that the dimensions of the board (n for height and m for width) are between 1 and 2,000.\n    'sum of sizes of all boards does not exceed 4\u22c510^6': This means the total number of cells across all test cases should not exceed 4 million.\n\n# [degree adverb] \n    'maximum': This indicates that we need to find the starting position that allows the robot to make the most moves possible.\n\n# [code logic]\n    The steps related to simulating the robot's movement and determining the starting position with the maximum moves should be implemented simultaneously. This involves iterating over each cell, simulating the movement, and tracking the number of moves in a single code block.\n\n# [edge case] \n    Edge Case 1: n = 1, m = 1, board = ['L'] => Output: 1 1 1\n    Explanation: With a single cell, the robot can only make one move before exiting.\n\n    Edge Case 2: n = 2, m = 2, board = ['LR', 'UD'] => Output: 1 1 4\n    Explanation: The robot can start at (1,1) and move through all cells before revisiting or exiting.\n\n    Edge Case 3: n = 3, m = 3, board = ['RRD', 'LLU', 'UUL'] => Output: 1 1 9\n    Explanation: The robot can traverse all cells in a loop, maximizing the number of moves.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the board size is minimal or the board configuration leads to immediate exits.\n    ```python\n    def handle_edge_cases(n, m, board):\n        if n == ", "Round_0": {"code": "def simulate_robot_movement(n, m, board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move_robot(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            moves += 1\n            dr, dc = directions[board[r][c]]\n            r += dr\n            c += dc\n        return moves\n\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = move_robot(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_robot_movement(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integers n and m, representing the dimensions of the board.\",\n        \"Read the next n lines, each containing a string of m characters ('L', 'R', 'D', 'U') to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board to determine the starting position that allows the maximum number of moves.\",\n      \"steps\": [\n        \"For each cell (r, c) on the board, simulate the robot's movement according to the direction specified by the character in the cell.\",\n        \"Track the number of moves made before the robot either exits the board or revisits a cell.\",\n        \"Store the starting position and the number of moves for each simulation.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting position that results in the maximum number of moves for each test case.\",\n      \"steps\": [\n        \"Compare the number of moves from all starting positions on the board.\",\n        \"Identify the starting position (r, c) with the maximum number of moves d.\",\n        \"If there are multiple positions with the same maximum number of moves, select any one of them.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"steps\": [\n        \"For each test case, output the integers r, c, and d, representing the starting position and the maximum number of moves.\",\n        \"Ensure the output format matches the requirement, with each test case result on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n    \"For each test case, iterate over all possible starting positions on the board.\",\n    \"Simulate the robot's movement from each starting position to calculate the number of moves.\",\n    \"Track the maximum number of moves and the corresponding starting position for each test case.\",\n    \"Output the starting position and the maximum number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the movement directions for the robot.\n\n    'maximum number of moves'\n    Explanation: This is the highest number of moves the robot can make starting from a specific cell before it either exits the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This means finding the highest possible count of moves the robot can make from a starting position. In code, this can be implemented by keeping a counter for moves and updating a maximum moves variable whenever a higher count is found.\n\n# [degree adverb]\n    'maximum': This indicates the need to find the highest number of moves possible. In code, this can be implemented using a comparison to update the maximum value found so far.\n\n# [code logic]\n    The steps in the subproblem \"Simulate the movement of a robot on the board to determine the starting position that allows the maximum number of moves\" should be implemented simultaneously. Specifically, simulating the robot's movement, tracking the number of moves, and storing the starting position and moves should be done in a single loop over the board.\n\n# [edge case]\n    1 1\n    L\n    = 1 1 1\n    Explanation: The board is 1x1 with a single 'L', the robot can only make one move before exiting.\n\n    2 2\n    LL\n    LL\n    = 1 1 2\n    Explanation: Starting from (1,1), the robot moves left to (1,2) and then exits, making 2 moves.\n\n    3 3\n    RRR\n    RRR\n    RRR\n    = 1 1 3\n    Explanation: Starting from (1,1), the robot moves right three times and exits, making 3 moves.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating the robot's movement and tracking the maximum number of moves will naturally handle these cases.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    # Direction vectors for 'L', 'R', 'D', 'U'\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'D': (1, 0),\n        'U': (-1, 0)\n    }\n    \n    for _ in range(t):\n        # Read the blank line\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Function to simulate the robot's movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return moves\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Iterate over all starting positions\n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 167)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    # Direction vectors for 'L', 'R', 'D', 'U'\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'D': (1, 0),\n        'U': (-1, 0)\n    }\n    \n    for _ in range(t):\n        # Read the blank line\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Function to simulate the robot's movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return moves\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Iterate over all starting positions\n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"List of test cases, each containing n, m, and the board configuration\"\n    },\n    {\n      \"description\": \"Validate the input to ensure that n and m are positive integers and that the board configuration matches the specified dimensions.\",\n      \"input\": \"List of test cases\",\n      \"output\": \"Validated list of test cases\"\n    },\n    {\n      \"description\": \"For each test case, determine the starting position (r, c) and the maximum number of moves (d) the robot can make.\",\n      \"input\": \"Validated list of test cases\",\n      \"output\": \"List of results for each test case, each containing r, c, and d\"\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"input\": \"List of results for each test case\",\n      \"output\": \"Formatted output string\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the entire input at once and split it into lines.\",\n    \"Extract the number of test cases (t) from the first line.\",\n    \"Iterate over each test case, parsing n, m, and the board configuration.\",\n    \"Validate that n and m are within the specified range and that the board configuration matches the dimensions.\",\n    \"For each test case, implement a function to simulate the robot's movement and calculate the maximum number of moves from any starting position.\",\n    \"Store the result (r, c, d) for each test case.\",\n    \"Format the results according to the specified output format and print them.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the possible movements of the robot.\n\n    'maximum number of moves'\n    Explanation: This means finding the starting position on the board from which the robot can make the most moves without leaving the board.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates the need to calculate the highest possible number of moves the robot can make from a starting position on the board. In code, this can be implemented by simulating the robot's movement from each position and keeping track of the number of moves made.\n\n# [degree adverb] \n    'maximum': This means the largest possible number of moves the robot can make from a starting position. In code, this can be implemented by comparing the number of moves from different starting positions and selecting the highest.\n\n# [code logic]\n    The steps related to parsing the input and validating the dimensions should be implemented simultaneously. Specifically:\n    - \"Read the entire input at once and split it into lines.\"\n    - \"Extract the number of test cases (t) from the first line.\"\n    - \"Iterate over each test case, parsing n, m, and the board configuration.\"\n    - \"Validate that n and m are within the specified range and that the board configuration matches the dimensions.\"\n    These can be done in a single loop that processes each test case.\n\n# [edge case] \n    Test case with minimum dimensions:\n    1 1\n    L\n    Expected output: 1 1 1\n    Explanation: The board is 1x1, and the robot can make only one move.\n\n    Test case with maximum dimensions:\n    2000 2000\n    (board filled with 'R')\n    Expected output: 1 1 2000\n    Explanation: The robot can move right across the entire row.\n\n    Test case with mixed directions:\n    2 2\n    LR\n    UD\n    Expected output: 1 1 4\n    Explanation: The robot can move in a cycle starting from (1,1).\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases related to board boundaries and movement cycles.\n    - Implement boundary checks to ensure the robot does not move outside the board.\n    - Implement cycle detection to prevent infinite loops in movement.\n\nYES", "Round_0": {"code": "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        test_cases.append((n, m, board))\n    \n    return test_cases\n\ndef simulate_movement(n, m, board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move(r, c):\n        visited = set()\n        steps = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            dr, dc = directions[board[r][c]]\n            r += dr\n            c += dc\n            steps += 1\n        return steps\n    \n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = move(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, m, board in test_cases:\n        r, c, d = simulate_movement(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: simulate_movement() missing 3 required positional arguments: 'n', 'm', and 'board'"}, "Round_1": {"code": "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        test_cases.append((n, m, board))\n    \n    return test_cases\n\ndef simulate_movement(n, m, board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move(r, c):\n        visited = set()\n        steps = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            dr, dc = directions[board[r][c]]\n            r += dr\n            c += dc\n            steps += 1\n        return steps\n    \n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = move(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, m, board in test_cases:\n        r, c, d = simulate_movement(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"input\": \"Raw input string containing multiple test cases.\",\n      \"output\": \"A structured format containing the number of test cases, and for each test case, the values of n, m, and the board configuration.\"\n    },\n    {\n      \"description\": \"Validate the input to ensure that n and m are positive integers and that the board configuration matches the specified dimensions.\",\n      \"input\": \"Structured input from the previous step.\",\n      \"output\": \"A boolean indicating whether the input is valid, and if not, an error message.\"\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board starting from each cell to determine the maximum number of moves possible.\",\n      \"input\": \"Validated board configuration for each test case.\",\n      \"output\": \"For each test case, the starting cell (r, c) and the maximum number of moves d.\"\n    },\n    {\n      \"description\": \"Determine the starting cell (r, c) that allows the robot to make the maximum number of moves d for each test case.\",\n      \"input\": \"Results of the simulation from the previous step.\",\n      \"output\": \"For each test case, the optimal starting cell (r, c) and the maximum number of moves d.\"\n    },\n    {\n      \"description\": \"Format the output according to the specified requirements.\",\n      \"input\": \"Optimal starting cell and maximum moves for each test case.\",\n      \"output\": \"Formatted output string for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the entire input at once and split it into lines.\",\n    \"Parse the number of test cases from the first line.\",\n    \"Iterate over each test case, parsing n, m, and the board configuration.\",\n    \"Validate the parsed input to ensure it meets the requirements.\",\n    \"For each test case, simulate the robot's movement from each cell to calculate the number of moves.\",\n    \"Track the starting cell that results in the maximum number of moves.\",\n    \"Once all test cases are processed, format the results for each test case.\",\n    \"Output the results to standard output.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the possible movements of the robot.\n\n    'maximum number of moves'\n    Explanation: This means finding the starting position on the board that allows the robot to make the most moves without repeating any position.\n\n# [phrase showing quantity relationship]\n    '1 \u2264 t \u2264 10000'\n    Explanation: This indicates the number of test cases is between 1 and 10,000.\n    Implementation: Use a loop to iterate through each test case.\n\n    '1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000'\n    Explanation: This indicates the dimensions of the board are between 1 and 2,000 for both height and width.\n    Implementation: Ensure the board is created with these dimensions.\n\n    'sum of sizes of all boards does not exceed 4\u22c510^6'\n    Explanation: This is a constraint on the total number of characters across all boards.\n    Implementation: Track the total size and ensure it does not exceed this limit.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This refers to the highest number of moves the robot can make starting from any cell.\n    Implementation: Use a comparison to track the highest number of moves found during simulation.\n\n# [code logic]\n    The steps for parsing input, validating dimensions, and simulating robot movement should be implemented simultaneously for efficiency.\n    Explanation: These steps can be combined in a loop that processes each test case, validates the input, and simulates movement in one pass.\n\n# [edge case]\n    Test case with minimum dimensions:\n    1 1\n    L\n    Expected output: 1 1 1\n    Explanation: The board is 1x1, and the robot can only make one move.\n\n    Test case with maximum dimensions:\n    2000 2000\n    (board filled with 'R')\n    Expected output: 1 1 2000\n    Explanation: The robot can move right across the entire row.\n\n    Test case with mixed directions:\n    2 2\n    LR\n    DU\n    Expected output: 1 1 4\n    Explanation: The robot can move in a cycle starting from (1,1).\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling edge cases:\n", "Round_0": {"code": "import sys\nfrom collections import deque\n\ndef parse_input():\n    input_data = sys.stdin.read().strip().split('\\n')\n    index = 0\n    t = int(input_data[index].strip())\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        while index < len(input_data) and input_data[index].strip() == '':\n            index += 1\n        n, m = map(int, input_data[index].strip().split())\n        index += 1\n        board = []\n        for _ in range(n):\n            board.append(input_data[index].strip())\n            index += 1\n        test_cases.append((n, m, board))\n    \n    return test_cases\n\ndef simulate_movement(n, m, board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def bfs(start_r, start_c):\n        visited = set()\n        queue = deque([(start_r, start_c)])\n        moves = 0\n        \n        while queue:\n            r, c = queue.popleft()\n            if (r, c) in visited:\n                continue\n            visited.add((r, c))\n            moves += 1\n            direction = board[r][c]\n            dr, dc = directions[direction]\n            new_r, new_c = r + dr, c + dc\n            if 0 <= new_r < n and 0 <= new_c < m:\n                queue.append((new_r, new_c))\n        \n        return moves\n    \n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = bfs(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, m, board in test_cases:\n        r, c, d = simulate_movement(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: simulate_movement() missing 3 required positional arguments: 'n', 'm', and 'board'"}, "Round_1": {"code": "import sys\nfrom collections import deque\n\ndef parse_input():\n    input_data = sys.stdin.read().strip().split('\\n')\n    index = 0\n    t = int(input_data[index].strip())\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        while index < len(input_data) and input_data[index].strip() == '':\n            index += 1\n        n, m = map(int, input_data[index].strip().split())\n        index += 1\n        board = []\n        for _ in range(n):\n            board.append(input_data[index].strip())\n            index += 1\n        test_cases.append((n, m, board))\n    \n    return test_cases\n\ndef simulate_movement(n, m, board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def bfs(start_r, start_c):\n        visited = set()\n        queue = deque([(start_r, start_c)])\n        moves = 0\n        \n        while queue:\n            r, c = queue.popleft()\n            if (r, c) in visited:\n                continue\n            visited.add((r, c))\n            moves += 1\n            direction = board[r][c]\n            dr, dc = directions[direction]\n            new_r, new_c = r + dr, c + dc\n            if 0 <= new_r < n and 0 <= new_c < m:\n                queue.append((new_r, new_c))\n        \n        return moves\n    \n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = bfs(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, m, board in test_cases:\n        r, c, d = simulate_movement(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Validate the input to ensure n and m are positive integers and the board configuration matches the specified dimensions.\",\n      \"steps\": [\n        \"Check that n and m are within the specified range (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000).\",\n        \"Ensure each board line contains exactly m characters and consists only of 'L', 'R', 'D', 'U'.\",\n        \"Verify that the sum of sizes of all boards does not exceed 4\u22c510^6.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting position (r, c) and the maximum number of moves (d) for the robot on each board.\",\n      \"steps\": [\n        \"For each cell (i, j) on the board, simulate the robot's movement according to the direction specified by the character in the cell.\",\n        \"Track the number of moves made by the robot until it can no longer move.\",\n        \"Record the starting position (r, c) and the maximum number of moves (d) for each test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"steps\": [\n        \"For each test case, output the integers r, c, and d, which denote the starting position and the maximum number of moves.\",\n        \"Ensure the output format matches the requirement, with each test case result on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and board configurations.\",\n    \"Validate the input data to ensure it meets the specified constraints.\",\n    \"Simulate the robot's movement on each board to determine the optimal starting position and maximum moves.\",\n    \"Output the results for each test case in the required format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the possible movements of the robot.\n\n    'maximum number of moves'\n    Explanation: This means finding the starting position on the board from which the robot can make the most moves before it can no longer move.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates the need to find the highest possible number of moves the robot can make from a starting position. In code, this can be implemented by simulating movements from each position and tracking the number of moves.\n\n# [degree adverb] \n    'maximum': This means the largest number of moves possible from a starting position. In code, this can be implemented by comparing the number of moves from different starting positions and selecting the highest.\n\n# [code logic]\n    The steps in the subproblem \"Determine the starting position (r, c) and the maximum number of moves (d) for the robot on each board\" should be implemented simultaneously. Specifically, simulating the robot's movement and tracking the number of moves should be done in a single loop or function to efficiently determine the optimal starting position and maximum moves.\n\n# [edge case] \n    Test case with smallest board: \n    1 1\n    L\n    Expected output: 1 1 1\n    Explanation: The robot can only make one move from the single cell.\n\n    Test case with all directions leading out of bounds:\n    2 2\n    UU\n    LL\n    Expected output: 1 1 0\n    Explanation: Starting from any position, the robot cannot make any valid moves.\n\n    Test case with maximum board size:\n    2000 2000\n    (board filled with 'R' in the first row and 'D' in the first column, rest 'L')\n    Expected output: 1 1 3999\n    Explanation: The robot can move right across the first row and then down the first column.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot cannot make any moves or when the board is at its maximum size.\n    Code for handling edge cases:\n    ```python\n    if n == 1 and m == 1:\n        return 1, 1, 1\n    if all(board[i][j] in ['U', '", "Round_0": {"code": "def simulate_robot(board, n, m):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move_from(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            direction = board[r][c]\n            dr, dc = directions[direction]\n            r += dr\n            c += dc\n            moves += 1\n        return moves\n    \n    max_moves = 0\n    start_position = (1, 1)\n    \n    for r in range(n):\n        for c in range(m):\n            moves = move_from(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_position = (r + 1, c + 1)\n    \n    return start_position[0], start_position[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_robot(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 162)"}, "Round_1": {"code": "def simulate_robot(board, n, m):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move_from(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            direction = board[r][c]\n            dr, dc = directions[direction]\n            r += dr\n            c += dc\n            moves += 1\n        return moves\n    \n    max_moves = 0\n    start_position = (1, 1)\n    \n    for r in range(n):\n        for c in range(m):\n            moves = move_from(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_position = (r + 1, c + 1)\n    \n    return start_position[0], start_position[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_robot(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"input\": \"Raw input from standard input\",\n      \"output\": \"A list of test cases, each containing n, m, and the board configuration\"\n    },\n    {\n      \"description\": \"Validate the input to ensure n and m are positive integers and the board configuration is valid according to the given constraints.\",\n      \"input\": \"Parsed test case data\",\n      \"output\": \"Validated test case data or an error if validation fails\"\n    },\n    {\n      \"description\": \"For each test case, determine the starting position (r, c) and the maximum number of moves (d) the robot can make.\",\n      \"input\": \"Validated test case data\",\n      \"output\": \"For each test case, the starting position (r, c) and the maximum number of moves (d)\"\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"input\": \"Results for each test case\",\n      \"output\": \"Formatted output to standard output\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the entire input at once and split it into lines.\",\n    \"Parse the first line to get the number of test cases, t.\",\n    \"Iterate over each test case, parsing n, m, and the board configuration.\",\n    \"Validate the parsed data to ensure it meets the constraints.\",\n    \"For each test case, implement a function to simulate the robot's movement and calculate the maximum number of moves from any starting position.\",\n    \"Determine the starting position (r, c) that allows for the maximum number of moves (d).\",\n    \"Store the result for each test case.\",\n    \"After processing all test cases, output the results in the required format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the possible movements of the robot.\n\n    'maximum number of moves'\n    Explanation: This is the highest number of moves the robot can make starting from any cell on the board, following the directions given by the characters.\n\n# [phrase showing quantity relationship]\n    '1 \u2264 t \u2264 10000': This indicates the number of test cases is between 1 and 10,000.\n    '1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000': This indicates the dimensions of the board, n and m, are between 1 and 2,000.\n    'sum of sizes of all boards does not exceed 4\u22c510^6': This means the total number of cells across all test cases is limited to 4 million.\n\n# [degree adverb]\n    'maximum': This indicates the need to find the highest possible number of moves the robot can make from any starting position on the board.\n\n# [code logic]\n    The steps for parsing input, validating data, and outputting results can be implemented separately. However, the steps for determining the starting position and calculating the maximum number of moves should be implemented simultaneously, as they are interdependent.\n\n# [edge case]\n    Test case with minimum size board (1x1):\n    Input: \n    ```\n    1\n\n    1 1\n    L\n    ```\n    Expected output: 1 1 1\n    Explanation: The robot can only make one move from the single cell.\n\n    Test case with maximum size board (2000x2000) with uniform direction:\n    Input:\n    ```\n    1\n\n    2000 2000\n    RRR...R (2000 times)\n    RRR...R (2000 times)\n    ...\n    RRR...R (2000 times)\n    ```\n    Expected output: 1 1 2000\n    Explanation: The robot can move continuously in one direction across the entire row.\n\n    Test case with mixed directions leading to a loop:\n    Input:\n    ```\n    1\n\n    2 2\n    LR\n    RL\n    ```\n    Expected output: 1 1 4\n    Explanation: The robot can move in a loop indefinitely, but the problem constraints may limit the count to the board size.\n\n# [", "Round_0": {"code": "def parse_input(data):\n    lines = data.strip().split('\\n')\n    t = int(lines[0].strip())\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        while lines[index].strip() == '':\n            index += 1\n        n, m = map(int, lines[index].strip().split())\n        index += 1\n        board = [lines[index + i].strip() for i in range(n)]\n        index += n\n        test_cases.append((n, m, board))\n    \n    return test_cases\n\ndef validate_test_case(n, m, board):\n    if not (1 <= n <= 2000 and 1 <= m <= 2000):\n        raise ValueError(\"Invalid board dimensions\")\n    if len(board) != n or any(len(row) != m for row in board):\n        raise ValueError(\"Invalid board configuration\")\n    return True\n\ndef simulate_robot(n, m, board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move_from(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited:\n            visited.add((r, c))\n            moves += 1\n            dr, dc = directions[board[r][c]]\n            r, c = r + dr, c + dc\n            if not (0 <= r < n and 0 <= c < m):\n                break\n        return moves\n    \n    max_moves = 0\n    start_position = (1, 1)\n    \n    for r in range(n):\n        for c in range(m):\n            moves = move_from(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_position = (r + 1, c + 1)\n    \n    return start_position[0], start_position[1], max_moves\n\ndef main():\n    data = input()\n    test_cases = parse_input(data)\n    results = []\n    \n    for n, m, board in test_cases:\n        validate_test_case(n, m, board)\n        r, c, d = simulate_robot(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    print(\"\\n\".join(results))", "report": "The compilation output of the preceding code is: list index out of range"}, "Round_1": {"code": "def parse_input(data):\n    lines = data.strip().split('\\n')\n    t = int(lines[0].strip())\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        while index < len(lines) and lines[index].strip() == '':\n            index += 1\n        n, m = map(int, lines[index].strip().split())\n        index += 1\n        board = [lines[index + i].strip() for i in range(n)]\n        index += n\n        test_cases.append((n, m, board))\n    \n    return test_cases\n\ndef validate_test_case(n, m, board):\n    if not (1 <= n <= 2000 and 1 <= m <= 2000):\n        raise ValueError(\"Invalid board dimensions\")\n    if len(board) != n or any(len(row) != m for row in board):\n        raise ValueError(\"Invalid board configuration\")\n    return True\n\ndef simulate_robot(n, m, board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move_from(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited:\n            visited.add((r, c))\n            moves += 1\n            dr, dc = directions[board[r][c]]\n            r, c = r + dr, c + dc\n            if not (0 <= r < n and 0 <= c < m):\n                break\n        return moves\n    \n    max_moves = 0\n    start_position = (1, 1)\n    \n    for r in range(n):\n        for c in range(m):\n            moves = move_from(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_position = (r + 1, c + 1)\n    \n    return start_position[0], start_position[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input()\n    test_cases = parse_input(data)\n    results = []\n    \n    for n, m, board in test_cases:\n        validate_test_case(n, m, board)\n        r, c, d = simulate_robot(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    print(\"\\"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Validate the input to ensure that n and m are positive integers and that the board configuration matches the specified dimensions.\",\n      \"steps\": [\n        \"Check that n and m are within the specified range (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000).\",\n        \"Ensure that each line of the board contains exactly m characters.\",\n        \"Verify that the characters are only 'L', 'R', 'D', or 'U'.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting position (r, c) and the maximum number of moves (d) for the robot on the board.\",\n      \"steps\": [\n        \"For each cell in the board, simulate the robot's movement based on the direction indicated by the character ('L', 'R', 'D', 'U').\",\n        \"Track the number of moves made by the robot until it can no longer move.\",\n        \"Record the starting position and the number of moves for each simulation.\",\n        \"Select the starting position (r, c) that results in the maximum number of moves (d).\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the integers r, c, and d, which denote the starting position and the maximum number of moves.\",\n        \"Ensure the output format matches the specified requirements.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n    \"Validate the input to ensure it meets the specified requirements.\",\n    \"Simulate the robot's movement on each board to determine the optimal starting position and maximum moves.\",\n    \"Output the results for each test case in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: The board configuration is represented by a sequence of n strings, each composed of m characters ('L', 'R', 'D', 'U'). These characters indicate directions on the board.\n\n    'maximum number of moves'\n    Explanation: This refers to the highest number of moves the robot can make starting from a specific cell on the board, following the directions given by the characters.\n\n# [phrase showing quantity relationship]\n    '1 \u2264 t \u2264 10000': The number of test cases is between 1 and 10,000.\n    '1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000': The dimensions of the board (n and m) are between 1 and 2,000.\n    'sum of sizes of all boards does not exceed 4\u22c510^6': The total number of cells across all boards is limited to 4 million.\n\n# [degree adverb]\n    'maximum': This indicates the need to find the highest possible number of moves the robot can make from a starting position. In code, this can be implemented by keeping track of the highest move count encountered during simulations.\n\n# [code logic]\n    The steps in the plan are well-structured and do not require simultaneous implementation. Each step logically follows from the previous one, ensuring that input parsing, validation, simulation, and output are handled sequentially.\n\n# [edge case]\n    1 1\n    L\n    = 1 1 1\n    Explanation: With a single cell board, the robot can only make one move in the direction specified by the single character.\n\n    2 2\n    LL\n    RR\n    = 1 1 2\n    Explanation: The robot can start at (1,1) and move to (1,2), then it cannot move further, resulting in 2 moves.\n\n    3 3\n    LRU\n    DLD\n    UUR\n    = 1 1 3\n    Explanation: Starting at (1,1), the robot can move to (1,2), then (1,3), and finally (2,3), making 3 moves.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating the robot's movement and tracking the maximum number of moves will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    # Direction vectors for L, R, D, U\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'D': (1, 0),\n        'U': (-1, 0)\n    }\n    \n    for _ in range(t):\n        # Skip the blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Function to simulate the robot's movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return moves\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Try starting from each cell\n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Validate the input to ensure that n and m are positive integers and that the board configuration matches the specified dimensions.\",\n      \"steps\": [\n        \"Check that n and m are within the specified range (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000).\",\n        \"Ensure that each line of the board contains exactly m characters.\",\n        \"Verify that the sum of sizes of all boards does not exceed 4\u22c510^6.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting position (r, c) and the maximum number of moves (d) for the robot on the board.\",\n      \"steps\": [\n        \"For each test case, iterate over all possible starting positions on the board.\",\n        \"Simulate the robot's movement from each starting position according to the board configuration.\",\n        \"Track the number of moves made by the robot and update the maximum number of moves (d) found.\",\n        \"Select any starting position (r, c) that results in the maximum number of moves.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the integers r, c, and d, which represent the starting position and the maximum number of moves.\",\n        \"Ensure the output format matches the specified requirements.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and board configurations.\",\n    \"Validate the input data to ensure it meets the requirements.\",\n    \"For each test case, determine the optimal starting position and maximum moves for the robot.\",\n    \"Output the results for each test case in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the possible movements of the robot.\n\n    'maximum number of moves'\n    Explanation: This is the highest number of moves the robot can make starting from any position on the board, following the directions given by the characters.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This means finding the highest possible count of moves the robot can make from a starting position. In code, this involves iterating over possible starting positions and simulating moves to find the maximum.\n\n# [degree adverb]\n    'maximum': This indicates the need to find the largest possible value of moves. In code, this can be implemented by maintaining a variable to track the highest number of moves found during simulation.\n\n# [code logic]\n    The steps in the subproblem \"Determine the starting position (r, c) and the maximum number of moves (d) for the robot on the board\" should be implemented simultaneously. Specifically, iterating over starting positions, simulating movements, and updating the maximum number of moves should be done in a single loop or function to efficiently determine the result.\n\n# [edge case]\n    Edge Case 1: n = 1, m = 1, board = ['L'] -> Output: 1 1 1\n    Explanation: With only one cell, the robot can only make one move.\n\n    Edge Case 2: n = 2, m = 2, board = ['LR', 'UD'] -> Output: 1 1 4\n    Explanation: The robot can move in a loop starting from (1, 1), making 4 moves.\n\n    Edge Case 3: n = 3, m = 3, board = ['RRD', 'LLU', 'UUD'] -> Output: 1 1 9\n    Explanation: The robot can traverse the entire board starting from (1, 1), making 9 moves.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all starting positions and simulating moves will naturally handle these cases.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip the blank line\n        while data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Function to simulate the robot's movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                if board[r][c] == 'L':\n                    c -= 1\n                elif board[r][c] == 'R':\n                    c += 1\n                elif board[r][c] == 'U':\n                    r -= 1\n                elif board[r][c] == 'D':\n                    r += 1\n                \n                # Check bounds\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            \n            return moves\n        \n        # Find the starting position with the maximum moves\n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing a string of m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Validate the input to ensure that n and m are positive integers and that the board configuration is valid.\",\n      \"steps\": [\n        \"Check that 1 \u2264 n \u2264 2000 and 1 \u2264 m \u2264 2000 for each test case.\",\n        \"Ensure that each string in the board configuration is exactly m characters long and consists only of the characters 'L', 'R', 'D', and 'U'.\"\n      ]\n    },\n    {\n      \"description\": \"Develop an algorithm to determine the starting cell (r, c) and the maximum number of moves d for each test case.\",\n      \"steps\": [\n        \"Initialize variables to track the maximum number of moves and the corresponding starting cell.\",\n        \"For each cell in the board, simulate the movement of the robot according to the board configuration.\",\n        \"Track the number of moves made from each starting cell and update the maximum if a longer path is found.\",\n        \"Handle cases where multiple starting cells yield the same maximum number of moves by selecting any valid one.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"steps\": [\n        \"For each test case, output the integers r, c, and d, representing the starting cell and the maximum number of moves.\",\n        \"Ensure the output format matches the requirement, with each test case result on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"Validate the input to ensure it meets the specified constraints.\",\n    \"For each test case, simulate the robot's movement from each possible starting cell to determine the maximum number of moves.\",\n    \"Output the starting cell and the maximum number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: The board configuration is represented by a sequence of n strings, each composed of m characters ('L', 'R', 'D', 'U'). These characters indicate directions: 'L' for left, 'R' for right, 'D' for down, and 'U' for up. The task is to determine the starting position on this board that allows the robot to make the maximum number of moves.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This means we need to find the starting position that allows the robot to move the most steps according to the board's directional instructions.\n    Implementation: This can be implemented by simulating the robot's movement from each cell and counting the number of moves until it can no longer move.\n\n# [degree adverb]\n    'maximum': This indicates that we need to find the highest possible number of moves the robot can make from any starting position.\n    Implementation: Use a variable to track the maximum number of moves found and update it whenever a longer path is discovered.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and tracking the maximum number of moves should be implemented simultaneously. Specifically:\n    - \"For each cell in the board, simulate the movement of the robot according to the board configuration.\"\n    - \"Track the number of moves made from each starting cell and update the maximum if a longer path is found.\"\n    These can be implemented in a single loop that iterates over each cell, simulates the movement, and updates the maximum moves.\n\n# [edge case]\n    Edge Case 1: A board with only one cell, e.g., n = 1, m = 1, board = ['R']\n    Expected Output: 1 1 1\n    Explanation: The robot can only make one move from the single cell.\n\n    Edge Case 2: A board where all directions lead out of bounds immediately, e.g., n = 2, m = 2, board = ['RR', 'RR']\n    Expected Output: 1 1 1\n    Explanation: Any starting position results in only one move before going out of bounds.\n\n    Edge Case 3: A board with a loop, e.g., n = 2, m = 2, board = ['LR', 'RL']\n    Expected Output: 1 1 4\n    Explanation: Starting from (1,1), the robot can", "Round_0": {"code": "def simulate_movement(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n        moves += 1\n\n    return moves\n\ndef find_max_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: find_max_moves() missing 3 required positional arguments: 'board', 'n', and 'm'"}, "Round_1": {"code": "def simulate_movement(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n        moves += 1\n\n    return moves\n\ndef find_max_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Validate the input to ensure that n and m are positive integers and that the board configuration is correctly formatted.\",\n      \"steps\": [\n        \"Check that 1 \u2264 n \u2264 2000 and 1 \u2264 m \u2264 2000.\",\n        \"Ensure that each line of the board contains exactly m characters.\",\n        \"Verify that the total number of characters across all boards does not exceed 4,000,000.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board to determine the starting position (r, c) that allows for the maximum number of moves d.\",\n      \"steps\": [\n        \"For each cell (i, j) on the board, simulate the robot's movement according to the direction specified by the character in the cell.\",\n        \"Track the number of moves made from each starting position.\",\n        \"Determine the starting position (r, c) that results in the maximum number of moves d.\"\n      ]\n    },\n    {\n      \"description\": \"Handle multiple solutions by selecting any valid starting position if there are ties in the maximum number of moves.\",\n      \"steps\": [\n        \"If multiple starting positions yield the same maximum number of moves, select any one of them.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"steps\": [\n        \"For each test case, output the integers r, c, and d, representing the starting position and the maximum number of moves.\",\n        \"Ensure the output format matches the requirement.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and board configurations.\",\n    \"Validate the input to ensure it meets the specified constraints.\",\n    \"For each test case, simulate the robot's movement from each possible starting position to determine the maximum number of\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: The board configuration refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the possible movements of the robot.\n\n    'maximum number of moves'\n    Explanation: This refers to the highest number of moves the robot can make starting from a specific position on the board.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates that we need to find the starting position that allows the robot to make the most moves possible. In code, this can be implemented by iterating over all possible starting positions and tracking the number of moves from each, then selecting the position with the highest count.\n\n# [degree adverb]\n    'maximum': This means we are looking for the greatest number of moves possible from any starting position. In code, this can be implemented by maintaining a variable to store the maximum number of moves found and updating it whenever a higher count is encountered.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and tracking the number of moves should be implemented simultaneously. Specifically:\n    - \"For each cell (i, j) on the board, simulate the robot's movement according to the direction specified by the character in the cell.\"\n    - \"Track the number of moves made from each starting position.\"\n    These can be implemented in a single loop that iterates over each cell, simulates the movement, and updates the move count.\n\n# [edge case]\n    Test case with minimum board size:\n    1 1\n    L\n    Expected output: 1 1 1\n    Explanation: The board is of size 1x1, and the robot can only make one move starting from the only cell.\n\n    Test case with all directions leading to a loop:\n    2 2\n    LR\n    RL\n    Expected output: 1 1 4\n    Explanation: Starting from (1, 1), the robot can move in a loop indefinitely, but since the board size is 2x2, the maximum moves are limited to 4.\n\n    Test case with no valid moves:\n    1 1\n    U\n    Expected output: 1 1 0\n    Explanation: The robot cannot move outside the board, so the number of moves is zero.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot cannot move or", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    # Direction vectors for 'L', 'R', 'D', 'U'\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'D': (1, 0),\n        'U': (-1, 0)\n    }\n    \n    for _ in range(t):\n        # Read blank line\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Function to simulate the robot's movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return moves\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Try starting from each cell\n        for i in range(n):\n            for j in range(m):\n                moves = simulate(i, j)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = i + 1, j + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 165)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    # Direction vectors for 'L', 'R', 'D', 'U'\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'D': (1, 0),\n        'U': (-1, 0)\n    }\n    \n    for _ in range(t):\n        # Read blank line\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Function to simulate the robot's movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return moves\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Try starting from each cell\n        for i in range(n):\n            for j in range(m):\n                moves = simulate(i, j)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = i + 1, j + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing a string of m characters ('L', 'R', 'D', 'U') representing the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Validate the input to ensure that n and m are positive integers and within the specified limits.\",\n      \"details\": [\n        \"Check that 1 \u2264 n \u2264 2000 and 1 \u2264 m \u2264 2000.\",\n        \"Ensure that the sum of sizes of all boards does not exceed 4\u22c510^6.\"\n      ]\n    },\n    {\n      \"description\": \"Develop an algorithm to determine the starting position (r, c) and the maximum number of moves (d) for each test case.\",\n      \"details\": [\n        \"Simulate the movement of a robot starting from each cell on the board.\",\n        \"Track the number of moves made before the robot exits the board or revisits a cell.\",\n        \"Identify the starting position that results in the maximum number of moves.\",\n        \"If multiple starting positions yield the same number of moves, any of them can be chosen.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"details\": [\n        \"For each test case, output three integers r, c, and d.\",\n        \"Ensure the output format matches the requirement: 1 \u2264 r \u2264 n, 1 \u2264 c \u2264 m, and d \u2265 0.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize a loop to process each test case.\",\n    \"For each test case, parse the input to retrieve n, m, and the board configuration.\",\n    \"Validate the input constraints for n, m, and the board size.\",\n    \"Implement a function to simulate robot movement and calculate the maximum number of moves for each starting position.\",\n    \"Determine the starting position (r, c) that results in the maximum number of moves (d).\",\n    \"Store the result for the current test case.\",\n    \"After processing all test cases, output the results in the required format.\"\n  ]\n\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the possible movements of a robot.\n\n    'maximum number of moves'\n    Explanation: This is the highest number of moves a robot can make starting from a specific cell before it either exits the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    '1 \u2264 t \u2264 10000': This indicates that the number of test cases is between 1 and 10,000.\n    '1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000': This means that the dimensions of the board (n for height and m for width) are between 1 and 2,000.\n    'sum of sizes of all boards does not exceed 4\u22c510^6': This means the total number of cells across all test cases should not exceed 4 million.\n\n# [degree adverb] \n    'maximum': This indicates that we need to find the starting position that allows the robot to make the most moves possible.\n\n# [code logic]\n    The steps related to simulating the robot's movement and determining the starting position with the maximum moves should be implemented simultaneously. This involves iterating over each cell, simulating the movement, and tracking the number of moves in a single code block.\n\n# [edge case] \n    Edge Case 1: n = 1, m = 1, board = ['L'] => Output: 1 1 1\n    Explanation: With a single cell, the robot can only make one move before exiting.\n\n    Edge Case 2: n = 2, m = 2, board = ['LR', 'UD'] => Output: 1 1 4\n    Explanation: The robot can start at (1,1) and move through all cells before revisiting or exiting.\n\n    Edge Case 3: n = 3, m = 3, board = ['RRD', 'LLU', 'UUL'] => Output: 1 1 9\n    Explanation: The robot can traverse all cells in a loop, maximizing the number of moves.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the board size is minimal or the board configuration leads to immediate exits.\n    ```python\n    def handle_edge_cases(n, m, board):\n        if n == ", "Round_0": {"code": "def simulate_robot_movement(n, m, board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move_robot(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            moves += 1\n            dr, dc = directions[board[r][c]]\n            r += dr\n            c += dc\n        return moves\n\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = move_robot(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_robot_movement(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, false, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 662, "prompt": "The input must include an integer n and an integer m, accompanied by a sequence of n strings each composed of m characters ('L', 'R', 'D', 'U'), showing the board configuration. Confirm that both n and m are positive integers.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "mutate_method": "rephrase_one", "save_node": true, "parent_index": 319}
