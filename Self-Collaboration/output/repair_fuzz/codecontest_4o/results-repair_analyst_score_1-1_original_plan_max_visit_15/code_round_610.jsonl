{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "repair_prompt": ["Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements. Note that it's possible that k is not an integer. The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements. In other words, it is the sum divided by n. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements. Note that it's possible that k is not an integer. The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements. In other words, when you calculate the mean, it involves taking the sum of all elements in the array and then dividing by the number of elements, which is n. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements, which is the sum of elements divided by the number of these elements. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def find_valid_pairs(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        total_sum = sum(a)\n        mean = total_sum / n\n\n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n\n        target_sum = total_sum - mean * (n - 2)\n\n        # Count pairs (i, j) such that a[i] + a[j] == target_sum\n        count = 0\n        value_count = {}\n\n        for value in a:\n            if target_sum - value in value_count:\n                count += value_count[target_sum - value]\n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n\n        results.append(count)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n\n    results = find_valid_pairs(t, test_cases)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying the equation:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        # Use a hashmap to count occurrences of each element\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        for num in a:\n            count[num] += 1\n        \n        valid_pairs = 0\n        \n        for num in a:\n            count[num] -= 1  # Remove current element from count\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n        \n        # Since each pair is counted twice, divide by 2\n        results.append(valid_pairs // 2)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def calculate_valid_pairs(test_cases):\n    results = []\n    for n, array in test_cases:\n        total_sum = sum(array)\n        k = total_sum / n\n        target_sum = (n - 2) * k\n\n        count = 0\n        value_count = {}\n        \n        for value in array:\n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n\n        for value in array:\n            value_count[value] -= 1\n            needed_value = target_sum - (total_sum - value)\n            if needed_value in value_count and value_count[needed_value] > 0:\n                count += value_count[needed_value]\n\n        results.append(count // 2)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = calculate_valid_pairs(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n        count = 0\n        value_count = {}\n        \n        for value in a:\n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        for i in range(n):\n            needed_value = target_sum - (total_sum - a[i])\n            if needed_value in value_count:\n                count += value_count[needed_value]\n                if needed_value == a[i]:\n                    count -= 1\n        \n        results.append(count // 2)\n    \n    return results\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\ntest_cases = []\n\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1:index + 1 + n]))\n    test_cases.append((n, a))\n    index += n + 1\n\nresults = find_valid_pairs(t, test_cases)\n\nfor result in results:\n    print(result)\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == k * (n - 2)\n        # a[i] + a[j] == total_sum - k * (n - 2)\n        \n        target_sum = total_sum - k * (n - 2)\n        \n        # Count pairs (i, j) such that a[i] + a[j] == target_sum\n        from collections import defaultdict\n        \n        count = 0\n        freq = defaultdict(int)\n        \n        for num in a:\n            # Check if there is a number that can pair with `num` to form `target_sum`\n            complement = target_sum - num\n            if complement in freq:\n                count += freq[complement]\n            \n            # Record the frequency of the current number\n            freq[num] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def find_valid_pairs(test_cases):\n    results = []\n    for n, array in test_cases:\n        total_sum = sum(array)\n        mean = total_sum / n\n        count = 0\n        value_count = {}\n        \n        for value in array:\n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if (total_sum - array[i] - array[j]) / (n - 2) == mean:\n                    count += 1\n        \n        results.append(count)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = find_valid_pairs(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            # If all elements are the same, any pair can be removed\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == k * (n - 2)\n        # a[i] + a[j] == total_sum - k * (n - 2)\n        \n        target_sum = total_sum - k * (n - 2)\n        \n        # Count pairs (i, j) such that a[i] + a[j] == target_sum\n        from collections import defaultdict\n        \n        count = 0\n        freq = defaultdict(int)\n        \n        for num in a:\n            # Check if there exists a number such that num + x = target_sum\n            if target_sum - num in freq:\n                count += freq[target_sum - num]\n            \n            # Record the frequency of the current number\n            freq[num] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Count pairs (i, j) such that removing them keeps the mean unchanged\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (total_sum - a[i] - a[j]) / (n - 2) == mean_k:\n                    count += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Dictionary to store frequency of each element\n        freq = {}\n        for num in a:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Calculate the sum of the remaining elements\n                remaining_sum = total_sum - a[i] - a[j]\n                remaining_mean = remaining_sum / (n - 2)\n                \n                # Check if the mean remains unchanged\n                if remaining_mean == mean_k:\n                    count += 1\n        \n        results.append(count)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_valid_pairs(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        total_sum = sum(a)\n        mean_k = total_sum / n\n        counter = 0\n        \n        # Use a dictionary to count occurrences of each element\n        element_count = {}\n        for num in a:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        # Iterate over all pairs (i, j) with i < j\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Calculate the sum of the remaining elements\n                remaining_sum = total_sum - a[i] - a[j]\n                remaining_mean = remaining_sum / (n - 2)\n                \n                # Check if the mean of the remaining elements equals k\n                if remaining_mean == mean_k:\n                    counter += 1\n        \n        results.append(counter)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_valid_pairs(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        total_sum = sum(a)\n        mean = total_sum / n\n\n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n\n        target_sum = total_sum - mean * (n - 2)\n\n        # Count pairs (i, j) such that a[i] + a[j] == target_sum\n        count = 0\n        value_count = {}\n\n        for value in a:\n            if target_sum - value in value_count:\n                count += value_count[target_sum - value]\n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n\n        results.append(count)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n\n    results = find_valid_pairs(t, test_cases)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by the number of elements n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Count the number of valid pairs (i, j) that satisfy the condition.\",\n      \"details\": \"Iterate through all possible pairs and count those that satisfy the condition derived in the previous step.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the total sum of the array a\",\n      \"details\": \"Compute the sum of all elements in the array a to use in mean calculations.\"\n    },\n    {\n      \"step\": \"Iterate over all pairs of elements\",\n      \"details\": \"Use a nested loop to consider each pair of elements (a[i], a[j]) with i < j.\"\n    },\n    {\n      \"step\": \"Check if removing the pair keeps the mean unchanged\",\n      \"details\": \"For each pair, calculate the new sum after removal and check if the mean of the remaining elements equals the original mean k.\"\n    },\n    {\n      \"step\": \"Count valid pairs\",\n      \"details\": \"Maintain a counter to count pairs that satisfy the condition and output the result for each test case.\"\n    },\n    {\n      \"step\": \"Output the results\",\n      \"details\": \"For each test case, print the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of a set of numbers is calculated by dividing the sum of the numbers by the count of numbers. In this requirement, the mean of the array should remain unchanged even after removing two elements.\n\n# [phrase showing quantity relationship]\n    'sum of elements divided by the number of these elements'\n    Explanation: This phrase describes the calculation of the mean, which is the total sum of the array elements divided by the number of elements. In code, this is implemented as `mean = sum(a) / n`.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps \"Iterate over all pairs of elements\" and \"Check if removing the pair keeps the mean unchanged\" should be implemented simultaneously. This can be done by using a nested loop to iterate over pairs and checking the condition within the same loop.\n\n# [edge case] \n    Case 1: n = 3, a = [1, 1, 1] = 3\n    Explanation: Any pair can be removed since all elements are equal, resulting in 3 valid pairs.\n    \n    Case 2: n = 4, a = [0, 0, 0, 0] = 6\n    Explanation: Any pair can be removed since all elements are equal, resulting in 6 valid pairs.\n    \n    Case 3: n = 5, a = [1, 2, 3, 4, 5] = 0\n    Explanation: No pair can be removed to keep the mean unchanged, resulting in 0 valid pairs.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over pairs and checking the mean condition will naturally handle these cases.\n\nNO", "Round_0": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        total_sum = sum(a)\n        mean = total_sum / n\n\n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n\n        target_sum = total_sum - mean * (n - 2)\n\n        # Count pairs (i, j) such that a[i] + a[j] == target_sum\n        count = 0\n        value_count = {}\n\n        for value in a:\n            if target_sum - value in value_count:\n                count += value_count[target_sum - value]\n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n\n        results.append(count)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n\n    results = find_valid_pairs(t, test_cases)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"details\": \"Sum all elements of the array and divide by the number of elements to get the initial mean.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"details\": \"For each pair of elements, check if their removal results in the same mean for the remaining elements.\"\n    },\n    {\n      \"description\": \"Count valid pairs.\",\n      \"details\": \"Count all pairs that satisfy the condition of maintaining the mean after removal.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases and for each test case, parse the number of elements and the array itself.\"\n    },\n    {\n      \"step\": \"Calculate the initial mean for each test case.\",\n      \"details\": \"Compute the sum of the array and divide by the number of elements to get the mean.\"\n    },\n    {\n      \"step\": \"Iterate over all pairs of elements in the array.\",\n      \"details\": \"For each pair (i, j) where i < j, calculate the sum of the remaining elements after removing a[i] and a[j].\"\n    },\n    {\n      \"step\": \"Check if the mean is maintained.\",\n      \"details\": \"Verify if the mean of the remaining elements equals the initial mean.\"\n    },\n    {\n      \"step\": \"Count and store the number of valid pairs for each test case.\",\n      \"details\": \"Increment the count for each pair that maintains the mean and store the result.\"\n    },\n    {\n      \"step\": \"Output the results.\",\n      \"details\": \"Print the count of valid pairs for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is calculated by summing all elements and dividing by the number of elements. It represents the average value of the array.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': means that we need to remove two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': means we need to find pairs of indices where the first index is less than the second.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps \"Iterate over all pairs of elements in the array\" and \"Check if the mean is maintained\" should be implemented simultaneously. This can be done by iterating through pairs and checking the condition within the same loop.\n\n# [edge case] \n    Test case with all elements equal: [5, 5, 5, 5] = 6\n    Explanation: Any pair of elements can be removed since all elements are equal, maintaining the mean.\n    \n    Test case with no valid pairs: [1, 2, 3] = 0\n    Explanation: No pair of elements can be removed to maintain the mean.\n    \n    Test case with large numbers: [1000000000, 1000000000, 1000000000, 1000000000] = 6\n    Explanation: Similar to the first edge case, all elements are equal, so any pair can be removed.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    - Use a hashmap to store frequency of elements and calculate potential pairs based on frequency.\n    - Consider cases where all elements are equal separately to optimize performance.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying the equation:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        # Use a hashmap to count occurrences of each element\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        for num in a:\n            count[num] += 1\n        \n        valid_pairs = 0\n        \n        for num in a:\n            count[num] -= 1  # Remove current element from count\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying the equation:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        # Use a hashmap to count occurrences of each element\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        for num in a:\n            count[num] += 1\n        \n        valid_pairs = 0\n        \n        for num in a:\n            count[num] -= 1  # Remove current element from count\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n        \n        # Since each pair is counted twice, divide by 2\n        results.append(valid_pairs // 2)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the corresponding arrays for each test case.\",\n      \"input\": \"Raw input string containing multiple test cases.\",\n      \"output\": \"A list of test cases, where each test case is a tuple containing the number of elements and the array of integers.\"\n    },\n    {\n      \"description\": \"Calculate the mathematical mean of the original array for each test case.\",\n      \"input\": \"An array of integers.\",\n      \"output\": \"The mathematical mean of the array.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements that can be removed such that the mean of the remaining elements is equal to the original mean.\",\n      \"input\": \"An array of integers and its mean.\",\n      \"output\": \"The number of valid pairs of indices (i, j) that can be removed.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a list of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Calculate the sum of the array and the mathematical mean (k) of the array.\",\n    \"  b. Iterate over all possible pairs of indices (i, j) with i < j.\",\n    \"  c. For each pair, calculate the sum of the remaining elements after removing a[i] and a[j].\",\n    \"  d. Check if the mean of the remaining elements equals the original mean (k).\",\n    \"  e. Count the number of valid pairs that satisfy the condition.\",\n    \"Store the result for each test case and print the results after processing all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean, often referred to as the average, is calculated by dividing the sum of all elements in a set by the number of elements in that set.\n\n# [phrase showing quantity relationship]\n    'sum of elements divided by the number of these elements': This describes the calculation of the mean, which is a division operation in code.\n    Implementation: mean = sum(array) / len(array)\n\n# [degree adverb] \n    'exactly': This indicates that precisely two elements must be removed, no more, no less.\n    Implementation: Ensure that the code logic only considers pairs of elements for removal.\n\n# [code logic]\n    The steps b, c, and d should be implemented simultaneously.\n    Explanation: When iterating over pairs of indices (i, j), the calculation of the sum of remaining elements and checking if the mean remains unchanged should be done in the same loop to optimize performance and ensure correctness.\n\n# [edge case] \n    Test case with all identical elements: [5, 5, 5, 5] = 6\n    Explanation: Any pair of elements can be removed without changing the mean since all elements are identical.\n    \n    Test case with minimum elements: [1, 2, 3] = 0\n    Explanation: With only three elements, removing any two will always change the mean unless all elements are identical.\n    \n    Test case with large numbers: [1000000000, 1000000000, 1000000000, 1000000000] = 6\n    Explanation: Similar to the first edge case, all elements are identical, so any pair can be removed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over pairs and checking the mean will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def calculate_valid_pairs(test_cases):\n    results = []\n    for n, array in test_cases:\n        total_sum = sum(array)\n        k = total_sum / n\n        target_sum = (n - 2) * k\n\n        count = 0\n        value_count = {}\n        \n        for value in array:\n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n\n        for value in array:\n            value_count[value] -= 1\n            needed_value = target_sum - (total_sum - value)\n            if needed_value in value_count and value_count[needed_value] > 0:\n                count += value_count[needed_value]\n\n        results.append(count // 2)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = calculate_valid_pairs(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean k.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Count the number of valid pairs (i, j) for each test case.\",\n      \"details\": \"Iterate through all possible pairs and count those that satisfy the condition.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read the number of test cases t.\"\n    },\n    {\n      \"step\": \"For each test case, perform the following:\",\n      \"substeps\": [\n        {\n          \"step\": \"Read the integer n and the array a of n integers.\"\n        },\n        {\n          \"step\": \"Calculate the sum of the array a and determine the mean k.\"\n        },\n        {\n          \"step\": \"Initialize a counter to zero for counting valid pairs.\"\n        },\n        {\n          \"step\": \"Iterate over all pairs of indices (i, j) with i < j:\",\n          \"substeps\": [\n            {\n              \"step\": \"Calculate the sum of the remaining elements if a[i] and a[j] are removed.\"\n            },\n            {\n              \"step\": \"Check if the mean of the remaining elements equals k.\"\n            },\n            {\n              \"step\": \"If the condition is satisfied, increment the counter.\"\n            }\n          ]\n        },\n        {\n          \"step\": \"Output the counter value for the current test case.\"\n        }\n      ]\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, it is used to determine if removing two elements from the array keeps the mean of the remaining elements the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to count all possible pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the sum of the array and determining the mean k should be done before iterating over pairs. The iteration over pairs and checking the condition should be done simultaneously in a loop.\n\n# [edge case]\n    1. Input: 3\n       3\n       1 1 1\n       Expected Output: 1\n       Explanation: With all elements being the same, any pair can be removed, and the mean remains unchanged.\n       \n    2. Input: 3\n       3\n       1 2 3\n       Expected Output: 0\n       Explanation: No pair can be removed to keep the mean the same because the mean changes with any removal.\n       \n    3. Input: 4\n       4\n       0 0 0 0\n       Expected Output: 6\n       Explanation: All elements are zero, so any pair can be removed, and the mean remains zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all pairs and checking the condition will naturally handle these cases.\n\nNO", "Round_0": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n        count = 0\n        value_count = {}\n        \n        for value in a:\n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        for i in range(n):\n            needed_value = target_sum - (total_sum - a[i])\n            if needed_value in value_count:\n                count += value_count[needed_value]\n                if needed_value == a[i]:\n                    count -= 1\n        \n        results.append(count // 2)\n    \n    return results\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\ntest_cases = []\n\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1:index + 1 + n]))\n    test_cases.append((n, a))\n    index += n + 1\n\nresults = find_valid_pairs(t, test_cases)\n\nfor result in results:\n    print(result)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n        count = 0\n        value_count = {}\n        \n        for value in a:\n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        for i in range(n):\n            needed_value = target_sum - (total_sum - a[i])\n            if needed_value in value_count:\n                count += value_count[needed_value]\n                if needed_value == a[i]:\n                    count -= 1\n        \n        results.append(count // 2)\n    \n    return results\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\ntest_cases = []\n\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1:index + 1 + n]))\n    test_cases.append((n, a))\n    index += n + 1\n\nresults = find_valid_pairs(t, test_cases)\n\nfor result in results:\n    print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the corresponding arrays for each test case.\",\n      \"input\": \"Raw input string containing multiple test cases.\",\n      \"output\": \"A list of test cases, where each test case is a tuple containing the number of elements and the array of integers.\"\n    },\n    {\n      \"description\": \"Calculate the mathematical mean of the original array for each test case.\",\n      \"input\": \"An array of integers.\",\n      \"output\": \"The mathematical mean of the array.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements that can be removed such that the mean of the remaining elements is equal to the original mean.\",\n      \"input\": \"An array of integers and its mean.\",\n      \"output\": \"The number of valid pairs of indices (i, j) that can be removed.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a list of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Calculate the sum of the array and the mathematical mean (k) of the array.\",\n    \"  b. Iterate over all possible pairs of indices (i, j) with i < j.\",\n    \"  c. For each pair, calculate the sum of the remaining elements after removing a[i] and a[j].\",\n    \"  d. Check if the mean of the remaining elements equals the original mean (k).\",\n    \"  e. Count the number of valid pairs (i, j) that satisfy the condition.\",\n    \"Store the result for each test case and print the results.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean, often referred to as the average, is calculated by summing all elements in a set and dividing by the number of elements. In this requirement, it is used to determine if removing two elements from the array keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This indicates that we need to remove precisely two elements from the array.\n    'sum of elements divided by the number of these elements': This describes the calculation of the mean, which is the total sum divided by the count of elements.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps b, c, and d should be implemented simultaneously:\n    \"Iterate over all possible pairs of indices (i, j) with i < j\",\n    \"For each pair, calculate the sum of the remaining elements after removing a[i] and a[j]\",\n    \"Check if the mean of the remaining elements equals the original mean (k)\"\n    This can be done by iterating through pairs of indices, calculating the new sum after removal, and checking the mean condition in one loop.\n\n# [edge case] \n    Test case with all elements equal: [5, 5, 5, 5] = 6\n    Explanation: Any pair of elements can be removed since all elements are equal, maintaining the mean.\n    \n    Test case with no valid pairs: [1, 2, 3] = 0\n    Explanation: No pair of elements can be removed to maintain the mean because the array is too small to satisfy the condition.\n    \n    Test case with large numbers: [1000000000, 1000000000, 1000000000, 1000000000] = 6\n    Explanation: Similar to the first edge case, any pair can be removed since all elements are equal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of iterating through pairs and checking the mean condition inherently handles these scenarios.\n\nNO", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == k * (n - 2)\n        # a[i] + a[j] == total_sum - k * (n - 2)\n        \n        target_sum = total_sum - k * (n - 2)\n        \n        # Count pairs (i, j) such that a[i] + a[j] == target_sum\n        from collections import defaultdict\n        \n        count = 0\n        freq = defaultdict(int)\n        \n        for num in a:\n            # Check if there is a number that can pair with `num` to form `target_sum`\n            complement = target_sum - num\n            if complement in freq:\n                count += freq[complement]\n            \n            # Record the frequency of the current number\n            freq[num] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 96)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == k * (n - 2)\n        # a[i] + a[j] == total_sum - k * (n - 2)\n        \n        target_sum = total_sum - k * (n - 2)\n        \n        # Count pairs (i, j) such that a[i] + a[j] == target_sum\n        from collections import defaultdict\n        \n        count = 0\n        freq = defaultdict(int)\n        \n        for num in a:\n            # Check if there is a number that can pair with `num` to form `target_sum`\n            complement = target_sum - num\n            if complement in freq:\n                count += freq[complement]\n            \n            # Record the frequency of the current number\n            freq[num] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"steps\": [\n        \"Sum all elements of the array.\",\n        \"Divide the sum by the number of elements to get the mean.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (i, j) in the array:\",\n        \"Calculate the sum of the remaining elements after removing elements at positions i and j.\",\n        \"Divide the sum by (n - 2) to get the new mean.\",\n        \"Check if the new mean equals the initial mean.\"\n      ]\n    },\n    {\n      \"description\": \"Count the number of valid pairs.\",\n      \"steps\": [\n        \"Initialize a counter to zero.\",\n        \"For each valid pair found in the previous step, increment the counter.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case:\",\n    \"Read the number of elements and the array.\",\n    \"Calculate the initial mean of the array.\",\n    \"Iterate over all pairs of elements in the array.\",\n    \"For each pair, calculate the mean of the remaining elements.\",\n    \"Check if the new mean equals the initial mean.\",\n    \"Count and store the number of valid pairs for each test case.\",\n    \"Output the count for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is calculated by summing all elements and dividing by the number of elements. The task requires maintaining this mean after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to find pairs of indices where the first index is less than the second.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for calculating the new mean and checking if it equals the initial mean should be implemented simultaneously for each pair of elements. This can be done within a nested loop iterating over pairs of indices.\n\n# [edge case] \n    Test case with all elements equal: [8, 8, 8, 8] = 6\n    Explanation: Any pair of elements can be removed since all elements are equal, maintaining the mean.\n    \n    Test case with no valid pairs: [50, 20, 10] = 0\n    Explanation: No pair of elements can be removed to maintain the mean.\n    \n    Test case with multiple valid pairs: [1, 4, 7, 3, 5] = 2\n    Explanation: Removing elements at positions 1 and 3 or 4 and 5 maintains the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over pairs and checking the mean will naturally handle these cases.\n\nNO", "Round_0": {"code": "def find_valid_pairs(test_cases):\n    results = []\n    for n, array in test_cases:\n        total_sum = sum(array)\n        mean = total_sum / n\n        count = 0\n        value_count = {}\n        \n        for value in array:\n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if (total_sum - array[i] - array[j]) / (n - 2) == mean:\n                    count += 1\n        \n        results.append(count)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = find_valid_pairs(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Count the number of valid pairs (i, j) for each test case.\",\n      \"details\": \"Iterate through all possible pairs (i, j) and count those that satisfy the condition.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read the number of test cases t.\"\n    },\n    {\n      \"step\": \"For each test case, perform the following:\",\n      \"substeps\": [\n        {\n          \"step\": \"Read the integer n and the array a of n integers.\"\n        },\n        {\n          \"step\": \"Calculate the sum of the array a to determine the mean k.\"\n        },\n        {\n          \"step\": \"Initialize a counter to zero for counting valid pairs.\"\n        },\n        {\n          \"step\": \"Iterate over all pairs (i, j) with i < j:\",\n          \"substeps\": [\n            {\n              \"step\": \"Calculate the sum of the remaining elements if a[i] and a[j] are removed.\"\n            },\n            {\n              \"step\": \"Check if the mean of the remaining elements equals k.\",\n              \"details\": \"The condition is: (sum of remaining elements) / (n - 2) == k.\"\n            },\n            {\n              \"step\": \"If the condition is satisfied, increment the counter.\"\n            }\n          ]\n        },\n        {\n          \"step\": \"Output the counter value for the current test case.\"\n        }\n      ]\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is calculated by summing all elements and dividing by the number of elements. It represents the average value of the array.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'equal to': This indicates that the mean of the remaining elements after removing two should be the same as the original mean.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps related to iterating over pairs and checking the mean condition should be implemented simultaneously. Specifically, the substeps under \"Iterate over all pairs (i, j) with i < j\" should be executed in a single loop structure to efficiently check each pair and update the counter.\n\n# [edge case] \n    Case 1: n = 3, a = [1, 1, 1] = 1\n    Explanation: Any pair of elements can be removed since all elements are equal, resulting in a mean that remains unchanged.\n    \n    Case 2: n = 4, a = [0, 0, 0, 0] = 6\n    Explanation: Any pair of elements can be removed since all elements are equal, resulting in a mean that remains unchanged.\n    \n    Case 3: n = 5, a = [1, 2, 3, 4, 5] = 0\n    Explanation: No pair of elements can be removed to keep the mean unchanged, as the elements are distinct and removal affects the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are equal.\n    ```python\n    if all(x == a[0] for x in a):\n        print((n * (n - 1)) // 2)\n    else:\n        # Original logic for checking pairs\n    ```\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            # If all elements are the same, any pair can be removed\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == k * (n - 2)\n        # a[i] + a[j] == total_sum - k * (n - 2)\n        \n        target_sum = total_sum - k * (n - 2)\n        \n        # Count pairs (i, j) such that a[i] + a[j] == target_sum\n        from collections import defaultdict\n        \n        count = 0\n        freq = defaultdict(int)\n        \n        for num in a:\n            # Check if there exists a number such that num + x = target_sum\n            if target_sum - num in freq:\n                count += freq[target_sum - num]\n            \n            # Record the frequency of the current number\n            freq[num] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the mathematical mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by the number of elements n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Count the number of valid pairs (i, j) that satisfy the condition.\",\n      \"details\": \"Iterate through all possible pairs and count those that satisfy the condition of maintaining the mean.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read the number of test cases t.\"\n    },\n    {\n      \"step\": \"For each test case, perform the following:\",\n      \"substeps\": [\n        {\n          \"step\": \"Read the integer n, the number of elements in the array.\"\n        },\n        {\n          \"step\": \"Read the array a of n integers.\"\n        },\n        {\n          \"step\": \"Calculate the sum of the array a and determine the mean k.\"\n        },\n        {\n          \"step\": \"Initialize a counter to zero for counting valid pairs.\"\n        },\n        {\n          \"step\": \"Iterate over all pairs of indices (i, j) with i < j:\",\n          \"substeps\": [\n            {\n              \"step\": \"Check if removing a[i] and a[j] keeps the mean of the remaining elements equal to k.\"\n            },\n            {\n              \"step\": \"If the condition is satisfied, increment the counter.\"\n            }\n          ]\n        },\n        {\n          \"step\": \"Output the counter value for the current test case.\"\n        }\n      ]\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean of the array should remain unchanged even after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to count all possible pairs of indices where the first index is less than the second.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps to calculate the mean and check pairs should be implemented in a loop for each test case. Specifically, the steps to calculate the sum and mean, and then iterate over pairs to check the condition, should be done in sequence for each test case.\n\n# [edge case] \n    1. Input: 3, [1, 1, 1] = 3\n       Explanation: All elements are the same, so any pair of elements can be removed without changing the mean.\n    2. Input: 3, [1, 2, 3] = 0\n       Explanation: No pair of elements can be removed to keep the mean unchanged.\n    3. Input: 4, [2, 2, 2, 2] = 6\n       Explanation: All elements are the same, so any pair of elements can be removed without changing the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are the same, as this simplifies the condition for maintaining the mean.\n    ```python\n    if all(x == a[0] for x in a):\n        print((n * (n - 1)) // 2)\n        continue\n    ```\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Count pairs (i, j) such that removing them keeps the mean unchanged\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (total_sum - a[i] - a[j]) / (n - 2) == mean_k:\n                    count += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Count the number of valid pairs (i, j) for each test case.\",\n      \"details\": \"Iterate through all possible pairs and count those that satisfy the condition.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Process each test case\",\n      \"details\": \"For each test case, perform the following sub-steps.\"\n    },\n    {\n      \"step\": \"Calculate the initial mean k\",\n      \"details\": \"Compute the sum of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Find valid pairs\",\n      \"details\": \"Iterate over all pairs (i, j) with i < j and check if removing a[i] and a[j] keeps the mean unchanged.\"\n    },\n    {\n      \"step\": \"Count and store the result\",\n      \"details\": \"Count the number of valid pairs for the current test case and store the result.\"\n    },\n    {\n      \"step\": \"Output results\",\n      \"details\": \"Print the number of valid pairs for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. In this problem, it is crucial to maintain the mean after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to count all possible pairs of indices where the first index is less than the second.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the initial mean k\" and \"Find valid pairs\" should be considered simultaneously. \n    Explanation: While iterating over pairs to find valid ones, the mean k should be used to check the condition for each pair. This can be done in a single loop that calculates the mean and checks pairs.\n\n# [edge case] \n    1. Input: 3\n       3\n       1 1 1\n       Explanation: All elements are the same, so any pair can be removed. Expected output: 3 (pairs: (1,2), (1,3), (2,3))\n    2. Input: 3\n       3\n       1 2 3\n       Explanation: No pair can be removed to keep the mean unchanged. Expected output: 0\n    3. Input: 4\n       4\n       5 5 5 5\n       Explanation: All elements are the same, so any pair can be removed. Expected output: 6 (pairs: (1,2), (1,3), (1,4), (2,3), (2,4), (3,4))\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are the same.\n    ```\n    if all(x == a[0] for x in a):\n        return (n * (n - 1)) // 2\n    ```\n    This code checks if all elements are the same and directly calculates the number of pairs, which is n choose 2.\n\nYES", "Round_0": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Dictionary to store frequency of each element\n        freq = {}\n        for num in a:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Calculate the sum of the remaining elements\n                remaining_sum = total_sum - a[i] - a[j]\n                remaining_mean = remaining_sum / (n - 2)\n                \n                # Check if the mean remains unchanged\n                if remaining_mean == mean_k:\n                    count += 1\n        \n        results.append(count)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Count the number of valid pairs (i, j) for each test case.\",\n      \"details\": \"Iterate through all possible pairs and count those that satisfy the condition.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read the number of test cases t.\"\n    },\n    {\n      \"step\": \"For each test case, perform the following steps:\"\n    },\n    {\n      \"step\": \"Read the integer n and the array a of n integers.\"\n    },\n    {\n      \"step\": \"Calculate the sum of the array a and determine the mean k.\"\n    },\n    {\n      \"step\": \"Initialize a counter to zero for counting valid pairs.\"\n    },\n    {\n      \"step\": \"Use a nested loop to iterate over all pairs (i, j) with i < j.\"\n    },\n    {\n      \"step\": \"For each pair, calculate the sum of the remaining elements after removing a[i] and a[j].\"\n    },\n    {\n      \"step\": \"Check if the mean of the remaining elements equals k. If yes, increment the counter.\"\n    },\n    {\n      \"step\": \"After checking all pairs, store the counter value as the result for the current test case.\"\n    },\n    {\n      \"step\": \"Output the results for all test cases.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. It represents the average value of the array.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to count pairs of indices where the first index is less than the second.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps 6-8 should be implemented simultaneously:\n    \"Use a nested loop to iterate over all pairs (i, j) with i < j\",\n    \"For each pair, calculate the sum of the remaining elements after removing a[i] and a[j]\",\n    \"Check if the mean of the remaining elements equals k. If yes, increment the counter\"\n    This can be done by writing a nested loop to iterate through all pairs, calculate the new sum after removing the elements, and check the condition in one code block.\n\n# [edge case] \n    Test case with all elements equal: [8, 8, 8, 8] = 6\n    Explanation: Any pair of elements can be removed since all of them are equal, maintaining the mean.\n    \n    Test case with no valid pairs: [50, 20, 10] = 0\n    Explanation: There is no way to delete two elements so the mathematic mean doesn't change.\n    \n    Test case with multiple valid pairs: [1, 4, 7, 3, 5] = 2\n    Explanation: It is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    To avoid recalculating the mean repeatedly, we can use the sum of the array and the mean to determine valid pairs without recalculating the mean for each pair.\n    ```python\n    total_sum = sum(a)\n    mean_k = total_sum / n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (total_sum - a[i] - a[j]) / (n - 2) == mean_k:\n                counter += 1\n    ```\n\nYES", "Round_0": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        total_sum = sum(a)\n        mean_k = total_sum / n\n        counter = 0\n        \n        # Use a dictionary to count occurrences of each element\n        element_count = {}\n        for num in a:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        # Iterate over all pairs (i, j) with i < j\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Calculate the sum of the remaining elements\n                remaining_sum = total_sum - a[i] - a[j]\n                remaining_mean = remaining_sum / (n - 2)\n                \n                # Check if the mean of the remaining elements equals k\n                if remaining_mean == mean_k:\n                    counter += 1\n        \n        results.append(counter)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by the number of elements n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Count the number of valid pairs (i, j) that satisfy the condition.\",\n      \"details\": \"Iterate through all possible pairs and count those that satisfy the condition derived in the previous step.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the total sum of the array a\",\n      \"details\": \"Compute the sum of all elements in the array a to use in mean calculations.\"\n    },\n    {\n      \"step\": \"Iterate over all pairs of elements\",\n      \"details\": \"Use a nested loop to consider each pair of elements (a[i], a[j]) with i < j.\"\n    },\n    {\n      \"step\": \"Check if removing the pair keeps the mean unchanged\",\n      \"details\": \"For each pair, calculate the new sum after removal and check if the mean of the remaining elements equals the original mean k.\"\n    },\n    {\n      \"step\": \"Count valid pairs\",\n      \"details\": \"Maintain a counter to count pairs that satisfy the condition and output the result for each test case.\"\n    },\n    {\n      \"step\": \"Output the results\",\n      \"details\": \"For each test case, print the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of a set of numbers is calculated by dividing the sum of the numbers by the count of numbers. In this requirement, the mean of the array should remain unchanged even after removing two elements.\n\n# [phrase showing quantity relationship]\n    'sum of elements divided by the number of these elements'\n    Explanation: This phrase describes the calculation of the mean, which is the total sum of the array elements divided by the number of elements. In code, this is implemented as `mean = sum(a) / n`.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps \"Iterate over all pairs of elements\" and \"Check if removing the pair keeps the mean unchanged\" should be implemented simultaneously. This can be done by using a nested loop to iterate over pairs and checking the condition within the same loop.\n\n# [edge case] \n    Case 1: n = 3, a = [1, 1, 1] = 3\n    Explanation: Any pair can be removed since all elements are equal, resulting in 3 valid pairs.\n    \n    Case 2: n = 4, a = [0, 0, 0, 0] = 6\n    Explanation: Any pair can be removed since all elements are equal, resulting in 6 valid pairs.\n    \n    Case 3: n = 5, a = [1, 2, 3, 4, 5] = 0\n    Explanation: No pair can be removed to keep the mean unchanged, resulting in 0 valid pairs.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over pairs and checking the mean condition will naturally handle these cases.\n\nNO", "Round_0": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        total_sum = sum(a)\n        mean = total_sum / n\n\n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n\n        target_sum = total_sum - mean * (n - 2)\n\n        # Count pairs (i, j) such that a[i] + a[j] == target_sum\n        count = 0\n        value_count = {}\n\n        for value in a:\n            if target_sum - value in value_count:\n                count += value_count[target_sum - value]\n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n\n        results.append(count)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n\n    results = find_valid_pairs(t, test_cases)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, false, true, false, true, true, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 610, "prompt": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements. Note that it's possible that k is not an integer. The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements. In other words, it is the sum divided by n. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "expand_one2two", "save_node": false, "parent_index": 71}
