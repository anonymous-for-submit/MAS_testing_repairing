{"name": "1615_A. Closing The Gap", "description": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\n\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "tags": ["greedy", "math"], "difficulty": 7, "id": 1615, "sample_io": [{"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}], "test_list": [{"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n1 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 3 -1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 0\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 1 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 10 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 5 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 0\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 4\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 0 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 0\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n1 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n24 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 -1 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n24 9 15\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n0 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n36 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 1\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n41 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 10 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 5\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 0 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 9\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n4 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n3 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n1 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n0 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n15 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 0 1 2\n5\n0 2 3 1 0\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 2 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 5 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n4 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 17 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 0 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n4 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 -1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 10\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n13 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 31 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n15 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 0 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n6 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 0 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n1 3 6 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 15\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 2 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 16\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 -1 3\n5\n0 3 6 1 5\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n11 12 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 2 4\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 2\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 0 6 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 1\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 14 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 2 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 14\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n1 3 10 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 19\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n0 0 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n-1 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 1\n5\n0 2 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 7\n", "output": ["0\n1\n0\n"]}], "task_id": "codecontest/119", "repair_prompt": ["There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and in a single day, you can perform an operation to make the buildings look as nice as possible: choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j). In this operation, you move a block from tower i to tower j, essentially decreasing a_i by 1 and increasing a_j by 1. You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and in a single day, you can perform an operation to make the buildings look as nice as possible: choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j). In this operation, you move a block from tower i to tower j. Essentially, you decrease the height of tower i by 1 and increase the height of tower j by 1. You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and in a single day, you can perform an operation to make the buildings look as nice as possible: choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j) and move a block from tower i to tower j, essentially decreasing a_i by 1 and increasing a_j by 1. You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_height_floor = total_blocks // n\n        target_height_ceil = target_height_floor + (1 if total_blocks % n != 0 else 0)\n\n        # Calculate the number of blocks needed to reach target heights\n        blocks_needed_floor = sum(max(0, h - target_height_floor) for h in heights)\n        blocks_needed_ceil = sum(max(0, target_height_ceil - h) for h in heights)\n\n        # Minimum ugliness achievable\n        min_ugliness = min(blocks_needed_floor, blocks_needed_ceil)\n        results.append(min_ugliness)\n    \n    return results\n\ndef parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    return test_cases\n\ndef main():\n    test_cases = parse_input()\n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        average_height = total_height // n\n        remainder = total_height % n\n        \n        # The minimum possible ugliness is determined by the remainder\n        # If remainder is 0, all buildings can be made equal\n        # If remainder is not 0, the minimum ugliness is 1\n        min_ugliness = 1 if remainder != 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        average_height = total_height // n\n        remainder = total_height % n\n        \n        # The minimum possible ugliness is determined by the remainder\n        # If remainder is 0, all buildings can be made equal, ugliness is 0\n        # If remainder is not 0, the ugliness is 1 because we can have at most one building with height different by 1\n        min_ugliness = 1 if remainder != 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        # Calculate the average height\n        average_height = total_height // n\n        # Calculate the remainder\n        remainder = total_height % n\n        # The minimum possible ugliness is 1 if there is a remainder, otherwise 0\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_height = sum(heights)\n        # Calculate the average height\n        average_height = total_height // n\n        # Calculate the remainder\n        remainder = total_height % n\n        # The minimum possible ugliness is 1 if there is a remainder, otherwise 0\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average = total_sum // n\n        remainder = total_sum % n\n        \n        # Calculate floor and ceiling of the average\n        floor_height = average\n        ceiling_height = average + 1\n        \n        # Determine the distribution\n        num_floor = n - remainder\n        num_ceiling = remainder\n        \n        # Calculate minimum possible ugliness\n        min_ugliness = ceiling_height - floor_height\n        \n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        max_height = max(heights)\n        min_height = min(heights)\n        \n        # Calculate the total number of blocks\n        total_blocks = sum(heights)\n        \n        # Calculate the average height\n        average_height = total_blocks // n\n        \n        # If the total number of blocks is divisible by n, we can make all towers equal\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            # Otherwise, the minimum ugliness is 1\n            results.append(1)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average = total_sum // n\n        remainder = total_sum % n\n        \n        # Calculate the minimum possible ugliness\n        # We can have `remainder` towers with height `average + 1` and `n - remainder` towers with height `average`\n        min_height = average\n        max_height = average + (1 if remainder > 0 else 0)\n        \n        min_ugliness = max_height - min_height\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        base_height = total_blocks // n\n        extra_blocks = total_blocks % n\n        \n        # If there are extra blocks, the minimum ugliness is 1, otherwise it's 0\n        min_ugliness = 1 if extra_blocks > 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    return test_cases\n\ndef main():\n    test_cases = parse_input()\n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        avg_floor = total_height // n\n        avg_ceil = (total_height + n - 1) // n  # Equivalent to math.ceil(total_height / n)\n\n        # Calculate the number of buildings that need to be at avg_floor and avg_ceil\n        count_floor = n * avg_ceil - total_height\n        count_ceil = n - count_floor\n\n        # The minimum ugliness is the difference between the two target heights\n        min_ugliness = avg_ceil - avg_floor if count_floor > 0 and count_ceil > 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_height_floor = total_blocks // n\n        target_height_ceil = target_height_floor + (1 if total_blocks % n != 0 else 0)\n\n        # Calculate the number of blocks needed to reach target heights\n        blocks_needed_floor = sum(max(0, h - target_height_floor) for h in heights)\n        blocks_needed_ceil = sum(max(0, target_height_ceil - h) for h in heights)\n\n        # Minimum ugliness achievable\n        min_ugliness = min(blocks_needed_floor, blocks_needed_ceil)\n        results.append(min_ugliness)\n    \n    return results\n\ndef parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    return test_cases\n\ndef main():\n    test_cases = parse_input()\n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of buildings and their respective heights.\",\n      \"output\": \"A list of test cases, where each test case is a tuple containing the number of buildings and a list of their heights.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of blocks across all towers.\",\n      \"output\": \"An integer representing the total number of blocks for each test case.\"\n    },\n    {\n      \"description\": \"Determine the target height for all towers to minimize ugliness. This is the average height if the total number of blocks is divisible by the number of towers, otherwise, it will be the floor and ceiling of the average.\",\n      \"output\": \"A tuple containing the possible target heights for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness by redistributing blocks to achieve the target heights.\",\n      \"output\": \"An integer representing the minimum possible ugliness for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into the number of test cases and their respective details.\",\n    \"For each test case, compute the total number of blocks and determine the possible target heights.\",\n    \"For each possible target height, calculate the ugliness by redistributing blocks to achieve that height.\",\n    \"Select the minimum ugliness from the calculated values for each test case.\",\n    \"Output the minimum ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means we need to find the smallest value of max(a) - min(a) after redistributing the blocks among the towers.\n\n# [degree adverb] \n    'minimum'\n    Explanation: We need to achieve the smallest possible value of ugliness, which is the difference between the tallest and shortest buildings.\n\n# [code logic]\n    The steps \"For each test case, compute the total number of blocks and determine the possible target heights\" and \"For each possible target height, calculate the ugliness by redistributing blocks to achieve that height\" should be considered simultaneously. This can be done by iterating through each test case, calculating the total blocks, determining target heights, and redistributing blocks in one loop.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 1] = 0\n    Explanation: Both towers have the same height, so the ugliness is already 0.\n    \n    Case 2: n = 3, heights = [1, 1, 10] = 0\n    Explanation: We can redistribute blocks to make all towers have the same height, resulting in an ugliness of 0.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 10] = 1\n    Explanation: After redistributing blocks, the minimum possible ugliness is 1, as we cannot make all towers have the same height.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve target heights will handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_height_floor = total_blocks // n\n        target_height_ceil = target_height_floor + (1 if total_blocks % n != 0 else 0)\n\n        # Calculate ugliness for both target heights\n        ugliness_floor = max(heights) - target_height_floor\n        ugliness_ceil = target_height_ceil - min(heights)\n\n        # Minimum ugliness achievable\n        min_ugliness = min(ugliness_floor, ugliness_ceil)\n        results.append(min_ugliness)\n    \n    return results\n\ndef parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    return test_cases\n\ndef main():\n    test_cases = parse_input()\n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: parse_input() takes 0 positional arguments but 1 was given"}, "Round_1": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_height_floor = total_blocks // n\n        target_height_ceil = target_height_floor + (1 if total_blocks % n != 0 else 0)\n\n        # Calculate the number of blocks needed to reach target heights\n        blocks_needed_floor = sum(max(0, h - target_height_floor) for h in heights)\n        blocks_needed_ceil = sum(max(0, target_height_ceil - h) for h in heights)\n\n        # Minimum ugliness achievable\n        min_ugliness = min(blocks_needed_floor, blocks_needed_ceil)\n        results.append(min_ugliness)\n    \n    return results\n\ndef parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    return test_cases\n\ndef main():\n    test_cases = parse_input()\n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the sum by the number of buildings, n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks to make the heights as equal as possible.\",\n        \"The minimum possible ugliness is the difference between the maximum and minimum heights after redistribution.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the sum of the heights and determine the average height.\",\n    \"Redistribute the blocks to minimize the height difference between the tallest and shortest buildings.\",\n    \"Calculate the minimum possible ugliness for each test case.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the height difference between the tallest and shortest buildings, formally expressed as max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': This means we need to find the smallest value of max(a) - min(a) after redistributing the blocks.\n    'as nice as possible': This implies making the heights of the buildings as equal as possible.\n\n# [degree adverb] \n    'minimum': This indicates that we need to achieve the smallest possible value for the ugliness, which is the difference between the maximum and minimum heights.\n\n# [code logic]\n    The steps in the plan related to calculating the sum of heights, determining the average height, and redistributing blocks should be considered simultaneously. This can be implemented in a single loop or function that calculates the sum, average, and redistributes blocks to minimize the height difference.\n\n# [edge case] \n    1. Test case with all buildings having the same height: \n       Input: 2\n              5 5\n       Expected output: 0\n       Explanation: Since all buildings are already of the same height, the ugliness is 0.\n\n    2. Test case with two buildings of different heights:\n       Input: 2\n              1 10\n       Expected output: 0\n       Explanation: You can move blocks from the taller building to the shorter one to make them equal.\n\n    3. Test case with maximum height difference:\n       Input: 3\n              1 1 10\n       Expected output: 1\n       Explanation: After redistributing, the closest you can get is [4, 4, 4], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to minimize the height difference will naturally handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        average_height = total_height // n\n        remainder = total_height % n\n        \n        # The minimum possible ugliness is determined by the remainder\n        # If remainder is 0, all buildings can be made equal\n        # If remainder is not 0, the minimum ugliness is 1\n        min_ugliness = 1 if remainder != 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the sum by the number of buildings, n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks to make the heights as equal as possible.\",\n        \"The minimum possible ugliness is the difference between the maximum and minimum possible heights after redistribution.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the sum of the heights and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to minimize the height difference.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'minimum possible ugliness'\n    Explanation: This refers to the smallest possible value of ugliness that can be achieved by redistributing the blocks among the towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible'\n    Explanation: This indicates the need to find the smallest value achievable, which in this context is the smallest difference between the maximum and minimum heights of the towers after redistribution.\n\n# [degree adverb]\n    'tallest', 'shortest'\n    Explanation: These refer to the maximum and minimum values in the list of building heights, respectively. In code, this can be implemented using the `max()` and `min()` functions.\n\n# [code logic]\n    The steps for calculating the sum of the heights, determining the average height, and calculating the minimum possible ugliness should be considered simultaneously. This can be done by iterating through the list of building heights once to calculate the sum, and then using this sum to determine the average and the potential redistribution.\n\n# [edge case]\n    1. Test case with all buildings having the same height: \n       Input: 3, [10, 10, 10]\n       Expected Output: 0\n       Explanation: Since all buildings are already of the same height, the ugliness is 0.\n\n    2. Test case with two buildings of different heights:\n       Input: 2, [1, 10000000]\n       Expected Output: 0\n       Explanation: You can move blocks from the taller building to the shorter one until they are equal.\n\n    3. Test case with a single building:\n       Input: 1, [5]\n       Expected Output: 0\n       Explanation: With only one building, there is no height difference, so the ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to minimize the height difference will naturally handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        average_height = total_height // n\n        remainder = total_height % n\n        \n        # The minimum possible ugliness is determined by the remainder\n        # If remainder is 0, all buildings can be made equal, ugliness is 0\n        # If remainder is not 0, the ugliness is 1 because we can have at most one building with height different by 1\n        min_ugliness = 1 if remainder != 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the building heights.\",\n        \"Determine the average height by dividing the total sum by n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of heights around the average.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the building heights.\",\n    \"Determine the average height by dividing the total sum by n.\",\n    \"Calculate the minimum possible ugliness by considering the distribution of heights around the average.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means finding the smallest value of max(a) - min(a) after performing any number of operations to redistribute the heights of the towers.\n\n# [degree adverb] \n    'minimum'\n    Explanation: The requirement is to achieve the smallest possible value of ugliness, which is the difference between the maximum and minimum heights of the towers.\n\n# [code logic]\n    The steps for calculating the total sum of building heights and determining the average height should be considered simultaneously. This can be done in one code block where the sum is calculated, and the average is derived immediately after.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 1] = 0\n    Explanation: Both towers have the same height, so the ugliness is already 0.\n    \n    Case 2: n = 3, heights = [1, 1, 3] = 0\n    Explanation: We can perform operations to make all towers have height 2, resulting in ugliness of 0.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 10] = 1\n    Explanation: We can redistribute the blocks to make the heights [3, 3, 3, 4], resulting in ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve the average height will naturally handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        # Calculate the average height\n        average_height = total_height // n\n        # Calculate the remainder\n        remainder = total_height % n\n        # The minimum possible ugliness is 1 if there is a remainder, otherwise 0\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the total sum by the number of buildings, n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks to make the heights as equal as possible.\",\n        \"The minimum possible ugliness is the difference between the maximum and minimum heights after redistribution.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the heights and determine the average height.\",\n    \"Redistribute the blocks to minimize the height difference between the tallest and shortest buildings.\",\n    \"Calculate the minimum possible ugliness for each test case.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the context of this problem, ugliness is defined as the difference between the tallest and shortest buildings after redistributing blocks. The goal is to minimize this difference.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': This means finding the smallest possible value of the difference between the maximum and minimum heights of the buildings after redistribution.\n    'as nice as possible': This implies making the heights as equal as possible, which directly relates to minimizing the ugliness.\n\n# [degree adverb]\n    'minimum': This indicates that the goal is to achieve the smallest possible value of ugliness, which is the difference between the tallest and shortest buildings.\n\n# [code logic]\n    The steps for calculating the total sum of heights, determining the average height, and redistributing blocks to minimize height differences should be considered simultaneously. This can be implemented in a loop that processes each test case, calculates the sum, determines the average, and redistributes blocks in one go.\n\n# [edge case]\n    1. Input: 1\n       2\n       10000000 1\n       Expected Output: 0\n       Explanation: With two buildings, you can move blocks from the taller to the shorter until they are equal.\n       \n    2. Input: 1\n       3\n       1 1 10000000\n       Expected Output: 0\n       Explanation: You can redistribute blocks from the tallest to the others to make all heights equal.\n       \n    3. Input: 1\n       4\n       1 1 1 10000000\n       Expected Output: 0\n       Explanation: Similar to the previous cases, redistribute blocks to equalize all heights.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to minimize the height difference will naturally handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        # Calculate the average height\n        average_height = total_height // n\n        # Calculate the remainder\n        remainder = total_height % n\n        # The minimum possible ugliness is 1 if there is a remainder, otherwise 0\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: minimum_ugliness() missing 1 required positional argument: 'test_cases'"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_height = sum(heights)\n        # Calculate the average height\n        average_height = total_height // n\n        # Calculate the remainder\n        remainder = total_height % n\n        # The minimum possible ugliness is 1 if there is a remainder, otherwise 0\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the building heights.\",\n        \"Determine the average height by dividing the total sum by the number of buildings, n.\",\n        \"Calculate the floor and ceiling of the average height to handle integer division.\",\n        \"Determine the number of buildings that should have the floor height and the number that should have the ceiling height to minimize the ugliness.\",\n        \"Calculate the minimum possible ugliness as the difference between the ceiling and floor heights.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the building heights.\",\n    \"Determine the average height and calculate the floor and ceiling of this average.\",\n    \"Determine the distribution of buildings between the floor and ceiling heights to minimize ugliness.\",\n    \"Calculate the minimum possible ugliness for each test case.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means finding the smallest possible value of max(a) - min(a) after performing any number of operations to redistribute the blocks among the towers.\n\n# [degree adverb] \n    'minimum'\n    Explanation: The requirement is asking for the smallest possible value of the ugliness, which is the difference between the tallest and shortest buildings after redistribution.\n\n# [code logic]\n    The steps for calculating the floor and ceiling of the average height and determining the distribution of buildings between these heights should be considered simultaneously. This can be implemented in a single code block where the average is calculated, and then the floor and ceiling are used to determine the distribution.\n\n# [edge case] \n    Test case with all buildings having the same height: \n    Input: 2\n           3\n           5 5 5\n    Expected output: 0\n    Explanation: Since all buildings have the same height, the ugliness is already 0.\n\n    Test case with two buildings having maximum and minimum heights:\n    Input: 2\n           2\n           1 10\n    Expected output: 0\n    Explanation: You can move blocks from the taller building to the shorter one to make them equal, resulting in an ugliness of 0.\n\n    Test case with heights that cannot be made equal:\n    Input: 2\n           3\n           1 2 4\n    Expected output: 1\n    Explanation: The closest you can get is [2, 2, 3] or [1, 3, 3], both resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating the floor and ceiling of the average height and distributing the buildings accordingly will handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average = total_sum // n\n        remainder = total_sum % n\n        \n        # Calculate floor and ceiling of the average\n        floor_height = average\n        ceiling_height = average + 1\n        \n        # Determine the distribution\n        num_floor = n - remainder\n        num_ceiling = remainder\n        \n        # Calculate minimum possible ugliness\n        min_ugliness = ceiling_height - floor_height\n        \n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, determine the maximum and minimum heights in the list of building heights.\",\n        \"Calculate the initial ugliness as the difference between the maximum and minimum heights.\",\n        \"Check if the ugliness can be reduced to zero by redistributing blocks between towers.\",\n        \"If all building heights can be equalized, set ugliness to zero.\",\n        \"If not, determine the minimum possible ugliness by redistributing blocks optimally.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each test case.\",\n    \"For each test case, calculate the minimum possible ugliness by redistributing blocks between towers.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the context of this problem, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': This means we need to find the smallest value of max(a) - min(a) that can be achieved by redistributing blocks between towers.\n\n# [degree adverb]\n    'minimum': This indicates that we are looking for the smallest possible value of ugliness after redistributing blocks.\n\n# [code logic]\n    The steps to calculate the minimum possible ugliness should be considered simultaneously:\n    - Determine the maximum and minimum heights in the list of building heights.\n    - Calculate the initial ugliness as the difference between the maximum and minimum heights.\n    - Check if the ugliness can be reduced to zero by redistributing blocks between towers.\n    - If all building heights can be equalized, set ugliness to zero.\n    - If not, determine the minimum possible ugliness by redistributing blocks optimally.\n    These steps can be implemented in a single loop or function that processes each test case.\n\n# [edge case]\n    1. Test case with all buildings of the same height: [5, 5, 5] = 0\n       Explanation: Since all buildings are already of the same height, the ugliness is 0.\n    2. Test case with two buildings of different heights: [1, 10] = 0\n       Explanation: You can move blocks from the taller building to the shorter one to equalize their heights.\n    3. Test case with alternating heights: [1, 3, 1, 3, 1] = 0\n       Explanation: Blocks can be redistributed to make all buildings of height 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to minimize the difference between the maximum and minimum heights will naturally handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        max_height = max(heights)\n        min_height = min(heights)\n        \n        # Calculate the total number of blocks\n        total_blocks = sum(heights)\n        \n        # Calculate the average height\n        average_height = total_blocks // n\n        \n        # If the total number of blocks is divisible by n, we can make all towers equal\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            # Otherwise, the minimum ugliness is 1\n            results.append(1)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the building heights.\",\n        \"Determine the average height by dividing the total sum by the number of buildings, n.\",\n        \"Calculate the floor and ceiling of the average height to determine the two possible target heights for redistribution.\",\n        \"Calculate the total number of blocks needed to reach each target height from the current heights.\",\n        \"Determine the minimum possible ugliness by finding the difference between the maximum and minimum heights after redistribution.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the building heights.\",\n    \"Determine the average height and calculate the floor and ceiling of this average.\",\n    \"Calculate the number of blocks needed to reach each target height from the current heights.\",\n    \"Determine the minimum possible ugliness by finding the difference between the maximum and minimum heights after redistribution.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means we need to find the smallest value of max(a) - min(a) after redistributing the blocks among the towers.\n\n# [degree adverb] \n    'minimum'\n    Explanation: We need to achieve the smallest possible difference between the tallest and shortest buildings.\n\n# [code logic]\n    The steps for calculating the total sum, determining the average height, and calculating the floor and ceiling of the average should be considered simultaneously. These steps are interconnected and can be implemented in a single code block to efficiently determine the target heights for redistribution.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 1] = 0\n    Explanation: Both buildings have the same height, so the ugliness is already 0.\n    \n    Case 2: n = 3, heights = [1, 1, 3] = 1\n    Explanation: Redistribute one block from the tallest building to one of the shortest buildings to achieve heights [2, 1, 2], resulting in an ugliness of 1.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 10] = 0\n    Explanation: Redistribute blocks to achieve equal heights [3, 3, 3, 3], resulting in an ugliness of 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve equal or nearly equal heights will naturally handle these edge cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average = total_sum // n\n        remainder = total_sum % n\n        \n        # Calculate the minimum possible ugliness\n        # We can have `remainder` towers with height `average + 1` and `n - remainder` towers with height `average`\n        min_height = average\n        max_height = average + (1 if remainder > 0 else 0)\n        \n        min_ugliness = max_height - min_height\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of buildings and their respective heights.\",\n      \"output\": \"A list of test cases, where each test case is a tuple containing the number of buildings and a list of their heights.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of blocks across all towers.\",\n      \"output\": \"An integer representing the total number of blocks for each test case.\"\n    },\n    {\n      \"description\": \"Determine the target height for each tower to minimize ugliness. This is achieved by dividing the total number of blocks by the number of towers and considering the remainder.\",\n      \"output\": \"Two integers: the base target height and the number of towers that need an extra block.\"\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness by determining the difference between the tallest and shortest towers after redistributing the blocks optimally.\",\n      \"output\": \"An integer representing the minimum possible ugliness for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a list of test cases.\",\n    \"For each test case, calculate the total number of blocks by summing the heights of all towers.\",\n    \"Determine the base target height by performing integer division of the total blocks by the number of towers.\",\n    \"Calculate the number of towers that need an extra block by finding the remainder of the total blocks divided by the number of towers.\",\n    \"The minimum possible ugliness is 1 if there are towers that need an extra block; otherwise, it is 0.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This refers to the smallest value of max(a) - min(a) that can be achieved after redistributing blocks among the towers.\n\n# [degree adverb] \n    'minimum'\n    Explanation: The requirement is asking for the smallest possible value of ugliness, which means we need to find the least difference between the tallest and shortest towers after redistribution.\n\n# [code logic]\n    The steps \"Determine the base target height by performing integer division of the total blocks by the number of towers\" and \"Calculate the number of towers that need an extra block by finding the remainder of the total blocks divided by the number of towers\" should be considered simultaneously. This can be implemented in one code block where both the base target height and the number of towers needing an extra block are calculated together.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 1] => Expected output: 0\n    Explanation: Both towers are already equal, so the ugliness is 0.\n    \n    Case 2: n = 3, heights = [1, 1, 3] => Expected output: 1\n    Explanation: Redistribute one block from the tallest tower to one of the shortest towers, resulting in heights [2, 1, 2] or [1, 2, 2], with an ugliness of 1.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 10] => Expected output: 1\n    Explanation: Redistribute blocks to make the heights [3, 3, 3, 4], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating the base target height and the number of towers needing an extra block will naturally handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        base_height = total_blocks // n\n        extra_blocks = total_blocks % n\n        \n        # If there are extra blocks, the minimum ugliness is 1, otherwise it's 0\n        min_ugliness = 1 if extra_blocks > 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    return test_cases\n\ndef main():\n    test_cases = parse_input()\n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the building heights.\",\n        \"Determine the average height by dividing the total sum by the number of buildings, n.\",\n        \"Calculate the floor and ceiling of the average height to determine the two possible target heights for redistribution.\",\n        \"Calculate the total number of blocks needed to reach each target height from the current heights.\",\n        \"Determine the minimum possible ugliness by finding the difference between the maximum and minimum heights after redistribution.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the building heights.\",\n    \"Determine the average height and calculate the floor and ceiling of this average.\",\n    \"Calculate the total number of blocks needed to reach each target height from the current heights.\",\n    \"Determine the minimum possible ugliness by finding the difference between the maximum and minimum heights after redistribution.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'height difference': This refers to the difference between the maximum and minimum heights of the towers, which is the measure of ugliness.\n    'minimum possible ugliness': This means finding the smallest possible value of max(a) - min(a) after redistributing blocks.\n\n# [degree adverb]\n    'minimum': This indicates the goal is to achieve the smallest possible ugliness value after redistribution.\n\n# [code logic]\n    The steps for calculating the total sum, determining the average height, and calculating the floor and ceiling of the average should be considered simultaneously. These steps are interconnected and can be implemented in a single code block to efficiently determine the target heights for redistribution.\n\n# [edge case]\n    Case 1: n = 2, heights = [1, 1]\n    Expected output: 0\n    Explanation: The towers are already equal in height, so the ugliness is 0.\n    \n    Case 2: n = 3, heights = [1, 1, 10]\n    Expected output: 0\n    Explanation: Redistribute blocks from the tallest tower to the shortest towers to make all heights equal, resulting in ugliness of 0.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 10]\n    Expected output: 1\n    Explanation: After redistribution, the closest possible equal heights are [3, 3, 3, 4], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should ensure that redistribution is done optimally to achieve the minimum possible ugliness. This involves calculating the floor and ceiling of the average height and redistributing blocks accordingly.\n\nYES", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        avg_floor = total_height // n\n        avg_ceil = (total_height + n - 1) // n  # Equivalent to math.ceil(total_height / n)\n\n        # Calculate the number of buildings that need to be at avg_floor and avg_ceil\n        count_floor = n * avg_ceil - total_height\n        count_ceil = n - count_floor\n\n        # The minimum ugliness is the difference between the two target heights\n        min_ugliness = avg_ceil - avg_floor if count_floor > 0 and count_ceil > 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of buildings and their respective heights.\",\n      \"output\": \"A list of test cases, where each test case is a tuple containing the number of buildings and a list of their heights.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of blocks across all towers.\",\n      \"output\": \"An integer representing the total number of blocks for each test case.\"\n    },\n    {\n      \"description\": \"Determine the target height for all towers to minimize ugliness. This is the average height if the total number of blocks is divisible by the number of towers, otherwise, it will be the floor and ceiling of the average.\",\n      \"output\": \"A tuple containing the possible target heights for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness by redistributing blocks to achieve the target heights.\",\n      \"output\": \"An integer representing the minimum possible ugliness for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into the number of test cases and their respective details.\",\n    \"For each test case, compute the total number of blocks and determine the possible target heights.\",\n    \"For each possible target height, calculate the ugliness by redistributing blocks to achieve that height.\",\n    \"Select the minimum ugliness from the calculated values for each test case.\",\n    \"Output the minimum ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means we need to find the smallest value of max(a) - min(a) after redistributing the blocks among the towers.\n\n# [degree adverb] \n    'minimum'\n    Explanation: We need to achieve the smallest possible value of ugliness, which is the difference between the tallest and shortest buildings.\n\n# [code logic]\n    The steps \"For each test case, compute the total number of blocks and determine the possible target heights\" and \"For each possible target height, calculate the ugliness by redistributing blocks to achieve that height\" should be considered simultaneously. This can be done by iterating through each test case, calculating the total blocks, determining target heights, and redistributing blocks in one loop.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 1] = 0\n    Explanation: Both towers have the same height, so the ugliness is already 0.\n    \n    Case 2: n = 3, heights = [1, 1, 10] = 0\n    Explanation: We can redistribute blocks to make all towers have the same height, resulting in an ugliness of 0.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 10] = 1\n    Explanation: After redistributing blocks, the minimum possible ugliness is 1, as we cannot make all towers have the same height.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve target heights will handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_height_floor = total_blocks // n\n        target_height_ceil = target_height_floor + (1 if total_blocks % n != 0 else 0)\n\n        # Calculate ugliness for both target heights\n        ugliness_floor = max(heights) - target_height_floor\n        ugliness_ceil = target_height_ceil - min(heights)\n\n        # Minimum ugliness achievable\n        min_ugliness = min(ugliness_floor, ugliness_ceil)\n        results.append(min_ugliness)\n    \n    return results\n\ndef parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    return test_cases\n\ndef main():\n    test_cases = parse_input()\n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: parse_input() takes 0 positional arguments but 1 was given"}, "Round_1": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_height_floor = total_blocks // n\n        target_height_ceil = target_height_floor + (1 if total_blocks % n != 0 else 0)\n\n        # Calculate the number of blocks needed to reach target heights\n        blocks_needed_floor = sum(max(0, h - target_height_floor) for h in heights)\n        blocks_needed_ceil = sum(max(0, target_height_ceil - h) for h in heights)\n\n        # Minimum ugliness achievable\n        min_ugliness = min(blocks_needed_floor, blocks_needed_ceil)\n        results.append(min_ugliness)\n    \n    return results\n\ndef parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    return test_cases\n\ndef main():\n    test_cases = parse_input()\n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}], "scores": [], "pass_results": [true, true, true, true, true, false, true, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 254, "prompt": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and in a single day, you can perform an operation to make the buildings look as nice as possible: choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j). In this operation, you move a block from tower i to tower j, essentially decreasing a_i by 1 and increasing a_j by 1. You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "mutate_method": "expand_one2two", "save_node": true, "parent_index": 157}
