{"name": "1622_E. Math Test", "description": "Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.\n\nIf the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.\n\nFor the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 ", "tags": ["bitmasks", "brute force", "greedy"], "difficulty": 11, "id": 1622, "sample_io": [{"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n", "output": ["3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n"]}], "test_list": [{"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n001\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1 4 2 6 3 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 4 1 6 2 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n13 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n101\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 2\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n000110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n3 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111001\n", "output": ["3 1 2\n3 1 4 2\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 2\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n2 1\n"]}, {"input": "3\n4 3\n5 1 1 0\n111\n000\n101\n010\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["1 2 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000001\n111111\n", "output": ["3 1 2\n2 3 4 1\n4 1 5 2 3 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1101\n0010\n0110\n0111\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 4 1 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n2 4 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n4 1 2 3\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0011\n0110\n0001\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n1 2 4 3\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n001\n110\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["3 2 1\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0010\n0101\n3 2\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n101\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["2 1 3\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n9 1 4 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000100\n111101\n", "output": ["3 1 2\n2 3 4 1\n4 3 5 1 2 6\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n111\n100\n4 4\n6 2 0 10\n1001\n0011\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111011\n", "output": ["3 2 1\n1 2 4 3\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n001\n110\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["2 1 3\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n001\n110\n4 4\n0 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["2 1 3\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 3 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100100\n111101\n", "output": ["3 1 2\n2 3 4 1\n6 2 3 4 1 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n1 2 0 10\n1101\n0010\n0100\n0111\n3 6\n38 3 7\n010110\n100101\n111101\n", "output": ["3 1 2\n3 4 1 2\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n1 1 2 0\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0011\n0111\n0101\n3 1\n20 3 2\n011110\n000101\n111011\n", "output": ["3 1 2\n1 2 4 3\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n000\n4 4\n6 3 0 10\n0001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100100\n111101\n", "output": ["2 1 3\n2 3 4 1\n6 2 3 4 1 5\n"]}, {"input": "3\n4 3\n5 1 3 4\n100\n100\n101\n100\n4 4\n12 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 4\n010110\n010101\n111111\n", "output": ["1 2 3\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n110\n000\n100\n100\n4 4\n6 2 1 11\n1001\n0010\n0110\n0101\n3 6\n38 0 7\n110110\n000101\n111101\n", "output": ["3 2 1\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n000\n4 4\n6 3 0 1\n0001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100100\n111101\n", "output": ["2 1 3\n1 4 3 2\n6 2 3 4 1 5\n"]}, {"input": "3\n4 3\n3 1 3 2\n110\n000\n100\n100\n4 4\n6 2 1 11\n1001\n0010\n0110\n0101\n3 6\n38 0 7\n110110\n000101\n111101\n", "output": ["1 3 2\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n0 1 2 1\n110\n100\n100\n101\n4 4\n2 2 0 13\n1101\n0110\n0110\n0101\n3 6\n38 3 12\n010110\n000001\n111101\n", "output": ["3 1 2\n2 3 4 1\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 2\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 0 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 0 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 3 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n101\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 1 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n11 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 0 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 0\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n13 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 1 0\n111\n000\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0100\n0100\n3 2\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000001\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n1 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0111\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n011\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1101\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n36 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 0 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n1101\n3 1\n34 3 7\n010110\n000101\n110111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0001\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 18\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010010\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 2 2\n101\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 1\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 2\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 10\n0001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n100\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n001\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111101\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n110110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 0\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n110110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n54 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n1 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0110\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111011\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 4\n1001\n0010\n0110\n0101\n3 1\n20 0 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n110\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n4 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n000\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0110\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n100101\n110101\n", "output": ["3 1 2\n2 3 4 1\n3 4 1 6 2 5\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n101\n101\n100\n4 4\n6 2 0 10\n1001\n0000\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0010\n0001\n3 1\n30 1 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n11 1 1 11\n1001\n0010\n1110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 2 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 0 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110110\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n13 1 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 1 0\n011\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n1110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n101\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111011\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n1110\n0101\n3 6\n20 3 15\n000110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n2 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n1 1\n20 3 7\n010110\n010101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n9 1 4 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n011\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n101\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n36 3 7\n010100\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n100\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 18\n1001\n0010\n0110\n0101\n3 6\n20 3 0\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0100\n0101\n3 1\n20 3 7\n010010\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 2 2\n101\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n011110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n010101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n3 1 0 10\n0001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n100\n100\n4 4\n6 2 0 11\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n000\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 17\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n0 1 2 0\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 6\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n110110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n54 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n010\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111001\n", "output": ["3 1 2\n3 1 4 2\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n1 2 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n111\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111011\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n000\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n8 1 0 10\n1001\n0110\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n010\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n100101\n110101\n", "output": ["3 1 2\n2 3 4 1\n3 4 1 6 2 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0010\n0001\n3 1\n30 0 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 2 0 10\n1001\n0010\n0110\n0100\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 0 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n2 1\n66 3 2\n010110\n000101\n110110\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 0\n011\n100\n111\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n1110\n0100\n3 1\n20 0 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 2 4 2\n111\n101\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111011\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 0 1 0\n111\n000\n101\n010\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["1 2 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 17\n1001\n0010\n0110\n0101\n1 1\n20 3 7\n010110\n010101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n011\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1101\n0010\n0100\n0111\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 4 1 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n100\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 0\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0011\n0110\n0001\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n1 2 4 3\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 18\n1001\n0010\n0110\n0101\n3 6\n20 3 0\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n4 1 2 2\n101\n110\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n011110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n100\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n010101\n111111\n", "output": ["1 2 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n100\n100\n4 4\n6 2 1 11\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n4 1 2 2\n111\n100\n000\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 17\n1001\n0110\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n110110\n000100\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n111\n100\n101\n000\n4 4\n4 1 0 10\n1001\n0010\n0110\n0001\n3 1\n54 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n011\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111001\n", "output": ["3 1 2\n3 1 4 2\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n000\n4 4\n12 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n1 0 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n000\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000111\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n000\n4 4\n6 1 0 10\n1101\n0010\n0010\n0101\n3 2\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n8 1 0 10\n1001\n0110\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n101\n101\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["2 1 3\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 1 0\n011\n100\n111\n000\n4 4\n20 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 3 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111110\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 17\n1001\n0010\n0110\n0101\n1 1\n20 3 8\n010110\n010101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}], "task_id": "codecontest/158", "repair_prompt": ["Petya is a math teacher. n of his students has written a test consisting of m questions, and for each student, it is known which questions he has answered correctly and which he has not. If the student answers the j-th question correctly, he earns p_j points where the points for the questions are arranged so that the array p is a rearrangement of numbers from 1 to m. For the i-th student, Petya knows that he expects to get x_i points for the test and wonders how unexpected the results could be, believing that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test. Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible; if there are multiple answers, print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Petya is a math teacher. n of his students has written a test composed of m questions. For each student, it is known which questions he has answered correctly and which he has not. If the student answers the j-th question correctly, he earns p_j points. The points for the questions are arranged so that the array p is a rearrangement of numbers from 1 to m. For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be, believing that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|. Here, r_i is the number of points that the i-th student has got for the test. Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible; if there are multiple answers, print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Petya is a math teacher. n of his students has written a test consisting of m questions, and for each student, it is known which questions he has answered correctly and which he has not, and if the student answers the j-th question correctly, he earns p_j points where the points for the questions are arranged so that the array p is a rearrangement of numbers from 1 to m. For the i-th student, Petya knows that he expects to get x_i points for the test and wonders how unexpected the results could be, believing that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test. Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible; if there are multiple answers, print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["import sys\n\ndef calculate_surprise_value(n, m, x, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(x[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Sort questions by the number of students who answered them correctly\n        question_correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Sort questions by the number of correct answers in descending order\n        sorted_questions = sorted(range(m), key=lambda j: question_correct_count[j], reverse=True)\n        \n        # Assign points in descending order to questions with more correct answers\n        permutation = [0] * m\n        for idx, question in enumerate(sorted_questions):\n            permutation[question] = m - idx\n        \n        results.append(permutation)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, student_answers, permutation):\n    actual_points = []\n    for answers in student_answers:\n        points = sum(permutation[j] for j in range(m) if answers[j] == '1')\n        actual_points.append(points)\n    surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n    return surprise_value\n\ndef find_max_surprise_permutation(n, m, expected_points, student_answers):\n    max_surprise_value = -1\n    best_permutation = None\n    for perm in permutations(range(1, m + 1)):\n        surprise_value = calculate_surprise_value(n, m, expected_points, student_answers, perm)\n        if surprise_value > max_surprise_value:\n            max_surprise_value = surprise_value\n            best_permutation = perm\n    return best_permutation\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = int(data[index]), int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        student_answers = []\n        for _ in range(n):\n            student_answers.append(data[index])\n            index += 1\n        \n        best_permutation = find_max_surprise_permutation(n, m, expected_points, student_answers)\n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, x, s, p):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(p[j] for j in range(m) if s[i][j] == '1')\n        surprise_value += abs(x[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        s = []\n        for _ in range(n):\n            s.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation of points\n        p = list(range(1, m + 1))\n        \n        # Calculate the surprise value for the initial permutation\n        max_surprise_value = calculate_surprise_value(n, m, x, s, p)\n        best_permutation = p[:]\n        \n        # Iterate over all permutations to find the one with maximum surprise value\n        for perm in itertools.permutations(p):\n            current_surprise_value = calculate_surprise_value(n, m, x, s, perm)\n            if current_surprise_value > max_surprise_value:\n                max_surprise_value = current_surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    # Print the results for each test case\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, correctness_matrix, permutation):\n    actual_points = [0] * n\n    for i in range(n):\n        for j in range(m):\n            if correctness_matrix[i][j] == '1':\n                actual_points[i] += permutation[j]\n    surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n    return surprise_value\n\ndef find_maximum_surprise_permutation(n, m, expected_points, correctness_matrix):\n    max_surprise_value = -1\n    best_permutation = None\n    points = list(range(1, m + 1))\n    \n    for perm in permutations(points):\n        surprise_value = calculate_surprise_value(n, m, expected_points, correctness_matrix, perm)\n        if surprise_value > max_surprise_value:\n            max_surprise_value = surprise_value\n            best_permutation = perm\n    \n    return best_permutation\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        correctness_matrix = []\n        for _ in range(n):\n            correctness_matrix.append(data[index])\n            index += 1\n        \n        best_permutation = find_maximum_surprise_permutation(n, m, expected_points, correctness_matrix)\n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, correctness_matrix, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if correctness_matrix[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef find_max_surprise_permutation(n, m, expected_points, correctness_matrix):\n    max_surprise_value = -1\n    best_permutation = None\n    initial_permutation = list(range(1, m + 1))\n    \n    for perm in permutations(initial_permutation):\n        surprise_value = calculate_surprise_value(n, m, expected_points, correctness_matrix, perm)\n        if surprise_value > max_surprise_value:\n            max_surprise_value = surprise_value\n            best_permutation = perm\n    \n    return best_permutation\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        correctness_matrix = []\n        for _ in range(n):\n            correctness_matrix.append(data[index])\n            index += 1\n        \n        best_permutation = find_max_surprise_permutation(n, m, expected_points, correctness_matrix)\n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we need to maximize the difference\n        # between expected and actual points. This can be achieved by assigning\n        # the highest points to the questions that are most frequently answered\n        # correctly.\n        \n        # Count how many students answered each question correctly\n        correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_count[j] += 1\n        \n        # Create a list of question indices sorted by the number of correct answers\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_count[x])\n        \n        # Assign the highest points to the questions with the least correct answers\n        permutation = [0] * m\n        for i in range(m):\n            permutation[question_indices[i]] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation of points\n        initial_permutation = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(initial_permutation):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\ninput = sys.stdin.read\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    actual_points = []\n    for i in range(n):\n        points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        actual_points.append(points)\n    surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n    return surprise_value\n\ndef main():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = int(data[index]), int(data[index + 1])\n        index += 2\n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        answers = [data[index + i] for i in range(n)]\n        index += n\n        \n        # Generate the permutation of points\n        points = list(range(1, m + 1))\n        max_surprise_value = -1\n        best_permutation = None\n        \n        # Iterate over all permutations\n        for perm in permutations(points):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        question_correct_count = [0] * m\n        for i in range(n):\n            for j in range(m):\n                if answers[i][j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Sort questions by the number of students who answered them correctly\n        sorted_questions = sorted(range(m), key=lambda j: question_correct_count[j])\n        \n        # Assign the highest points to the questions that were answered correctly by the least number of students\n        permutation = [0] * m\n        for i in range(m):\n            permutation[sorted_questions[i]] = i + 1\n        \n        results.append(permutation)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read integers n and m.\",\n        \"Read the list of expected points x for each student.\",\n        \"Read the answer strings for each student.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student has scored based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the score by summing the points for the questions they answered correctly.\",\n        \"Use a permutation of points from 1 to m to calculate the score.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over possible permutations of points from 1 to m.\",\n        \"Calculate the surprise value for each permutation using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Track the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case that maximizes the surprise value.\",\n      \"steps\": [\n        \"For each test case, output the permutation that gives the maximum surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract all necessary data for each test case.\",\n    \"For each test case, generate all possible permutations of the points array.\",\n    \"For each permutation, calculate the actual scores for each student and compute the surprise value.\",\n    \"Identify the permutation that maximizes the surprise value.\",\n    \"Output the identified permutation for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    In the requirement, permutation refers to rearranging the points array from 1 to m to find the configuration that maximizes the surprise value.\n\n    'surprise value'\n    The surprise value is calculated as the sum of the absolute differences between expected points and actual points for each student.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    This indicates that we need to find the permutation that results in the highest possible surprise value.\n\n# [degree adverb] \n    'maximum'\n    This means we need to find the permutation that results in the largest surprise value.\n\n# [code logic]\n    The steps for calculating the actual points and determining the permutation that maximizes the surprise value should be considered simultaneously. Specifically, iterating over permutations and calculating the surprise value should be done in a single loop to efficiently track the maximum surprise value.\n\n# [edge case] \n    Test case with n = 1 and m = 1, x_1 = 0, s_1 = \"0\" = 1\n    Explanation: With only one question and the student expecting 0 points, the permutation [1] results in a surprise value of 1.\n    \n    Test case with n = 1 and m = 1, x_1 = 1, s_1 = \"1\" = 0\n    Explanation: With only one question and the student expecting 1 point, the permutation [1] results in a surprise value of 0.\n    \n    Test case with n = 2 and m = 2, x_1 = 1, x_2 = 2, s_1 = \"01\", s_2 = \"11\" = 1 2\n    Explanation: The permutation [1, 2] results in a surprise value of 1, which is the maximum possible.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially when m is small, to avoid unnecessary computation.\n    Consider using itertools.permutations to generate permutations and a loop to calculate surprise values efficiently.\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: calculate_surprise_value() missing 5 required positional arguments: 'n', 'm', 'expected_points', 'answers', and 'permutation'"}, "Round_1": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the values of n and m.\",\n        \"Read the expected points array x for each student.\",\n        \"Read the answer strings for each student.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student has earned based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the total points earned by summing the points for correctly answered questions.\",\n        \"Use a permutation of points from 1 to m to calculate these points.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"For each permutation of points from 1 to m, calculate the surprise value as the sum of absolute differences between expected and actual points for all students.\",\n        \"Identify the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case that maximizes the surprise value.\",\n      \"steps\": [\n        \"For each test case, print the permutation of points that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract all necessary data for each test case.\",\n    \"For each test case, generate all possible permutations of points from 1 to m.\",\n    \"For each permutation, calculate the actual points for each student and compute the surprise value.\",\n    \"Select the permutation that maximizes the surprise value and store it.\",\n    \"Output the selected permutation for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'surprise value'\n    Explanation: The surprise value is defined as the sum of the absolute differences between the expected points and the actual points earned by each student. The goal is to maximize this value by choosing an optimal permutation of points.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that the permutation of points should be chosen such that the surprise value is as large as possible. In code, this involves iterating over all permutations and selecting the one with the highest calculated surprise value.\n\n# [degree adverb] \n    'maximum'\n    Explanation: The requirement is to find the permutation that results in the largest possible surprise value. This can be implemented by comparing the surprise values of all permutations and selecting the one with the highest value.\n\n# [code logic]\n    The steps for calculating the actual points and determining the permutation that maximizes the surprise value should be considered simultaneously. Specifically, generating permutations and calculating surprise values can be done in a single loop over permutations.\n\n# [edge case] \n    Case 1: n = 1, m = 1, x = [0], s = [\"0\"]\n    Expected output: 1\n    Explanation: With only one question and the student expecting 0 points, the permutation doesn't affect the surprise value, which is 0.\n\n    Case 2: n = 1, m = 1, x = [1], s = [\"1\"]\n    Expected output: 1\n    Explanation: The student expects 1 point and answers correctly, so the permutation doesn't affect the surprise value, which is 0.\n\n    Case 3: n = 2, m = 2, x = [1, 2], s = [\"10\", \"01\"]\n    Expected output: 2 1\n    Explanation: The permutation 2, 1 maximizes the surprise value by creating the largest difference between expected and actual points.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that permutations are generated correctly and that the calculation of surprise values accounts for all possible permutations.\n    ```python\n    from itertools import permutations\n\n    def calculate_surprise_value(n, m, x, answers, permutation):\n        surprise_value = 0\n        for i in range(n):\n            actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n            surprise_value +=", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, x, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(x[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        # Since m can be large, we use a greedy approach instead of generating all permutations\n        # Sort questions by the number of students who answered them correctly\n        question_correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Sort questions by the number of correct answers in descending order\n        sorted_questions = sorted(range(m), key=lambda j: question_correct_count[j], reverse=True)\n        \n        # Assign points in descending order to questions with more correct answers\n        permutation = [0] * m\n        for idx, question in enumerate(sorted_questions):\n            permutation[question] = m - idx\n        \n        # Calculate the surprise value for this permutation\n        surprise_value = calculate_surprise_value(n, m, x, answers, permutation)\n        \n        if surprise_value > max_surprise_value:\n            max_surprise_value = surprise_value\n            best_permutation = permutation\n        \n        results.append(best_permutation)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: calculate_surprise_value() missing 5 required positional arguments: 'n', 'm', 'x', 'answers', and 'permutation'"}, "Round_1": {"code": "import sys\n\ndef calculate_surprise_value(n, m, x, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(x[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Sort questions by the number of students who answered them correctly\n        question_correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Sort questions by the number of correct answers in descending order\n        sorted_questions = sorted(range(m), key=lambda j: question_correct_count[j], reverse=True)\n        \n        # Assign points in descending order to questions with more correct answers\n        permutation = [0] * m\n        for idx, question in enumerate(sorted_questions):\n            permutation[question] = m - idx\n        \n        results.append(permutation)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points, and students' answers.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers for each student.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student has earned based on their answers and the permutation of points.\",\n      \"steps\": [\n        \"Initialize a list to store the actual points for each student.\",\n        \"For each student, calculate the points earned by summing the points of correctly answered questions.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value.\",\n      \"steps\": [\n        \"For each test case, generate all possible permutations of points from 1 to m.\",\n        \"Calculate the surprise value for each permutation using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Select the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation of points that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, calculate the actual points earned by each student based on their answers.\",\n    \"Generate permutations of points and calculate the surprise value for each permutation.\",\n    \"Select and output the permutation that maximizes the surprise value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'surprise value'\n    Explanation: The surprise value is defined as the sum of the absolute differences between the expected points and the actual points earned by each student. The goal is to maximize this value by finding an optimal permutation of points.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that the permutation of points should be chosen such that the surprise value is as large as possible. In code, this involves calculating the surprise value for each permutation and selecting the one with the highest value.\n\n# [degree adverb]\n    'maximum'\n    Explanation: The requirement is to find the permutation that results in the largest possible surprise value. This involves iterating through all permutations and comparing their surprise values to find the greatest one.\n\n# [code logic]\n    The steps for generating permutations and calculating surprise values should be considered simultaneously. Specifically, generating permutations and calculating their surprise values can be done in a single loop where each permutation is evaluated immediately after it is generated.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    0\n    0\n    Expected output: 1\n    Explanation: With only one question and one student expecting 0 points, the permutation is trivial, and the surprise value is 0.\n\n    Test case with all students expecting maximum points:\n    2 2\n    3 3\n    11\n    11\n    Expected output: 2 1\n    Explanation: Both students answered all questions correctly, and the permutation that maximizes the surprise value is any permutation since all permutations result in the same surprise value.\n\n    Test case with no correct answers:\n    3 3\n    0 0 0\n    000\n    000\n    000\n    Expected output: 1 2 3\n    Explanation: No student answered any question correctly, so the permutation does not affect the surprise value, which remains 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of generating permutations and calculating surprise values will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, student_answers, permutation):\n    actual_points = []\n    for answers in student_answers:\n        points = sum(permutation[j] for j in range(m) if answers[j] == '1')\n        actual_points.append(points)\n    surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n    return surprise_value\n\ndef find_max_surprise_permutation(n, m, expected_points, student_answers):\n    max_surprise_value = -1\n    best_permutation = None\n    for perm in permutations(range(1, m + 1)):\n        surprise_value = calculate_surprise_value(n, m, expected_points, student_answers, perm)\n        if surprise_value > max_surprise_value:\n            max_surprise_value = surprise_value\n            best_permutation = perm\n    return best_permutation\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = int(data[index]), int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        student_answers = []\n        for _ in range(n):\n            student_answers.append(data[index])\n            index += 1\n        \n        best_permutation = find_max_surprise_permutation(n, m, expected_points, student_answers)\n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 113)"}, "Round_1": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, student_answers, permutation):\n    actual_points = []\n    for answers in student_answers:\n        points = sum(permutation[j] for j in range(m) if answers[j] == '1')\n        actual_points.append(points)\n    surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n    return surprise_value\n\ndef find_max_surprise_permutation(n, m, expected_points, student_answers):\n    max_surprise_value = -1\n    best_permutation = None\n    for perm in permutations(range(1, m + 1)):\n        surprise_value = calculate_surprise_value(n, m, expected_points, student_answers, perm)\n        if surprise_value > max_surprise_value:\n            max_surprise_value = surprise_value\n            best_permutation = perm\n    return best_permutation\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = int(data[index]), int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        student_answers = []\n        for _ in range(n):\n            student_answers.append(data[index])\n            index += 1\n        \n        best_permutation = find_max_surprise_permutation(n, m, expected_points, student_answers)\n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers matrix.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"output\": \"A list of actual points for each student for a given permutation.\"\n    },\n    {\n      \"description\": \"Compute the surprise value for a given permutation of points by calculating the sum of absolute differences between expected and actual points for all students.\",\n      \"output\": \"The surprise value for a given permutation.\"\n    },\n    {\n      \"description\": \"Generate all possible permutations of the points array and calculate the surprise value for each permutation.\",\n      \"output\": \"A list of surprise values corresponding to each permutation.\"\n    },\n    {\n      \"description\": \"Identify the permutation that results in the maximum surprise value.\",\n      \"output\": \"The permutation of points that maximizes the surprise value.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize the points array as a permutation of numbers from 1 to m.\",\n    \"For each permutation of the points array, calculate the actual points each student received.\",\n    \"Compute the surprise value for each permutation by summing the absolute differences between expected and actual points for all students.\",\n    \"Track the permutation that yields the maximum surprise value.\",\n    \"Output the permutation that results in the maximum surprise value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation refers to an arrangement of the points array, which is a rearrangement of numbers from 1 to m. The task is to find a permutation that maximizes the surprise value.\n\n    'surprise value'\n    Explanation: The surprise value is defined as the sum of the absolute differences between the expected points and the actual points obtained by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that we need to find the permutation that results in the highest possible surprise value. In code, this can be implemented by iterating through all permutations and keeping track of the one with the highest surprise value.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This refers to the largest possible surprise value that can be achieved. In code, this involves comparing the surprise values of different permutations and selecting the largest one.\n\n# [code logic]\n    The steps \"Calculate the actual points each student received\" and \"Compute the surprise value for each permutation\" should be implemented simultaneously. This can be done by iterating through each permutation, calculating the actual points, and immediately computing the surprise value in the same loop.\n\n# [edge case]\n    Edge Case 1: n = 1, m = 1, x = [0], s = [\"0\"]\n    Expected Output: 1\n    Explanation: With only one question and the student expecting 0 points, the permutation doesn't matter as the surprise value will be 0 regardless.\n\n    Edge Case 2: n = 1, m = 10, x = [55], s = [\"1111111111\"]\n    Expected Output: Any permutation of [1, 2, ..., 10]\n    Explanation: The student expects the maximum possible points, so any permutation will result in a surprise value of 0.\n\n    Edge Case 3: n = 10, m = 1, x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], s = [\"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\"]\n    Expected Output: 1\n    Explanation: With only one question and all students expecting 0 points, the permutation doesn't matter as the surprise value will be 0", "Round_0": {"code": "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, x, s, p):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(p[j] for j in range(m) if s[i][j] == '1')\n        surprise_value += abs(x[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        s = []\n        for _ in range(n):\n            s.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation of points\n        p = list(range(1, m + 1))\n        \n        # Calculate the surprise value for the initial permutation\n        max_surprise_value = calculate_surprise_value(n, m, x, s, p)\n        best_permutation = p[:]\n        \n        # Iterate over all permutations to find the one with maximum surprise value\n        for perm in itertools.permutations(p):\n            current_surprise_value = calculate_surprise_value(n, m, x, s, perm)\n            if current_surprise_value > max_surprise_value:\n                max_surprise_value = current_surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    # Print the results for each test case\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: calculate_surprise_value() missing 5 required positional arguments: 'n', 'm', 'x', 's', and 'p'"}, "Round_1": {"code": "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, x, s, p):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(p[j] for j in range(m) if s[i][j] == '1')\n        surprise_value += abs(x[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        s = []\n        for _ in range(n):\n            s.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation of points\n        p = list(range(1, m + 1))\n        \n        # Calculate the surprise value for the initial permutation\n        max_surprise_value = calculate_surprise_value(n, m, x, s, p)\n        best_permutation = p[:]\n        \n        # Iterate over all permutations to find the one with maximum surprise value\n        for perm in itertools.permutations(p):\n            current_surprise_value = calculate_surprise_value(n, m, x, s, perm)\n            if current_surprise_value > max_surprise_value:\n                max_surprise_value = current_surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    # Print the results for each test case\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the correctness matrix for each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student has obtained based on the correctness matrix and a given permutation of points.\",\n      \"output\": \"A list of actual points obtained by each student for a given permutation.\"\n    },\n    {\n      \"description\": \"Compute the surprise value for a given permutation of points by calculating the sum of absolute differences between expected and actual points for all students.\",\n      \"output\": \"The surprise value for the given permutation.\"\n    },\n    {\n      \"description\": \"Generate all possible permutations of the points array and calculate the surprise value for each permutation.\",\n      \"output\": \"A list of surprise values corresponding to each permutation.\"\n    },\n    {\n      \"description\": \"Identify the permutation that results in the maximum surprise value.\",\n      \"output\": \"The permutation of points that maximizes the surprise value.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize the points array as a permutation of numbers from 1 to m.\",\n    \"For each permutation of the points array, calculate the actual points obtained by each student using the correctness matrix.\",\n    \"Compute the surprise value for each permutation by summing the absolute differences between expected and actual points for all students.\",\n    \"Track the permutation that yields the maximum surprise value.\",\n    \"Output the permutation that results in the maximum surprise value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'surprise value'\n    Explanation: The surprise value is defined as the sum of the absolute differences between the expected points and the actual points obtained by each student. The task is to find a permutation of question points that maximizes this surprise value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that we need to find the permutation of points that results in the highest possible surprise value. In code, this means iterating over all permutations and selecting the one with the highest surprise value.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This refers to the largest possible value of the surprise value. In code, this involves comparing the surprise values of different permutations and selecting the largest one.\n\n# [code logic]\n    The steps related to generating permutations and calculating surprise values should be considered simultaneously. Specifically:\n    - \"Generate all possible permutations of the points array and calculate the surprise value for each permutation.\"\n    - \"Identify the permutation that results in the maximum surprise value.\"\n    These steps can be implemented in a single loop where each permutation is generated, its surprise value is calculated, and the maximum is tracked.\n\n# [edge case]\n    1. Test case with n = 1, m = 1, x_1 = 0, s_1 = \"0\" = 1\n       Explanation: With only one question and the student expecting 0 points, the permutation doesn't matter as the surprise value will be 1.\n    2. Test case with n = 1, m = 1, x_1 = 1, s_1 = \"1\" = 1\n       Explanation: With only one question and the student expecting 1 point, the permutation doesn't matter as the surprise value will be 0.\n    3. Test case with n = 2, m = 2, x_1 = 1, x_2 = 2, s_1 = \"10\", s_2 = \"01\" = 2 1\n       Explanation: Both students expect different points, and the permutation that maximizes the surprise value is [2, 1].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of generating permutations and calculating surprise values will naturally handle these cases.\n\nNO", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, correctness_matrix, permutation):\n    actual_points = [0] * n\n    for i in range(n):\n        for j in range(m):\n            if correctness_matrix[i][j] == '1':\n                actual_points[i] += permutation[j]\n    surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n    return surprise_value\n\ndef find_maximum_surprise_permutation(n, m, expected_points, correctness_matrix):\n    max_surprise_value = -1\n    best_permutation = None\n    points = list(range(1, m + 1))\n    \n    for perm in permutations(points):\n        surprise_value = calculate_surprise_value(n, m, expected_points, correctness_matrix, perm)\n        if surprise_value > max_surprise_value:\n            max_surprise_value = surprise_value\n            best_permutation = perm\n    \n    return best_permutation\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        correctness_matrix = []\n        for _ in range(n):\n            correctness_matrix.append(data[index])\n            index += 1\n        \n        best_permutation = find_maximum_surprise_permutation(n, m, expected_points, correctness_matrix)\n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: find_maximum_surprise_permutation() missing 4 required positional arguments: 'n', 'm', 'expected_points', and 'correctness_matrix'"}, "Round_1": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, correctness_matrix, permutation):\n    actual_points = [0] * n\n    for i in range(n):\n        for j in range(m):\n            if correctness_matrix[i][j] == '1':\n                actual_points[i] += permutation[j]\n    surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n    return surprise_value\n\ndef find_maximum_surprise_permutation(n, m, expected_points, correctness_matrix):\n    max_surprise_value = -1\n    best_permutation = None\n    points = list(range(1, m + 1))\n    \n    for perm in permutations(points):\n        surprise_value = calculate_surprise_value(n, m, expected_points, correctness_matrix, perm)\n        if surprise_value > max_surprise_value:\n            max_surprise_value = surprise_value\n            best_permutation = perm\n    \n    return best_permutation\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        correctness_matrix = []\n        for _ in range(n):\n            correctness_matrix.append(data[index])\n            index += 1\n        \n        best_permutation = find_maximum_surprise_permutation(n, m, expected_points, correctness_matrix)\n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the correctness matrix for each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"output\": \"A function that computes the actual points for each student based on a given permutation of question points.\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of absolute differences between expected and actual points for all students.\",\n      \"output\": \"A permutation of question points that maximizes the surprise value.\"\n    },\n    {\n      \"description\": \"Handle multiple test cases and output the result for each test case.\",\n      \"output\": \"A list of permutations, one for each test case, that maximizes the surprise value.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format for each test case.\",\n    \"For each test case, initialize a permutation of question points from 1 to m.\",\n    \"For each permutation, calculate the actual points each student would get and compute the surprise value.\",\n    \"Iterate over possible permutations to find the one that maximizes the surprise value.\",\n    \"Store the optimal permutation for each test case.\",\n    \"Output the optimal permutation for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation refers to an arrangement of the question points from 1 to m. The task is to find a permutation that maximizes the surprise value.\n\n    'surprise value'\n    Explanation: The surprise value is defined as the sum of the absolute differences between the expected points and the actual points obtained by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that the task is to find the permutation that results in the highest possible surprise value. In code, this would involve iterating over permutations and selecting the one with the highest computed surprise value.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This refers to the highest possible value of the surprise value. In code, this can be implemented by keeping track of the highest surprise value encountered during the permutation iterations.\n\n# [code logic]\n    The steps \"For each permutation, calculate the actual points each student would get and compute the surprise value\" and \"Iterate over possible permutations to find the one that maximizes the surprise value\" should be implemented simultaneously. This can be done by iterating over permutations and calculating the surprise value in the same loop.\n\n# [edge case]\n    1. Test case with n = 1, m = 1, x_1 = 0, s_1 = \"0\" = 1\n       Explanation: With only one question and the student expecting 0 points, the permutation doesn't matter as the surprise value will be 0.\n    2. Test case with n = 1, m = 1, x_1 = 1, s_1 = \"1\" = 1\n       Explanation: With only one question and the student expecting 1 point, the permutation doesn't matter as the surprise value will be 0.\n    3. Test case with n = 2, m = 2, x_1 = 1, x_2 = 2, s_1 = \"10\", s_2 = \"01\" = 2 1\n       Explanation: Both students expect different points, and the permutation should maximize the difference between expected and actual points.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over permutations and calculating the surprise value will naturally handle these cases.\n\nNO", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, correctness_matrix, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if correctness_matrix[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef find_max_surprise_permutation(n, m, expected_points, correctness_matrix):\n    max_surprise_value = -1\n    best_permutation = None\n    initial_permutation = list(range(1, m + 1))\n    \n    for perm in permutations(initial_permutation):\n        surprise_value = calculate_surprise_value(n, m, expected_points, correctness_matrix, perm)\n        if surprise_value > max_surprise_value:\n            max_surprise_value = surprise_value\n            best_permutation = perm\n    \n    return best_permutation\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        correctness_matrix = []\n        for _ in range(n):\n            correctness_matrix.append(data[index])\n            index += 1\n        \n        best_permutation = find_max_surprise_permutation(n, m, expected_points, correctness_matrix)\n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers given by each student as binary strings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student has earned based on their answers and a permutation of points for the questions.\",\n      \"steps\": [\n        \"For each test case, initialize a permutation of points for the questions from 1 to m.\",\n        \"Calculate the actual points earned by each student using the permutation and their answers.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over possible permutations of points.\",\n        \"Calculate the surprise value for each permutation using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Select the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation of points that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, calculate the actual points earned by each student using a permutation of points.\",\n    \"Iterate over possible permutations to find the one that maximizes the surprise value.\",\n    \"Output the permutation for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    In the requirement, permutation refers to rearranging the points assigned to questions such that the surprise value is maximized.\n\n    'surprise value'\n    The surprise value is calculated as the sum of the absolute differences between expected points and actual points for each student.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    This indicates that we need to find the permutation that results in the highest possible surprise value.\n\n# [degree adverb] \n    'maximum'\n    This means we need to find the permutation that results in the largest surprise value.\n\n# [code logic]\n    The steps for calculating the actual points and determining the permutation that maximizes the surprise value should be considered simultaneously. Specifically, iterating over possible permutations and calculating the surprise value should be done in a single loop to efficiently find the optimal permutation.\n\n# [edge case] \n    Test case with minimum values:\n    1 1\n    0\n    0\n    Expected output: 1\n    Explanation: With only one question and no points expected, the permutation is trivial.\n\n    Test case with all students expecting zero points:\n    3 3\n    0 0 0\n    000\n    000\n    000\n    Expected output: 1 2 3\n    Explanation: Since all students expect zero points, any permutation will result in the same surprise value.\n\n    Test case with maximum m:\n    1 10000\n    50005000\n    111...111 (10000 times)\n    Expected output: 10000 9999 ... 1\n    Explanation: The permutation should be in descending order to maximize the surprise value when all questions are answered correctly.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially for large values of m.\n    - For the case where all students expect zero points, the permutation can be any order.\n    - For large m, ensure the permutation generation is efficient to handle the constraints.\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we need to maximize the difference\n        # between expected and actual points. This can be achieved by assigning\n        # the highest points to the questions that are most frequently answered\n        # correctly.\n        \n        # Count how many students answered each question correctly\n        correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_count[j] += 1\n        \n        # Create a list of question indices sorted by the number of correct answers\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_count[x])\n        \n        # Assign the highest points to the questions with the least correct answers\n        permutation = [0] * m\n        for i in range(m):\n            permutation[question_indices[i]] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 137)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we need to maximize the difference\n        # between expected and actual points. This can be achieved by assigning\n        # the highest points to the questions that are most frequently answered\n        # correctly.\n        \n        # Count how many students answered each question correctly\n        correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_count[j] += 1\n        \n        # Create a list of question indices sorted by the number of correct answers\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_count[x])\n        \n        # Assign the highest points to the questions with the least correct answers\n        permutation = [0] * m\n        for i in range(m):\n            permutation[question_indices[i]] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points, and students' answers.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers for each student as binary strings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student has earned based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the points earned by summing the points of correctly answered questions.\",\n        \"Use a permutation of points to determine the points for each question.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"Calculate the surprise value for a given permutation as the sum of absolute differences between expected and actual points for all students.\",\n        \"Iterate over possible permutations of points to find the one that maximizes the surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation of points that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract relevant information for each test case.\",\n    \"For each test case, iterate over possible permutations of points.\",\n    \"Calculate the actual points earned by each student for each permutation.\",\n    \"Compute the surprise value for each permutation and track the maximum surprise value.\",\n    \"Output the permutation that results in the maximum surprise value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'surprise value'\n    Explanation: The surprise value is defined as the sum of the absolute differences between the expected points and the actual points each student receives. The task is to find a permutation of question points that maximizes this surprise value.\n\n# [phrase showing quantity relationship]\n    'maximum possible': This indicates that we need to find the permutation that results in the highest possible surprise value.\n    Implementation: Iterate over permutations and calculate the surprise value for each, keeping track of the maximum.\n\n# [degree adverb]\n    'maximum': This refers to the highest possible surprise value that can be achieved.\n    Implementation: Use a variable to store the maximum surprise value found during iteration over permutations.\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the calculation of the actual points and the surprise value should be done simultaneously for each permutation. This can be done in a nested loop where the outer loop iterates over permutations and the inner loop calculates the points and surprise value.\n\n# [edge case]\n    Edge Case 1: n = 1, m = 1, x = [0], s = [\"0\"]\n    Expected Output: 1\n    Explanation: With only one question and the student expecting 0 points, any permutation will result in a surprise value of 0.\n\n    Edge Case 2: n = 1, m = 1, x = [1], s = [\"1\"]\n    Expected Output: 1\n    Explanation: The student expects 1 point and answers correctly, so the permutation should assign 1 point to the question.\n\n    Edge Case 3: n = 2, m = 2, x = [1, 2], s = [\"10\", \"01\"]\n    Expected Output: 2 1\n    Explanation: The permutation should maximize the surprise value by assigning higher points to the question answered by the student expecting fewer points.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    The code should handle cases where the number of questions is minimal and ensure that permutations are generated correctly even for small inputs.\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation of points\n        initial_permutation = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(initial_permutation):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 111)"}, "Round_1": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation of points\n        initial_permutation = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(initial_permutation):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points for each student, and the answers matrix for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers matrix for each student.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student has earned based on their answers and the permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the number of questions answered correctly.\",\n        \"Determine the permutation of points that maximizes the surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"For each test case, generate all possible permutations of points from 1 to m.\",\n        \"Calculate the surprise value for each permutation.\",\n        \"Select the permutation with the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation of points that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, calculate the actual points earned by each student based on their answers.\",\n    \"Generate all possible permutations of points and calculate the surprise value for each permutation.\",\n    \"Select the permutation with the maximum surprise value and store it.\",\n    \"Output the selected permutation for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation refers to an arrangement of the points assigned to each question. The task is to find a permutation that maximizes the surprise value.\n\n    'surprise value'\n    Explanation: The surprise value is defined as the sum of the absolute differences between the expected points and the actual points obtained by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that we need to find the permutation that results in the highest possible surprise value. In code, this means iterating over all permutations and selecting the one with the highest calculated surprise value.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This refers to the highest possible value of the surprise value. In code, this involves comparing calculated surprise values and keeping track of the highest one.\n\n# [code logic]\n    The steps in the plan related to generating permutations and calculating surprise values should be considered simultaneously. Specifically:\n    - \"Generate all possible permutations of points from 1 to m.\"\n    - \"Calculate the surprise value for each permutation.\"\n    These can be implemented in a single loop where each permutation is generated and its surprise value is calculated immediately.\n\n# [edge case]\n    Edge Case 1: n = 1, m = 1, x = [0], s = [\"0\"]\n    Expected Output: 1\n    Explanation: With only one question and the student expecting 0 points, the permutation doesn't matter as the surprise value will be 0 regardless.\n\n    Edge Case 2: n = 1, m = 10, x = [55], s = [\"1111111111\"]\n    Expected Output: 10 9 8 7 6 5 4 3 2 1\n    Explanation: The student expects the maximum possible points, so the permutation should be in descending order to maximize the surprise value.\n\n    Edge Case 3: n = 10, m = 1, x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], s = [\"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\"]\n    Expected Output: 1\n    Explanation: With all students expecting 0 points and no questions answered correctly, the permutation doesn't", "Round_0": {"code": "import sys\ninput = sys.stdin.read\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    actual_points = []\n    for i in range(n):\n        points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        actual_points.append(points)\n    surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n    return surprise_value\n\ndef main():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = int(data[index]), int(data[index + 1])\n        index += 2\n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        answers = [data[index + i] for i in range(n)]\n        index += n\n        \n        # Generate the permutation of points\n        points = list(range(1, m + 1))\n        max_surprise_value = -1\n        best_permutation = None\n        \n        # Iterate over all permutations\n        for perm in permutations(points):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 97)"}, "Round_1": {"code": "import sys\ninput = sys.stdin.read\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    actual_points = []\n    for i in range(n):\n        points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        actual_points.append(points)\n    surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n    return surprise_value\n\ndef main():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = int(data[index]), int(data[index + 1])\n        index += 2\n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        answers = [data[index + i] for i in range(n)]\n        index += n\n        \n        # Generate the permutation of points\n        points = list(range(1, m + 1))\n        max_surprise_value = -1\n        best_permutation = None\n        \n        # Iterate over all permutations\n        for perm in permutations(points):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"output\": \"A function that computes the actual points for each student based on a given permutation of question points.\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of absolute differences between expected and actual points for all students.\",\n      \"output\": \"A permutation of question points that maximizes the surprise value.\"\n    },\n    {\n      \"description\": \"Handle multiple test cases and ensure the solution is efficient given the constraints.\",\n      \"output\": \"A loop or structure that processes each test case independently and efficiently.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Parse the number of students (n) and questions (m).\",\n    \"  b. Parse the expected points for each student.\",\n    \"  c. Parse the answers given by each student.\",\n    \"  d. Generate all possible permutations of question points from 1 to m.\",\n    \"  e. For each permutation, calculate the actual points for each student and compute the surprise value.\",\n    \"  f. Track the permutation that results in the maximum surprise value.\",\n    \"  g. Store the permutation with the maximum surprise value for output.\",\n    \"Output the permutation for each test case that maximizes the surprise value.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation refers to an arrangement of the question points from 1 to m. The task is to find a permutation that maximizes the surprise value.\n\n    'surprise value'\n    Explanation: The surprise value is defined as the sum of the absolute differences between the expected points and the actual points obtained by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that we need to find the permutation that results in the highest possible surprise value. In code, this can be implemented by iterating over all permutations and selecting the one with the highest surprise value.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This refers to the highest possible value of the surprise value. In code, this can be implemented by keeping track of the highest surprise value encountered during the permutation checks.\n\n# [code logic]\n    Steps 2e and 2f should be implemented simultaneously. Specifically, while calculating the actual points for each permutation, the surprise value should be computed and compared to the current maximum surprise value. This can be done in a single loop over permutations.\n\n# [edge case]\n    Case 1: n = 1, m = 1, x = [0], s = [\"0\"]\n    Expected output: 1\n    Explanation: With only one question and the student expecting 0 points, any permutation will result in a surprise value of 0.\n\n    Case 2: n = 1, m = 1, x = [1], s = [\"1\"]\n    Expected output: 1\n    Explanation: The student expects 1 point and answers correctly, so the surprise value is 0, which is the maximum possible.\n\n    Case 3: n = 2, m = 2, x = [1, 1], s = [\"10\", \"01\"]\n    Expected output: 2 1\n    Explanation: Both students expect 1 point, and the permutation 2 1 maximizes the surprise value by giving the first student 2 points and the second student 1 point.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over permutations and calculating the surprise value will naturally handle these cases.\n\nNO", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the permutation of points from 1 to m\n        best_permutation = None\n        max_surprise_value = -1\n        \n        # Since m can be large, we need an efficient way to find the best permutation\n        # Instead of generating all permutations, we can use a greedy approach\n        # Sort students by their expected points\n        sorted_students = sorted(range(n), key=lambda i: expected_points[i])\n        \n        # Sort questions by the number of students who answered them correctly\n        question_correct_count = [0] * m\n        for i in range(n):\n            for j in range(m):\n                if answers[i][j] == '1':\n                    question_correct_count[j] += 1\n        \n        sorted_questions = sorted(range(m), key=lambda j: question_correct_count[j])\n        \n        # Assign the highest points to the questions that were answered correctly by the least number of students\n        permutation = [0] * m\n        for i in range(m):\n            permutation[sorted_questions[i]] = i + 1\n        \n        # Calculate the surprise value for this permutation\n        surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n        \n        if surprise_value > max_surprise_value:\n            max_surprise_value = surprise_value\n            best_permutation = permutation\n        \n        results.append(best_permutation)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: calculate_surprise_value() missing 5 required positional arguments: 'n', 'm', 'expected_points', 'answers', and 'permutation'"}, "Round_1": {"code": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        question_correct_count = [0] * m\n        for i in range(n):\n            for j in range(m):\n                if answers[i][j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Sort questions by the number of students who answered them correctly\n        sorted_questions = sorted(range(m), key=lambda j: question_correct_count[j])\n        \n        # Assign the highest points to the questions that were answered correctly by the least number of students\n        permutation = [0] * m\n        for i in range(m):\n            permutation[sorted_questions[i]] = i + 1\n        \n        results.append(permutation)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read integers n and m.\",\n        \"Read the list of expected points x for each student.\",\n        \"Read the answer strings for each student.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student has scored based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the score by summing the points for the questions they answered correctly.\",\n        \"Use a permutation of points from 1 to m to calculate the score.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over possible permutations of points from 1 to m.\",\n        \"Calculate the surprise value for each permutation using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Track the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case that maximizes the surprise value.\",\n      \"steps\": [\n        \"For each test case, output the permutation that gives the maximum surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract all necessary data for each test case.\",\n    \"For each test case, generate all possible permutations of the points array.\",\n    \"For each permutation, calculate the actual scores for each student and compute the surprise value.\",\n    \"Identify the permutation that maximizes the surprise value.\",\n    \"Output the identified permutation for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    In the requirement, permutation refers to rearranging the points array from 1 to m to find the configuration that maximizes the surprise value.\n\n    'surprise value'\n    The surprise value is calculated as the sum of the absolute differences between expected points and actual points for each student.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    This indicates that we need to find the permutation that results in the highest possible surprise value.\n\n# [degree adverb] \n    'maximum'\n    This means we need to find the permutation that results in the largest surprise value.\n\n# [code logic]\n    The steps for calculating the actual points and determining the permutation that maximizes the surprise value should be considered simultaneously. Specifically, iterating over permutations and calculating the surprise value should be done in a single loop to efficiently track the maximum surprise value.\n\n# [edge case] \n    Test case with n = 1 and m = 1, x_1 = 0, s_1 = \"0\" = 1\n    Explanation: With only one question and the student expecting 0 points, the permutation [1] results in a surprise value of 1.\n    \n    Test case with n = 1 and m = 1, x_1 = 1, s_1 = \"1\" = 0\n    Explanation: With only one question and the student expecting 1 point, the permutation [1] results in a surprise value of 0.\n    \n    Test case with n = 2 and m = 2, x_1 = 1, x_2 = 2, s_1 = \"01\", s_2 = \"11\" = 1 2\n    Explanation: The permutation [1, 2] results in a surprise value of 1, which is the maximum possible.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially when m is small, to avoid unnecessary computation.\n    Consider using itertools.permutations to generate permutations and a loop to calculate surprise values efficiently.\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: calculate_surprise_value() missing 5 required positional arguments: 'n', 'm', 'expected_points', 'answers', and 'permutation'"}, "Round_1": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}], "scores": [], "pass_results": [true, true, true, true, true, true, false, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 681, "prompt": "Petya is a math teacher. n of his students has written a test consisting of m questions, and for each student, it is known which questions he has answered correctly and which he has not. If the student answers the j-th question correctly, he earns p_j points where the points for the questions are arranged so that the array p is a rearrangement of numbers from 1 to m. For the i-th student, Petya knows that he expects to get x_i points for the test and wonders how unexpected the results could be, believing that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test. Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible; if there are multiple answers, print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 ", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 ", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 354}
