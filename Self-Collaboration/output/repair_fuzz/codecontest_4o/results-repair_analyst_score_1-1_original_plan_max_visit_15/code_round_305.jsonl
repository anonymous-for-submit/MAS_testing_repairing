{"name": "1615_A. Closing The Gap", "description": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\n\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "tags": ["greedy", "math"], "difficulty": 7, "id": 1615, "sample_io": [{"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}], "test_list": [{"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n1 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 3 -1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 0\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 1 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 10 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 5 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 0\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 4\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 0 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 0\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n1 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n24 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 -1 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n24 9 15\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n0 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n36 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 1\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n41 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 10 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 5\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 0 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 9\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n4 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n3 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n1 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n0 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n15 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 0 1 2\n5\n0 2 3 1 0\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 2 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 5 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n4 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 17 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 0 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n4 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 -1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 10\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n13 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 31 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n15 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 0 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n6 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 0 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n1 3 6 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 15\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 2 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 16\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 -1 3\n5\n0 3 6 1 5\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n11 12 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 2 4\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 2\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 0 6 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 1\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 14 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 2 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 14\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n1 3 10 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 19\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n0 0 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n-1 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 1\n5\n0 2 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 7\n", "output": ["0\n1\n0\n"]}], "task_id": "codecontest/119", "repair_prompt": ["There are n block towers in a row, where tower i has a height of a_i. You're part of a construction team, and in one day, you can execute an operation to make the towers look as nice as possible: choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j). In this operation, you move a block from tower i to tower j, essentially decreasing a_i by 1 and increasing a_j by 1. You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "There are n block towers in a row, where tower i has a height of a_i. You're part of a construction team. In one day, you can execute an operation to make the towers look as nice as possible. During this operation, you choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j). In this operation, you move a block from tower i to tower j, essentially decreasing a_i by 1 and increasing a_j by 1. You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "There are n block towers in a row, where tower i has a height of a_i. You're part of a construction team, and in one day, you can execute an operation to make the towers look as nice as possible: choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), moving a block from tower i to tower j, essentially decreasing a_i by 1 and increasing a_j by 1. You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(heights)\n        \n        # If the total sum is perfectly divisible by n, we can make all towers equal\n        if total_sum % n == 0:\n            results.append(0)\n        else:\n            # If not, the minimum possible ugliness is 1\n            results.append(1)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def minimum_ugliness(test_cases):\n    results = []\n    for heights in test_cases:\n        total_blocks = sum(heights)\n        n = len(heights)\n        \n        # Calculate the target height for equal distribution\n        target_height = total_blocks // n\n        if total_blocks % n != 0:\n            target_height += 1\n        \n        # Calculate the minimum possible ugliness\n        min_ugliness = max(heights) - min(heights)\n        \n        # If the total number of blocks is perfectly divisible by n, ugliness can be 0\n        if total_blocks % n == 0:\n            min_ugliness = 0\n        else:\n            # Otherwise, the minimum ugliness is 1\n            min_ugliness = 1\n        \n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append(heights)\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        # Calculate the average height\n        avg_height = total_height // n\n        # Calculate the remainder\n        remainder = total_height % n\n        # The minimum possible ugliness is 1 if there is a remainder, otherwise 0\n        min_ugliness = 1 if remainder else 0\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_ugliness(heights):\n    total_blocks = sum(heights)\n    n = len(heights)\n    average_height = total_blocks // n\n    remainder = total_blocks % n\n    # Calculate ugliness based on distribution\n    return 1 if remainder > 0 else 0\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        \n        ugliness = calculate_minimum_ugliness(heights)\n        results.append(ugliness)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_ugliness(t, test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average_height = total_sum // n\n        floor_target = average_height\n        ceiling_target = average_height + (1 if total_sum % n != 0 else 0)\n        \n        # Calculate the number of blocks needed to reach each target height\n        floor_excess = sum(max(0, h - floor_target) for h in heights)\n        ceiling_deficit = sum(max(0, ceiling_target - h) for h in heights)\n        \n        # The minimum ugliness is determined by the maximum of the two\n        min_ugliness = max(floor_excess, ceiling_deficit)\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = calculate_minimum_ugliness(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        # Calculate the average height\n        avg_floor = total_height // n\n        avg_ceil = (total_height + n - 1) // n  # Equivalent to math.ceil(total_height / n)\n\n        # Calculate potential ugliness for both floor and ceiling averages\n        ugliness_floor = max(heights) - min(heights)\n        if total_height % n == 0:\n            # If total height is perfectly divisible by n, we can make all heights equal\n            results.append(0)\n        else:\n            # Otherwise, the minimum ugliness is 1\n            results.append(1)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        avg_floor = total_height // n\n        avg_ceil = avg_floor if total_height % n == 0 else avg_floor + 1\n        \n        # Calculate how many towers should have height avg_floor and avg_ceil\n        count_ceil = total_height % n\n        count_floor = n - count_ceil\n        \n        # The minimum ugliness is the difference between avg_ceil and avg_floor\n        min_ugliness = avg_ceil - avg_floor\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_ugliness(heights):\n    total_blocks = sum(heights)\n    n = len(heights)\n    average_height = total_blocks // n\n    remainder = total_blocks % n\n    \n    # Sort heights to redistribute blocks\n    heights.sort()\n    \n    # Redistribute blocks to minimize ugliness\n    for i in range(n):\n        if i < remainder:\n            heights[i] = average_height + 1\n        else:\n            heights[i] = average_height\n    \n    return max(heights) - min(heights)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = calculate_minimum_ugliness(heights)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average_height = total_sum // n\n        remainder = total_sum % n\n        \n        # Calculate the minimum possible ugliness\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        max_height = max(heights)\n        min_height = min(heights)\n        results.append(max_height - min_height)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(heights)\n        \n        # If the total sum is perfectly divisible by n, we can make all towers equal\n        if total_sum % n == 0:\n            results.append(0)\n        else:\n            # If not, the minimum possible ugliness is 1\n            results.append(1)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Read the integer t, which represents the number of test cases. For each test case, read the integer n (number of buildings) and the list of integers representing the heights of the buildings.\"\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"details\": \"For each test case, determine the minimum and maximum heights of the buildings. Calculate the total sum of the heights. Compute the average height by dividing the total sum by n. Determine the minimum possible ugliness by considering the distribution of blocks to achieve heights as close to the average as possible.\"\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, output the calculated minimum possible ugliness.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases, t.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the number of buildings, n, and their respective heights.\",\n    \"  b. Calculate the total sum of the heights.\",\n    \"  c. Compute the average height by dividing the total sum by n.\",\n    \"  d. Determine the minimum and maximum heights of the buildings.\",\n    \"  e. Calculate the minimum possible ugliness by redistributing blocks to achieve heights as close to the average as possible.\",\n    \"  f. Output the minimum possible ugliness for the current test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'minimum possible ugliness'\n    Explanation: This refers to the smallest value of ugliness that can be achieved by redistributing blocks between towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible'\n    Explanation: This indicates the need to find the smallest achievable value of ugliness after redistributing blocks.\n\n# [degree adverb] \n    'minimum'\n    Explanation: This means the smallest value that can be achieved, which in this context is the smallest difference between the tallest and shortest buildings.\n\n# [code logic]\n    Steps 2b, 2c, and 2e should be considered simultaneously.\n    Explanation: Calculating the total sum, computing the average, and determining the minimum possible ugliness are interrelated and should be handled in a single logical block to ensure the redistribution of blocks is optimal.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 10000000]\n    Expected output: 0\n    Explanation: With only two towers, you can move blocks from the taller to the shorter until they are equal.\n\n    Case 2: n = 3, heights = [1, 1, 10000000]\n    Expected output: 0\n    Explanation: You can redistribute blocks from the tallest to the other two until all are equal.\n\n    Case 3: n = 4, heights = [1, 1, 1, 10000000]\n    Expected output: 0\n    Explanation: You can redistribute blocks from the tallest to the other three until all are equal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases.\n    Explanation: The original logic of redistributing blocks to achieve heights as close to the average as possible inherently handles these edge cases. The key is to ensure that the redistribution logic is correctly implemented to balance the heights optimally.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average_height = total_sum // n\n        # Calculate the minimum possible ugliness\n        min_ugliness = max(heights) - min(heights)\n        if total_sum % n == 0:\n            min_ugliness = 0\n        else:\n            min_ugliness = 1\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: minimum_ugliness() missing 1 required positional argument: 'test_cases'"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(heights)\n        \n        # If the total sum is perfectly divisible by n, we can make all towers equal\n        if total_sum % n == 0:\n            results.append(0)\n        else:\n            # If not, the minimum possible ugliness is 1\n            results.append(1)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Read the integer t representing the number of test cases. For each test case, read the integer n representing the number of buildings and the list of integers representing the heights of the buildings.\"\n    },\n    {\n      \"subproblem\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"details\": \"For each test case, determine the minimum and maximum heights of the buildings. Calculate the difference between the maximum and minimum heights. If the difference is zero, the ugliness is already minimized. Otherwise, redistribute the blocks to minimize the difference.\"\n    },\n    {\n      \"subproblem\": \"Redistribute blocks to minimize the height difference.\",\n      \"details\": \"Iteratively move blocks from the tallest building to the shortest building until the height difference is minimized. Ensure that the redistribution process is efficient and terminates when the minimum possible ugliness is achieved.\"\n    },\n    {\n      \"subproblem\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, output the calculated minimum possible ugliness.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Input Parsing\",\n      \"action\": \"Read the number of test cases. For each test case, read the number of buildings and their respective heights.\"\n    },\n    {\n      \"step\": \"Ugliness Calculation\",\n      \"action\": \"For each test case, calculate the initial ugliness as the difference between the maximum and minimum heights.\"\n    },\n    {\n      \"step\": \"Block Redistribution\",\n      \"action\": \"If the initial ugliness is not zero, redistribute blocks between buildings to minimize the height difference. Use a loop to move blocks from the tallest to the shortest building until the difference is minimized.\"\n    },\n    {\n      \"step\": \"Output Results\",\n      \"action\": \"Print the minimum possible ugliness for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means we need to find the smallest value of max(a) - min(a) after redistributing blocks between towers. In code, this involves iteratively adjusting the heights to reduce the difference.\n\n# [degree adverb] \n    'tallest', 'shortest'\n    Explanation: These refer to the maximum and minimum values in the list of building heights. In code, this can be implemented using the max() and min() functions.\n\n# [code logic]\n    The steps \"Ugliness Calculation\" and \"Block Redistribution\" should be considered simultaneously. After calculating the initial ugliness, if it's not zero, the redistribution process should be initiated immediately to minimize the height difference.\n\n# [edge case] \n    Test case with all towers having the same height: [5, 5, 5, 5] = 0\n    Explanation: Since all towers have the same height, the ugliness is already minimized to 0.\n    \n    Test case with two towers having extreme heights: [1, 10000000] = 0\n    Explanation: Blocks can be moved from the taller tower to the shorter one until both have the same height, resulting in an ugliness of 0.\n    \n    Test case with incremental heights: [1, 2, 3, 4, 5] = 0\n    Explanation: Blocks can be redistributed to make all towers have the same height, resulting in an ugliness of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The redistribution logic should ensure that blocks are moved efficiently to achieve equal heights when possible.\n    Example code for handling redistribution:\n    ```python\n    def redistribute_blocks(heights):\n        total_blocks = sum(heights)\n        n = len(heights)\n        target_height = total_blocks // n\n        if total_blocks % n != 0:\n            target_height += 1\n        return target_height\n\n    for test_case in test_cases:\n        heights = test_case\n        target_height = redistribute_blocks(heights)\n        # Implement logic to adjust heights to target_height\n    ```\n\nYES", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for heights in test_cases:\n        total_blocks = sum(heights)\n        n = len(heights)\n        \n        # Calculate the target height for equal distribution\n        target_height = total_blocks // n\n        if total_blocks % n != 0:\n            target_height += 1\n        \n        # Calculate the minimum possible ugliness\n        min_ugliness = max(heights) - min(heights)\n        \n        # If the total number of blocks is perfectly divisible by n, ugliness can be 0\n        if total_blocks % n == 0:\n            min_ugliness = 0\n        else:\n            # Otherwise, the minimum ugliness is 1\n            min_ugliness = 1\n        \n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append(heights)\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the heights of the buildings.\",\n        \"Calculate the average height by dividing the total sum by n.\",\n        \"Determine the minimum possible ugliness by considering the distribution of blocks to make the heights as equal as possible.\",\n        \"The minimum possible ugliness is the difference between the maximum and minimum possible heights after redistribution.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each test case.\",\n    \"For each test case, calculate the total sum of the heights and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to minimize the height difference.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the context of this problem, ugliness is defined as the difference between the tallest and shortest buildings after redistributing blocks. The goal is to minimize this difference.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': This means finding the smallest possible value of the difference between the maximum and minimum heights of the towers after redistribution.\n    'as nice as possible': This implies making the heights of the towers as equal as possible, which directly relates to minimizing the ugliness.\n\n# [degree adverb]\n    'minimum': This indicates that the goal is to achieve the smallest possible ugliness, which is the smallest difference between the tallest and shortest towers.\n\n# [code logic]\n    The steps in the plan related to calculating the total sum, average height, and determining the minimum possible ugliness should be considered simultaneously. Specifically, calculating the average height and determining the minimum possible ugliness are closely related and can be implemented in a single code block.\n\n# [edge case]\n    1. Test case with all towers having the same height: \n       Input: 3\n              3\n              5 5 5\n       Expected output: 0\n       Explanation: All towers are already of equal height, so the ugliness is 0.\n\n    2. Test case with two towers of different heights:\n       Input: 1\n              2\n              1 10\n       Expected output: 0\n       Explanation: You can move blocks from the taller tower to the shorter one until both are equal.\n\n    3. Test case with maximum height difference:\n       Input: 1\n              3\n              1 1 10\n       Expected output: 1\n       Explanation: You can redistribute blocks to make the heights [4, 4, 4], resulting in an ugliness of 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to minimize the height difference will naturally handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        # Calculate the average height\n        avg_height = total_height // n\n        # Calculate the remainder\n        remainder = total_height % n\n        # The minimum possible ugliness is 1 if there is a remainder, otherwise 0\n        min_ugliness = 1 if remainder else 0\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the sum by the number of buildings.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks to achieve heights as close to the average as possible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the sum of the heights and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to achieve heights close to the average.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means finding the smallest possible value of max(a) - min(a) after redistributing the blocks among the towers.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The requirement is to achieve the smallest possible ugliness, which involves redistributing blocks to make the heights of the towers as equal as possible.\n\n# [code logic]\n    The steps for calculating the sum of heights, determining the average height, and calculating the minimum possible ugliness should be considered simultaneously. This can be done by iterating through the heights, calculating the sum, and then using the sum to determine the average and redistribute blocks accordingly.\n\n# [edge case]\n    Case 1: Input: 2 1 1\n    Expected Output: 0\n    Explanation: Both towers have the same height, so the ugliness is already 0.\n\n    Case 2: Input: 3 1 1 10\n    Expected Output: 0\n    Explanation: Redistribute blocks from the tallest tower to the shortest ones to make all heights equal.\n\n    Case 3: Input: 4 1 1 1 10\n    Expected Output: 1\n    Explanation: After redistribution, the closest possible equal heights are [3, 3, 3, 4], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling the edge case:\n    ```python\n    def calculate_minimum_ugliness(heights):\n        total_blocks = sum(heights)\n        n = len(heights)\n        average_height = total_blocks // n\n        remainder = total_blocks % n\n        # Calculate ugliness based on distribution\n        return 1 if remainder > 0 else 0\n    ```\n\nYES", "Round_0": {"code": "def calculate_minimum_ugliness(heights):\n    total_blocks = sum(heights)\n    n = len(heights)\n    average_height = total_blocks // n\n    remainder = total_blocks % n\n    # Calculate ugliness based on distribution\n    return 1 if remainder > 0 else 0\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        \n        ugliness = calculate_minimum_ugliness(heights)\n        results.append(ugliness)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of towers and their respective heights.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of towers.\",\n        \"Read the list of integers representing the heights of the towers.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the tower heights.\",\n        \"Determine the average height by dividing the total sum by the number of towers, n.\",\n        \"Calculate the floor and ceiling of the average height to determine the two possible target heights for redistribution.\",\n        \"Calculate the total number of blocks needed to reach each target height from the current heights.\",\n        \"Determine the minimum possible ugliness by finding the difference between the maximum and minimum heights after redistribution.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the tower heights.\",\n    \"Determine the average height and calculate the floor and ceiling of this average.\",\n    \"Calculate the number of blocks needed to reach each target height.\",\n    \"Determine the minimum possible ugliness by comparing the results for the two target heights.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means finding the smallest value of max(a) - min(a) after redistributing the blocks among the towers.\n\n# [degree adverb] \n    'minimum'\n    Explanation: The requirement is asking for the smallest possible value of ugliness after redistribution.\n\n# [code logic]\n    The steps for calculating the total sum, determining the average height, and calculating the floor and ceiling of the average should be considered simultaneously. These calculations are interdependent and should be done in one code block to ensure accurate redistribution of blocks.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 1] => Expected output: 0\n    Explanation: Both towers are already equal, so the ugliness is 0.\n    \n    Case 2: n = 3, heights = [1, 1, 10] => Expected output: 0\n    Explanation: Redistribute blocks from the tallest tower to the shortest towers to make all heights equal, resulting in ugliness of 0.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 10] => Expected output: 1\n    Explanation: After redistribution, the closest possible equal heights are [3, 3, 3, 4], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling the edge case:\n    ```python\n    def calculate_minimum_ugliness(t, test_cases):\n        results = []\n        for n, heights in test_cases:\n            total_sum = sum(heights)\n            average_height = total_sum // n\n            floor_target = average_height\n            ceiling_target = average_height + (1 if total_sum % n != 0 else 0)\n            \n            # Calculate ugliness for both floor and ceiling targets\n            floor_ugliness = max(heights) - min(heights)\n            ceiling_ugliness = max(heights) - min(heights)\n            \n            # Choose the minimum ugliness\n            min_ugliness = min(floor_ugliness, ceiling_ugliness)\n            results", "Round_0": {"code": "def calculate_minimum_ugliness(t, test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average_height = total_sum // n\n        floor_target = average_height\n        ceiling_target = average_height + (1 if total_sum % n != 0 else 0)\n        \n        # Calculate the number of blocks needed to reach each target height\n        floor_excess = sum(max(0, h - floor_target) for h in heights)\n        ceiling_deficit = sum(max(0, ceiling_target - h) for h in heights)\n        \n        # The minimum ugliness is determined by the maximum of the two\n        min_ugliness = max(floor_excess, ceiling_deficit)\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = calculate_minimum_ugliness(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the building heights.\",\n        \"Determine the average height by dividing the total sum by n and consider both floor and ceiling values of this average.\",\n        \"Calculate the potential ugliness for both floor and ceiling values by redistributing the blocks to make all buildings as close to these values as possible.\",\n        \"Choose the minimum ugliness from the calculated potential ugliness values.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the minimum possible ugliness calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the building heights.\",\n    \"Determine the average height and consider both floor and ceiling values.\",\n    \"Calculate the potential ugliness for both floor and ceiling values by redistributing the blocks.\",\n    \"Choose the minimum ugliness from the calculated potential ugliness values.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means finding the smallest value of max(a) - min(a) after redistributing the blocks among the towers.\n\n# [degree adverb] \n    'minimum'\n    Explanation: The requirement is to achieve the smallest possible difference between the tallest and shortest buildings after redistribution.\n\n# [code logic]\n    The steps for calculating the total sum, determining the average height, and calculating potential ugliness should be considered simultaneously. This can be done by iterating through the building heights once to calculate the sum, then using this sum to determine the average and potential ugliness in one logical block.\n\n# [edge case] \n    Case 1: 2\n            1 1\n    Expected output: 0\n    Explanation: Both buildings have the same height, so the ugliness is already 0.\n    \n    Case 2: 3\n            1 1 10000000\n    Expected output: 0\n    Explanation: Redistribute blocks from the tallest building to the shortest ones to make all heights equal, resulting in ugliness of 0.\n    \n    Case 3: 4\n            1 1 1 1\n    Expected output: 0\n    Explanation: All buildings have the same height, so the ugliness is already 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve the minimum possible ugliness will handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        # Calculate the average height\n        avg_floor = total_height // n\n        avg_ceil = (total_height + n - 1) // n  # Equivalent to math.ceil(total_height / n)\n\n        # Calculate potential ugliness for both floor and ceiling averages\n        ugliness_floor = max(heights) - min(heights)\n        if total_height % n == 0:\n            # If total height is perfectly divisible by n, we can make all heights equal\n            results.append(0)\n        else:\n            # Otherwise, the minimum ugliness is 1\n            results.append(1)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the building heights.\",\n        \"Calculate the average height by dividing the total sum by the number of buildings, n.\",\n        \"Determine the floor and ceiling of the average height to handle integer division.\",\n        \"Calculate the number of buildings that should have the floor height and the number that should have the ceiling height to minimize the ugliness.\",\n        \"Distribute the blocks accordingly to achieve the minimum possible difference between the tallest and shortest buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the minimum possible ugliness calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the building heights.\",\n    \"Determine the average height and its floor and ceiling values.\",\n    \"Calculate the distribution of buildings to achieve the minimum ugliness.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means we need to find the smallest possible value of max(a) - min(a) after redistributing the blocks among the towers.\n\n# [degree adverb] \n    'minimum'\n    Explanation: We need to achieve the smallest possible value for the ugliness, which is the difference between the tallest and shortest buildings.\n\n# [code logic]\n    The steps for calculating the average height and distributing the blocks should be considered simultaneously. Specifically, calculating the floor and ceiling of the average height and determining the distribution of blocks should be done in one logical block to ensure the correct redistribution of blocks.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 10000000]\n    Expected output: 0\n    Explanation: We can move blocks from the second tower to the first tower until both have equal heights, resulting in an ugliness of 0.\n\n    Case 2: n = 3, heights = [1, 1, 10000000]\n    Expected output: 0\n    Explanation: We can redistribute blocks from the third tower to the first two towers until all have equal heights, resulting in an ugliness of 0.\n\n    Case 3: n = 4, heights = [1, 1, 1, 10000000]\n    Expected output: 1\n    Explanation: After redistribution, the closest we can get is three towers with height 2500000 and one tower with height 2500001, resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks based on the average height and its floor and ceiling values will handle these cases correctly.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        avg_floor = total_height // n\n        avg_ceil = avg_floor if total_height % n == 0 else avg_floor + 1\n        \n        # Calculate how many towers should have height avg_floor and avg_ceil\n        count_ceil = total_height % n\n        count_floor = n - count_ceil\n        \n        # The minimum ugliness is the difference between avg_ceil and avg_floor\n        min_ugliness = avg_ceil - avg_floor\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total number of blocks across all towers.\",\n        \"Determine the average height by dividing the total number of blocks by the number of towers.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks to achieve heights as close to the average as possible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each test case.\",\n    \"For each test case, calculate the total number of blocks and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to achieve heights close to the average.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means we need to find the smallest value of max(a) - min(a) after redistributing blocks between towers.\n\n# [degree adverb] \n    'minimum'\n    Explanation: We need to achieve the smallest possible difference between the tallest and shortest buildings.\n\n# [code logic]\n    The steps for calculating the total number of blocks, determining the average height, and calculating the minimum possible ugliness should be considered simultaneously. This can be done by iterating through the heights, calculating the total, and then redistributing blocks to minimize the difference between the tallest and shortest towers.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 1] => Expected output: 0\n    Explanation: Both towers have the same height, so the ugliness is already 0.\n    \n    Case 2: n = 3, heights = [1, 1, 10] => Expected output: 0\n    Explanation: We can redistribute blocks to make all towers have the same height, resulting in an ugliness of 0.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 10] => Expected output: 1\n    Explanation: After redistributing blocks, the closest we can get is [3, 3, 3, 4], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling the edge case:\n    ```python\n    def calculate_minimum_ugliness(heights):\n        total_blocks = sum(heights)\n        n = len(heights)\n        average_height = total_blocks // n\n        remainder = total_blocks % n\n        \n        # Sort heights to redistribute blocks\n        heights.sort()\n        \n        # Redistribute blocks to minimize ugliness\n        for i in range(n):\n            if i < remainder:\n                heights[i] = average_height + 1\n            else:\n                heights[i] = average_height\n        \n        return max(heights) - min(heights)\n    ```\n\nYES", "Round_0": {"code": "def calculate_minimum_ugliness(heights):\n    total_blocks = sum(heights)\n    n = len(heights)\n    average_height = total_blocks // n\n    remainder = total_blocks % n\n    \n    # Sort heights to redistribute blocks\n    heights.sort()\n    \n    # Redistribute blocks to minimize ugliness\n    for i in range(n):\n        if i < remainder:\n            heights[i] = average_height + 1\n        else:\n            heights[i] = average_height\n    \n    return max(heights) - min(heights)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = calculate_minimum_ugliness(heights)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the building heights.\",\n        \"Calculate the average height by dividing the total sum by the number of buildings, n.\",\n        \"Determine the floor and ceiling of the average height to handle integer division.\",\n        \"Calculate the number of buildings that should have the floor height and the number that should have the ceiling height to minimize the ugliness.\",\n        \"Compute the minimum possible ugliness as the difference between the ceiling and floor values.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the building heights.\",\n    \"Determine the average height and its floor and ceiling values.\",\n    \"Calculate the distribution of buildings with floor and ceiling heights to minimize ugliness.\",\n    \"Compute the minimum possible ugliness for each test case.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the height difference between the tallest and shortest buildings, formally expressed as max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means finding the smallest value of max(a) - min(a) after redistributing the blocks among the towers. In code, this involves redistributing the blocks to make the heights as equal as possible.\n\n# [degree adverb] \n    'tallest', 'shortest'\n    Explanation: 'Tallest' refers to the building with the maximum height, and 'shortest' refers to the building with the minimum height. In code, these are found using max() and min() functions.\n\n# [code logic]\n    The steps for calculating the total sum, average height, floor and ceiling values, and distribution of buildings should be considered simultaneously to efficiently minimize the ugliness. This can be implemented in a single loop or function that handles these calculations together.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 1] = 0\n    Explanation: Both buildings have the same height, so the ugliness is already 0.\n    \n    Case 2: n = 3, heights = [1, 1, 10] = 0\n    Explanation: Redistribute blocks from the tallest to the shortest until all are equal, resulting in ugliness of 0.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 10] = 1\n    Explanation: After redistribution, the closest equal distribution results in a minimum ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve equal heights will naturally handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average_height = total_sum // n\n        remainder = total_sum % n\n        \n        # Calculate the minimum possible ugliness\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the total sum by the number of buildings, n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks to make the heights as equal as possible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the heights and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to minimize the height difference.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the height difference between the tallest and shortest buildings, which is calculated as max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means we need to find the smallest value of max(a) - min(a) after redistributing the blocks among the towers.\n\n# [degree adverb] \n    'minimum'\n    Explanation: We need to achieve the smallest possible value of ugliness, which is the smallest difference between the tallest and shortest buildings.\n\n# [code logic]\n    The steps for calculating the total sum of heights and determining the average height should be considered simultaneously when redistributing blocks to minimize the height difference. This can be done by iterating through the list of heights and adjusting them to be as close to the average as possible.\n\n# [edge case] \n    Case 1: Input: 2 1 1\n    Expected Output: 0\n    Explanation: Both towers have the same height, so the ugliness is already 0.\n\n    Case 2: Input: 2 1 10000000\n    Expected Output: 9999999\n    Explanation: The maximum possible ugliness is the difference between the tallest and shortest building, which is 9999999.\n\n    Case 3: Input: 3 1 1 10000000\n    Expected Output: 9999999\n    Explanation: The maximum possible ugliness is the difference between the tallest and shortest building, which is 9999999.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to minimize the height difference will naturally handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        max_height = max(heights)\n        min_height = min(heights)\n        results.append(max_height - min_height)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Read the integer t, which represents the number of test cases. For each test case, read the integer n (number of buildings) and the list of integers representing the heights of the buildings.\"\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"details\": \"For each test case, determine the minimum and maximum heights of the buildings. Calculate the total sum of the heights. Compute the average height by dividing the total sum by n. Determine the minimum possible ugliness by considering the distribution of blocks to achieve heights as close to the average as possible.\"\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, output the calculated minimum possible ugliness.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases, t.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the number of buildings, n, and their respective heights.\",\n    \"  b. Calculate the total sum of the heights.\",\n    \"  c. Compute the average height by dividing the total sum by n.\",\n    \"  d. Determine the minimum and maximum heights of the buildings.\",\n    \"  e. Calculate the minimum possible ugliness by redistributing blocks to achieve heights as close to the average as possible.\",\n    \"  f. Output the minimum possible ugliness for the current test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'minimum possible ugliness'\n    Explanation: This refers to the smallest value of ugliness that can be achieved by redistributing blocks between towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible'\n    Explanation: This indicates the need to find the smallest achievable value of ugliness after redistributing blocks.\n\n# [degree adverb] \n    'minimum'\n    Explanation: This means the smallest value that can be achieved, which in this context is the smallest difference between the tallest and shortest buildings.\n\n# [code logic]\n    Steps 2b, 2c, and 2e should be considered simultaneously.\n    Explanation: Calculating the total sum, computing the average, and determining the minimum possible ugliness are interrelated and should be handled in a single logical block to ensure the redistribution of blocks is optimal.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 10000000]\n    Expected output: 0\n    Explanation: With only two towers, you can move blocks from the taller to the shorter until they are equal.\n\n    Case 2: n = 3, heights = [1, 1, 10000000]\n    Expected output: 0\n    Explanation: You can redistribute blocks from the tallest to the other two until all are equal.\n\n    Case 3: n = 4, heights = [1, 1, 1, 10000000]\n    Expected output: 0\n    Explanation: You can redistribute blocks from the tallest to the other three until all are equal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases.\n    Explanation: The original logic of redistributing blocks to achieve heights as close to the average as possible inherently handles these edge cases. The key is to ensure that the redistribution logic is correctly implemented to balance the heights optimally.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average_height = total_sum // n\n        # Calculate the minimum possible ugliness\n        min_ugliness = max(heights) - min(heights)\n        if total_sum % n == 0:\n            min_ugliness = 0\n        else:\n            min_ugliness = 1\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: minimum_ugliness() missing 1 required positional argument: 'test_cases'"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(heights)\n        \n        # If the total sum is perfectly divisible by n, we can make all towers equal\n        if total_sum % n == 0:\n            results.append(0)\n        else:\n            # If not, the minimum possible ugliness is 1\n            results.append(1)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, false, true, true, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 305, "prompt": "There are n block towers in a row, where tower i has a height of a_i. You're part of a construction team, and in one day, you can execute an operation to make the towers look as nice as possible: choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j). In this operation, you move a block from tower i to tower j, essentially decreasing a_i by 1 and increasing a_j by 1. You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 173}
