{"name": "1618_E. Singers' Tour", "description": "n towns are arranged in a circle sequentially. The towns are numbered from 1 to n in clockwise order. In the i-th town, there lives a singer with a repertoire of a_i minutes for each i \u2208 [1, n].\n\nEach singer visited all n towns in clockwise order, starting with the town he lives in, and gave exactly one concert in each town. In addition, in each town, the i-th singer got inspired and came up with a song that lasts a_i minutes. The song was added to his repertoire so that he could perform it in the rest of the cities.\n\nHence, for the i-th singer, the concert in the i-th town will last a_i minutes, in the (i + 1)-th town the concert will last 2 \u22c5 a_i minutes, ..., in the ((i + k) mod n + 1)-th town the duration of the concert will be (k + 2) \u22c5 a_i, ..., in the town ((i + n - 2) mod n + 1) \u2014 n \u22c5 a_i minutes.\n\nYou are given an array of b integer numbers, where b_i is the total duration of concerts in the i-th town. Reconstruct any correct sequence of positive integers a or say that it is impossible.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of two lines. The first line contains a single integer n (1 \u2264 n \u2264 4 \u22c5 10^4) \u2014 the number of cities. The second line contains n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 10^{9}) \u2014 the total duration of concerts in i-th city.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print the answer as follows:\n\nIf there is no suitable sequence a, print NO. Otherwise, on the first line print YES, on the next line print the sequence a_1, a_2, ..., a_n of n integers, where a_i (1 \u2264 a_i \u2264 10^{9}) is the initial duration of repertoire of the i-th singer. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n\n\nOutput\n\n\nYES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n\nNote\n\nLet's consider the 1-st test case of the example:\n\n  1. the 1-st singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 6 minutes, in the 3-rd \u2014 for 9 minutes; \n  2. the 2-nd singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 1 minute, in the 3-rd - for 2 minutes; \n  3. the 3-rd singer in the 1-st city will give a concert for 6 minutes, in the 2-nd \u2014 for 9 minutes, in the 3-rd \u2014 for 3 minutes. ", "tags": ["constructive algorithms", "math"], "difficulty": 11, "id": 1618, "sample_io": [{"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n", "output": ["YES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n"]}], "test_list": [{"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 75 93 93 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nYES\n5 5 4 1 4 5\n"]}, {"input": "4\n3\n12 19 14\n1\n1\n3\n1 2 3\n6\n8 75 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 18 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 87\n", "output": ["NO\nYES\n1\nNO\nYES\n5 5 4 1 4 5\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n14 75 202 179 49 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n2\n3\n1 2 3\n6\n14 75 202 179 91 39\n", "output": ["YES\n3 1 3\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n4\n3\n1 2 3\n6\n14 75 202 179 91 39\n", "output": ["YES\n3 1 3\nYES\n4\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n3\n3\n1 2 1\n6\n2 75 202 179 72 39\n", "output": ["NO\nYES\n3\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n4\n3\n0 4 3\n4\n26 75 32 4 3 6\n", "output": ["NO\nYES\n4\nNO\nNO\n"]}, {"input": "4\n3\n6 10 14\n1\n2\n3\n1 2 0\n6\n81 75 75 93 93 87\n", "output": ["NO\nYES\n2\nNO\nYES\n5 5 4 1 4 5\n"]}, {"input": "4\n3\n19 16 19\n1\n1\n3\n1 0 3\n6\n8 37 80 169 133 87\n", "output": ["YES\n3 4 2\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 75 93 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 80 93 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 119 93 93 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 75 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 119 93 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 3\n6\n8 75 75 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 19 14\n1\n1\n3\n1 2 2\n6\n8 75 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n14 75 119 93 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 3\n6\n8 75 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n14 75 119 179 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n1 1 3\n6\n8 75 75 82 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n1 1 3\n6\n8 75 75 82 133 105\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 37 80 93 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 87\n", "output": ["NO\nYES\n1\nNO\nYES\n5 5 4 1 4 5\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 2 3\n6\n8 75 119 93 93 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 75 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 62 93 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 18 14\n1\n1\n3\n1 2 1\n6\n112 75 75 93 93 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 3\n6\n8 75 119 93 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 3\n6\n8 132 75 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 4\n6\n8 75 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n1\n3\n1 2 3\n6\n14 75 119 179 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n1 1 3\n6\n8 39 75 82 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 37 80 169 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 3\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 2 3\n6\n8 75 119 93 93 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 1\n6\n8 75 62 93 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 18 14\n1\n1\n3\n1 2 1\n6\n112 75 75 93 93 124\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 3\n6\n8 75 119 93 49 15\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 4\n6\n8 75 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n1\n3\n1 2 3\n6\n14 75 119 179 49 39\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n1 2 3\n6\n8 39 75 82 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n2\n8 37 80 169 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 22\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 3\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 2 3\n6\n16 75 119 93 93 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 50 16 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 4\n6\n8 75 75 82 133 117\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n1\n3\n1 2 3\n6\n14 75 202 179 49 39\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n1 2 3\n6\n8 39 4 82 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 3\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 3\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 50 3 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n2\n1 2 3\n6\n8 39 4 82 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 3\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 91 3 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n14 75 202 179 91 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 10 3\n1\n1\n3\n2 2 1\n6\n81 75 75 93 93 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 91 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n2 75 202 179 91 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n24 10 3\n1\n1\n3\n2 2 1\n6\n81 75 75 93 93 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 19 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n2 75 202 179 42 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n24 10 3\n1\n1\n3\n2 2 1\n6\n81 75 75 184 93 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 4 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 0\n6\n2 75 202 179 42 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n24 10 3\n1\n1\n3\n2 2 1\n6\n81 75 75 184 129 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n13 75 32 4 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 4 3\n6\n13 75 32 4 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 4 3\n6\n13 75 32 4 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n2 2 3\n6\n8 75 75 93 93 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n10 75 75 93 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 119 93 155 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 19 13\n1\n1\n3\n1 2 3\n6\n8 75 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 18 14\n1\n1\n3\n1 2 1\n6\n62 75 75 93 93 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 119 93 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 3\n6\n8 75 84 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 19 14\n1\n1\n3\n1 2 2\n6\n8 75 80 93 133 150\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 6\n6\n8 75 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n14 102 119 179 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n1 1 3\n6\n8 75 75 82 16 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 37 80 8 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n6 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 87\n", "output": ["NO\nYES\n1\nNO\nYES\n5 5 4 1 4 5\n"]}, {"input": "4\n3\n12 16 27\n1\n1\n3\n0 2 3\n6\n8 75 75 50 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 25\n1\n1\n3\n1 0 3\n6\n8 75 119 93 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 4\n6\n8 81 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n19 16 14\n1\n1\n3\n1 2 3\n6\n8 37 80 169 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 81 3\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 2 3\n6\n8 75 119 93 167 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 6\n6\n8 75 32 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 1\n6\n8 75 62 64 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 0 3\n6\n8 75 119 93 49 15\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 4\n6\n8 75 75 82 133 133\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n4 16 7\n1\n1\n3\n1 2 3\n6\n14 75 119 179 49 39\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 22\n1\n1\n3\n1 2 2\n6\n81 75 75 93 93 3\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n8 16 4\n1\n1\n3\n1 2 3\n6\n16 75 119 93 93 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 50 16 2\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 8\n6\n8 75 75 82 133 117\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n22 16 7\n1\n1\n3\n1 2 3\n6\n14 75 202 179 49 39\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n2 2 3\n6\n8 39 4 82 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 3 3\n6\n8 75 32 50 3 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n14 75 202 176 49 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 10 3\n1\n1\n3\n1 2 1\n6\n81 75 75 93 29 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 4 3\n6\n8 75 32 91 3 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n2\n0 2 3\n6\n8 75 32 91 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 0 3\n6\n2 75 202 179 91 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n24 10 3\n1\n1\n3\n2 2 1\n6\n81 75 75 93 93 -1\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n2 75 202 179 42 4\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n24 10 3\n1\n1\n3\n2 2 1\n6\n81 138 75 184 93 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 6\n1\n1\n3\n0 2 3\n6\n8 75 32 4 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 1\n6\n2 75 202 179 42 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n13 75 32 4 4 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n0 4 3\n6\n13 75 32 4 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n2 2 3\n6\n8 75 75 93 21 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n10 75 75 88 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 119 93 240 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n14 19 13\n1\n1\n3\n1 2 3\n6\n8 75 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 16 119 93 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n13 16 14\n1\n1\n3\n1 1 3\n6\n8 75 84 50 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 19 14\n1\n1\n3\n1 2 2\n6\n8 75 80 181 133 150\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 6\n6\n8 75 75 82 41 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n11 16 14\n1\n1\n3\n1 2 3\n6\n14 102 119 179 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n2\n1 2 3\n6\n8 37 80 8 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n6 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 140\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 27\n1\n1\n3\n0 0 3\n6\n8 75 75 50 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 25\n1\n1\n3\n1 0 3\n6\n8 75 119 93 4 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 4\n6\n12 81 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n19 16 14\n1\n1\n2\n1 2 3\n6\n8 37 80 169 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 37 81 3\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 1 3\n6\n8 75 119 93 167 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 1\n6\n8 75 62 41 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 0 3\n6\n8 75 112 93 49 15\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 4\n3\n8 75 75 82 133 133\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n8 16 4\n1\n2\n3\n1 2 3\n6\n16 75 119 93 93 111\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 8\n6\n8 75 76 82 133 117\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n22 16 7\n1\n1\n2\n1 2 3\n6\n14 75 202 179 49 39\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n2 2 3\n6\n8 39 4 82 133 20\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 3 3\n6\n8 75 32 50 3 169\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 2\n6\n14 75 202 176 49 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 10 3\n1\n1\n3\n1 2 1\n6\n81 93 75 93 29 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 24\n1\n1\n3\n0 4 3\n6\n8 75 32 91 3 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 22\n1\n1\n2\n0 2 3\n6\n8 75 32 91 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n0 0 3\n6\n2 75 202 179 91 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n2 75 202 179 55 4\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 6\n1\n2\n3\n0 2 3\n6\n8 75 32 4 3 6\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 1\n6\n2 75 202 179 72 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n13 53 32 4 4 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n0 4 3\n4\n13 75 32 4 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 17 14\n1\n1\n3\n1 2 3\n6\n10 75 75 88 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 119 93 15 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n14 19 13\n1\n1\n3\n1 2 3\n6\n8 109 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 26 14\n1\n1\n3\n0 2 3\n6\n8 16 119 93 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n13 16 14\n1\n1\n3\n1 1 3\n6\n8 75 104 50 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 19 14\n1\n1\n3\n1 2 2\n6\n8 42 80 181 133 150\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 6\n6\n8 75 75 82 41 77\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n11 16 14\n1\n1\n3\n1 2 3\n6\n14 102 38 179 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n2\n1 2 3\n6\n11 37 80 8 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n6 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 38 140\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 25\n1\n1\n3\n1 0 3\n6\n8 75 143 93 4 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n2 1 4\n6\n12 81 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n19 16 14\n1\n1\n2\n1 2 3\n6\n10 37 80 169 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 37 81 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 1 3\n6\n8 21 119 93 167 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 1\n6\n8 35 62 41 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 4\n3\n8 75 75 133 133 133\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n2\n3\n1 0 8\n6\n8 75 76 82 133 117\n", "output": ["YES\n3 1 3\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n22 22 7\n1\n1\n3\n1 2 3\n6\n14 75 202 179 49 39\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 6 3\n6\n8 75 32 50 3 169\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 2\n6\n14 75 202 176 47 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 10 3\n1\n1\n3\n1 2 2\n6\n81 93 75 93 29 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 22\n1\n1\n2\n0 2 3\n6\n8 75 28 91 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n3 75 202 179 55 4\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n0 16 6\n1\n2\n3\n0 2 3\n6\n8 75 32 4 3 6\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n13 53 32 2 4 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n0 4 3\n4\n26 75 32 4 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 17 14\n1\n1\n3\n1 2 3\n6\n0 75 75 88 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n14 19 23\n1\n1\n3\n1 2 3\n6\n8 109 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 26 14\n1\n1\n3\n0 2 3\n6\n8 16 119 141 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 6 14\n1\n1\n3\n1 2 2\n6\n8 42 80 181 133 150\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 6\n6\n8 75 75 82 41 77\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n11 16 28\n1\n1\n3\n1 2 3\n6\n14 102 38 179 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n11 37 80 8 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 25\n1\n1\n3\n1 0 3\n6\n8 75 143 93 5 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n2 1 4\n6\n12 81 144 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n19 16 14\n1\n1\n2\n1 0 3\n6\n10 37 80 169 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 1 2\n6\n8 21 119 93 167 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 1\n6\n8 35 12 41 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 -1 4\n3\n8 75 75 133 133 133\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n2\n3\n1 1 8\n6\n8 75 76 82 133 117\n", "output": ["YES\n3 1 3\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n2\n3\n0 6 3\n6\n8 75 32 50 3 169\n", "output": ["YES\n3 1 3\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 2\n6\n14 75 202 176 57 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 10 4\n1\n1\n3\n1 2 2\n6\n81 93 75 93 29 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 22\n1\n1\n2\n0 2 3\n6\n13 75 28 91 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n3\n3\n1 1 1\n6\n2 75 202 179 72 39\n", "output": ["NO\nYES\n3\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n2\n3\n0 4 3\n4\n26 75 32 4 3 6\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 17 14\n1\n1\n3\n1 2 3\n6\n0 75 75 27 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n14 19 23\n1\n1\n3\n1 2 3\n6\n8 136 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 26 14\n1\n1\n3\n0 2 3\n6\n8 16 119 141 64 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 6 14\n1\n1\n3\n2 2 2\n6\n8 42 80 181 133 150\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 6\n6\n8 141 75 82 41 77\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}], "task_id": "codecontest/136", "repair_prompt": ["n towns are arranged in a circle sequentially. The towns are numbered from 1 to n in clockwise order. In the i-th town, there lives a singer with a repertoire of a_i minutes for each i \u2208 [1, n].\n\nEach singer visited all n towns in clockwise order, starting with the town he lives in, and gave exactly one concert in each town. In addition, in each town, the i-th singer got inspired and came up with a song that lasts a_i minutes. The song was added to his repertoire so that he could perform it in the rest of the cities.\n\nHence, for the i-th singer, the concert in the i-th town will last a_i minutes, in the (i + 1)-th town the concert will last 2 \u22c5 a_i minutes, ..., in the ((i + k) mod n + 1)-th town the duration of the concert will be (k + 2) \u22c5 a_i, ..., in the town ((i + n - 2) mod n + 1) \u2014 n \u22c5 a_i minutes.\n\nYou are given an array of b integer numbers, where b_i is the total duration of concerts in the i-th town. Reconstruct any correct sequence of positive integers a or say that it is impossible. Ensure that the reconstructed sequence satisfies the given constraints and conditions.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of two lines. The first line contains a single integer n (1 \u2264 n \u2264 4 \u22c5 10^4) \u2014 the number of cities. The second line contains n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 10^{9}) \u2014 the total duration of concerts in i-th city.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print the answer as follows:\n\nIf there is no suitable sequence a, print NO. Otherwise, on the first line print YES, on the next line print the sequence a_1, a_2, ..., a_n of n integers, where a_i (1 \u2264 a_i \u2264 10^{9}) is the initial duration of repertoire of the i-th singer. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n\n\nOutput\n\n\nYES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n\nNote\n\nLet's consider the 1-st test case of the example:\n\n  1. the 1-st singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 6 minutes, in the 3-rd \u2014 for 9 minutes; \n  2. the 2-nd singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 1 minute, in the 3-rd - for 2 minutes; \n  3. the 3-rd singer in the 1-st city will give a concert for 6 minutes, in the 2-nd \u2014 for 9 minutes, in the 3-rd \u2014 for 3 minutes. \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "n towns are arranged in a circle sequentially. The towns are numbered from 1 to n in clockwise order. In the i-th town, there lives a singer with a repertoire of a_i minutes for each i \u2208 [1, n].\n\nEach singer visited all n towns in clockwise order, starting with the town he lives in, and gave exactly one concert in each town. In addition, in each town, the i-th singer got inspired and came up with a song. This song was unique and it lasts a_i minutes. The song was added to his repertoire so that he could perform it in the rest of the cities.\n\nHence, for the i-th singer, the concert in the i-th town will last a_i minutes, in the (i + 1)-th town the concert will last 2 \u22c5 a_i minutes, ..., in the ((i + k) mod n + 1)-th town the duration of the concert will be (k + 2) \u22c5 a_i, ..., in the town ((i + n - 2) mod n + 1) \u2014 n \u22c5 a_i minutes.\n\nYou are given an array of b integer numbers, where b_i is the total duration of concerts in the i-th town. Reconstruct any correct sequence of positive integers a or say that it is impossible. Ensure that the reconstructed sequence satisfies the given constraints and conditions.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of two lines. The first line contains a single integer n (1 \u2264 n \u2264 4 \u22c5 10^4) \u2014 the number of cities. The second line contains n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 10^{9}) \u2014 the total duration of concerts in i-th city.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print the answer as follows:\n\nIf there is no suitable sequence a, print NO. Otherwise, on the first line print YES, on the next line print the sequence a_1, a_2, ..., a_n of n integers, where a_i (1 \u2264 a_i \u2264 10^{9}) is the initial duration of repertoire of the i-th singer. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n\n\nOutput\n\n\nYES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n\nNote\n\nLet's consider the 1-st test case of the example:\n\n  1. the 1-st singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 6 minutes, in the 3-rd \u2014 for 9 minutes; \n  2. the 2-nd singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 1 minute, in the 3-rd - for 2 minutes; \n  3. the 3-rd singer in the 1-st city will give a concert for 6 minutes, in the 2-nd \u2014 for 9 minutes, in the 3-rd \u2014 for 3 minutes. \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "n towns are arranged in a circle sequentially, numbered from 1 to n in clockwise order, each hosting a singer with a repertoire of a_i minutes for each i \u2208 [1, n]. Each singer visited all n towns in clockwise order, starting with the town he lives in, and gave exactly one concert in each town; in each town, the i-th singer got inspired and came up with a song that lasts a_i minutes, adding it to his repertoire for subsequent cities. Hence, for the i-th singer, the concert in the i-th town will last a_i minutes, with the (i + 1)-th town's concert lasting 2 \u22c5 a_i minutes,... in the ((i + k) mod n + 1)-th town, the duration of the concert will be (k + 2) \u22c5 a_i,... and in the town ((i + n - 2) mod n + 1) \u2014 n \u22c5 a_i minutes. You are given an array of b integer numbers, where b_i is the total duration of concerts in the i-th town; reconstruct any correct sequence of positive integers a or say that it is impossible, ensuring that the reconstructed sequence satisfies the given constraints and conditions.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of two lines. The first line contains a single integer n (1 \u2264 n \u2264 4 \u22c5 10^4) \u2014 the number of cities. The second line contains n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 10^{9}) \u2014 the total duration of concerts in i-th city.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print the answer as follows:\n\nIf there is no suitable sequence a, print NO. Otherwise, on the first line print YES, on the next line print the sequence a_1, a_2, ..., a_n of n integers, where a_i (1 \u2264 a_i \u2264 10^{9}) is the initial duration of repertoire of the i-th singer. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n\n\nOutput\n\n\nYES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n\nNote\n\nLet's consider the 1-st test case of the example:\n\n  1. the 1-st singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 6 minutes, in the 3-rd \u2014 for 9 minutes; \n  2. the 2-nd singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 1 minute, in the 3-rd - for 2 minutes; \n  3. the 3-rd singer in the 1-st city will give a concert for 6 minutes, in the 2-nd \u2014 for 9 minutes, in the 3-rd \u2014 for 3 minutes. \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def reconstruct_sequence(t, test_cases):\n    results = []\n    for n, b in test_cases:\n        total_sum = sum(b)\n        if total_sum % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a_sum = total_sum // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev_index = (i - 1 + n) % n\n            diff = b[i] - b[prev_index]\n            if (total_a_sum - diff) % n != 0 or total_a_sum - diff <= 0:\n                possible = False\n                break\n            a[i] = (total_a_sum - diff) // n\n        \n        if possible:\n            results.append(f\"YES\\n{' '.join(map(str, a))}\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, b))\n    \n    results = reconstruct_sequence(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            # Edge case: only one town\n            results.append(\"YES\")\n            results.append(f\"{b[0]}\")\n            continue\n        \n        # Calculate the total sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) / 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of a\n        total_a = total_b // (n * (n + 1) // 2)\n        \n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            # Calculate the difference\n            diff = b[i] - b[i - 1]\n            # Calculate a[i]\n            a[i] = (total_a + diff) // n\n            \n            # Check if a[i] is a positive integer\n            if a[i] <= 0 or (total_a + diff) % n != 0:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    # Print all results\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            # Edge case for n = 1\n            if b[0] > 0:\n                results.append(\"YES\")\n                results.append(f\"{b[0]}\")\n            else:\n                results.append(\"NO\")\n            continue\n        \n        # Attempt to reconstruct sequence a\n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n < 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\n# This function will be called when the script is executed\nif __name__ == \"__main__\":\n    solve()\n\nmain()", "def solve_concerts(test_cases):\n    results = []\n    for n, b in test_cases:\n        if n == 1:\n            # If there's only one town, the only possible a is b[0]\n            results.append(\"YES\\n\" + str(b[0]))\n            continue\n        \n        # Calculate the total sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) // 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the sum of a_i\n        sum_a = total_b // (n * (n + 1) // 2)\n        \n        # Attempt to reconstruct a valid sequence\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            # Calculate the difference between b[i] and b[i-1] (circular)\n            diff = b[i] - b[i - 1]\n            # Calculate a[i]\n            a[i] = (diff - sum_a) // n\n            # Check if a[i] is a valid positive integer\n            if a[i] <= 0 or (diff - sum_a) % n != 0:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\\n\" + \" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, b))\n    \n    results = solve_concerts(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            a[i] = (total_a + diff) // n\n            if (total_a + diff) % n != 0 or a[i] <= 0:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] % n == 0:\n                results.append(\"YES\")\n                results.append(str(b[0] // n))\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nif __name__ == \"__main__\":\n    solve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        # Calculate the sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) // 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of a_i\n        total_a = total_b // (n * (n + 1) // 2)\n        \n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            # Calculate the difference\n            diff = b[i] - b[i - 1] if i > 0 else b[i] - b[n - 1]\n            \n            # Calculate a_i\n            if (total_a + diff) % n != 0 or (total_a + diff) // n <= 0:\n                possible = False\n                break\n            \n            a[i] = (total_a + diff) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev = (i - 1 + n) % n\n            diff = b[i] - b[prev]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n\nmain()", "def reconstruct_sequence(t, test_cases):\n    results = []\n    \n    for n, b in test_cases:\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) / 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff + total_a) % n != 0 or (diff + total_a) <= 0:\n                possible = False\n                break\n            a[i] = (diff + total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, b))\n    \n    results = reconstruct_sequence(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            results.append(\"YES\")\n            results.append(str(b[0]))\n            continue\n        \n        total_sum = sum(b)\n        if total_sum % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a_sum = total_sum // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev_index = (i - 1 + n) % n\n            diff = b[i] - b[prev_index]\n            if (total_a_sum - diff) % n != 0 or (total_a_sum - diff) // n <= 0:\n                possible = False\n                break\n            a[i] = (total_a_sum - diff) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n\nmain()", "def reconstruct_sequence(t, test_cases):\n    results = []\n    for n, b in test_cases:\n        total_sum = sum(b)\n        if total_sum % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a_sum = total_sum // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev_index = (i - 1 + n) % n\n            diff = b[i] - b[prev_index]\n            if (total_a_sum - diff) % n != 0 or total_a_sum - diff <= 0:\n                possible = False\n                break\n            a[i] = (total_a_sum - diff) // n\n        \n        if possible:\n            results.append(f\"YES\\n{' '.join(map(str, a))}\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, b))\n    \n    results = reconstruct_sequence(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of towns.\",\n        \"Read the array b, which contains the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence a exists for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize an empty list to store the sequence a.\",\n        \"Iterate over each town and calculate the possible initial duration a_i for the singer in that town.\",\n        \"Check if the calculated sequence a satisfies the conditions given in the problem statement.\",\n        \"If a valid sequence is found, store it; otherwise, mark the test case as impossible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a valid sequence a was found, print 'YES' followed by the sequence a.\",\n        \"If no valid sequence was found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence a that satisfies the given conditions.\",\n    \"Output 'YES' and the sequence a if a valid sequence is found; otherwise, output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sequence of positive integers a'\n    Explanation: The requirement is to reconstruct a sequence of positive integers that represents the initial duration of repertoire for each singer in each town. This sequence must satisfy the conditions given for the total duration of concerts in each town.\n\n# [phrase showing quantity relationship]\n    '2 \u22c5 a_i', '(k + 2) \u22c5 a_i', 'n \u22c5 a_i'\n    Explanation: These phrases describe how the duration of concerts increases as the singer moves from town to town. The concert duration in each subsequent town is a multiple of the initial duration a_i. This relationship needs to be implemented in code by calculating the concert duration for each town based on the singer's initial repertoire.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps to parse the input and determine if a valid sequence exists should be implemented simultaneously for each test case. This involves reading the input, calculating the sequence, and checking its validity in one cohesive block of code.\n\n# [edge case]\n    Test case with n = 1 and b_1 = 1: \n    Expected output: YES followed by 1\n    Explanation: With only one town and a concert duration of 1, the initial repertoire must be 1 to satisfy the condition.\n    \n    Test case with n = 3 and b = [1, 2, 3]: \n    Expected output: NO\n    Explanation: It's impossible to satisfy the conditions with these concert durations as they don't align with the required multiples of initial repertoire.\n    \n    Test case with n = 6 and b = [81, 75, 75, 93, 93, 87]: \n    Expected output: YES followed by a valid sequence such as 5 5 4 1 4 5\n    Explanation: The sequence satisfies the conditions for concert durations in each town.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling the edge case:\n    ```python\n    def reconstruct_sequence(t, test_cases):\n        results = []\n        for n, b in test_cases:\n            a = [0] * n\n            possible = True\n            for i in range(n):\n                if b[i] % n != 0:\n                    possible = False\n                    break\n                a[i] = b[i] // n\n            if possible:\n                results.append(f\"YES\\n{'", "Round_0": {"code": "def reconstruct_sequence(t, test_cases):\n    results = []\n    for n, b in test_cases:\n        total_sum = sum(b)\n        if total_sum % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a_sum = total_sum // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev_index = (i - 1 + n) % n\n            diff = b[i] - b[prev_index]\n            if (total_a_sum - diff) % n != 0 or total_a_sum - diff <= 0:\n                possible = False\n                break\n            a[i] = (total_a_sum - diff) // n\n        \n        if possible:\n            results.append(f\"YES\\n{' '.join(map(str, a))}\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, b))\n    \n    results = reconstruct_sequence(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of towns.\",\n        \"Read the array b of n integers, representing the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence a exists for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize an array a of size n to store the initial repertoire durations.\",\n        \"Iterate over each town and calculate the possible initial repertoire duration for each singer.\",\n        \"Check if the calculated sequence a satisfies the conditions for the total concert durations given in b.\",\n        \"If a valid sequence is found, store it; otherwise, mark the test case as impossible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a valid sequence a was found, print 'YES' followed by the sequence a.\",\n        \"If no valid sequence was found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence a that satisfies the given conditions.\",\n    \"Iterate over each town and calculate the possible initial repertoire duration for each singer.\",\n    \"Verify if the calculated sequence a results in the total concert durations specified in b.\",\n    \"Store the result for each test case, indicating whether a valid sequence was found or not.\",\n    \"Output the results for each test case, either printing the sequence a or indicating impossibility.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'repertoire': refers to the initial duration of songs each singer has before starting the concerts.\n    'concert duration': refers to the total time each singer performs in each town, which increases as they visit more towns.\n\n# [phrase showing quantity relationship]\n    '2 \u22c5 a_i': indicates that the concert duration in the next town is twice the initial repertoire duration.\n    '(k + 2) \u22c5 a_i': indicates that the concert duration increases by a factor of (k + 2) times the initial repertoire duration as the singer visits more towns.\n    'n \u22c5 a_i': indicates that the concert duration in the last town is n times the initial repertoire duration.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for parsing input and outputting results can be implemented simultaneously for efficiency. Specifically, reading input and storing results can be done in one code block, while the logic for determining the sequence can be handled separately.\n\n# [edge case]\n    Test case with n = 1 and b = [1] = YES, 1\n    Explanation: With only one town, the singer's repertoire matches the concert duration directly.\n    \n    Test case with n = 2 and b = [2, 4] = YES, 1 2\n    Explanation: The first singer performs for 1 minute in the first town and 2 minutes in the second town. The second singer performs for 2 minutes in the first town and 4 minutes in the second town.\n    \n    Test case with n = 3 and b = [3, 6, 9] = YES, 1 2 3\n    Explanation: Each singer's repertoire matches the concert duration directly as they visit each town.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the calculated sequence a satisfies the conditions for the total concert durations given in b. This involves checking if the sum of calculated durations matches the given b values for each town.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            # Edge case: only one town\n            results.append(\"YES\")\n            results.append(f\"{b[0]}\")\n            continue\n        \n        # Calculate the total sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) / 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of a\n        total_a = total_b // (n * (n + 1) // 2)\n        \n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            # Calculate the difference\n            diff = b[i] - b[i - 1]\n            # Calculate a[i]\n            a[i] = (total_a + diff) // n\n            \n            # Check if a[i] is a positive integer\n            if a[i] <= 0 or (total_a + diff) % n != 0:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    # Print all results\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of towns.\",\n        \"Read the array b of n integers, representing the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence a exists for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize an array a of size n to store the initial repertoire durations.\",\n        \"Iterate over each town and calculate the possible initial repertoire duration for each singer.\",\n        \"Check if the calculated sequence a satisfies the conditions for the total concert durations given in b.\",\n        \"If a valid sequence is found, store it; otherwise, mark the test case as impossible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a valid sequence a was found, print 'YES' followed by the sequence a.\",\n        \"If no valid sequence was found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence a that satisfies the given conditions.\",\n    \"Check the validity of the reconstructed sequence against the total concert durations provided.\",\n    \"Output 'YES' and the sequence a if a valid sequence is found; otherwise, output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'repertoire': refers to the initial duration of songs each singer has before starting the concerts.\n    'concert duration': refers to the total time each singer performs in each town, which increases as they visit more towns.\n\n# [phrase showing quantity relationship]\n    '2 \u22c5 a_i': means the concert duration in the next town is twice the initial repertoire duration.\n    '(k + 2) \u22c5 a_i': means the concert duration increases by a factor of (k + 2) times the initial repertoire duration as the singer visits more towns.\n    'n \u22c5 a_i': means the concert duration in the last town is n times the initial repertoire duration.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for checking the validity of the sequence a and calculating the possible initial repertoire duration should be considered simultaneously. This involves iterating over each town and calculating the initial repertoire duration while checking if it satisfies the conditions.\n\n# [edge case]\n    Test case with n = 1 and b = [1] = YES, 1\n    Explanation: With only one town, the singer's repertoire duration matches the concert duration directly.\n    \n    Test case with n = 2 and b = [2, 4] = YES, 1 2\n    Explanation: The first singer performs for 1 minute in the first town and 2 minutes in the second town. The second singer performs for 2 minutes in the first town and 4 minutes in the second town.\n    \n    Test case with n = 3 and b = [3, 6, 9] = YES, 1 2 3\n    Explanation: Each singer's concert duration increases by their initial repertoire duration as they visit more towns.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n = 1 or the sequence cannot be reconstructed.\n    ```\n    if n == 1:\n        if b[0] > 0:\n            print(\"YES\")\n            print(b[0])\n        else:\n            print(\"NO\")\n    else:\n        # Implement logic to reconstruct sequence a\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            # Edge case for n = 1\n            if b[0] > 0:\n                results.append(\"YES\")\n                results.append(f\"{b[0]}\")\n            else:\n                results.append(\"NO\")\n            continue\n        \n        # Attempt to reconstruct sequence a\n        a = [0] * n\n        possible = True\n        \n        # Calculate a[0] based on the given b array\n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            possible = False\n        else:\n            total_a = total_b // (n * (n + 1) // 2)\n            a[0] = total_a\n        \n        if possible:\n            for i in range(n):\n                diff = b[i] - b[i - 1]\n                if (diff - total_a) % n != 0 or (diff - total_a) // n < 0:\n                    possible = False\n                    break\n                a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\n# This function will be called when the script is executed\nif __name__ == \"__main__\":\n    solve()\n", "report": "The compilation output of the preceding code is: solve() takes 0 positional arguments but 1 was given"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            # Edge case for n = 1\n            if b[0] > 0:\n                results.append(\"YES\")\n                results.append(f\"{b[0]}\")\n            else:\n                results.append(\"NO\")\n            continue\n        \n        # Attempt to reconstruct sequence a\n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n < 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\n# This function will be called when the script is executed\nif __name__ == \"__main__\":\n    solve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of towns and the total duration of concerts in each town.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Parsed data structure containing test cases\"\n    },\n    {\n      \"description\": \"For each test case, determine if a valid sequence of initial repertoire durations exists that satisfies the given conditions.\",\n      \"input\": \"Parsed data structure for a single test case\",\n      \"output\": \"Boolean indicating if a valid sequence exists\"\n    },\n    {\n      \"description\": \"If a valid sequence exists, reconstruct one possible sequence of initial repertoire durations for the singers.\",\n      \"input\": \"Parsed data structure for a single test case\",\n      \"output\": \"A sequence of integers representing the initial repertoire durations\"\n    },\n    {\n      \"description\": \"Format the output for each test case according to the specified format, either 'NO' or 'YES' followed by the sequence.\",\n      \"input\": \"Boolean and sequence of integers for each test case\",\n      \"output\": \"Formatted output string for each test case\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"Iterate over each test case and perform the following steps:\",\n    \"  - Check if a valid sequence of initial repertoire durations exists by analyzing the constraints and conditions.\",\n    \"  - If a valid sequence exists, reconstruct one possible sequence of initial repertoire durations.\",\n    \"  - Format the result for the test case as 'YES' followed by the sequence or 'NO' if no valid sequence exists.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'circular arrangement'\n    Explanation: The towns are arranged in a circle, meaning the sequence wraps around after reaching the last town.\n\n    'repertoire'\n    Explanation: Each singer has an initial repertoire duration, which increases as they perform in each town.\n\n    'concert duration'\n    Explanation: The duration of each concert is determined by the singer's repertoire, which increases with each town visited.\n\n# [phrase showing quantity relationship]\n    '2 \u22c5 a_i': This indicates that the concert duration in the next town is twice the initial repertoire duration.\n    'k + 2 \u22c5 a_i': This indicates that the concert duration increases by a factor of (k + 2) times the initial repertoire duration as the singer moves to subsequent towns.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps to check if a valid sequence exists and reconstruct it should be considered simultaneously. Specifically, the logic to determine if a sequence is possible and to construct it should be integrated, as they both depend on the same constraints and conditions.\n\n# [edge case]\n    1. n = 1, b = [1] = YES, 1\n       Explanation: With only one town, the initial repertoire must match the total concert duration.\n    2. n = 3, b = [1, 1, 1] = NO\n       Explanation: It's impossible to distribute the concert durations such that each singer's repertoire increases correctly.\n    3. n = 4, b = [4, 4, 4, 4] = YES, 1 1 1 1\n       Explanation: Each singer can start with a repertoire of 1, and the concert durations will match the given totals.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should include logic to handle cases where n = 1 separately, as well as checks to ensure that the calculated sequence satisfies the constraints for all towns.\n\n```python\ndef solve_concerts(test_cases):\n    results = []\n    for n, b in test_cases:\n        if n == 1:\n            results.append(\"YES\\n\" + str(b[0]))\n            continue\n        \n        # Attempt to reconstruct a valid sequence\n        a = [0] * n\n        possible = True\n        for i in range(n):\n            if b[i] % n != 0:\n                possible = False", "Round_0": {"code": "def solve_concerts(test_cases):\n    results = []\n    for n, b in test_cases:\n        if n == 1:\n            # If there's only one town, the only possible a is b[0]\n            results.append(\"YES\\n\" + str(b[0]))\n            continue\n        \n        # Calculate the total sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the sum of a_i\n        sum_a = total_b // (n * (n + 1) // 2)\n        \n        # Attempt to reconstruct a valid sequence\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            # Calculate the difference between b[i] and b[i-1]\n            diff = b[i] - b[i - 1]\n            # Calculate a[i]\n            a[i] = (diff - sum_a) // n\n            # Check if a[i] is a valid positive integer\n            if a[i] <= 0 or (diff - sum_a) % n != 0:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\\n\" + \" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, b))\n    \n    results = solve_concerts(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: solve_concerts() missing 1 required positional argument: 'test_cases'"}, "Round_1": {"code": "def solve_concerts(test_cases):\n    results = []\n    for n, b in test_cases:\n        if n == 1:\n            # If there's only one town, the only possible a is b[0]\n            results.append(\"YES\\n\" + str(b[0]))\n            continue\n        \n        # Calculate the total sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) // 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the sum of a_i\n        sum_a = total_b // (n * (n + 1) // 2)\n        \n        # Attempt to reconstruct a valid sequence\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            # Calculate the difference between b[i] and b[i-1] (circular)\n            diff = b[i] - b[i - 1]\n            # Calculate a[i]\n            a[i] = (diff - sum_a) // n\n            # Check if a[i] is a valid positive integer\n            if a[i] <= 0 or (diff - sum_a) % n != 0:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\\n\" + \" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, b))\n    \n    results = solve_concerts(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the corresponding data for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of towns.\",\n        \"Read the array b of n integers, where each b_i represents the total duration of concerts in the i-th town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence a exists for each test case and reconstruct it if possible.\",\n      \"steps\": [\n        \"For each test case, initialize an array a of size n to store the initial duration of repertoire for each singer.\",\n        \"Iterate over each town and calculate the possible values for a_i based on the given b array.\",\n        \"Check if the calculated values for a_i satisfy the conditions for all towns.\",\n        \"If a valid sequence a is found, store it; otherwise, mark the test case as impossible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a valid sequence a was found, print 'YES' followed by the sequence a.\",\n        \"If no valid sequence was found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the data for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence a that satisfies the given conditions.\",\n    \"Check the feasibility of the sequence by ensuring the calculated concert durations match the given b array.\",\n    \"Output 'YES' and the sequence a if a valid sequence is found; otherwise, output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'circular arrangement'\n    Explanation: The towns are arranged in a circle, meaning the sequence wraps around after the last town back to the first.\n\n    'repertoire'\n    Explanation: The initial duration of songs each singer has, which increases as they visit more towns.\n\n    'concert duration'\n    Explanation: The total time a singer performs in a town, which increases as they add new songs to their repertoire.\n\n# [phrase showing quantity relationship]\n    'exactly one concert'\n    Explanation: Each singer performs exactly once in each town, which means the number of concerts equals the number of towns.\n\n    'k + 2'\n    Explanation: This represents the multiplier for the concert duration as the singer visits more towns. It starts from 1 and increases by 1 for each subsequent town.\n\n# [degree adverb]\n    'any correct sequence'\n    Explanation: There can be multiple valid sequences of initial song durations that satisfy the conditions.\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the calculation of possible values for `a_i` and checking their validity can be done in a single loop for efficiency.\n\n# [edge case]\n    1. n = 1, b = [1] = YES, 1\n       Explanation: With only one town, the singer's initial repertoire must match the total concert duration.\n    2. n = 2, b = [2, 2] = NO\n       Explanation: It's impossible to have two singers with initial repertoires that satisfy the given conditions.\n    3. n = 3, b = [3, 3, 3] = YES, 1 1 1\n       Explanation: Each singer can start with a repertoire of 1, and the conditions are satisfied.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n is very small (like 1 or 2) because the logic for larger n might not apply directly.\n    ```\n    if n == 1:\n        if b[0] == 1:\n            print(\"YES\")\n            print(1)\n        else:\n            print(\"NO\")\n    elif n == 2:\n        if b[0] == b[1] and b[0] % 2 == 0:\n            print(\"YES\")\n            print(b[0] // 2, b[0] // 2)\n        else:\n            print", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] == 1:\n                results.append(\"YES\")\n                results.append(\"1\")\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            a[i] = (total_a + diff) // n\n            if (total_a + diff) % n != 0 or a[i] <= 0:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 95)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            a[i] = (total_a + diff) // n\n            if (total_a + diff) % n != 0 or a[i] <= 0:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of towns.\",\n        \"Read the array b of n integers, representing the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence a exists for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize an array a of size n to store the initial repertoire durations.\",\n        \"Iterate over each town and calculate the possible initial repertoire duration a_i for each singer.\",\n        \"Check if the calculated sequence a satisfies the conditions for the total concert durations given in b.\",\n        \"If a valid sequence a is found, store it; otherwise, mark the test case as impossible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a valid sequence a was found, print 'YES' followed by the sequence a.\",\n        \"If no valid sequence was found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence a that satisfies the given conditions.\",\n    \"Check the validity of the reconstructed sequence against the total concert durations provided.\",\n    \"Output 'YES' and the sequence a if a valid sequence is found, otherwise output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'repertoire': refers to the initial set of songs each singer has, which is expanded as they visit each town.\n    'concert duration': refers to the total time a singer performs in each town, which increases as they visit more towns.\n\n# [phrase showing quantity relationship]\n    '2 \u22c5 a_i': indicates that the concert duration in the next town is twice the initial repertoire duration.\n    '(k + 2) \u22c5 a_i': indicates that the concert duration increases by a factor of (k + 2) times the initial repertoire duration as the singer visits more towns.\n    'n \u22c5 a_i': indicates that the concert duration in the last town is n times the initial repertoire duration.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for parsing input and determining the sequence should be implemented simultaneously for efficiency. Specifically, parsing the input and initializing the array a can be done in one block, followed by the logic to determine if a valid sequence exists.\n\n# [edge case]\n    Test case with n = 1 and b = [1] = YES, 1\n    Explanation: With only one town, the singer's initial repertoire matches the total concert duration.\n    \n    Test case with n = 2 and b = [2, 4] = YES, 1 2\n    Explanation: The first singer performs for 1 minute in the first town and 2 minutes in the second town. The second singer performs for 2 minutes in the first town and 4 minutes in the second town.\n    \n    Test case with n = 3 and b = [3, 6, 9] = YES, 1 2 3\n    Explanation: Each singer's initial repertoire matches the pattern of increasing concert durations.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n = 1 or the sequence cannot be reconstructed.\n    ```python\n    if n == 1:\n        if b[0] % n == 0:\n            print(\"YES\")\n            print(b[0] // n)\n        else:\n            print(\"NO\")\n    else:\n        # Implement logic to reconstruct sequence a\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] % n == 0:\n                results.append(\"YES\")\n                results.append(str(b[0] // n))\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nif __name__ == \"__main__\":\n    solve()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of towns and the total duration of concerts in each town.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Parsed data structure containing test cases\"\n    },\n    {\n      \"description\": \"For each test case, determine if a valid sequence of initial repertoire durations exists that satisfies the given conditions.\",\n      \"input\": \"Number of towns and total concert durations for each town\",\n      \"output\": \"Boolean indicating if a valid sequence exists\"\n    },\n    {\n      \"description\": \"If a valid sequence exists, reconstruct one possible sequence of initial repertoire durations for the singers.\",\n      \"input\": \"Number of towns and total concert durations for each town\",\n      \"output\": \"A sequence of initial repertoire durations\"\n    },\n    {\n      \"description\": \"Format the output for each test case, indicating whether a valid sequence was found and, if so, providing the sequence.\",\n      \"input\": \"Boolean indicating validity and the sequence of initial repertoire durations\",\n      \"output\": \"Formatted output string for each test case\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"Iterate over each test case to process the number of towns and the total concert durations.\",\n    \"For each test case, attempt to reconstruct a valid sequence of initial repertoire durations:\",\n    \"  - Initialize variables to track the current state of the sequence reconstruction.\",\n    \"  - Use mathematical reasoning or algorithms to determine if a valid sequence can be constructed.\",\n    \"  - If a valid sequence is found, store it; otherwise, mark the test case as impossible.\",\n    \"Format the results for each test case, indicating 'YES' and the sequence if possible, or 'NO' if not.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'circular arrangement'\n    Explanation: The towns are arranged in a circle, meaning the sequence wraps around, and the last town connects back to the first.\n\n    'repertoire'\n    Explanation: Each singer has an initial repertoire duration, which increases as they visit each town.\n\n    'concert duration'\n    Explanation: The total duration of concerts in each town is given, and it is the sum of the contributions from all singers.\n\n# [phrase showing quantity relationship]\n    'exactly one concert'\n    Explanation: Each singer performs exactly one concert in each town, contributing to the total duration.\n\n    'k + 2'\n    Explanation: This indicates the multiplier for the repertoire as the singer moves to the next town. It starts from 1 and increases by 1 for each subsequent town.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for parsing input and formatting output can be implemented simultaneously as they both involve handling input/output operations. The core logic for determining if a valid sequence exists and reconstructing it should be handled in separate steps due to its complexity.\n\n# [edge case]\n    1. Test case with n = 1 and b_1 = 1\n       Expected output: YES, 1\n       Explanation: With only one town and a total duration of 1, the only possible initial repertoire is 1.\n\n    2. Test case with n = 2 and b_1 = b_2 = 2\n       Expected output: NO\n       Explanation: Each singer would need to contribute 1 in each town, but this does not satisfy the increasing duration requirement.\n\n    3. Test case with n = 3 and b_1 = b_2 = b_3 = 3\n       Expected output: YES, 1 1 1\n       Explanation: Each singer starts with 1, and the total duration in each town is 3, which matches the requirement.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Specifically, we need to ensure that the sequence wraps around correctly and that the total duration matches the given constraints.\n    - Implement checks to ensure that the calculated sequence satisfies the increasing duration requirement for each town.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        # Calculate the sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) // 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of a_i\n        total_a = total_b // (n * (n + 1) // 2)\n        \n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            # Calculate the difference\n            diff = b[i] - b[i - 1] if i > 0 else b[i] - b[n - 1]\n            \n            # Calculate a_i\n            if (total_a + diff) % n != 0 or (total_a + diff) // n <= 0:\n                possible = False\n                break\n            \n            a[i] = (total_a + diff) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        # Calculate the sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) // 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of a_i\n        total_a = total_b // (n * (n + 1) // 2)\n        \n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            # Calculate the difference\n            diff = b[i] - b[i - 1] if i > 0 else b[i] - b[n - 1]\n            \n            # Calculate a_i\n            if (total_a + diff) % n != 0 or (total_a + diff) // n <= 0:\n                possible = False\n                break\n            \n            a[i] = (total_a + diff) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of towns.\",\n        \"Read the array b of n integers, which represents the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence a exists for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize an empty list to store the sequence a.\",\n        \"Iterate over each town and calculate the possible initial duration a_i for the singer in that town.\",\n        \"Check if the calculated sequence a satisfies the conditions given in the problem statement.\",\n        \"If a valid sequence is found, store it; otherwise, mark the test case as impossible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a valid sequence a was found, print 'YES' followed by the sequence a.\",\n        \"If no valid sequence was found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence a that satisfies the given conditions.\",\n    \"Output 'YES' and the sequence a if a valid sequence is found; otherwise, output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'circular arrangement'\n    Explanation: The towns are arranged in a circle, meaning the sequence wraps around after the last town back to the first.\n\n    'repertoire growth'\n    Explanation: Each singer's repertoire grows as they visit each town, adding a song of their initial repertoire length to their total performance time.\n\n# [phrase showing quantity relationship]\n    'exactly one concert'\n    Explanation: Each singer performs exactly once in each town, which means the total concert time in each town is a sum of contributions from all singers.\n\n    'k + 2'\n    Explanation: This indicates the multiplier for the repertoire as the singer moves to the next town. It starts from 1 and increases by 1 for each subsequent town.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps to parse input and determine if a valid sequence exists should be implemented simultaneously for efficiency. Specifically, parsing the input and calculating the possible initial duration a_i can be done in a single loop over the test cases.\n\n# [edge case]\n    Test case with n = 1 and b_1 = 1\n    Explanation: The simplest case where there is only one town and one singer. The expected output is YES with a_1 = 1.\n\n    Test case with n = 2 and b_1 = b_2 = 2\n    Explanation: Each singer can have an initial repertoire of 1, leading to a total of 2 in each town. The expected output is YES with a_1 = 1, a_2 = 1.\n\n    Test case with n = 3 and b_1 = b_2 = b_3 = 3\n    Explanation: Each singer can have an initial repertoire of 1, leading to a total of 3 in each town. The expected output is YES with a_1 = 1, a_2 = 1, a_3 = 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the calculated sequence a satisfies the constraints for each test case. This involves checking if the sum of the calculated sequence matches the given b array for each town.\n\n    Example code for handling edge cases:\n    ```python\n    def is_valid_sequence(n, b):\n        a = [0] * n\n        for i in range(n):\n            a[i] = b[i] //", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev = (i - 1 + n) % n\n            diff = b[i] - b[prev]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev = (i - 1 + n) % n\n            diff = b[i] - b[prev]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of towns.\",\n        \"Read the array b of n integers, which represents the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence a exists for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over possible values of a_i to reconstruct the sequence a.\",\n        \"Calculate the total concert duration for each town based on the sequence a.\",\n        \"Check if the calculated durations match the given durations in array b.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"If a valid sequence a is found, print 'YES' followed by the sequence a.\",\n        \"If no valid sequence a is found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize the program to read input data.\",\n    \"For each test case, attempt to reconstruct the sequence a by iterating over possible values.\",\n    \"Calculate the concert durations for each town based on the sequence a.\",\n    \"Compare calculated durations with the given durations in array b.\",\n    \"Output 'YES' and the sequence a if a valid sequence is found, otherwise output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'repertoire': refers to the initial duration of songs each singer has before visiting other towns.\n    'concert duration': refers to the total time a singer performs in a town, including newly inspired songs.\n    Explanation: The requirement involves reconstructing the initial repertoire of each singer based on the total concert durations in each town.\n\n# [phrase showing quantity relationship]\n    '2 \u22c5 a_i': means the concert duration in the next town is twice the initial repertoire.\n    '(k + 2) \u22c5 a_i': means the concert duration increases by a factor of (k + 2) times the initial repertoire as the singer moves to subsequent towns.\n    Explanation: These phrases describe how the concert duration increases as singers move from town to town, based on their initial repertoire.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for parsing input and determining if a valid sequence exists should be implemented simultaneously for efficiency. Specifically, iterating over possible values of a_i and calculating concert durations should be done in a single loop to minimize complexity.\n\n# [edge case]\n    Test case with n = 1 and b = [1] = YES, 1\n    Explanation: With only one town, the initial repertoire must match the total concert duration.\n    Test case with n = 2 and b = [2, 4] = YES, 1 2\n    Explanation: The first singer performs for 1 minute in the first town and 2 minutes in the second town, while the second singer performs for 2 minutes in the first town and 4 minutes in the second town.\n    Test case with n = 3 and b = [3, 6, 9] = NO\n    Explanation: It's impossible to reconstruct a valid sequence a that satisfies the given concert durations.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Implement logic to check if the sum of calculated durations matches the given durations in array b for each test case.\n    ```python\n    def reconstruct_sequence(t, test_cases):\n        results = []\n        for n, b in test_cases:\n            possible = False\n            for a1 in range(1, b[0] + 1):\n                a = [a1]\n                valid = True\n                for i in range(1, n):\n                    ai = b[i] // (i + 1)\n                    if ai * (i", "Round_0": {"code": "def reconstruct_sequence(t, test_cases):\n    results = []\n    \n    for n, b in test_cases:\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) / 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff + total_a) % n != 0 or (diff + total_a) <= 0:\n                possible = False\n                break\n            a[i] = (diff + total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, b))\n    \n    results = reconstruct_sequence(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of towns.\",\n        \"For each test case, read the array b, which contains the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence a exists for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize an array a of size n to store the initial duration of repertoire for each singer.\",\n        \"Iterate over each town and calculate the possible values for a_i based on the given b_i values.\",\n        \"Check if the calculated values for a_i satisfy the conditions for all towns.\",\n        \"If a valid sequence is found, store it; otherwise, mark the test case as impossible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a valid sequence a was found, print 'YES' followed by the sequence.\",\n        \"If no valid sequence was found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence a that satisfies the given conditions.\",\n    \"Output 'YES' and the sequence a if a valid sequence is found; otherwise, output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sequence of positive integers a'\n    This refers to the initial duration of repertoire for each singer in each town, which needs to be reconstructed based on the given conditions.\n\n    'concert duration'\n    This refers to the total duration of concerts in each town, which is provided in the array b.\n\n# [phrase showing quantity relationship]\n    '2 \u22c5 a_i': This indicates that the concert duration in the next town is twice the initial repertoire duration of the singer.\n    'k + 2 \u22c5 a_i': This indicates that the concert duration increases by a factor of (k + 2) times the initial repertoire duration as the singer moves to subsequent towns.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps to parse the input and determine if a valid sequence exists should be implemented simultaneously for efficiency. Specifically, parsing the input and initializing the array a should be done in one code block, followed by the logic to calculate and validate the sequence.\n\n# [edge case]\n    Test case with n = 1 and b_1 = 1: \n    Expected output: YES, 1\n    Explanation: With only one town, the singer's repertoire can be exactly the concert duration.\n\n    Test case with n = 2 and b_1 = 2, b_2 = 4:\n    Expected output: YES, 1 2\n    Explanation: The first singer performs for 1 minute in the first town and 2 minutes in the second town, while the second singer performs for 2 minutes in the first town and 4 minutes in the second town.\n\n    Test case with n = 3 and b_1 = 3, b_2 = 6, b_3 = 9:\n    Expected output: NO\n    Explanation: It's impossible to find a sequence where each singer's concert duration matches the given b values.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the logic for calculating the sequence a correctly handles cases where n = 1 or where the sequence cannot be constructed due to constraints.\n\n    ```python\n    if n == 1:\n        if b[0] > 0:\n            print(\"YES\")\n            print(b[0])\n        else:\n            print(\"NO\")\n    else:\n        # Implement logic to calculate sequence a and validate it\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            results.append(\"YES\")\n            results.append(str(b[0]))\n            continue\n        \n        total_sum = sum(b)\n        if total_sum % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a_sum = total_sum // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev_index = (i - 1 + n) % n\n            diff = b[i] - b[prev_index]\n            if (total_a_sum - diff) % n != 0 or (total_a_sum - diff) // n <= 0:\n                possible = False\n                break\n            a[i] = (total_a_sum - diff) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            results.append(\"YES\")\n            results.append(str(b[0]))\n            continue\n        \n        total_sum = sum(b)\n        if total_sum % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a_sum = total_sum // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev_index = (i - 1 + n) % n\n            diff = b[i] - b[prev_index]\n            if (total_a_sum - diff) % n != 0 or (total_a_sum - diff) // n <= 0:\n                possible = False\n                break\n            a[i] = (total_a_sum - diff) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of towns.\",\n        \"Read the array b, which contains the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence a exists for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize an empty list to store the sequence a.\",\n        \"Iterate over each town and calculate the possible initial duration a_i for the singer in that town.\",\n        \"Check if the calculated sequence a satisfies the conditions given in the problem statement.\",\n        \"If a valid sequence is found, store it; otherwise, mark the test case as impossible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a valid sequence a was found, print 'YES' followed by the sequence a.\",\n        \"If no valid sequence was found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence a that satisfies the given conditions.\",\n    \"Output 'YES' and the sequence a if a valid sequence is found; otherwise, output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sequence of positive integers a'\n    Explanation: The requirement is to reconstruct a sequence of positive integers that represents the initial duration of repertoire for each singer in each town. This sequence must satisfy the conditions given for the total duration of concerts in each town.\n\n# [phrase showing quantity relationship]\n    '2 \u22c5 a_i', '(k + 2) \u22c5 a_i', 'n \u22c5 a_i'\n    Explanation: These phrases describe how the duration of concerts increases as the singer moves from town to town. The concert duration in each subsequent town is a multiple of the initial duration a_i. This relationship needs to be implemented in code by calculating the concert duration for each town based on the singer's initial repertoire.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps to parse the input and determine if a valid sequence exists should be implemented simultaneously for each test case. This involves reading the input, calculating the sequence, and checking its validity in one cohesive block of code.\n\n# [edge case]\n    Test case with n = 1 and b_1 = 1: \n    Expected output: YES followed by 1\n    Explanation: With only one town and a concert duration of 1, the initial repertoire must be 1 to satisfy the condition.\n    \n    Test case with n = 3 and b = [1, 2, 3]: \n    Expected output: NO\n    Explanation: It's impossible to satisfy the conditions with these concert durations as they don't align with the required multiples of initial repertoire.\n    \n    Test case with n = 6 and b = [81, 75, 75, 93, 93, 87]: \n    Expected output: YES followed by a valid sequence such as 5 5 4 1 4 5\n    Explanation: The sequence satisfies the conditions for concert durations in each town.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling the edge case:\n    ```python\n    def reconstruct_sequence(t, test_cases):\n        results = []\n        for n, b in test_cases:\n            a = [0] * n\n            possible = True\n            for i in range(n):\n                if b[i] % n != 0:\n                    possible = False\n                    break\n                a[i] = b[i] // n\n            if possible:\n                results.append(f\"YES\\n{'", "Round_0": {"code": "def reconstruct_sequence(t, test_cases):\n    results = []\n    for n, b in test_cases:\n        total_sum = sum(b)\n        if total_sum % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a_sum = total_sum // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev_index = (i - 1 + n) % n\n            diff = b[i] - b[prev_index]\n            if (total_a_sum - diff) % n != 0 or total_a_sum - diff <= 0:\n                possible = False\n                break\n            a[i] = (total_a_sum - diff) // n\n        \n        if possible:\n            results.append(f\"YES\\n{' '.join(map(str, a))}\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, b))\n    \n    results = reconstruct_sequence(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, false, false, true, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 601, "prompt": "n towns are arranged in a circle sequentially. The towns are numbered from 1 to n in clockwise order. In the i-th town, there lives a singer with a repertoire of a_i minutes for each i \u2208 [1, n].\n\nEach singer visited all n towns in clockwise order, starting with the town he lives in, and gave exactly one concert in each town. In addition, in each town, the i-th singer got inspired and came up with a song that lasts a_i minutes. The song was added to his repertoire so that he could perform it in the rest of the cities.\n\nHence, for the i-th singer, the concert in the i-th town will last a_i minutes, in the (i + 1)-th town the concert will last 2 \u22c5 a_i minutes, ..., in the ((i + k) mod n + 1)-th town the duration of the concert will be (k + 2) \u22c5 a_i, ..., in the town ((i + n - 2) mod n + 1) \u2014 n \u22c5 a_i minutes.\n\nYou are given an array of b integer numbers, where b_i is the total duration of concerts in the i-th town. Reconstruct any correct sequence of positive integers a or say that it is impossible. Ensure that the reconstructed sequence satisfies the given constraints and conditions.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of two lines. The first line contains a single integer n (1 \u2264 n \u2264 4 \u22c5 10^4) \u2014 the number of cities. The second line contains n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 10^{9}) \u2014 the total duration of concerts in i-th city.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print the answer as follows:\n\nIf there is no suitable sequence a, print NO. Otherwise, on the first line print YES, on the next line print the sequence a_1, a_2, ..., a_n of n integers, where a_i (1 \u2264 a_i \u2264 10^{9}) is the initial duration of repertoire of the i-th singer. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n\n\nOutput\n\n\nYES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n\nNote\n\nLet's consider the 1-st test case of the example:\n\n  1. the 1-st singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 6 minutes, in the 3-rd \u2014 for 9 minutes; \n  2. the 2-nd singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 1 minute, in the 3-rd - for 2 minutes; \n  3. the 3-rd singer in the 1-st city will give a concert for 6 minutes, in the 2-nd \u2014 for 9 minutes, in the 3-rd \u2014 for 3 minutes. ", "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of two lines. The first line contains a single integer n (1 \u2264 n \u2264 4 \u22c5 10^4) \u2014 the number of cities. The second line contains n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 10^{9}) \u2014 the total duration of concerts in i-th city.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print the answer as follows:\n\nIf there is no suitable sequence a, print NO. Otherwise, on the first line print YES, on the next line print the sequence a_1, a_2, ..., a_n of n integers, where a_i (1 \u2264 a_i \u2264 10^{9}) is the initial duration of repertoire of the i-th singer. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n\n\nOutput\n\n\nYES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n\nNote\n\nLet's consider the 1-st test case of the example:\n\n  1. the 1-st singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 6 minutes, in the 3-rd \u2014 for 9 minutes; \n  2. the 2-nd singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 1 minute, in the 3-rd - for 2 minutes; \n  3. the 3-rd singer in the 1-st city will give a concert for 6 minutes, in the 2-nd \u2014 for 9 minutes, in the 3-rd \u2014 for 3 minutes. ", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 45}
