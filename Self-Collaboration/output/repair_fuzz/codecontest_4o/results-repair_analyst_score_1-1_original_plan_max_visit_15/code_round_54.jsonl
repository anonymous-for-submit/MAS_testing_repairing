{"name": "1622_E. Math Test", "description": "Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.\n\nIf the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.\n\nFor the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 ", "tags": ["bitmasks", "brute force", "greedy"], "difficulty": 11, "id": 1622, "sample_io": [{"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n", "output": ["3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n"]}], "test_list": [{"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n001\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1 4 2 6 3 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 4 1 6 2 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n13 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n101\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 2\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n000110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n3 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111001\n", "output": ["3 1 2\n3 1 4 2\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 2\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n2 1\n"]}, {"input": "3\n4 3\n5 1 1 0\n111\n000\n101\n010\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["1 2 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000001\n111111\n", "output": ["3 1 2\n2 3 4 1\n4 1 5 2 3 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1101\n0010\n0110\n0111\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 4 1 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n2 4 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n4 1 2 3\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0011\n0110\n0001\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n1 2 4 3\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n001\n110\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["3 2 1\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0010\n0101\n3 2\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n101\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["2 1 3\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n9 1 4 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000100\n111101\n", "output": ["3 1 2\n2 3 4 1\n4 3 5 1 2 6\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n111\n100\n4 4\n6 2 0 10\n1001\n0011\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111011\n", "output": ["3 2 1\n1 2 4 3\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n001\n110\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["2 1 3\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n001\n110\n4 4\n0 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["2 1 3\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 3 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100100\n111101\n", "output": ["3 1 2\n2 3 4 1\n6 2 3 4 1 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n1 2 0 10\n1101\n0010\n0100\n0111\n3 6\n38 3 7\n010110\n100101\n111101\n", "output": ["3 1 2\n3 4 1 2\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n1 1 2 0\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0011\n0111\n0101\n3 1\n20 3 2\n011110\n000101\n111011\n", "output": ["3 1 2\n1 2 4 3\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n000\n4 4\n6 3 0 10\n0001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100100\n111101\n", "output": ["2 1 3\n2 3 4 1\n6 2 3 4 1 5\n"]}, {"input": "3\n4 3\n5 1 3 4\n100\n100\n101\n100\n4 4\n12 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 4\n010110\n010101\n111111\n", "output": ["1 2 3\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n110\n000\n100\n100\n4 4\n6 2 1 11\n1001\n0010\n0110\n0101\n3 6\n38 0 7\n110110\n000101\n111101\n", "output": ["3 2 1\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n000\n4 4\n6 3 0 1\n0001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100100\n111101\n", "output": ["2 1 3\n1 4 3 2\n6 2 3 4 1 5\n"]}, {"input": "3\n4 3\n3 1 3 2\n110\n000\n100\n100\n4 4\n6 2 1 11\n1001\n0010\n0110\n0101\n3 6\n38 0 7\n110110\n000101\n111101\n", "output": ["1 3 2\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n0 1 2 1\n110\n100\n100\n101\n4 4\n2 2 0 13\n1101\n0110\n0110\n0101\n3 6\n38 3 12\n010110\n000001\n111101\n", "output": ["3 1 2\n2 3 4 1\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 2\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 0 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 0 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 3 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n101\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 1 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n11 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 0 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 0\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n13 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 1 0\n111\n000\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0100\n0100\n3 2\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000001\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n1 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0111\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n011\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1101\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n36 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 0 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n1101\n3 1\n34 3 7\n010110\n000101\n110111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0001\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 18\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010010\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 2 2\n101\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 1\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 2\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 10\n0001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n100\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n001\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111101\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n110110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 0\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n110110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n54 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n1 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0110\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111011\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 4\n1001\n0010\n0110\n0101\n3 1\n20 0 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n110\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n4 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n000\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0110\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n100101\n110101\n", "output": ["3 1 2\n2 3 4 1\n3 4 1 6 2 5\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n101\n101\n100\n4 4\n6 2 0 10\n1001\n0000\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0010\n0001\n3 1\n30 1 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n11 1 1 11\n1001\n0010\n1110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 2 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 0 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110110\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n13 1 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 1 0\n011\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n1110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n101\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111011\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n1110\n0101\n3 6\n20 3 15\n000110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n2 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n1 1\n20 3 7\n010110\n010101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n9 1 4 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n011\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n101\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n36 3 7\n010100\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n100\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 18\n1001\n0010\n0110\n0101\n3 6\n20 3 0\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0100\n0101\n3 1\n20 3 7\n010010\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 2 2\n101\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n011110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n010101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n3 1 0 10\n0001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n100\n100\n4 4\n6 2 0 11\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n000\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 17\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n0 1 2 0\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 6\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n110110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n54 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n010\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111001\n", "output": ["3 1 2\n3 1 4 2\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n1 2 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n111\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111011\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n000\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n8 1 0 10\n1001\n0110\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n010\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n100101\n110101\n", "output": ["3 1 2\n2 3 4 1\n3 4 1 6 2 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0010\n0001\n3 1\n30 0 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 2 0 10\n1001\n0010\n0110\n0100\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 0 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n2 1\n66 3 2\n010110\n000101\n110110\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 0\n011\n100\n111\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n1110\n0100\n3 1\n20 0 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 2 4 2\n111\n101\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111011\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 0 1 0\n111\n000\n101\n010\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["1 2 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 17\n1001\n0010\n0110\n0101\n1 1\n20 3 7\n010110\n010101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n011\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1101\n0010\n0100\n0111\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 4 1 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n100\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 0\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0011\n0110\n0001\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n1 2 4 3\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 18\n1001\n0010\n0110\n0101\n3 6\n20 3 0\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n4 1 2 2\n101\n110\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n011110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n100\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n010101\n111111\n", "output": ["1 2 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n100\n100\n4 4\n6 2 1 11\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n4 1 2 2\n111\n100\n000\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 17\n1001\n0110\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n110110\n000100\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n111\n100\n101\n000\n4 4\n4 1 0 10\n1001\n0010\n0110\n0001\n3 1\n54 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n011\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111001\n", "output": ["3 1 2\n3 1 4 2\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n000\n4 4\n12 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n1 0 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n000\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000111\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n000\n4 4\n6 1 0 10\n1101\n0010\n0010\n0101\n3 2\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n8 1 0 10\n1001\n0110\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n101\n101\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["2 1 3\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 1 0\n011\n100\n111\n000\n4 4\n20 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 3 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111110\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 17\n1001\n0010\n0110\n0101\n1 1\n20 3 8\n010110\n010101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}], "task_id": "codecontest/158", "repair_prompt": ["Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.\n\nIf the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.\n\nFor the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them. Assume all input values are integers.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.\n\nIf the student answers the j-th question correctly, he gets p_j points. If the student answers incorrectly or does not answer, he receives 0 points for that particular question. Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.\n\nFor the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them. Assume all input values are integers.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Petya is a math teacher. n of his students has written a test consisting of m questions, and for each student, it is known which questions he has answered correctly and which he has not. If the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points), and the array p is a permutation of numbers from 1 to m. For the i-th student, Petya knows that he expects to get x_i points for the test and wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test. Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them. Assume all input values are integers.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "import sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda j: correct_counts[j])\n        \n        # Assign points in descending order to questions with fewer correct answers\n        p = [0] * m\n        for i, j in enumerate(question_indices):\n            p[j] = m - i\n        \n        results.append(' '.join(map(str, p)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        student_answers = []\n        for _ in range(n):\n            student_answers.append(data[index])\n            index += 1\n        \n        # Initialize the permutation as a list from 1 to m\n        permutation = list(range(1, m + 1))\n        \n        # Sort the permutation in descending order\n        permutation.sort(reverse=True)\n        \n        # Calculate the actual points for each student\n        actual_points = [0] * n\n        for i in range(n):\n            for j in range(m):\n                if student_answers[i][j] == '1':\n                    actual_points[i] += permutation[j]\n        \n        # Calculate the surprise value\n        surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n        \n        # Store the result\n        results.append(' '.join(map(str, permutation)))\n    \n    # Output the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef find_maximum_surprise_permutation(n, m, expected_points, answers):\n    # To maximize the surprise value, we should assign the highest points to the questions\n    # that are least expected by the students. This means sorting the questions by the number\n    # of students who answered them correctly and assigning the highest points to the least\n    # answered questions.\n    \n    # Count how many students answered each question correctly\n    question_correct_count = [0] * m\n    for i in range(n):\n        for j in range(m):\n            if answers[i][j] == '1':\n                question_correct_count[j] += 1\n    \n    # Create a list of question indices sorted by the number of correct answers (ascending)\n    sorted_questions = sorted(range(m), key=lambda x: question_correct_count[x])\n    \n    # Assign points from 1 to m based on the sorted order\n    permutation = [0] * m\n    for i, question_index in enumerate(sorted_questions):\n        permutation[question_index] = i + 1\n    \n    return permutation\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        best_permutation = find_maximum_surprise_permutation(n, m, expected_points, answers)\n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\ninput = sys.stdin.read\n\ndef solve():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_count[j] += 1\n        \n        # Sort questions by the number of correct answers in descending order\n        sorted_questions = sorted(range(m), key=lambda j: correct_count[j], reverse=True)\n        \n        # Assign points in descending order to the questions sorted by correct answers\n        permutation = [0] * m\n        for i, question_index in enumerate(sorted_questions):\n            permutation[question_index] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nsolve()\n\nmain()", "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation\n        initial_permutation = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(initial_permutation):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points array\n        permutations = itertools.permutations(range(1, m + 1))\n        \n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in permutations:\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    total_surprise = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        total_surprise += abs(expected_points[i] - actual_points)\n    return total_surprise\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of point values from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\n\ndef maximize_surprise(t, test_cases):\n    results = []\n    for n, m, x, answers in test_cases:\n        # Calculate the frequency of correct answers for each question\n        question_correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Sort questions by the number of correct answers in descending order\n        sorted_questions = sorted(range(m), key=lambda j: question_correct_count[j], reverse=True)\n        \n        # Assign the highest points to the most frequently correctly answered questions\n        points = list(range(1, m + 1))\n        p = [0] * m\n        for idx, question in enumerate(sorted_questions):\n            p[question] = points[idx]\n        \n        results.append(p)\n    \n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, x, answers))\n    \n    results = maximize_surprise(t, test_cases)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nimport itertools\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        # We can use itertools.permutations to generate permutations\n        for perm in itertools.permutations(range(1, m + 1)):\n            # Calculate the actual points for each student\n            actual_points = []\n            for i in range(n):\n                total_points = 0\n                for j in range(m):\n                    if answers[i][j] == '1':\n                        total_points += perm[j]\n                actual_points.append(total_points)\n            \n            # Calculate the surprise value\n            surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n            \n            # Check if this is the maximum surprise value\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        # Store the result for this test case\n        results.append(' '.join(map(str, best_permutation)))\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    total_surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        total_surprise_value += abs(expected_points[i] - actual_points)\n    return total_surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the permutation of points from 1 to m\n        points = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in itertools.permutations(points):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda j: correct_counts[j])\n        \n        # Assign points in descending order to questions with fewer correct answers\n        p = [0] * m\n        for i, j in enumerate(question_indices):\n            p[j] = m - i\n        \n        results.append(' '.join(map(str, p)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"output\": \"A function that computes the actual points for each student based on a given permutation of question points.\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of absolute differences between expected and actual points for all students.\",\n      \"output\": \"A permutation of question points that maximizes the surprise value.\"\n    },\n    {\n      \"description\": \"Output the permutation of question points for each test case.\",\n      \"output\": \"Formatted output of the permutation for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a permutation of question points as a list of integers from 1 to m.\",\n    \"For each permutation of question points, calculate the actual points for each student and compute the surprise value.\",\n    \"Iterate over all possible permutations of question points to find the one that maximizes the surprise value.\",\n    \"Store the permutation that results in the maximum surprise value for each test case.\",\n    \"Output the stored permutation for each test case in the required format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation refers to an arrangement of the question points such that each question is assigned a unique point value from 1 to m.\n\n    'surprise value'\n    Explanation: The surprise value is defined as the sum of the absolute differences between the expected points and the actual points obtained by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that we need to find the permutation of question points that results in the highest possible surprise value.\n\n# [degree adverb] \n    'maximum'\n    Explanation: This means we are looking for the permutation that results in the greatest possible surprise value.\n\n# [code logic]\n    The steps \"For each permutation of question points, calculate the actual points for each student and compute the surprise value\" and \"Iterate over all possible permutations of question points to find the one that maximizes the surprise value\" should be considered simultaneously. This can be implemented using a loop to iterate over permutations and a function to calculate the surprise value for each permutation.\n\n# [edge case] \n    Edge Case 1: n = 1, m = 1, x = [0], s = [\"0\"]\n    Expected Output: 1\n    Explanation: With only one question and the student expecting 0 points, the permutation doesn't matter as the surprise value will be 0.\n\n    Edge Case 2: n = 1, m = 10, x = [55], s = [\"1111111111\"]\n    Expected Output: 10 9 8 7 6 5 4 3 2 1\n    Explanation: The student expects the maximum possible points, so the permutation should be in descending order to maximize the surprise value.\n\n    Edge Case 3: n = 10, m = 1, x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], s = [\"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\"]\n    Expected Output: 1\n    Explanation: With all students expecting 0 points and no correct answers, the permutation doesn't affect the surprise value.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The", "Round_0": {"code": "import sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda j: correct_counts[j])\n        \n        # Assign points in descending order to questions with fewer correct answers\n        p = [0] * m\n        for i, j in enumerate(question_indices):\n            p[j] = m - i\n        \n        results.append(' '.join(map(str, p)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 138)"}, "Round_1": {"code": "import sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda j: correct_counts[j])\n        \n        # Assign points in descending order to questions with fewer correct answers\n        p = [0] * m\n        for i, j in enumerate(question_indices):\n            p[j] = m - i\n        \n        results.append(' '.join(map(str, p)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"output\": \"A function that computes the actual points for each student based on a given permutation of question points.\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of absolute differences between expected and actual points for all students.\",\n      \"output\": \"A permutation of question points that maximizes the surprise value.\"\n    },\n    {\n      \"description\": \"Output the permutation of question points for each test case.\",\n      \"output\": \"Formatted output of the permutation for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Parse the number of students, number of questions, expected points, and student answers.\",\n    \"  b. Initialize a permutation of question points as a list of integers from 1 to m.\",\n    \"  c. Calculate the actual points for each student using the current permutation.\",\n    \"  d. Compute the surprise value for the current permutation.\",\n    \"  e. Explore different permutations of question points to find the one that maximizes the surprise value.\",\n    \"  f. Store the permutation that results in the maximum surprise value.\",\n    \"Output the stored permutation for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation refers to an arrangement of the question points from 1 to m. The task is to find such an arrangement that maximizes the surprise value.\n\n    'surprise value'\n    Explanation: The surprise value is defined as the sum of the absolute differences between the expected points and the actual points obtained by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible': This indicates that we need to find the permutation that results in the highest possible surprise value. In code, this involves iterating over possible permutations and selecting the one with the highest computed surprise value.\n\n# [degree adverb] \n    'maximum': This refers to the highest possible value of the surprise value. In code, this can be implemented by keeping track of the highest surprise value encountered during the permutation exploration.\n\n# [code logic]\n    Steps 3e and 3f should be considered simultaneously. The exploration of different permutations (3e) and storing the permutation that results in the maximum surprise value (3f) are closely related and can be implemented in a single loop or recursive function that checks each permutation and updates the maximum surprise value and corresponding permutation.\n\n# [edge case] \n    1. Test case with n=1, m=1, x_1=0, s_1=\"0\" = 1\n       Explanation: With only one question and the student expecting 0 points, any permutation will result in a surprise value of 0, which is the maximum possible.\n    2. Test case with n=1, m=1, x_1=1, s_1=\"1\" = 1\n       Explanation: The student expects 1 point and answers correctly, so the permutation [1] results in a surprise value of 0, which is the maximum possible.\n    3. Test case with n=2, m=2, x_1=1, x_2=2, s_1=\"10\", s_2=\"01\" = 2 1\n       Explanation: The permutation [2, 1] results in the maximum surprise value because it maximizes the difference between expected and actual points.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should handle cases where the number of questions is minimal (m=1) and where students have varying expectations and", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        student_answers = []\n        for _ in range(n):\n            student_answers.append(data[index])\n            index += 1\n        \n        # Initialize the permutation as a list from 1 to m\n        permutation = list(range(1, m + 1))\n        \n        # Sort the permutation in descending order\n        permutation.sort(reverse=True)\n        \n        # Calculate the actual points for each student\n        actual_points = [0] * n\n        for i in range(n):\n            for j in range(m):\n                if student_answers[i][j] == '1':\n                    actual_points[i] += permutation[j]\n        \n        # Calculate the surprise value\n        surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n        \n        # Store the result\n        results.append(' '.join(map(str, permutation)))\n    \n    # Output the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 106)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        student_answers = []\n        for _ in range(n):\n            student_answers.append(data[index])\n            index += 1\n        \n        # Initialize the permutation as a list from 1 to m\n        permutation = list(range(1, m + 1))\n        \n        # Sort the permutation in descending order\n        permutation.sort(reverse=True)\n        \n        # Calculate the actual points for each student\n        actual_points = [0] * n\n        for i in range(n):\n            for j in range(m):\n                if student_answers[i][j] == '1':\n                    actual_points[i] += permutation[j]\n        \n        # Calculate the surprise value\n        surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n        \n        # Store the result\n        results.append(' '.join(map(str, permutation)))\n    \n    # Output the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"output\": \"A function that computes the actual points for each student based on a given permutation of question points.\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of absolute differences between expected and actual points for all students.\",\n      \"output\": \"A permutation of question points that maximizes the surprise value.\"\n    },\n    {\n      \"description\": \"Output the permutation of question points for each test case.\",\n      \"output\": \"Formatted output of the permutation for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a permutation of question points as a list of integers from 1 to m.\",\n    \"Iterate over all possible permutations of question points and calculate the actual points for each student using the current permutation.\",\n    \"Compute the surprise value for each permutation by summing the absolute differences between expected and actual points for all students.\",\n    \"Track the permutation that results in the maximum surprise value.\",\n    \"Once the optimal permutation is found for a test case, store the result.\",\n    \"After processing all test cases, output the stored permutations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation refers to an arrangement of the question points such that each question is assigned a unique point value from 1 to m.\n\n    'surprise value'\n    Explanation: The surprise value is the sum of the absolute differences between the expected points and the actual points obtained by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that we need to find the permutation of question points that results in the highest possible surprise value.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This means we are looking for the permutation that results in the greatest possible surprise value.\n\n# [code logic]\n    The steps related to iterating over permutations and calculating the surprise value should be considered simultaneously. Specifically, the steps:\n    - \"Iterate over all possible permutations of question points and calculate the actual points for each student using the current permutation.\"\n    - \"Compute the surprise value for each permutation by summing the absolute differences between expected and actual points for all students.\"\n    These can be implemented in a single loop where each permutation is evaluated for its surprise value.\n\n# [edge case]\n    Edge cases are not explicitly provided in the requirement, but we can infer some:\n    - Case with minimum values: 1 student, 1 question, expected points = 0, answers = \"0\"\n      Expected output: [1]\n      Explanation: With only one question, the permutation is trivial, and the surprise value is maximized by assigning the only available point.\n    - Case with all students expecting 0 points: n students, m questions, all x_i = 0, all answers = \"0\"\n      Expected output: Any permutation of [1, 2, ..., m]\n      Explanation: Since all students expect 0 points and answer no questions, any permutation will result in the same surprise value.\n    - Case with all students answering all questions correctly: n students, m questions, all x_i = m(m+1)/2, all answers = \"1\" * m\n      Expected output: Any permutation of [1, 2, ..., m]\n      Explanation: Since all students answer all questions correctly and expect the maximum possible points, any permutation will result in the same surprise value.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over permutations", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef find_maximum_surprise_permutation(n, m, expected_points, answers):\n    max_surprise_value = -1\n    best_permutation = None\n    initial_permutation = list(range(1, m + 1))\n    \n    for perm in permutations(initial_permutation):\n        current_surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n        if current_surprise_value > max_surprise_value:\n            max_surprise_value = current_surprise_value\n            best_permutation = perm\n    \n    return best_permutation\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        best_permutation = find_maximum_surprise_permutation(n, m, expected_points, answers)\n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 108)"}, "Round_1": {"code": "import sys\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef find_maximum_surprise_permutation(n, m, expected_points, answers):\n    # To maximize the surprise value, we should assign the highest points to the questions\n    # that are least expected by the students. This means sorting the questions by the number\n    # of students who answered them correctly and assigning the highest points to the least\n    # answered questions.\n    \n    # Count how many students answered each question correctly\n    question_correct_count = [0] * m\n    for i in range(n):\n        for j in range(m):\n            if answers[i][j] == '1':\n                question_correct_count[j] += 1\n    \n    # Create a list of question indices sorted by the number of correct answers (ascending)\n    sorted_questions = sorted(range(m), key=lambda x: question_correct_count[x])\n    \n    # Assign points from 1 to m based on the sorted order\n    permutation = [0] * m\n    for i, question_index in enumerate(sorted_questions):\n        permutation[question_index] = i + 1\n    \n    return permutation\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        best_permutation = find_maximum_surprise_permutation(n, m, expected_points, answers)\n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points for each student, and the answers matrix for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers matrix for each student.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on the answers matrix and a given permutation of points.\",\n      \"steps\": [\n        \"Initialize a permutation of points from 1 to m.\",\n        \"For each student, calculate the total points received using the current permutation and the answers matrix.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over possible permutations of points.\",\n        \"Calculate the surprise value for each permutation using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Select the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation of points that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, initialize a permutation of points and calculate the actual points received by each student.\",\n    \"Iterate over all possible permutations to find the one that maximizes the surprise value.\",\n    \"Output the permutation for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation refers to an arrangement of the point values assigned to each question. The array p is a permutation of numbers from 1 to m, meaning each question is assigned a unique point value from 1 to m.\n\n    'surprise value'\n    Explanation: The surprise value is defined as the sum of the absolute differences between the expected points (x_i) and the actual points (r_i) for each student. The goal is to maximize this value by finding an optimal permutation of point values.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that the task is to find the permutation that results in the highest possible surprise value. In code, this involves iterating over permutations and selecting the one with the highest calculated surprise value.\n\n# [degree adverb]\n    'maximum'\n    Explanation: The requirement is to find the permutation that results in the greatest possible surprise value. This involves comparing the surprise values of different permutations and selecting the largest one.\n\n# [code logic]\n    The steps in the plan related to calculating the actual points and determining the permutation that maximizes the surprise value should be considered simultaneously. Specifically, the calculation of the actual points and the evaluation of the surprise value for each permutation should be done in a single loop to efficiently find the optimal permutation.\n\n# [edge case]\n    Edge Case 1: n = 1, m = 1, x = [0], s = [\"0\"]\n    Expected Output: 1\n    Explanation: With only one question and the student expecting 0 points, any permutation will result in a surprise value of 0, as the student answered incorrectly.\n\n    Edge Case 2: n = 1, m = 10, x = [55], s = [\"1111111111\"]\n    Expected Output: 10 9 8 7 6 5 4 3 2 1\n    Explanation: The student expects the maximum possible points, and the permutation should assign the highest points to the questions answered correctly to maximize the surprise value.\n\n    Edge Case 3: n = 10, m = 1, x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], s = [\"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\",", "Round_0": {"code": "import sys\ninput = sys.stdin.read\n\ndef solve():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_count[j] += 1\n        \n        # Sort questions by the number of correct answers in descending order\n        sorted_questions = sorted(range(m), key=lambda j: correct_count[j], reverse=True)\n        \n        # Assign points in descending order to the questions sorted by correct answers\n        permutation = [0] * m\n        for i, question_index in enumerate(sorted_questions):\n            permutation[question_index] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nsolve()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 127)"}, "Round_1": {"code": "import sys\ninput = sys.stdin.read\n\ndef solve():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_count[j] += 1\n        \n        # Sort questions by the number of correct answers in descending order\n        sorted_questions = sorted(range(m), key=lambda j: correct_count[j], reverse=True)\n        \n        # Assign points in descending order to the questions sorted by correct answers\n        permutation = [0] * m\n        for i, question_index in enumerate(sorted_questions):\n            permutation[question_index] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points, and answers for each student.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers for each student as binary strings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"Initialize a permutation of points from 1 to m.\",\n        \"For each student, calculate the actual points received by summing the points for correctly answered questions.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value.\",\n      \"steps\": [\n        \"For each permutation of points, calculate the surprise value as the sum of absolute differences between expected and actual points for all students.\",\n        \"Identify the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation of points that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract relevant information for each test case.\",\n    \"Generate all possible permutations of points from 1 to m.\",\n    \"For each permutation, calculate the actual points received by each student and compute the surprise value.\",\n    \"Select the permutation that maximizes the surprise value for each test case.\",\n    \"Output the selected permutation for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of the requirement, a permutation refers to an arrangement of the points from 1 to m in a specific order. The task is to find a permutation that maximizes the surprise value.\n\n    'surprise value'\n    Explanation: The surprise value is calculated as the sum of the absolute differences between the expected points and the actual points received by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that the permutation should be chosen such that the surprise value is as large as possible. In code, this involves iterating through all permutations and selecting the one with the highest calculated surprise value.\n\n# [degree adverb]\n    'maximum'\n    Explanation: The requirement is to find the permutation that results in the highest possible surprise value. In code, this means comparing the surprise values of all permutations and selecting the largest one.\n\n# [code logic]\n    The steps for calculating the actual points and determining the permutation that maximizes the surprise value should be considered simultaneously. Specifically, generating permutations and calculating surprise values can be done in a single loop where each permutation is evaluated.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    0\n    0\n    Expected output: 1\n    Explanation: With only one question and the student expecting 0 points, the permutation is trivial, and the surprise value is 0.\n\n    Test case with all students expecting maximum points:\n    2 2\n    3 3\n    11\n    11\n    Expected output: 2 1\n    Explanation: Both students answered all questions correctly, expecting maximum points. The permutation that maximizes the surprise value is one that reverses the order of points.\n\n    Test case with no correct answers:\n    3 3\n    0 0 0\n    000\n    000\n    000\n    Expected output: 1 2 3\n    Explanation: No student answered any question correctly, so the permutation does not affect the surprise value, which remains 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through permutations and calculating surprise values will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation\n        initial_permutation = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(initial_permutation):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 107)"}, "Round_1": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation\n        initial_permutation = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(initial_permutation):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, generate all possible permutations of the points array p, which is a permutation of numbers from 1 to m.\",\n      \"output\": \"A list of all possible permutations of the points array for each test case.\"\n    },\n    {\n      \"description\": \"For each permutation of the points array, calculate the actual points r_i each student would receive based on their answers.\",\n      \"output\": \"The actual points r_i for each student for each permutation of the points array.\"\n    },\n    {\n      \"description\": \"Calculate the surprise value for each permutation by computing the sum of absolute differences between expected points x_i and actual points r_i for all students.\",\n      \"output\": \"The surprise value for each permutation of the points array.\"\n    },\n    {\n      \"description\": \"Identify the permutation of the points array that results in the maximum surprise value.\",\n      \"output\": \"The permutation of the points array that maximizes the surprise value for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract the number of test cases and details for each test case.\",\n    \"For each test case, generate all permutations of the points array p, which is a permutation of numbers from 1 to m.\",\n    \"For each permutation, calculate the actual points r_i for each student based on their answers.\",\n    \"Compute the surprise value for each permutation by summing the absolute differences between expected points x_i and actual points r_i for all students.\",\n    \"Determine the permutation that yields the maximum surprise value and store it as the result for the test case.\",\n    \"Output the permutation with the maximum surprise value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation refers to an arrangement of the numbers from 1 to m, which are the possible points for each question. The task is to find a permutation that maximizes the surprise value.\n\n    'surprise value'\n    Explanation: The surprise value is defined as the sum of the absolute differences between the expected points (x_i) and the actual points (r_i) obtained by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that we need to find the permutation of points that results in the highest possible surprise value. In code, this can be implemented by iterating through all permutations and keeping track of the one with the highest surprise value.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This refers to the highest possible value of the surprise value. In code, this can be implemented by comparing the surprise values of different permutations and selecting the largest one.\n\n# [code logic]\n    The steps to generate permutations and calculate the surprise value should be implemented simultaneously. Specifically, generating permutations and calculating the surprise value for each permutation can be done in a single loop to optimize performance.\n\n# [edge case]\n    1. Test case with n = 1 and m = 1, x_1 = 0, s_1 = \"0\"\n       Expected output: 1\n       Explanation: With only one question and the student expecting 0 points, the permutation doesn't matter as the surprise value will be 0 regardless.\n\n    2. Test case with n = 1 and m = 1, x_1 = 1, s_1 = \"1\"\n       Expected output: 1\n       Explanation: The student expects 1 point and answers correctly, so the permutation should be [1] to match the expectation.\n\n    3. Test case with n = 2 and m = 2, x_1 = 1, x_2 = 2, s_1 = \"10\", s_2 = \"01\"\n       Expected output: 2 1\n       Explanation: To maximize the surprise value, assign the higher point to the question answered correctly by the student expecting fewer points.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of generating permutations and calculating the surprise value will naturally handle these cases.\n\nNO", "Round_0": {"code": "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points array\n        permutations = itertools.permutations(range(1, m + 1))\n        \n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in permutations:\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: calculate_surprise_value() missing 5 required positional arguments: 'n', 'm', 'expected_points', 'answers', and 'permutation'"}, "Round_1": {"code": "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points array\n        permutations = itertools.permutations(range(1, m + 1))\n        \n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in permutations:\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input data to extract the number of test cases, number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers given by each student as binary strings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, initialize their score to zero.\",\n        \"Iterate over each question and add the corresponding point value from the permutation if the student answered correctly.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"Generate all possible permutations of point values from 1 to m.\",\n        \"For each permutation, calculate the total surprise value using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Select the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, generate permutations of point values and calculate the actual scores for each student.\",\n    \"Compute the surprise value for each permutation and identify the permutation that maximizes this value.\",\n    \"Output the optimal permutation for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    In the requirement, permutation refers to arranging the point values from 1 to m in such a way that each arrangement is considered to find the maximum surprise value.\n\n    'surprise value'\n    The surprise value is calculated as the sum of the absolute differences between the expected points and the actual points received by each student.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    This indicates that we need to find the permutation of point values that results in the highest possible surprise value.\n\n# [degree adverb] \n    'maximum'\n    This means we are looking for the permutation that yields the greatest surprise value among all possible permutations.\n\n# [code logic]\n    The steps in the plan related to generating permutations and calculating surprise values should be considered simultaneously. Specifically:\n    - \"Generate all possible permutations of point values from 1 to m.\"\n    - \"For each permutation, calculate the total surprise value using the formula \u2211_{i=1}^{n} |x_i - r_i|.\"\n    These steps can be implemented in a loop where each permutation is evaluated for its surprise value.\n\n# [edge case] \n    Test case with minimum values:\n    1 1\n    0\n    0\n    Expected output: 1\n    Explanation: With only one question and one student expecting 0 points, the permutation [1] results in a surprise value of 1, which is the maximum possible.\n\n    Test case with all students expecting maximum points:\n    2 2\n    3 3\n    11\n    11\n    Expected output: 2 1\n    Explanation: Both students answered all questions correctly, expecting maximum points. The permutation [2, 1] results in a surprise value of 2, which is the maximum possible.\n\n    Test case with no correct answers:\n    3 3\n    0 0 0\n    000\n    000\n    000\n    Expected output: 3 2 1\n    Explanation: No student answered correctly, so the permutation [3, 2, 1] results in a surprise value of 0, which is the maximum possible.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of generating permutations and calculating surprise values will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    total_surprise = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        total_surprise += abs(expected_points[i] - actual_points)\n    return total_surprise\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of point values from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 136)"}, "Round_1": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    total_surprise = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        total_surprise += abs(expected_points[i] - actual_points)\n    return total_surprise\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of point values from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input data to extract the number of test cases, number of students, number of questions, expected points, and students' answers.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers for each student.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the total points received by summing the points for correctly answered questions.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value.\",\n      \"steps\": [\n        \"Generate all possible permutations of points from 1 to m.\",\n        \"For each permutation, calculate the surprise value by summing the absolute differences between expected and actual points for all students.\",\n        \"Select the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"Print the permutation that maximizes the surprise value for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, generate permutations of points and calculate the surprise value for each permutation.\",\n    \"Select the permutation with the maximum surprise value and store it.\",\n    \"Output the selected permutation for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the requirement, permutation refers to arranging the points for questions in such a way that they are a rearrangement of numbers from 1 to m. This is crucial for calculating the surprise value.\n\n    'surprise value'\n    Explanation: The surprise value is calculated as the sum of the absolute differences between the expected points and the actual points received by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that the permutation of points should be chosen such that the surprise value is as large as possible. In code, this involves iterating through all permutations and selecting the one with the highest calculated surprise value.\n\n# [degree adverb]\n    'maximum'\n    Explanation: The requirement is to find the permutation that results in the largest possible surprise value. In code, this means comparing the surprise values of all permutations and selecting the one with the highest value.\n\n# [code logic]\n    The steps for generating permutations and calculating surprise values should be considered simultaneously. Specifically, generating permutations and calculating the surprise value for each permutation can be done in a single loop or function call to optimize performance.\n\n# [edge case]\n    Case 1: n = 1, m = 1, x = [0], s = [\"0\"]\n    Expected output: 1\n    Explanation: With only one question and the student expecting 0 points, any permutation will result in a surprise value of 0, as the student answered incorrectly.\n\n    Case 2: n = 1, m = 1, x = [1], s = [\"1\"]\n    Expected output: 1\n    Explanation: The student expects 1 point and answers correctly, so the permutation should be [1] to maximize the surprise value.\n\n    Case 3: n = 2, m = 2, x = [1, 2], s = [\"10\", \"01\"]\n    Expected output: 2 1\n    Explanation: The permutation [2, 1] maximizes the surprise value because it results in the largest difference between expected and actual points.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    Code for handling edge cases:\n    ```python\n    import itertools\n\n    def maximize_surprise(t, test_cases):\n        results = []\n        for n, m, x, answers in test_cases:\n            max_surprise =", "Round_0": {"code": "import sys\n\ndef maximize_surprise(t, test_cases):\n    results = []\n    for n, m, x, answers in test_cases:\n        # Calculate the frequency of correct answers for each question\n        question_correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Sort questions by the number of correct answers in descending order\n        sorted_questions = sorted(range(m), key=lambda j: question_correct_count[j], reverse=True)\n        \n        # Assign the highest points to the most frequently correctly answered questions\n        points = list(range(1, m + 1))\n        p = [0] * m\n        for idx, question in enumerate(sorted_questions):\n            p[question] = points[idx]\n        \n        results.append(p)\n    \n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, x, answers))\n    \n    results = maximize_surprise(t, test_cases)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers matrix.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the integers n and m.\",\n        \"Read the list of expected points x for each student.\",\n        \"Read the matrix of answers, where each row corresponds to a student's answers.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the total points by summing the points for each correctly answered question.\",\n        \"Use a permutation of points from 1 to m to calculate the total points.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value.\",\n      \"steps\": [\n        \"For each permutation of points from 1 to m, calculate the surprise value as the sum of absolute differences between expected and actual points for all students.\",\n        \"Track the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation that results in the maximum surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract all necessary data for each test case.\",\n    \"For each test case, iterate over all permutations of points from 1 to m.\",\n    \"For each permutation, calculate the actual points for each student and compute the surprise value.\",\n    \"Track the permutation that yields the maximum surprise value.\",\n    \"Output the permutation for each test case that maximizes the surprise value.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    In the requirement, permutation refers to arranging the points from 1 to m in different orders to calculate the surprise value.\n\n    'surprise value'\n    The surprise value is calculated as the sum of absolute differences between expected points and actual points for all students.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    This means we need to find the permutation that results in the highest surprise value.\n\n# [degree adverb] \n    'maximum'\n    This indicates that we are looking for the permutation that gives the largest surprise value.\n\n# [code logic]\n    The steps in the plan related to calculating the actual points and determining the permutation that maximizes the surprise value should be considered simultaneously. Specifically, iterating over permutations and calculating the surprise value should be done in a single loop to efficiently track the maximum surprise value.\n\n# [edge case] \n    Test case with n = 1 and m = 1, x_1 = 0, s_1 = \"0\" = 1\n    Explanation: With only one question and the student expecting 0 points, the permutation doesn't affect the result, but the surprise value is 1.\n    \n    Test case with n = 1 and m = 1, x_1 = 1, s_1 = \"1\" = 0\n    Explanation: The student expects 1 point and answers correctly, so the surprise value is 0.\n    \n    Test case with n = 2 and m = 2, x_1 = 1, x_2 = 2, s_1 = \"01\", s_2 = \"11\" = 1 2\n    Explanation: The permutation 1 2 maximizes the surprise value because it results in the largest difference between expected and actual points.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially when n or m is very small.\n    Consider using itertools.permutations to generate permutations and calculate surprise values efficiently.\n\nYES", "Round_0": {"code": "import sys\nimport itertools\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        # We can use itertools.permutations to generate permutations\n        for perm in itertools.permutations(range(1, m + 1)):\n            # Calculate the actual points for each student\n            actual_points = []\n            for i in range(n):\n                total_points = 0\n                for j in range(m):\n                    if answers[i][j] == '1':\n                        total_points += perm[j]\n                actual_points.append(total_points)\n            \n            # Calculate the surprise value\n            surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n            \n            # Check if this is the maximum surprise value\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        # Store the result for this test case\n        results.append(' '.join(map(str, best_permutation)))\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: cannot assign to function call (<string>, line 156)"}, "Round_1": {"code": "import sys\nimport itertools\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        # We can use itertools.permutations to generate permutations\n        for perm in itertools.permutations(range(1, m + 1)):\n            # Calculate the actual points for each student\n            actual_points = []\n            for i in range(n):\n                total_points = 0\n                for j in range(m):\n                    if answers[i][j] == '1':\n                        total_points += perm[j]\n                actual_points.append(total_points)\n            \n            # Calculate the surprise value\n            surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n            \n            # Check if this is the maximum surprise value\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        # Store the result for this test case\n        results.append(' '.join(map(str, best_permutation)))\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers given by each student as binary strings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student has scored based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the points scored by summing the points of correctly answered questions according to a permutation of points.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"Generate all possible permutations of points from 1 to m.\",\n        \"For each permutation, calculate the total surprise value by summing the absolute differences between expected and actual points for all students.\",\n        \"Select the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation of points that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, iterate over all possible permutations of points.\",\n    \"Calculate the actual points scored by each student for each permutation.\",\n    \"Compute the surprise value for each permutation and track the maximum surprise value.\",\n    \"Output the permutation that results in the maximum surprise value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is an arrangement of all the elements of a set in a specific order. In this context, it refers to arranging the points from 1 to m in different orders to calculate the surprise value.\n\n    'surprise value'\n    Explanation: The surprise value is calculated as the sum of the absolute differences between the expected points and the actual points scored by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that the permutation should be chosen such that the surprise value is as large as possible. In code, this means iterating through all permutations and selecting the one with the highest surprise value.\n\n# [degree adverb] \n    'maximum'\n    Explanation: The requirement is to find the permutation that results in the highest surprise value. This involves comparing the surprise values of all permutations and selecting the largest one.\n\n# [code logic]\n    The steps in the plan related to generating permutations and calculating surprise values should be implemented simultaneously. Specifically, generating permutations and calculating the surprise value for each should be done in a loop, where each permutation is evaluated immediately after it is generated.\n\n# [edge case] \n    Test case with minimum values:\n    1 1\n    0\n    0\n    Expected output: 1\n    Explanation: With only one question and one student expecting 0 points, the permutation is trivial, and the surprise value is 0.\n\n    Test case with all students expecting maximum points:\n    2 2\n    3 3\n    11\n    11\n    Expected output: 2 1\n    Explanation: Both students answered all questions correctly, and the permutation that maximizes the surprise value is one where the highest points are assigned to the least expected question.\n\n    Test case with no correct answers:\n    3 3\n    0 0 0\n    000\n    000\n    000\n    Expected output: 1 2 3\n    Explanation: Since no student answered any question correctly, any permutation will result in a surprise value of 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through permutations and calculating surprise values will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    total_surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        total_surprise_value += abs(expected_points[i] - actual_points)\n    return total_surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the permutation of points from 1 to m\n        points = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in itertools.permutations(points):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 140)"}, "Round_1": {"code": "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    total_surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        total_surprise_value += abs(expected_points[i] - actual_points)\n    return total_surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the permutation of points from 1 to m\n        points = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in itertools.permutations(points):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"output\": \"A function that computes the actual points for each student based on a given permutation of question points.\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of absolute differences between expected and actual points for all students.\",\n      \"output\": \"A permutation of question points that maximizes the surprise value.\"\n    },\n    {\n      \"description\": \"Output the permutation of question points for each test case.\",\n      \"output\": \"Formatted output of the permutation for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a permutation of question points as a list of integers from 1 to m.\",\n    \"For each permutation of question points, calculate the actual points for each student and compute the surprise value.\",\n    \"Iterate over all possible permutations of question points to find the one that maximizes the surprise value.\",\n    \"Store the permutation that results in the maximum surprise value for each test case.\",\n    \"Output the stored permutation for each test case in the required format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation refers to an arrangement of the question points such that each question is assigned a unique point value from 1 to m.\n\n    'surprise value'\n    Explanation: The surprise value is defined as the sum of the absolute differences between the expected points and the actual points obtained by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that we need to find the permutation of question points that results in the highest possible surprise value.\n\n# [degree adverb] \n    'maximum'\n    Explanation: This means we are looking for the permutation that results in the greatest possible surprise value.\n\n# [code logic]\n    The steps \"For each permutation of question points, calculate the actual points for each student and compute the surprise value\" and \"Iterate over all possible permutations of question points to find the one that maximizes the surprise value\" should be considered simultaneously. This can be implemented using a loop to iterate over permutations and a function to calculate the surprise value for each permutation.\n\n# [edge case] \n    Edge Case 1: n = 1, m = 1, x = [0], s = [\"0\"]\n    Expected Output: 1\n    Explanation: With only one question and the student expecting 0 points, the permutation doesn't matter as the surprise value will be 0.\n\n    Edge Case 2: n = 1, m = 10, x = [55], s = [\"1111111111\"]\n    Expected Output: 10 9 8 7 6 5 4 3 2 1\n    Explanation: The student expects the maximum possible points, so the permutation should be in descending order to maximize the surprise value.\n\n    Edge Case 3: n = 10, m = 1, x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], s = [\"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\"]\n    Expected Output: 1\n    Explanation: With all students expecting 0 points and no correct answers, the permutation doesn't affect the surprise value.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The", "Round_0": {"code": "import sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda j: correct_counts[j])\n        \n        # Assign points in descending order to questions with fewer correct answers\n        p = [0] * m\n        for i, j in enumerate(question_indices):\n            p[j] = m - i\n        \n        results.append(' '.join(map(str, p)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 138)"}, "Round_1": {"code": "import sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda j: correct_counts[j])\n        \n        # Assign points in descending order to questions with fewer correct answers\n        p = [0] * m\n        for i, j in enumerate(question_indices):\n            p[j] = m - i\n        \n        results.append(' '.join(map(str, p)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n"}}], "scores": [], "pass_results": [true, false, false, false, true, true, false, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 54, "prompt": "Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.\n\nIf the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.\n\nFor the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them. Assume all input values are integers.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 ", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 ", "mutate_method": "add_1_sentence_at_end", "save_node": true, "parent_index": 54}
