{"name": "1619_H. Permutation and Queries", "description": "You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.\n\nThere are two types of queries:\n\n  * 1 x y \u2014 swap p_x and p_y. \n  * 2 i k \u2014 print the number that i will become if we assign i = p_i k times. \n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.", "tags": ["brute force", "data structures", "divide and conquer", "two pointers"], "difficulty": 14, "id": 1619, "sample_io": [{"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n3\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n", "output": ["4\n1\n2\n"]}], "test_list": [{"input": "1 1\n1\n2 1 1\n", "output": ["1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 6\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n8\n4\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 3\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n8\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 4\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["7\n6\n8\n9\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 83 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 6\n2 36 69\n1 100 59\n", "output": ["19\n6\n40\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 7 9\n2 9 16\n1 3 6\n", "output": ["10\n6\n8\n8\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n5\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 4\n1 1 3\n2 1 2\n", "output": ["4\n1\n2\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n59\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n4\n9\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 1 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n4\n2\n4\n3\n5\n1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 68\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n6\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n1\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n1 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n1\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 7 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n4\n8\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n1\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 2 2\n1 1 3\n2 1 2\n", "output": ["4\n4\n2\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 44 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 1\n2 36 69\n1 100 59\n", "output": ["21\n6\n40\n54\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 2\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n1\n2\n3\n3\n5\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 4\n1 1 2\n2 1 2\n", "output": ["4\n1\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 4 5\n2 5 1\n2 5 3\n2 1 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n4\n4\n2\n4\n3\n5\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n1\n5\n2\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n2\n3\n3\n1\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n1 1 3\n2 1 2\n", "output": ["4\n2\n2\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 44 22\n2 1 72\n2 65 13\n1 18 37\n1 19 89\n1 86 1\n2 36 69\n1 100 59\n", "output": ["21\n6\n57\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n7\n5\n2\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n2\n3\n5\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n7\n5\n10\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 2\n", "output": ["3\n5\n4\n2\n3\n5\n3\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n9\n5\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 7 9\n2 9 9\n1 3 6\n", "output": ["10\n6\n8\n7\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 2 72\n2 65 8\n1 18 37\n1 19 89\n1 86 3\n2 36 69\n1 100 59\n", "output": ["71\n16\n40\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n9\n8\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 1 6\n1 7 9\n2 9 16\n1 3 6\n", "output": ["10\n6\n8\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 1 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n9\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n1\n2\n3\n3\n1\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 2 2\n1 2 3\n2 1 2\n", "output": ["4\n4\n1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 44 44\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 1\n2 36 69\n1 100 59\n", "output": ["64\n6\n40\n54\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 4\n2 5 2\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n3\n1\n2\n3\n3\n5\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 0\n2 1 4\n1 1 2\n2 1 2\n", "output": ["3\n1\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["7\n6\n7\n5\n2\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 4 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n2\n3\n1\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n6\n8\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 4 9\n2 8 8\n1 3 6\n", "output": ["7\n6\n7\n8\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n1 3 6\n", "output": ["10\n3\n8\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 15\n1 3 6\n", "output": ["10\n3\n8\n6\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 83 22\n2 1 72\n2 65 10\n1 18 37\n1 19 89\n1 86 6\n2 36 69\n1 100 59\n", "output": ["19\n6\n47\n54\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n2 1 3\n2 1 2\n", "output": ["4\n1\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 1\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n4\n4\n3\n3\n1\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 2 2\n1 1 3\n2 2 2\n", "output": ["4\n4\n5\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 4 5\n2 5 1\n2 5 3\n2 1 4\n1 5 2\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n4\n4\n2\n4\n3\n1\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n6\n5\n3\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n1\n4\n2\n3\n3\n1\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 4 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n3\n3\n5\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["2\n6\n7\n5\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 5 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n9\n7\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 5 6\n1 10 6\n2 3 3\n1 1 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n9\n3\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 5 3\n2 5 8\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n1\n2\n2\n3\n1\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 0\n2 1 3\n1 1 2\n2 1 2\n", "output": ["3\n5\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n6\n2\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 10\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n1 3 6\n", "output": ["10\n3\n7\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 0\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n4\n5\n3\n3\n1\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n6\n5\n7\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 2\n2 2 7\n2 4 1\n", "output": ["3\n1\n4\n2\n3\n2\n1\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 5 6\n2 5 9\n2 8 2\n1 3 6\n", "output": ["10\n6\n9\n7\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 3\n1 6 2\n2 9 0\n1 4 6\n1 5 9\n2 9 8\n1 3 7\n", "output": ["10\n9\n9\n9\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 5 3\n2 5 8\n1 5 4\n2 5 3\n2 2 7\n2 5 2\n", "output": ["3\n5\n1\n2\n2\n3\n1\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n6\n8\n4\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 0\n2 5 3\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n4\n5\n2\n3\n1\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n7\n5\n7\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 6\n1 5 4\n2 5 2\n2 2 7\n2 4 1\n", "output": ["3\n1\n4\n2\n4\n2\n1\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 8 8\n1 4 6\n", "output": ["2\n6\n7\n6\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 3\n1 6 2\n2 9 0\n1 4 6\n2 5 9\n2 9 8\n1 3 7\n", "output": ["10\n9\n9\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n6\n8\n4\n4\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n8\n8\n8\n"]}, {"input": "5 7\n2 3 5 1 4\n2 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 6\n1 5 4\n2 5 2\n2 2 7\n2 4 1\n", "output": ["3\n1\n4\n2\n4\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 8 8\n2 4 6\n", "output": ["2\n6\n7\n6\n10\n4\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n6\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 13\n1 3 6\n", "output": ["10\n6\n8\n8\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 8 6\n2 4 6\n", "output": ["2\n6\n7\n6\n8\n4\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 5\n2 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n8\n8\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n2 5 4\n2 5 3\n2 2 5\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n2\n2\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 0\n", "output": ["4\n1\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 4\n2 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n4\n8\n7\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 1 4\n1 5 4\n2 4 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n4\n2\n4\n4\n5\n1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 3\n2 1 72\n2 65 8\n1 18 68\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["55\n6\n40\n6\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 2\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n8\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 1 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n4\n5\n2\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n2 1 3\n2 1 2\n", "output": ["4\n2\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n1 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n5\n4\n4\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 8\n1 10 6\n2 4 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n9\n4\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n2 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 8\n2 9 8\n1 3 6\n", "output": ["10\n10\n6\n9\n2\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 0\n1 1 4\n1 1 2\n2 1 2\n", "output": ["3\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 4\n2 1 3\n2 1 2\n", "output": ["4\n4\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 1 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n2\n3\n4\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n2 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n6\n8\n6\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 7 6\n2 3 3\n1 6 2\n2 5 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n5\n5\n3\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 4 3\n2 5 4\n1 5 1\n2 5 3\n2 2 12\n2 4 1\n", "output": ["3\n5\n4\n3\n3\n5\n2\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 2\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 10\n2 4 2\n", "output": ["3\n5\n1\n2\n3\n5\n3\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 1 3\n2 5 8\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n1\n5\n2\n3\n1\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 10\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 1 8\n1 3 6\n", "output": ["7\n6\n7\n5\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 9 8\n1 4 6\n", "output": ["2\n6\n7\n5\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 6\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 8 8\n1 4 6\n", "output": ["2\n3\n7\n6\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 3 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n6\n8\n8\n4\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 2 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n8\n5\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 6\n1 3 6\n2 6 9\n2 8 8\n2 4 6\n", "output": ["2\n6\n8\n6\n10\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 4\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 13\n1 3 6\n", "output": ["10\n7\n4\n5\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 0\n1 3 6\n2 6 9\n2 8 6\n2 4 6\n", "output": ["2\n6\n9\n6\n8\n4\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 5\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 4\n1 1 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n3\n4\n5\n2\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n2 1 3\n2 1 1\n", "output": ["4\n2\n5\n5\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 0\n2 5 4\n2 5 2\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 2\n", "output": ["3\n3\n1\n2\n3\n3\n5\n2\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 0\n2 5 4\n1 5 1\n2 1 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n5\n3\n4\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 9 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 10 10\n1 3 6\n", "output": ["10\n6\n1\n5\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n5\n5\n8\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n2 1 2\n2 1 1\n", "output": ["4\n2\n1\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 9 6\n2 4 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 10 10\n1 3 6\n", "output": ["10\n8\n1\n5\n8\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 0\n2 1 2\n2 1 1\n", "output": ["4\n3\n1\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 9 6\n1 4 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 10 10\n1 3 6\n", "output": ["10\n6\n5\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 5\n2 8 10\n1 3 8\n", "output": ["10\n6\n5\n2\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 6\n1 6 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n2\n8\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n1 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n", "output": ["3\n5\n4\n2\n2\n2\n4\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 13\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 1\n2 36 69\n1 100 59\n", "output": ["33\n89\n40\n94\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 1 9\n2 9 16\n1 3 6\n", "output": ["10\n6\n8\n6\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n1 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["95\n40\n32\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 5 2\n2 9 5\n1 4 6\n1 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n10\n5\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 4 5\n2 4 1\n2 5 3\n2 1 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n4\n1\n2\n4\n3\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 1\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n4\n4\n2\n3\n3\n1\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n1 2 3\n2 1 2\n", "output": ["4\n2\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 2 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n2\n4\n2\n3\n5\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 6\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["9\n6\n7\n5\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 8 8\n1 3 6\n", "output": ["10\n9\n8\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n2 7 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 8\n2 9 8\n1 3 6\n", "output": ["10\n9\n6\n9\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 1 2\n2 9 4\n1 4 6\n1 8 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n9\n2\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 3\n1 1 2\n2 1 2\n", "output": ["4\n5\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 4\n1 1 4\n2 1 2\n", "output": ["4\n4\n3\n"]}, {"input": "5 2\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 4 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n2 5 8\n2 9 8\n1 3 6\n", "output": ["10\n6\n8\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 3\n2 4 8\n1 3 6\n", "output": ["10\n6\n8\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 5\n1 7 6\n1 7 9\n2 3 1\n1 6 2\n2 9 5\n1 4 6\n2 4 9\n2 8 8\n1 5 6\n", "output": ["7\n4\n7\n8\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n2 3 6\n", "output": ["10\n3\n8\n7\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 5 6\n1 5 8\n2 4 15\n1 3 6\n", "output": ["10\n3\n8\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 3\n2 1 3\n2 1 2\n", "output": ["4\n5\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 4 5\n2 1 1\n2 5 3\n2 1 4\n1 5 2\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n4\n2\n2\n4\n3\n1\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 10\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["2\n6\n3\n5\n10\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 17\n2 4 2\n", "output": ["3\n5\n4\n2\n3\n5\n5\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n1 9 5\n1 5 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n5\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 5\n1 1 6\n1 7 10\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n1 3 6\n", "output": ["7\n3\n7\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 5\n1 6 2\n2 9 0\n1 4 6\n1 5 9\n2 9 8\n1 3 7\n", "output": ["10\n2\n9\n9\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 5 3\n2 5 8\n1 5 4\n1 5 3\n2 2 7\n2 5 2\n", "output": ["3\n5\n1\n2\n2\n3\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 1\n2 9 22\n2 3 6\n", "output": ["10\n6\n8\n4\n2\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 7 6\n1 4 6\n2 5 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n3\n8\n8\n"]}, {"input": "5 7\n2 3 5 1 4\n1 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 6\n1 5 4\n2 5 2\n2 2 7\n2 4 1\n", "output": ["5\n5\n5\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n2 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 13\n1 3 6\n", "output": ["10\n6\n9\n4\n2\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n1 5 3\n2 1 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n1\n4\n4\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 0\n2 5 4\n2 5 0\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 2\n", "output": ["3\n3\n5\n2\n3\n3\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 1\n1 6 2\n2 9 4\n2 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n4\n8\n6\n8\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 4 3\n2 5 4\n1 5 1\n2 5 3\n2 4 12\n2 4 1\n", "output": ["3\n5\n4\n3\n3\n5\n4\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 2\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 10\n2 4 3\n", "output": ["3\n5\n1\n2\n3\n5\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 9 8\n1 4 6\n", "output": ["2\n6\n7\n6\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 3 5\n1 1 6\n1 7 9\n2 9 22\n2 3 4\n", "output": ["10\n6\n8\n8\n4\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 6\n1 3 6\n2 6 7\n2 8 8\n2 4 6\n", "output": ["2\n6\n8\n4\n10\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 0\n2 5 4\n2 5 4\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 2\n", "output": ["3\n3\n3\n2\n3\n3\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 9\n2 8 10\n2 3 6\n", "output": ["10\n6\n5\n5\n8\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n2 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 9\n2 8 10\n1 3 8\n", "output": ["10\n8\n6\n9\n10\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 6\n1 6 2\n2 3 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n2\n7\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 4\n1 7 6\n1 10 6\n2 3 2\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 5\n", "output": ["7\n1\n8\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 2\n1 4 6\n1 1 9\n2 9 16\n1 3 6\n", "output": ["10\n6\n2\n6\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 5 2\n2 9 5\n1 4 6\n1 5 8\n2 8 8\n1 3 6\n", "output": ["10\n6\n10\n8\n"]}, {"input": "5 4\n5 3 4 2 1\n1 3 1\n2 2 2\n1 1 5\n2 1 2\n", "output": ["5\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 6\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 6\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["9\n6\n8\n5\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 9 9\n2 8 8\n1 3 8\n", "output": ["10\n6\n9\n9\n8\n"]}, {"input": "5 4\n5 3 4 2 1\n2 1 1\n2 1 3\n1 1 2\n2 1 2\n", "output": ["5\n5\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 2 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n2 3 6\n", "output": ["10\n10\n8\n7\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 5 3\n1 5 8\n2 4 15\n1 3 6\n", "output": ["10\n3\n8\n1\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n1 9 5\n1 5 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 9\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n1 5 6\n", "output": ["7\n6\n2\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 4 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 1\n2 9 22\n2 3 6\n", "output": ["10\n9\n6\n4\n4\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 1\n1 8 5\n1 7 6\n2 3 3\n2 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 13\n1 3 6\n", "output": ["9\n6\n9\n4\n2\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n2 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 9\n2 8 10\n2 3 6\n", "output": ["10\n7\n6\n5\n3\n2\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 11\n1 6 2\n2 3 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n7\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 2 3\n1 10 1\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n2 3 6\n", "output": ["10\n10\n6\n3\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 9\n1 7 6\n1 10 4\n2 3 3\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n1 5 6\n", "output": ["7\n8\n6\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 2 3\n1 10 1\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n2 3 8\n", "output": ["10\n10\n6\n3\n10\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 1 3\n1 6 2\n1 9 5\n1 5 6\n3 5 9\n2 8 8\n1 3 6\n", "output": ["10\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 9\n1 7 6\n1 10 4\n2 3 3\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 8 22\n1 5 6\n", "output": ["7\n8\n6\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 6 9\n2 3 3\n1 6 2\n2 9 6\n1 3 6\n2 6 12\n2 8 8\n1 4 6\n", "output": ["2\n6\n9\n6\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 2 3\n1 10 1\n2 9 4\n1 4 6\n1 5 8\n2 3 8\n2 3 8\n", "output": ["10\n10\n6\n10\n10\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 2 3\n1 6 2\n1 9 5\n1 5 6\n3 5 9\n2 8 8\n1 3 6\n", "output": ["10\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 9\n1 7 6\n1 10 4\n2 3 3\n1 6 2\n2 9 8\n1 1 6\n1 7 9\n2 8 22\n1 5 6\n", "output": ["7\n8\n4\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 4\n1 7 6\n1 10 3\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["7\n2\n4\n9\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 1 2\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n3\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 2 4\n1 1 3\n2 1 2\n", "output": ["4\n3\n2\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 37\n1 86 5\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n51\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 2 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n4\n2\n1\n3\n5\n1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 10\n1 18 68\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["71\n6\n47\n6\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 0\n", "output": ["3\n5\n4\n2\n3\n3\n1\n5\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 2\n2 5 3\n2 5 7\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n1\n2\n1\n3\n5\n1\n"]}, {"input": "5 3\n5 3 4 2 1\n2 3 1\n2 1 4\n1 1 2\n2 1 2\n", "output": ["4\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n1 3 5\n2 4 5\n2 5 1\n2 5 3\n2 1 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["1\n5\n5\n1\n3\n4\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n1 3 1\n2 3 2\n1 1 3\n2 1 2\n", "output": ["1\n1\n"]}], "task_id": "codecontest/146", "repair_prompt": ["You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once; for example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.\n\nThere are two types of queries:\n\n  * 1 x y \u2014 swap p_x and p_y. \n  * 2 i k \u2014 print the number that i will become if we assign i = p_i k times.\n\nYour task is to efficiently handle each query and return the expected results promptly.\n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once; for example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations. The arrays [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.\n\nThere are two types of queries:\n\n  * 1 x y \u2014 swap p_x and p_y. \n  * 2 i k \u2014 print the number that i will become if we assign i = p_i k times.\n\nYour task is to efficiently handle each query and return the expected results promptly.\n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once; for example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations, and you should perform q queries.\n\nThere are two types of queries:\n\n  * 1 x y \u2014 swap p_x and p_y. \n  * 2 i k \u2014 print the number that i will become if we assign i = p_i k times.\n\nYour task is to efficiently handle each query and return the expected results promptly.\n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    queries = data[n+2:]\n    \n    results = []\n    index = 0\n    \n    for _ in range(q):\n        t = int(queries[index])\n        x = int(queries[index+1])\n        y = int(queries[index+2])\n        index += 3\n        \n        if t == 1:\n            # Swap operation\n            p[x-1], p[y-1] = p[y-1], p[x-1]\n        elif t == 2:\n            # Calculate operation\n            i = x\n            k = y\n            for _ in range(k):\n                i = p[i-1]\n            results.append(i)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    queries = data[n+2:]\n    \n    results = []\n    index = 0\n    \n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index+1]) - 1\n            y = int(queries[index+2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(queries[index+1]) - 1\n            k = int(queries[index+2])\n            for _ in range(k):\n                i = p[i] - 1\n            results.append(p[i])\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    queries = data[n+2:]\n    \n    results = []\n    index = 0\n    \n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index+1]) - 1\n            y = int(queries[index+2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(queries[index+1]) - 1\n            k = int(queries[index+2])\n            result = i + 1\n            for _ in range(k):\n                result = p[result - 1]\n            results.append(result)\n            index += 3\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            \n            results.append(p[current])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    queries = data[n+2:]\n    \n    results = []\n    index = 0\n    \n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index+1]) - 1\n            y = int(queries[index+2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(queries[index+1]) - 1\n            k = int(queries[index+2])\n            for _ in range(k):\n                i = p[i] - 1\n            results.append(p[i])\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def handle_queries(n, q, p, queries):\n    def swap(p, x, y):\n        p[x], p[y] = p[y], p[x]\n\n    def iterative_assignment(p, i, k):\n        for _ in range(k):\n            i = p[i]\n        return i\n\n    results = []\n    for query in queries:\n        t, x, y = query\n        if t == 1:\n            swap(p, x - 1, y - 1)\n        elif t == 2:\n            result = iterative_assignment(p, x - 1, y)\n            results.append(result)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(lambda x: int(x) - 1, data[2:n+2]))  # Convert to zero-based index\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((t, x, y))\n        index += 3\n    \n    results = handle_queries(n, q, p, queries)\n    for result in results:\n        print(result + 1)  # Convert back to one-based index for output\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def handle_queries(n, q, p, queries):\n    def swap(p, x, y):\n        p[x], p[y] = p[y], p[x]\n\n    def iterative_assignment(p, i, k):\n        for _ in range(k):\n            i = p[i]\n        return i\n\n    results = []\n    for query in queries:\n        t, a, b = query\n        if t == 1:\n            swap(p, a - 1, b - 1)\n        elif t == 2:\n            result = iterative_assignment(p, a - 1, b)\n            results.append(result)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(lambda x: int(x) - 1, data[2:n+2]))  # Convert to zero-based index\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        a = int(data[index + 1])\n        b = int(data[index + 2])\n        queries.append((t, a, b))\n        index += 3\n    \n    results = handle_queries(n, q, p, queries)\n    for result in results:\n        print(result + 1)  # Convert back to one-based index for output\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    index = n + 2\n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            \n            results.append(p[current])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            results.append(p[current])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def handle_queries(n, q, p, queries):\n    results = []\n\n    def swap(p, x, y):\n        p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n\n    def iterative_assignment(p, i, k):\n        current = i\n        for _ in range(k):\n            current = p[current - 1]\n        return current\n\n    for query in queries:\n        t, x, y = query\n        if t == 1:\n            swap(p, x, y)\n        elif t == 2:\n            result = iterative_assignment(p, x, y)\n            results.append(result)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(int, data[2:n+2]))\n    queries = []\n\n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((t, x, y))\n        index += 3\n\n    results = handle_queries(n, q, p, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    queries = data[n+2:]\n    \n    results = []\n    index = 0\n    \n    for _ in range(q):\n        t = int(queries[index])\n        x = int(queries[index+1])\n        y = int(queries[index+2])\n        index += 3\n        \n        if t == 1:\n            # Swap operation\n            p[x-1], p[y-1] = p[y-1], p[x-1]\n        elif t == 2:\n            # Calculate operation\n            i = x\n            k = y\n            for _ in range(k):\n                i = p[i-1]\n            results.append(i)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": \"Read the first line to get n and q. Read the second line to get the permutation array p. Read the next q lines to get the queries.\"\n    },\n    {\n      \"description\": \"Implement the swap operation for the first type of query.\",\n      \"details\": \"For a query of type 1 x y, swap the elements at positions x and y in the permutation array p.\"\n    },\n    {\n      \"description\": \"Implement the calculation for the second type of query.\",\n      \"details\": \"For a query of type 2 i k, repeatedly assign i = p[i] for k times and return the final value of i.\"\n    },\n    {\n      \"description\": \"Efficiently handle multiple queries and output results for second-type queries.\",\n      \"details\": \"Iterate through the list of queries, perform the required operations, and store results for second-type queries to output them later.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize the permutation array p from the input.\",\n    \"Iterate through each query:\",\n    \"  - If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"  - If the query is of type 2, calculate the result by iterating k times and store the result.\",\n    \"Output the results for all second-type queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that the array is a rearrangement of numbers from 1 to n without repetition.\n\n    'query'\n    A query is an operation that needs to be performed on the permutation array. There are two types of queries: swap and calculate.\n\n# [phrase showing quantity relationship]\n    'k times'\n    This indicates that the operation of assigning i = p[i] should be performed repeatedly k times. In code, this can be implemented using a loop that runs k iterations.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling queries should be considered simultaneously within the loop that processes each query. Specifically, the swap operation and the calculation operation should be handled in the same iteration of the loop, depending on the type of query.\n\n# [edge case]\n    Input: 1 1\n           1\n           2 1 1\n    Output: 1\n    Explanation: With only one element, the permutation is [1]. The query asks for the result of assigning i = p[i] one time, which remains 1.\n\n    Input: 2 2\n           1 2\n           1 1 2\n           2 1 1\n    Output: 2\n    Explanation: After swapping the elements at positions 1 and 2, the permutation becomes [2, 1]. The query asks for the result of assigning i = p[i] one time, which is 2.\n\n    Input: 3 3\n           3 1 2\n           2 1 2\n           1 1 3\n           2 1 1\n    Output: 2\n            3\n    Explanation: The first query results in assigning i = p[i] twice, resulting in 2. After swapping positions 1 and 3, the permutation becomes [2, 1, 3]. The second query results in assigning i = p[i] one time, resulting in 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of processing each query and handling swaps and calculations will naturally cover these edge cases.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    queries = data[n+2:]\n    \n    results = []\n    index = 0\n    \n    for _ in range(q):\n        t = int(queries[index])\n        x = int(queries[index+1])\n        y = int(queries[index+2])\n        index += 3\n        \n        if t == 1:\n            # Swap operation\n            p[x-1], p[y-1] = p[y-1], p[x-1]\n        elif t == 2:\n            # Calculate operation\n            i = x\n            k = y\n            for _ in range(k):\n                i = p[i-1]\n            results.append(i)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": \"Read the first line to get n and q. Read the second line to get the permutation array p. Read the next q lines to get the queries.\"\n    },\n    {\n      \"description\": \"Implement the swap operation for the first type of query.\",\n      \"details\": \"For a query of type 1 x y, swap the elements at positions x and y in the permutation array p.\"\n    },\n    {\n      \"description\": \"Implement the calculation for the second type of query.\",\n      \"details\": \"For a query of type 2 i k, repeatedly assign i = p[i] for k times and return the final value of i.\"\n    },\n    {\n      \"description\": \"Handle multiple queries efficiently.\",\n      \"details\": \"Iterate through the list of queries, perform the required operations, and store the results for second-type queries.\"\n    },\n    {\n      \"description\": \"Output the results for all second-type queries.\",\n      \"details\": \"Print each result from the second-type queries on a new line.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, permutation array p, and the list of queries.\",\n    \"Initialize a list to store results for second-type queries.\",\n    \"Iterate through each query:\",\n    \"  If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"  If the query is of type 2, calculate the result by iterating k times and store the result.\",\n    \"Output the stored results for all second-type queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that the array is a rearrangement of the numbers from 1 to n.\n\n    'query'\n    Explanation: A query is an operation that needs to be performed on the permutation. There are two types of queries: one that swaps elements and another that calculates a value based on repeated assignments.\n\n# [phrase showing quantity relationship]\n    'k times'\n    Explanation: This means that the operation should be repeated k times. In the context of the second type of query, it means repeatedly assigning i = p[i] for k iterations.\n    Implementation: Use a loop to perform the assignment operation k times.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling queries should be considered simultaneously:\n    - For each query, determine its type and perform the corresponding operation. This involves checking the query type and either performing a swap or calculating the result for the second type of query. This can be implemented using an if-else statement within a loop that iterates over the queries.\n\n# [edge case]\n    1. n = 1, q = 1, p = [1], query = [2, 1, 1]\n       Expected output: 1\n       Explanation: With only one element, any number of assignments will result in the same element.\n       \n    2. n = 5, q = 1, p = [1, 2, 3, 4, 5], query = [2, 5, 100000]\n       Expected output: 5\n       Explanation: Since the permutation is already in order, any number of assignments will result in the same element.\n       \n    3. n = 5, q = 1, p = [5, 4, 3, 2, 1], query = [2, 1, 5]\n       Expected output: 1\n       Explanation: The permutation is reversed, but since the query starts at the first element, it will always return the first element after any number of assignments.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the queries and performing the operations as specified will naturally handle these cases. \n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    queries = data[n+2:]\n    \n    results = []\n    index = 0\n    \n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index+1]) - 1\n            y = int(queries[index+2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(queries[index+1]) - 1\n            k = int(queries[index+2])\n            for _ in range(k):\n                i = p[i] - 1\n            results.append(p[i])\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 78)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    queries = data[n+2:]\n    \n    results = []\n    index = 0\n    \n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index+1]) - 1\n            y = int(queries[index+2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(queries[index+1]) - 1\n            k = int(queries[index+2])\n            for _ in range(k):\n                i = p[i] - 1\n            results.append(p[i])\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of elements n, number of queries q, the permutation array p, and the list of queries.\",\n      \"steps\": [\n        \"Read the first line to get n and q.\",\n        \"Read the second line to get the permutation array p.\",\n        \"Read the next q lines to get the list of queries.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the logic to handle the first type of query (swap operation).\",\n      \"steps\": [\n        \"Identify the query type by checking the first integer.\",\n        \"If the query type is 1, extract x and y.\",\n        \"Swap the elements at positions x and y in the permutation array p.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the logic to handle the second type of query (iterative assignment operation).\",\n      \"steps\": [\n        \"Identify the query type by checking the first integer.\",\n        \"If the query type is 2, extract i and k.\",\n        \"Iteratively assign i = p[i-1] for k times to find the resulting value.\",\n        \"Store the result for this query.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all second-type queries.\",\n      \"steps\": [\n        \"For each second-type query, print the stored result in a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, permutation array p, and the list of queries.\",\n    \"Initialize a list to store results for second-type queries.\",\n    \"Iterate over each query and determine its type.\",\n    \"For first-type queries, perform the swap operation on the permutation array.\",\n    \"For second-type queries, perform the iterative assignment operation and store the result.\",\n    \"After processing all queries, output the results for all second-type queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that the array is a rearrangement of numbers from 1 to n without repetition.\n\n    'query'\n    A query is an operation that needs to be performed on the permutation array. There are two types of queries: swap and iterative assignment.\n\n# [phrase showing quantity relationship]\n    'k times': This indicates that the iterative assignment operation should be performed k times. In code, this can be implemented using a loop that runs k iterations.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for handling the first-type query (swap operation) and the second-type query (iterative assignment operation) should be implemented separately as they involve different operations. However, within the second-type query handling, the iterative assignment should be done in a loop, which is a simultaneous operation within that context.\n\n# [edge case] \n    Input: 1 1\n           1\n           2 1 1\n    Output: 1\n    Explanation: With only one element, the permutation is [1]. The query asks for the result of assigning i = p_i one time, which remains 1.\n\n    Input: 3 3\n           3 1 2\n           2 1 2\n           1 1 3\n           2 1 2\n    Output: 2\n            3\n    Explanation: Initially, p = [3, 1, 2]. The first query results in 2 after two assignments. After swapping p_1 and p_3, p becomes [2, 1, 3]. The second query results in 3 after two assignments.\n\n    Input: 4 2\n           4 3 2 1\n           2 4 4\n           2 1 1\n    Output: 1\n            3\n    Explanation: The permutation is reversed. The first query results in 1 after four assignments. The second query results in 3 after one assignment.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating k times for the second-type query and swapping for the first-type query will handle these cases correctly.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    queries = data[n+2:]\n    \n    results = []\n    index = 0\n    \n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index+1]) - 1\n            y = int(queries[index+2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(queries[index+1]) - 1\n            k = int(queries[index+2])\n            result = i + 1\n            for _ in range(k):\n                result = p[result - 1]\n            results.append(result)\n            index += 3\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 78)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    queries = data[n+2:]\n    \n    results = []\n    index = 0\n    \n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index+1]) - 1\n            y = int(queries[index+2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(queries[index+1]) - 1\n            k = int(queries[index+2])\n            result = i + 1\n            for _ in range(k):\n                result = p[result - 1]\n            results.append(result)\n            index += 3\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": [\n        \"Read the first line to get the values of n and q.\",\n        \"Read the second line to get the permutation array p.\",\n        \"Read the next q lines to get the list of queries.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the swap operation for the first type of query.\",\n      \"details\": [\n        \"Identify queries of type 1.\",\n        \"For each query, swap the elements at positions x and y in the permutation array.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the calculation for the second type of query.\",\n      \"details\": [\n        \"Identify queries of type 2.\",\n        \"For each query, calculate the result by iteratively applying the permutation k times starting from index i.\",\n        \"Store the result for each query.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all second-type queries.\",\n      \"details\": [\n        \"Print each result on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, the permutation array p, and the list of queries.\",\n    \"Initialize a list to store results for second-type queries.\",\n    \"Iterate over each query:\",\n    \"  - If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"  - If the query is of type 2, calculate the result by applying the permutation k times starting from index i and store the result.\",\n    \"Output the stored results for all second-type queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that the array is a rearrangement of numbers from 1 to n without repetition.\n\n    'query'\n    A query is an operation that needs to be performed on the permutation array. There are two types of queries: swap and calculate.\n\n# [phrase showing quantity relationship]\n    'k times'\n    This indicates that the operation should be repeated k times. In the context of the second type of query, it means applying the permutation starting from index i, k times.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling type 1 and type 2 queries should be implemented separately as they involve different operations. However, within the handling of type 2 queries, the calculation of the result by applying the permutation k times should be done in a loop.\n\n# [edge case]\n    Input: 1 1\n    Output: 1\n    Explanation: With only one element, any swap operation is irrelevant, and the second-type query will always return the single element itself.\n\n    Input: 5 1\n    Output: 5\n    Explanation: With a permutation of 5 elements and only one query, the output will be the result of the single query.\n\n    Input: 5 5\n    Output: 5\n    Explanation: With a permutation of 5 elements and 5 queries, the output will depend on the specific queries, but the permutation remains valid.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of handling queries and permutations will naturally accommodate these scenarios.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            \n            results.append(p[current])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 81)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            \n            results.append(p[current])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": \"Read the first line to get n and q. Read the second line to get the permutation array p. Read the next q lines to get the queries.\"\n    },\n    {\n      \"description\": \"Implement the swap operation for the first type of query.\",\n      \"details\": \"For a query of type 1 x y, swap the elements at positions x and y in the permutation array p.\"\n    },\n    {\n      \"description\": \"Implement the calculation for the second type of query.\",\n      \"details\": \"For a query of type 2 i k, repeatedly assign i = p[i] for k times and return the final value of i.\"\n    },\n    {\n      \"description\": \"Efficiently handle multiple queries and output results for second-type queries.\",\n      \"details\": \"Iterate through the list of queries, perform the required operations, and store results for second-type queries to output them later.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, the permutation array p, and the list of queries.\",\n    \"Initialize an empty list to store results for second-type queries.\",\n    \"Iterate through each query:\",\n    \"  - If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"  - If the query is of type 2, calculate the result by repeatedly assigning i = p[i] for k times and append the result to the list.\",\n    \"Output each result stored in the list for second-type queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that the array is a rearrangement of the numbers from 1 to n.\n\n    'query'\n    Explanation: A query is an operation that needs to be performed on the permutation. There are two types of queries: one that swaps elements and another that calculates a value based on repeated assignments.\n\n# [phrase showing quantity relationship]\n    'k times': This indicates that the operation should be repeated k times. In the context of the second type of query, it means repeatedly assigning i = p[i] for k iterations.\n    Implementation: Use a loop to perform the assignment operation k times.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling the queries should be implemented in a loop that processes each query one by one. The swap operation and the repeated assignment operation are distinct and should be handled separately within the loop.\n\n# [edge case]\n    1. Input: 1 1\n       Output: 1\n       Explanation: With only one element, any swap operation is redundant, and any repeated assignment will return the element itself.\n\n    2. Input: 5 1\n       Output: 5\n       Explanation: If k is 1, the result of the second type of query will always be the element at the given index.\n\n    3. Input: 5 5\n       Output: 1\n       Explanation: If the permutation is a cycle of length n, repeating the assignment n times will return the starting element.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the queries and performing the operations as described will naturally handle these cases.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    queries = data[n+2:]\n    \n    results = []\n    index = 0\n    \n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index+1]) - 1\n            y = int(queries[index+2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(queries[index+1]) - 1\n            k = int(queries[index+2])\n            for _ in range(k):\n                i = p[i] - 1\n            results.append(p[i])\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 78)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    queries = data[n+2:]\n    \n    results = []\n    index = 0\n    \n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index+1]) - 1\n            y = int(queries[index+2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(queries[index+1]) - 1\n            k = int(queries[index+2])\n            for _ in range(k):\n                i = p[i] - 1\n            results.append(p[i])\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of elements n, number of queries q, the permutation array p, and the list of queries.\",\n      \"steps\": [\n        \"Read the first line to get n and q.\",\n        \"Read the second line to get the permutation array p of length n.\",\n        \"Read the next q lines to get the list of queries.\"\n      ]\n    },\n    {\n      \"description\": \"Implement a function to handle the first type of query (swap operation).\",\n      \"steps\": [\n        \"Define a function that takes the permutation array p and indices x and y.\",\n        \"Swap the elements at positions x and y in the array p.\"\n      ]\n    },\n    {\n      \"description\": \"Implement a function to handle the second type of query (iterative assignment operation).\",\n      \"steps\": [\n        \"Define a function that takes the permutation array p, index i, and integer k.\",\n        \"Iteratively assign i = p[i] for k times and return the final value of i.\"\n      ]\n    },\n    {\n      \"description\": \"Process each query and produce the required output.\",\n      \"steps\": [\n        \"Iterate over each query in the list of queries.\",\n        \"For a query of type 1, call the swap function with the appropriate parameters.\",\n        \"For a query of type 2, call the iterative assignment function and store the result.\",\n        \"Collect results for all type 2 queries and print them.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, permutation array p, and the list of queries.\",\n    \"Implement a function to handle swap operations for type 1 queries.\",\n    \"Implement a function to handle iterative assignment operations for type 2 queries.\",\n    \"Iterate over the list of queries, process each query using the appropriate function, and collect results for type 2 queries.\",\n    \"Output the results for all type 2 queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    A permutation of n elements is an array of length n containing each integer from 1 to n exactly once.\n\n    'query'\n    A query is an operation that needs to be performed on the permutation array. There are two types of queries: swap and iterative assignment.\n\n# [phrase showing quantity relationship]\n    'exactly once': means each integer from 1 to n appears only one time in the permutation array.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for handling the swap operation and iterative assignment operation should be implemented separately as they are distinct operations. However, within the iterative assignment operation, the assignment of i = p[i] for k times should be implemented in a loop.\n\n# [edge case] \n    Input: 1 1\n           1\n           2 1 1\n    Output: 1\n    Explanation: With only one element, the permutation is [1]. The query asks for the result of assigning i = p[i] one time, which remains 1.\n\n    Input: 2 2\n           1 2\n           2 1 2\n           2 2 1\n    Output: 2\n            2\n    Explanation: The permutation is [1, 2]. The first query results in 2 after two assignments, and the second query results in 2 after one assignment.\n\n    Input: 3 3\n           3 1 2\n           2 3 1\n           1 1 3\n           2 1 1\n    Output: 2\n            1\n    Explanation: The permutation is [3, 1, 2]. The first query results in 2 after one assignment. After swapping elements at positions 1 and 3, the permutation becomes [2, 1, 3]. The second query results in 1 after one assignment.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of handling queries will naturally accommodate these edge cases.\n\nNO", "Round_0": {"code": "def handle_queries(n, q, p, queries):\n    def swap(p, x, y):\n        p[x], p[y] = p[y], p[x]\n\n    def iterative_assignment(p, i, k):\n        for _ in range(k):\n            i = p[i]\n        return i\n\n    results = []\n    for query in queries:\n        t, x, y = query\n        if t == 1:\n            swap(p, x - 1, y - 1)\n        elif t == 2:\n            result = iterative_assignment(p, x - 1, y)\n            results.append(result)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(int, data[2:n+2]))\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((t, x, y))\n        index += 3\n    \n    results = handle_queries(n, q, p, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 89)"}, "Round_1": {"code": "def handle_queries(n, q, p, queries):\n    def swap(p, x, y):\n        p[x], p[y] = p[y], p[x]\n\n    def iterative_assignment(p, i, k):\n        for _ in range(k):\n            i = p[i]\n        return i\n\n    results = []\n    for query in queries:\n        t, x, y = query\n        if t == 1:\n            swap(p, x - 1, y - 1)\n        elif t == 2:\n            result = iterative_assignment(p, x - 1, y)\n            results.append(result)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(lambda x: int(x) - 1, data[2:n+2]))  # Convert to zero-based index\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((t, x, y))\n        index += 3\n    \n    results = handle_queries(n, q, p, queries)\n    for result in results:\n        print(result + 1)  # Convert back to one-based index for output\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of elements n, number of queries q, the permutation array p, and the list of queries.\",\n      \"steps\": [\n        \"Read the first line to get n and q.\",\n        \"Read the second line to get the permutation array p.\",\n        \"Read the next q lines to get the list of queries.\"\n      ]\n    },\n    {\n      \"description\": \"Implement a function to handle the first type of query (swap operation).\",\n      \"steps\": [\n        \"Define a function that takes the permutation array p and indices x and y.\",\n        \"Swap the elements at positions x and y in the array p.\"\n      ]\n    },\n    {\n      \"description\": \"Implement a function to handle the second type of query (iterative assignment).\",\n      \"steps\": [\n        \"Define a function that takes the permutation array p, index i, and integer k.\",\n        \"Iteratively assign i = p[i] for k times.\",\n        \"Return the final value of i.\"\n      ]\n    },\n    {\n      \"description\": \"Process each query and produce the required output.\",\n      \"steps\": [\n        \"Iterate over each query in the list of queries.\",\n        \"For a query of type 1, call the swap function with the appropriate parameters.\",\n        \"For a query of type 2, call the iterative assignment function and store the result.\",\n        \"Print the results of all type 2 queries.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, permutation array p, and the list of queries.\",\n    \"Implement a function to handle swap operations for type 1 queries.\",\n    \"Implement a function to handle iterative assignments for type 2 queries.\",\n    \"Iterate over the list of queries, process each query using the appropriate function, and store the results for type 2 queries.\",\n    \"Output the results for all type 2 queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    A permutation of n elements is an array of length n containing each integer from 1 to n exactly once.\n\n    'query'\n    A query is an operation that needs to be performed on the permutation array. There are two types of queries: swap and iterative assignment.\n\n# [phrase showing quantity relationship]\n    'k times': means that the iterative assignment should be performed k times, which involves repeatedly assigning i = p[i].\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for handling type 1 and type 2 queries should be implemented separately, as they involve different operations. However, within the processing of type 2 queries, the iterative assignment should be handled in a loop that performs the assignment k times.\n\n# [edge case] \n    Input: 1 1\n           1\n           2 1 1\n    Output: 1\n    Explanation: With only one element, the permutation is [1]. The query asks for the result of one assignment, which remains 1.\n\n    Input: 3 3\n           3 1 2\n           2 1 2\n           1 1 3\n           2 1 2\n    Output: 2\n            3\n    Explanation: Initially, p = [3, 1, 2]. The first query results in p_1 = 3, then p_3 = 2. After swapping p_1 and p_3, p becomes [2, 1, 3]. The second query results in p_1 = 2, then p_2 = 1, then p_1 = 3.\n\n    Input: 5 5\n           5 4 3 2 1\n           2 5 5\n           1 1 5\n           2 5 5\n           1 2 4\n           2 5 5\n    Output: 1\n            5\n            1\n    Explanation: Initially, p = [5, 4, 3, 2, 1]. The first query results in p_5 = 1. After swapping p_1 and p_5, p becomes [1, 4, 3, 2, 5]. The second query results in p_5 = 5. After swapping p", "Round_0": {"code": "def handle_queries(n, q, p, queries):\n    def swap(p, x, y):\n        p[x], p[y] = p[y], p[x]\n\n    def iterative_assignment(p, i, k):\n        for _ in range(k):\n            i = p[i]\n        return i\n\n    results = []\n    for query in queries:\n        t, a, b = query\n        if t == 1:\n            swap(p, a - 1, b - 1)\n        elif t == 2:\n            result = iterative_assignment(p, a - 1, b)\n            results.append(result)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(lambda x: int(x) - 1, data[2:n+2]))  # Convert to zero-based index\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        a = int(data[index + 1])\n        b = int(data[index + 2])\n        queries.append((t, a, b))\n        index += 3\n    \n    results = handle_queries(n, q, p, queries)\n    for result in results:\n        print(result + 1)  # Convert back to one-based index for output\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 79)"}, "Round_1": {"code": "def handle_queries(n, q, p, queries):\n    def swap(p, x, y):\n        p[x], p[y] = p[y], p[x]\n\n    def iterative_assignment(p, i, k):\n        for _ in range(k):\n            i = p[i]\n        return i\n\n    results = []\n    for query in queries:\n        t, a, b = query\n        if t == 1:\n            swap(p, a - 1, b - 1)\n        elif t == 2:\n            result = iterative_assignment(p, a - 1, b)\n            results.append(result)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(lambda x: int(x) - 1, data[2:n+2]))  # Convert to zero-based index\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        a = int(data[index + 1])\n        b = int(data[index + 2])\n        queries.append((t, a, b))\n        index += 3\n    \n    results = handle_queries(n, q, p, queries)\n    for result in results:\n        print(result + 1)  # Convert back to one-based index for output\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": \"Read the first line to get n and q. Read the second line to get the permutation array p. Read the next q lines to get the queries.\"\n    },\n    {\n      \"description\": \"Implement the swap operation for the first type of query.\",\n      \"details\": \"For a query of type 1 x y, swap the elements at positions x and y in the permutation array p.\"\n    },\n    {\n      \"description\": \"Implement the calculation for the second type of query.\",\n      \"details\": \"For a query of type 2 i k, repeatedly apply the permutation k times starting from index i to find the resulting value.\"\n    },\n    {\n      \"description\": \"Efficiently handle multiple queries and output results for second-type queries.\",\n      \"details\": \"Iterate through the list of queries, apply the appropriate operation for each query, and store the results for second-type queries.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, the permutation array p, and the list of queries.\",\n    \"Initialize a list to store results for second-type queries.\",\n    \"Iterate through each query:\",\n    \"  - If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"  - If the query is of type 2, calculate the result by applying the permutation k times starting from index i and store the result.\",\n    \"Output the results for all second-type queries, each on a new line.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that each number in the range 1 to n appears exactly once in the array.\n\n    'query'\n    Explanation: A query is an operation that needs to be performed on the permutation array. There are two types of queries: one that swaps elements and another that calculates a result based on repeated application of the permutation.\n\n# [phrase showing quantity relationship]\n    'k times': This means that the permutation operation should be applied repeatedly k times. In code, this can be implemented using a loop that iterates k times to apply the permutation.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for handling each query should be considered simultaneously within the loop that processes each query. Specifically, the logic for determining whether to perform a swap or calculate a result based on the query type should be handled in an if-else statement within the loop.\n\n# [edge case] \n    1. Input: 1 1\n       Output: 1\n       Explanation: With only one element, any query will result in the same element since there are no other elements to swap or permute.\n       \n    2. Input: 5 1\n       Output: 5\n       Explanation: With a single query of type 2, the result will be the element itself since k=1 means no permutation is applied.\n       \n    3. Input: 5 5\n       Output: 5\n       Explanation: With a single query of type 2 and k equal to the length of the permutation, the result will be the element itself since a full cycle of permutation returns to the starting point.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through queries and applying the permutation or swap as specified will naturally handle these cases. \n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    index = n + 2\n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            \n            results.append(p[current])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 79)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    index = n + 2\n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            \n            results.append(p[current])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of elements (n), number of queries (q), the permutation array (p), and the list of queries.\",\n      \"steps\": [\n        \"Read the first line to get n and q.\",\n        \"Read the second line to get the permutation array p.\",\n        \"Read the next q lines to get the list of queries.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the logic to handle the first type of query (swap operation).\",\n      \"steps\": [\n        \"Identify the query type by checking the first integer of the query.\",\n        \"If the query type is 1, extract x and y.\",\n        \"Swap the elements at positions x and y in the permutation array p.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the logic to handle the second type of query (iterative assignment operation).\",\n      \"steps\": [\n        \"Identify the query type by checking the first integer of the query.\",\n        \"If the query type is 2, extract i and k.\",\n        \"Iteratively assign i = p[i-1] for k times to find the resulting number.\",\n        \"Store the result for output.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all second-type queries.\",\n      \"steps\": [\n        \"For each second-type query processed, print the result on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, the permutation array p, and the list of queries.\",\n    \"Initialize a list to store results for second-type queries.\",\n    \"Iterate over each query and determine its type.\",\n    \"For first-type queries, perform the swap operation on the permutation array.\",\n    \"For second-type queries, perform the iterative assignment operation and store the result.\",\n    \"After processing all queries, output the results for all second-type queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that the array is a rearrangement of numbers from 1 to n without repetition.\n\n    'query'\n    A query is an operation that needs to be performed on the permutation array. There are two types of queries: swap and iterative assignment.\n\n# [phrase showing quantity relationship]\n    'k times'\n    This indicates that the iterative assignment operation should be performed k times. In code, this can be implemented using a loop that runs k iterations, updating the value of i each time.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling the first-type query (swap operation) and the second-type query (iterative assignment operation) should be implemented separately, as they involve different operations on the permutation array. However, within the second-type query handling, the iterative assignment operation should be performed in a loop, which is a simultaneous operation within that context.\n\n# [edge case]\n    Input: 1 1\n           1\n           2 1 1\n    Output: 1\n    Explanation: With only one element, the permutation is [1]. The query asks for the result of one iteration, which remains 1.\n\n    Input: 3 2\n           3 1 2\n           2 1 3\n           2 2 2\n    Output: 2\n            1\n    Explanation: The first query results in 2 after three iterations starting from index 1. The second query results in 1 after two iterations starting from index 2.\n\n    Input: 5 1\n           5 4 3 2 1\n           2 5 5\n    Output: 1\n    Explanation: Starting from index 5, after five iterations, the result is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating k times for the second-type query and swapping for the first-type query will handle these cases correctly.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            results.append(p[current])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 72)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            results.append(p[current])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of elements n, number of queries q, the permutation array p, and the list of queries.\",\n      \"steps\": [\n        \"Read the first line to get n and q.\",\n        \"Read the second line to get the permutation array p.\",\n        \"Read the next q lines to get the list of queries.\"\n      ]\n    },\n    {\n      \"description\": \"Implement a function to handle the first type of query (swap operation).\",\n      \"steps\": [\n        \"Define a function that takes the permutation array p and indices x and y.\",\n        \"Swap the elements at positions x and y in the array p.\"\n      ]\n    },\n    {\n      \"description\": \"Implement a function to handle the second type of query (iterative assignment operation).\",\n      \"steps\": [\n        \"Define a function that takes the permutation array p, index i, and integer k.\",\n        \"Iteratively assign i = p[i] for k times and return the final value of i.\"\n      ]\n    },\n    {\n      \"description\": \"Process each query and produce the required output.\",\n      \"steps\": [\n        \"Iterate over each query in the list of queries.\",\n        \"For a query of type 1, call the swap function with the appropriate parameters.\",\n        \"For a query of type 2, call the iterative assignment function and store the result.\",\n        \"Collect results for all type 2 queries.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all second-type queries.\",\n      \"steps\": [\n        \"Print each result from the collected results of type 2 queries on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, permutation array p, and the list of queries.\",\n    \"Implement a swap function to handle type 1 queries.\",\n    \"Implement an iterative assignment function to handle type 2 queries.\",\n    \"Process each query, updating the permutation array or collecting results as needed.\",\n    \"Output the results for all type 2 queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that each number in the range 1 to n appears exactly once in the array.\n\n# [phrase showing quantity relationship]\n    'at least one second-type query': This guarantees that there will be at least one query of type 2, ensuring that the output will not be empty.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for processing each query should be considered simultaneously:\n    - \"For a query of type 1, call the swap function with the appropriate parameters.\"\n    - \"For a query of type 2, call the iterative assignment function and store the result.\"\n    These steps should be implemented in a loop that iterates over each query, determining the type and executing the corresponding function.\n\n# [edge case] \n    Edge Case 1: n = 1, q = 1, p = [1], query = [2, 1, 1]\n    Expected Output: 1\n    Explanation: With only one element, any number of iterations will always result in the same element.\n\n    Edge Case 2: n = 5, q = 1, p = [1, 2, 3, 4, 5], query = [2, 5, 100000]\n    Expected Output: 5\n    Explanation: Since the permutation is already in order, any number of iterations will result in the same element.\n\n    Edge Case 3: n = 5, q = 2, p = [5, 4, 3, 2, 1], queries = [1, 1, 5], [2, 1, 1]\n    Expected Output: 1\n    Explanation: After swapping the first and last elements, the permutation becomes [1, 4, 3, 2, 5]. The query [2, 1, 1] will return the first element, which is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of processing queries and handling swaps and iterative assignments will naturally handle these cases.\n\nNO", "Round_0": {"code": "def handle_queries(n, q, p, queries):\n    results = []\n\n    def swap(p, x, y):\n        p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n\n    def iterative_assignment(p, i, k):\n        current = i\n        for _ in range(k):\n            current = p[current - 1]\n        return current\n\n    for query in queries:\n        t, x, y = query\n        if t == 1:\n            swap(p, x, y)\n        elif t == 2:\n            result = iterative_assignment(p, x, y)\n            results.append(result)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(int, data[2:n+2]))\n    queries = []\n\n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((t, x, y))\n        index += 3\n\n    results = handle_queries(n, q, p, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 81)"}, "Round_1": {"code": "def handle_queries(n, q, p, queries):\n    results = []\n\n    def swap(p, x, y):\n        p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n\n    def iterative_assignment(p, i, k):\n        current = i\n        for _ in range(k):\n            current = p[current - 1]\n        return current\n\n    for query in queries:\n        t, x, y = query\n        if t == 1:\n            swap(p, x, y)\n        elif t == 2:\n            result = iterative_assignment(p, x, y)\n            results.append(result)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(int, data[2:n+2]))\n    queries = []\n\n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((t, x, y))\n        index += 3\n\n    results = handle_queries(n, q, p, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": \"Read the first line to get n and q. Read the second line to get the permutation array p. Read the next q lines to get the queries.\"\n    },\n    {\n      \"description\": \"Implement the swap operation for the first type of query.\",\n      \"details\": \"For a query of type 1 x y, swap the elements at positions x and y in the permutation array p.\"\n    },\n    {\n      \"description\": \"Implement the calculation for the second type of query.\",\n      \"details\": \"For a query of type 2 i k, repeatedly assign i = p[i] for k times and return the final value of i.\"\n    },\n    {\n      \"description\": \"Efficiently handle multiple queries and output results for second-type queries.\",\n      \"details\": \"Iterate through the list of queries, perform the required operations, and store results for second-type queries to output them later.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize the permutation array p from the input.\",\n    \"Iterate through each query:\",\n    \"  - If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"  - If the query is of type 2, calculate the result by iterating k times and store the result.\",\n    \"Output the results for all second-type queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that the array is a rearrangement of numbers from 1 to n without repetition.\n\n    'query'\n    A query is an operation that needs to be performed on the permutation array. There are two types of queries: swap and calculate.\n\n# [phrase showing quantity relationship]\n    'k times'\n    This indicates that the operation of assigning i = p[i] should be performed repeatedly k times. In code, this can be implemented using a loop that runs k iterations.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling queries should be considered simultaneously within the loop that processes each query. Specifically, the swap operation and the calculation operation should be handled in the same iteration of the loop, depending on the type of query.\n\n# [edge case]\n    Input: 1 1\n           1\n           2 1 1\n    Output: 1\n    Explanation: With only one element, the permutation is [1]. The query asks for the result of assigning i = p[i] one time, which remains 1.\n\n    Input: 2 2\n           1 2\n           1 1 2\n           2 1 1\n    Output: 2\n    Explanation: After swapping the elements at positions 1 and 2, the permutation becomes [2, 1]. The query asks for the result of assigning i = p[i] one time, which is 2.\n\n    Input: 3 3\n           3 1 2\n           2 1 2\n           1 1 3\n           2 1 1\n    Output: 2\n            3\n    Explanation: The first query results in assigning i = p[i] twice, resulting in 2. After swapping positions 1 and 3, the permutation becomes [2, 1, 3]. The second query results in assigning i = p[i] one time, resulting in 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of processing each query and handling swaps and calculations will naturally cover these edge cases.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    queries = data[n+2:]\n    \n    results = []\n    index = 0\n    \n    for _ in range(q):\n        t = int(queries[index])\n        x = int(queries[index+1])\n        y = int(queries[index+2])\n        index += 3\n        \n        if t == 1:\n            # Swap operation\n            p[x-1], p[y-1] = p[y-1], p[x-1]\n        elif t == 2:\n            # Calculate operation\n            i = x\n            k = y\n            for _ in range(k):\n                i = p[i-1]\n            results.append(i)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, true, true, true, true, false, false, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 487, "prompt": "You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once; for example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.\n\nThere are two types of queries:\n\n  * 1 x y \u2014 swap p_x and p_y. \n  * 2 i k \u2014 print the number that i will become if we assign i = p_i k times.\n\nYour task is to efficiently handle each query and return the expected results promptly.\n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.", "examples": "\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 182}
