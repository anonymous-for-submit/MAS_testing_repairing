{"name": "1622_E. Math Test", "description": "Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.\n\nIf the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.\n\nFor the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 ", "tags": ["bitmasks", "brute force", "greedy"], "difficulty": 11, "id": 1622, "sample_io": [{"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n", "output": ["3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n"]}], "test_list": [{"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n001\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1 4 2 6 3 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 4 1 6 2 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n13 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n101\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 2\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n000110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n3 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111001\n", "output": ["3 1 2\n3 1 4 2\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 2\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n2 1\n"]}, {"input": "3\n4 3\n5 1 1 0\n111\n000\n101\n010\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["1 2 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000001\n111111\n", "output": ["3 1 2\n2 3 4 1\n4 1 5 2 3 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1101\n0010\n0110\n0111\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 4 1 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n2 4 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n4 1 2 3\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0011\n0110\n0001\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n1 2 4 3\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n001\n110\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["3 2 1\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0010\n0101\n3 2\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n101\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["2 1 3\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n9 1 4 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000100\n111101\n", "output": ["3 1 2\n2 3 4 1\n4 3 5 1 2 6\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n111\n100\n4 4\n6 2 0 10\n1001\n0011\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111011\n", "output": ["3 2 1\n1 2 4 3\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n001\n110\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["2 1 3\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n001\n110\n4 4\n0 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["2 1 3\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 3 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100100\n111101\n", "output": ["3 1 2\n2 3 4 1\n6 2 3 4 1 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n1 2 0 10\n1101\n0010\n0100\n0111\n3 6\n38 3 7\n010110\n100101\n111101\n", "output": ["3 1 2\n3 4 1 2\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n1 1 2 0\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0011\n0111\n0101\n3 1\n20 3 2\n011110\n000101\n111011\n", "output": ["3 1 2\n1 2 4 3\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n000\n4 4\n6 3 0 10\n0001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100100\n111101\n", "output": ["2 1 3\n2 3 4 1\n6 2 3 4 1 5\n"]}, {"input": "3\n4 3\n5 1 3 4\n100\n100\n101\n100\n4 4\n12 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 4\n010110\n010101\n111111\n", "output": ["1 2 3\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n110\n000\n100\n100\n4 4\n6 2 1 11\n1001\n0010\n0110\n0101\n3 6\n38 0 7\n110110\n000101\n111101\n", "output": ["3 2 1\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n000\n4 4\n6 3 0 1\n0001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100100\n111101\n", "output": ["2 1 3\n1 4 3 2\n6 2 3 4 1 5\n"]}, {"input": "3\n4 3\n3 1 3 2\n110\n000\n100\n100\n4 4\n6 2 1 11\n1001\n0010\n0110\n0101\n3 6\n38 0 7\n110110\n000101\n111101\n", "output": ["1 3 2\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n0 1 2 1\n110\n100\n100\n101\n4 4\n2 2 0 13\n1101\n0110\n0110\n0101\n3 6\n38 3 12\n010110\n000001\n111101\n", "output": ["3 1 2\n2 3 4 1\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 2\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 0 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 0 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 3 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n101\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 1 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n11 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 0 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 0\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n13 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 1 0\n111\n000\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0100\n0100\n3 2\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000001\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n1 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0111\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n011\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1101\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n36 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 0 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n1101\n3 1\n34 3 7\n010110\n000101\n110111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0001\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 18\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010010\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 2 2\n101\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 1\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 2\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 10\n0001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n100\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n001\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111101\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n110110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 0\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n110110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n54 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n1 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0110\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111011\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 4\n1001\n0010\n0110\n0101\n3 1\n20 0 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n110\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n4 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n000\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0110\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n100101\n110101\n", "output": ["3 1 2\n2 3 4 1\n3 4 1 6 2 5\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n101\n101\n100\n4 4\n6 2 0 10\n1001\n0000\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0010\n0001\n3 1\n30 1 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n11 1 1 11\n1001\n0010\n1110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 2 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 0 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110110\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n13 1 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 1 0\n011\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n1110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n101\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111011\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n1110\n0101\n3 6\n20 3 15\n000110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n2 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n1 1\n20 3 7\n010110\n010101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n9 1 4 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n011\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n101\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n36 3 7\n010100\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n100\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 18\n1001\n0010\n0110\n0101\n3 6\n20 3 0\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0100\n0101\n3 1\n20 3 7\n010010\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 2 2\n101\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n011110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n010101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n3 1 0 10\n0001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n100\n100\n4 4\n6 2 0 11\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n000\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 17\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n0 1 2 0\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 6\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n110110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n54 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n010\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111001\n", "output": ["3 1 2\n3 1 4 2\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n1 2 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n111\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111011\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n000\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n8 1 0 10\n1001\n0110\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n010\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n100101\n110101\n", "output": ["3 1 2\n2 3 4 1\n3 4 1 6 2 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0010\n0001\n3 1\n30 0 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 2 0 10\n1001\n0010\n0110\n0100\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 0 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n2 1\n66 3 2\n010110\n000101\n110110\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 0\n011\n100\n111\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n1110\n0100\n3 1\n20 0 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 2 4 2\n111\n101\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111011\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 0 1 0\n111\n000\n101\n010\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["1 2 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 17\n1001\n0010\n0110\n0101\n1 1\n20 3 7\n010110\n010101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n011\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1101\n0010\n0100\n0111\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 4 1 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n100\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 0\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0011\n0110\n0001\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n1 2 4 3\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 18\n1001\n0010\n0110\n0101\n3 6\n20 3 0\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n4 1 2 2\n101\n110\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n011110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n100\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n010101\n111111\n", "output": ["1 2 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n100\n100\n4 4\n6 2 1 11\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n4 1 2 2\n111\n100\n000\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 17\n1001\n0110\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n110110\n000100\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n111\n100\n101\n000\n4 4\n4 1 0 10\n1001\n0010\n0110\n0001\n3 1\n54 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n011\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111001\n", "output": ["3 1 2\n3 1 4 2\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n000\n4 4\n12 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n1 0 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n000\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000111\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n000\n4 4\n6 1 0 10\n1101\n0010\n0010\n0101\n3 2\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n8 1 0 10\n1001\n0110\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n101\n101\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["2 1 3\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 1 0\n011\n100\n111\n000\n4 4\n20 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 3 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111110\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 17\n1001\n0010\n0110\n0101\n1 1\n20 3 8\n010110\n010101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}], "task_id": "codecontest/158", "repair_prompt": ["Petya is a math teacher. n of his students has written a test consisting of m questions, and for each student, it is known which questions he has answered correctly and which he has not.\n\nIf the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points); moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.\n\nFor the i-th student, Petya knows that he expects to get x_i points for the test and wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Petya is a math teacher. n of his students has written a test consisting of m questions, and for each student, it is known which questions he has answered correctly and which he has not.\n\nIf the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). Additionally, it is important to note that the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m. This means that each number from 1 to m appears exactly once in the array p.\n\nFor the i-th student, Petya knows that he expects to get x_i points for the test and wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Petya is a math teacher. n of his students has written a test consisting of m questions, and for each student, it is known which questions he has answered correctly and which he has not. If the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points), with the points distributed such that array p is a permutation of numbers from 1 to m. For the i-th student, Petya knows that he expects to get x_i points for the test and wonders how unexpected the results could be; he believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points the i-th student has got for the test. Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation of points\n        initial_permutation = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(initial_permutation):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["import sys\nimport itertools\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        permutations = itertools.permutations(range(1, m + 1))\n        \n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in permutations:\n            # Calculate the actual points for each student\n            actual_points = [0] * n\n            for j in range(m):\n                for i in range(n):\n                    if answers[i][j] == '1':\n                        actual_points[i] += permutation[j]\n            \n            # Calculate the surprise value\n            surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n            \n            # Update the maximum surprise value and best permutation\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        # Store the result\n        results.append(' '.join(map(str, best_permutation)))\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        student_answers = []\n        for _ in range(n):\n            student_answers.append(data[index])\n            index += 1\n        \n        # Edge case handling\n        if all(x_i == 0 for x_i in expected_points):\n            results.append(' '.join(map(str, range(m, 0, -1))))\n            continue\n        elif all('1' * m == s_i for s_i in student_answers):\n            results.append(' '.join(map(str, range(1, m + 1))))\n            continue\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for s in student_answers:\n            for j in range(m):\n                if s[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Assign points in descending order of correct counts\n        permutation = [0] * m\n        for i, q_index in enumerate(question_indices):\n            permutation[q_index] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Create the permutation of points\n        permutation = [0] * m\n        for i in range(m):\n            permutation[question_indices[i]] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in itertools.permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate permutations of points from 1 to m\n        points = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in itertools.permutations(points):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    actual_points = [0] * n\n    for i in range(n):\n        for j in range(m):\n            if answers[i][j] == '1':\n                actual_points[i] += permutation[j]\n    surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n    return surprise_value\n\ndef find_maximum_surprise_permutation(n, m, expected_points, answers):\n    max_surprise_value = -1\n    best_permutation = None\n    all_permutations = permutations(range(1, m + 1))\n    \n    for perm in all_permutations:\n        surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n        if surprise_value > max_surprise_value:\n            max_surprise_value = surprise_value\n            best_permutation = perm\n    \n    return best_permutation\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        best_permutation = find_maximum_surprise_permutation(n, m, expected_points, answers)\n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        received_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - received_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = int(data[index]), int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we need to maximize the difference\n        # between expected and actual points. This can be achieved by assigning\n        # the highest points to the questions that are least answered correctly.\n        \n        # Count how many students answered each question correctly\n        correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_count[j] += 1\n        \n        # Pair each question index with its correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_count[x])\n        \n        # Assign points in descending order to questions with least correct answers\n        permutation = [0] * m\n        for i, question_index in enumerate(question_indices):\n            permutation[question_index] = m - i\n        \n        results.append(\" \".join(map(str, permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation of points\n        points = list(range(1, m + 1))\n        \n        # Find the permutation with the maximum surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(points):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation of points\n        initial_permutation = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(initial_permutation):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"output\": \"A function that computes the actual points for each student based on a given permutation of question points.\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of the absolute differences between expected and actual points for all students.\",\n      \"output\": \"A permutation of question points that maximizes the surprise value for each test case.\"\n    },\n    {\n      \"description\": \"Output the permutation of question points for each test case.\",\n      \"output\": \"Formatted output of the permutation for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a permutation of question points from 1 to m.\",\n    \"For each permutation, calculate the actual points each student would get and compute the surprise value.\",\n    \"Iterate over all possible permutations of question points to find the one that maximizes the surprise value.\",\n    \"Store the permutation that results in the maximum surprise value for each test case.\",\n    \"Output the stored permutation for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of the requirement, a permutation refers to an arrangement of the question points such that each number from 1 to m appears exactly once. The goal is to find a permutation that maximizes the surprise value.\n\n    'surprise value'\n    Explanation: The surprise value is calculated as the sum of the absolute differences between the expected points and the actual points obtained by each student. The task is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that the permutation should be chosen such that the surprise value is as large as possible. In code, this involves iterating over permutations and selecting the one with the highest calculated surprise value.\n\n# [degree adverb]\n    'maximum'\n    Explanation: The requirement is to find the permutation that results in the largest possible surprise value. This involves comparing calculated surprise values for different permutations and selecting the highest one.\n\n# [code logic]\n    The steps \"For each permutation, calculate the actual points each student would get and compute the surprise value\" and \"Iterate over all possible permutations of question points to find the one that maximizes the surprise value\" should be implemented simultaneously. This can be done by iterating over permutations and calculating the surprise value in the same loop.\n\n# [edge case]\n    Case 1: n = 1, m = 1, x = [0], s = [\"0\"]\n    Expected output: 1\n    Explanation: With only one question and the student expecting 0 points, the permutation doesn't affect the outcome, but the surprise value is maximized by assigning the lowest point value.\n\n    Case 2: n = 1, m = 1, x = [1], s = [\"1\"]\n    Expected output: 1\n    Explanation: The student expects 1 point and answers correctly, so the permutation should assign 1 point to the question to maximize the surprise value.\n\n    Case 3: n = 2, m = 2, x = [1, 1], s = [\"10\", \"01\"]\n    Expected output: 2 1\n    Explanation: Both students expect 1 point, and each answers one question correctly. Assigning higher points to the questions they answered incorrectly maximizes the surprise value.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should ensure that permutations are generated and evaluated correctly, even for", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation of points\n        initial_permutation = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(initial_permutation):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 106)"}, "Round_1": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation of points\n        initial_permutation = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(initial_permutation):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"output\": \"A list of actual points for each student for a given permutation.\"\n    },\n    {\n      \"description\": \"Compute the surprise value for a given permutation of points by calculating the sum of absolute differences between expected and actual points for all students.\",\n      \"output\": \"The surprise value for the given permutation.\"\n    },\n    {\n      \"description\": \"Generate all possible permutations of points from 1 to m and evaluate the surprise value for each permutation.\",\n      \"output\": \"A list of surprise values corresponding to each permutation.\"\n    },\n    {\n      \"description\": \"Identify the permutation that results in the maximum surprise value.\",\n      \"output\": \"The permutation of points that maximizes the surprise value.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Parse the number of students (n), number of questions (m), expected points (x_i) for each student, and their answers (s_i).\",\n    \"  b. Initialize a list to store the maximum surprise value and corresponding permutation for each test case.\",\n    \"  c. Generate all permutations of points from 1 to m.\",\n    \"  d. For each permutation, calculate the actual points for each student and compute the surprise value.\",\n    \"  e. Compare the surprise value with the current maximum and update if the current permutation yields a higher surprise value.\",\n    \"  f. Store the permutation with the maximum surprise value.\",\n    \"Output the permutation with the maximum surprise value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation refers to an arrangement of the points assigned to each question such that each number from 1 to m is used exactly once. The goal is to find a permutation that maximizes the surprise value.\n\n    'surprise value'\n    Explanation: The surprise value is calculated as the sum of the absolute differences between the expected points and the actual points received by each student. The task is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that the permutation should be chosen such that the surprise value is as large as possible. In code, this means iterating through all permutations and selecting the one with the highest surprise value.\n\n# [degree adverb]\n    'maximum'\n    Explanation: The requirement is to find the permutation that results in the largest possible surprise value. This involves comparing the surprise values of all permutations and selecting the highest one.\n\n# [code logic]\n    The steps related to generating permutations and calculating surprise values should be considered simultaneously. Specifically, generating permutations and calculating the surprise value for each permutation can be done in a single loop.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    0\n    0\n    Expected output: 1\n    Explanation: With only one question and one student expecting 0 points, the permutation is trivial, and the surprise value is 0.\n\n    Test case with all students expecting maximum points:\n    2 2\n    3 3\n    11\n    11\n    Expected output: 2 1\n    Explanation: Both students answered all questions correctly, expecting maximum points. The permutation does not affect the surprise value, which is 0.\n\n    Test case with no correct answers:\n    2 3\n    0 0\n    000\n    000\n    Expected output: 3 2 1\n    Explanation: No questions are answered correctly, so the permutation does not affect the surprise value, which is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of generating permutations and calculating surprise values will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "import sys\nimport itertools\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        permutations = itertools.permutations(range(1, m + 1))\n        \n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in permutations:\n            # Calculate the actual points for each student\n            actual_points = [0] * n\n            for j in range(m):\n                for i in range(n):\n                    if answers[i][j] == '1':\n                        actual_points[i] += permutation[j]\n            \n            # Calculate the surprise value\n            surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n            \n            # Update the maximum surprise value and best permutation\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        # Store the result\n        results.append(' '.join(map(str, best_permutation)))\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input data to extract the number of test cases, number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"steps\": [\n        \"Read the number of test cases (t).\",\n        \"For each test case, read the number of students (n) and the number of questions (m).\",\n        \"Read the expected points for each student (x_i).\",\n        \"Read the answers given by each student (s_i).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the points received (r_i) by summing the points for correctly answered questions according to a permutation p.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"For each test case, generate permutations of points from 1 to m.\",\n        \"Calculate the surprise value for each permutation using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Select the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, iterate over possible permutations of points.\",\n    \"Calculate the actual points received by each student for each permutation.\",\n    \"Compute the surprise value for each permutation and identify the permutation with the maximum surprise value.\",\n    \"Output the permutation for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    In the requirement, permutation refers to arranging the points from 1 to m in such a way that each question has a unique point value, and the arrangement can be changed to maximize the surprise value.\n\n    'surprise value'\n    The surprise value is calculated as the sum of the absolute differences between the expected points and the actual points received by each student.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    This indicates that we need to find the permutation of points that results in the highest possible surprise value.\n\n# [degree adverb] \n    'maximum'\n    This means we need to find the permutation that results in the largest surprise value.\n\n# [code logic]\n    The steps in the plan related to generating permutations and calculating surprise values should be considered simultaneously. Specifically, generating permutations and calculating the surprise value for each permutation can be done in a single loop or function call to optimize performance.\n\n# [edge case] \n    Test case with all students expecting zero points:\n    Input: 1 3 0 0 0\n           000\n           000\n           000\n    Output: 3 2 1\n    Explanation: Since all students expect zero points, any permutation will result in the same surprise value, but the permutation should still be valid.\n\n    Test case with all questions answered correctly:\n    Input: 1 3 6 6 6\n           111\n           111\n           111\n    Output: 1 2 3\n    Explanation: Since all questions are answered correctly, the permutation should be such that the sum of points matches the expected points.\n\n    Test case with no questions answered correctly:\n    Input: 1 3 0 0 0\n           000\n           000\n           000\n    Output: 1 2 3\n    Explanation: Since no questions are answered correctly, the permutation does not affect the surprise value, but it should still be valid.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all students expect zero points or all questions are answered correctly.\n    ```python\n    if all(x_i == 0 for x_i in expected_points):\n        print(list(range(m, 0, -1)))\n    elif all('1' * m == s_i for s_i in student_answers):\n        print(list(range(1, m + 1)))\n    else:\n        #", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        student_answers = []\n        for _ in range(n):\n            student_answers.append(data[index])\n            index += 1\n        \n        # Edge case handling\n        if all(x_i == 0 for x_i in expected_points):\n            results.append(' '.join(map(str, range(m, 0, -1))))\n            continue\n        elif all('1' * m == s_i for s_i in student_answers):\n            results.append(' '.join(map(str, range(1, m + 1))))\n            continue\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for s in student_answers:\n            for j in range(m):\n                if s[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Assign points in descending order of correct counts\n        permutation = [0] * m\n        for i, q_index in enumerate(question_indices):\n            permutation[q_index] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Structured data containing test cases with students, questions, expected points, and answers\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"input\": \"Structured data for a single test case\",\n      \"output\": \"List of actual points for each student based on a permutation of question points\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of absolute differences between expected and actual points for all students.\",\n      \"input\": \"List of expected points and list of actual points for each permutation\",\n      \"output\": \"Permutation of question points that maximizes the surprise value\"\n    },\n    {\n      \"description\": \"Output the permutation of question points for each test case.\",\n      \"input\": \"Permutation of question points for each test case\",\n      \"output\": \"Formatted output for each test case\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a list of question points as a permutation of numbers from 1 to m.\",\n    \"For each permutation of question points, calculate the actual points each student would get.\",\n    \"Compute the surprise value for each permutation by summing the absolute differences between expected and actual points for all students.\",\n    \"Identify the permutation that results in the maximum surprise value.\",\n    \"Store the permutation for each test case.\",\n    \"Output the stored permutations for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    In the requirement, permutation refers to arranging the points for questions such that each question has a unique point value from 1 to m.\n\n    'surprise value'\n    The surprise value is the sum of the absolute differences between the expected points and the actual points obtained by each student.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    This indicates that we need to find the permutation of question points that results in the highest possible surprise value.\n\n# [degree adverb] \n    'maximum'\n    This means we need to find the permutation that results in the largest sum of absolute differences between expected and actual points.\n\n# [code logic]\n    The steps for calculating actual points and computing the surprise value should be considered simultaneously. For each permutation, calculate the actual points and immediately compute the surprise value to determine if it's the maximum.\n\n# [edge case] \n    Test case with all students expecting zero points and answering all questions correctly:\n    Input: 1 3 0 0 0 111 111 111\n    Output: 3 2 1\n    Explanation: Since all students expect zero points, the permutation that assigns the highest points to questions they answered correctly will maximize the surprise value.\n\n    Test case with one student expecting maximum points and answering no questions correctly:\n    Input: 1 3 6 000\n    Output: 1 2 3\n    Explanation: The student expects maximum points but answers no questions correctly, so any permutation will result in the same surprise value.\n\n    Test case with all students expecting maximum points and answering all questions correctly:\n    Input: 1 3 6 6 6 111 111 111\n    Output: 1 2 3\n    Explanation: Since all students expect maximum points and answer all questions correctly, the permutation that assigns the lowest points to questions will maximize the surprise value.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through permutations and calculating the surprise value will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Create the permutation of points\n        permutation = [0] * m\n        for i in range(m):\n            permutation[question_indices[i]] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"output\": \"A list of actual points for each student for a given permutation.\"\n    },\n    {\n      \"description\": \"Compute the surprise value for a given permutation of points by calculating the sum of absolute differences between expected and actual points for all students.\",\n      \"output\": \"The surprise value for the given permutation.\"\n    },\n    {\n      \"description\": \"Generate all possible permutations of points from 1 to m and evaluate the surprise value for each permutation.\",\n      \"output\": \"A list of surprise values corresponding to each permutation.\"\n    },\n    {\n      \"description\": \"Identify the permutation that results in the maximum surprise value.\",\n      \"output\": \"The permutation of points that maximizes the surprise value.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Parse the number of students (n), number of questions (m), expected points (x_i) for each student, and their answers (s_i).\",\n    \"  b. Initialize a list to store the maximum surprise value and corresponding permutation for each test case.\",\n    \"  c. Generate all permutations of points from 1 to m.\",\n    \"  d. For each permutation, calculate the actual points for each student and compute the surprise value.\",\n    \"  e. Compare the surprise value with the current maximum and update if the current permutation yields a higher surprise value.\",\n    \"  f. Store the permutation with the maximum surprise value.\",\n    \"Output the permutation with the maximum surprise value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is an arrangement of all the elements of a set in a specific order. In this context, it refers to arranging the points from 1 to m in different orders to maximize the surprise value.\n\n    'surprise value'\n    Explanation: The surprise value is calculated as the sum of the absolute differences between the expected points and the actual points received by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that the task is to find the permutation that results in the highest possible surprise value.\n\n# [degree adverb] \n    'maximum'\n    Explanation: The requirement is to find the permutation that results in the largest surprise value. This involves evaluating all permutations and selecting the one with the highest surprise value.\n\n# [code logic]\n    Steps 3 and 4 should be considered simultaneously.\n    \"Generate all possible permutations of points from 1 to m and evaluate the surprise value for each permutation.\"\n    This can be implemented using a loop to generate permutations and calculate the surprise value in the same iteration.\n\n# [edge case] \n    Test case with minimum values:\n    1 1\n    0\n    0\n    Expected output: 1\n    Explanation: With only one question and one student expecting 0 points, the permutation is trivial, and the surprise value is 0.\n\n    Test case with all students expecting maximum points:\n    2 2\n    3 3\n    11\n    11\n    Expected output: 2 1\n    Explanation: Both students answered all questions correctly, expecting maximum points. The permutation that maximizes the surprise value is 2 1.\n\n    Test case with no correct answers:\n    3 3\n    0 0 0\n    000\n    000\n    000\n    Expected output: 3 2 1\n    Explanation: No student answered correctly, so the permutation doesn't affect the actual points, and the surprise value is maximized by any permutation.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of generating permutations and calculating surprise values will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in itertools.permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers given by each student as a binary string.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the total points received by summing the points for correctly answered questions.\",\n        \"Use a permutation of points from 1 to m to calculate the points.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"Calculate the surprise value for a given permutation as the sum of absolute differences between expected and actual points for all students.\",\n        \"Iterate over possible permutations to find the one that maximizes the surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case that maximizes the surprise value.\",\n      \"steps\": [\n        \"For each test case, print the permutation of points that results in the maximum surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, generate permutations of points from 1 to m.\",\n    \"Calculate the actual points received by each student for each permutation.\",\n    \"Compute the surprise value for each permutation and identify the permutation that maximizes it.\",\n    \"Output the permutation that maximizes the surprise value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    In the requirement, permutation refers to arranging the points from 1 to m in such a way that each question has a unique point value, and the arrangement can be changed to maximize the surprise value.\n\n    'surprise value'\n    The surprise value is calculated as the sum of the absolute differences between the expected points and the actual points received by each student.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    This indicates that the goal is to find the permutation of points that results in the highest possible surprise value.\n\n# [degree adverb] \n    'maximum'\n    This means we need to find the permutation that results in the largest surprise value.\n\n# [code logic]\n    The steps for calculating the actual points and determining the permutation that maximizes the surprise value should be considered simultaneously. Specifically, iterating over permutations and calculating the surprise value should be done in a single loop to efficiently find the optimal permutation.\n\n# [edge case] \n    Test case with minimum values:\n    1 1\n    0\n    0\n    Expected output: 1\n    Explanation: With only one question and the student expecting 0 points, the permutation is trivial, and the surprise value is 0.\n\n    Test case with all students expecting maximum points:\n    2 2\n    3 3\n    11\n    11\n    Expected output: 2 1\n    Explanation: Both students answered all questions correctly, and the permutation that maximizes the surprise value is [2, 1].\n\n    Test case with no correct answers:\n    3 3\n    0 0 0\n    000\n    000\n    000\n    Expected output: 1 2 3\n    Explanation: No points are awarded, so any permutation results in the same surprise value.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over permutations and calculating the surprise value will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate permutations of points from 1 to m\n        points = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in itertools.permutations(points):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"output\": \"A list of actual points for each student for a given permutation.\"\n    },\n    {\n      \"description\": \"Compute the surprise value for a given permutation of points by calculating the sum of absolute differences between expected and actual points for all students.\",\n      \"output\": \"The surprise value for the given permutation.\"\n    },\n    {\n      \"description\": \"Generate all possible permutations of points from 1 to m and evaluate the surprise value for each permutation.\",\n      \"output\": \"A list of surprise values corresponding to each permutation.\"\n    },\n    {\n      \"description\": \"Identify the permutation that results in the maximum surprise value.\",\n      \"output\": \"The permutation of points that maximizes the surprise value.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a list of points from 1 to m.\",\n    \"Generate all permutations of the points list.\",\n    \"For each permutation, calculate the actual points each student received and compute the surprise value.\",\n    \"Track the permutation that yields the maximum surprise value.\",\n    \"Output the permutation with the maximum surprise value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation refers to an arrangement of the points assigned to each question. Since the points are a permutation of numbers from 1 to m, it means each question has a unique point value from this range.\n\n    'surprise value'\n    Explanation: The surprise value is the sum of the absolute differences between the expected points and the actual points received by each student. The goal is to maximize this value by finding the optimal permutation of points.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that we need to find the permutation that results in the highest possible surprise value. In code, this means iterating through all permutations and selecting the one with the highest computed surprise value.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This refers to the largest possible surprise value that can be achieved. In code, this involves comparing surprise values of different permutations and keeping track of the largest one.\n\n# [code logic]\n    The steps related to generating permutations and calculating surprise values should be considered simultaneously. Specifically, generating a permutation and immediately calculating its surprise value can be done in a single loop over permutations.\n\n# [edge case]\n    1. Test case with n = 1, m = 1, x = [0], s = [\"0\"] = [1]\n       Explanation: With only one question and the student expecting 0 points, the permutation [1] maximizes the surprise value.\n    2. Test case with n = 1, m = 1, x = [1], s = [\"1\"] = [1]\n       Explanation: With only one question and the student expecting 1 point, the permutation [1] results in a surprise value of 0.\n    3. Test case with n = 2, m = 2, x = [1, 2], s = [\"01\", \"10\"] = [2, 1]\n       Explanation: The permutation [2, 1] maximizes the surprise value by assigning higher points to the question answered correctly by the student expecting fewer points.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of generating permutations and calculating surprise values will naturally handle these cases.\n\nNO", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    actual_points = [0] * n\n    for i in range(n):\n        for j in range(m):\n            if answers[i][j] == '1':\n                actual_points[i] += permutation[j]\n    surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n    return surprise_value\n\ndef find_maximum_surprise_permutation(n, m, expected_points, answers):\n    max_surprise_value = -1\n    best_permutation = None\n    all_permutations = permutations(range(1, m + 1))\n    \n    for perm in all_permutations:\n        surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n        if surprise_value > max_surprise_value:\n            max_surprise_value = surprise_value\n            best_permutation = perm\n    \n    return best_permutation\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        best_permutation = find_maximum_surprise_permutation(n, m, expected_points, answers)\n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers given by each student as binary strings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the points received by summing the points of correctly answered questions.\",\n        \"Use a permutation of points from 1 to m to calculate the received points.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"Calculate the surprise value for a given permutation as the sum of absolute differences between expected and received points for all students.\",\n        \"Iterate over possible permutations of points to find the one that maximizes the surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case that maximizes the surprise value.\",\n      \"steps\": [\n        \"For each test case, print the permutation of points that results in the maximum surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, iterate over permutations of points from 1 to m.\",\n    \"Calculate the received points for each student using the current permutation.\",\n    \"Compute the surprise value for the current permutation.\",\n    \"Track the permutation that results in the maximum surprise value.\",\n    \"Output the permutation for each test case that maximizes the surprise value.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    In the requirement, permutation refers to arranging the points from 1 to m in such a way that each number appears exactly once. This is crucial for calculating the points each student receives based on their correct answers.\n\n    'surprise value'\n    The surprise value is defined as the sum of the absolute differences between the expected points and the received points for all students. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    This indicates that the permutation should be chosen such that the surprise value is as large as possible. In code, this means iterating over all permutations and selecting the one with the highest surprise value.\n\n# [degree adverb]\n    'maximum'\n    This means finding the permutation that results in the largest surprise value. In code, this involves comparing the surprise values of different permutations and selecting the highest one.\n\n# [code logic]\n    The steps for calculating the received points and computing the surprise value should be implemented simultaneously for efficiency. Specifically:\n    - \"Calculate the points received by summing the points of correctly answered questions.\"\n    - \"Compute the surprise value for the current permutation.\"\n    These can be done in a single loop over the students for each permutation.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    0\n    0\n    Expected output: 1\n    Explanation: With only one question and the student expecting 0 points, any permutation will result in a surprise value of 0.\n\n    Test case with all students expecting maximum points:\n    2 2\n    3 3\n    11\n    11\n    Expected output: 2 1\n    Explanation: Both students answered all questions correctly, expecting maximum points. The permutation 2 1 maximizes the surprise value.\n\n    Test case with no correct answers:\n    3 3\n    0 0 0\n    000\n    000\n    000\n    Expected output: 3 2 1\n    Explanation: No points are received, so the permutation doesn't affect the surprise value, but 3 2 1 is a valid permutation.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over permutations and calculating the surprise value will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        received_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - received_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 84)"}, "Round_1": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        received_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - received_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points, and answers for each student.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers for each student as a binary string.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, initialize their score to 0.\",\n        \"Iterate over each question and add the corresponding point value from the permutation if the student answered correctly.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value.\",\n      \"steps\": [\n        \"Generate all possible permutations of point values from 1 to m.\",\n        \"For each permutation, calculate the total surprise value using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Select the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, generate all permutations of point values from 1 to m.\",\n    \"Calculate the actual points received by each student for each permutation.\",\n    \"Compute the surprise value for each permutation and identify the permutation with the maximum surprise value.\",\n    \"Output the permutation that maximizes the surprise value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    In the requirement, permutation refers to arranging the point values from 1 to m in such a way that each number appears exactly once. This is crucial for calculating the surprise value.\n\n    'surprise value'\n    The surprise value is calculated as the sum of the absolute differences between the expected points and the actual points received by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    This indicates that the permutation should be chosen to achieve the highest possible surprise value.\n\n# [degree adverb] \n    'maximum'\n    This means we need to find the permutation that results in the largest surprise value.\n\n# [code logic]\n    The steps for calculating the actual points and determining the permutation should be considered simultaneously. Specifically, generating permutations and calculating the surprise value should be done in a loop where each permutation is evaluated for its surprise value.\n\n# [edge case] \n    Test case with minimum values: \n    1 1\n    0\n    0\n    Expected output: 1\n    Explanation: With only one question and one student expecting 0 points, the permutation is trivial, and the surprise value is maximized with any permutation.\n\n    Test case with all students expecting maximum points:\n    2 2\n    3 3\n    11\n    11\n    Expected output: 2 1\n    Explanation: Both students answered all questions correctly, expecting maximum points. The permutation that maximizes surprise value is one that reverses the point order.\n\n    Test case with no correct answers:\n    3 3\n    0 0 0\n    000\n    000\n    000\n    Expected output: 1 2 3\n    Explanation: No student answered correctly, so the permutation does not affect the surprise value, which remains zero.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially for generating permutations and calculating surprise values.\n    ```python\n    from itertools import permutations\n\n    def calculate_surprise_value(expected_points, actual_points):\n        return sum(abs(x - r) for x, r in zip(expected_points, actual_points))\n\n    def find_max_surprise_permutation(n, m, expected_points, answers):\n        max_surprise = -1\n        best_permutation = None\n        for perm in permutations(range(1, m + 1)):\n            actual", "Round_0": {"code": "from itertools import permutations\nimport sys\n\ndef calculate_surprise_value(expected_points, actual_points):\n    return sum(abs(x - r) for x, r in zip(expected_points, actual_points))\n\ndef find_max_surprise_permutation(n, m, expected_points, answers):\n    max_surprise = -1\n    best_permutation = None\n    for perm in permutations(range(1, m + 1)):\n        actual_points = []\n        for answer in answers:\n            score = sum(p if answer[j] == '1' else 0 for j, p in enumerate(perm))\n            actual_points.append(score)\n        surprise_value = calculate_surprise_value(expected_points, actual_points)\n        if surprise_value > max_surprise:\n            max_surprise = surprise_value\n            best_permutation = perm\n    return best_permutation\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = int(data[index]), int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        best_permutation = find_max_surprise_permutation(n, m, expected_points, answers)\n        results.append(\" \".join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: find_max_surprise_permutation() missing 4 required positional arguments: 'n', 'm', 'expected_points', and 'answers'"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = int(data[index]), int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we need to maximize the difference\n        # between expected and actual points. This can be achieved by assigning\n        # the highest points to the questions that are least answered correctly.\n        \n        # Count how many students answered each question correctly\n        correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_count[j] += 1\n        \n        # Pair each question index with its correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_count[x])\n        \n        # Assign points in descending order to questions with least correct answers\n        permutation = [0] * m\n        for i, question_index in enumerate(question_indices):\n            permutation[question_index] = m - i\n        \n        results.append(\" \".join(map(str, permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"output\": \"A list of actual points for each student for a given permutation.\"\n    },\n    {\n      \"description\": \"Compute the surprise value for a given permutation of points by calculating the sum of absolute differences between expected and actual points for all students.\",\n      \"output\": \"The surprise value for the given permutation.\"\n    },\n    {\n      \"description\": \"Generate all possible permutations of points from 1 to m and evaluate the surprise value for each permutation.\",\n      \"output\": \"A list of surprise values corresponding to each permutation.\"\n    },\n    {\n      \"description\": \"Identify the permutation that results in the maximum surprise value.\",\n      \"output\": \"The permutation of points that maximizes the surprise value.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a list of points from 1 to m.\",\n    \"Generate all permutations of the points list.\",\n    \"For each permutation, calculate the actual points for each student and compute the surprise value.\",\n    \"Track the permutation that yields the maximum surprise value.\",\n    \"Output the permutation with the maximum surprise value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is an arrangement of all the elements of a set in a specific sequence or order. In this context, it refers to arranging the points from 1 to m in different orders to maximize the surprise value.\n\n    'surprise value'\n    Explanation: The surprise value is calculated as the sum of the absolute differences between the expected points and the actual points received by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that the task is to find the permutation of points that results in the highest possible surprise value.\n\n# [degree adverb] \n    'maximum'\n    Explanation: The requirement is to find the permutation that results in the largest surprise value. This involves evaluating all permutations and selecting the one with the highest sum of absolute differences.\n\n# [code logic]\n    The steps \"Generate all permutations of the points list\" and \"For each permutation, calculate the actual points for each student and compute the surprise value\" should be considered simultaneously. This can be implemented using a loop that iterates over each permutation, calculates the actual points, and computes the surprise value in one block of code.\n\n# [edge case] \n    Edge cases are not explicitly provided in the requirement, but we can infer some based on the constraints:\n    - Case with minimum values: n = 1, m = 1, x_1 = 0, s_1 = \"0\"\n      Expected output: 1\n      Explanation: With only one question and the student expecting 0 points, the permutation doesn't affect the surprise value, which is 0.\n    - Case with maximum values: n = 10, m = 10, x_i = 55 (for all i), s_i = \"1111111111\" (for all i)\n      Expected output: Any permutation of [1, 2, ..., 10]\n      Explanation: All students answered all questions correctly, and the expected points are the maximum possible, so any permutation will result in a surprise value of 0.\n    - Case with mixed answers: n = 2, m = 3, x_1 = 3, x_2 = 0, s_1 = \"111\", s_2 = \"000\"\n      Expected output: 3 2 1\n      Explanation: The first student expects 3 points and answered all correctly, while the second expects 0 and", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation of points\n        points = list(range(1, m + 1))\n        \n        # Find the permutation with the maximum surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(points):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"output\": \"A function that computes the actual points for each student based on a given permutation of question points.\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of the absolute differences between expected and actual points for all students.\",\n      \"output\": \"A permutation of question points that maximizes the surprise value for each test case.\"\n    },\n    {\n      \"description\": \"Output the permutation of question points for each test case.\",\n      \"output\": \"Formatted output of the permutation for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a permutation of question points from 1 to m.\",\n    \"For each permutation, calculate the actual points each student would get and compute the surprise value.\",\n    \"Iterate over all possible permutations of question points to find the one that maximizes the surprise value.\",\n    \"Store the permutation that results in the maximum surprise value for each test case.\",\n    \"Output the stored permutation for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of the requirement, a permutation refers to an arrangement of the question points such that each number from 1 to m appears exactly once. The goal is to find a permutation that maximizes the surprise value.\n\n    'surprise value'\n    Explanation: The surprise value is calculated as the sum of the absolute differences between the expected points and the actual points obtained by each student. The task is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that the permutation should be chosen such that the surprise value is as large as possible. In code, this involves iterating over permutations and selecting the one with the highest calculated surprise value.\n\n# [degree adverb]\n    'maximum'\n    Explanation: The requirement is to find the permutation that results in the largest possible surprise value. This involves comparing calculated surprise values for different permutations and selecting the highest one.\n\n# [code logic]\n    The steps \"For each permutation, calculate the actual points each student would get and compute the surprise value\" and \"Iterate over all possible permutations of question points to find the one that maximizes the surprise value\" should be implemented simultaneously. This can be done by iterating over permutations and calculating the surprise value in the same loop.\n\n# [edge case]\n    Case 1: n = 1, m = 1, x = [0], s = [\"0\"]\n    Expected output: 1\n    Explanation: With only one question and the student expecting 0 points, the permutation doesn't affect the outcome, but the surprise value is maximized by assigning the lowest point value.\n\n    Case 2: n = 1, m = 1, x = [1], s = [\"1\"]\n    Expected output: 1\n    Explanation: The student expects 1 point and answers correctly, so the permutation should assign 1 point to the question to maximize the surprise value.\n\n    Case 3: n = 2, m = 2, x = [1, 1], s = [\"10\", \"01\"]\n    Expected output: 2 1\n    Explanation: Both students expect 1 point, and each answers one question correctly. Assigning higher points to the questions they answered incorrectly maximizes the surprise value.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should ensure that permutations are generated and evaluated correctly, even for", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation of points\n        initial_permutation = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(initial_permutation):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 106)"}, "Round_1": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation of points\n        initial_permutation = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(initial_permutation):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}], "scores": [], "pass_results": [false, false, false, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 551, "prompt": "Petya is a math teacher. n of his students has written a test consisting of m questions, and for each student, it is known which questions he has answered correctly and which he has not.\n\nIf the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points); moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.\n\nFor the i-th student, Petya knows that he expects to get x_i points for the test and wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 ", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 ", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 54}
