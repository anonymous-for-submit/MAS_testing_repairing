{"name": "1594_D. The Number of Imposters", "description": "Theofanis started playing the new online game called \"Among them\". However, he always plays with Cypriot players, and they all have the same name: \"Andreas\" (the most common name in Cyprus).\n\nIn each game, Theofanis plays with n other players. Since they all have the same name, they are numbered from 1 to n.\n\nThe players write m comments in the chat. A comment has the structure of \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate). The comment means that player i said that player j has the role c.\n\nAn imposter always lies, and a crewmate always tells the truth. \n\nHelp Theofanis find the maximum possible number of imposters among all the other Cypriot players, or determine that the comments contradict each other (see the notes for further explanation).\n\nNote that each player has exactly one role: either imposter or crewmate.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.", "tags": ["constructive algorithms", "dfs and similar", "dp", "dsu", "graphs"], "difficulty": 10, "id": 1594, "sample_io": [{"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}], "test_list": [{"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n2\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["4\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n-1\n2\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n4\n1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n4\n-1\n2\n9\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n9\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n10 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n9\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n3\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n1 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n4\n2\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n5\n1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["2\n4\n-1\n2\n13\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n4 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n3\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 3 crewmate\n1 3 imposter\n10 0\n", "output": ["4\n3\n-1\n2\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n4 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n4 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n3\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n8 0\n", "output": ["2\n4\n1\n-1\n8\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n-1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n2\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n2 0\n", "output": ["2\n4\n-1\n5\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n2\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["4\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n-1\n-1\n2\n9\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n-1\n1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 3 crewmate\n2 3 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["-1\n4\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n15 0\n", "output": ["2\n4\n1\n-1\n15\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n4\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n6 0\n", "output": ["2\n3\n1\n-1\n6\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n3\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n7 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n6\n-1\n2\n7\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n4\n2\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n5 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n4\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n3\n-1\n2\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["2\n4\n1\n2\n13\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n4 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n4 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n-1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n7 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 4 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n6\n3\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n4 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n2 0\n", "output": ["2\n4\n-1\n2\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n10 0\n", "output": ["2\n4\n2\n2\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n-1\n1\n-1\n9\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n10 0\n", "output": ["2\n4\n1\n-1\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n-1\n-1\n-1\n4\n"]}, {"input": "5\n6 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 1 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["5\n4\n-1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["4\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 4 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n-1\n1\n-1\n7\n"]}, {"input": "5\n4 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["3\n3\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n-1\n1\n-1\n5\n"]}, {"input": "5\n8 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["7\n4\n2\n-1\n2\n"]}, {"input": "5\n6 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["5\n4\n1\n2\n13\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 4 imposter\n2 1 crewmate\n6 5\n1 1 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n4\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n4 5 crewmate\n1 4 imposter\n2 1 imposter\n4 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n3\n-1\n5\n"]}, {"input": "5\n4 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["3\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n10 0\n", "output": ["2\n4\n2\n-1\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 3 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n5\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n2 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n2 0\n", "output": ["2\n4\n-1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n1 3 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n2 2 crewmate\n1 2 imposter\n2 0\n", "output": ["2\n4\n1\n2\n2\n"]}, {"input": "5\n5 2\n1 2 imposter\n4 2 crewmate\n10 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n8\n-1\n2\n5\n"]}, {"input": "5\n10 2\n1 2 imposter\n4 2 crewmate\n10 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["9\n8\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n3\n2\n5\n"]}, {"input": "5\n6 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["5\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n4\n-1\n2\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n3\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 1 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n-1\n-1\n2\n4\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n-1\n1\n-1\n2\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 4 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 2 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n-1\n5\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n4 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n-1\n1\n2\n5\n"]}, {"input": "5\n4 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["3\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n8 0\n", "output": ["2\n4\n1\n2\n8\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n2\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n3 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n-1\n2\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 3 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n4\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 3 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 3 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 3 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 3 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n1 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n3 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 4 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 1 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n5\n1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n2 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n3 5 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 4 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n3\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 3 imposter\n3 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 1 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n8 0\n", "output": ["2\n4\n1\n-1\n8\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n1 4 imposter\n2 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n3 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n3 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 4 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n4\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n2\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n4 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 3 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n4\n-1\n2\n9\n"]}, {"input": "5\n3 2\n1 2 imposter\n3 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n4\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 1 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n4 2\n1 4 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n3\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n3 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n7 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 1 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 2 crewmate\n2 5 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["4\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 1 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n4 5 crewmate\n1 4 imposter\n2 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n2 3 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n2\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 2 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 3 imposter\n2 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 1 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 5 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 1 crewmate\n2 4 imposter\n1 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 5 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 3 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 1 crewmate\n2 5 crewmate\n2 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 3 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n2 3 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n4\n1\n-1\n2\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 3 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["2\n4\n-1\n2\n13\n"]}], "task_id": "codecontest/54", "repair_prompt": ["Theofanis started playing the new online game called \"Among them\". However, he always plays with Cypriot players, and they all have the same name: \"Andreas\" (the most common name in Cyprus).\n\nIn each game, Theofanis plays with n other players, and since they all have the same name, they are numbered from 1 to n.\n\nThe players write m comments in the chat. A comment has the structure of \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate), which means that player i said that player j has the role c.\n\nAn imposter always lies, and a crewmate always tells the truth. \n\nHelp Theofanis find the maximum possible number of imposters among all the other Cypriot players, or determine that the comments contradict each other (see the notes for further explanation).\n\nNote that each player has exactly one role: either imposter or crewmate.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Theofanis started playing the new online game called \"Among them\". However, he always plays with Cypriot players, and they all have the same name: \"Andreas\" (the most common name in Cyprus).\n\nIn each game, Theofanis plays with n other players, and because they all share the same name, they are numbered from 1 to n. In this setup, assigning numbers is crucial to identifying each player uniquely.\n\nThe players write m comments in the chat. A comment has the structure of \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate), which means that player i said that player j has the role c.\n\nAn imposter always lies, and a crewmate always tells the truth. \n\nHelp Theofanis find the maximum possible number of imposters among all the other Cypriot players, or determine that the comments contradict each other (see the notes for further explanation).\n\nNote that each player has exactly one role: either imposter or crewmate.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Theofanis started playing the new online game called \"Among them\". However, he always plays with Cypriot players, and they all have the same name: \"Andreas\" (the most common name in Cyprus). In each game, Theofanis plays with n other players, who are numbered from 1 to n since they all have the same name. The players write m comments in the chat. A comment has the structure of \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate), which means that player i said that player j has the role c. An imposter always lies, and a crewmate always tells the truth. Help Theofanis find the maximum possible number of imposters among all the other Cypriot players, or determine that the comments contradict each other (see the notes for further explanation). Note that each player has exactly one role: either imposter or crewmate.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n        \n        roles = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node = queue.popleft()\n                current_role = roles[node]\n                \n                for neighbor, role in graph[node]:\n                    expected_role = 0 if role == 'crewmate' else 1\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = current_role ^ expected_role\n                        count[roles[neighbor]] += 1\n                        queue.append(neighbor)\n                    elif roles[neighbor] != current_role ^ expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "completions": ["def handle_no_comments_case(n):\n    return n\n\ndef detect_contradictions_and_calculate_max_imposters(graph, n):\n    roles = [-1] * (n + 1)  # -1 means unvisited, 0 means crewmate, 1 means imposter\n    max_imposters = 0\n\n    def bfs(start):\n        queue = [(start, 0)]  # Start with the assumption that the first node is a crewmate\n        local_imposters = 0\n        local_crewmates = 0\n\n        while queue:\n            node, role = queue.pop(0)\n            if roles[node] == -1:\n                roles[node] = role\n                if role == 0:\n                    local_crewmates += 1\n                else:\n                    local_imposters += 1\n            elif roles[node] != role:\n                return -1  # Contradiction found\n\n            for neighbor, claim in graph[node]:\n                expected_role = role if claim == 'crewmate' else 1 - role\n                if roles[neighbor] == -1:\n                    queue.append((neighbor, expected_role))\n                elif roles[neighbor] != expected_role:\n                    return -1  # Contradiction found\n\n        return max(local_imposters, local_crewmates)\n\n    for player in range(1, n + 1):\n        if roles[player] == -1:\n            result = bfs(player)\n            if result == -1:\n                return -1\n            max_imposters += result\n\n    return max_imposters\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n\n        if m == 0:\n            results.append(handle_no_comments_case(n))\n            continue\n\n        graph = [[] for _ in range(n + 1)]\n\n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n\n        result = detect_contradictions_and_calculate_max_imposters(graph, n)\nmain()", "def solve_among_them():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1 means unassigned, 0 means crewmate, 1 means imposter\n        \n        def dfs(player, role):\n            stack = [(player, role)]\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while stack:\n                current, current_role = stack.pop()\n                \n                if roles[current] != -1:\n                    if roles[current] != current_role:\n                        return -1, None  # contradiction found\n                    continue\n                \n                roles[current] = current_role\n                count[current_role] += 1\n                \n                for neighbor, claim in graph[current]:\n                    if claim == 'crewmate':\n                        next_role = current_role\n                    else:\n                        next_role = 1 - current_role\n                    \n                    if roles[neighbor] == -1:\n                        stack.append((neighbor, next_role))\n                    elif roles[neighbor] != next_role:\n                        return -1, None  # contradiction found\n            \n            return max(count), count\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result, _ = dfs(player, 0)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve_among_them()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, False))\n                graph[j].append((i, False))\n            else:\n                graph[i].append((j, True))\n                graph[j].append((i, True))\n        \n        roles = [-1] * (n + 1)\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([(start, True)])\n            roles[start] = True\n            count_true = 0\n            count_false = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if role:\n                    count_true += 1\n                else:\n                    count_false += 1\n                \n                for neighbor, truth in graph[node]:\n                    expected_role = role if truth else not role\n                    \n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append((neighbor, expected_role))\n                    elif roles[neighbor] != expected_role:\n                        return -1\n            \n            return max(count_true, count_false)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                else:\n                    max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n    if rootX != rootY:\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        parent = list(range(2 * n + 1))\n        rank = [0] * (2 * n + 1)\n        \n        contradiction = False\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                if find(parent, i) == find(parent, j):\n                    contradiction = True\n                    break\n                union(parent, rank, i, j + n)\n                union(parent, rank, i + n, j)\n            else:  # c == \"crewmate\"\n                if find(parent, i) == find(parent, j + n):\n                    contradiction = True\n                    break\n                union(parent, rank, i, j)\n                union(parent, rank, i + n, j + n)\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            imposter_count = 0\n            visited = set()\n            for i in range(1, n + 1):\n                root1 = find(parent, i)\n                root2 = find(parent, i + n)\n                if root1 not in visited and root2 not in visited:\n                    visited.add(root1)\n                    visited.add(root2)\n                    imposter_count += max(rank[root1], rank[root2])\n            results.append(imposter_count)\n    \n    for result in results:\n        print(result)\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            # If there are no comments, all players can be imposters\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1 means unvisited, 0 means crewmate, 1 means imposter\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0  # Start with crewmate\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                node = queue.popleft()\n                current_role = roles[node]\n                count[current_role] += 1\n                \n                for neighbor, claim in graph[node]:\n                    expected_role = 1 - current_role if claim == \"imposter\" else current_role\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != expected_role:\n                        return -1  # Contradiction found\n            \n            return max(count)\n        \n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n        \n        roles = [-1] * (n + 1)\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                node = queue.popleft()\n                current_role = roles[node]\n                count[current_role] += 1\n                \n                for neighbor, role in graph[node]:\n                    expected_role = 0 if role == 'crewmate' else 1\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = 1 - current_role if role == 'imposter' else current_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != (1 - current_role if role == 'imposter' else current_role):\n                        return -1\n            \n            return max(count)\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                results.append(result)\n        \n        if contradiction:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve_among_them():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1 means unknown, 0 means crewmate, 1 means imposter\n        contradiction_found = False\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # Start with crewmate\n            roles[start] = 0\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                current, role = queue.popleft()\n                count[role] += 1\n                \n                for neighbor, claim in graph[current]:\n                    expected_role = 1 if claim == 'imposter' else 0\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = role ^ expected_role\n                        queue.append((neighbor, roles[neighbor]))\n                    elif roles[neighbor] != role ^ expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction_found = True\n                    break\n                else:\n                    max_imposters += result\n        \n        if contradiction_found:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve_among_them()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        roles = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            roles[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        count[expected_role] += 1\n                        queue.append((neighbor, expected_role))\n                    elif roles[neighbor] != expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        contradiction = False\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        comments = []\n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            comments.append((i, j, c))\n            index += 3\n        \n        # Graph representation\n        graph = defaultdict(list)\n        \n        for i, j, c in comments:\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        roles = [-1] * (n + 1)  # -1 means unassigned, 0 means crewmate, 1 means imposter\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # Start with crewmate assumption\n            roles[start] = 0\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                node, role = queue.popleft()\n                count[role] += 1\n                \n                for neighbor, expected_role in graph[node]:\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = role ^ expected_role\n                        queue.append((neighbor, roles[neighbor]))\n                    elif roles[neighbor] != role ^ expected_role:\n                        return -1, 0\n            \n            return max(count), sum(count)\n        \n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result, _ = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n        \n        roles = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node = queue.popleft()\n                current_role = roles[node]\n                \n                for neighbor, role in graph[node]:\n                    expected_role = 0 if role == 'crewmate' else 1\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = current_role ^ expected_role\n                        count[roles[neighbor]] += 1\n                        queue.append(neighbor)\n                    elif roles[neighbor] != current_role ^ expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of players and comments.\",\n        \"For each comment, read the player indices and the role mentioned.\"\n      ]\n    },\n    {\n      \"description\": \"Model the problem using a graph where players are nodes and comments are edges with labels indicating the role.\",\n      \"steps\": [\n        \"Create a graph representation for each test case.\",\n        \"Add nodes for each player.\",\n        \"Add edges between nodes based on comments, with labels indicating 'imposter' or 'crewmate'.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters or detect contradictions using graph traversal and role assignment.\",\n      \"steps\": [\n        \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to assign roles to players.\",\n        \"Check for contradictions during traversal (e.g., conflicting role assignments).\",\n        \"Calculate the maximum number of imposters if no contradictions are found.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output the maximum number of imposters or -1 if contradictions are detected.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and comments.\",\n    \"Model each test case as a graph with players as nodes and comments as edges.\",\n    \"Traverse the graph to assign roles and detect contradictions.\",\n    \"Calculate and output the maximum number of imposters or -1 for contradictions.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter': A player who always lies about the role of other players.\n    'crewmate': A player who always tells the truth about the role of other players.\n    'contradict': A situation where the comments made by players lead to logical inconsistencies, making it impossible to assign roles without conflict.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This indicates that we need to find the highest number of imposters that can be assigned without contradictions.\n    Implementation: This can be achieved by traversing the graph and attempting to maximize the number of imposters while checking for contradictions.\n\n# [degree adverb]\n    'maximum': Refers to the largest number of imposters that can be assigned without contradictions.\n    Implementation: Use graph traversal to explore all possible role assignments and keep track of the highest number of imposters.\n\n# [code logic]\n    The steps in the plan related to graph traversal and role assignment should be implemented simultaneously. Specifically:\n    - \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to assign roles to players.\"\n    - \"Check for contradictions during traversal (e.g., conflicting role assignments).\"\n    These steps can be combined in a single traversal function that assigns roles and checks for contradictions in one pass.\n\n# [edge case]\n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: With no comments, there are no contradictions, so all players can be imposters.\n    \n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, making it impossible to assign roles without conflict.\n    \n    Test case with multiple comments for the same pair (e.g., 3 5 with comments \"1 2 imposter\", \"1 2 imposter\", \"3 2 crewmate\", \"3 2 crewmate\", \"1 3 imposter\") = 2\n    Explanation: Despite multiple comments, the roles can be assigned without contradiction, allowing for 2 imposters.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, particularly for detecting contradictions.\n    Code for handling contradictions:\n    ```python\n    def detect_contradictions(graph):\n        # Implement graph traversal to assign roles\n        # Check for contradictions during traversal\n        # Return", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n        \n        roles = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node = queue.popleft()\n                current_role = roles[node]\n                \n                for neighbor, role in graph[node]:\n                    expected_role = 0 if role == 'crewmate' else 1\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = current_role ^ expected_role\n                        count[roles[neighbor]] += 1\n                        queue.append(neighbor)\n                    elif roles[neighbor] != current_role ^ expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n        \n        roles = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node = queue.popleft()\n                current_role = roles[node]\n                \n                for neighbor, role in graph[node]:\n                    expected_role = 0 if role == 'crewmate' else 1\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = current_role ^ expected_role\n                        count[roles[neighbor]] += 1\n                        queue.append(neighbor)\n                    elif roles[neighbor] != current_role ^ expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read integers n and m, representing the number of players and comments respectively.\",\n        \"For each test case, read m lines of comments, each containing two integers i, j and a string c.\"\n      ]\n    },\n    {\n      \"description\": \"Model the problem using graph theory where players are nodes and comments are edges with labels indicating truth or lie.\",\n      \"steps\": [\n        \"Create a graph for each test case where nodes represent players.\",\n        \"Add edges between nodes based on comments, with labels indicating 'imposter' or 'crewmate'.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters or detect contradictions in comments.\",\n      \"steps\": [\n        \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to assign roles to players.\",\n        \"Check for contradictions during traversal: if a contradiction is found, mark the test case as invalid.\",\n        \"If no contradictions are found, calculate the maximum number of imposters possible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if a contradiction is detected, output -1.\",\n        \"Otherwise, output the maximum number of imposters calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and comments.\",\n    \"Model each test case as a graph with players as nodes and comments as edges.\",\n    \"Traverse the graph to assign roles and detect contradictions.\",\n    \"Calculate the maximum number of imposters if no contradictions are found.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter' and 'crewmate'\n    Explanation: In the game, an imposter always lies, and a crewmate always tells the truth. The task is to determine the maximum number of imposters possible or detect contradictions in the comments.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This means we need to find the highest count of imposters that can be logically deduced from the comments without contradictions.\n    '1 \u2264 i, j \u2264 n': This indicates the range of player numbers, ensuring they are valid player identifiers.\n\n# [degree adverb]\n    'maximum': This refers to finding the largest possible number of imposters that can be deduced from the comments without contradictions.\n\n# [code logic]\n    The steps in the plan related to graph traversal and contradiction detection should be implemented simultaneously. Specifically:\n    - \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to assign roles to players.\"\n    - \"Check for contradictions during traversal: if a contradiction is found, mark the test case as invalid.\"\n    These steps can be combined in a single traversal process where roles are assigned and contradictions are checked concurrently.\n\n# [edge case]\n    Test case with no comments (e.g., n = 5, m = 0) = 5\n    Explanation: With no comments, there are no constraints, so all players can be imposters.\n    \n    Test case with contradictory comments (e.g., 1 2 imposter, 2 1 crewmate) = -1\n    Explanation: This is a direct contradiction, as explained in the requirement, leading to an invalid scenario.\n    \n    Test case with all players claiming others are imposters (e.g., 1 2 imposter, 2 3 imposter, 3 1 imposter) = 2\n    Explanation: In a cycle of accusations, at least one player must be a crewmate to avoid contradiction, so the maximum imposters are n-1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - For the case with no comments, we can directly return n as the number of imposters.\n    - For contradiction detection, ensure the graph traversal checks for cycles and conflicting statements.\n\n```python\ndef handle_no_comments_case(n):\n    return n\n\ndef detect_contradictions_and_calculate_max_imposters(graph, n):\n    # Implement DFS/BFS to", "Round_0": {"code": "def handle_no_comments_case(n):\n    return n\n\ndef detect_contradictions_and_calculate_max_imposters(graph, n):\n    roles = [-1] * (n + 1)  # -1 means unvisited, 0 means crewmate, 1 means imposter\n    max_imposters = 0\n\n    def bfs(start):\n        queue = [(start, 0)]  # Start with the assumption that the first node is a crewmate\n        local_imposters = 0\n        local_crewmates = 0\n\n        while queue:\n            node, role = queue.pop(0)\n            if roles[node] == -1:\n                roles[node] = role\n                if role == 0:\n                    local_crewmates += 1\n                else:\n                    local_imposters += 1\n            elif roles[node] != role:\n                return -1  # Contradiction found\n\n            for neighbor, claim in graph[node]:\n                expected_role = role if claim == 'crewmate' else 1 - role\n                if roles[neighbor] == -1:\n                    queue.append((neighbor, expected_role))\n                elif roles[neighbor] != expected_role:\n                    return -1  # Contradiction found\n\n        return max(local_imposters, local_crewmates)\n\n    for player in range(1, n + 1):\n        if roles[player] == -1:\n            result = bfs(player)\n            if result == -1:\n                return -1\n            max_imposters += result\n\n    return max_imposters\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n\n        if m == 0:\n            results.append(handle_no_comments_case(n))\n            continue\n\n        graph = [[] for _ in range(n + 1)]\n\n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n\n        result = detect_contradictions_and_calculate_max_imposters(graph, n)", "report": "The compilation output of the preceding code is: detect_contradictions_and_calculate_max_imposters() missing 1 required positional argument: 'n'"}, "Round_1": {"code": "def handle_no_comments_case(n):\n    return n\n\ndef detect_contradictions_and_calculate_max_imposters(graph, n):\n    roles = [-1] * (n + 1)  # -1 means unvisited, 0 means crewmate, 1 means imposter\n    max_imposters = 0\n\n    def bfs(start):\n        queue = [(start, 0)]  # Start with the assumption that the first node is a crewmate\n        local_imposters = 0\n        local_crewmates = 0\n\n        while queue:\n            node, role = queue.pop(0)\n            if roles[node] == -1:\n                roles[node] = role\n                if role == 0:\n                    local_crewmates += 1\n                else:\n                    local_imposters += 1\n            elif roles[node] != role:\n                return -1  # Contradiction found\n\n            for neighbor, claim in graph[node]:\n                expected_role = role if claim == 'crewmate' else 1 - role\n                if roles[neighbor] == -1:\n                    queue.append((neighbor, expected_role))\n                elif roles[neighbor] != expected_role:\n                    return -1  # Contradiction found\n\n        return max(local_imposters, local_crewmates)\n\n    for player in range(1, n + 1):\n        if roles[player] == -1:\n            result = bfs(player)\n            if result == -1:\n                return -1\n            max_imposters += result\n\n    return max_imposters\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n\n        if m == 0:\n            results.append(handle_no_comments_case(n))\n            continue\n\n        graph = [[] for _ in range(n + 1)]\n\n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n\n        result = detect_contradictions_and_calculate_max_imposters(graph, n)"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of players and comments.\",\n        \"For each comment, extract the player numbers and the role mentioned.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the roles of players based on comments and identify contradictions.\",\n      \"steps\": [\n        \"Initialize a data structure to store the role information for each player.\",\n        \"Iterate through the comments and update the roles based on the truthfulness of the statements.\",\n        \"Check for contradictions in the comments (e.g., if a player is both claimed to be a crewmate and an imposter).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum possible number of imposters or identify contradictions.\",\n      \"steps\": [\n        \"If no contradictions are found, calculate the maximum number of imposters by considering the possible role assignments.\",\n        \"If contradictions are found, mark the test case as invalid.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the maximum number of imposters or -1 if contradictions are present.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and comments.\",\n    \"For each test case, analyze the comments to determine possible roles of players.\",\n    \"Check for contradictions in the comments.\",\n    \"Calculate the maximum number of imposters if no contradictions are found.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter' and 'crewmate'\n    Explanation: In the game, an imposter always lies, and a crewmate always tells the truth. The task is to determine the maximum number of imposters based on the comments made by players, or identify if the comments contradict each other.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This means we need to find the highest count of imposters that can be logically deduced from the comments without contradiction.\n\n# [degree adverb] \n    'maximum': This indicates that we need to find the largest possible number of imposters that can be deduced from the given comments.\n\n# [code logic]\n    The steps in the plan related to checking for contradictions and calculating the maximum number of imposters should be considered simultaneously. Specifically, while iterating through the comments to update roles, we should also check for contradictions in the same loop to avoid unnecessary re-iteration.\n\n# [edge case] \n    1. Test case with no comments (e.g., n = 5, m = 0) = 5\n       Explanation: With no comments, there are no contradictions, and all players can be imposters.\n    2. Test case with contradictory comments (e.g., 1 2 imposter, 2 1 crewmate) = -1\n       Explanation: The comments directly contradict each other, making it impossible to assign roles without contradiction.\n    3. Test case with all players claiming others as imposters (e.g., 1 2 imposter, 2 3 imposter, 3 1 imposter) = 2\n       Explanation: A possible configuration is that two players are imposters and one is a crewmate, which satisfies the conditions without contradiction.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, particularly for detecting contradictions and handling cases with no comments.\n    ```python\n    def handle_edge_cases(n, m, comments):\n        if m == 0:\n            return n  # No comments, all can be imposters\n        # Initialize role tracking\n        roles = {}\n        for i, j, c in comments:\n            if (i, j) in roles:\n                if roles[(i, j)] != c:\n                    return -1  # Contradiction found\n            roles[(i, j)] = c\n        # Further logic to determine maximum imposters\n        #", "Round_0": {"code": "def solve_among_them():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1 means unassigned, 0 means crewmate, 1 means imposter\n        \n        def dfs(player, role):\n            stack = [(player, role)]\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while stack:\n                current, current_role = stack.pop()\n                \n                if roles[current] != -1:\n                    if roles[current] != current_role:\n                        return -1, None  # contradiction found\n                    continue\n                \n                roles[current] = current_role\n                count[current_role] += 1\n                \n                for neighbor, claim in graph[current]:\n                    if claim == 'crewmate':\n                        next_role = current_role\n                    else:\n                        next_role = 1 - current_role\n                    \n                    if roles[neighbor] == -1:\n                        stack.append((neighbor, next_role))\n                    elif roles[neighbor] != next_role:\n                        return -1, None  # contradiction found\n            \n            return max(count), count\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result, _ = dfs(player, 0)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve_among_them()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 114)"}, "Round_1": {"code": "def solve_among_them():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1 means unassigned, 0 means crewmate, 1 means imposter\n        \n        def dfs(player, role):\n            stack = [(player, role)]\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while stack:\n                current, current_role = stack.pop()\n                \n                if roles[current] != -1:\n                    if roles[current] != current_role:\n                        return -1, None  # contradiction found\n                    continue\n                \n                roles[current] = current_role\n                count[current_role] += 1\n                \n                for neighbor, claim in graph[current]:\n                    if claim == 'crewmate':\n                        next_role = current_role\n                    else:\n                        next_role = 1 - current_role\n                    \n                    if roles[neighbor] == -1:\n                        stack.append((neighbor, next_role))\n                    elif roles[neighbor] != next_role:\n                        return -1, None  # contradiction found\n            \n            return max(count), count\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result, _ = dfs(player, 0)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve_among_them()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of players, number of comments, and the comments themselves.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, model the problem as a graph where players are nodes and comments are directed edges with labels indicating the role (imposter or crewmate).\",\n      \"output\": \"A graph representation for each test case.\"\n    },\n    {\n      \"description\": \"Determine the possible roles (imposter or crewmate) for each player using the graph, ensuring no contradictions arise from the comments.\",\n      \"output\": \"A role assignment for each player or a contradiction flag.\"\n    },\n    {\n      \"description\": \"Calculate the maximum number of imposters possible for each test case based on the valid role assignments.\",\n      \"output\": \"The maximum number of imposters or -1 if a contradiction is found.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, construct a graph where nodes represent players and edges represent comments with roles.\",\n    \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to assign roles to each player, checking for contradictions.\",\n    \"If a contradiction is detected during role assignment, mark the test case as having a contradiction.\",\n    \"If no contradiction is found, calculate the maximum number of imposters by considering the possible role assignments.\",\n    \"Output the result for each test case, either the maximum number of imposters or -1 if a contradiction exists.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter': A player who always lies about the role of other players.\n    'crewmate': A player who always tells the truth about the role of other players.\n    'contradiction': Occurs when the comments from players lead to an impossible scenario where roles cannot be consistently assigned.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': Refers to the highest count of imposters that can be assigned without contradictions.\n    'distinct integers': Ensures that the players involved in a comment are different from each other.\n\n# [degree adverb]\n    'maximum': Indicates the need to find the largest possible number of imposters.\n\n# [code logic]\n    The steps related to graph construction and role assignment should be implemented simultaneously. Specifically, constructing the graph and traversing it to assign roles should be done in a single code block using DFS or BFS to ensure consistency in role assignment and contradiction detection.\n\n# [edge case]\n    Test case with no comments (e.g., n = 5, m = 0) = 5\n    Explanation: With no comments, all players can be imposters, as there are no contradictions.\n    \n    Test case with contradictory comments (e.g., 1 2 imposter, 2 1 crewmate) = -1\n    Explanation: The comments directly contradict each other, making it impossible to assign roles consistently.\n    \n    Test case with all players claiming others are imposters (e.g., 1 2 imposter, 2 3 imposter, 3 1 imposter) = 3\n    Explanation: All players can be imposters since each claim supports the others being imposters.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, particularly for detecting contradictions.\n        if m == 0:\n            print(n)\n        else:\n            # Implement graph traversal to detect contradictions\n            # If contradiction detected, print -1\n            # Otherwise, calculate and print the maximum number of imposters\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, False))\n                graph[j].append((i, False))\n            else:\n                graph[i].append((j, True))\n                graph[j].append((i, True))\n        \n        roles = [-1] * (n + 1)\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([(start, True)])\n            roles[start] = True\n            count_true = 0\n            count_false = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if role:\n                    count_true += 1\n                else:\n                    count_false += 1\n                \n                for neighbor, truth in graph[node]:\n                    expected_role = role if truth else not role\n                    \n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append((neighbor, expected_role))\n                    elif roles[neighbor] != expected_role:\n                        return -1\n            \n            return max(count_true, count_false)\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                else:\n                    results.append(result)\n        \n        if contradiction:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, False))\n                graph[j].append((i, False))\n            else:\n                graph[i].append((j, True))\n                graph[j].append((i, True))\n        \n        roles = [-1] * (n + 1)\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([(start, True)])\n            roles[start] = True\n            count_true = 0\n            count_false = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if role:\n                    count_true += 1\n                else:\n                    count_false += 1\n                \n                for neighbor, truth in graph[node]:\n                    expected_role = role if truth else not role\n                    \n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append((neighbor, expected_role))\n                    elif roles[neighbor] != expected_role:\n                        return -1\n            \n            return max(count_true, count_false)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                else:\n                    max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of players, number of comments, and the comments themselves.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases where each test case contains the number of players, number of comments, and a list of comments.\"\n    },\n    {\n      \"description\": \"For each test case, determine if the comments are consistent or contradictory. This involves checking if there is a logical contradiction in the statements made by the players.\",\n      \"output\": \"A boolean value indicating whether the comments are consistent or contradictory for each test case.\"\n    },\n    {\n      \"description\": \"If the comments are consistent, calculate the maximum possible number of imposters among the players. This involves analyzing the statements to determine the maximum number of players that can be imposters without causing a contradiction.\",\n      \"output\": \"An integer representing the maximum number of imposters for each test case, or -1 if the comments are contradictory.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"Iterate over each test case and perform the following steps:\",\n    \"  a. Initialize data structures to represent the players and their statements.\",\n    \"  b. Check for contradictions in the comments using a graph-based approach or a union-find data structure to manage player roles.\",\n    \"  c. If a contradiction is found, mark the test case as inconsistent and set the result to -1.\",\n    \"  d. If no contradiction is found, calculate the maximum number of imposters by exploring possible role assignments that maximize imposters.\",\n    \"Store the results for each test case.\",\n    \"Output the results for all test cases in the required format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter' and 'crewmate'\n    Explanation: In the game, an imposter always lies, and a crewmate always tells the truth. The task is to determine the maximum number of imposters possible or identify contradictions in the comments.\n\n# [phrase showing quantity relationship]\n    'maximum possible number of imposters'\n    Explanation: This means finding the highest number of players that can be imposters without causing any contradictions in the statements. In code, this involves checking all possible configurations of player roles and ensuring no contradictions arise.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This indicates the need to find the largest possible count of imposters. In code, this can be implemented by iterating through possible configurations and keeping track of the highest valid count.\n\n# [code logic]\n    The steps related to checking contradictions and calculating the maximum number of imposters should be considered simultaneously. Specifically, steps 2b and 2d in the high-level plan can be integrated into a single process where contradictions are checked while attempting to maximize the number of imposters.\n\n# [edge case]\n    1. Test case with no comments (e.g., n = 5, m = 0) = 5\n       Explanation: With no comments, there are no contradictions, so all players can be imposters.\n    2. Test case with contradictory comments (e.g., 1 2 imposter, 2 1 crewmate) = -1\n       Explanation: The comments directly contradict each other, so the output should be -1.\n    3. Test case with all players claiming others are imposters (e.g., 1 2 imposter, 2 3 imposter, 3 1 imposter) = 2\n       Explanation: At least one player must be a crewmate to avoid contradiction, so the maximum number of imposters is 2.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should include logic to handle cases with no comments and to detect direct contradictions. This can be achieved using a union-find data structure to manage player roles and detect cycles or contradictions in the graph of statements.\n\nYES", "Round_0": {"code": "def find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n    if rootX != rootY:\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        parent = list(range(2 * n + 1))\n        rank = [0] * (2 * n + 1)\n        \n        contradiction = False\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                if find(parent, i) == find(parent, j):\n                    contradiction = True\n                    break\n                union(parent, rank, i, j + n)\n                union(parent, rank, i + n, j)\n            else:  # c == \"crewmate\"\n                if find(parent, i) == find(parent, j + n):\n                    contradiction = True\n                    break\n                union(parent, rank, i, j)\n                union(parent, rank, i + n, j + n)\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            imposter_count = 0\n            visited = set()\n            for i in range(1, n + 1):\n                root1 = find(parent, i)\n                root2 = find(parent, i + n)\n                if root1 not in visited and root2 not in visited:\n                    visited.add(root1)\n                    visited.add(root2)\n                    imposter_count += max(rank[root1], rank[root2])\n            results.append(imposter_count)\n    \n    for result in results:\n        print(result", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 72)"}, "Round_1": {"code": "def find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n    if rootX != rootY:\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        parent = list(range(2 * n + 1))\n        rank = [0] * (2 * n + 1)\n        \n        contradiction = False\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                if find(parent, i) == find(parent, j):\n                    contradiction = True\n                    break\n                union(parent, rank, i, j + n)\n                union(parent, rank, i + n, j)\n            else:  # c == \"crewmate\"\n                if find(parent, i) == find(parent, j + n):\n                    contradiction = True\n                    break\n                union(parent, rank, i, j)\n                union(parent, rank, i + n, j + n)\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            imposter_count = 0\n            visited = set()\n            for i in range(1, n + 1):\n                root1 = find(parent, i)\n                root2 = find(parent, i + n)\n                if root1 not in visited and root2 not in visited:\n                    visited.add(root1)\n                    visited.add(root2)\n                    imposter_count += max(rank[root1], rank[root2])\n            results.append(imposter_count)\n    \n    for result in results:\n        print(result)"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read integers n and m, representing the number of players and comments respectively.\",\n        \"For each test case, read m lines of comments, each containing two integers i, j and a string c.\"\n      ]\n    },\n    {\n      \"description\": \"Model the problem using a graph where players are nodes and comments are edges with labels indicating the role (imposter or crewmate).\",\n      \"steps\": [\n        \"Create a graph representation for each test case where nodes represent players and edges represent comments.\",\n        \"Label edges with the role indicated in the comment (imposter or crewmate).\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters or detect contradictions in comments.\",\n      \"steps\": [\n        \"Use graph traversal techniques (e.g., DFS or BFS) to attempt to assign roles to players based on comments.\",\n        \"Check for contradictions during traversal: if a contradiction is found, mark the test case as invalid (-1).\",\n        \"If no contradictions are found, calculate the maximum number of imposters possible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output the maximum number of imposters or -1 if contradictions are detected.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases, number of players, comments, and their details.\",\n    \"Model each test case as a graph with players as nodes and comments as labeled edges.\",\n    \"Traverse the graph to assign roles to players, checking for contradictions.\",\n    \"Calculate the maximum number of imposters if no contradictions are found.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter' and 'crewmate'\n    Explanation: In the game, an imposter always lies, and a crewmate always tells the truth. The task is to determine the maximum number of imposters possible or identify contradictions in the comments.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This means we need to find the highest count of imposters that can be logically deduced from the comments without contradictions.\n    Implementation: This can be implemented by traversing the graph and counting the imposters while ensuring no contradictions arise.\n\n# [degree adverb]\n    'maximum': This indicates the need to find the largest possible number of imposters.\n    Implementation: Use a graph traversal to explore all possible configurations and select the one with the highest number of imposters.\n\n# [code logic]\n    The steps in the plan related to graph traversal and contradiction checking should be implemented simultaneously. Specifically:\n    - \"Use graph traversal techniques (e.g., DFS or BFS) to attempt to assign roles to players based on comments.\"\n    - \"Check for contradictions during traversal: if a contradiction is found, mark the test case as invalid (-1).\"\n    These steps can be combined in a single traversal function that assigns roles and checks for contradictions concurrently.\n\n# [edge case]\n    1. Test case with no comments (e.g., n = 5, m = 0) = 5\n       Explanation: With no comments, there are no constraints, so all players can be imposters.\n    2. Test case with a single contradiction (e.g., 1 2 imposter, 2 1 crewmate) = -1\n       Explanation: The comments directly contradict each other, so the output should be -1.\n    3. Test case with all players claiming each other as imposters (e.g., 1 2 imposter, 2 3 imposter, 3 1 imposter) = 2\n       Explanation: A cycle of claims can be resolved with two imposters and one crewmate, maximizing imposters.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Specifically, handle cases with no comments by defaulting to all players as imposters.\n    - Implement a contradiction detection mechanism during graph traversal.\n    ```python\n    def handle_no_comments(n):\n        return n\n\n    def detect_contradictions(graph):\n        # Implement DFS/BFS to", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            # If there are no comments, all players can be imposters\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1 means unvisited, 0 means crewmate, 1 means imposter\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0  # Start with crewmate\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                node = queue.popleft()\n                current_role = roles[node]\n                count[current_role] += 1\n                \n                for neighbor, claim in graph[node]:\n                    expected_role = 1 - current_role if claim == \"imposter\" else current_role\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != expected_role:\n                        return -1  # Contradiction found\n            \n            return max(count)\n        \n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 115)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            # If there are no comments, all players can be imposters\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1 means unvisited, 0 means crewmate, 1 means imposter\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0  # Start with crewmate\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                node = queue.popleft()\n                current_role = roles[node]\n                count[current_role] += 1\n                \n                for neighbor, claim in graph[node]:\n                    expected_role = 1 - current_role if claim == \"imposter\" else current_role\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != expected_role:\n                        return -1  # Contradiction found\n            \n            return max(count)\n        \n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n and m representing the number of players and comments.\",\n        \"For each test case, read m comments of the form 'i j c'.\"\n      ]\n    },\n    {\n      \"description\": \"Model the problem using a graph where players are nodes and comments are edges with labels indicating the role (imposter or crewmate).\",\n      \"steps\": [\n        \"Create a graph representation for each test case.\",\n        \"Add nodes for each player.\",\n        \"Add edges between nodes based on comments, with labels indicating the role.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters or detect contradictions in comments.\",\n      \"steps\": [\n        \"Use graph traversal techniques (e.g., DFS or BFS) to attempt to assign roles to players.\",\n        \"Check for contradictions during traversal (e.g., conflicting roles for the same player).\",\n        \"Calculate the maximum number of imposters if no contradictions are found.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output the maximum number of imposters or -1 if contradictions are detected.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and comments.\",\n    \"For each test case, construct a graph based on players and comments.\",\n    \"Traverse the graph to assign roles and detect contradictions.\",\n    \"Calculate the maximum number of imposters if possible.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter' and 'crewmate'\n    Explanation: In the game, an imposter always lies, and a crewmate always tells the truth. The task is to determine the maximum number of imposters based on the comments, or identify contradictions.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This means we need to find the highest count of imposters that can be logically deduced from the comments without contradictions.\n    'distinct integers': This indicates that the players i and j in a comment are different individuals.\n\n# [degree adverb]\n    'maximum': This refers to finding the largest possible number of imposters that can be deduced from the comments without contradictions.\n\n# [code logic]\n    The steps in the plan related to graph traversal and contradiction checking should be implemented simultaneously. Specifically:\n    - \"Use graph traversal techniques (e.g., DFS or BFS) to attempt to assign roles to players.\"\n    - \"Check for contradictions during traversal (e.g., conflicting roles for the same player).\"\n    These can be done in a single traversal loop where roles are assigned and contradictions are checked concurrently.\n\n# [edge case]\n    1. Test case with no comments (e.g., n = 5, m = 0) = 5\n       Explanation: With no comments, there are no contradictions, so all players can be imposters.\n    2. Test case with contradictory comments (e.g., 1 2 imposter, 2 1 crewmate) = -1\n       Explanation: The comments directly contradict each other, so the output should be -1.\n    3. Test case with all players claiming others are imposters (e.g., 1 2 imposter, 2 3 imposter, 3 1 imposter) = 2\n       Explanation: A cycle of accusations can lead to a maximum of n-1 imposters if no contradictions arise.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to handle cases with no comments and detect contradictions during graph traversal.\n    ```python\n    if m == 0:\n        return n\n    # During graph traversal\n    if contradiction_detected:\n        return -1\n    ```\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n        \n        roles = [-1] * (n + 1)\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                node = queue.popleft()\n                current_role = roles[node]\n                count[current_role] += 1\n                \n                for neighbor, role in graph[node]:\n                    expected_role = 0 if role == 'crewmate' else 1\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = 1 - current_role if role == 'imposter' else current_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != (1 - current_role if role == 'imposter' else current_role):\n                        return -1\n            \n            return max(count)\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                results.append(result)\n        \n        if contradiction:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 158)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n        \n        roles = [-1] * (n + 1)\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                node = queue.popleft()\n                current_role = roles[node]\n                count[current_role] += 1\n                \n                for neighbor, role in graph[node]:\n                    expected_role = 0 if role == 'crewmate' else 1\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = 1 - current_role if role == 'imposter' else current_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != (1 - current_role if role == 'imposter' else current_role):\n                        return -1\n            \n            return max(count)\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                results.append(result)\n        \n        if contradiction:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the comments themselves.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of players and comments.\",\n        \"For each comment, read the player numbers and the role mentioned.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the roles of players based on comments and check for contradictions.\",\n      \"steps\": [\n        \"Initialize a data structure to store the role information for each player.\",\n        \"Iterate through each comment and update the role information based on the comment.\",\n        \"Check for contradictions in the comments (e.g., if a player is both claimed to be an imposter and a crewmate).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum possible number of imposters or determine if there is a contradiction.\",\n      \"steps\": [\n        \"If a contradiction is found, mark the test case as invalid.\",\n        \"Otherwise, calculate the maximum number of imposters by considering the possible role assignments.\",\n        \"Store the result for each test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all test cases.\",\n      \"steps\": [\n        \"For each test case, output the maximum number of imposters or -1 if a contradiction was found.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and comments.\",\n    \"For each test case, analyze the comments to determine possible roles and check for contradictions.\",\n    \"Calculate the maximum number of imposters for valid test cases.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter', 'crewmate'\n    Explanation: In the game, an imposter always lies, and a crewmate always tells the truth. The task is to determine the maximum number of imposters based on the comments made by players, or identify contradictions in the comments.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This means we need to find the highest count of imposters that can be logically deduced from the comments without contradictions.\n    'at least': This phrase is not explicitly in the requirement but is implied in the logic of determining roles based on comments.\n\n# [degree adverb]\n    'maximum': This indicates that we need to find the largest possible number of imposters that can be deduced from the comments without contradictions.\n\n# [code logic]\n    The steps in the plan related to checking for contradictions and calculating the maximum number of imposters should be considered simultaneously. Specifically:\n    - \"Iterate through each comment and update the role information based on the comment.\"\n    - \"Check for contradictions in the comments.\"\n    These steps should be integrated into a single loop where each comment is processed, and contradictions are checked immediately.\n\n# [edge case]\n    1. Test case with no comments (e.g., 5 0) = 5\n       Explanation: With no comments, there are no contradictions, so all players can be imposters.\n    2. Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n       Explanation: The comments directly contradict each other, so the output should be -1.\n    3. Test case with all players claiming others as imposters (e.g., 3 3 with comments \"1 2 imposter\", \"2 3 imposter\", \"3 1 imposter\") = 3\n       Explanation: If all players claim others as imposters, they can all be imposters without contradiction.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, especially for detecting contradictions.\n    ```python\n    def detect_contradictions_and_calculate_max_imposters(comments, n):\n        # Initialize role information\n        roles = [-1] * (n + 1)  # -1 means unknown, 0 means crewmate, 1 means imposter\n        contradiction_found = False\n        \n        # Process each", "Round_0": {"code": "def solve_among_them():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1 means unknown, 0 means crewmate, 1 means imposter\n        contradiction_found = False\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # Start with crewmate\n            roles[start] = 0\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                current, role = queue.popleft()\n                count[role] += 1\n                \n                for neighbor, claim in graph[current]:\n                    expected_role = 1 if claim == 'imposter' else 0\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = role ^ expected_role\n                        queue.append((neighbor, roles[neighbor]))\n                    elif roles[neighbor] != role ^ expected_role:\n                        return -1\n            \n            return max(count)\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction_found = True\n                    break\n                else:\n                    results.append(result)\n        \n        if contradiction_found:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve_among_them()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve_among_them():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1 means unknown, 0 means crewmate, 1 means imposter\n        contradiction_found = False\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # Start with crewmate\n            roles[start] = 0\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                current, role = queue.popleft()\n                count[role] += 1\n                \n                for neighbor, claim in graph[current]:\n                    expected_role = 1 if claim == 'imposter' else 0\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = role ^ expected_role\n                        queue.append((neighbor, roles[neighbor]))\n                    elif roles[neighbor] != role ^ expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction_found = True\n                    break\n                else:\n                    max_imposters += result\n        \n        if contradiction_found:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve_among_them()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"Model the problem as a graph where each player is a node and each comment is an edge with a label indicating the role (imposter or crewmate).\",\n      \"output\": \"A graph representation for each test case.\"\n    },\n    {\n      \"description\": \"Determine the possible roles (imposter or crewmate) for each player using the graph, ensuring no contradictions arise from the comments.\",\n      \"output\": \"A role assignment for each player or a contradiction flag.\"\n    },\n    {\n      \"description\": \"Calculate the maximum number of imposters possible given a valid role assignment.\",\n      \"output\": \"The maximum number of imposters for each test case.\"\n    },\n    {\n      \"description\": \"Handle contradictions by checking for cycles in the graph that violate the imposter/crewmate rules.\",\n      \"output\": \"A flag indicating whether a contradiction exists for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, construct a graph where nodes represent players and edges represent comments with roles.\",\n    \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to assign roles to each player, checking for contradictions.\",\n    \"If a contradiction is found during traversal, mark the test case as having a contradiction and output -1.\",\n    \"If no contradiction is found, calculate the maximum number of imposters by considering the role assignments.\",\n    \"Output the result for each test case, either the maximum number of imposters or -1 if a contradiction exists.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter': A player who always lies about the role of other players.\n    'crewmate': A player who always tells the truth about the role of other players.\n    'contradiction': Occurs when the comments made by players cannot logically coexist, indicating an inconsistency in role assignments.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': Refers to the highest count of imposters that can be assigned without causing contradictions in the comments.\n\n# [degree adverb]\n    'maximum': Indicates the need to find the largest possible number of imposters that can be assigned without contradictions.\n\n# [code logic]\n    The steps related to graph construction and role assignment should be considered simultaneously:\n    - Constructing the graph and assigning roles can be done in a single traversal using DFS or BFS, where nodes are players and edges are comments with roles.\n\n# [edge case]\n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: With no comments, there are no constraints, so all players can be imposters.\n    \n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, making it impossible to assign roles without inconsistency.\n    \n    Test case with all players claiming others are imposters (e.g., 3 3 with comments \"1 2 imposter\", \"2 3 imposter\", \"3 1 imposter\") = 3\n    Explanation: All players can be imposters since each claims another is an imposter, which is consistent.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, particularly for detecting contradictions.\n    - Implement a cycle detection mechanism in the graph traversal to identify contradictions.\n    - Use a union-find or similar algorithm to efficiently manage role assignments and detect inconsistencies.\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        roles = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            roles[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        count[expected_role] += 1\n                        queue.append((neighbor, expected_role))\n                    elif roles[neighbor] != expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        contradiction = False\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        roles = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            roles[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        count[expected_role] += 1\n                        queue.append((neighbor, expected_role))\n                    elif roles[neighbor] != expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        contradiction = False\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, determine if the comments are consistent or contradictory. If contradictory, return -1 for that test case.\",\n      \"output\": \"A boolean indicating whether the comments are consistent or contradictory.\"\n    },\n    {\n      \"description\": \"For consistent comments, calculate the maximum possible number of imposters among the players.\",\n      \"output\": \"An integer representing the maximum number of imposters for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read and parse the input data to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\"\n    },\n    {\n      \"step\": \"For each test case, initialize a data structure to represent the players and their roles based on the comments.\"\n    },\n    {\n      \"step\": \"Iterate through the comments for each test case to check for contradictions. Use a graph or similar structure to track relationships and detect cycles or inconsistencies.\"\n    },\n    {\n      \"step\": \"If a contradiction is found, mark the test case as invalid and prepare to output -1.\"\n    },\n    {\n      \"step\": \"If no contradictions are found, use the data structure to calculate the maximum number of imposters by considering possible role assignments that maximize imposters.\"\n    },\n    {\n      \"step\": \"Output the result for each test case, either the maximum number of imposters or -1 if contradictions were found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter' and 'crewmate'\n    Explanation: In the game, imposters always lie, and crewmates always tell the truth. Each player has exactly one role, either imposter or crewmate. The goal is to determine the maximum possible number of imposters or identify contradictions in the comments.\n\n# [phrase showing quantity relationship]\n    'maximum possible number'\n    Explanation: This means finding the highest number of imposters that can be assigned without contradictions. In code, this involves checking all possible role assignments and selecting the one with the most imposters.\n\n# [degree adverb] \n    'maximum'\n    Explanation: The requirement is to find the largest number of imposters possible. This involves evaluating all consistent role assignments and choosing the one with the highest count of imposters.\n\n# [code logic]\n    The steps related to checking contradictions and calculating the maximum number of imposters should be considered simultaneously. Specifically, while iterating through comments, we should simultaneously check for contradictions and calculate possible imposter counts using a graph-based approach to track relationships.\n\n# [edge case] \n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: With no comments, there are no contradictions, and all players can be imposters.\n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, so the output should be -1.\n    Test case with consistent comments but all players are crewmates (e.g., 3 2 with comments \"1 2 crewmate\" and \"2 3 crewmate\") = 0\n    Explanation: All players are crewmates, so the maximum number of imposters is 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to implement logic to detect contradictions using a graph-based approach and handle cases with no comments by defaulting to all players as imposters.\n\nYES", "Round_0": {"code": "def solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        comments = []\n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            comments.append((i, j, c))\n            index += 3\n        \n        # Graph representation\n        graph = defaultdict(list)\n        \n        for i, j, c in comments:\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        roles = [-1] * (n + 1)  # -1 means unassigned, 0 means crewmate, 1 means imposter\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # Start with crewmate assumption\n            roles[start] = 0\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                node, role = queue.popleft()\n                count[role] += 1\n                \n                for neighbor, expected_role in graph[node]:\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = role ^ expected_role\n                        queue.append((neighbor, roles[neighbor]))\n                    elif roles[neighbor] != role ^ expected_role:\n                        return -1, 0\n            \n            return max(count), sum(count)\n        \n        max_imposters = 0\n        total_players = 0\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result, total = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n                total_players += total\n        \n        if max_imposters == -1:\n            results.append(-1)", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 114)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        comments = []\n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            comments.append((i, j, c))\n            index += 3\n        \n        # Graph representation\n        graph = defaultdict(list)\n        \n        for i, j, c in comments:\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        roles = [-1] * (n + 1)  # -1 means unassigned, 0 means crewmate, 1 means imposter\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # Start with crewmate assumption\n            roles[start] = 0\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                node, role = queue.popleft()\n                count[role] += 1\n                \n                for neighbor, expected_role in graph[node]:\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = role ^ expected_role\n                        queue.append((neighbor, roles[neighbor]))\n                    elif roles[neighbor] != role ^ expected_role:\n                        return -1, 0\n            \n            return max(count), sum(count)\n        \n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result, _ = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of players and comments.\",\n        \"For each comment, read the player indices and the role mentioned.\"\n      ]\n    },\n    {\n      \"description\": \"Model the problem using a graph where players are nodes and comments are edges with labels indicating the role.\",\n      \"steps\": [\n        \"Create a graph representation for each test case.\",\n        \"Add nodes for each player.\",\n        \"Add edges between nodes based on comments, with labels indicating 'imposter' or 'crewmate'.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters or detect contradictions using graph traversal and role assignment.\",\n      \"steps\": [\n        \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to assign roles to players.\",\n        \"Check for contradictions during traversal (e.g., conflicting role assignments).\",\n        \"Calculate the maximum number of imposters if no contradictions are found.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output the maximum number of imposters or -1 if contradictions are detected.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and comments.\",\n    \"Model each test case as a graph with players as nodes and comments as edges.\",\n    \"Traverse the graph to assign roles and detect contradictions.\",\n    \"Calculate and output the maximum number of imposters or -1 for contradictions.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter': A player who always lies about the role of other players.\n    'crewmate': A player who always tells the truth about the role of other players.\n    'contradict': A situation where the comments made by players lead to logical inconsistencies, making it impossible to assign roles without conflict.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This indicates that we need to find the highest number of imposters that can be assigned without contradictions.\n    Implementation: This can be achieved by traversing the graph and attempting to maximize the number of imposters while checking for contradictions.\n\n# [degree adverb]\n    'maximum': Refers to the largest number of imposters that can be assigned without contradictions.\n    Implementation: Use graph traversal to explore all possible role assignments and keep track of the highest number of imposters.\n\n# [code logic]\n    The steps in the plan related to graph traversal and role assignment should be implemented simultaneously. Specifically:\n    - \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to assign roles to players.\"\n    - \"Check for contradictions during traversal (e.g., conflicting role assignments).\"\n    These steps can be combined in a single traversal function that assigns roles and checks for contradictions in one pass.\n\n# [edge case]\n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: With no comments, there are no contradictions, so all players can be imposters.\n    \n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, making it impossible to assign roles without conflict.\n    \n    Test case with multiple comments for the same pair (e.g., 3 5 with comments \"1 2 imposter\", \"1 2 imposter\", \"3 2 crewmate\", \"3 2 crewmate\", \"1 3 imposter\") = 2\n    Explanation: Despite multiple comments, the roles can be assigned without contradiction, allowing for 2 imposters.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, particularly for detecting contradictions.\n    Code for handling contradictions:\n    ```python\n    def detect_contradictions(graph):\n        # Implement graph traversal to assign roles\n        # Check for contradictions during traversal\n        # Return", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n        \n        roles = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node = queue.popleft()\n                current_role = roles[node]\n                \n                for neighbor, role in graph[node]:\n                    expected_role = 0 if role == 'crewmate' else 1\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = current_role ^ expected_role\n                        count[roles[neighbor]] += 1\n                        queue.append(neighbor)\n                    elif roles[neighbor] != current_role ^ expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n        \n        roles = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node = queue.popleft()\n                current_role = roles[node]\n                \n                for neighbor, role in graph[node]:\n                    expected_role = 0 if role == 'crewmate' else 1\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = current_role ^ expected_role\n                        count[roles[neighbor]] += 1\n                        queue.append(neighbor)\n                    elif roles[neighbor] != current_role ^ expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}], "scores": [], "pass_results": [true, true, false, false, true, false, false, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 268, "prompt": "Theofanis started playing the new online game called \"Among them\". However, he always plays with Cypriot players, and they all have the same name: \"Andreas\" (the most common name in Cyprus).\n\nIn each game, Theofanis plays with n other players, and since they all have the same name, they are numbered from 1 to n.\n\nThe players write m comments in the chat. A comment has the structure of \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate), which means that player i said that player j has the role c.\n\nAn imposter always lies, and a crewmate always tells the truth. \n\nHelp Theofanis find the maximum possible number of imposters among all the other Cypriot players, or determine that the comments contradict each other (see the notes for further explanation).\n\nNote that each player has exactly one role: either imposter or crewmate.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 22}
