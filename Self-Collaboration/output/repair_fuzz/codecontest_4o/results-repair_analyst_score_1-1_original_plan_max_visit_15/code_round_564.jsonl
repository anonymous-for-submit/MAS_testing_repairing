{"name": "1591_C. Minimize Distance", "description": "A total of n depots are located on a number line. Depot i lies at the point x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots. You and the n bags are initially at the origin 0. You can carry up to k bags at a time. You must collect the required number of goods from the origin, deliver them to the respective depots, and then return to the origin to collect your next batch of goods.\n\nCalculate the minimum distance you need to cover to deliver all the bags of goods to the depots. You do not have to return to the origin after you have delivered all the bags.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "tags": ["greedy", "math"], "difficulty": 9, "id": 1591, "sample_io": [{"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n7\n3000000000\n"]}], "test_list": [{"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n7\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n23\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["30\n41\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n43\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n43\n25\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n0 1 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["21\n40\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n46\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n50\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n40\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n40\n10\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n41\n7\n3000010100\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["13\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 4 4\n5 3\n2 2 5 3 3\n4 2\n0000000000 1000000000 1000000000 1000000000\n", "output": ["25\n39\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n9\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n23\n1000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n41\n10\n3000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n41\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n43\n27\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n44\n7\n3000000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n23\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n9\n3001000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -15 5 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n44\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 6 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n46\n8\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 3 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n50\n12\n3000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["13\n41\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n51\n7\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -15 6 2 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n44\n11\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000010000\n", "output": ["27\n41\n23\n1000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n41\n13\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n41\n9\n3000100000\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-14 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 7\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n45\n27\n3000010000\n"]}, {"input": "4\n5 1\n0 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n44\n9\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 3 3 6 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["30\n46\n9\n3001000000\n"]}, {"input": "4\n5 1\n1 0 3 4 5\n9 3\n-9 -18 -1 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["21\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["25\n46\n10\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n44\n8\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n50\n8\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 8 3 9 3\n5 3\n1 2 6 3 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n42\n10\n7000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 0 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["13\n37\n7\n3000000000\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 0 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000001000 1000000000 1000000000 1000010000\n", "output": ["13\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n37\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n45\n13\n3000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 8 3 12 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n49\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n57\n27\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 7\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000001000 1000000000 1000010000\n", "output": ["23\n45\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010000000 1000000000\n", "output": ["27\n46\n7\n3010000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 0\n5 1\n2 4 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n27\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 6 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["30\n46\n7\n3001000000\n"]}, {"input": "4\n5 1\n2 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["27\n46\n10\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1010000000\n", "output": ["16\n44\n8\n3010000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n44\n8\n3000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 -1 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["13\n39\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 6 5 9 1 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n53\n7\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 7 0\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["19\n37\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000010 1000000000\n", "output": ["29\n44\n11\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 5\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000010000 1001010000\n", "output": ["25\n41\n9\n3001010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 4\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n43\n13\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n41\n9\n7000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 8 3 12 4\n5 1\n2 0 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n49\n21\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n57\n27\n1000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010010000 1000000000\n", "output": ["27\n46\n7\n3010010000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n46\n7\n3001000000\n"]}, {"input": "4\n5 1\n2 2 3 4 5\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["27\n53\n10\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1010100000\n", "output": ["16\n44\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["11\n44\n8\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n53\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 7 0\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 4 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["19\n37\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1010000000 1000000010 1000000000\n", "output": ["29\n44\n11\n3010000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 2 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n39\n9\n7000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 1 3 12 4\n5 1\n2 0 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n47\n21\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-14 -18 -13 6 2 8 3 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n42\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 8 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n46\n10\n3001000000\n"]}, {"input": "4\n5 1\n2 2 3 4 5\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 0 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["27\n53\n8\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n2 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["11\n44\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 7 3 9 3\n5 3\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n42\n11\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-14 -18 -13 6 2 8 6 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n57\n27\n1010010000\n"]}, {"input": "4\n5 1\n2 2 3 4 7\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 0 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["29\n53\n8\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 0 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1001000000 1000000000 1010100000\n", "output": ["16\n42\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 4\n2 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["11\n44\n6\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 7 3 9 3\n5 2\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n42\n17\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 6\n-14 -18 -13 6 2 8 6 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n34\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n135\n27\n1010010000\n"]}, {"input": "4\n5 1\n2 2 3 5 7\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 0 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["31\n53\n8\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 8 1\n9 3\n-9 -18 -6 6 5 8 3 0 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1001000000 1000000000 1010100000\n", "output": ["20\n42\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -10 -6 6 6 7 3 9 3\n5 2\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n40\n17\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 10\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000010100\n", "output": ["30\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 6\n-14 -18 -13 6 2 8 6 11 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n40\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 10\n9 5\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000010100\n", "output": ["30\n40\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -6 -15 10 5 8 4 0 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["27\n43\n13\n3000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["23\n135\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -6 -15 10 5 8 4 0 4\n5 3\n2 7 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000110000\n", "output": ["27\n43\n13\n1000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["23\n135\n31\n1010010000\n"]}, {"input": "4\n5 1\n0 0 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["19\n135\n31\n1010010000\n"]}, {"input": "4\n5 1\n0 0 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 4 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["19\n115\n31\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 3 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n41\n7\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 7\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n0000000000 1000000000 1000000000 1000000000\n", "output": ["27\n41\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 1\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["18\n41\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 4 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 2 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["27\n41\n7\n3000010000\n"]}, {"input": "4\n5 1\n1 0 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["21\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 4 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n29\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 1\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n43\n25\n7000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n1 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n43\n23\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 12 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n48\n25\n3000010000\n"]}, {"input": "4\n5 1\n0 1 3 4 3\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["18\n40\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 0 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 9 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n48\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["18\n50\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 0\n9 3\n-9 -12 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["14\n40\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 2 6 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["30\n41\n7\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 4 4\n5 3\n2 2 5 6 3\n4 2\n0000000000 1000000000 1000000000 1000000000\n", "output": ["25\n39\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -23 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n49\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 4\n-5 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n42\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 16 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["38\n41\n10\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-14 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000001 1000000000\n", "output": ["25\n44\n9\n3000000001\n"]}, {"input": "4\n5 1\n0 3 3 4 5\n9 3\n-9 -18 -15 6 5 3 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n40\n9\n3000000000\n"]}, {"input": "4\n5 1\n-1 2 3 4 5\n9 3\n-5 -10 -15 9 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n47\n25\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 2 10 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n28\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 0\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["18\n46\n9\n3001000000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -1 6 6 8 3 7 4\n5 5\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n5\n3000000000\n"]}, {"input": "4\n5 1\n1 2 1 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["21\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 0 3 4 1\n9 3\n-9 -18 -15 5 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["14\n44\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 3 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n49\n7\n3000010100\n"]}, {"input": "4\n5 2\n2 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000001000 1000000000 1000000000 1000010000\n", "output": ["15\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n2 2 3 7 5\n9 3\n-5 -10 -15 6 2 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["31\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 0 3 4 9\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n44\n11\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 0000000000 1000110000\n", "output": ["30\n41\n13\n1000110000\n"]}, {"input": "4\n5 1\n1 2 3 2 2\n9 3\n-14 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["17\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 7\n5 1\n2 3 3 0 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n45\n19\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n4 2 3 5 3\n4 3\n1000000000 1000001000 1000000000 1000010000\n", "output": ["23\n43\n29\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 6\n1 2 5 0 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n5\n3000000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 14 8 3 7 0\n5 1\n2 2 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n50\n23\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 0 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["25\n42\n10\n3000000001\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 0 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000001000 1000000000 1001000000 1000010000\n", "output": ["13\n39\n8\n3001000000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -9 6 2 8 3 0 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n32\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 5\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n44\n5\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 2\n-5 -10 -15 6 5 8 3 7 5\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000010000 1000010000\n", "output": ["25\n63\n9\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1001000000 1000000000 1000110000\n", "output": ["30\n45\n13\n3001000000\n"]}, {"input": "4\n5 1\n1 2 6 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000100000 1000000000 1000000000\n", "output": ["30\n41\n9\n3000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 4 8 3 12 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n47\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1010010000\n", "output": ["25\n57\n27\n3010010000\n"]}, {"input": "4\n5 1\n1 3 3 8 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010000000 1000000000\n", "output": ["32\n46\n7\n3010000000\n"]}, {"input": "4\n5 1\n0 2 3 6 5\n9 3\n-5 -10 -12 6 7 8 3 7 0\n5 1\n2 4 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["26\n40\n27\n3000010000\n"]}, {"input": "4\n5 2\n1 2 4 4 5\n9 3\n-5 -10 -15 6 -1 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["15\n39\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 7 0\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 2 3 8 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["19\n37\n12\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 2\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000010 1000000000\n", "output": ["29\n44\n15\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 6\n9 3\n-5 -10 -15 6 5 8 3 7 5\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000010000 1001010000\n", "output": ["26\n41\n9\n3001010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 4\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1010110000\n", "output": ["30\n43\n13\n3010110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 8\n5 3\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n43\n9\n7000100000\n"]}, {"input": "4\n5 1\n1 2 3 7 2\n9 3\n-14 -18 -13 6 5 8 3 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000100000 1000000000 1000000000 1000010000\n", "output": ["25\n57\n27\n1000100000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 1 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010010000 1000000000\n", "output": ["27\n44\n7\n3010010000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 5 3 2\n4 4\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n46\n7\n1001000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -6 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1010100000\n", "output": ["16\n35\n8\n3010100000\n"]}, {"input": "4\n5 2\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["7\n44\n8\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 2\n-5 -10 -25 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n73\n8\n3000010100\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -18 -15 6 5 1 3 12 4\n5 1\n2 0 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n50\n21\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 6\n4 5\n1000000000 1000000000 1000000010 1000010000\n", "output": ["25\n57\n32\n1000010000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -26 6 6 8 3 7 4\n5 3\n1 1 8 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n54\n10\n3001000000\n"]}, {"input": "4\n5 1\n2 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1001000000 1000000000 1010100000\n", "output": ["18\n44\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -14 -6 6 6 7 3 9 3\n5 3\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n44\n11\n7000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["13\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 2 1 8 3 7 4\n5 4\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n37\n9\n7000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 1 3 12 4\n5 1\n1 0 3 5 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n47\n19\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 6\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n57\n32\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000100001 1000000000 1000000000 1000010100\n", "output": ["25\n48\n8\n3000100001\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 1\n-7 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n139\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 0 3 4 1\n9 3\n-9 -10 -6 6 6 7 3 9 3\n5 2\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["14\n40\n17\n7000000010\n"]}, {"input": "4\n5 1\n0 2 3 4 10\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000010100\n", "output": ["28\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 4\n-5 -6 -15 10 5 8 4 0 0\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n35\n13\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 0\n9 6\n-14 -18 -13 6 2 8 6 11 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n40\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 1\n-5 -10 -20 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["25\n140\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 4 10\n9 5\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000000100\n", "output": ["30\n40\n8\n3000000100\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 1\n-2 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["23\n129\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -6 -15 10 5 8 4 0 4\n5 3\n2 7 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000111000\n", "output": ["27\n43\n13\n1000111000\n"]}, {"input": "4\n5 2\n0 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["11\n135\n31\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -4 -15 10 3 8 4 0 4\n5 3\n2 7 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000110000\n", "output": ["27\n41\n13\n1000110000\n"]}, {"input": "4\n5 1\n0 0 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 4 7\n5 1\n4 3 3 5 1\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["19\n115\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 5 4\n5 3\n2 2 5 3 3\n4 2\n1000001000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n9\n3000001000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 3 8 0 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["20\n41\n10\n3000010000\n"]}], "task_id": "codecontest/47", "repair_prompt": ["A total of n depots are positioned on a number line. There is a number line along which the depots are situated. Depot i lies at the point x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots. You and the n bags are initially at the origin 0. You can carry up to k bags at a time. You must collect the required number of goods from the origin, deliver them to the respective depots, and then return to the origin to collect your next batch of goods.\n\nCalculate the minimum distance you need to cover to deliver all the bags of goods to the depots. You do not have to return to the origin after you have delivered all the bags. Account for both the number of bags you can carry and the positions of the depots while determining the optimal delivery strategy.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "A total of n depots are positioned on a number line. There is a number line along which the depots are situated. The depots are located at distinct points on the number line. Depot i lies at the point x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots. You and the n bags are initially at the origin 0. You can carry up to k bags at a time. You must collect the required number of goods from the origin, deliver them to the respective depots, and then return to the origin to collect your next batch of goods.\n\nCalculate the minimum distance you need to cover to deliver all the bags of goods to the depots. You do not have to return to the origin after you have delivered all the bags. Account for both the number of bags you can carry and the positions of the depots while determining the optimal delivery strategy.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "A total of n depots are positioned on a number line, and depot i lies at the point x_i for 1 \u2264 i \u2264 n. You are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots. You and the n bags are initially at the origin 0. You can carry up to k bags at a time. You must collect the required number of goods from the origin, deliver them to the respective depots, and then return to the origin to collect your next batch of goods.\n\nCalculate the minimum distance you need to cover to deliver all the bags of goods to the depots. You do not have to return to the origin after you have delivered all the bags. Account for both the number of bags you can carry and the positions of the depots while determining the optimal delivery strategy.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        # Separate positive and negative positions\n        positive_positions = [x for x in positions if x > 0]\n        negative_positions = [-x for x in positions if x < 0]\n        \n        # Sort positions in descending order\n        positive_positions.sort(reverse=True)\n        negative_positions.sort(reverse=True)\n        \n        # Function to calculate distance for a list of positions\n        def calculate_distance(positions):\n            distance = 0\n            for i in range(0, len(positions), k):\n                distance += 2 * positions[i]\n            return distance\n        \n        # Calculate total distance\n        total_distance = calculate_distance(positive_positions) + calculate_distance(negative_positions)\n        \n        # Subtract the farthest position as we don't need to return to origin after last delivery\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= negative_positions[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = sorted([x for x in positions if x > 0], reverse=True)\n        negative_positions = sorted([-x for x in positions if x < 0], reverse=True)\n        \n        def calculate_distance(positions):\n            distance = 0\n            for i in range(0, len(positions), k):\n                distance += 2 * positions[i]\n            return distance\n        \n        positive_distance = calculate_distance(positive_positions)\n        negative_distance = calculate_distance(negative_positions)\n        \n        # The last trip does not require returning to the origin\n        if positive_positions and negative_positions:\n            min_distance = positive_distance + negative_distance - max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            min_distance = positive_distance - positive_positions[0]\n        elif negative_positions:\n            min_distance = negative_distance - negative_positions[0]\n        else:\n            min_distance = 0\n        \n        results.append(min_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = sorted([x for x in positions if x > 0], reverse=True)\n        negative_positions = sorted([x for x in positions if x < 0])\n        \n        def calculate_distance(positions):\n            distance = 0\n            for i in range(0, len(positions), k):\n                distance += 2 * abs(positions[i])\n            return distance\n        \n        positive_distance = calculate_distance(positive_positions)\n        negative_distance = calculate_distance(negative_positions)\n        \n        # Subtract the distance of the last trip (no need to return to origin)\n        if positive_positions and negative_positions:\n            last_trip_distance = min(abs(positive_positions[0]), abs(negative_positions[0]))\n        elif positive_positions:\n            last_trip_distance = abs(positive_positions[0])\n        elif negative_positions:\n            last_trip_distance = abs(negative_positions[0])\n        else:\n            last_trip_distance = 0\n        \n        total_distance = positive_distance + negative_distance - last_trip_distance\n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = [x for x in positions if x > 0]\n        negative_positions = [-x for x in positions if x < 0]\n        \n        positive_positions.sort(reverse=True)\n        negative_positions.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive positions\n        for i in range(0, len(positive_positions), k):\n            total_distance += 2 * positive_positions[i]\n        \n        # Calculate distance for negative positions\n        for i in range(0, len(negative_positions), k):\n            total_distance += 2 * negative_positions[i]\n        \n        # Subtract the maximum distance as we don't need to return to origin after last delivery\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= negative_positions[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = sorted([x for x in positions if x > 0], reverse=True)\n        negative_positions = sorted([-x for x in positions if x < 0], reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive positions\n        for i in range(0, len(positive_positions), k):\n            total_distance += 2 * positive_positions[i]\n        \n        # Calculate distance for negative positions\n        for i in range(0, len(negative_positions), k):\n            total_distance += 2 * negative_positions[i]\n        \n        # Subtract the last trip back to origin\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= negative_positions[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = []\n        negative_positions = []\n        \n        # Separate positions into positive and negative\n        for pos in positions:\n            if pos > 0:\n                positive_positions.append(pos)\n            elif pos < 0:\n                negative_positions.append(-pos)  # Store negative positions as positive for easier handling\n        \n        # Sort positions in descending order\n        positive_positions.sort(reverse=True)\n        negative_positions.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive positions\n        for i in range(0, len(positive_positions), k):\n            total_distance += 2 * positive_positions[i]\n        \n        # Calculate distance for negative positions\n        for i in range(0, len(negative_positions), k):\n            total_distance += 2 * negative_positions[i]\n        \n        # Subtract the farthest trip as we don't need to return to origin\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= negative_positions[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        # Separate positive and negative depot positions\n        positive = sorted([x for x in depots if x > 0], reverse=True)\n        negative = sorted([-x for x in depots if x < 0], reverse=True)\n        \n        def calculate_distance(positions):\n            distance = 0\n            for i in range(0, len(positions), k):\n                distance += 2 * positions[i]\n            return distance\n        \n        # Calculate total minimum distance\n        total_distance = calculate_distance(positive) + calculate_distance(negative)\n        \n        # Subtract the distance of the farthest depot (no need to return to origin)\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = sorted([x for x in positions if x > 0], reverse=True)\n        negative_positions = sorted([x for x in positions if x < 0])\n        \n        def calculate_distance(positions):\n            distance = 0\n            for i in range(0, len(positions), k):\n                distance += 2 * abs(positions[i])\n            return distance\n        \n        positive_distance = calculate_distance(positive_positions)\n        negative_distance = calculate_distance(negative_positions)\n        \n        # Subtract the maximum of the farthest positive or negative position\n        if positive_positions and negative_positions:\n            max_distance = max(abs(positive_positions[0]), abs(negative_positions[0]))\n        elif positive_positions:\n            max_distance = abs(positive_positions[0])\n        elif negative_positions:\n            max_distance = abs(negative_positions[0])\n        else:\n            max_distance = 0\n        \n        total_distance = positive_distance + negative_distance - max_distance\n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n, k = int(data[index]), int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = sorted([x for x in positions if x > 0], reverse=True)\n        negative_positions = sorted([-x for x in positions if x < 0], reverse=True)\n        \n        def calculate_distance(positions):\n            distance = 0\n            for i in range(0, len(positions), k):\n                distance += 2 * positions[i]\n            return distance\n        \n        positive_distance = calculate_distance(positive_positions)\n        negative_distance = calculate_distance(negative_positions)\n        \n        # Subtract the maximum absolute value of the farthest depot to avoid unnecessary return\n        max_distance = 0\n        if positive_positions:\n            max_distance = max(max_distance, positive_positions[0])\n        if negative_positions:\n            max_distance = max(max_distance, negative_positions[0])\n        \n        total_distance = positive_distance + negative_distance - max_distance\n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive_depots = sorted([x for x in depots if x > 0], reverse=True)\n        negative_depots = sorted([-x for x in depots if x < 0], reverse=True)\n        \n        def calculate_distance(depot_list):\n            distance = 0\n            for i in range(0, len(depot_list), k):\n                distance += 2 * depot_list[i]\n            return distance\n        \n        positive_distance = calculate_distance(positive_depots)\n        negative_distance = calculate_distance(negative_depots)\n        \n        # Subtract the last trip back to origin for the farthest depot\n        if positive_depots and negative_depots:\n            results.append(positive_distance + negative_distance - max(positive_depots[0], negative_depots[0]))\n        elif positive_depots:\n            results.append(positive_distance - positive_depots[0])\n        elif negative_depots:\n            results.append(negative_distance - negative_depots[0])\n        else:\n            results.append(0)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        # Separate positive and negative positions\n        positive_positions = [x for x in positions if x > 0]\n        negative_positions = [-x for x in positions if x < 0]\n        \n        # Sort positions in descending order\n        positive_positions.sort(reverse=True)\n        negative_positions.sort(reverse=True)\n        \n        # Function to calculate distance for a list of positions\n        def calculate_distance(positions):\n            distance = 0\n            for i in range(0, len(positions), k):\n                distance += 2 * positions[i]\n            return distance\n        \n        # Calculate total distance\n        total_distance = calculate_distance(positive_positions) + calculate_distance(negative_positions)\n        \n        # Subtract the farthest position as we don't need to return to origin after last delivery\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= negative_positions[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of depots, the maximum number of bags that can be carried at once, and the positions of the depots.\",\n      \"output\": \"A structured representation of the input data for further processing.\"\n    },\n    {\n      \"description\": \"For each test case, separate the depot positions into positive and negative coordinates, as they represent different directions on the number line.\",\n      \"output\": \"Two lists of depot positions: one for positive coordinates and one for negative coordinates.\"\n    },\n    {\n      \"description\": \"For each list of depot positions (positive and negative), calculate the minimum distance required to deliver the bags by grouping the positions into batches of size k and determining the optimal delivery strategy.\",\n      \"output\": \"The minimum distance required for each direction (positive and negative) for a single test case.\"\n    },\n    {\n      \"description\": \"Combine the distances calculated for positive and negative directions to determine the total minimum distance for each test case.\",\n      \"output\": \"The total minimum distance for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, split the depot positions into positive and negative lists.\",\n    \"Sort each list of depot positions in descending order of their absolute values.\",\n    \"For each sorted list, iterate over the positions in batches of size k, calculating the distance for each batch as twice the farthest position in the batch (to account for the return trip to the origin).\",\n    \"Sum the distances for all batches in both positive and negative directions, subtracting the distance of the farthest position (since the final trip does not require a return to the origin).\",\n    \"Output the total minimum distance for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'number line'\n    Explanation: A number line is a straight line on which every point corresponds to a real number. In this problem, depots are positioned on this line, and the salesman must travel along it to deliver goods.\n\n    'minimum distance'\n    Explanation: The goal is to calculate the shortest possible distance the salesman needs to travel to deliver all goods to the depots, considering the constraints of carrying capacity and depot positions.\n\n# [phrase showing quantity relationship]\n    'at a time': Refers to the maximum number of bags (k) that can be carried in one trip.\n    Implementation: This is used to determine how many depot positions can be grouped together for a single trip.\n\n# [degree adverb]\n    'minimum': Refers to the smallest possible total distance traveled.\n    Implementation: This involves optimizing the delivery strategy to ensure the least amount of travel, which can be achieved by sorting and batching depot positions.\n\n# [code logic]\n    The steps of splitting depot positions into positive and negative lists, sorting them, and calculating distances for each batch should be implemented simultaneously for both directions (positive and negative). This can be done in a loop that processes each test case independently.\n\n# [edge case]\n    1. n = 1, k = 1, x = [0] = 0\n       Explanation: The depot is at the origin, so no travel is needed. The expected output is 0.\n    2. n = 5, k = 5, x = [1, 2, 3, 4, 5] = 5\n       Explanation: All bags can be delivered in one trip to the farthest depot at position 5, with no return needed. The expected output is 5.\n    3. n = 3, k = 1, x = [-1, -2, -3] = 6\n       Explanation: Each bag must be delivered individually, with a return to the origin after each delivery. The expected output is 6.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and batching based on the maximum number of bags (k) and calculating the distance should naturally handle these cases.\n\nNO", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        # Separate positive and negative positions\n        positive_positions = [x for x in positions if x > 0]\n        negative_positions = [-x for x in positions if x < 0]\n        \n        # Sort positions in descending order\n        positive_positions.sort(reverse=True)\n        negative_positions.sort(reverse=True)\n        \n        # Function to calculate distance for a list of positions\n        def calculate_distance(positions):\n            distance = 0\n            for i in range(0, len(positions), k):\n                distance += 2 * positions[i]\n            return distance\n        \n        # Calculate total distance\n        total_distance = calculate_distance(positive_positions) + calculate_distance(negative_positions)\n        \n        # Subtract the farthest position as we don't need to return to origin after last delivery\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= negative_positions[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of depots, the maximum number of bags that can be carried at once, and the positions of the depots.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the integers n and k.\",\n        \"Read the list of depot positions.\"\n      ]\n    },\n    {\n      \"description\": \"Separate the depot positions into positive and negative coordinates to handle them independently.\",\n      \"steps\": [\n        \"Split the list of depot positions into two lists: one for positive positions and one for negative positions.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering bags to depots located at positive positions.\",\n      \"steps\": [\n        \"Sort the positive positions in descending order.\",\n        \"Group the positions into batches of size k.\",\n        \"For each batch, calculate the round trip distance from the origin to the furthest depot in the batch and back to the origin.\",\n        \"Sum the distances for all batches.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering bags to depots located at negative positions.\",\n      \"steps\": [\n        \"Sort the negative positions in ascending order (considering their absolute values).\",\n        \"Group the positions into batches of size k.\",\n        \"For each batch, calculate the round trip distance from the origin to the furthest depot in the batch and back to the origin.\",\n        \"Sum the distances for all batches.\"\n      ]\n    },\n    {\n      \"description\": \"Combine the distances from positive and negative depot deliveries to get the total minimum distance for each test case.\",\n      \"steps\": [\n        \"Add the total distance for positive positions and the total distance for negative positions.\",\n        \"Output the combined distance for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and depot positions.\",\n    \"Separate depot positions into positive and negative lists.\",\n    \"Calculate the minimum delivery distance for positive depot positions.\",\n    \"Calculate the minimum delivery distance for negative depot positions.\",\n    \"Combine the distances from positive and negative deliveries for each test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'number line'\n    Explanation: A number line is a straight line on which every point corresponds to a real number. In this problem, depots are positioned on this line, and the salesman must travel along it to deliver goods.\n\n    'origin'\n    Explanation: The origin is the starting point (0 on the number line) where the salesman begins and returns to collect more bags.\n\n    'minimum distance'\n    Explanation: The shortest possible total distance the salesman must travel to deliver all bags to the depots.\n\n# [phrase showing quantity relationship]\n    'up to k bags'\n    Explanation: The salesman can carry a maximum of k bags at a time. This affects how many trips are needed to deliver all bags.\n    Implementation: Use a loop to handle batches of k bags.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the smallest total distance traveled.\n    Implementation: Calculate distances for different strategies and choose the smallest.\n\n# [code logic]\n    The steps for calculating the minimum distance for positive and negative depot positions can be implemented simultaneously in separate functions or code blocks. This is because they are independent of each other and can be processed in parallel.\n\n# [edge case]\n    1. n = 1, k = 1, x = [0] = 0\n    Explanation: The depot is at the origin, so no travel is needed. The expected output is 0.\n\n    2. n = 5, k = 5, x = [1, 2, 3, 4, 5] = 5\n    Explanation: All bags can be delivered in one trip since k equals n. The furthest depot is at 5, so the total distance is 5.\n\n    3. n = 3, k = 1, x = [-1, -2, -3] = 12\n    Explanation: Each bag must be delivered individually. The total distance is 2*(1 + 2 + 3) = 12.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting, batching, and calculating round trips will naturally handle these scenarios. \n\nNO", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = sorted([x for x in positions if x > 0], reverse=True)\n        negative_positions = sorted([-x for x in positions if x < 0], reverse=True)\n        \n        def calculate_distance(positions):\n            distance = 0\n            for i in range(0, len(positions), k):\n                distance += 2 * positions[i]\n            return distance\n        \n        positive_distance = calculate_distance(positive_positions)\n        negative_distance = calculate_distance(negative_positions)\n        \n        # The last trip does not require returning to the origin\n        if positive_positions and negative_positions:\n            min_distance = positive_distance + negative_distance - max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            min_distance = positive_distance - positive_positions[0]\n        elif negative_positions:\n            min_distance = negative_distance - negative_positions[0]\n        else:\n            min_distance = 0\n        \n        results.append(min_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of depots, the maximum number of bags that can be carried at once, and the positions of the depots.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the integers n and k.\",\n        \"Read the list of depot positions.\"\n      ]\n    },\n    {\n      \"description\": \"Separate the depot positions into positive and negative coordinates to handle them independently.\",\n      \"steps\": [\n        \"Filter the depot positions into two lists: one for positive positions and one for negative positions.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering bags to depots located at positive positions.\",\n      \"steps\": [\n        \"Sort the positive positions in descending order.\",\n        \"Group the positions into batches of size k.\",\n        \"For each batch, calculate the round trip distance from the origin to the farthest depot in the batch and back.\",\n        \"Sum the distances for all batches.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering bags to depots located at negative positions.\",\n      \"steps\": [\n        \"Sort the negative positions in ascending order (more negative first).\",\n        \"Group the positions into batches of size k.\",\n        \"For each batch, calculate the round trip distance from the origin to the farthest depot in the batch and back.\",\n        \"Sum the distances for all batches.\"\n      ]\n    },\n    {\n      \"description\": \"Combine the distances from positive and negative depot deliveries to get the total minimum distance for each test case.\",\n      \"steps\": [\n        \"Add the total distance from positive depot deliveries to the total distance from negative depot deliveries.\",\n        \"Subtract the distance of the last trip (since no return to origin is needed after the final delivery).\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and depot information.\",\n    \"For each test case, separate depot positions into positive and negative lists.\",\n    \"Calculate the minimum delivery distance for positive depot positions.\",\n    \"Calculate the minimum delivery distance for negative depot positions.\",\n    \"Combine the distances from positive and negative deliveries, adjusting for the final trip.\",\n    \"Output the minimum distance for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'number line': A one-dimensional line where each point corresponds to a real number. Depots are positioned on this line.\n    'origin': The starting point (0) on the number line where the salesman begins and returns to collect bags.\n    'minimum distance': The shortest possible total distance the salesman needs to travel to deliver all bags to the depots.\n\n# [phrase showing quantity relationship]\n    'up to k bags': The salesman can carry a maximum of k bags at a time. This means the salesman can carry between 1 and k bags per trip.\n    'n depots': There are n distinct depots, each requiring one bag of goods.\n\n# [degree adverb]\n    'minimum': Refers to the smallest possible total distance traveled. This requires optimizing the delivery strategy to reduce travel distance.\n\n# [code logic]\n    The steps for calculating the minimum distance for positive and negative depot positions can be implemented simultaneously in separate code blocks. However, they should be combined in the final step to calculate the total minimum distance.\n\n# [edge case]\n    Test case with all depots at the same position:\n    Input: 3 2\n           5 5 5\n    Expected output: 10\n    Explanation: The salesman can carry 2 bags to position 5, return to origin, and then carry the last bag to position 5, totaling 10 units of distance.\n\n    Test case with depots at extreme positions:\n    Input: 2 1\n           -1000000000 1000000000\n    Expected output: 3000000000\n    Explanation: The salesman must travel to each extreme position separately, totaling 3000000000 units of distance.\n\n    Test case with k equal to n:\n    Input: 4 4\n           1 2 3 4\n    Expected output: 4\n    Explanation: The salesman can carry all bags in one trip to the farthest depot at position 4, totaling 4 units of distance.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of grouping positions into batches and calculating round trip distances inherently handles these scenarios.\n\nNO", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = sorted([x for x in positions if x > 0], reverse=True)\n        negative_positions = sorted([x for x in positions if x < 0])\n        \n        def calculate_distance(positions):\n            distance = 0\n            for i in range(0, len(positions), k):\n                distance += 2 * abs(positions[i])\n            return distance\n        \n        positive_distance = calculate_distance(positive_positions)\n        negative_distance = calculate_distance(negative_positions)\n        \n        # Subtract the distance of the last trip (no need to return to origin)\n        if positive_positions and negative_positions:\n            last_trip_distance = min(abs(positive_positions[0]), abs(negative_positions[0]))\n        elif positive_positions:\n            last_trip_distance = abs(positive_positions[0])\n        elif negative_positions:\n            last_trip_distance = abs(negative_positions[0])\n        else:\n            last_trip_distance = 0\n        \n        total_distance = positive_distance + negative_distance - last_trip_distance\n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of depots (n), the maximum number of bags that can be carried at once (k), and the positions of the depots.\",\n      \"steps\": [\n        \"Read the number of test cases (t).\",\n        \"For each test case, read the integers n and k.\",\n        \"Read the list of integers representing the positions of the depots.\"\n      ]\n    },\n    {\n      \"description\": \"Separate the depot positions into positive and negative coordinates to handle them independently.\",\n      \"steps\": [\n        \"Iterate through the list of depot positions.\",\n        \"Separate the positions into two lists: one for positive positions and one for negative positions.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance required to deliver all bags to the depots for each test case.\",\n      \"steps\": [\n        \"Sort the positive and negative positions in descending order of absolute value.\",\n        \"For each list, calculate the total distance by grouping the positions into batches of size k.\",\n        \"For each batch, calculate the round trip distance from the origin to the furthest position in the batch and back.\",\n        \"Sum the distances for all batches, ensuring the last batch does not require a return trip to the origin.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum distance for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum distance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, separate the depot positions into positive and negative lists.\",\n    \"Sort the positions in each list by absolute value in descending order.\",\n    \"Calculate the minimum delivery distance by batching the positions into groups of size k and summing the round trip distances.\",\n    \"Output the minimum distance for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'depot', 'origin', 'minimum distance', 'carry up to k bags'\n    Explanation: \n    - 'depot': A location on the number line where a bag needs to be delivered.\n    - 'origin': The starting point (0) where the salesman begins and returns to collect more bags.\n    - 'minimum distance': The shortest total distance the salesman needs to travel to deliver all bags.\n    - 'carry up to k bags': The maximum number of bags the salesman can carry in one trip.\n\n# [phrase showing quantity relationship]\n    'up to k bags': The salesman can carry a maximum of k bags in one trip.\n    Implementation: This can be implemented by grouping the depot positions into batches of size k.\n\n# [degree adverb] \n    'minimum': The goal is to find the smallest possible total distance.\n    Implementation: This involves optimizing the delivery route to minimize the total travel distance.\n\n# [code logic]\n    The steps in the plan related to sorting and calculating distances for positive and negative positions should be considered simultaneously. Specifically:\n    - \"Sort the positive and negative positions in descending order of absolute value.\"\n    - \"For each list, calculate the total distance by grouping the positions into batches of size k.\"\n    These steps can be implemented in a single loop that processes both positive and negative positions.\n\n# [edge case] \n    1. n = 1, k = 1, positions = [0] = 0\n       Explanation: No travel is needed as the depot is at the origin.\n    2. n = 1, k = 1, positions = [10^9] = 10^9\n       Explanation: Only one trip is needed to the farthest point, no return trip required.\n    3. n = 2, k = 2, positions = [-10^9, 10^9] = 10^9\n       Explanation: Both depots can be visited in one trip, no return trip required.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and batching by k already accounts for these scenarios.\n\nNO", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = [x for x in positions if x > 0]\n        negative_positions = [-x for x in positions if x < 0]\n        \n        positive_positions.sort(reverse=True)\n        negative_positions.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive positions\n        for i in range(0, len(positive_positions), k):\n            total_distance += 2 * positive_positions[i]\n        \n        # Calculate distance for negative positions\n        for i in range(0, len(negative_positions), k):\n            total_distance += 2 * negative_positions[i]\n        \n        # Subtract the maximum distance as we don't need to return to origin after last delivery\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= negative_positions[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the values of n, k, and the list of depot positions.\",\n      \"steps\": [\n        \"Read the number of test cases t.\",\n        \"For each test case, read the integers n and k.\",\n        \"Read the list of depot positions x_i.\"\n      ]\n    },\n    {\n      \"description\": \"Separate depot positions into positive and negative lists to handle them independently.\",\n      \"steps\": [\n        \"Initialize two lists: one for positive depot positions and one for negative depot positions.\",\n        \"Iterate through the list of depot positions and append each position to the appropriate list based on its sign.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots on the positive side of the number line.\",\n      \"steps\": [\n        \"Sort the positive depot positions in descending order.\",\n        \"Iterate over the sorted list in steps of k, calculating the round-trip distance for each batch of k depots.\",\n        \"Sum the distances, ensuring the last trip does not return to the origin.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots on the negative side of the number line.\",\n      \"steps\": [\n        \"Sort the negative depot positions in ascending order (more negative first).\",\n        \"Iterate over the sorted list in steps of k, calculating the round-trip distance for each batch of k depots.\",\n        \"Sum the distances, ensuring the last trip does not return to the origin.\"\n      ]\n    },\n    {\n      \"description\": \"Combine the distances from both positive and negative depot deliveries to get the total minimum distance for each test case.\",\n      \"steps\": [\n        \"Add the total distances calculated for positive and negative depot deliveries.\",\n        \"Store the result for each test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all test cases.\",\n      \"steps\": [\n        \"Print the minimum distance for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and depot positions.\",\n    \"Separate depot positions into positive and negative lists.\",\n    \"Calculate the minimum delivery distance for positive depot positions.\",\n    \"Calculate the minimum delivery distance for negative depot positions.\",\n    \"Combine distances from positive and negative deliveries.\",\n    \"\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'depot': A location on the number line where goods need to be delivered.\n    'origin': The starting point (0) where the salesman begins and returns to collect goods.\n    'minimum distance': The shortest total distance the salesman needs to travel to deliver all goods.\n\n# [phrase showing quantity relationship]\n    'up to k bags': The salesman can carry a maximum of k bags at a time.\n    'n depots': There are n locations to deliver goods to.\n    Implementation: Use a loop to handle deliveries in batches of k.\n\n# [degree adverb]\n    'minimum': Refers to the smallest possible total distance traveled.\n    Implementation: Optimize the delivery route to minimize the total distance.\n\n# [code logic]\n    Steps 3 and 4 (calculating distances for positive and negative depot positions) can be implemented simultaneously in separate loops, as they are independent of each other. This can be done by iterating over the positive and negative lists in parallel, if needed.\n\n# [edge case]\n    1. n = 1, k = 1, x = [0] = 0\n       Explanation: The depot is at the origin, so no travel is needed.\n    2. n = 5, k = 5, x = [1, 2, 3, 4, 5] = 5\n       Explanation: All depots can be reached in one trip, so the distance is the farthest depot.\n    3. n = 3, k = 1, x = [-1, -2, -3] = 12\n       Explanation: Each depot requires a separate trip, and the total distance is the sum of all round trips.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and iterating over the depot positions in batches of k will naturally handle these cases. \n\nNO", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = sorted([x for x in positions if x > 0], reverse=True)\n        negative_positions = sorted([-x for x in positions if x < 0], reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive positions\n        for i in range(0, len(positive_positions), k):\n            total_distance += 2 * positive_positions[i]\n        \n        # Calculate distance for negative positions\n        for i in range(0, len(negative_positions), k):\n            total_distance += 2 * negative_positions[i]\n        \n        # Subtract the last trip back to origin\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= negative_positions[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 94)"}, "Round_1": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = sorted([x for x in positions if x > 0], reverse=True)\n        negative_positions = sorted([-x for x in positions if x < 0], reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive positions\n        for i in range(0, len(positive_positions), k):\n            total_distance += 2 * positive_positions[i]\n        \n        # Calculate distance for negative positions\n        for i in range(0, len(negative_positions), k):\n            total_distance += 2 * negative_positions[i]\n        \n        # Subtract the last trip back to origin\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= negative_positions[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of depots, the maximum number of bags that can be carried at once, and the positions of the depots.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the integers n and k.\",\n        \"Read the list of depot positions.\"\n      ]\n    },\n    {\n      \"description\": \"Separate the depot positions into positive and negative coordinates for easier handling of distances.\",\n      \"steps\": [\n        \"Iterate through the list of depot positions.\",\n        \"Separate the positions into two lists: one for positive positions and one for negative positions.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance required to deliver all bags for each test case.\",\n      \"steps\": [\n        \"Sort the positive and negative position lists in descending order of absolute values.\",\n        \"For each list, calculate the total distance by grouping the positions into batches of size k.\",\n        \"For each batch, calculate the round trip distance to the farthest depot in the batch and back to the origin, except for the last trip where returning to the origin is not necessary.\",\n        \"Sum the distances for both positive and negative positions.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum distance for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum distance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, separate the depot positions into positive and negative coordinates.\",\n    \"Sort the positive and negative positions by absolute value in descending order.\",\n    \"Calculate the minimum distance by batching the positions into groups of size k and summing the necessary distances.\",\n    \"Output the minimum distance for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'number line'\n    Explanation: The depots are positioned along a number line, which means their positions can be represented as integers, both positive and negative, indicating their distance from the origin.\n\n    'origin'\n    Explanation: The starting point for the salesman, where all bags are initially located, and where the salesman returns to collect more bags.\n\n    'minimum distance'\n    Explanation: The goal is to calculate the shortest possible total distance the salesman needs to travel to deliver all bags to the depots.\n\n# [phrase showing quantity relationship]\n    'up to k bags'\n    Explanation: The salesman can carry a maximum of k bags at a time, which affects how the trips are planned and the total distance calculated.\n    Implementation: This can be implemented by grouping depot positions into batches of size k.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The requirement is to find the smallest possible total distance for delivering all bags.\n    Implementation: This involves optimizing the delivery strategy to minimize the total travel distance.\n\n# [code logic]\n    The steps for sorting and calculating distances for positive and negative positions should be considered simultaneously.\n    Explanation: Sorting both positive and negative positions and calculating distances can be done in parallel to optimize the delivery strategy.\n\n# [edge case]\n    Case 1: n = 1, k = 1, positions = [0]\n    Expected output: 0\n    Explanation: No travel is needed as the depot is at the origin.\n\n    Case 2: n = 1, k = 1, positions = [1000000000]\n    Expected output: 1000000000\n    Explanation: Only one trip is needed to deliver the bag to the farthest depot.\n\n    Case 3: n = 2, k = 2, positions = [-1000000000, 1000000000]\n    Expected output: 2000000000\n    Explanation: The salesman can carry both bags in one trip, visiting both depots without returning to the origin.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of batching and calculating distances will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = []\n        negative_positions = []\n        \n        # Separate positions into positive and negative\n        for pos in positions:\n            if pos > 0:\n                positive_positions.append(pos)\n            elif pos < 0:\n                negative_positions.append(-pos)  # Store negative positions as positive for easier handling\n        \n        # Sort positions in descending order\n        positive_positions.sort(reverse=True)\n        negative_positions.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive positions\n        for i in range(0, len(positive_positions), k):\n            total_distance += 2 * positive_positions[i]\n        \n        # Calculate distance for negative positions\n        for i in range(0, len(negative_positions), k):\n            total_distance += 2 * negative_positions[i]\n        \n        # Subtract the farthest trip as we don't need to return to origin\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= negative_positions[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of depots, the maximum number of bags that can be carried at once, and the positions of the depots.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"Separate the depot positions into positive and negative coordinates to handle them independently, as the strategy for minimizing distance can differ based on the direction.\",\n      \"output\": \"Two lists for each test case: one for positive depot positions and one for negative depot positions.\"\n    },\n    {\n      \"description\": \"For each list of depot positions (positive and negative), calculate the minimum distance required to deliver the bags by grouping the depots into batches of size k and determining the optimal delivery sequence.\",\n      \"output\": \"The minimum distance required for delivering bags to all depots in one direction (positive or negative).\"\n    },\n    {\n      \"description\": \"Combine the results from both positive and negative directions to get the total minimum distance for each test case.\",\n      \"output\": \"The total minimum distance for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, separate the depot positions into positive and negative lists.\",\n    \"Sort each list of depot positions in descending order of absolute values.\",\n    \"For each sorted list, iterate over the positions in steps of size k, calculating the round-trip distance for each batch and summing these distances.\",\n    \"Subtract the distance of the farthest depot from the total distance, as the final trip does not require a return to the origin.\",\n    \"Sum the minimum distances from both positive and negative directions to get the total minimum distance for each test case.\",\n    \"Output the total minimum distance for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'number line': A linear representation where depots are positioned at specific integer coordinates.\n    'origin': The starting point (0) from which the salesman begins and returns after each delivery batch.\n    'minimum distance': The shortest possible total distance the salesman must travel to deliver all bags.\n\n# [phrase showing quantity relationship]\n    'up to k bags': Indicates the maximum number of bags the salesman can carry in one trip. In code, this means grouping depot positions into batches of size k.\n    'sum of n over all test cases does not exceed 2 \u22c5 10^5': Ensures that the total number of depots across all test cases is within computational limits.\n\n# [degree adverb]\n    'minimum': Refers to the smallest possible total distance traveled. In code, this involves optimizing the delivery sequence to reduce travel distance.\n\n# [code logic]\n    The steps for handling positive and negative depot positions should be implemented simultaneously, as they are independent and can be processed in parallel. This can be done by creating separate functions or loops for positive and negative positions and combining their results.\n\n# [edge case]\n    Test case with all depots at the same position: \n    Input: 3 2\n           5 5 5\n    Expected output: 10\n    Explanation: The salesman makes two trips: 0 \u2192 5 \u2192 0 \u2192 5 \u2192 0 \u2192 5, totaling 10 units of distance.\n\n    Test case with depots at the origin:\n    Input: 3 2\n           0 0 0\n    Expected output: 0\n    Explanation: No travel is needed as all depots are at the origin.\n\n    Test case with maximum k:\n    Input: 5 5\n           1 2 3 4 5\n    Expected output: 5\n    Explanation: The salesman can carry all bags in one trip: 0 \u2192 5, totaling 5 units of distance.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all depots are at the same position or at the origin.\n    ```python\n    if all(x == 0 for x in depot_positions):\n        return 0\n    ```\n\nYES", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        # Separate positive and negative depot positions\n        positive = sorted([x for x in depots if x > 0], reverse=True)\n        negative = sorted([-x for x in depots if x < 0], reverse=True)\n        \n        def calculate_distance(positions):\n            distance = 0\n            for i in range(0, len(positions), k):\n                distance += 2 * positions[i]\n            return distance\n        \n        # Calculate total minimum distance\n        total_distance = calculate_distance(positive) + calculate_distance(negative)\n        \n        # Subtract the distance of the farthest depot (no need to return to origin)\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of depots, the maximum number of bags that can be carried at once, and the positions of the depots.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the integers n and k.\",\n        \"Read the list of depot positions.\"\n      ]\n    },\n    {\n      \"description\": \"Separate the depot positions into positive and negative coordinates to handle them independently.\",\n      \"steps\": [\n        \"Split the list of depot positions into two lists: one for positive positions and one for negative positions.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots located at positive positions.\",\n      \"steps\": [\n        \"Sort the list of positive positions in descending order.\",\n        \"Iterate over the sorted list in steps of k, calculating the round-trip distance for each batch of deliveries.\",\n        \"Sum the distances to get the total distance for positive positions.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots located at negative positions.\",\n      \"steps\": [\n        \"Sort the list of negative positions in ascending order.\",\n        \"Iterate over the sorted list in steps of k, calculating the round-trip distance for each batch of deliveries.\",\n        \"Sum the distances to get the total distance for negative positions.\"\n      ]\n    },\n    {\n      \"description\": \"Combine the distances from positive and negative positions to get the total minimum distance for each test case.\",\n      \"steps\": [\n        \"Add the total distance for positive positions and the total distance for negative positions.\",\n        \"Subtract the maximum of the farthest positive or negative position from the total distance to account for not returning to the origin after the last delivery.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum distance for each test case.\",\n      \"steps\": [\n        \"Print the calculated minimum distance for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and depot positions.\",\n    \"Separate depot positions into positive and negative lists.\",\n    \"Calculate the minimum delivery distance for positive depot positions.\",\n    \"Calculate the minimum delivery distance for negative depot positions.\",\n    \"Combine distances and adjust for final delivery without return.\",\n    \"Output the results for each\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'number line': A linear representation where depots are positioned at distinct points, allowing calculation of distances between them and the origin.\n    'origin': The starting point (0) from which deliveries are made.\n    'minimum distance': The shortest possible total distance traveled to deliver all bags to depots.\n    'carry up to k bags': The constraint on the number of bags that can be transported in one trip.\n\n# [phrase showing quantity relationship]\n    'up to k bags': Indicates a maximum limit on the number of bags carried per trip. In code, this is implemented by iterating over depot positions in steps of k.\n    'minimum distance': Requires calculating the least possible distance, which involves optimizing the delivery path.\n\n# [degree adverb]\n    'minimum': Refers to the smallest possible total distance. In code, this is achieved by optimizing the delivery strategy to reduce unnecessary travel.\n\n# [code logic]\n    Steps for calculating distances for positive and negative positions can be implemented simultaneously using similar logic, but they should be handled separately due to differing directions (positive vs. negative).\n\n# [edge case]\n    Test case with all depots at the same position: \n    Input: 3 2\n           5 5 5\n    Expected output: 10\n    Explanation: The salesman makes two trips: 0 \u2192 5 \u2192 0 \u2192 5, covering a total distance of 10.\n\n    Test case with depots at extreme positions:\n    Input: 2 1\n           -1000000000 1000000000\n    Expected output: 3000000000\n    Explanation: The salesman travels to each extreme position separately, covering a total distance of 3000000000.\n\n    Test case with k equal to n:\n    Input: 3 3\n           1 2 3\n    Expected output: 6\n    Explanation: The salesman can deliver all bags in one trip: 0 \u2192 3 \u2192 2 \u2192 1, covering a total distance of 6.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and iterating over depot positions in steps of k inherently handles these scenarios.\n\nNO", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = sorted([x for x in positions if x > 0], reverse=True)\n        negative_positions = sorted([x for x in positions if x < 0])\n        \n        def calculate_distance(positions):\n            distance = 0\n            for i in range(0, len(positions), k):\n                distance += 2 * abs(positions[i])\n            return distance\n        \n        positive_distance = calculate_distance(positive_positions)\n        negative_distance = calculate_distance(negative_positions)\n        \n        # Subtract the maximum of the farthest positive or negative position\n        if positive_positions and negative_positions:\n            max_distance = max(abs(positive_positions[0]), abs(negative_positions[0]))\n        elif positive_positions:\n            max_distance = abs(positive_positions[0])\n        elif negative_positions:\n            max_distance = abs(negative_positions[0])\n        else:\n            max_distance = 0\n        \n        total_distance = positive_distance + negative_distance - max_distance\n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n, k = int(data[index]), int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of depots, the maximum number of bags that can be carried at once, and the positions of the depots.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"Separate the depot positions into positive and negative coordinates to handle them independently, as the strategy for minimizing distance can differ based on the direction.\",\n      \"output\": \"Two lists for each test case: one for positive depot positions and one for negative depot positions.\"\n    },\n    {\n      \"description\": \"For each list of depot positions (positive and negative), calculate the minimum distance required to deliver all bags by grouping the depots into batches of size k and determining the optimal delivery sequence.\",\n      \"output\": \"The minimum distance required for delivering bags to all depots in one direction (either positive or negative).\"\n    },\n    {\n      \"description\": \"Combine the results from both positive and negative directions to get the total minimum distance for each test case.\",\n      \"output\": \"The total minimum distance for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  - Parse the number of depots (n), the maximum number of bags (k), and the depot positions.\",\n    \"  - Separate the depot positions into positive and negative lists.\",\n    \"  - Sort both lists in descending order of absolute values.\",\n    \"  - Calculate the minimum distance for the positive list by iterating over it in steps of k, adding twice the farthest distance in each batch except for the last batch.\",\n    \"  - Calculate the minimum distance for the negative list similarly.\",\n    \"  - Sum the distances from both directions and subtract the maximum absolute value of the farthest depot (either positive or negative) to avoid unnecessary return to origin after the last delivery.\",\n    \"  - Store the result for the current test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'number line'\n    Explanation: This refers to a one-dimensional line where each depot is located at a specific integer coordinate.\n\n    'minimum distance'\n    Explanation: The shortest possible total distance the salesman needs to travel to deliver all bags to the depots.\n\n    'carry up to k bags'\n    Explanation: The salesman can carry a maximum of k bags in one trip from the origin to the depots.\n\n# [phrase showing quantity relationship]\n    'at a time': This indicates the maximum number of bags (k) that can be carried in one trip.\n    Implementation: Use a loop to handle batches of k bags.\n\n    'minimum distance': This refers to the shortest path calculation.\n    Implementation: Calculate the distance for each batch and sum them, ensuring to optimize the path by not returning to the origin after the last delivery.\n\n# [degree adverb]\n    'minimum': This indicates the need to find the smallest possible total distance.\n    Implementation: Use sorting and strategic grouping to minimize the travel distance.\n\n# [code logic]\n    The steps for separating depot positions into positive and negative lists and calculating the minimum distance for each should be implemented simultaneously for both directions. This can be done by handling both lists in a single loop structure, iterating over them in steps of k.\n\n# [edge case]\n    1. n = 1, k = 1, x = [0] = 0\n       Explanation: The depot is at the origin, so no travel is needed.\n    2. n = 5, k = 5, x = [1, 2, 3, 4, 5] = 5\n       Explanation: All bags can be delivered in one trip, so the distance is the farthest depot.\n    3. n = 3, k = 1, x = [-1, -2, -3] = 6\n       Explanation: Each bag must be delivered individually, requiring a round trip for each.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and batching already accounts for these scenarios.\n\nNO", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = sorted([x for x in positions if x > 0], reverse=True)\n        negative_positions = sorted([-x for x in positions if x < 0], reverse=True)\n        \n        def calculate_distance(positions):\n            distance = 0\n            for i in range(0, len(positions), k):\n                distance += 2 * positions[i]\n            return distance\n        \n        positive_distance = calculate_distance(positive_positions)\n        negative_distance = calculate_distance(negative_positions)\n        \n        # Subtract the maximum absolute value of the farthest depot to avoid unnecessary return\n        max_distance = 0\n        if positive_positions:\n            max_distance = max(max_distance, positive_positions[0])\n        if negative_positions:\n            max_distance = max(max_distance, negative_positions[0])\n        \n        total_distance = positive_distance + negative_distance - max_distance\n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the values of n, k, and the list of depot positions.\",\n      \"steps\": [\n        \"Read the number of test cases t.\",\n        \"For each test case, read the integers n and k.\",\n        \"Read the list of depot positions x_i.\"\n      ]\n    },\n    {\n      \"description\": \"Separate depot positions into positive and negative lists to handle them independently.\",\n      \"steps\": [\n        \"Initialize two lists: one for positive depot positions and one for negative depot positions.\",\n        \"Iterate through the list of depot positions and add each position to the appropriate list based on its sign.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots for each test case.\",\n      \"steps\": [\n        \"Sort both positive and negative depot lists in descending order of absolute values.\",\n        \"For each list, calculate the total distance by grouping depots into batches of size k.\",\n        \"For each batch, calculate the round trip distance from the origin to the farthest depot in the batch and back.\",\n        \"Sum the distances for all batches, ensuring the last batch does not require a return trip to the origin.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum distance for each test case.\",\n      \"steps\": [\n        \"Store the calculated minimum distance for each test case.\",\n        \"Print the stored distances in sequence.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and depot positions.\",\n    \"Separate depot positions into positive and negative lists.\",\n    \"Sort depot positions by absolute value in descending order.\",\n    \"Calculate the minimum delivery distance for each test case by batching depots and summing travel distances.\",\n    \"Output the calculated minimum distances for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'depot': A location on the number line where goods need to be delivered.\n    'origin': The starting point (0) where the salesman begins and returns to collect goods.\n    'bags': The goods that need to be delivered to each depot.\n    'minimum distance': The shortest possible total distance the salesman needs to travel to deliver all goods.\n\n# [phrase showing quantity relationship]\n    'up to k bags': Indicates the maximum number of bags that can be carried at once. In code, this means grouping deliveries into batches of size k.\n    'sum of n over all test cases does not exceed 2 \u22c5 10^5': Ensures that the total number of depots across all test cases is within a specified limit, which affects performance considerations.\n\n# [degree adverb]\n    'minimum': Refers to the smallest possible total travel distance. In code, this involves optimizing the delivery route to reduce travel distance.\n\n# [code logic]\n    The steps for sorting depot positions and calculating distances for batches should be implemented simultaneously. Sorting and batching can be done in one code block to streamline the process.\n\n# [edge case]\n    Test case with all depots at the origin: \n    Input: 1 1\n           0\n    Expected output: 0\n    Explanation: No travel is needed as all depots are at the origin.\n\n    Test case with maximum k and all depots at the same position:\n    Input: 3 3\n           5 5 5\n    Expected output: 5\n    Explanation: Only one trip is needed to deliver all bags to the same depot.\n\n    Test case with depots at extreme positions:\n    Input: 2 1\n           -1000000000 1000000000\n    Expected output: 3000000000\n    Explanation: Each depot requires a separate trip due to k=1, and the total distance is the sum of the absolute values of the positions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and batching based on k will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive_depots = sorted([x for x in depots if x > 0], reverse=True)\n        negative_depots = sorted([-x for x in depots if x < 0], reverse=True)\n        \n        def calculate_distance(depot_list):\n            distance = 0\n            for i in range(0, len(depot_list), k):\n                distance += 2 * depot_list[i]\n            return distance\n        \n        positive_distance = calculate_distance(positive_depots)\n        negative_distance = calculate_distance(negative_depots)\n        \n        # Subtract the last trip back to origin for the farthest depot\n        if positive_depots and negative_depots:\n            results.append(positive_distance + negative_distance - max(positive_depots[0], negative_depots[0]))\n        elif positive_depots:\n            results.append(positive_distance - positive_depots[0])\n        elif negative_depots:\n            results.append(negative_distance - negative_depots[0])\n        else:\n            results.append(0)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 90)"}, "Round_1": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive_depots = sorted([x for x in depots if x > 0], reverse=True)\n        negative_depots = sorted([-x for x in depots if x < 0], reverse=True)\n        \n        def calculate_distance(depot_list):\n            distance = 0\n            for i in range(0, len(depot_list), k):\n                distance += 2 * depot_list[i]\n            return distance\n        \n        positive_distance = calculate_distance(positive_depots)\n        negative_distance = calculate_distance(negative_depots)\n        \n        # Subtract the last trip back to origin for the farthest depot\n        if positive_depots and negative_depots:\n            results.append(positive_distance + negative_distance - max(positive_depots[0], negative_depots[0]))\n        elif positive_depots:\n            results.append(positive_distance - positive_depots[0])\n        elif negative_depots:\n            results.append(negative_distance - negative_depots[0])\n        else:\n            results.append(0)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of depots, the maximum number of bags that can be carried at once, and the positions of the depots.\",\n      \"output\": \"A structured representation of the input data for further processing.\"\n    },\n    {\n      \"description\": \"For each test case, separate the depot positions into positive and negative coordinates, as they represent different directions on the number line.\",\n      \"output\": \"Two lists of depot positions: one for positive coordinates and one for negative coordinates.\"\n    },\n    {\n      \"description\": \"For each list of depot positions (positive and negative), calculate the minimum distance required to deliver the bags by grouping the positions into batches of size k and determining the optimal delivery strategy.\",\n      \"output\": \"The minimum distance required for each direction (positive and negative) for a single test case.\"\n    },\n    {\n      \"description\": \"Combine the distances calculated for positive and negative directions to determine the total minimum distance for each test case.\",\n      \"output\": \"The total minimum distance for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, split the depot positions into positive and negative lists.\",\n    \"Sort each list of depot positions in descending order of their absolute values.\",\n    \"For each sorted list, iterate over the positions in batches of size k, calculating the distance for each batch as twice the farthest position in the batch (to account for the return trip to the origin).\",\n    \"Sum the distances for all batches in both positive and negative directions, subtracting the distance of the farthest position (since the final trip does not require a return to the origin).\",\n    \"Output the total minimum distance for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'number line'\n    Explanation: A number line is a straight line on which every point corresponds to a real number. In this problem, depots are positioned on this line, and the salesman must travel along it to deliver goods.\n\n    'minimum distance'\n    Explanation: The goal is to calculate the shortest possible distance the salesman needs to travel to deliver all goods to the depots, considering the constraints of carrying capacity and depot positions.\n\n# [phrase showing quantity relationship]\n    'at a time': Refers to the maximum number of bags (k) that can be carried in one trip.\n    Implementation: This is used to determine how many depot positions can be grouped together for a single trip.\n\n# [degree adverb]\n    'minimum': Refers to the smallest possible total distance traveled.\n    Implementation: This involves optimizing the delivery strategy to ensure the least amount of travel, which can be achieved by sorting and batching depot positions.\n\n# [code logic]\n    The steps of splitting depot positions into positive and negative lists, sorting them, and calculating distances for each batch should be implemented simultaneously for both directions (positive and negative). This can be done in a loop that processes each test case independently.\n\n# [edge case]\n    1. n = 1, k = 1, x = [0] = 0\n       Explanation: The depot is at the origin, so no travel is needed. The expected output is 0.\n    2. n = 5, k = 5, x = [1, 2, 3, 4, 5] = 5\n       Explanation: All bags can be delivered in one trip to the farthest depot at position 5, with no return needed. The expected output is 5.\n    3. n = 3, k = 1, x = [-1, -2, -3] = 6\n       Explanation: Each bag must be delivered individually, with a return to the origin after each delivery. The expected output is 6.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and batching based on the maximum number of bags (k) and calculating the distance should naturally handle these cases.\n\nNO", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        # Separate positive and negative positions\n        positive_positions = [x for x in positions if x > 0]\n        negative_positions = [-x for x in positions if x < 0]\n        \n        # Sort positions in descending order\n        positive_positions.sort(reverse=True)\n        negative_positions.sort(reverse=True)\n        \n        # Function to calculate distance for a list of positions\n        def calculate_distance(positions):\n            distance = 0\n            for i in range(0, len(positions), k):\n                distance += 2 * positions[i]\n            return distance\n        \n        # Calculate total distance\n        total_distance = calculate_distance(positive_positions) + calculate_distance(negative_positions)\n        \n        # Subtract the farthest position as we don't need to return to origin after last delivery\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= negative_positions[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 564, "prompt": "A total of n depots are positioned on a number line. There is a number line along which the depots are situated. Depot i lies at the point x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots. You and the n bags are initially at the origin 0. You can carry up to k bags at a time. You must collect the required number of goods from the origin, deliver them to the respective depots, and then return to the origin to collect your next batch of goods.\n\nCalculate the minimum distance you need to cover to deliver all the bags of goods to the depots. You do not have to return to the origin after you have delivered all the bags. Account for both the number of bags you can carry and the positions of the depots while determining the optimal delivery strategy.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 235}
