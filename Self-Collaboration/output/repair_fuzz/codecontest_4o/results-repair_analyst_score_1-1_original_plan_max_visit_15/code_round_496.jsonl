{"name": "1582_A. Luntik and Concerts", "description": "Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.\n\nHe wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.\n\nPlease help Luntik and find the minimal possible difference in minutes between the concerts durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "tags": ["math"], "difficulty": 7, "id": 1582, "sample_io": [{"input": "4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}], "test_list": [{"input": "4\n1 1 1\n2 1 3\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 2 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n4 2 0\n6 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n5 4 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n0 2 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 4 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 4 1\n4 2 0\n10 4 5\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 5\n2 1 2\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 4\n2 2 2\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 8 4\n2 2 2\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 1 5\n1 1 1\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 0\n2 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 0\n4 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n7 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n4 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 1\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 2 5\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 4 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 1 1\n3 2 8\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n1 2 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 7\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n1 2 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 2 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 9\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n4 1 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n4 2 1\n6 4 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 0\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n4 1 1\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 8\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 5\n1 2 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 2 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n6 4 9\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 4\n4 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 3 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n2 4 0\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 5\n1 1 6\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 1\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n1 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 3 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 1 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 9\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n0 2 4\n4 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 3 2\n3 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 4 5\n1 1 4\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n10 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n2 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 1\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 9\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 3 5\n1 1 4\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 4 0\n4 2 0\n10 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n2 4 0\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n6 2 1\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 2 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 3\n2 2 2\n3 2 3\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 1\n6 4 9\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n4 2 1\n6 3 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n1 4 0\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 2 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 8 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 1 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 4 1\n4 2 1\n6 3 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n4 2 0\n10 4 3\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n1 4 0\n1 1 0\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 1 1\n2 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 3\n2 2 2\n3 2 1\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 5\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n10 4 3\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 1 1\n4 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 1\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 5\n2 2 2\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n2 1 1\n2 3 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 4\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n6 4 3\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 1 1\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 5 4\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n6 4 6\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 1 2\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 3\n1 1 6\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n7 2 1\n6 4 6\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n2 2 3\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n3 8 4\n2 2 2\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 2\n1 1 6\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 1\n6 4 4\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n1 2 3\n3 1 2\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n4 8 4\n2 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n2 3 1\n10 4 2\n1 1 6\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 4\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n1 2 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n4 8 4\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n3 3 1\n10 4 2\n1 1 6\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 3\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 2 6\n1 1 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n4 8 4\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n3 3 1\n10 4 0\n1 1 6\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 2\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 4 6\n1 1 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n4 8 6\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 3 2\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n4 1 3\n5 5 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 2 1\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n4 2 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n4 1 1\n4 2 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n4 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 1 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n4 2 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 4 5\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 0\n5 2 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 0\n2 1 1\n3 2 5\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n4 2 1\n12 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 3 3\n7 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n4 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 0\n4 2 1\n6 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 0 0\n4 2 1\n6 4 1\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 4 5\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 4 1\n2 1 1\n3 2 10\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n2 4 5\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 2\n2 2 1\n3 2 2\n1 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n11 4 9\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 3 3\n4 1 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 2 2\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n9 4 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 0\n1 1 1\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 6\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 1 8\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n1 4 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 2 2\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 4\n2 2 1\n6 4 9\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 4\n3 1 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 4 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n4 2 0\n5 4 5\n1 1 0\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 1 1\n6 2 5\n1 1 6\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 4 1\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n1 1 1\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n2 3 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n4 1 2\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 7 9\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n0 2 4\n6 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 0\n4 3 2\n3 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n5 2 1\n3 4 5\n1 1 4\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4 2 1\n4 2 1\n2 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n2 2 0\n0 2 2\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 8\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 13\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 3 5\n1 1 1\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n1 2 0\n2 1 1\n6 2 1\n2 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 2 1\n0 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 6 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 2 1\n4 3 1\n1 4 0\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 2 1\n6 2 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 5 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 10\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 2 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 4 1\n4 2 1\n6 1 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 4 1\n4 2 0\n10 4 3\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n3 2 1\n1 4 0\n1 1 0\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 1 1\n2 2 1\n3 4 0\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 3\n2 2 1\n3 2 1\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n1 2 1\n3 8 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 4 1\n7 2 0\n10 4 3\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 1\n1 1 4\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 8 5\n2 2 2\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n2 1 1\n3 3 1\n6 4 3\n1 1 3\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 2\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}], "task_id": "codecontest/28", "repair_prompt": ["Luntik has decided to try singing. He has a one-minute songs. He also has b two-minute songs and c three-minute songs and wants to distribute all songs into two concerts so that each song must be part of only one concert to minimize the absolute difference between the durations of the concerts as much as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Luntik has decided to try singing. He has a one-minute songs. He also has b two-minute songs. Additionally, he has c three-minute songs and wants to distribute all songs into two concerts so that each song must be part of only one concert to minimize the absolute difference between the durations of the concerts as much as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Luntik has decided to try singing. He has a one-minute songs, b two-minute songs, and c three-minute songs, and wants to distribute all songs into two concerts so that each song must be part of only one concert to minimize the absolute difference between the durations of the concerts as much as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        target_duration_floor = total_duration // 2\n        target_duration_ceiling = target_duration_floor + (total_duration % 2)\n\n        # Use dynamic programming to find the closest possible sum to target_duration_floor\n        possible_sums = {0}\n        for _ in range(a):\n            possible_sums = {x + 1 for x in possible_sums} | possible_sums\n        for _ in range(b):\n            possible_sums = {x + 2 for x in possible_sums} | possible_sums\n        for _ in range(c):\n            possible_sums = {x + 3 for x in possible_sums} | possible_sums\n\n        # Find the minimal difference using both target durations\n        min_diff = float('inf')\n        for sum1 in possible_sums:\n            sum2 = total_duration - sum1\n            min_diff = min(min_diff, abs(sum1 - sum2))\n\n        results.append(min_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "completions": ["def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge cases\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a + b + c == 1:\n            results.append(total_duration)\n            continue\n        \n        # Dynamic programming approach\n        max_possible_duration = total_duration // 2\n        dp = [False] * (max_possible_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible partition\n        for i in range(max_possible_duration, -1, -1):\n            if dp[i]:\n                best_partition = i\n                break\n        \n        minimal_diff = abs(total_duration - 2 * best_partition)\n        results.append(minimal_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n        \n        # Dynamic programming approach to find the closest possible split\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(half_duration, 0, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(half_duration, 0, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the maximum possible duration that can be achieved for one concert\n        max_possible_duration = 0\n        for i in range(half_duration + 1):\n            if dp[i]:\n                max_possible_duration = i\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * max_possible_duration)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If total duration is zero, the difference is zero\n        if total_duration == 0:\n            results.append(0)\n            continue\n        \n        # Target duration for each concert\n        target_duration = total_duration // 2\n        \n        # Dynamic programming approach to find the closest sum to target_duration\n        # Initialize a set to store possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the closest sum to target_duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - target_duration))\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        target = total_duration // 2\n\n        # Dynamic programming approach to find the closest sum to target\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(target, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n\n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(target, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n\n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(target, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n\n        # Find the closest sum to target\n        for i in range(target, -1, -1):\n            if dp[i]:\n                closest_sum = i\n                break\n\n        other_concert_duration = total_duration - closest_sum\n        difference = abs(other_concert_duration - closest_sum)\n        results.append(difference)\n\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # We need to find a subset of songs that can be assigned to one concert\n        # such that the absolute difference between the total durations of the two concerts is minimized.\n        \n        # The maximum possible sum we can try to achieve in one concert is half of the total duration\n        max_possible_sum = total_duration // 2\n        \n        # Dynamic programming approach to find the closest sum to max_possible_sum\n        # Initialize a DP array where dp[i] means whether a sum of i can be achieved\n        dp = [False] * (max_possible_sum + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_sum, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_sum, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_sum, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum we can achieve\n        best_sum = 0\n        for i in range(max_possible_sum + 1):\n            if dp[i]:\n                best_sum = i\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * best_sum)\n        results.append(difference)\n    \n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        target = total_duration // 2\n\n        # Initialize a set to store possible sums\n        possible_sums = {0}\n\n        # Consider one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n\n        # Consider two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n\n        # Consider three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n\n        # Find the closest sum to the target\n        closest_sum = min(possible_sums, key=lambda x: abs(x - target))\n        min_difference = abs(total_duration - 2 * closest_sum)\n        results.append(min_difference)\n\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n        \n        # Initialize a DP set to track possible durations\n        possible_durations = {0}\n        \n        # Process one-minute songs\n        for _ in range(a):\n            new_durations = set()\n            for duration in possible_durations:\n                if duration + 1 <= half_duration:\n                    new_durations.add(duration + 1)\n            possible_durations.update(new_durations)\n        \n        # Process two-minute songs\n        for _ in range(b):\n            new_durations = set()\n            for duration in possible_durations:\n                if duration + 2 <= half_duration:\n                    new_durations.add(duration + 2)\n            possible_durations.update(new_durations)\n        \n        # Process three-minute songs\n        for _ in range(c):\n            new_durations = set()\n            for duration in possible_durations:\n                if duration + 3 <= half_duration:\n                    new_durations.add(duration + 3)\n            possible_durations.update(new_durations)\n        \n        # Find the best possible duration close to half of total_duration\n        best_duration = max(possible_durations)\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * best_duration)\n        results.append(min_difference)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge case handling\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a == 1 and b == 0 and c == 0:\n            results.append(1)\n            continue\n        \n        # Dynamic programming approach to find the minimal possible difference\n        half_duration = total_duration // 2\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(half_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(half_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible partition\n        for j in range(half_duration, -1, -1):\n            if dp[j]:\n                min_diff = total_duration - 2 * j\n                results.append(min_diff)\n                break\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If the total duration is odd, the minimal difference is 1\n        if total_duration % 2 != 0:\n            results.append(1)\n        else:\n            results.append(0)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        target_duration_floor = total_duration // 2\n        target_duration_ceiling = target_duration_floor + (total_duration % 2)\n\n        # Use dynamic programming to find the closest possible sum to target_duration_floor\n        possible_sums = {0}\n        for _ in range(a):\n            possible_sums = {x + 1 for x in possible_sums} | possible_sums\n        for _ in range(b):\n            possible_sums = {x + 2 for x in possible_sums} | possible_sums\n        for _ in range(c):\n            possible_sums = {x + 3 for x in possible_sums} | possible_sums\n\n        # Find the minimal difference using both target durations\n        min_diff = float('inf')\n        for sum1 in possible_sums:\n            sum2 = total_duration - sum1\n            min_diff = min(min_diff, abs(sum1 - sum2))\n\n        results.append(min_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the total duration of all songs.\",\n      \"steps\": [\n        \"Multiply the number of one-minute songs by 1 to get their total duration.\",\n        \"Multiply the number of two-minute songs by 2 to get their total duration.\",\n        \"Multiply the number of three-minute songs by 3 to get their total duration.\",\n        \"Sum the durations of all song types to get the total duration.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the target duration for each concert.\",\n      \"steps\": [\n        \"Divide the total duration by 2 to get the target duration for each concert.\",\n        \"Consider both floor and ceiling values of the division to handle cases where the total duration is odd.\"\n      ]\n    },\n    {\n      \"description\": \"Distribute songs between two concerts to minimize the difference.\",\n      \"steps\": [\n        \"Use a greedy or dynamic programming approach to distribute songs such that the absolute difference between the two concerts' durations is minimized.\",\n        \"Iterate through possible distributions and calculate the duration of each concert.\",\n        \"Track the minimal difference encountered during the distribution process.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, read the number of one-minute, two-minute, and three-minute songs.\",\n    \"Calculate the total duration of all songs.\",\n    \"Determine the target duration for each concert.\",\n    \"Distribute songs between two concerts to minimize the difference.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concert': refers to the grouping of songs into two separate events.\n    'duration': refers to the total time of songs in each concert.\n    'absolute difference': refers to the non-negative difference between the durations of the two concerts.\n\n# [phrase showing quantity relationship]\n    'minimize the absolute difference': means to make the difference between the durations of the two concerts as small as possible.\n    'sum of durations': means adding up the durations of all songs in a concert.\n\n# [degree adverb]\n    'minimal': means the smallest possible difference between the durations of the two concerts.\n\n# [code logic]\n    The steps for calculating total duration and determining target duration should be considered simultaneously. \n    \"Calculate the total duration of all songs\" and \"Determine the target duration for each concert\" can be done in one code block as they are directly related.\n\n# [edge case]\n    1 0 0 = 1\n    Explanation: With only one one-minute song, the difference between the two concerts is 1 since one concert will have the song and the other will have none.\n    \n    0 0 0 = 0\n    Explanation: With no songs, both concerts have a duration of 0, so the difference is 0.\n    \n    1 1 0 = 1\n    Explanation: With one one-minute song and one two-minute song, the best distribution is one song per concert, resulting in a difference of 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the total duration is odd.\n        if total_duration % 2 != 0:\n            # Handle odd total duration by considering both floor and ceiling values\n            target_duration_floor = total_duration // 2\n            target_duration_ceiling = target_duration_floor + 1\n            # Implement logic to minimize difference using both target durations\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        target_duration_floor = total_duration // 2\n        target_duration_ceiling = target_duration_floor + (total_duration % 2)\n\n        # Use dynamic programming to find the closest possible sum to target_duration_floor\n        possible_sums = {0}\n        for _ in range(a):\n            possible_sums = {x + 1 for x in possible_sums} | possible_sums\n        for _ in range(b):\n            possible_sums = {x + 2 for x in possible_sums} | possible_sums\n        for _ in range(c):\n            possible_sums = {x + 3 for x in possible_sums} | possible_sums\n\n        # Find the minimal difference using both target durations\n        min_diff = float('inf')\n        for sum1 in possible_sums:\n            sum2 = total_duration - sum1\n            min_diff = min(min_diff, abs(sum1 - sum2))\n\n        results.append(min_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"input\": \"A single integer t followed by t lines, each containing three integers a, b, c.\",\n      \"output\": \"A list of tuples, each containing three integers (a, b, c) for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"input\": \"A tuple (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the total duration of all songs.\"\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts for each test case.\",\n      \"input\": \"The total duration of all songs and the number of each type of song (a, b, c).\",\n      \"output\": \"An integer representing the minimal possible difference in minutes between the concerts' durations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases and the number of each type of song for each test case.\",\n    \"For each test case, calculate the total duration of all songs using the formula: total_duration = a * 1 + b * 2 + c * 3.\",\n    \"For each test case, use a dynamic programming approach to find the minimal possible difference between the durations of two concerts. This involves finding a subset of songs that can be assigned to one concert such that the absolute difference between the two concerts' durations is minimized.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts'\n    Explanation: In the requirement, concerts refer to two separate groups of songs that need to be balanced in terms of their total duration.\n\n    'minimal possible difference'\n    Explanation: This means the goal is to make the total duration of songs in the two concerts as close as possible, minimizing the absolute difference between their durations.\n\n# [phrase showing quantity relationship]\n    'as much as possible': This phrase indicates the need to minimize the difference between the two concert durations as much as possible, which means finding the smallest possible absolute difference.\n\n# [degree adverb] \n    'minimal': This indicates that the solution should aim for the smallest possible difference in the total duration of the two concerts.\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the dynamic programming approach to find the minimal possible difference should be carefully integrated. The calculation of total duration and the dynamic programming solution should be considered together to ensure the correct subset of songs is chosen.\n\n# [edge case] \n    1. (1, 0, 0) = 1\n       Explanation: With only one one-minute song, the difference is 1 since one concert will have the song and the other will have none.\n    2. (0, 0, 0) = 0\n       Explanation: If there are no songs, the difference is 0 as both concerts have a duration of 0.\n    3. (1, 1, 1) = 0\n       Explanation: As given in the example, the songs can be distributed to achieve a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the number of songs is extremely low or zero.\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    if a + b + c == 1:\n        return a + 2 * b + 3 * c\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge cases\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a + b + c == 1:\n            results.append(total_duration)\n            continue\n        \n        # Dynamic programming approach\n        max_possible_duration = total_duration // 2\n        dp = [False] * (max_possible_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible partition\n        for i in range(max_possible_duration, -1, -1):\n            if dp[i]:\n                best_partition = i\n                break\n        \n        minimal_diff = abs(total_duration - 2 * best_partition)\n        results.append(minimal_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"input\": \"A single integer t followed by t lines, each containing three integers a, b, c.\",\n      \"output\": \"A list of tuples, each containing three integers (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"input\": \"A tuple (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the total duration of all songs.\"\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts for each test case.\",\n      \"input\": \"The total duration of all songs and the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the minimal possible difference in minutes between the concerts durations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n    \"For each test case, calculate the total duration of all songs using the formula: total_duration = a * 1 + b * 2 + c * 3.\",\n    \"For each test case, use a dynamic programming approach to find the minimal possible difference between the durations of two concerts. This involves finding a subset of songs whose total duration is as close as possible to half of the total duration.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts'\n    Explanation: In the requirement, concerts refer to the two separate groups into which the songs are divided. The goal is to balance the total duration of songs in each concert.\n\n    'minimal possible difference'\n    Explanation: This refers to the smallest absolute difference in total duration between the two concerts.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute'\n    Explanation: These phrases indicate the duration of each type of song. In code, this can be implemented by multiplying the number of each type of song by its respective duration to get the total duration.\n\n# [degree adverb]\n    'minimal'\n    Explanation: This indicates the need to find the smallest possible value. In code, this can be implemented by iterating through possible distributions of songs and keeping track of the smallest difference found.\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the dynamic programming approach to find the minimal possible difference should be carefully integrated. The calculation of total duration and the dynamic programming logic to find the minimal difference should be considered together.\n\n# [edge case]\n    1. (1, 0, 0) = 1\n    Explanation: With only one one-minute song, the difference between the two concerts will be 1 since one concert will have the song and the other will have none.\n    \n    2. (0, 0, 0) = 0\n    Explanation: If there are no songs, the difference is 0 because both concerts have a duration of 0.\n    \n    3. (1, 1, 1) = 0\n    Explanation: As given in the example, the songs can be distributed to achieve a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, especially when there are no songs or when the total duration is odd, which might require special handling in the dynamic programming approach.\n    \n    ```python\n    if total_duration == 0:\n        return 0\n    if total_duration % 2 != 0:\n        # Handle the case where the total duration is odd\n        # Implement logic to find the closest possible split\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n        \n        # Dynamic programming approach to find the closest possible split\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        for _ in range(b):\n            for j in range(half_duration, 0, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        for _ in range(c):\n            for j in range(half_duration, 0, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the maximum possible duration that can be achieved for one concert\n        max_possible_duration = 0\n        for i in range(half_duration + 1):\n            if dp[i]:\n                max_possible_duration = i\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * max_possible_duration)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n        \n        # Dynamic programming approach to find the closest possible split\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(half_duration, 0, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(half_duration, 0, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the maximum possible duration that can be achieved for one concert\n        max_possible_duration = 0\n        for i in range(half_duration + 1):\n            if dp[i]:\n                max_possible_duration = i\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * max_possible_duration)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the total duration of all songs.\",\n      \"steps\": [\n        \"Multiply the number of one-minute songs by 1 to get their total duration.\",\n        \"Multiply the number of two-minute songs by 2 to get their total duration.\",\n        \"Multiply the number of three-minute songs by 3 to get their total duration.\",\n        \"Sum the durations of all song types to get the total duration.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the target duration for each concert.\",\n      \"steps\": [\n        \"Divide the total duration by 2 to get the target duration for each concert.\",\n        \"Consider both floor and ceiling values of the division to handle cases where the total duration is odd.\"\n      ]\n    },\n    {\n      \"description\": \"Distribute songs into two concerts to minimize the difference in durations.\",\n      \"steps\": [\n        \"Use a greedy or dynamic programming approach to distribute songs such that the absolute difference between the two concerts' durations is minimized.\",\n        \"Ensure each song is part of only one concert.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimal possible difference in durations between the two concerts.\",\n      \"steps\": [\n        \"Compute the absolute difference between the durations of the two concerts after distribution.\",\n        \"Output the minimal possible difference for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, read the number of one-minute, two-minute, and three-minute songs.\",\n    \"Calculate the total duration of all songs.\",\n    \"Determine the target duration for each concert.\",\n    \"Distribute songs into two concerts to minimize the difference in durations.\",\n    \"Calculate and output the minimal possible difference in durations between the two concerts.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concert': refers to the event where songs are played, and the goal is to distribute songs between two concerts.\n    'absolute difference': refers to the non-negative difference between the durations of the two concerts.\n\n# [phrase showing quantity relationship]\n    'minimize the absolute difference': means the goal is to make the difference between the durations of the two concerts as small as possible.\n    'one-minute', 'two-minute', 'three-minute': refers to the duration of each type of song, which affects the total duration of the concerts.\n\n# [degree adverb]\n    'minimal': means the smallest possible difference between the durations of the two concerts.\n\n# [code logic]\n    The steps for calculating the total duration and determining the target duration should be considered simultaneously. Specifically, calculating the total duration and determining the target duration for each concert can be done in one code block, as they are directly related.\n\n# [edge case]\n    Edge Case 1: 1 0 0 = 1\n    Explanation: With only one one-minute song, the difference between the two concerts is 1 since one concert will have the song and the other will have none.\n    \n    Edge Case 2: 0 0 0 = 0\n    Explanation: With no songs, both concerts have a duration of 0, resulting in a difference of 0.\n    \n    Edge Case 3: 1 1 1 = 0\n    Explanation: As explained in the example, distributing one one-minute song and one two-minute song in one concert and the three-minute song in the other results in a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, especially when the total duration is odd or when there are no songs.\n    Code for handling the edge case:\n    ```python\n    if total_duration == 0:\n        return 0\n    if total_duration % 2 != 0:\n        # Handle odd total duration by considering both floor and ceiling values\n        target_duration_floor = total_duration // 2\n        target_duration_ceiling = target_duration_floor + 1\n        # Implement logic to distribute songs considering both target durations\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If total duration is zero, the difference is zero\n        if total_duration == 0:\n            results.append(0)\n            continue\n        \n        # Target duration for each concert\n        target_duration = total_duration // 2\n        \n        # Dynamic programming approach to find the closest sum to target_duration\n        # Initialize a set to store possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the closest sum to target_duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - target_duration))\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the total duration of all songs.\",\n      \"details\": \"Sum the durations of all songs using the formula: total_duration = a * 1 + b * 2 + c * 3.\"\n    },\n    {\n      \"description\": \"Determine the target duration for each concert.\",\n      \"details\": \"The target duration for each concert is half of the total duration, rounded down if necessary.\"\n    },\n    {\n      \"description\": \"Distribute songs between two concerts to minimize the difference in durations.\",\n      \"details\": \"Use a greedy or dynamic programming approach to distribute songs such that the absolute difference between the durations of the two concerts is minimized.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Read the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\"\n    },\n    {\n      \"step\": \"Process each test case\",\n      \"details\": \"For each test case, perform the following substeps.\"\n    },\n    {\n      \"step\": \"Calculate total duration\",\n      \"details\": \"Compute the total duration of all songs using the formula: total_duration = a * 1 + b * 2 + c * 3.\"\n    },\n    {\n      \"step\": \"Determine target duration\",\n      \"details\": \"Calculate the target duration for each concert as half of the total duration.\"\n    },\n    {\n      \"step\": \"Distribute songs\",\n      \"details\": \"Implement a strategy to distribute songs between two concerts to minimize the absolute difference in durations. Consider using a dynamic programming approach to find the optimal distribution.\"\n    },\n    {\n      \"step\": \"Output result\",\n      \"details\": \"For each test case, output the minimal possible difference in minutes between the durations of the two concerts.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts': refers to the two separate events where songs are distributed.\n    'absolute difference': refers to the non-negative difference between the durations of the two concerts.\n\n# [phrase showing quantity relationship]\n    'one-minute songs', 'two-minute songs', 'three-minute songs': These phrases indicate the duration of each type of song. The relationship is that each song contributes to the total duration of a concert based on its type.\n    Implementation: Use the formula total_duration = a * 1 + b * 2 + c * 3 to calculate the total duration.\n\n# [degree adverb]\n    'minimal': refers to the smallest possible value of the absolute difference between the durations of the two concerts.\n    Implementation: Use a strategy (e.g., dynamic programming) to distribute songs such that the absolute difference is minimized.\n\n# [code logic]\n    The steps \"Calculate total duration\" and \"Determine target duration\" can be implemented simultaneously as they are both preparatory calculations before distributing songs.\n\n# [edge case]\n    Edge Case 1: 1 0 0 = 1\n    Explanation: With only one one-minute song, the difference between the two concerts will be 1 since one concert will have the song and the other will have none.\n    \n    Edge Case 2: 0 0 0 = 0\n    Explanation: With no songs, both concerts have a duration of 0, resulting in a difference of 0.\n    \n    Edge Case 3: 1 1 1 = 0\n    Explanation: As explained in the example, distributing one one-minute song and one two-minute song in one concert and the three-minute song in the other results in a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Implement a check for cases where the total number of songs is very small or zero, and handle them separately to ensure correct output.\n    Example code:\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        print(0)\n    elif a + b + c == 1:\n        print(1)\n    else:\n        # Implement dynamic programming or greedy approach for distribution\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        target = total_duration // 2\n\n        # Dynamic programming approach to find the closest sum to target\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(target, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n\n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(target, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n\n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(target, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n\n        # Find the closest sum to target\n        for i in range(target, -1, -1):\n            if dp[i]:\n                closest_sum = i\n                break\n\n        other_concert_duration = total_duration - closest_sum\n        difference = abs(other_concert_duration - closest_sum)\n        results.append(difference)\n\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        target = total_duration // 2\n\n        # Dynamic programming approach to find the closest sum to target\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(target, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n\n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(target, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n\n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(target, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n\n        # Find the closest sum to target\n        for i in range(target, -1, -1):\n            if dp[i]:\n                closest_sum = i\n                break\n\n        other_concert_duration = total_duration - closest_sum\n        difference = abs(other_concert_duration - closest_sum)\n        results.append(difference)\n\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"input\": \"A single integer t followed by t lines, each containing three integers a, b, c.\",\n      \"output\": \"A list of tuples, each containing three integers (a, b, c) for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"input\": \"A tuple (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the total duration of all songs.\"\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts for each test case.\",\n      \"input\": \"The total duration of all songs and the number of each type of song (a, b, c).\",\n      \"output\": \"An integer representing the minimal possible difference in minutes between the concerts' durations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n    \"For each test case, calculate the total duration of all songs using the formula: total_duration = a * 1 + b * 2 + c * 3.\",\n    \"For each test case, use a dynamic programming approach to find the minimal possible difference between the durations of two concerts. This involves finding a subset of songs that can be assigned to one concert such that the absolute difference between the total durations of the two concerts is minimized.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts': refers to the two separate events where songs are distributed.\n    'absolute difference': refers to the non-negative difference between the durations of the two concerts.\n    Explanation: The requirement is to distribute songs into two concerts such that the difference in their total durations is minimized.\n\n# [phrase showing quantity relationship]\n    'minimize the absolute difference': means to make the difference between the durations of the two concerts as small as possible.\n    'one-minute', 'two-minute', 'three-minute': refers to the duration of each type of song.\n    Implementation: Calculate the total duration of songs and use a method (like dynamic programming) to partition them into two groups with minimal difference.\n\n# [degree adverb]\n    'minimal': means the smallest possible difference between the durations of the two concerts.\n    Implementation: Use an algorithm to find the optimal partition of songs that results in the smallest difference.\n\n# [code logic]\n    The step of calculating the total duration and determining the minimal possible difference should be considered simultaneously. The total duration calculation is straightforward, but finding the minimal difference requires a more complex approach, possibly involving dynamic programming or a greedy algorithm.\n\n# [edge case]\n    Case 1: (1, 0, 0) = 1\n    Explanation: Only one song, so it must be in one concert, resulting in a difference of 1.\n    \n    Case 2: (0, 0, 0) = 0\n    Explanation: No songs, so both concerts have a duration of 0, resulting in a difference of 0.\n    \n    Case 3: (1, 1, 1) = 0\n    Explanation: Distribute one-minute and two-minute songs in one concert and the three-minute song in another, resulting in equal durations.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    if a == 1 and b == 0 and c == 0:\n        return 1\n    # Additional logic for dynamic programming or greedy approach to partition songs\n    ```\n\nNO", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # We need to find a subset of songs that can be assigned to one concert\n        # such that the absolute difference between the total durations of the two concerts is minimized.\n        \n        # The maximum possible sum we can try to achieve in one concert is half of the total duration\n        max_possible_sum = total_duration // 2\n        \n        # Dynamic programming approach to find the closest sum to max_possible_sum\n        # Initialize a DP array where dp[i] means whether a sum of i can be achieved\n        dp = [False] * (max_possible_sum + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_sum, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_sum, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_sum, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum we can achieve\n        best_sum = 0\n        for i in range(max_possible_sum + 1):\n            if dp[i]:\n                best_sum = i\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * best_sum)\n        results.append(difference)\n    \n    return results", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # We need to find a subset of songs that can be assigned to one concert\n        # such that the absolute difference between the total durations of the two concerts is minimized.\n        \n        # The maximum possible sum we can try to achieve in one concert is half of the total duration\n        max_possible_sum = total_duration // 2\n        \n        # Dynamic programming approach to find the closest sum to max_possible_sum\n        # Initialize a DP array where dp[i] means whether a sum of i can be achieved\n        dp = [False] * (max_possible_sum + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_sum, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_sum, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_sum, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum we can achieve\n        best_sum = 0\n        for i in range(max_possible_sum + 1):\n            if dp[i]:\n                best_sum = i\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * best_sum)\n        results.append(difference)\n    \n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the total duration of all songs.\",\n      \"details\": \"Sum the durations of all songs using the formula: total_duration = a * 1 + b * 2 + c * 3.\"\n    },\n    {\n      \"description\": \"Determine the target duration for each concert.\",\n      \"details\": \"The target duration for each concert is half of the total duration, rounded down if necessary.\"\n    },\n    {\n      \"description\": \"Distribute songs between two concerts to minimize the difference in durations.\",\n      \"details\": \"Use a greedy or dynamic programming approach to distribute songs such that the absolute difference between the two concerts' durations is minimized.\"\n    },\n    {\n      \"description\": \"Calculate the minimal possible difference.\",\n      \"details\": \"Compute the absolute difference between the durations of the two concerts after distribution.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"Calculate the total duration of all songs.\",\n    \"Determine the target duration for each concert.\",\n    \"Distribute songs between two concerts using a suitable algorithm to minimize the difference.\",\n    \"Calculate and store the minimal possible difference for the current test case.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concert': refers to the grouping of songs into two separate events.\n    'duration': refers to the total time of songs in each concert.\n    'absolute difference': refers to the non-negative difference between the durations of the two concerts.\n\n# [phrase showing quantity relationship]\n    'as much as possible': means minimizing the difference between the durations of the two concerts.\n    Implementation: This can be achieved by distributing songs in a way that the sum of durations in each concert is as close as possible.\n\n# [degree adverb]\n    'minimal': means the smallest possible difference between the durations of the two concerts.\n    Implementation: Use an algorithm to ensure the difference is minimized, such as dynamic programming or greedy approach.\n\n# [code logic]\n    The steps \"Calculate the total duration of all songs\" and \"Determine the target duration for each concert\" should be implemented simultaneously as they are interdependent. Calculating the total duration is necessary to determine the target duration.\n\n# [edge case]\n    Case 1: a = 0, b = 0, c = 1\n    Expected output: 3\n    Explanation: Only one song exists, and it must be placed in one concert, resulting in a duration difference of 3.\n    \n    Case 2: a = 1, b = 0, c = 0\n    Expected output: 1\n    Explanation: Only one song exists, and it must be placed in one concert, resulting in a duration difference of 1.\n    \n    Case 3: a = 0, b = 1, c = 0\n    Expected output: 2\n    Explanation: Only one song exists, and it must be placed in one concert, resulting in a duration difference of 2.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where one type of song is completely absent.\n    Code for handling the edge case:\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    if a == 0 and b == 0:\n        return c * 3\n    if a == 0 and c == 0:\n        return b * 2\n    if b == 0 and c == 0:\n        return a * 1\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        target = total_duration // 2\n\n        # Initialize a set to store possible sums\n        possible_sums = {0}\n\n        # Consider one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n\n        # Consider two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n\n        # Consider three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n\n        # Find the closest sum to the target\n        closest_sum = min(possible_sums, key=lambda x: abs(x - target))\n        min_difference = abs(total_duration - 2 * closest_sum)\n        results.append(min_difference)\n\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        target = total_duration // 2\n\n        # Initialize a set to store possible sums\n        possible_sums = {0}\n\n        # Consider one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n\n        # Consider two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n\n        # Consider three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n\n        # Find the closest sum to the target\n        closest_sum = min(possible_sums, key=lambda x: abs(x - target))\n        min_difference = abs(total_duration - 2 * closest_sum)\n        results.append(min_difference)\n\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"input\": \"A single integer t followed by t lines, each containing three integers a, b, c.\",\n      \"output\": \"A list of tuples, each containing three integers (a, b, c) for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"input\": \"A tuple (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the total duration of all songs.\"\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts for each test case.\",\n      \"input\": \"The total duration of all songs and the number of each type of song (a, b, c).\",\n      \"output\": \"An integer representing the minimal possible difference in minutes between the concerts' durations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases and the number of each type of song for each test case.\",\n    \"For each test case, calculate the total duration of all songs using the formula: total_duration = a * 1 + b * 2 + c * 3.\",\n    \"For each test case, use a dynamic programming approach to find the minimal possible difference between the durations of two concerts. This involves finding a subset of songs whose total duration is as close as possible to half of the total duration.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts': refers to the two separate events where songs are distributed.\n    'minimal possible difference': means the smallest absolute difference in total duration between the two concerts.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute': these phrases indicate the duration of each type of song.\n    'minimize the absolute difference': means to make the difference between the total durations of the two concerts as small as possible.\n\n# [degree adverb]\n    'minimal': means the smallest possible value for the difference between the durations of the two concerts.\n\n# [code logic]\n    The steps to calculate the total duration and determine the minimal possible difference should be considered simultaneously. Specifically, the dynamic programming approach to find the subset of songs should be integrated with the calculation of total duration to ensure the difference is minimized.\n\n# [edge case]\n    Case 1: a = 0, b = 0, c = 0\n    Expected output: 0\n    Explanation: No songs are present, so the difference is 0.\n    \n    Case 2: a = 1, b = 0, c = 0\n    Expected output: 1\n    Explanation: Only one song of one-minute duration, so the difference is 1.\n    \n    Case 3: a = 0, b = 1, c = 1\n    Expected output: 1\n    Explanation: One two-minute song and one three-minute song can be split into two concerts with durations 2 and 3, resulting in a difference of 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the number of songs is extremely low or zero.\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    if a + b + c == 1:\n        return a * 1 + b * 2 + c * 3\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n        \n        # Initialize a DP array to track possible durations\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(half_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(half_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible duration close to half of total_duration\n        best_duration = 0\n        for i in range(half_duration + 1):\n            if dp[i]:\n                best_duration = i\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * best_duration)\n        results.append(min_difference)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    \n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n        \n        # Initialize a DP set to track possible durations\n        possible_durations = {0}\n        \n        # Process one-minute songs\n        for _ in range(a):\n            new_durations = set()\n            for duration in possible_durations:\n                if duration + 1 <= half_duration:\n                    new_durations.add(duration + 1)\n            possible_durations.update(new_durations)\n        \n        # Process two-minute songs\n        for _ in range(b):\n            new_durations = set()\n            for duration in possible_durations:\n                if duration + 2 <= half_duration:\n                    new_durations.add(duration + 2)\n            possible_durations.update(new_durations)\n        \n        # Process three-minute songs\n        for _ in range(c):\n            new_durations = set()\n            for duration in possible_durations:\n                if duration + 3 <= half_duration:\n                    new_durations.add(duration + 3)\n            possible_durations.update(new_durations)\n        \n        # Find the best possible duration close to half of total_duration\n        best_duration = max(possible_durations)\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * best_duration)\n        results.append(min_difference)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"List of tuples, each containing three integers (a, b, c) for each test case\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"input\": \"Tuple (a, b, c) for each test case\",\n      \"output\": \"Total duration of all songs\"\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts for each test case.\",\n      \"input\": \"Total duration of all songs\",\n      \"output\": \"Minimal possible difference in minutes between the concerts\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n    \"For each test case, calculate the total duration of all songs by computing the sum of a, 2*b, and 3*c.\",\n    \"For each test case, use a dynamic programming approach to find the minimal possible difference between the durations of two concerts. This involves finding a subset of songs whose total duration is as close as possible to half of the total duration.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concert': refers to the grouping of songs into two separate events.\n    'minimal possible difference': means the smallest absolute difference in total duration between the two concerts.\n\n# [phrase showing quantity relationship]\n    'one-minute songs', 'two-minute songs', 'three-minute songs': indicates the duration of each type of song.\n    Implementation: Calculate the total duration by summing a*1, b*2, and c*3.\n\n# [degree adverb]\n    'minimal': means the smallest possible value.\n    Implementation: Use a method to partition the songs such that the absolute difference between the two groups is minimized.\n\n# [code logic]\n    The steps to calculate the total duration and determine the minimal possible difference should be considered simultaneously.\n    Implementation: Calculate the total duration first, then use dynamic programming or a similar approach to partition the songs into two groups with minimal difference.\n\n# [edge case]\n    Test case: 1 0 0 = 1\n    Explanation: Only one one-minute song exists, so the difference is 1.\n    Test case: 0 0 0 = 0\n    Explanation: No songs exist, so the difference is 0.\n    Test case: 1000000000 1000000000 1000000000 = 0\n    Explanation: With equal numbers of each type of song, they can be perfectly balanced between the two concerts.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling the edge case:\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    if a == 1 and b == 0 and c == 0:\n        return 1\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge case handling\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a == 1 and b == 0 and c == 0:\n            results.append(1)\n            continue\n        \n        # Dynamic programming approach to find the minimal possible difference\n        half_duration = total_duration // 2\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(half_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(half_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible partition\n        for j in range(half_duration, -1, -1):\n            if dp[j]:\n                min_diff = total_duration - 2 * j\n                results.append(min_diff)\n                break\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge case handling\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a == 1 and b == 0 and c == 0:\n            results.append(1)\n            continue\n        \n        # Dynamic programming approach to find the minimal possible difference\n        half_duration = total_duration // 2\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(half_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(half_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible partition\n        for j in range(half_duration, -1, -1):\n            if dp[j]:\n                min_diff = total_duration - 2 * j\n                results.append(min_diff)\n                break\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the total duration of all songs.\",\n      \"details\": \"Sum the durations of all songs using the formula: total_duration = a * 1 + b * 2 + c * 3.\"\n    },\n    {\n      \"description\": \"Determine the target duration for each concert.\",\n      \"details\": \"Calculate the target duration for each concert as half of the total duration: target_duration = total_duration / 2.\"\n    },\n    {\n      \"description\": \"Distribute songs to minimize the difference between concert durations.\",\n      \"details\": \"Use a method to distribute songs into two groups such that the absolute difference between the sum of durations of songs in each group is minimized.\"\n    },\n    {\n      \"description\": \"Calculate the minimal possible difference.\",\n      \"details\": \"Compute the absolute difference between the durations of the two concerts after distribution.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  Calculate the total duration of all songs.\",\n    \"  Determine the target duration for each concert.\",\n    \"  Distribute songs into two concerts to minimize the difference in durations.\",\n    \"  Calculate and store the minimal possible difference for the current test case.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concert': Refers to the two separate events where songs are distributed.\n    'minimal possible difference': The goal is to make the total duration of songs in each concert as close as possible.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute': These indicate the duration of each type of song.\n    'minimize the absolute difference': This means the difference between the total durations of the two concerts should be as small as possible.\n\n# [degree adverb] \n    'minimal': Refers to the smallest possible difference in durations between the two concerts.\n\n# [code logic]\n    The steps \"Calculate the total duration of all songs\" and \"Determine the target duration for each concert\" can be implemented simultaneously as they both involve calculations based on the input values a, b, and c.\n\n# [edge case] \n    1 0 0 = 1\n    Explanation: With only one one-minute song, the best we can do is assign it to one concert, resulting in a difference of 1 minute.\n    \n    0 0 0 = 0\n    Explanation: If there are no songs, the difference is naturally 0 as both concerts have a duration of 0.\n    \n    1 1 1 = 0\n    Explanation: As given in the example, one possible distribution is one one-minute song and one two-minute song in one concert, and one three-minute song in the other, resulting in a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the total number of songs is very small or zero.\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    if a + b + c == 1:\n        return max(a, b, c)\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If the total duration is odd, the minimal difference is 1\n        if total_duration % 2 != 0:\n            results.append(1)\n        else:\n            results.append(0)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    \n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the total duration of all songs.\",\n      \"steps\": [\n        \"Multiply the number of one-minute songs by 1 to get their total duration.\",\n        \"Multiply the number of two-minute songs by 2 to get their total duration.\",\n        \"Multiply the number of three-minute songs by 3 to get their total duration.\",\n        \"Sum the durations of all song types to get the total duration.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the target duration for each concert.\",\n      \"steps\": [\n        \"Divide the total duration by 2 to get the target duration for each concert.\",\n        \"Consider both floor and ceiling values of the division to handle cases where the total duration is odd.\"\n      ]\n    },\n    {\n      \"description\": \"Distribute songs between two concerts to minimize the difference.\",\n      \"steps\": [\n        \"Use a greedy or dynamic programming approach to distribute songs such that the absolute difference between the two concerts' durations is minimized.\",\n        \"Iterate through possible distributions and calculate the duration of each concert.\",\n        \"Track the minimal difference encountered during the distribution process.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, read the number of one-minute, two-minute, and three-minute songs.\",\n    \"Calculate the total duration of all songs.\",\n    \"Determine the target duration for each concert.\",\n    \"Distribute songs between two concerts to minimize the difference.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concert': refers to the grouping of songs into two separate events.\n    'duration': refers to the total time of songs in each concert.\n    'absolute difference': refers to the non-negative difference between the durations of the two concerts.\n\n# [phrase showing quantity relationship]\n    'minimize the absolute difference': means to make the difference between the durations of the two concerts as small as possible.\n    'sum of durations': means adding up the durations of all songs in a concert.\n\n# [degree adverb]\n    'minimal': means the smallest possible difference between the durations of the two concerts.\n\n# [code logic]\n    The steps for calculating total duration and determining target duration should be considered simultaneously. \n    \"Calculate the total duration of all songs\" and \"Determine the target duration for each concert\" can be done in one code block as they are directly related.\n\n# [edge case]\n    1 0 0 = 1\n    Explanation: With only one one-minute song, the difference between the two concerts is 1 since one concert will have the song and the other will have none.\n    \n    0 0 0 = 0\n    Explanation: With no songs, both concerts have a duration of 0, so the difference is 0.\n    \n    1 1 0 = 1\n    Explanation: With one one-minute song and one two-minute song, the best distribution is one song per concert, resulting in a difference of 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the total duration is odd.\n        if total_duration % 2 != 0:\n            # Handle odd total duration by considering both floor and ceiling values\n            target_duration_floor = total_duration // 2\n            target_duration_ceiling = target_duration_floor + 1\n            # Implement logic to minimize difference using both target durations\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        target_duration_floor = total_duration // 2\n        target_duration_ceiling = target_duration_floor + (total_duration % 2)\n\n        # Use dynamic programming to find the closest possible sum to target_duration_floor\n        possible_sums = {0}\n        for _ in range(a):\n            possible_sums = {x + 1 for x in possible_sums} | possible_sums\n        for _ in range(b):\n            possible_sums = {x + 2 for x in possible_sums} | possible_sums\n        for _ in range(c):\n            possible_sums = {x + 3 for x in possible_sums} | possible_sums\n\n        # Find the minimal difference using both target durations\n        min_diff = float('inf')\n        for sum1 in possible_sums:\n            sum2 = total_duration - sum1\n            min_diff = min(min_diff, abs(sum1 - sum2))\n\n        results.append(min_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, false, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 496, "prompt": "Luntik has decided to try singing. He has a one-minute songs. He also has b two-minute songs and c three-minute songs and wants to distribute all songs into two concerts so that each song must be part of only one concert to minimize the absolute difference between the durations of the concerts as much as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "mutate_method": "expand_one2two", "save_node": true, "parent_index": 238}
