{"name": "1607_D. Blue-Red Permutation", "description": "You are given an array of integers a of length n. The elements of the array can be either different or the same. \n\nEach element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step:\n\n  * either you can select any blue element and decrease its value by 1; \n  * or you can select any red element and increase its value by 1. \n\n\n\nSituations in which there are no elements of some color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable.\n\nDetermine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?\n\nIn other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of input data sets in the test.\n\nThe description of each set of input data consists of three lines. The first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 \u2264 a_i \u2264 10^9) \u2014 the array elements themselves.\n\nThe third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.\n\nIt is guaranteed that the sum of n over all input sets does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.\n\nYou can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).\n\nExample\n\nInput\n\n\n8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n\n\nOutput\n\n\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n\nNote\n\nIn the first test case of the example, the following sequence of moves can be performed:\n\n  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; \n  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. \n\n\n\nWe got that a is a permutation. Hence the answer is YES.", "tags": ["greedy", "math", "sortings"], "difficulty": 10, "id": 1607, "sample_io": [{"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}], "test_list": [{"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n2 2 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 3\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -1\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n2 1 4 2 5\nRBRRB\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 7 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nNO\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 1\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n4 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n0 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 2\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n6 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n2 2 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nNO\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n0 1 5 1 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nNO\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 0 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n0 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 1 5 2\nRBRB\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n0 2 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 10\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 2 -1\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 7 2 0\nRBRRB\n5\n5 1 3 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 2\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nNO\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n2 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 2 3\nRBRRB\n5\n0 1 5 1 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBBRR\n2\n1 1\nBB\n5\n3 1 4 2 2\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 2 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nNO\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nRBRB\n2\n1 1\nBB\n5\n3 0 4 2 2\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nNO\nNO\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 2\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 6 1 4\nRBRRB\n5\n5 1 5 1 10\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 10\nRBRRB\n5\n5 2 5 1 7\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 0 -1\nRRRR\n", "output": ["YES\nNO\nYES\nNO\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n0 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nNO\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n2 1 4 2 5\nRBRRB\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 7 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nNO\nNO\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 2\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nRBRB\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nYES\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 2\nBB\n5\n3 1 8 2 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 6 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 0 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n0 -2\nRB\n4\n-1 -1 4 0\nRRRR\n", "output": ["YES\nNO\nNO\nYES\nYES\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 1 5 2\nRBRB\n2\n1 2\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n0 2 -1 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nYES\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBBRR\n2\n1 1\nBB\n5\n3 1 4 2 2\nRBRRB\n5\n8 1 3 1 3\nRBRRB\n5\n5 1 5 2 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nNO\nNO\nYES\n"]}, {"input": "8\n4\n1 2 6 1\nBRBR\n2\n1 2\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 10\nRBRRB\n5\n5 2 5 1 7\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 0 -1\nRRRR\n", "output": ["YES\nYES\nYES\nNO\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 10\nRBRRB\n5\n3 2 5 1 7\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 0 -1\nRRRR\n", "output": ["YES\nNO\nYES\nNO\nYES\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n2 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n2 1 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 5 1 3\nRBRRB\n5\n5 1 4 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-1 -1 8 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nNO\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 6 9\nRBRRB\n5\n3 1 3 1 1\nRBRRB\n5\n5 1 0 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n0 -2\nRB\n4\n-1 -1 4 0\nRRRR\n", "output": ["YES\nNO\nNO\nNO\nYES\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nRBRB\n2\n1 1\nBB\n5\n3 0 4 2 5\nRBRRB\n5\n1 1 3 1 1\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-1 -1 8 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nNO\n"]}, {"input": "8\n4\n1 2 5 2\nRBRB\n2\n1 1\nBB\n5\n3 1 4 2 2\nRBRRB\n5\n0 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 6 1\nBRBR\n2\n1 2\nBB\n5\n3 1 7 2 3\nRBRRB\n5\n3 1 6 1 10\nRBRRB\n5\n5 2 5 1 7\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 0 -1\nRRRR\n", "output": ["YES\nYES\nNO\nNO\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 1 4 3\nRBRRB\n5\n3 1 6 0 5\nRBRRB\n5\n5 2 4 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -2\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 0\nRBRRB\n5\n0 1 6 1 10\nRBRRA\n5\n5 2 5 1 7\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 0 -1\nRRRR\n", "output": ["YES\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n7 1 3 1 3\nRBRRB\n5\n5 1 2 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 0 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nNO\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n2 1\nBB\n5\n3 0 4 2 3\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nBRRBR\n4\n3 2 2 2\nBRBR\n2\n1 -1\nBR\n4\n-2 -1 2 -1\nRRRR\n", "output": ["NO\nYES\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 4\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n1 2 1 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -2\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n1 1 5 2\nBRBR\n2\n1 2\nBB\n5\n3 1 4 2 10\nBRRBR\n5\n4 1 6 1 4\nRBRRB\n5\n5 1 5 1 10\nRBRRA\n4\n2 2 2 3\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n2 1 4 2 5\nRBRRB\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 10\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n2 1 4 2 5\nRBRRB\n5\n2 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 0 4\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nRRBB\n2\n1 1\nBB\n5\n3 1 4 3 10\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 0 4\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nRRBB\n2\n1 1\nBB\n5\n3 1 4 3 10\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -1\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 7 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 9 1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 4 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 0 4\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n0 2 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n0 1 3 1 3\nRBRRB\n5\n5 1 9 1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 4 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 3\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nBRRBR\n5\n4 1 3 0 4\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n2 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n0 1 3 1 3\nRBRRB\n5\n5 1 9 0 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 2 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n1 1 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n0 1 3 1 3\nRBRRB\n5\n5 1 9 0 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 1 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n0 1 3 1 3\nRBRRB\n5\n5 1 9 -1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -1\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -1\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -1\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 3\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 0\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 0\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 0\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 4 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 0\nRBRRB\n5\n5 1 6 0 5\nRBRRB\n5\n5 4 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 5 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n1 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nBRRBR\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 4\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 10\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 3 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 5 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRRBBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nRRBB\n2\n1 1\nBB\n5\n3 1 4 3 10\nRBRRB\n5\n3 1 6 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 1 4 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 6 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 0 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n3 1 3 0 4\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nRRBB\n2\n1 1\nBB\n5\n3 1 4 3 10\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 1 2\nBRBR\n2\n1 -1\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 7 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 0 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 0 1 3\nRBRRB\n5\n5 1 9 1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 4 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 0 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n5 1 4 2 5\nBRRBR\n5\n4 1 3 0 4\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 1 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n0 2 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 1\nRBBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n0 1 3 1 3\nRBRRB\n5\n5 1 9 1 5\nRBRRA\n4\n0 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n2 4 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n1 2 2 3\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 0\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nBRRBR\n5\n4 1 3 0 4\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 6 1\nBRBR\n2\n0 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n0 1 3 1 3\nRBRRB\n5\n5 1 9 0 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-4 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 2\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 2 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nRBRB\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n3 3 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 10\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -1\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -2\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 1\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 7 2 0\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 0\nRBRRB\n5\n5 1 6 1 6\nRBRRB\n5\n5 4 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n6 0 4 2 0\nRBRRB\n5\n5 1 6 0 5\nRBRRB\n5\n5 4 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 5 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-1 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 5\nRBRRB\n5\n1 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nBRRBR\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 0 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n4 1 5 1 5\nRBRRB\n4\n2 2 2 3\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 4\nRBBRR\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 2\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 5 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRQB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 3 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRRBBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 2\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-4 -1 0 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 0 4 7 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 0 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 0 1 3\nRBRRB\n5\n5 1 9 1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-3 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 4 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 0 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 0 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nRBBR\n2\n1 1\nBB\n5\n5 1 4 2 5\nBRRBR\n5\n4 1 3 0 4\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 1\nRBBR\n2\n1 1\nBB\n5\n3 1 5 2 3\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 0\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nBRRBR\n5\n4 1 3 0 4\nRBRRB\n5\n5 1 4 1 2\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 2 3\nRBRRB\n5\n0 1 5 1 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nNO\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n0 1 3 1 6\nRBRRB\n5\n5 1 9 0 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-4 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBBRR\n2\n1 1\nBB\n5\n3 1 4 2 2\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 2 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 1 2 3\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -2\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 1\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 3 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 0\nRBRRB\n5\n5 1 6 1 6\nRBRRB\n5\n5 4 5 1 5\nRBRRB\n4\n3 2 2 1\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 5 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-1 -1 4 -1\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nRBRB\n2\n1 1\nBB\n5\n3 0 4 2 5\nRBRRB\n5\n1 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nBRRBR\n4\n2 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 0 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n4 1 5 1 5\nBRRBR\n4\n2 2 2 3\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 3\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 4\nRBBRR\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n0 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 5 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRQB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 3 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRRBBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nRBRB\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 0 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n0 -2\nRB\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 2\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 10\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-4 -1 0 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 0 4 7 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 -1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 9 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 0 1 3\nRBRRB\n5\n5 1 9 1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-3 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n4 4 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 0 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 0 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 1 5 2\nRBRB\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n0 2 -1 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 1\nRBBR\n2\n1 1\nBB\n5\n3 1 5 2 3\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 5 1 8\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 0\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nBRRBR\n5\n4 1 3 0 4\nRBRRB\n5\n5 1 4 1 2\nRBRRB\n4\n3 2 2 4\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n0 1 3 1 6\nRBRRB\n5\n5 1 9 0 5\nRBRRA\n4\n2 3 2 2\nBRBR\n2\n1 -3\nBR\n4\n-4 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 10\nRBRRB\n5\n5 2 5 1 7\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 2 -1\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 1 4 3\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -2\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n5 0 4 2 1\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 3 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 5 2 0\nRBRRB\n5\n5 1 3 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 0\nRBRRB\n5\n5 1 6 2 6\nRBRRB\n5\n5 4 5 1 5\nRBRRB\n4\n3 2 2 1\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nRBRB\n2\n1 1\nBB\n5\n3 0 4 2 5\nRBRRB\n5\n1 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-1 -1 4 0\nRRRR\n", "output": ["NO\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n4 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n4 1 5 1 5\nBRRBR\n4\n2 2 2 3\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 3\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 4\nRBBRR\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -2 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n0 1\nBB\n5\n5 1 4 2 5\nRBRRB\n5\n3 1 5 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRQB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 3 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 1\nRRBBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nRBRB\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 0 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n0 -2\nRB\n4\n-1 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 2\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 5 1 4\nRBRRB\n5\n5 1 5 1 10\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 4 2 2\nBRBR\n2\n1 -2\nRB\n4\n-4 -1 0 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 0 4 7 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 -1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n4 4 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 0\nRBRRB\n5\n5 1 5 0 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 0 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 1 5 2\nRBRB\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n-1 2 -1 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 0\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nBRRBR\n5\n4 1 2 0 4\nRBRRB\n5\n5 1 4 1 2\nRBRRB\n4\n3 2 2 4\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n2 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n0 1 5 1 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBBRR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n0 1 3 1 6\nRBRRB\n5\n5 1 9 0 5\nRBRRA\n4\n2 3 2 2\nBRBR\n2\n1 -3\nBR\n4\n-4 -1 4 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 10\nRBRRB\n5\n5 2 5 1 7\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 0 -1\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 1 4 3\nRBRRB\n5\n5 1 6 0 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -2\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 5 2 0\nRBRRB\n5\n5 1 3 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 1\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 0\nRBRRB\n5\n5 0 6 2 6\nRBRRB\n5\n5 4 5 1 5\nRBRRB\n4\n3 2 2 1\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRRB\n2\n1 1\nBB\n5\n3 0 4 2 5\nRBRRB\n5\n1 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-1 -1 4 0\nRRRR\n", "output": ["NO\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 3\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 2 4\nRBBRR\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -2 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 3 2\nBRBR\n2\n0 1\nBB\n5\n5 1 4 2 5\nRBRRB\n5\n3 1 5 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRQB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 3 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 1\nRRBBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nRBRB\n2\n1 -3\nBR\n4\n-2 -1 4 1\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 0 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n0 -4\nRB\n4\n-1 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nNO\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 1 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 4 2 2\nBRBR\n2\n1 -2\nRB\n4\n-4 -1 0 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 0 4 7 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 -2 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n4 4 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 1\nRBRRB\n5\n5 1 5 0 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 0 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 0\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nBRRBR\n5\n4 1 2 0 4\nRBRRB\n5\n5 1 4 1 2\nRBRRB\n4\n3 2 2 4\nBRBR\n2\n1 -2\nBR\n4\n-1 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBBRR\n2\n1 1\nBB\n5\n6 1 4 2 5\nBRRBR\n5\n0 1 3 1 6\nRBRRB\n5\n5 1 9 0 5\nRBRRA\n4\n2 3 2 2\nBRBR\n2\n1 -3\nBR\n4\n-4 -1 4 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 5 2 0\nRBRRB\n5\n5 1 3 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 1\nBRBR\n2\n2 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 9\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 0 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n0 -4\nRB\n4\n-1 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 4\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 6 1 4\nRBRRB\n5\n5 1 5 1 10\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\n"]}], "task_id": "codecontest/101", "repair_prompt": ["You are given an array of integers a of length n; the elements of the array can be either different or the same, and each element of the array is colored either blue or red, with no unpainted elements. One of the two operations described below can be applied to an array in a single step:\n\n  * either you can select any blue element and decrease its value by 1; \n  * or you can select any red element and increase its value by 1.\n\nSituations in which there are no elements of some color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable.\n\nDetermine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?\n\nIn other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of input data sets in the test.\n\nThe description of each set of input data consists of three lines. The first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 \u2264 a_i \u2264 10^9) \u2014 the array elements themselves.\n\nThe third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.\n\nIt is guaranteed that the sum of n over all input sets does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.\n\nYou can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).\n\nExample\n\nInput\n\n\n8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n\n\nOutput\n\n\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n\nNote\n\nIn the first test case of the example, the following sequence of moves can be performed:\n\n  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; \n  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. \n\n\n\nWe got that a is a permutation. Hence the answer is YES.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "You are given an array of integers a of length n; the elements of the array can be either different or the same. Each element of the array is colored either blue or red, with no unpainted elements. One of the two operations described below can be applied to an array in a single step:\n\n  * either you can select any blue element and decrease its value by 1; \n  * or you can select any red element and increase its value by 1.\n\nSituations in which there are no elements of some color at all are also possible. For instance, if the entire array is colored blue or red, then one of the operations becomes unavailable.\n\nDetermine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?\n\nIn other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of input data sets in the test.\n\nThe description of each set of input data consists of three lines. The first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 \u2264 a_i \u2264 10^9) \u2014 the array elements themselves.\n\nThe third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.\n\nIt is guaranteed that the sum of n over all input sets does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.\n\nYou can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).\n\nExample\n\nInput\n\n\n8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n\n\nOutput\n\n\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n\nNote\n\nIn the first test case of the example, the following sequence of moves can be performed:\n\n  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; \n  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. \n\n\n\nWe got that a is a permutation. Hence the answer is YES.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "You are given an array of integers a of length n; the elements of the array can be either different or the same, and each element of the array is colored either blue or red, with no unpainted elements. Either you can select any blue element and decrease its value by 1, or you can select any red element and increase its value by 1 in a single step. Situations in which there are no elements of some color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable. Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n? In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of input data sets in the test.\n\nThe description of each set of input data consists of three lines. The first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 \u2264 a_i \u2264 10^9) \u2014 the array elements themselves.\n\nThe third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.\n\nIt is guaranteed that the sum of n over all input sets does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.\n\nYou can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).\n\nExample\n\nInput\n\n\n8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n\n\nOutput\n\n\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n\nNote\n\nIn the first test case of the example, the following sequence of moves can be performed:\n\n  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; \n  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. \n\n\n\nWe got that a is a permutation. Hence the answer is YES.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def can_form_permutation(n, a, colors):\n    blue_min = 1\n    red_max = n\n    for i in range(n):\n        if colors[i] == 'B' and a[i] < blue_min:\n            return \"NO\"\n        if colors[i] == 'R' and a[i] > red_max:\n            return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        results.append(can_form_permutation(n, a, colors))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def can_transform_to_permutation(n, a, colors):\n    blue_elements = []\n    red_elements = []\n\n    # Separate elements into blue and red lists\n    for i in range(n):\n        if colors[i] == 'B':\n            blue_elements.append(a[i])\n        else:\n            red_elements.append(a[i])\n\n    # Sort blue in non-decreasing order and red in non-increasing order\n    blue_elements.sort()\n    red_elements.sort(reverse=True)\n\n    # Check blue elements\n    for i, value in enumerate(blue_elements):\n        if value < i + 1:\n            return \"NO\"\n\n    # Check red elements\n    for i, value in enumerate(red_elements):\n        if value > n - i:\n            return \"NO\"\n\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n\n        result = can_transform_to_permutation(n, a, colors)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_permutation(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, a, colors = case\n        blue = []\n        red = []\n        \n        for i in range(n):\n            if colors[i] == 'B':\n                blue.append(a[i])\n            else:\n                red.append(a[i])\n        \n        blue.sort()\n        red.sort(reverse=True)\n        \n        possible = True\n        \n        for i in range(len(blue)):\n            if blue[i] < 1 + i:\n                possible = False\n                break\n        \n        for i in range(len(red)):\n            if red[i] > n - i:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        test_cases.append((n, a, colors))\n    \n    results = can_form_permutation(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_permutation(n, a, colors):\n    # Separate the elements into blue and red lists based on their color\n    blue_elements = []\n    red_elements = []\n    \n    for i in range(n):\n        if colors[i] == 'B':\n            blue_elements.append(a[i])\n        else:\n            red_elements.append(a[i])\n    \n    # Sort the blue and red elements\n    blue_elements.sort()\n    red_elements.sort()\n    \n    # Check if blue elements can be decreased to fit within the range [1, n]\n    for i, value in enumerate(blue_elements):\n        if value > i + 1:\n            return False\n    \n    # Check if red elements can be increased to fit within the range [1, n]\n    for i, value in enumerate(red_elements):\n        if value < n - len(red_elements) + i + 1:\n            return False\n    \n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        if can_form_permutation(n, a, colors):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_permutation(n, a, colors):\n    blue_elements = []\n    red_elements = []\n    \n    for i in range(n):\n        if colors[i] == 'B':\n            blue_elements.append(a[i])\n        else:\n            red_elements.append(a[i])\n    \n    blue_elements.sort()\n    red_elements.sort(reverse=True)\n    \n    for i in range(1, n + 1):\n        if blue_elements and blue_elements[0] >= i:\n            blue_elements.pop(0)\n        elif red_elements and red_elements[0] <= i:\n            red_elements.pop(0)\n        else:\n            return \"NO\"\n    \n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        result = can_form_permutation(n, a, colors)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_permutation(n, array, colors):\n    blue_elements = [array[i] for i in range(n) if colors[i] == 'B']\n    red_elements = [array[i] for i in range(n) if colors[i] == 'R']\n    \n    # Sort blue elements in descending order and red elements in ascending order\n    blue_elements.sort(reverse=True)\n    red_elements.sort()\n    \n    # Check if blue elements can be decreased to fit within [1, n]\n    for i in range(len(blue_elements)):\n        if blue_elements[i] > n - i:\n            return False\n    \n    # Check if red elements can be increased to fit within [1, n]\n    for i in range(len(red_elements)):\n        if red_elements[i] < i + 1:\n            return False\n    \n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        if can_form_permutation(n, array, colors):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_transform_to_permutation(n, a, colors):\n    # We need to check if we can transform the array into a permutation of 1 to n\n    # by using the operations allowed on blue and red elements.\n    \n    # Sort the elements along with their colors\n    elements = sorted(zip(a, colors))\n    \n    for i in range(n):\n        value, color = elements[i]\n        target = i + 1  # The target value in a permutation of 1 to n\n        \n        if color == 'B':\n            # Blue elements can only be decreased\n            if value < target:\n                return False\n        elif color == 'R':\n            # Red elements can only be increased\n            if value > target:\n                return False\n    \n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        if can_transform_to_permutation(n, a, colors):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_permutation(n, a, colors):\n    # Separate the elements based on their colors\n    blue_elements = []\n    red_elements = []\n    \n    for i in range(n):\n        if colors[i] == 'B':\n            blue_elements.append(a[i])\n        else:\n            red_elements.append(a[i])\n    \n    # Sort the blue elements in ascending order and red elements in descending order\n    blue_elements.sort()\n    red_elements.sort(reverse=True)\n    \n    # Check if we can form a permutation from 1 to n\n    for i in range(1, n + 1):\n        # Check if there is a blue element that can be decreased to i\n        if blue_elements and blue_elements[0] <= i:\n            blue_elements.pop(0)\n        # Check if there is a red element that can be increased to i\n        elif red_elements and red_elements[0] >= i:\n            red_elements.pop(0)\n        else:\n            return \"NO\"\n    \n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        result = can_form_permutation(n, a, colors)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_permutation(n, a, colors):\n    # Create lists to track the minimum and maximum possible values for each position\n    min_possible = [1] * n\n    max_possible = [n] * n\n    \n    # Iterate over the array elements and their colors\n    for i in range(n):\n        if colors[i] == 'B':\n            # Blue elements can be decreased, so they must be >= 1\n            if a[i] < min_possible[i]:\n                return False\n        elif colors[i] == 'R':\n            # Red elements can be increased, so they must be <= n\n            if a[i] > max_possible[i]:\n                return False\n    \n    # Sort the array and check if it can form a valid permutation\n    a_sorted = sorted(a)\n    for i in range(n):\n        if a_sorted[i] < 1 or a_sorted[i] > n:\n            return False\n        if colors[i] == 'B' and a_sorted[i] > i + 1:\n            return False\n        if colors[i] == 'R' and a_sorted[i] < i + 1:\n            return False\n    \n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        if can_form_permutation(n, a, colors):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_permutation(n, a, colors):\n    min_blue = float('inf')\n    max_red = float('-inf')\n    \n    for i in range(n):\n        if colors[i] == 'B':\n            min_blue = min(min_blue, a[i])\n        else:\n            max_red = max(max_red, a[i])\n    \n    # Check if blue elements can cover 1 to min_blue and red elements can cover max_red to n\n    if min_blue >= 1 and max_red <= n:\n        return 'YES'\n    return 'NO'\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        results.append(can_form_permutation(n, a, colors))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_permutation(n, a, colors):\n    blue_min = 1\n    red_max = n\n    for i in range(n):\n        if colors[i] == 'B' and a[i] < blue_min:\n            return \"NO\"\n        if colors[i] == 'R' and a[i] > red_max:\n            return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        results.append(can_form_permutation(n, a, colors))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, the array of integers a, and the string of colors.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array can be transformed into a permutation of numbers from 1 to n.\",\n      \"steps\": [\n        \"For each test case, identify the minimum and maximum values that can be achieved by the blue and red elements respectively.\",\n        \"Check if the blue elements can be decreased to cover all numbers from 1 to the smallest number in the permutation.\",\n        \"Check if the red elements can be increased to cover all numbers from the largest number in the permutation to n.\",\n        \"Ensure that the combination of blue and red elements can cover all numbers from 1 to n without gaps.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print 'YES' if the array can be transformed into a permutation, otherwise print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, analyze the array and color information to determine if a valid permutation can be formed.\",\n    \"Implement logic to check the feasibility of transforming the array into a permutation using the allowed operations.\",\n    \"Output the result for each test case based on the analysis.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of numbers from 1 to n means that the array should contain all integers from 1 to n exactly once, in any order.\n\n# [phrase showing quantity relationship]\n    '0 or more steps': This indicates that the transformation can involve any number of steps, including none.\n    'from 1 to n': This specifies the range of numbers that must be present in the permutation.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps \"Check if the blue elements can be decreased to cover all numbers from 1 to the smallest number in the permutation\" and \"Check if the red elements can be increased to cover all numbers from the largest number in the permutation to n\" should be considered simultaneously. This can be done by iterating through the array and checking both conditions in a single pass.\n\n# [edge case] \n    Test case with all elements blue and already a permutation: \n    Input: 3, [1, 2, 3], 'BBB'\n    Expected output: YES\n    Explanation: The array is already a permutation of numbers from 1 to 3.\n\n    Test case with all elements red and already a permutation:\n    Input: 3, [1, 2, 3], 'RRR'\n    Expected output: YES\n    Explanation: The array is already a permutation of numbers from 1 to 3.\n\n    Test case with elements that cannot be transformed:\n    Input: 3, [1, 1, 1], 'BRB'\n    Expected output: NO\n    Explanation: The array cannot be transformed into a permutation of numbers from 1 to 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    ```python\n    def can_form_permutation(n, a, colors):\n        blue_min = 1\n        red_max = n\n        for i in range(n):\n            if colors[i] == 'B' and a[i] < blue_min:\n                return \"NO\"\n            if colors[i] == 'R' and a[i] > red_max:\n                return \"NO\"\n        return \"YES\"\n    ```\n\nYES", "Round_0": {"code": "def can_form_permutation(n, a, colors):\n    blue_min = 1\n    red_max = n\n    for i in range(n):\n        if colors[i] == 'B' and a[i] < blue_min:\n            return \"NO\"\n        if colors[i] == 'R' and a[i] > red_max:\n            return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        results.append(can_form_permutation(n, a, colors))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the array of integers and their corresponding colors.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the length of the array.\",\n        \"Read the array of integers a of length n.\",\n        \"Read the string of colors of length n, where each character is either 'B' or 'R'.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array can be transformed into a permutation of numbers from 1 to n using the allowed operations.\",\n      \"steps\": [\n        \"For each test case, initialize two lists: one for blue elements and one for red elements.\",\n        \"Iterate through the array and separate the elements into the blue list and red list based on their colors.\",\n        \"Sort the blue list in non-decreasing order and the red list in non-increasing order.\",\n        \"Check if each element in the blue list can be decreased to a value between 1 and its index in the permutation (inclusive).\",\n        \"Check if each element in the red list can be increased to a value between its index in the permutation and n (inclusive).\",\n        \"If both conditions are satisfied, the array can be transformed into a permutation; otherwise, it cannot.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print 'YES' if the array can be transformed into a permutation, otherwise print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, separate the elements into blue and red lists based on their colors.\",\n    \"Sort the blue list in non-decreasing order and the red list in non-increasing order.\",\n    \"Check if the elements in the blue list can be decreased to fit the permutation requirements.\",\n    \"Check if the elements in the red list can be increased to fit the permutation requirements.\",\n    \"Output 'YES' if the array can be transformed into a permutation, otherwise output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of numbers from 1 to n means that the array should contain all integers from 1 to n exactly once, in any order.\n\n# [phrase showing quantity relationship]\n    'from 1 to n': This indicates that the array should contain all integers between 1 and n inclusive, each exactly once.\n    Implementation: Ensure that after operations, the array contains all numbers from 1 to n.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for sorting and checking conditions for blue and red lists should be considered simultaneously.\n    Explanation: Sorting the blue list in non-decreasing order and the red list in non-increasing order should be done before checking the conditions for transformation into a permutation. This ensures that the elements are in the correct order for comparison against their respective indices.\n\n# [edge case]\n    Case 1: n = 1, a = [1], colors = ['B']\n    Expected output: YES\n    Explanation: The array already contains the permutation [1].\n    \n    Case 2: n = 2, a = [2, 1], colors = ['R', 'B']\n    Expected output: YES\n    Explanation: The red element can be increased to 2, and the blue element can be decreased to 1, forming the permutation [1, 2].\n    \n    Case 3: n = 3, a = [3, 3, 3], colors = ['B', 'B', 'B']\n    Expected output: NO\n    Explanation: All elements are blue and cannot be decreased to form the permutation [1, 2, 3].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and checking conditions will handle these cases appropriately.\n\nYES", "Round_0": {"code": "def can_transform_to_permutation(n, a, colors):\n    blue_elements = []\n    red_elements = []\n\n    # Separate elements into blue and red lists\n    for i in range(n):\n        if colors[i] == 'B':\n            blue_elements.append(a[i])\n        else:\n            red_elements.append(a[i])\n\n    # Sort blue in non-decreasing order and red in non-increasing order\n    blue_elements.sort()\n    red_elements.sort(reverse=True)\n\n    # Check blue elements\n    for i, value in enumerate(blue_elements):\n        if value < i + 1:\n            return \"NO\"\n\n    # Check red elements\n    for i, value in enumerate(red_elements):\n        if value > n - i:\n            return \"NO\"\n\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n\n        result = can_transform_to_permutation(n, a, colors)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the array length, the array elements, and their corresponding colors.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the length of the array.\",\n        \"Read the array of integers a of length n.\",\n        \"Read the string of colors of length n, consisting of 'B' and 'R'.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array can be transformed into a permutation of numbers from 1 to n using the allowed operations.\",\n      \"steps\": [\n        \"For each test case, initialize two lists: one for blue elements and one for red elements.\",\n        \"Iterate through the array and separate elements into blue and red lists based on their color.\",\n        \"Sort the blue list in non-decreasing order and the red list in non-increasing order.\",\n        \"Check if the blue elements can be decreased to fit into the range [1, n] and if the red elements can be increased to fit into the range [1, n].\",\n        \"Ensure that no blue element is less than 1 and no red element is greater than n after the operations.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if the array can be transformed into a permutation, output 'YES'. Otherwise, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, separate the array elements into blue and red lists based on their color.\",\n    \"Sort the blue list in non-decreasing order and the red list in non-increasing order.\",\n    \"Check if the blue elements can be decreased and the red elements can be increased to form a permutation of numbers from 1 to n.\",\n    \"Output 'YES' if the transformation is possible, otherwise output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of numbers from 1 to n means that the array should contain all integers from 1 to n exactly once, in any order.\n\n# [phrase showing quantity relationship]\n    'from 1 to n': This indicates the range of numbers that should be present in the array after transformation. In code, this can be implemented by checking if the transformed array contains all numbers from 1 to n.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps of sorting the blue list in non-decreasing order and the red list in non-increasing order should be considered simultaneously with checking if the elements can be adjusted to fit into the range [1, n]. This can be done by iterating through the sorted lists and checking the conditions in one code block.\n\n# [edge case]\n    Test case with all elements already being a permutation: \n    Input: 3, [1, 2, 3], 'BRB'\n    Expected output: YES\n    Explanation: The array is already a permutation of numbers from 1 to 3.\n\n    Test case with all elements colored the same:\n    Input: 3, [3, 3, 3], 'RRR'\n    Expected output: NO\n    Explanation: All elements are the same and cannot be adjusted to form a permutation of numbers from 1 to 3.\n\n    Test case with negative numbers:\n    Input: 3, [-1, -2, -3], 'BRB'\n    Expected output: NO\n    Explanation: Negative numbers cannot be adjusted to form a permutation of numbers from 1 to 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where elements are already a permutation or all elements are colored the same.\n    ```\n    if all elements are already a permutation:\n        return 'YES'\n    if all elements are colored the same and cannot be adjusted:\n        return 'NO'\n    ```\n\nYES", "Round_0": {"code": "def can_form_permutation(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, a, colors = case\n        blue = []\n        red = []\n        \n        for i in range(n):\n            if colors[i] == 'B':\n                blue.append(a[i])\n            else:\n                red.append(a[i])\n        \n        blue.sort()\n        red.sort(reverse=True)\n        \n        possible = True\n        \n        for i in range(len(blue)):\n            if blue[i] < 1 + i:\n                possible = False\n                break\n        \n        for i in range(len(red)):\n            if red[i] > n - i:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        test_cases.append((n, a, colors))\n    \n    results = can_form_permutation(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, the array of integers a, and the string of colors.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array can be transformed into a permutation of numbers from 1 to n.\",\n      \"steps\": [\n        \"For each test case, identify the range of numbers needed for a valid permutation (1 to n).\",\n        \"Separate the elements of the array into two lists based on their color: blue and red.\",\n        \"Check if the blue elements can be decreased to fit within the range [1, n] and if the red elements can be increased to fit within the range [1, n].\",\n        \"Ensure that the final list of numbers can form a valid permutation of numbers from 1 to n.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print 'YES' if the array can be transformed into a valid permutation, otherwise print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, separate the elements into blue and red lists based on their color.\",\n    \"Check if the blue elements can be decreased and the red elements can be increased to form a valid permutation of numbers from 1 to n.\",\n    \"Output 'YES' or 'NO' for each test case based on whether a valid permutation can be formed.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this requirement, a permutation refers to a rearrangement of numbers such that each number from 1 to n appears exactly once in the array.\n\n# [phrase showing quantity relationship]\n    '0 or more steps': This means that the transformation can involve any number of operations, including none, to achieve the desired permutation.\n    'from 1 to n': This indicates that the target permutation should include all integers starting from 1 up to n, inclusive.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to checking if blue elements can be decreased and red elements can be increased should be considered simultaneously. This involves iterating through the array and checking each element's color and value to determine if it can be adjusted to fit within the required range [1, n]. This can be implemented using a single loop that processes both blue and red elements together.\n\n# [edge case] \n    Case 1: n = 1, a = [1], colors = \"B\"\n    Expected output: YES\n    Explanation: The array already contains the permutation [1], so no steps are needed.\n\n    Case 2: n = 3, a = [3, 3, 3], colors = \"RRR\"\n    Expected output: NO\n    Explanation: All elements are red and cannot be increased to form the permutation [1, 2, 3].\n\n    Case 3: n = 2, a = [2, 1], colors = \"BR\"\n    Expected output: YES\n    Explanation: The array can be transformed into [1, 2] by decreasing the blue element 2 to 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if blue elements can be decreased and red elements can be increased to fit within the range [1, n] should naturally handle these cases.\n\nYES", "Round_0": {"code": "def can_form_permutation(n, a, colors):\n    # Separate the elements into blue and red lists based on their color\n    blue_elements = []\n    red_elements = []\n    \n    for i in range(n):\n        if colors[i] == 'B':\n            blue_elements.append(a[i])\n        else:\n            red_elements.append(a[i])\n    \n    # Sort the blue and red elements\n    blue_elements.sort()\n    red_elements.sort()\n    \n    # Check if blue elements can be decreased to fit within the range [1, n]\n    for i, value in enumerate(blue_elements):\n        if value > i + 1:\n            return False\n    \n    # Check if red elements can be increased to fit within the range [1, n]\n    for i, value in enumerate(red_elements):\n        if value < n - len(red_elements) + i + 1:\n            return False\n    \n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        if can_form_permutation(n, a, colors):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, the array of integers a, and the string of colors.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array can be transformed into a permutation of numbers from 1 to n.\",\n      \"steps\": [\n        \"Separate the elements of the array into two lists based on their color: blue and red.\",\n        \"For blue elements, check if they can be decreased to fit within the range 1 to n.\",\n        \"For red elements, check if they can be increased to fit within the range 1 to n.\",\n        \"Ensure that the combined elements from both lists can form a permutation of numbers from 1 to n.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print 'YES' if the array can be transformed into a permutation, otherwise print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize a list to store results for each test case.\",\n    \"Iterate over each test case and perform the following:\",\n    \"Parse the input to extract n, array a, and color string.\",\n    \"Separate elements into blue and red lists based on color.\",\n    \"Check if blue elements can be decreased to fit within 1 to n.\",\n    \"Check if red elements can be increased to fit within 1 to n.\",\n    \"Verify if the combined elements can form a permutation of 1 to n.\",\n    \"Store 'YES' or 'NO' in the results list based on the verification.\",\n    \"Print each result from the results list.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of numbers from 1 to n means that the array should contain each number from 1 to n exactly once, in any order.\n\n# [phrase showing quantity relationship]\n    '0 or more steps': This indicates that the transformation can involve any number of steps, including none, to achieve the desired permutation.\n    Implementation: This means the code should allow for the possibility of no changes being needed if the array already meets the permutation criteria.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Check if blue elements can be decreased to fit within 1 to n\" and \"Check if red elements can be increased to fit within 1 to n\" should be considered simultaneously. This can be implemented by iterating through the array once and checking each element based on its color.\n\n# [edge case]\n    Case 1: n = 1, a = [1], colors = 'B' => YES\n    Explanation: The array already contains the permutation [1], so no steps are needed.\n    \n    Case 2: n = 3, a = [3, 3, 3], colors = 'RRR' => NO\n    Explanation: All elements are red and cannot be decreased, and they cannot form the permutation [1, 2, 3].\n    \n    Case 3: n = 2, a = [2, 1], colors = 'BR' => YES\n    Explanation: The array can be transformed into the permutation [1, 2] by decreasing the blue element 2 to 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling edge cases:\n    ```python\n    def can_form_permutation(n, a, colors):\n        blue_elements = []\n        red_elements = []\n        \n        for i in range(n):\n            if colors[i] == 'B':\n                blue_elements.append(a[i])\n            else:\n                red_elements.append(a[i])\n        \n        blue_elements.sort()\n        red_elements.sort(reverse=True)\n        \n        for i in range(1, n + 1):\n            if blue_elements and blue_elements[0] >= i:\n                blue_elements.pop(0)\n            elif red_elements and red_elements[0] <= i:\n                red_elements.pop(0)\n            else:\n                return \"NO\"\n        \n        return \"YES\"\n    ```\n\nYES", "Round_0": {"code": "def can_form_permutation(n, a, colors):\n    blue_elements = []\n    red_elements = []\n    \n    for i in range(n):\n        if colors[i] == 'B':\n            blue_elements.append(a[i])\n        else:\n            red_elements.append(a[i])\n    \n    blue_elements.sort()\n    red_elements.sort(reverse=True)\n    \n    for i in range(1, n + 1):\n        if blue_elements and blue_elements[0] >= i:\n            blue_elements.pop(0)\n        elif red_elements and red_elements[0] <= i:\n            red_elements.pop(0)\n        else:\n            return \"NO\"\n    \n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        result = can_form_permutation(n, a, colors)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the array length, the array elements, and their corresponding colors.\",\n      \"output\": \"A list of test cases, where each test case contains the array length, the array elements, and their colors.\"\n    },\n    {\n      \"description\": \"For each test case, determine if it is possible to transform the array into a permutation of numbers from 1 to n using the allowed operations.\",\n      \"output\": \"A boolean value indicating whether the transformation is possible for each test case.\"\n    },\n    {\n      \"description\": \"Output the result for each test case as 'YES' if the transformation is possible and 'NO' otherwise.\",\n      \"output\": \"A list of strings ('YES' or 'NO') corresponding to each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it to extract the number of test cases and the details for each test case.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Initialize two lists to separate the elements based on their colors: one for blue elements and one for red elements.\",\n    \"  b. Check if the blue elements can be decreased to fit within the range [1, n] and if the red elements can be increased to fit within the range [1, n].\",\n    \"  c. Ensure that the blue elements do not exceed their maximum allowable value and the red elements do not fall below their minimum allowable value.\",\n    \"  d. Verify if the combined elements can form a permutation of numbers from 1 to n.\",\n    \"Store the result ('YES' or 'NO') for each test case based on the feasibility of the transformation.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of numbers from 1 to n means that the array should contain all integers from 1 to n exactly once, in any order.\n\n# [phrase showing quantity relationship]\n    'from 1 to n': This indicates that the numbers should range from 1 to n, inclusive. In code, this can be implemented by checking if the transformed array contains all numbers from 1 to n without any duplicates or missing numbers.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Steps 2b and 2c should be considered simultaneously. \n    Explanation: When checking if blue elements can be decreased and red elements can be increased to fit within the range [1, n], both conditions need to be checked together to ensure that the final array can form a valid permutation.\n\n# [edge case] \n    Test case with all elements already forming a permutation: \n    Input: 3, [1, 2, 3], 'BRB'\n    Expected output: YES\n    Explanation: The array already forms a permutation of numbers from 1 to 3.\n\n    Test case with all elements colored the same and not forming a permutation:\n    Input: 3, [3, 3, 3], 'BBB'\n    Expected output: NO\n    Explanation: All elements are the same and cannot be transformed into a permutation of numbers from 1 to 3.\n\n    Test case with negative numbers:\n    Input: 3, [-1, -2, -3], 'RRR'\n    Expected output: NO\n    Explanation: Negative numbers cannot be transformed into a permutation of positive numbers from 1 to 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: \n    - Ensure that the transformation logic checks for negative numbers and handles cases where all elements are the same.\n    - Implement checks to ensure that the final array contains all numbers from 1 to n without duplicates or missing numbers.\n\n    (code for handling the edge case)\n    ```python\n    def can_form_permutation(n, array, colors):\n        blue_elements = [array[i] for i in range(n) if colors[i] == 'B']\n        red_elements = [array[i] for i in range(n) if colors[i] == 'R']\n        \n        # Check if blue elements can be decreased to fit within [1, n]\n       ", "Round_0": {"code": "def can_form_permutation(n, array, colors):\n    blue_elements = [array[i] for i in range(n) if colors[i] == 'B']\n    red_elements = [array[i] for i in range(n) if colors[i] == 'R']\n    \n    # Sort blue elements in descending order and red elements in ascending order\n    blue_elements.sort(reverse=True)\n    red_elements.sort()\n    \n    # Check if blue elements can be decreased to fit within [1, n]\n    for i in range(len(blue_elements)):\n        if blue_elements[i] > n - i:\n            return False\n    \n    # Check if red elements can be increased to fit within [1, n]\n    for i in range(len(red_elements)):\n        if red_elements[i] < i + 1:\n            return False\n    \n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        if can_form_permutation(n, array, colors):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, the array of integers a, and the string of colors.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array can be transformed into a permutation of numbers from 1 to n.\",\n      \"steps\": [\n        \"Identify the minimum and maximum values that can be achieved by blue and red elements respectively.\",\n        \"Check if the blue elements can be decreased to cover all numbers from 1 to n.\",\n        \"Check if the red elements can be increased to cover all numbers from 1 to n.\",\n        \"Ensure that the transformation does not violate the constraints of the colors.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print 'YES' if the array can be transformed into a permutation, otherwise print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize a list to store results for each test case.\",\n    \"Iterate over each test case and parse the input data.\",\n    \"For each test case, determine if the array can be transformed into a permutation using the defined subproblems.\",\n    \"Store the result ('YES' or 'NO') for each test case in the results list.\",\n    \"Print each result from the results list.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of numbers from 1 to n means that the array should contain each number from 1 to n exactly once, in any order.\n\n# [phrase showing quantity relationship]\n    '0 or more steps': This means that it is possible to make no changes at all if the array is already a permutation, or make as many changes as needed to achieve the permutation.\n    'from 1 to n': This indicates that the array should contain all integers starting from 1 up to n.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps to check if the array can be transformed into a permutation should be considered simultaneously:\n    - \"Identify the minimum and maximum values that can be achieved by blue and red elements respectively.\"\n    - \"Check if the blue elements can be decreased to cover all numbers from 1 to n.\"\n    - \"Check if the red elements can be increased to cover all numbers from 1 to n.\"\n    These steps can be implemented in a single loop that iterates over the array and checks the conditions for each element based on its color.\n\n# [edge case]\n    Case 1: n = 1, a = [1], colors = \"B\" => YES\n    Explanation: The array already contains the permutation [1], no steps are needed.\n\n    Case 2: n = 2, a = [2, 1], colors = \"RR\" => NO\n    Explanation: Both elements are red, and we cannot decrease them to form the permutation [1, 2].\n\n    Case 3: n = 3, a = [3, 3, 3], colors = \"BBB\" => NO\n    Explanation: All elements are blue and cannot be decreased to form the permutation [1, 2, 3].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where:\n    - All elements are of one color and cannot be adjusted to form the permutation.\n    - The array already forms a permutation without any changes.\n    This can be handled by checking the initial state of the array and the color constraints before attempting any transformations.", "Round_0": {"code": "def can_transform_to_permutation(n, a, colors):\n    # We need to check if we can transform the array into a permutation of 1 to n\n    # by using the operations allowed on blue and red elements.\n    \n    # Sort the elements along with their colors\n    elements = sorted(zip(a, colors))\n    \n    for i in range(n):\n        value, color = elements[i]\n        target = i + 1  # The target value in a permutation of 1 to n\n        \n        if color == 'B':\n            # Blue elements can only be decreased\n            if value < target:\n                return False\n        elif color == 'R':\n            # Red elements can only be increased\n            if value > target:\n                return False\n    \n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        if can_transform_to_permutation(n, a, colors):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the array length, the array elements, and their corresponding colors.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the length of the array.\",\n        \"Read the array of integers a of length n.\",\n        \"Read the string of colors of length n, consisting of 'B' and 'R'.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array can be transformed into a permutation of numbers from 1 to n using the allowed operations.\",\n      \"steps\": [\n        \"For each test case, identify the range of numbers needed (1 to n).\",\n        \"Check if there are enough blue elements to decrease to numbers less than or equal to n.\",\n        \"Check if there are enough red elements to increase to numbers greater than or equal to 1.\",\n        \"Ensure that the operations can transform the array into a permutation of numbers from 1 to n.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print 'YES' if the array can be transformed into a permutation, otherwise print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, analyze the array and its colors to determine if it can be transformed into a permutation of numbers from 1 to n.\",\n    \"Output the result for each test case based on the analysis.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation of numbers from 1 to n means that the array should contain each number from 1 to n exactly once, in any order.\n\n# [phrase showing quantity relationship]\n    '0 or more steps': This means that it is possible to make no changes at all if the array is already a permutation.\n    'numbers from 1 to n': This indicates that the final array should contain all integers from 1 to n, inclusive.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the second subproblem should be considered simultaneously:\n    - \"Check if there are enough blue elements to decrease to numbers less than or equal to n.\"\n    - \"Check if there are enough red elements to increase to numbers greater than or equal to 1.\"\n    These checks can be done in a single pass through the array by maintaining two conditions: \n    1. Blue elements should be able to cover numbers from 1 to their maximum possible value.\n    2. Red elements should be able to cover numbers from their minimum possible value to n.\n\n# [edge case] \n    Case 1: n = 1, a = [1], colors = \"B\" => YES\n    Explanation: The array is already a permutation of [1].\n    \n    Case 2: n = 2, a = [2, 1], colors = \"RR\" => NO\n    Explanation: Both elements are red, and we need to decrease one to get a permutation of [1, 2], which is not possible.\n    \n    Case 3: n = 3, a = [3, 3, 3], colors = \"BBB\" => NO\n    Explanation: All elements are blue and need to be decreased to form [1, 2, 3], but we can't decrease 3 to 1 or 2.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - We need to ensure that for each number from 1 to n, there is a corresponding element in the array that can be adjusted to that number using the allowed operations.\n    - This can be done by iterating through the array and checking if each number from 1 to n can be formed by either decreasing a blue element or increasing a red element.\n\n```python\ndef can_form_permutation(n, a", "Round_0": {"code": "def can_form_permutation(n, a, colors):\n    # Separate the elements based on their colors\n    blue_elements = []\n    red_elements = []\n    \n    for i in range(n):\n        if colors[i] == 'B':\n            blue_elements.append(a[i])\n        else:\n            red_elements.append(a[i])\n    \n    # Sort the blue elements in ascending order and red elements in descending order\n    blue_elements.sort()\n    red_elements.sort(reverse=True)\n    \n    # Check if we can form a permutation from 1 to n\n    for i in range(1, n + 1):\n        # Check if there is a blue element that can be decreased to i\n        if blue_elements and blue_elements[0] <= i:\n            blue_elements.pop(0)\n        # Check if there is a red element that can be increased to i\n        elif red_elements and red_elements[0] >= i:\n            red_elements.pop(0)\n        else:\n            return \"NO\"\n    \n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        result = can_form_permutation(n, a, colors)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the array length, the array elements, and their corresponding colors.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, determine if it is possible to transform the array into a permutation of numbers from 1 to n using the allowed operations.\",\n      \"output\": \"A boolean value indicating whether the transformation is possible for each test case.\"\n    },\n    {\n      \"description\": \"Output the result for each test case as 'YES' or 'NO' based on the boolean value obtained in the previous step.\",\n      \"output\": \"A list of strings ('YES' or 'NO') corresponding to each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the entire input at once and split it into manageable parts.\",\n    \"Iterate over each test case and extract the array length, elements, and colors.\",\n    \"For each test case, perform the following steps:\",\n    \"  - Initialize two lists to track the minimum and maximum possible values for each position in the permutation.\",\n    \"  - Iterate over the array elements and their colors:\",\n    \"    - If the element is blue ('B'), ensure it can be decreased to fit within the range [1, n].\",\n    \"    - If the element is red ('R'), ensure it can be increased to fit within the range [1, n].\",\n    \"  - Check if the constructed lists of minimum and maximum values can form a valid permutation of numbers from 1 to n.\",\n    \"  - If a valid permutation is possible, mark the test case as 'YES'; otherwise, mark it as 'NO'.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of numbers from 1 to n means that the array should contain all integers from 1 to n exactly once, in any order.\n\n# [phrase showing quantity relationship]\n    'from 1 to n': This indicates a range of numbers that the array should contain after transformation. In code, this can be implemented by checking if the array can be transformed to contain all numbers in the range [1, n].\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to checking if the array can be transformed into a permutation should be considered simultaneously. Specifically, the logic for ensuring blue elements can be decreased and red elements can be increased should be integrated into a single loop that checks the feasibility of forming a permutation.\n\n# [edge case]\n    Test case with all elements already forming a permutation:\n    Input: 3, [1, 2, 3], 'BRB'\n    Expected output: YES\n    Explanation: The array already forms a permutation of numbers from 1 to 3.\n\n    Test case with all elements the same and colored blue:\n    Input: 3, [2, 2, 2], 'BBB'\n    Expected output: NO\n    Explanation: All elements are the same and cannot be decreased to form a permutation.\n\n    Test case with negative numbers:\n    Input: 3, [-1, -2, -3], 'RRR'\n    Expected output: NO\n    Explanation: Negative numbers cannot be increased to form a permutation of positive numbers from 1 to 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that:\n    - Blue elements can be decreased to fit within the range [1, n].\n    - Red elements can be increased to fit within the range [1, n].\n    - The final array can form a valid permutation of numbers from 1 to n.\n\n    Example code snippet:\n    ```python\n    def can_form_permutation(n, a, colors):\n        min_possible = [1] * n\n        max_possible = [n] * n\n        for i in range(n):\n            if colors[i] == 'B':\n                if a[i] < min_possible[i]:\n                    return False\n            elif colors[i] == 'R':\n                if a[i] > max_possible[i]:\n                    return False\n        # Check if", "Round_0": {"code": "def can_form_permutation(n, a, colors):\n    # Create lists to track the minimum and maximum possible values for each position\n    min_possible = [1] * n\n    max_possible = [n] * n\n    \n    # Iterate over the array elements and their colors\n    for i in range(n):\n        if colors[i] == 'B':\n            # Blue elements can be decreased, so they must be >= 1\n            if a[i] < min_possible[i]:\n                return False\n        elif colors[i] == 'R':\n            # Red elements can be increased, so they must be <= n\n            if a[i] > max_possible[i]:\n                return False\n    \n    # Sort the array and check if it can form a valid permutation\n    a_sorted = sorted(a)\n    for i in range(n):\n        if a_sorted[i] < 1 or a_sorted[i] > n:\n            return False\n        if colors[i] == 'B' and a_sorted[i] > i + 1:\n            return False\n        if colors[i] == 'R' and a_sorted[i] < i + 1:\n            return False\n    \n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        if can_form_permutation(n, a, colors):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, the array of integers a, and the string of colors.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array can be transformed into a permutation of numbers from 1 to n.\",\n      \"steps\": [\n        \"For each test case, identify the minimum and maximum values that can be achieved by blue and red elements respectively.\",\n        \"Check if the blue elements can be decreased to cover all numbers from 1 to the minimum value in the array.\",\n        \"Check if the red elements can be increased to cover all numbers from the maximum value in the array to n.\",\n        \"Ensure that the combined operations can cover all numbers from 1 to n without gaps.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print 'YES' if the array can be transformed into a permutation, otherwise print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, analyze the array and color pattern to determine if a permutation from 1 to n is possible.\",\n    \"Implement logic to check the feasibility of transforming the array using the allowed operations.\",\n    \"Output the result for each test case based on the analysis.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of numbers from 1 to n means that the array should contain all integers from 1 to n exactly once, in any order.\n\n# [phrase showing quantity relationship]\n    'from 1 to n': This indicates a range of numbers that must be present in the array after transformation. In code, this can be implemented by checking if all numbers from 1 to n are present in the array after performing the allowed operations.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the subproblem \"Determine if the array can be transformed into a permutation of numbers from 1 to n\" should be considered simultaneously. Specifically, checking the feasibility of transforming blue and red elements to cover the range from 1 to n should be done in a single logical block to ensure no gaps exist.\n\n# [edge case] \n    Test case with all elements already being a permutation: \n    Input: 3, [1, 2, 3], 'BRB'\n    Expected output: YES\n    Explanation: The array already contains all numbers from 1 to 3, so no operations are needed.\n\n    Test case with all elements being the same and colored blue:\n    Input: 3, [2, 2, 2], 'BBB'\n    Expected output: NO\n    Explanation: All elements are the same and cannot be decreased to form a permutation from 1 to 3.\n\n    Test case with negative numbers:\n    Input: 3, [-1, -2, -3], 'RRR'\n    Expected output: NO\n    Explanation: Negative numbers cannot be increased to form a permutation from 1 to 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array already contains a permutation or where all elements are the same or negative.\n    ```\n    def can_form_permutation(n, a, colors):\n        min_blue = float('inf')\n        max_red = float('-inf')\n        \n        for i in range(n):\n            if colors[i] == 'B':\n                min_blue = min(min_blue, a[i])\n            else:\n                max_red = max(max_red, a[i])\n        \n        # Check if blue elements can cover 1 to min_blue and red elements can cover max_red to n\n        if min_blue >= 1 and max_red <= n:\n            return 'YES'\n        return '", "Round_0": {"code": "def can_form_permutation(n, a, colors):\n    min_blue = float('inf')\n    max_red = float('-inf')\n    \n    for i in range(n):\n        if colors[i] == 'B':\n            min_blue = min(min_blue, a[i])\n        else:\n            max_red = max(max_red, a[i])\n    \n    # Check if blue elements can cover 1 to min_blue and red elements can cover max_red to n\n    if min_blue >= 1 and max_red <= n:\n        return 'YES'\n    return 'NO'\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        results.append(can_form_permutation(n, a, colors))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, the array of integers a, and the string of colors.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array can be transformed into a permutation of numbers from 1 to n.\",\n      \"steps\": [\n        \"For each test case, identify the minimum and maximum values that can be achieved by the blue and red elements respectively.\",\n        \"Check if the blue elements can be decreased to cover all numbers from 1 to the smallest number in the permutation.\",\n        \"Check if the red elements can be increased to cover all numbers from the largest number in the permutation to n.\",\n        \"Ensure that the combination of blue and red elements can cover all numbers from 1 to n without gaps.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print 'YES' if the array can be transformed into a permutation, otherwise print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, analyze the array and color information to determine if a valid permutation can be formed.\",\n    \"Implement logic to check the feasibility of transforming the array into a permutation using the allowed operations.\",\n    \"Output the result for each test case based on the analysis.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of numbers from 1 to n means that the array should contain all integers from 1 to n exactly once, in any order.\n\n# [phrase showing quantity relationship]\n    '0 or more steps': This indicates that the transformation can involve any number of steps, including none.\n    'from 1 to n': This specifies the range of numbers that must be present in the permutation.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps \"Check if the blue elements can be decreased to cover all numbers from 1 to the smallest number in the permutation\" and \"Check if the red elements can be increased to cover all numbers from the largest number in the permutation to n\" should be considered simultaneously. This can be done by iterating through the array and checking both conditions in a single pass.\n\n# [edge case] \n    Test case with all elements blue and already a permutation: \n    Input: 3, [1, 2, 3], 'BBB'\n    Expected output: YES\n    Explanation: The array is already a permutation of numbers from 1 to 3.\n\n    Test case with all elements red and already a permutation:\n    Input: 3, [1, 2, 3], 'RRR'\n    Expected output: YES\n    Explanation: The array is already a permutation of numbers from 1 to 3.\n\n    Test case with elements that cannot be transformed:\n    Input: 3, [1, 1, 1], 'BRB'\n    Expected output: NO\n    Explanation: The array cannot be transformed into a permutation of numbers from 1 to 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    ```python\n    def can_form_permutation(n, a, colors):\n        blue_min = 1\n        red_max = n\n        for i in range(n):\n            if colors[i] == 'B' and a[i] < blue_min:\n                return \"NO\"\n            if colors[i] == 'R' and a[i] > red_max:\n                return \"NO\"\n        return \"YES\"\n    ```\n\nYES", "Round_0": {"code": "def can_form_permutation(n, a, colors):\n    blue_min = 1\n    red_max = n\n    for i in range(n):\n        if colors[i] == 'B' and a[i] < blue_min:\n            return \"NO\"\n        if colors[i] == 'R' and a[i] > red_max:\n            return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        results.append(can_form_permutation(n, a, colors))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, false, false, false, false, false, true, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 36, "prompt": "You are given an array of integers a of length n; the elements of the array can be either different or the same, and each element of the array is colored either blue or red, with no unpainted elements. One of the two operations described below can be applied to an array in a single step:\n\n  * either you can select any blue element and decrease its value by 1; \n  * or you can select any red element and increase its value by 1.\n\nSituations in which there are no elements of some color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable.\n\nDetermine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?\n\nIn other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of input data sets in the test.\n\nThe description of each set of input data consists of three lines. The first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 \u2264 a_i \u2264 10^9) \u2014 the array elements themselves.\n\nThe third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.\n\nIt is guaranteed that the sum of n over all input sets does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.\n\nYou can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).\n\nExample\n\nInput\n\n\n8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n\n\nOutput\n\n\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n\nNote\n\nIn the first test case of the example, the following sequence of moves can be performed:\n\n  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; \n  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. \n\n\n\nWe got that a is a permutation. Hence the answer is YES.", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of input data sets in the test.\n\nThe description of each set of input data consists of three lines. The first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 \u2264 a_i \u2264 10^9) \u2014 the array elements themselves.\n\nThe third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.\n\nIt is guaranteed that the sum of n over all input sets does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.\n\nYou can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).\n\nExample\n\nInput\n\n\n8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n\n\nOutput\n\n\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n\nNote\n\nIn the first test case of the example, the following sequence of moves can be performed:\n\n  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; \n  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. \n\n\n\nWe got that a is a permutation. Hence the answer is YES.", "mutate_method": "condense_two2one", "save_node": true, "parent_index": 36}
