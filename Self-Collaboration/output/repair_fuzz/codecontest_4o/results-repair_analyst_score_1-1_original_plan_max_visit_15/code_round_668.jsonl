{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "repair_prompt": ["Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements. Note that it's possible that k is not an integer. The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i.e. sum divided by n). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the constraints are efficiently handled to optimize the solution. Consider edge cases where the array might have duplicates or all identical elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements. Note that it's possible that k is not an integer. The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i.e. sum divided by n). Monocarp wants to delete exactly two elements from a. The aim is that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the constraints are efficiently handled to optimize the solution. Consider edge cases where the array might have duplicates or all identical elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements, which is the sum of elements divided by the number of these elements (i.e., sum divided by n). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the constraints are efficiently handled to optimize the solution. Consider edge cases where the array might have duplicates or all identical elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        \n        # Edge case: all elements are identical\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # To find pairs (i, j) such that removing them keeps the mean unchanged\n        # We need to find pairs (i, j) such that a[i] + a[j] = 2 * mean_k\n        # mean_k = total_sum / n\n        # 2 * mean_k = 2 * total_sum / n\n        target_sum = 2 * total_sum / n\n        \n        count = 0\n        value_count = {}\n        \n        for value in a:\n            complement = target_sum - value\n            if complement in value_count:\n                count += value_count[complement]\n            \n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "completions": ["def count_valid_pairs(n, arr):\n    total_sum = sum(arr)\n    mean = total_sum / n\n    count = 0\n\n    if all(x == arr[0] for x in arr):\n        # If all elements are identical, any pair can be removed\n        return n * (n - 1) // 2\n\n    # We need to find pairs (i, j) such that:\n    # (total_sum - arr[i] - arr[j]) / (n - 2) == mean\n    # Simplifying, we get: arr[i] + arr[j] == 2 * mean\n    target_sum = 2 * mean\n\n    # Use a dictionary to count occurrences of each element\n    from collections import defaultdict\n    element_count = defaultdict(int)\n\n    for value in arr:\n        element_count[value] += 1\n\n    for i in range(n):\n        element_count[arr[i]] -= 1\n        for j in range(i + 1, n):\n            element_count[arr[j]] -= 1\n            if arr[i] + arr[j] == target_sum:\n                count += 1\n            element_count[arr[j]] += 1\n        element_count[arr[i]] += 1\n\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        arr = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_valid_pairs(n, arr))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        mean_k = total_sum / n\n        target_sum = mean_k * (n - 2)\n\n        # Dictionary to store frequency of elements\n        freq = {}\n        for num in a:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n\n        count_pairs = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Calculate the sum of the two elements to be removed\n                sum_removed = a[i] + a[j]\n                # Check if the remaining sum equals the target sum\n                if total_sum - sum_removed == target_sum:\n                    count_pairs += 1\n\n        results.append(count_pairs)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            # If all elements are the same, any pair can be removed\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == k\n        # Simplifying gives us:\n        # total_sum - a[i] - a[j] == k * (n - 2)\n        # a[i] + a[j] == total_sum - k * (n - 2)\n        \n        target_sum = total_sum - k * (n - 2)\n        \n        # Use a hashmap to count occurrences of each number\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        for num in a:\n            count[num] += 1\n        \n        pair_count = 0\n        \n        for num in a:\n            count[num] -= 1\n            complement = target_sum - num\n            if complement in count:\n                pair_count += count[complement]\n        \n        results.append(pair_count // 2)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def count_valid_pairs(n, a):\n    total_sum = sum(a)\n    mean_k = total_sum / n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (total_sum - a[i] - a[j]) / (n - 2) == mean_k:\n                count += 1\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_valid_pairs(n, a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Edge case: all elements are identical\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Count pairs (i, j) such that removing them keeps the mean unchanged\n        count = 0\n        target_sum = mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of each element\n        from collections import defaultdict\n        freq = defaultdict(int)\n        \n        for num in a:\n            freq[num] += 1\n        \n        for i in range(n):\n            freq[a[i]] -= 1\n            for j in range(i + 1, n):\n                freq[a[j]] -= 1\n                \n                # Calculate the sum of the remaining elements\n                remaining_sum = total_sum - a[i] - a[j]\n                \n                if remaining_sum == target_sum:\n                    count += 1\n                \n                freq[a[j]] += 1\n            freq[a[i]] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        pair_count = 0\n        value_count = defaultdict(int)\n        \n        for value in a:\n            value_count[value] += 1\n        \n        for value in a:\n            target = 2 * total_sum / n - value\n            if target in value_count:\n                pair_count += value_count[target]\n        \n        pair_count //= 2\n        results.append(pair_count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n        \n        count = 0\n        seen = {}\n        \n        for num in a:\n            needed = target_sum - num\n            if needed in seen:\n                count += seen[needed]\n            \n            if num in seen:\n                seen[num] += 1\n            else:\n                seen[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        target_sum = mean_k * (n - 2)\n        pair_count = 0\n        value_count = {}\n        \n        for value in a:\n            value_count[value] = value_count.get(value, 0) + 1\n        \n        for i in range(n):\n            value_count[a[i]] -= 1\n            for j in range(i + 1, n):\n                value_count[a[j]] -= 1\n                if a[i] + a[j] == total_sum - target_sum:\n                    pair_count += 1\n                value_count[a[j]] += 1\n            value_count[a[i]] += 1\n        \n        results.append(pair_count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        from collections import Counter\n        freq = Counter(a)\n        count = 0\n        \n        for x in freq:\n            y = target_sum - x\n            if y in freq:\n                if x == y:\n                    count += freq[x] * (freq[x] - 1) // 2\n                elif x < y:\n                    count += freq[x] * freq[y]\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        \n        # Edge case: all elements are identical\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # To find pairs (i, j) such that removing them keeps the mean unchanged\n        # We need to find pairs (i, j) such that a[i] + a[j] = 2 * mean_k\n        # mean_k = total_sum / n\n        # 2 * mean_k = 2 * total_sum / n\n        target_sum = 2 * total_sum / n\n        \n        count = 0\n        value_count = {}\n        \n        for value in a:\n            complement = target_sum - value\n            if complement in value_count:\n                count += value_count[complement]\n            \n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical properties and efficient data structures to reduce the time complexity of finding valid pairs.\"\n    },\n    {\n      \"description\": \"Handle edge cases.\",\n      \"details\": \"Consider cases where all elements are identical or where there are duplicates, ensuring the solution is efficient and correct.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the mean k for each test case.\",\n      \"details\": \"Compute the sum of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Find valid pairs of indices (i, j) for each test case.\",\n      \"details\": \"Iterate over all pairs (i, j) with i < j and check if removing a[i] and a[j] keeps the mean unchanged. Use efficient methods to reduce complexity.\"\n    },\n    {\n      \"step\": \"Count and store the number of valid pairs for each test case.\",\n      \"details\": \"For each test case, count the number of valid pairs and store the result.\"\n    },\n    {\n      \"step\": \"Output the results.\",\n      \"details\": \"Print the number of valid pairs for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of a set of numbers is the sum of the numbers divided by the count of numbers. In this requirement, it refers to the mean of the array elements before and after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'sum divided by n': This refers to the calculation of the mean, which is the sum of elements divided by the number of elements.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to find pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    'equal': This means that the mean of the remaining elements after removing two should be the same as the original mean.\n\n# [code logic]\n    The steps \"Calculate the mean k for each test case\" and \"Find valid pairs of indices (i, j) for each test case\" should be considered simultaneously. \n    Explanation: While iterating over pairs, we can calculate the mean and check the condition in the same loop to optimize performance.\n\n# [edge case]\n    Case 1: [8, 8, 8, 8] = 6\n    Explanation: All elements are identical, so any pair can be removed without changing the mean.\n    \n    Case 2: [50, 20, 10] = 0\n    Explanation: No pair of elements can be removed to keep the mean unchanged.\n    \n    Case 3: [1, 1, 1, 1, 1] = 10\n    Explanation: All elements are identical, so any pair can be removed without changing the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: Specifically, when all elements are identical, we can directly calculate the number of pairs using combinatorial logic.\n    ```python\n    if all(x == a[0] for x in a):\n        return (n * (n - 1)) // 2\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        # Edge case: all elements are identical\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # To find pairs (i, j) such that removing them keeps the mean unchanged\n        # We need to find pairs (i, j) such that a[i] + a[j] = 2 * mean_k\n        target_sum = 2 * mean_k\n        count = 0\n        value_count = {}\n        \n        for value in a:\n            complement = target_sum - value\n            if complement in value_count:\n                count += value_count[complement]\n            \n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        \n        # Edge case: all elements are identical\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # To find pairs (i, j) such that removing them keeps the mean unchanged\n        # We need to find pairs (i, j) such that a[i] + a[j] = 2 * mean_k\n        # mean_k = total_sum / n\n        # 2 * mean_k = 2 * total_sum / n\n        target_sum = 2 * total_sum / n\n        \n        count = 0\n        value_count = {}\n        \n        for value in a:\n            complement = target_sum - value\n            if complement in value_count:\n                count += value_count[complement]\n            \n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"details\": \"Compute the sum of the array and divide by the number of elements to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"details\": \"For each pair of elements (i, j), check if removing them keeps the mean of the remaining elements equal to the initial mean k.\"\n    },\n    {\n      \"description\": \"Handle edge cases.\",\n      \"details\": \"Consider cases where all elements are identical or where the array has duplicates.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases and for each test case, read the number of elements and the array itself.\"\n    },\n    {\n      \"step\": \"Calculate the initial mean for each test case.\",\n      \"details\": \"Compute the sum of the array and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Iterate over pairs of elements.\",\n      \"details\": \"For each pair (i, j) where i < j, calculate the sum of the remaining elements after removing a[i] and a[j]. Check if the mean of the remaining elements equals k.\"\n    },\n    {\n      \"step\": \"Count valid pairs.\",\n      \"details\": \"Maintain a count of pairs (i, j) that satisfy the condition of maintaining the mean.\"\n    },\n    {\n      \"step\": \"Output the result for each test case.\",\n      \"details\": \"Print the count of valid pairs for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean is the sum of all elements divided by the number of elements. In this problem, it is crucial to maintain the mean after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: We need to find pairs of indices such that removing the elements at these indices keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: This means we must remove precisely two elements from the array.\n\n    'sum of elements divided by the number of these elements'\n    Explanation: This describes the calculation of the mean, which is the total sum divided by the count of elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the initial mean for each test case\" and \"Iterate over pairs of elements\" should be considered simultaneously. \n    Explanation: While iterating over pairs, we can simultaneously check if removing them maintains the mean, which requires the initial mean calculation.\n\n# [edge case]\n    1. Input: [4, 4, 4, 4] = 6\n       Explanation: All elements are identical, so any pair can be removed without changing the mean.\n    2. Input: [10, 10, 10, 10, 10] = 10\n       Explanation: Similar to the first case, all elements are identical, allowing any pair to be removed.\n    3. Input: [1, 2, 3, 4, 5] = 0\n       Explanation: No pair of elements can be removed to maintain the mean, as the elements are distinct and the mean changes with any removal.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: Specifically, when all elements are identical, we can directly calculate the number of pairs using combinatorial logic.\n    ```python\n    from itertools import combinations\n\n    def count_valid_pairs(arr):\n        n = len(arr)\n        total_sum = sum(arr)\n        mean = total_sum / n\n        count = 0\n\n        if all(x == arr[0] for x in arr):\n            # If all elements are identical, any pair can be removed\n            return n * (n - 1) // 2\n\n        for i, j in combinations(range(n), 2):\n            if (total", "Round_0": {"code": "def count_valid_pairs(n, arr):\n    total_sum = sum(arr)\n    mean = total_sum / n\n    count = 0\n\n    if all(x == arr[0] for x in arr):\n        # If all elements are identical, any pair can be removed\n        return n * (n - 1) // 2\n\n    # We need to find pairs (i, j) such that:\n    # (total_sum - arr[i] - arr[j]) / (n - 2) == mean\n    # Simplifying, we get: arr[i] + arr[j] == 2 * mean\n    target_sum = 2 * mean\n\n    # Use a dictionary to count occurrences of each element\n    from collections import defaultdict\n    element_count = defaultdict(int)\n\n    for value in arr:\n        element_count[value] += 1\n\n    for i in range(n):\n        element_count[arr[i]] -= 1\n        for j in range(i + 1, n):\n            element_count[arr[j]] -= 1\n            if arr[i] + arr[j] == target_sum:\n                count += 1\n            element_count[arr[j]] += 1\n        element_count[arr[i]] += 1\n\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        arr = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_valid_pairs(n, arr))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the mathematical mean k of the original array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use a hashmap or dictionary to store and quickly access the frequency of elements needed to form valid pairs.\"\n    },\n    {\n      \"description\": \"Handle edge cases.\",\n      \"details\": \"Consider cases where all elements are identical or where the array has duplicates.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the mean k for each test case.\",\n      \"details\": \"Compute the sum of the array and divide by n to get k.\"\n    },\n    {\n      \"step\": \"Iterate over each element to find valid pairs.\",\n      \"details\": \"For each element a[i], calculate the required complement to maintain the mean and use a hashmap to count valid pairs.\"\n    },\n    {\n      \"step\": \"Count and output the number of valid pairs for each test case.\",\n      \"details\": \"For each test case, output the total number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. It represents the average value of the array.\n\n    'delete exactly two elements'\n    Explanation: The task requires removing two elements from the array such that the mean of the remaining elements remains unchanged.\n\n# [phrase showing quantity relationship]\n    'number of pairs of positions [i, j] (i < j)'\n    Explanation: This indicates that we need to find pairs of indices where the first index is less than the second, and the removal of these elements keeps the mean unchanged.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the mean k for each test case\" and \"Iterate over each element to find valid pairs\" should be considered simultaneously. \n    Explanation: While iterating over each element, we can calculate the required complement to maintain the mean and use a hashmap to count valid pairs in one code block.\n\n# [edge case]\n    Case 1: All elements are identical\n    Input: [8, 8, 8, 8]\n    Expected Output: 6\n    Explanation: Any pair of elements can be removed since all of them are equal, and the mean remains unchanged.\n\n    Case 2: No valid pairs\n    Input: [50, 20, 10]\n    Expected Output: 0\n    Explanation: There is no way to delete two elements so the mathematical mean doesn't change.\n\n    Case 3: Array with duplicates\n    Input: [1, 4, 7, 3, 5]\n    Expected Output: 2\n    Explanation: It is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: We need to ensure that the logic for finding pairs accounts for cases where all elements are identical or where no valid pairs exist. This can be handled by checking the conditions during the pair search process.\n\nYES", "Round_0": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        mean_k = total_sum / n\n        target_sum = mean_k * (n - 2)\n\n        # Dictionary to store frequency of elements\n        freq = {}\n        for num in a:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n\n        count_pairs = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Calculate the sum of the two elements to be removed\n                sum_removed = a[i] + a[j]\n                # Check if the remaining sum equals the target sum\n                if total_sum - sum_removed == target_sum:\n                    count_pairs += 1\n\n        results.append(count_pairs)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical properties and efficient data structures to reduce the time complexity of finding valid pairs.\"\n    },\n    {\n      \"description\": \"Handle edge cases.\",\n      \"details\": \"Consider cases where all elements are identical or where there are duplicates, ensuring the solution is efficient and correct.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the mean k for each test case.\",\n      \"details\": \"Compute the sum of the array a and divide by n to get k.\"\n    },\n    {\n      \"step\": \"Find all valid pairs of indices (i, j) for each test case.\",\n      \"details\": \"Iterate over all pairs (i, j) with i < j and check if removing a[i] and a[j] keeps the mean unchanged.\"\n    },\n    {\n      \"step\": \"Optimize pair search using mathematical insights.\",\n      \"details\": \"Use the equation derived from the mean condition to efficiently find pairs, possibly using a hashmap or other data structure.\"\n    },\n    {\n      \"step\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, print the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of a set of numbers is the sum of the numbers divided by the count of numbers. In this requirement, it refers to the mean of the array elements before and after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to find all unique pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the mean k for each test case\" and \"Find all valid pairs of indices (i, j) for each test case\" should be considered simultaneously. \n    Explanation: While calculating the mean, we can simultaneously check for valid pairs by using the derived condition for the mean to remain unchanged.\n\n# [edge case]\n    Case 1: [8, 8, 8, 8] = 6\n    Explanation: All elements are identical, so any pair of elements can be removed without changing the mean.\n    \n    Case 2: [50, 20, 10] = 0\n    Explanation: No pair of elements can be removed to keep the mean unchanged because the elements are too distinct.\n    \n    Case 3: [1, 1, 1, 1, 1] = 10\n    Explanation: All elements are identical, so any pair of elements can be removed without changing the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: Specifically, when all elements are identical, we can directly calculate the number of pairs using combinatorial logic.\n    ```python\n    if all(x == a[0] for x in a):\n        return (n * (n - 1)) // 2\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            # If all elements are the same, any pair can be removed\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == k\n        # Simplifying gives us:\n        # total_sum - a[i] - a[j] == k * (n - 2)\n        # a[i] + a[j] == total_sum - k * (n - 2)\n        \n        target_sum = total_sum - k * (n - 2)\n        \n        # Use a hashmap to count occurrences of each number\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        for num in a:\n            count[num] += 1\n        \n        pair_count = 0\n        \n        for num in a:\n            count[num] -= 1\n            complement = target_sum - num\n            if complement in count:\n                pair_count += count[complement]\n        \n        results.append(pair_count // 2)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical transformations to reduce the complexity of checking each pair, leveraging properties of sums and means.\"\n    },\n    {\n      \"description\": \"Handle edge cases.\",\n      \"details\": \"Consider cases where all elements are identical or where there are duplicates, ensuring the solution is efficient.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the mean k for each test case.\",\n      \"details\": \"Compute the sum of the array and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Iterate over possible pairs of elements to remove.\",\n      \"details\": \"For each pair (i, j) with i < j, check if removing these elements keeps the mean unchanged.\"\n    },\n    {\n      \"step\": \"Use mathematical properties to optimize pair checking.\",\n      \"details\": \"Derive a condition based on the sum of the array and the elements to be removed to quickly verify if the mean remains unchanged.\"\n    },\n    {\n      \"step\": \"Count and output the number of valid pairs for each test case.\",\n      \"details\": \"For each test case, output the count of pairs that satisfy the condition.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is calculated by summing all elements and dividing by the number of elements. It represents the average value of the array.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This indicates that precisely two elements must be removed from the array.\n    'sum divided by n': This describes the calculation of the mean, where the sum of elements is divided by the number of elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the mean k for each test case\" and \"Iterate over possible pairs of elements to remove\" should be considered simultaneously. This can be done by calculating the mean once and then iterating over pairs to check the condition without recalculating the mean each time.\n\n# [edge case]\n    Test case with all identical elements: [8, 8, 8, 8] = 6\n    Explanation: Any pair of elements can be removed since all elements are equal, and the mean remains unchanged.\n    \n    Test case with no valid pairs: [50, 20, 10] = 0\n    Explanation: No pair of elements can be removed to keep the mean unchanged, as removing any pair changes the mean.\n    \n    Test case with multiple valid pairs: [1, 4, 7, 3, 5] = 2\n    Explanation: Removing elements at positions 1 and 3 or positions 4 and 5 keeps the mean unchanged.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    ```python\n    def count_valid_pairs(n, a):\n        total_sum = sum(a)\n        mean_k = total_sum / n\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (total_sum - a[i] - a[j]) / (n - 2) == mean_k:\n                    count += 1\n        return count\n    ```\n\nYES", "Round_0": {"code": "def count_valid_pairs(n, a):\n    total_sum = sum(a)\n    mean_k = total_sum / n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (total_sum - a[i] - a[j]) / (n - 2) == mean_k:\n                count += 1\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_valid_pairs(n, a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"details\": \"Sum all elements of the array and divide by the number of elements to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (i, j), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Handle edge cases efficiently.\",\n      \"details\": \"Consider cases where all elements are identical or where there are duplicates, ensuring the solution is optimized for large inputs.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases and for each test case, read the number of elements and the array itself.\"\n    },\n    {\n      \"step\": \"Calculate the mean of the array.\",\n      \"details\": \"Compute the sum of the array and divide by the number of elements to find the mean k.\"\n    },\n    {\n      \"step\": \"Iterate over pairs of elements.\",\n      \"details\": \"For each pair of elements (i, j) in the array, calculate the sum of the remaining elements and check if the mean remains unchanged.\"\n    },\n    {\n      \"step\": \"Count valid pairs.\",\n      \"details\": \"Maintain a count of pairs (i, j) where the removal of these elements keeps the mean unchanged.\"\n    },\n    {\n      \"step\": \"Output the result for each test case.\",\n      \"details\": \"Print the count of valid pairs for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. In this problem, it is crucial to maintain the mean after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: This refers to selecting two distinct positions in the array such that the first position is less than the second.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: This means that precisely two elements must be removed from the array.\n\n    'number of pairs'\n    Explanation: This refers to counting how many valid pairs of indices can be found.\n\n# [degree adverb]\n    'still equal'\n    Explanation: This means that after removing the two elements, the mean of the remaining elements must remain the same as the original mean.\n\n# [code logic]\n    The steps \"Calculate the mean of the array\" and \"Iterate over pairs of elements\" should be considered simultaneously. \n    Explanation: While iterating over pairs, the mean calculation should be used to check if the removal of the pair keeps the mean unchanged. This can be done in a single loop where the mean is checked for each pair.\n\n# [edge case]\n    1. Input: 3\n       Array: [1, 1, 1]\n       Expected Output: 3\n       Explanation: Any pair of elements can be removed since all are equal, and the mean remains unchanged.\n\n    2. Input: 4\n       Array: [0, 0, 0, 0]\n       Expected Output: 6\n       Explanation: All elements are zero, so any pair can be removed without changing the mean.\n\n    3. Input: 5\n       Array: [1, 2, 3, 4, 5]\n       Expected Output: 0\n       Explanation: No pair of elements can be removed to keep the mean unchanged.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: Special handling is required for cases where all elements are identical or zero, as any pair can be removed without changing the mean. This can be optimized by checking if all elements are the same before iterating over pairs.\n\n    ```python\n    if all(x == array[0] for x in array):\n        return (n * (n - 1)) // 2  # Combination of n", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Edge case: all elements are identical\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Count pairs (i, j) such that removing them keeps the mean unchanged\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                remaining_sum = total_sum - a[i] - a[j]\n                remaining_mean = remaining_sum / (n - 2)\n                if remaining_mean == mean:\n                    count += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 79)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Edge case: all elements are identical\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Count pairs (i, j) such that removing them keeps the mean unchanged\n        count = 0\n        target_sum = mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of each element\n        from collections import defaultdict\n        freq = defaultdict(int)\n        \n        for num in a:\n            freq[num] += 1\n        \n        for i in range(n):\n            freq[a[i]] -= 1\n            for j in range(i + 1, n):\n                freq[a[j]] -= 1\n                \n                # Calculate the sum of the remaining elements\n                remaining_sum = total_sum - a[i] - a[j]\n                \n                if remaining_sum == target_sum:\n                    count += 1\n                \n                freq[a[j]] += 1\n            freq[a[i]] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical transformations to reduce the complexity of checking each pair, leveraging properties of sums and means.\"\n    },\n    {\n      \"description\": \"Handle edge cases.\",\n      \"details\": \"Consider cases where all elements are identical or where there are duplicates, ensuring the solution is efficient.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the mean k for each test case.\",\n      \"details\": \"Compute the sum of the array and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Iterate over possible pairs of elements to remove.\",\n      \"details\": \"For each pair (i, j) with i < j, check if removing these elements keeps the mean unchanged.\"\n    },\n    {\n      \"step\": \"Use mathematical properties to optimize pair checking.\",\n      \"details\": \"Derive a condition based on the sum of the array and the elements to be removed to quickly verify if the mean remains unchanged.\"\n    },\n    {\n      \"step\": \"Count and output the number of valid pairs for each test case.\",\n      \"details\": \"For each test case, output the count of pairs that satisfy the condition.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean of the array should remain unchanged after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to count all unique pairs of indices where the first index is less than the second.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps \"Iterate over possible pairs of elements to remove\" and \"Use mathematical properties to optimize pair checking\" should be considered simultaneously. This can be implemented by iterating over pairs and applying the derived mathematical condition in the same loop to check if the mean remains unchanged.\n\n# [edge case] \n    1. Input: [4, 4, 4, 4] = 6\n       Explanation: All elements are identical, so any pair of elements can be removed without changing the mean.\n    2. Input: [1, 1, 1, 1, 1] = 10\n       Explanation: Similar to the first case, all elements are identical, allowing any pair to be removed.\n    3. Input: [1, 2, 3, 4, 5] = 0\n       Explanation: No two elements can be removed to keep the mean unchanged, as the elements are distinct and the mean changes with any removal.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are identical.\n    ```python\n    if all(x == a[0] for x in a):\n        return comb(n, 2)  # Return the combination of n elements taken 2 at a time\n    ```\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(comb(n, 2))\n            continue\n        \n        pair_count = 0\n        value_count = defaultdict(int)\n        \n        for value in a:\n            value_count[value] += 1\n        \n        for value in a:\n            target = 2 * mean_k - value\n            if target in value_count:\n                pair_count += value_count[target]\n        \n        pair_count //= 2\n        results.append(pair_count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        pair_count = 0\n        value_count = defaultdict(int)\n        \n        for value in a:\n            value_count[value] += 1\n        \n        for value in a:\n            target = 2 * total_sum / n - value\n            if target in value_count:\n                pair_count += value_count[target]\n        \n        pair_count //= 2\n        results.append(pair_count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"steps\": [\n        \"Sum all elements of the array.\",\n        \"Divide the sum by the number of elements to get the mean.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (i, j), calculate the sum of the remaining elements after removing i and j.\",\n        \"Check if the mean of the remaining elements equals the initial mean.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"steps\": [\n        \"Use mathematical properties to simplify the condition for unchanged mean.\",\n        \"Implement efficient search techniques to handle large arrays and constraints.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following:\",\n    \"Read the number of elements and the array.\",\n    \"Calculate the initial mean of the array.\",\n    \"Iterate over all pairs of elements in the array.\",\n    \"For each pair, check if their removal keeps the mean unchanged.\",\n    \"Count and store the number of valid pairs for each test case.\",\n    \"Output the count for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is calculated by dividing the sum of its elements by the number of elements. The task requires maintaining this mean after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This indicates that we need to remove precisely two elements from the array.\n    'sum divided by n': This is the formula for calculating the mean, where 'sum' is the total of all elements and 'n' is the number of elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the initial mean and checking pairs should be considered simultaneously for efficiency. Specifically, while iterating over pairs, the condition for unchanged mean can be checked using mathematical properties derived from the initial mean calculation.\n\n# [edge case]\n    Test case with all identical elements: [8, 8, 8, 8] = 6\n    Explanation: Any pair of elements can be removed since all elements are equal, maintaining the mean.\n    \n    Test case with no valid pairs: [50, 20, 10] = 0\n    Explanation: No pair of elements can be removed to maintain the mean.\n    \n    Test case with multiple valid pairs: [1, 4, 7, 3, 5] = 2\n    Explanation: Removing elements at positions 1 and 3 or positions 4 and 5 maintains the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    Implement efficient search techniques using mathematical properties to reduce the complexity of checking each pair.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n        \n        count = 0\n        seen = {}\n        \n        for num in a:\n            needed = target_sum - num\n            if needed in seen:\n                count += seen[needed]\n            \n            if num in seen:\n                seen[num] += 1\n            else:\n                seen[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n        \n        count = 0\n        seen = {}\n        \n        for num in a:\n            needed = target_sum - num\n            if needed in seen:\n                count += seen[needed]\n            \n            if num in seen:\n                seen[num] += 1\n            else:\n                seen[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the mathematical mean k of the original array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical properties and efficient data structures to reduce the complexity of finding valid pairs.\"\n    },\n    {\n      \"description\": \"Handle edge cases.\",\n      \"details\": \"Consider cases with duplicate elements, all identical elements, and minimal array size.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the mean k for each test case.\",\n      \"details\": \"Compute the sum of the array and divide by n to get k.\"\n    },\n    {\n      \"step\": \"Find all valid pairs (i, j) for each test case.\",\n      \"details\": \"Iterate over all pairs (i, j) with i < j and check if removing a[i] and a[j] keeps the mean unchanged.\"\n    },\n    {\n      \"step\": \"Optimize pair search using mathematical insights.\",\n      \"details\": \"Use the equation derived from the mean condition to efficiently find pairs, possibly using hash maps or other data structures.\"\n    },\n    {\n      \"step\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, print the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean of the array should remain the same even after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'sum divided by n': This refers to the calculation of the mean, where the sum of the elements is divided by the number of elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the mean k for each test case\" and \"Find all valid pairs (i, j) for each test case\" should be considered simultaneously. \n    Explanation: While calculating the mean, we can simultaneously check for pairs that satisfy the condition to optimize the process.\n\n# [edge case]\n    1. Input: [4, 8, 8, 8, 8] = 6\n       Explanation: All elements are the same, so any pair can be removed without changing the mean.\n    2. Input: [3, 50, 20, 10] = 0\n       Explanation: No pair of elements can be removed to keep the mean unchanged.\n    3. Input: [5, 1, 4, 7, 3, 5] = 2\n       Explanation: Removing elements at positions 1 and 3 or 4 and 5 keeps the mean unchanged.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: We need to ensure that the code efficiently handles cases with all identical elements or minimal array sizes.\n    ```\n    if n == 3:\n        return 0\n    if all(x == a[0] for x in a):\n        return (n * (n - 1)) // 2\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        target_sum = mean_k * (n - 2)\n        pair_count = 0\n        value_count = {}\n        \n        for value in a:\n            value_count[value] = value_count.get(value, 0) + 1\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if a[i] + a[j] == total_sum - target_sum:\n                    pair_count += 1\n        \n        results.append(pair_count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        target_sum = mean_k * (n - 2)\n        pair_count = 0\n        value_count = {}\n        \n        for value in a:\n            value_count[value] = value_count.get(value, 0) + 1\n        \n        for i in range(n):\n            value_count[a[i]] -= 1\n            for j in range(i + 1, n):\n                value_count[a[j]] -= 1\n                if a[i] + a[j] == total_sum - target_sum:\n                    pair_count += 1\n                value_count[a[j]] += 1\n            value_count[a[i]] += 1\n        \n        results.append(pair_count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"steps\": [\n        \"Sum all elements of the array.\",\n        \"Divide the sum by the number of elements to get the mean.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (i, j) in the array, calculate the sum of the remaining elements after removing these two.\",\n        \"Check if the mean of the remaining elements equals the initial mean.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for pairs to handle constraints efficiently.\",\n      \"steps\": [\n        \"Use mathematical properties to simplify the condition for unchanged mean.\",\n        \"Implement efficient data structures or algorithms to reduce time complexity.\"\n      ]\n    },\n    {\n      \"description\": \"Handle edge cases such as arrays with duplicates or identical elements.\",\n      \"steps\": [\n        \"Consider special cases where all elements are identical.\",\n        \"Ensure the solution works for arrays with duplicate values.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following:\",\n    \"Read the number of elements and the array itself.\",\n    \"Calculate the initial mean of the array.\",\n    \"Iterate over all pairs of elements to check if their removal keeps the mean unchanged.\",\n    \"Count and store the number of valid pairs for each test case.\",\n    \"Output the count for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. In this problem, the task is to find pairs of elements whose removal does not change the mean of the remaining elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to count pairs of indices where the first index is less than the second.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to calculating the initial mean and checking pairs should be considered simultaneously. Specifically, the calculation of the initial mean and the checking of pairs for unchanged mean should be integrated to avoid redundant calculations.\n\n# [edge case] \n    Test case with all identical elements, e.g., [5, 5, 5, 5] = 6\n    Explanation: Any pair of elements can be removed without changing the mean.\n    \n    Test case with no possible pairs, e.g., [1, 2, 3] = 0\n    Explanation: No pair of elements can be removed to keep the mean unchanged.\n    \n    Test case with a large number of elements, e.g., [1, 1, 1, ..., 1] (n = 200,000) = 199,999 * 199,998 / 2\n    Explanation: All elements are identical, so any pair can be removed.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially for large arrays with identical elements.\n    ```python\n    from collections import Counter\n\n    def count_pairs(n, a):\n        total_sum = sum(a)\n        mean = total_sum / n\n        count = 0\n        freq = Counter(a)\n        \n        for x in freq:\n            if (total_sum - 2 * x) / (n - 2) == mean:\n                count += freq[x] * (freq[x] - 1) // 2\n        \n        return count\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        from collections import Counter\n        freq = Counter(a)\n        count = 0\n        \n        for x in freq:\n            y = target_sum - x\n            if y in freq:\n                if x == y:\n                    count += freq[x] * (freq[x] - 1) // 2\n                elif x < y:\n                    count += freq[x] * freq[y]\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical properties and efficient data structures to reduce the time complexity of finding valid pairs.\"\n    },\n    {\n      \"description\": \"Handle edge cases.\",\n      \"details\": \"Consider cases where all elements are identical or where there are duplicates, ensuring the solution is efficient and correct.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the mean k for each test case.\",\n      \"details\": \"Compute the sum of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Find valid pairs of indices (i, j) for each test case.\",\n      \"details\": \"Iterate over all pairs (i, j) with i < j and check if removing a[i] and a[j] keeps the mean unchanged. Use efficient methods to reduce complexity.\"\n    },\n    {\n      \"step\": \"Count and store the number of valid pairs for each test case.\",\n      \"details\": \"For each test case, count the number of valid pairs and store the result.\"\n    },\n    {\n      \"step\": \"Output the results.\",\n      \"details\": \"Print the number of valid pairs for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of a set of numbers is the sum of the numbers divided by the count of numbers. In this requirement, it refers to the mean of the array elements before and after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'sum divided by n': This refers to the calculation of the mean, which is the sum of elements divided by the number of elements.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to find pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    'equal': This means that the mean of the remaining elements after removing two should be the same as the original mean.\n\n# [code logic]\n    The steps \"Calculate the mean k for each test case\" and \"Find valid pairs of indices (i, j) for each test case\" should be considered simultaneously. \n    Explanation: While iterating over pairs, we can calculate the mean and check the condition in the same loop to optimize performance.\n\n# [edge case]\n    Case 1: [8, 8, 8, 8] = 6\n    Explanation: All elements are identical, so any pair can be removed without changing the mean.\n    \n    Case 2: [50, 20, 10] = 0\n    Explanation: No pair of elements can be removed to keep the mean unchanged.\n    \n    Case 3: [1, 1, 1, 1, 1] = 10\n    Explanation: All elements are identical, so any pair can be removed without changing the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: Specifically, when all elements are identical, we can directly calculate the number of pairs using combinatorial logic.\n    ```python\n    if all(x == a[0] for x in a):\n        return (n * (n - 1)) // 2\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        # Edge case: all elements are identical\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # To find pairs (i, j) such that removing them keeps the mean unchanged\n        # We need to find pairs (i, j) such that a[i] + a[j] = 2 * mean_k\n        target_sum = 2 * mean_k\n        count = 0\n        value_count = {}\n        \n        for value in a:\n            complement = target_sum - value\n            if complement in value_count:\n                count += value_count[complement]\n            \n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        \n        # Edge case: all elements are identical\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # To find pairs (i, j) such that removing them keeps the mean unchanged\n        # We need to find pairs (i, j) such that a[i] + a[j] = 2 * mean_k\n        # mean_k = total_sum / n\n        # 2 * mean_k = 2 * total_sum / n\n        target_sum = 2 * total_sum / n\n        \n        count = 0\n        value_count = {}\n        \n        for value in a:\n            complement = target_sum - value\n            if complement in value_count:\n                count += value_count[complement]\n            \n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}], "scores": [], "pass_results": [false, true, false, false, false, true, true, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 668, "prompt": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements. Note that it's possible that k is not an integer. The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i.e. sum divided by n). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the constraints are efficiently handled to optimize the solution. Consider edge cases where the array might have duplicates or all identical elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "expand_one2two", "save_node": false, "parent_index": 171}
