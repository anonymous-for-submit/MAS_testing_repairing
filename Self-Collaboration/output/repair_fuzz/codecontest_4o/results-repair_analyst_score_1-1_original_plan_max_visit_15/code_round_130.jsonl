{"name": "1607_C. Minimum Extraction", "description": "Yelisey has an array a of n integers.\n\nIf a has length strictly greater than 1, then Yelisei can apply an operation called minimum extraction to it: \n\n  1. First, Yelisei finds the minimal number m in the array. If there are several identical minima, Yelisey can choose any of them. \n  2. Then the selected minimal element is removed from the array. After that, m is subtracted from each remaining element. \n\n\n\nThus, after each operation, the length of the array is reduced by 1.\n\nFor example, if a = [1, 6, -4, -2, -4], then the minimum element in it is a_3 = -4, which means that after this operation the array will be equal to a=[1 {- (-4)}, 6 {- (-4)}, -2 {- (-4)}, -4 {- (-4)}] = [5, 10, 2, 0].\n\nSince Yelisey likes big numbers, he wants the numbers in the array a to be as big as possible.\n\nFormally speaking, he wants to make the minimum of the numbers in array a to be maximal possible (i.e. he want to maximize a minimum). To do this, Yelisey can apply the minimum extraction operation to the array as many times as he wants (possibly, zero). Note that the operation cannot be applied to an array of length 1.\n\nHelp him find what maximal value can the minimal element of the array have after applying several (possibly, zero) minimum extraction operations to the array.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.", "tags": ["brute force", "sortings"], "difficulty": 9, "id": 1607, "sample_io": [{"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n2\n2\n-2\n"]}], "test_list": [{"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 2 0 -2 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n2\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n8\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n8\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n8\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n8\n2\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n2\n8\n2\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["10\n1\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -2 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n5\n2\n3\n2\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n3\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-4\n", "output": ["10\n1\n2\n8\n2\n2\n0\n-4\n"]}, {"input": "8\n1\n10\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["10\n2\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 14\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n8\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 19 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n12\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n5\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n5\n2\n5\n2\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 7\n2\n1 6\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n4\n5\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n8\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n1\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n3 10 1 14\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n7\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 1\n5\n3 2 -4 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n5\n1\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n16\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 3 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n3\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n3\n16\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n1 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 3 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n3\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 12\n2\n2 4\n5\n3 3 -5 -4 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n8\n2\n5\n2\n0\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n3\n16\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n2\n2\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 0\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n0\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 4 -1\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -4 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n4\n5\n1\n3\n1\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n0 3 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n2\n3\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n3\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 1 -6 -1 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n5\n3\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 17 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n10\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -1 -1 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n3\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 10 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n9\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n2\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n6\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-2 2\n1\n-3\n", "output": ["10\n0\n2\n4\n2\n3\n4\n-3\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 1 -4 -2 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n2\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n1 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n1\n-2\n"]}, {"input": "8\n1\n12\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["12\n1\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 4\n5\n3 3 -4 -2 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n3\n2\n3\n2\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 12\n5\n3 2 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n3\n10\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 0 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 10\n2\n1 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n7\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-3\n", "output": ["10\n0\n2\n5\n4\n3\n1\n-3\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 2 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n1\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 1 0\n4\n2 10 1 -1\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n1\n8\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n0 4\n5\n3 2 -4 0 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n4\n3\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n0 -1\n1\n0\n", "output": ["10\n2\n2\n8\n2\n2\n1\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n3\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-2 1\n1\n-2\n", "output": ["8\n0\n2\n5\n4\n4\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 4\n5\n4 3 0 0 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 0 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n1\n1\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n0 4\n5\n3 2 -4 -4 -2\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n3\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 18 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n11\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 2\n1\n0\n", "output": ["10\n0\n2\n5\n2\n5\n3\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n17\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n-1 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n0\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 14\n2\n0 4\n5\n3 2 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n6\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n1\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n1 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 3 -4 0 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n3\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 -1\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n1\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -4 -1 2\n2\n0 0\n1\n-2\n", "output": ["10\n0\n2\n5\n1\n3\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n3\n16\n3\n3\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 4\n5\n3 2 -4 -3 1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n2\n4\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 0\n3\n0 3 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n0\n3\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n0\n2\n7\n2\n3\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 2 -1 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n2\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 1 -4 -1 1\n2\n-1 0\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n3\n1\n-1\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n2 17 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n10\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n6\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n3\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 10 1 0\n2\n2 6\n5\n3 2 -1 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n9\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n3 4\n5\n3 1 -4 -2 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n3\n2\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 12\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n1 2\n1\n-2\n", "output": ["10\n0\n2\n7\n2\n3\n1\n-2\n"]}, {"input": "8\n1\n12\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["12\n2\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n-1 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 0 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 4\n5\n3 3 -4 -2 1\n2\n-2 1\n1\n0\n", "output": ["10\n0\n2\n3\n2\n3\n3\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 0 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n1\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 10\n2\n1 3\n5\n3 4 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n7\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n15\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["15\n0\n2\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 2 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n1\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 10 1 -1\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n8\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n3 10 1 7\n2\n0 4\n5\n3 2 -4 0 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n1\n2\n4\n4\n3\n4\n-2\n"]}, {"input": "8\n1\n7\n2\n0 -1\n3\n-2 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-4\n", "output": ["7\n1\n2\n8\n2\n2\n0\n-4\n"]}, {"input": "8\n1\n10\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -7 -2 0\n2\n0 -1\n1\n0\n", "output": ["10\n2\n2\n8\n2\n5\n1\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 0 7\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n4\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 14\n2\n2 1\n5\n0 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n8\n1\n2\n2\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-2 1\n1\n-2\n", "output": ["0\n0\n2\n5\n4\n4\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 1 0\n4\n2 10 1 7\n2\n2 6\n5\n3 4 -4 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n1\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 0 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n1\n1\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n0 4\n5\n3 2 -4 -4 -2\n2\n0 2\n1\n-3\n", "output": ["10\n0\n2\n3\n4\n4\n2\n-3\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n4 3\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n6\n3\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 2\n1\n0\n", "output": ["10\n1\n2\n5\n2\n5\n3\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 18 1 -1\n2\n3 6\n5\n6 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n17\n3\n4\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 15 1 14\n2\n0 4\n5\n3 2 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n10\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 -1\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n5 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n1\n2\n5\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 8\n5\n3 2 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n3\n16\n5\n3\n0\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n6 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n5\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n2\n7\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 16 1 11\n2\n2 1\n5\n3 2 -1 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n8\n1\n2\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 2\n5\n3 1 -4 -1 1\n2\n-1 0\n1\n-1\n", "output": ["18\n1\n2\n7\n2\n3\n1\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 10\n2\n2 4\n5\n3 3 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n8\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 11\n2\n2 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n8\n6\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 4\n2\n2 6\n5\n5 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n2\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -2\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n2\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n3 4\n5\n3 1 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n4\n3\n2\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 12\n2\n2 4\n5\n3 4 -4 -2 -1\n2\n1 2\n1\n-2\n", "output": ["10\n0\n2\n7\n2\n4\n1\n-2\n"]}, {"input": "8\n1\n12\n2\n0 -4\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["12\n4\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n-1 0\n3\n-1 2 -1\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 0 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n3\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 2\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n4\n1\n-2\n"]}, {"input": "8\n1\n11\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 0 -3 1\n2\n-1 1\n1\n-2\n", "output": ["11\n0\n1\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 10\n2\n1 3\n5\n3 4 -4 -2 -1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n3\n7\n2\n4\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n-1 0\n3\n0 2 0\n4\n2 10 2 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-3\n", "output": ["10\n1\n2\n5\n4\n3\n1\n-3\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 2 1 -1\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n2\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 0 7\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-4\n", "output": ["17\n0\n3\n4\n2\n2\n2\n-4\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n4 3 0 -1 1\n2\n-1 1\n1\n-2\n", "output": ["14\n0\n2\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-2 0 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n1\n2\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n0 18 1 9\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n9\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 0\n1\n0\n", "output": ["10\n0\n2\n5\n2\n5\n1\n0\n"]}, {"input": "8\n1\n19\n2\n0 0\n3\n-1 2 0\n4\n1 18 1 -1\n2\n3 6\n5\n6 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["19\n0\n2\n17\n3\n4\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n-2 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 1 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n4\n2\n2\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n6 2 -8 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n5\n4\n6\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 20\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n2\n10\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 2 0\n4\n3 12 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-2\n", "output": ["14\n0\n2\n5\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 2\n3\n-1 2 0\n4\n2 10 1 10\n2\n2 4\n5\n3 3 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n2\n2\n8\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 17 0 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n3\n10\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 17 1 11\n2\n2 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n9\n6\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 0\n4\n2 4 1 4\n2\n2 6\n5\n5 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n2\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n17\n2\n-1 0\n3\n-1 2 -1\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 0 -1\n2\n0 2\n1\n-3\n", "output": ["17\n1\n3\n3\n2\n3\n2\n-3\n"]}, {"input": "8\n1\n11\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 1 -3 1\n2\n-1 1\n1\n-2\n", "output": ["11\n0\n1\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n-1 0\n3\n0 2 1\n4\n2 10 2 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-3\n", "output": ["10\n1\n1\n5\n4\n3\n1\n-3\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 2 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n1\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 2 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n2\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 2 -4 -2 2\n2\n0 1\n1\n-2\n", "output": ["0\n0\n2\n5\n4\n4\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-2 0 0\n4\n0 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n1\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n4 10 1 7\n2\n-1 4\n5\n3 2 -4 -4 -2\n2\n0 2\n1\n-3\n", "output": ["10\n0\n2\n3\n5\n4\n2\n-3\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n4 15 1 14\n2\n0 4\n5\n3 1 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n3\n10\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 4 -2\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -6 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n4\n5\n1\n5\n1\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n0 4\n5\n0 2 -4 -3 1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n4\n3\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n-1 2 -1\n4\n0 10 1 7\n2\n2 6\n5\n6 2 -8 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n6\n4\n6\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 1 0\n4\n3 10 1 20\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n1\n10\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 2\n3\n-1 2 0\n4\n2 10 1 8\n2\n2 4\n5\n3 3 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n2\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 17 1 11\n2\n4 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n9\n4\n3\n3\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -3 -2\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n1\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 2 1 0\n2\n1 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n1\n5\n3\n1\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 2 1 -1\n2\n3 6\n5\n3 2 -4 -2 -1\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n2\n3\n3\n0\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n3 10 0 9\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-4\n", "output": ["17\n0\n3\n6\n2\n2\n2\n-4\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 0 -4 -2 2\n2\n0 1\n1\n-2\n", "output": ["0\n0\n2\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n4 15 1 12\n2\n0 4\n5\n3 1 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n3\n8\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n1 0\n3\n-1 2 -2\n4\n2 18 1 -1\n2\n3 8\n5\n3 1 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["8\n1\n3\n16\n5\n3\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n-1 0\n3\n0 4 -2\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -6 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n4\n5\n1\n5\n1\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 1 0\n4\n3 11 1 20\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n1\n9\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n0 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n1\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-2 2 -1\n4\n2 17 0 7\n2\n1 3\n5\n3 4 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n3\n10\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n15\n2\n0 0\n3\n-1 2 0\n4\n3 6 1 7\n2\n2 4\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["15\n0\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -3 0\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n1\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n6 10 2 7\n2\n3 4\n5\n3 1 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n1\n2\n4\n3\n2\n3\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 0 -4 -2 2\n2\n0 1\n1\n-4\n", "output": ["0\n0\n2\n5\n4\n3\n1\n-4\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n4 15 1 12\n2\n0 4\n5\n3 1 -12 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n3\n8\n4\n8\n2\n-2\n"]}, {"input": "8\n1\n1\n2\n1 0\n3\n-1 2 -2\n4\n2 18 1 -1\n2\n3 8\n5\n3 1 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["1\n1\n3\n16\n5\n3\n0\n-2\n"]}, {"input": "8\n1\n11\n2\n0 1\n3\n0 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["11\n1\n1\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-2 2 -1\n4\n2 17 0 7\n2\n1 6\n5\n3 4 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n3\n10\n5\n3\n2\n-2\n"]}, {"input": "8\n1\n15\n2\n0 0\n3\n-1 2 0\n4\n3 6 1 12\n2\n2 4\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["15\n0\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 0 0\n4\n0 10 0 7\n2\n2 3\n5\n3 2 -4 -3 0\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n1\n7\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n17\n2\n1 0\n3\n-1 3 0\n4\n3 10 0 9\n2\n2 0\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-4\n", "output": ["17\n1\n3\n6\n2\n2\n2\n-4\n"]}, {"input": "8\n1\n11\n2\n0 1\n3\n0 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 0\n1\n-2\n", "output": ["11\n1\n1\n5\n3\n4\n1\n-2\n"]}], "task_id": "codecontest/100", "repair_prompt": ["Yelisey has an array a with n integers.\n\nIf a has length strictly greater than 1, then Yelisei can apply an operation called minimum extraction to it: \n\n  1. First, Yelisei identifies the smallest number m in the array. If there are multiple identical minima, Yelisey can choose any of them. \n  2. Then the chosen minimal element is deleted from the array. After that, m is subtracted from each remaining element. \n\nTherefore, following each operation, the array's length decreases by 1.\n\nFor example, if a = [1, 6, -4, -2, -4], then the minimum element in it is a_3 = -4, which means that after this operation the array will be equal to a=[1 {- (-4)}, 6 {- (-4)}, -2 {- (-4)}, -4 {- (-4)}] = [5, 10, 2, 0].\n\nSince Yelisey likes big numbers, he wants the numbers in the array a to be as big as possible.\n\nFormally speaking, he wants to make the minimum of the numbers in array a to be maximal possible (i.e. he want to maximize a minimum). To do this, Yelisey can apply the minimum extraction operation to the array as many times as he wants (possibly, zero). Note that the operation cannot be applied to an array of length 1.\n\nHelp him find out the largest possible value that the smallest element of the array can achieve after implementing several (possibly, zero) minimum extraction operations on the array.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Yelisey has an array a with n integers.\n\nIf a has length strictly greater than 1, then Yelisei can apply an operation called minimum extraction to it:\n\n1. First, Yelisei identifies the smallest number m in the array. There could be several identical minimum numbers in the array. Yelisey can choose any of them. \n\n2. Then the chosen minimal element is deleted from the array. After that, m is subtracted from each remaining element.\n\nTherefore, following each operation, the array's length decreases by 1.\n\nFor example, if a = [1, 6, -4, -2, -4], then the minimum element in it is a_3 = -4, which means that after this operation the array will be equal to a=[1 {- (-4)}, 6 {- (-4)}, -2 {- (-4)}, -4 {- (-4)}] = [5, 10, 2, 0].\n\nSince Yelisey likes big numbers, he wants the numbers in the array a to be as big as possible.\n\nFormally speaking, he wants to make the minimum of the numbers in array a to be maximal possible (i.e. he want to maximize a minimum). To do this, Yelisey can apply the minimum extraction operation to the array as many times as he wants (possibly, zero). Note that the operation cannot be applied to an array of length 1.\n\nHelp him find out the largest possible value that the smallest element of the array can achieve after implementing several (possibly, zero) minimum extraction operations on the array.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Yelisey has an array a with n integers. If a has length strictly greater than 1, then Yelisei can apply an operation called minimum extraction to it: 1. First, Yelisei identifies the smallest number m in the array. If there are multiple identical minima, Yelisey can choose any of them. 2. Then the chosen minimal element is deleted from the array, and after that, m is subtracted from each remaining element. Therefore, following each operation, the array's length decreases by 1. For example, if a = [1, 6, -4, -2, -4], then the minimum element in it is a_3 = -4, which means that after this operation the array will be equal to a=[1 {- (-4)}, 6 {- (-4)}, -2 {- (-4)}, -4 {- (-4)}] = [5, 10, 2, 0]. Since Yelisey likes big numbers, he wants the numbers in the array a to be as big as possible. Formally speaking, he wants to make the minimum of the numbers in array a to be maximal possible (i.e. he want to maximize a minimum). To do this, Yelisey can apply the minimum extraction operation to the array as many times as he wants (possibly, zero). Note that the operation cannot be applied to an array of length 1. Help him find out the largest possible value that the smallest element of the array can achieve after implementing several (possibly, zero) minimum extraction operations on the array.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def maximize_minimum(t, test_cases):\n    results = []\n    for i in range(t):\n        n, a = test_cases[i]\n        if n == 1:\n            # If there's only one element, the maximum possible minimum is the element itself\n            results.append(a[0])\n        else:\n            # Sort the array\n            a.sort()\n            # Initialize the maximum possible minimum\n            max_min = a[0]\n            # Calculate the differences between consecutive elements\n            for j in range(1, n):\n                max_min = max(max_min, a[j] - a[j - 1])\n            results.append(max_min)\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "completions": ["def maximize_minimum(t, test_cases):\n    results = []\n    for n, array in test_cases:\n        if n == 1:\n            results.append(array[0])\n            continue\n        \n        array.sort()\n        max_minimum = array[0]\n        current_minimum = array[0]\n        \n        for i in range(1, n):\n            current_minimum = array[i] - array[i - 1]\n            max_minimum = max(max_minimum, current_minimum)\n        \n        results.append(max_minimum)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def maximize_minimum(t, test_cases):\n    results = []\n    for n, array in test_cases:\n        if n == 1:\n            results.append(array[0])\n            continue\n        \n        array.sort()\n        max_minimum = array[0]\n        \n        for i in range(1, n):\n            max_minimum = max(max_minimum, array[i] - array[i - 1])\n        \n        results.append(max_minimum)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = maximize_minimum(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nmain()", "def maximize_minimum_extraction(t, test_cases):\n    results = []\n    for n, array in test_cases:\n        if n == 1:\n            results.append(array[0])\n            continue\n        \n        array.sort()\n        max_minimum = array[0]\n        \n        for i in range(1, n):\n            max_minimum = max(max_minimum, array[i] - array[i - 1])\n        \n        results.append(max_minimum)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = maximize_minimum_extraction(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nmain()", "def maximize_minimum(t, test_cases):\n    results = []\n    for n, array in test_cases:\n        if n == 1:\n            results.append(array[0])\n            continue\n        \n        array.sort()\n        max_minimum = array[0]\n        \n        for i in range(1, n):\n            max_minimum = max(max_minimum, array[i] - array[i - 1])\n        \n        results.append(max_minimum)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def maximize_minimum(t, test_cases):\n    results = []\n    for n, array in test_cases:\n        if n == 1:\n            results.append(array[0])\n        else:\n            array.sort()\n            max_minimum = array[0]\n            for i in range(1, n):\n                max_minimum = max(max_minimum, array[i] - array[i - 1])\n            results.append(max_minimum)\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def maximize_minimum(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        if n == 1:\n            results.append(a[0])\n        else:\n            a.sort()\n            max_minimum = a[0]\n            for i in range(1, n):\n                max_minimum = max(max_minimum, a[i] - a[i - 1])\n            results.append(max_minimum)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = maximize_minimum(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def maximize_minimum(t, test_cases):\n    results = []\n    for n, array in test_cases:\n        if n == 1:\n            results.append(array[0])\n        else:\n            array.sort()\n            max_min = array[0]\n            for i in range(1, n):\n                max_min = max(max_min, array[i] - array[i - 1])\n            results.append(max_min)\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def maximize_minimum(t, test_cases):\n    results = []\n    for n, array in test_cases:\n        if n == 1:\n            results.append(array[0])\n        else:\n            array.sort()\n            max_minimum = array[0]\n            for i in range(1, n):\n                max_minimum = max(max_minimum, array[i] - array[i - 1])\n            results.append(max_minimum)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def maximize_minimum(t, test_cases):\n    results = []\n    for i in range(t):\n        n, a = test_cases[i]\n        if n == 1:\n            # If the array has only one element, the maximum minimum is the element itself\n            results.append(a[0])\n            continue\n        \n        # Sort the array\n        a.sort()\n        \n        # Initialize the maximum possible minimum\n        max_min = a[0]\n        \n        # Apply the minimum extraction operation\n        for j in range(1, n):\n            # Calculate the difference between current and previous element\n            diff = a[j] - a[j - 1]\n            # Update the maximum possible minimum\n            max_min = max(max_min, diff)\n        \n        results.append(max_min)\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nt = int(data[0])\nindex = 1\ntest_cases = []\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1:index + 1 + n]))\n    test_cases.append((n, a))\n    index += 1 + n\n\n# Get results\nresults = maximize_minimum(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n\nmain()", "def maximize_minimum(t, test_cases):\n    results = []\n    for i in range(t):\n        n, a = test_cases[i]\n        if n == 1:\n            # If there's only one element, the maximum possible minimum is the element itself\n            results.append(a[0])\n        else:\n            # Sort the array\n            a.sort()\n            # Initialize the maximum possible minimum\n            max_min = a[0]\n            # Calculate the differences between consecutive elements\n            for j in range(1, n):\n                max_min = max(max_min, a[j] - a[j - 1])\n            results.append(max_min)\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the length of the array.\",\n        \"Read the n space-separated integers, which represent the elements of the array.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the minimum extraction operation to maximize the minimum element in the array.\",\n      \"steps\": [\n        \"For each test case, if the array length is 1, the maximum possible minimum is the single element itself.\",\n        \"Sort the array to easily identify the minimum element.\",\n        \"Iteratively apply the minimum extraction operation: subtract the minimum element from all other elements and remove it from the array.\",\n        \"Track the maximum value of the minimum element encountered during the operations.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print the maximum possible minimum value obtained.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, determine the maximum possible minimum value by applying the minimum extraction operation.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    This refers to the operation where the smallest number in the array is removed, and its value is subtracted from all remaining elements in the array.\n\n    'maximize a minimum'\n    This means to perform operations in such a way that the smallest number in the array becomes as large as possible.\n\n# [phrase showing quantity relationship]\n    'strictly greater than 1'\n    This indicates that the operation can only be applied if the array has more than one element.\n\n# [degree adverb]\n    'largest possible'\n    This means finding the maximum value that the smallest element can achieve after performing the operations.\n\n# [code logic]\n    The steps for sorting the array and iteratively applying the minimum extraction operation should be considered simultaneously. Sorting the array allows easy identification of the minimum element, and the extraction operation can be applied in a loop until the desired condition is met.\n\n# [edge case]\n    Test case with a single element: \n    Input: [1, 10]\n    Expected output: 10\n    Explanation: Since the array has only one element, no operation can be applied, and the minimum is the element itself.\n\n    Test case with all elements being the same:\n    Input: [3, 0, 0, 0]\n    Expected output: 0\n    Explanation: The array consists of zeros, and any operation will result in zeros, so the maximum possible minimum is 0.\n\n    Test case with negative numbers:\n    Input: [2, -1, 1]\n    Expected output: 2\n    Explanation: The array can be transformed to maximize the minimum element to 2 through operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and iteratively applying the minimum extraction operation will naturally handle these cases.\n\nNO", "Round_0": {"code": "def maximize_minimum(t, test_cases):\n    results = []\n    for i in range(t):\n        n, a = test_cases[i]\n        if n == 1:\n            # If there's only one element, the maximum possible minimum is the element itself\n            results.append(a[0])\n        else:\n            # Sort the array\n            a.sort()\n            # Initialize the maximum possible minimum\n            max_min = a[0]\n            # Calculate the differences between consecutive elements\n            for j in range(1, n):\n                max_min = max(max_min, a[j] - a[j - 1])\n            results.append(max_min)\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the length of the array.\",\n        \"Read the n space-separated integers that form the array a.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the minimum extraction operation to maximize the minimum element of the array.\",\n      \"steps\": [\n        \"For each test case, if n is 1, the result is the single element in the array.\",\n        \"Sort the array in ascending order.\",\n        \"Iteratively apply the minimum extraction operation by subtracting the smallest element from all subsequent elements.\",\n        \"Track the maximum value of the minimum element obtained after each operation.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, print the maximum possible minimum value obtained.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, determine the maximum possible minimum value by applying the minimum extraction operation.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    This refers to the operation where the smallest element in the array is removed, and its value is subtracted from all remaining elements.\n\n    'maximize a minimum'\n    This means to make the smallest number in the array as large as possible after performing the minimum extraction operations.\n\n# [phrase showing quantity relationship]\n    'strictly greater than 1'\n    This indicates that the operation can only be applied if the array has more than one element.\n\n# [degree adverb] \n    'largest possible value'\n    This means finding the maximum value that the smallest element can achieve after performing the operations.\n\n# [code logic]\n    The steps in the plan related to sorting the array and applying the minimum extraction operation should be implemented simultaneously. Sorting the array and then iteratively applying the extraction operation can be done in a single loop.\n\n# [edge case] \n    Test case with n = 1, e.g., [10] = 10\n    Explanation: Since the array has only one element, no operation can be applied, and the result is the element itself.\n\n    Test case with all elements being the same, e.g., [0, 0, 0] = 0\n    Explanation: The minimum extraction operation will not change the array, and the minimum remains 0.\n\n    Test case with negative numbers, e.g., [-1, -1, -1] = -1\n    Explanation: The minimum extraction operation will not change the array, and the minimum remains -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if n is 1 and sorting the array will naturally handle these cases.\n\nNO", "Round_0": {"code": "def maximize_minimum(t, test_cases):\n    results = []\n    for n, array in test_cases:\n        if n == 1:\n            results.append(array[0])\n            continue\n        \n        array.sort()\n        max_minimum = array[0]\n        current_minimum = array[0]\n        \n        for i in range(1, n):\n            current_minimum = array[i] - array[i - 1]\n            max_minimum = max(max_minimum, current_minimum)\n        \n        results.append(max_minimum)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the length of the array.\",\n        \"Read the n space-separated integers that form the array a.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the minimum extraction operation to maximize the minimum element of the array.\",\n      \"steps\": [\n        \"For each test case, if n is 1, the result is the single element in the array.\",\n        \"Sort the array in ascending order.\",\n        \"Iteratively apply the minimum extraction operation by subtracting the smallest element from all subsequent elements.\",\n        \"Track the maximum value of the minimum element obtained after each operation.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, print the maximum possible minimum value obtained.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, determine the maximum possible minimum value by applying the minimum extraction operation.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    This refers to the operation where the smallest number in the array is identified, removed, and then subtracted from each remaining element in the array.\n\n    'maximize a minimum'\n    This means to perform operations in such a way that the smallest number in the array becomes as large as possible.\n\n# [phrase showing quantity relationship]\n    'strictly greater than 1': This means the length of the array must be more than 1 to apply the operation.\n    'largest possible value': This means finding the maximum value that the minimum element can achieve after operations.\n\n# [degree adverb]\n    'largest': This refers to the maximum value that the smallest element can achieve after performing the operations.\n\n# [code logic]\n    The steps in the plan related to sorting the array and applying the minimum extraction operation should be considered simultaneously. Specifically:\n    - \"Sort the array in ascending order.\"\n    - \"Iteratively apply the minimum extraction operation by subtracting the smallest element from all subsequent elements.\"\n    These steps can be implemented in a single loop after sorting the array, where the subtraction is applied iteratively.\n\n# [edge case]\n    Case 1: n = 1, a = [10] => Output: 10\n    Explanation: With only one element, no operation can be applied, so the result is the element itself.\n\n    Case 2: n = 2, a = [0, 0] => Output: 0\n    Explanation: The array consists of zeros, so the minimum remains zero after any operations.\n\n    Case 3: n = 3, a = [-1, 2, 0] => Output: 2\n    Explanation: After applying the operations, the array can be transformed to maximize the minimum to 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting the array and applying the minimum extraction operation will naturally handle these cases. The logic inherently accounts for arrays of length 1 and arrays with all identical elements.\n\nNO", "Round_0": {"code": "def maximize_minimum(t, test_cases):\n    results = []\n    for n, array in test_cases:\n        if n == 1:\n            results.append(array[0])\n            continue\n        \n        array.sort()\n        max_minimum = array[0]\n        \n        for i in range(1, n):\n            max_minimum = max(max_minimum, array[i] - array[i - 1])\n        \n        results.append(max_minimum)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = maximize_minimum(t, test_cases)\n    \n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the corresponding arrays for each test case.\",\n      \"details\": \"Read the first line to get the number of test cases, t. For each test case, read the next line to get the integer n, and then read the following line to get the array of integers a.\"\n    },\n    {\n      \"description\": \"For each test case, determine the maximum possible minimum value after performing the minimum extraction operations.\",\n      \"details\": \"Sort the array in non-decreasing order. Calculate the differences between consecutive elements in the sorted array. The maximum of these differences will be the result for that test case.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, print the calculated maximum possible minimum value.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data to get the number of test cases and the arrays for each test case.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. If the array length is 1, the result is the single element itself.\",\n    \"  b. Sort the array in non-decreasing order.\",\n    \"  c. Initialize a variable to track the maximum difference, starting with the first element.\",\n    \"  d. Iterate through the sorted array, calculating the difference between consecutive elements.\",\n    \"  e. Update the maximum difference if the current difference is greater.\",\n    \"  f. The result for the test case is the maximum difference found.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    Explanation: This operation involves identifying the smallest number in the array, removing it, and subtracting it from all remaining elements. The goal is to maximize the smallest number in the array after performing this operation multiple times.\n\n    'maximize a minimum'\n    Explanation: The objective is to make the smallest number in the array as large as possible after performing the minimum extraction operations.\n\n# [phrase showing quantity relationship]\n    'strictly greater than 1'\n    Explanation: The operation can only be applied if the array has more than one element. In code, this can be checked using a condition like `if len(array) > 1`.\n\n# [degree adverb]\n    'largest possible'\n    Explanation: This refers to finding the maximum value that the smallest element can achieve after the operations. In code, this involves calculating the maximum difference between consecutive elements in a sorted array.\n\n# [code logic]\n    Steps 2b, 2c, 2d, and 2e should be implemented simultaneously.\n    Explanation: Sorting the array and calculating the differences between consecutive elements can be done in a single loop after sorting. This involves iterating through the sorted array and updating the maximum difference.\n\n# [edge case]\n    Test case with a single element: \n    Input: [1]\n    Expected output: 1\n    Explanation: No operation can be performed, so the result is the element itself.\n\n    Test case with all elements the same:\n    Input: [0, 0]\n    Expected output: 0\n    Explanation: The array will always consist only of zeros, so the result is 0.\n\n    Test case with negative and positive numbers:\n    Input: [-1, 1]\n    Expected output: 2\n    Explanation: After performing the operation, the array changes to [2], which is the maximum possible minimum.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting the array and calculating the maximum difference between consecutive elements will handle these cases correctly.\n\nNO", "Round_0": {"code": "def maximize_minimum_extraction(t, test_cases):\n    results = []\n    for n, array in test_cases:\n        if n == 1:\n            results.append(array[0])\n            continue\n        \n        array.sort()\n        max_minimum = array[0]\n        \n        for i in range(1, n):\n            max_minimum = max(max_minimum, array[i] - array[i - 1])\n        \n        results.append(max_minimum)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = maximize_minimum_extraction(t, test_cases)\n    \n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the length of the array.\",\n        \"Read the array of n integers.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the minimum extraction operation to maximize the minimum element of the array.\",\n      \"steps\": [\n        \"Sort the array in ascending order.\",\n        \"Initialize a variable to track the maximum possible minimum value.\",\n        \"Iterate through the sorted array, applying the minimum extraction operation.\",\n        \"For each element, calculate the difference between the current element and the previous element.\",\n        \"Update the maximum possible minimum value with the maximum of the current difference.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"Store the maximum possible minimum value for each test case.\",\n        \"Print the stored results for all test cases.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, sort the array and apply the minimum extraction operation to find the maximum possible minimum value.\",\n    \"Store the result for each test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    Explanation: This operation involves identifying the smallest number in the array, removing it, and subtracting it from all remaining elements. The goal is to maximize the smallest number in the array after several operations.\n\n    'maximize a minimum'\n    Explanation: The task is to make the smallest number in the array as large as possible after performing the minimum extraction operation multiple times.\n\n# [phrase showing quantity relationship]\n    'strictly greater than 1': This means the operation can only be applied if the array has more than one element.\n    'as many times as he wants (possibly, zero)': This means the operation can be applied any number of times, including not at all.\n\n# [degree adverb]\n    'largest possible value': This means finding the maximum value that the smallest element can achieve after the operations.\n    'smallest element': This refers to the minimum value in the array at any given time.\n\n# [code logic]\n    The steps in the plan are well-structured, but the iteration through the sorted array and the calculation of differences should be implemented simultaneously. Specifically, sorting the array and then iterating through it to calculate differences and update the maximum possible minimum value should be done in a single loop.\n\n# [edge case]\n    Case 1: n = 1, a = [10] => Output: 10\n    Explanation: With only one element, no operation can be performed, so the result is the element itself.\n\n    Case 2: n = 2, a = [0, 0] => Output: 0\n    Explanation: The array consists of zeros, and any operation will still result in zeros.\n\n    Case 3: n = 3, a = [-1, 0, 1] => Output: 1\n    Explanation: After sorting, the array becomes [-1, 0, 1]. The operations will result in [1] as the maximum possible minimum.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting the array and calculating differences will naturally handle these cases.\n\nNO", "Round_0": {"code": "def maximize_minimum(t, test_cases):\n    results = []\n    for n, array in test_cases:\n        if n == 1:\n            results.append(array[0])\n            continue\n        \n        array.sort()\n        max_minimum = array[0]\n        \n        for i in range(1, n):\n            max_minimum = max(max_minimum, array[i] - array[i - 1])\n        \n        results.append(max_minimum)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the length of the array.\",\n        \"Read the array of n integers.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the minimum extraction operation to maximize the minimum element of the array.\",\n      \"steps\": [\n        \"For each test case, if n is 1, the result is the single element in the array.\",\n        \"If n is greater than 1, sort the array in ascending order.\",\n        \"Iteratively apply the minimum extraction operation by removing the smallest element and subtracting it from the remaining elements.\",\n        \"Track the maximum value of the minimum element during the operations.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the maximum possible minimum value obtained.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, determine the maximum possible minimum value using the minimum extraction operation.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    This refers to the operation where the smallest number in the array is removed, and this number is subtracted from all remaining elements in the array.\n\n    'maximize a minimum'\n    This means to perform operations in such a way that the smallest number in the array becomes as large as possible.\n\n# [phrase showing quantity relationship]\n    'strictly greater than 1'\n    This indicates that the operation can only be applied if the array has more than one element.\n\n# [degree adverb] \n    'largest possible value'\n    This means finding the maximum value that the smallest element can achieve after performing the operations.\n\n# [code logic]\n    The steps for sorting the array and iteratively applying the minimum extraction operation should be implemented simultaneously. Sorting the array first allows for efficient extraction of the minimum element, and the subtraction operation can be performed in a loop.\n\n# [edge case] \n    Test case with n = 1, such as [10] = 10\n    Explanation: Since the array has only one element, no operation can be applied, and the result is the element itself.\n\n    Test case with all elements being the same, such as [0, 0] = 0\n    Explanation: The array will always consist only of zeros, and the minimum extraction operation will not change the array.\n\n    Test case with negative numbers, such as [-1, 1] = 2\n    Explanation: The array will be modified as [-1, 1] \u2192 [2]. The maximum of the minimum elements is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and iteratively applying the minimum extraction operation will handle these cases correctly.\n\nNO", "Round_0": {"code": "def maximize_minimum(t, test_cases):\n    results = []\n    for n, array in test_cases:\n        if n == 1:\n            results.append(array[0])\n        else:\n            array.sort()\n            max_minimum = array[0]\n            for i in range(1, n):\n                max_minimum = max(max_minimum, array[i] - array[i - 1])\n            results.append(max_minimum)\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the corresponding arrays for each test case.\",\n      \"details\": \"Read the first line to get the number of test cases, t. For each test case, read the next line to get the integer n, and then read the following line to get the array of integers a.\"\n    },\n    {\n      \"description\": \"For each test case, determine the maximum possible minimum value after performing the minimum extraction operations.\",\n      \"details\": \"Sort the array in non-decreasing order. Calculate the differences between consecutive elements in the sorted array. The maximum of these differences will be the result for that test case.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, print the calculated maximum possible minimum value.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. If the array length is 1, the result is the single element itself.\",\n    \"  b. Sort the array in non-decreasing order.\",\n    \"  c. Initialize a variable to track the maximum possible minimum value.\",\n    \"  d. Iterate through the sorted array and calculate the difference between consecutive elements.\",\n    \"  e. Update the maximum possible minimum value with the maximum of these differences.\",\n    \"  f. Store the result for the current test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    Explanation: This operation involves identifying the smallest number in the array, removing it, and subtracting it from all remaining elements. The goal is to maximize the smallest number in the array after performing this operation multiple times.\n\n    'maximize a minimum'\n    Explanation: The objective is to make the smallest number in the array as large as possible after performing the minimum extraction operations.\n\n# [phrase showing quantity relationship]\n    'strictly greater than 1': This means the operation can only be applied if the array has more than one element.\n    'as many times as he wants (possibly, zero)': This indicates that the operation can be performed any number of times, including not at all.\n\n# [degree adverb]\n    'largest possible value': This means finding the maximum value that the smallest element can achieve after the operations.\n    'smallest element': Refers to the minimum value in the array at any given time.\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the calculation of differences between consecutive elements (step 2d) and updating the maximum possible minimum value (step 2e) can be done in a single loop over the sorted array.\n\n# [edge case]\n    Test case: [1] = 10\n    Explanation: With only one element, no operation can be performed, so the result is the element itself.\n\n    Test case: [0, 0] = 0\n    Explanation: The array consists only of zeros, so the minimum remains zero after any operations.\n\n    Test case: [-1, 2, 0] = 2\n    Explanation: After sorting and performing operations, the maximum possible minimum value is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting the array and calculating differences will naturally handle these cases.\n\nNO", "Round_0": {"code": "def maximize_minimum(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        if n == 1:\n            results.append(a[0])\n        else:\n            a.sort()\n            max_minimum = a[0]\n            for i in range(1, n):\n                max_minimum = max(max_minimum, a[i] - a[i - 1])\n            results.append(max_minimum)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = maximize_minimum(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the length of the array.\",\n        \"Read the array of n integers.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the minimum extraction operation to maximize the minimum element of the array.\",\n      \"steps\": [\n        \"For each test case, if n is 1, the result is the single element in the array.\",\n        \"If n is greater than 1, sort the array in non-decreasing order.\",\n        \"Iteratively apply the minimum extraction operation: subtract the smallest element from all other elements and remove it from the array.\",\n        \"Track the maximum value of the minimum element during the operations.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the maximum possible minimum value obtained.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, determine the maximum possible minimum value using the minimum extraction operation.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    This refers to the operation where the smallest number in the array is identified, removed, and subtracted from each remaining element in the array.\n\n    'maximize a minimum'\n    This means to perform operations such that the smallest number in the array becomes as large as possible.\n\n# [phrase showing quantity relationship]\n    'strictly greater than 1': This indicates that the operation can only be applied if the array length is more than 1.\n    Implementation: Check if the length of the array is greater than 1 before applying the operation.\n\n# [degree adverb]\n    'largest possible value': This means finding the maximum value that the smallest element can achieve after operations.\n    Implementation: Track the maximum value of the minimum element during the operations.\n\n# [code logic]\n    The steps in the plan related to sorting the array and applying the minimum extraction operation should be implemented simultaneously. Sorting the array and iteratively applying the operation can be done in a single loop where the smallest element is subtracted from the rest and removed.\n\n# [edge case]\n    Test case with n = 1, e.g., [10] = 10\n    Explanation: Since the array length is 1, no operation can be applied, and the result is the single element itself.\n\n    Test case with all elements equal, e.g., [0, 0] = 0\n    Explanation: The array will always consist only of zeros, and the minimum remains 0.\n\n    Test case with negative numbers, e.g., [-1, 1] = 2\n    Explanation: The array changes as follows: [-1, 1] \u2192 [2]. The maximum of the minimum elements is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking the array length and applying the operation iteratively will handle these cases.\n\nNO", "Round_0": {"code": "def maximize_minimum(t, test_cases):\n    results = []\n    for n, array in test_cases:\n        if n == 1:\n            results.append(array[0])\n        else:\n            array.sort()\n            max_min = array[0]\n            for i in range(1, n):\n                max_min = max(max_min, array[i] - array[i - 1])\n            results.append(max_min)\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n      \"details\": \"Read the integer t from the first line, then for each test case, read the integer n and the array of n integers.\"\n    },\n    {\n      \"description\": \"Implement the minimum extraction operation on the array.\",\n      \"details\": \"Identify the smallest number in the array, remove it, and subtract it from each remaining element.\"\n    },\n    {\n      \"description\": \"Determine the maximum possible minimum value for each test case.\",\n      \"details\": \"Apply the minimum extraction operation iteratively and track the minimum value obtained after each operation.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"Print the maximum possible minimum value for each test case on a new line.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following steps:\",\n    \"  - Read the integer n and the array of n integers.\",\n    \"  - If n is 1, output the single element as the result.\",\n    \"  - Otherwise, sort the array to facilitate the minimum extraction operation.\",\n    \"  - Initialize a variable to track the maximum possible minimum value.\",\n    \"  - Iterate through the sorted array, applying the minimum extraction operation:\",\n    \"    - Calculate the difference between consecutive elements to simulate the operation.\",\n    \"    - Update the maximum possible minimum value based on the differences.\",\n    \"  - Output the maximum possible minimum value for the current test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    Explanation: This operation involves identifying the smallest number in the array, removing it, and subtracting it from each remaining element. The goal is to maximize the minimum value of the array after several operations.\n\n    'maximize a minimum'\n    Explanation: This means to make the smallest number in the array as large as possible after performing the allowed operations.\n\n# [phrase showing quantity relationship]\n    'strictly greater than 1'\n    Explanation: The operation can only be applied if the array length is more than 1. In code, this can be checked using `if len(array) > 1:`.\n\n# [degree adverb]\n    'largest possible'\n    Explanation: This refers to finding the maximum value that the minimum element can achieve after the operations. In code, this involves tracking the maximum of the minimum values obtained during the operations.\n\n# [code logic]\n    The steps involving sorting the array and iterating through it to apply the minimum extraction operation should be considered simultaneously. Sorting the array allows for easy calculation of differences between consecutive elements, which simulates the operation.\n\n# [edge case]\n    Test case: [1] = 10\n    Explanation: With only one element, no operation can be performed, so the result is the element itself.\n\n    Test case: [0, 0] = 0\n    Explanation: The array consists only of zeros, so the maximum possible minimum remains 0 after any operations.\n\n    Test case: [-1, 1] = 2\n    Explanation: After removing -1 and adjusting, the array becomes [2], which is the maximum possible minimum.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if `n` is 1 and handling arrays of zeros or negative numbers inherently covers these scenarios.\n\nNO", "Round_0": {"code": "def maximize_minimum(t, test_cases):\n    results = []\n    for n, array in test_cases:\n        if n == 1:\n            results.append(array[0])\n        else:\n            array.sort()\n            max_minimum = array[0]\n            for i in range(1, n):\n                max_minimum = max(max_minimum, array[i] - array[i - 1])\n            results.append(max_minimum)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the length of the array.\",\n        \"Read the array of n integers.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the minimum extraction operation to maximize the minimum element of the array.\",\n      \"steps\": [\n        \"For each test case, if the array length is 1, the maximum minimum is the single element itself.\",\n        \"Sort the array in ascending order.\",\n        \"Iteratively apply the minimum extraction operation by subtracting the smallest element from all subsequent elements.\",\n        \"Track the maximum of the minimum elements obtained after each operation.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, print the maximum possible minimum value obtained.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, determine the maximum possible minimum value by applying the minimum extraction operation.\",\n    \"Output the maximum possible minimum value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    This refers to the operation where the smallest number in the array is identified and removed, and then subtracted from each remaining element in the array.\n\n    'maximize a minimum'\n    This means to perform operations such that the smallest number in the array becomes as large as possible.\n\n# [phrase showing quantity relationship]\n    'strictly greater than 1'\n    This indicates that the operation can only be applied if the array has more than one element.\n\n# [degree adverb]\n    'largest possible'\n    This means finding the maximum value that the smallest element can achieve after performing the operations.\n\n# [code logic]\n    The steps for parsing input and outputting results can be implemented separately. However, within the operation implementation, sorting the array and iteratively applying the minimum extraction should be done in a loop, as they are dependent on each other.\n\n# [edge case]\n    Test case with a single element: [10] = 10\n    Explanation: Since the array length is 1, no operation can be applied, and the minimum is the element itself.\n\n    Test case with all elements being the same: [0, 0] = 0\n    Explanation: The array will always consist only of zeros, and the minimum remains 0.\n\n    Test case with negative and positive numbers: [-1, 1] = 2\n    Explanation: The array changes as follows: [-1, 1] \u2192 [2]. The maximum of the minimum elements is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of sorting and iteratively applying the minimum extraction operation inherently handles these cases.\n\nNO", "Round_0": {"code": "def maximize_minimum(t, test_cases):\n    results = []\n    for i in range(t):\n        n, a = test_cases[i]\n        if n == 1:\n            # If the array has only one element, the maximum minimum is the element itself\n            results.append(a[0])\n            continue\n        \n        # Sort the array\n        a.sort()\n        \n        # Initialize the maximum possible minimum\n        max_min = a[0]\n        \n        # Apply the minimum extraction operation\n        for j in range(1, n):\n            # Calculate the difference between current and previous element\n            diff = a[j] - a[j - 1]\n            # Update the maximum possible minimum\n            max_min = max(max_min, diff)\n        \n        results.append(max_min)\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nt = int(data[0])\nindex = 1\ntest_cases = []\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1:index + 1 + n]))\n    test_cases.append((n, a))\n    index += 1 + n\n\n# Get results\nresults = maximize_minimum(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def maximize_minimum(t, test_cases):\n    results = []\n    for i in range(t):\n        n, a = test_cases[i]\n        if n == 1:\n            # If the array has only one element, the maximum minimum is the element itself\n            results.append(a[0])\n            continue\n        \n        # Sort the array\n        a.sort()\n        \n        # Initialize the maximum possible minimum\n        max_min = a[0]\n        \n        # Apply the minimum extraction operation\n        for j in range(1, n):\n            # Calculate the difference between current and previous element\n            diff = a[j] - a[j - 1]\n            # Update the maximum possible minimum\n            max_min = max(max_min, diff)\n        \n        results.append(max_min)\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nt = int(data[0])\nindex = 1\ntest_cases = []\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1:index + 1 + n]))\n    test_cases.append((n, a))\n    index += 1 + n\n\n# Get results\nresults = maximize_minimum(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the length of the array.\",\n        \"Read the n space-separated integers, which represent the elements of the array.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the minimum extraction operation to maximize the minimum element in the array.\",\n      \"steps\": [\n        \"For each test case, if the array length is 1, the maximum possible minimum is the single element itself.\",\n        \"Sort the array to easily identify the minimum element.\",\n        \"Iteratively apply the minimum extraction operation: subtract the minimum element from all other elements and remove it from the array.\",\n        \"Track the maximum value of the minimum element encountered during the operations.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print the maximum possible minimum value obtained.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, determine the maximum possible minimum value by applying the minimum extraction operation.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum extraction'\n    This refers to the operation where the smallest number in the array is removed, and its value is subtracted from all remaining elements in the array.\n\n    'maximize a minimum'\n    This means to perform operations in such a way that the smallest number in the array becomes as large as possible.\n\n# [phrase showing quantity relationship]\n    'strictly greater than 1'\n    This indicates that the operation can only be applied if the array has more than one element.\n\n# [degree adverb]\n    'largest possible'\n    This means finding the maximum value that the smallest element can achieve after performing the operations.\n\n# [code logic]\n    The steps for sorting the array and iteratively applying the minimum extraction operation should be considered simultaneously. Sorting the array allows easy identification of the minimum element, and the extraction operation can be applied in a loop until the desired condition is met.\n\n# [edge case]\n    Test case with a single element: \n    Input: [1, 10]\n    Expected output: 10\n    Explanation: Since the array has only one element, no operation can be applied, and the minimum is the element itself.\n\n    Test case with all elements being the same:\n    Input: [3, 0, 0, 0]\n    Expected output: 0\n    Explanation: The array consists of zeros, and any operation will result in zeros, so the maximum possible minimum is 0.\n\n    Test case with negative numbers:\n    Input: [2, -1, 1]\n    Expected output: 2\n    Explanation: The array can be transformed to maximize the minimum element to 2 through operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and iteratively applying the minimum extraction operation will naturally handle these cases.\n\nNO", "Round_0": {"code": "def maximize_minimum(t, test_cases):\n    results = []\n    for i in range(t):\n        n, a = test_cases[i]\n        if n == 1:\n            # If there's only one element, the maximum possible minimum is the element itself\n            results.append(a[0])\n        else:\n            # Sort the array\n            a.sort()\n            # Initialize the maximum possible minimum\n            max_min = a[0]\n            # Calculate the differences between consecutive elements\n            for j in range(1, n):\n                max_min = max(max_min, a[j] - a[j - 1])\n            results.append(max_min)\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 130, "prompt": "Yelisey has an array a with n integers.\n\nIf a has length strictly greater than 1, then Yelisei can apply an operation called minimum extraction to it: \n\n  1. First, Yelisei identifies the smallest number m in the array. If there are multiple identical minima, Yelisey can choose any of them. \n  2. Then the chosen minimal element is deleted from the array. After that, m is subtracted from each remaining element. \n\nTherefore, following each operation, the array's length decreases by 1.\n\nFor example, if a = [1, 6, -4, -2, -4], then the minimum element in it is a_3 = -4, which means that after this operation the array will be equal to a=[1 {- (-4)}, 6 {- (-4)}, -2 {- (-4)}, -4 {- (-4)}] = [5, 10, 2, 0].\n\nSince Yelisey likes big numbers, he wants the numbers in the array a to be as big as possible.\n\nFormally speaking, he wants to make the minimum of the numbers in array a to be maximal possible (i.e. he want to maximize a minimum). To do this, Yelisey can apply the minimum extraction operation to the array as many times as he wants (possibly, zero). Note that the operation cannot be applied to an array of length 1.\n\nHelp him find out the largest possible value that the smallest element of the array can achieve after implementing several (possibly, zero) minimum extraction operations on the array.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 78}
