{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "repair_prompt": ["Monocarp is engaged in yet another computer game adventure. In this game, his virtual persona must defeat a dragon. The confrontation with the dragon extends over 100^{500} seconds. Throughout that prolonged encounter, Monocarp using a poisoned dagger to assault the dragon. The i-th attack takes place at the onset of the a_i-th second following the commencement of the battle. The dagger itself inflicts no damage. But, it imposes a toxic effect on the dragon, which inflicts 1 damage during each of the subsequent k seconds (initiating with the very second when the dragon was struck by the dagger). Nonetheless, if the dragon is already under the influence of poison, then the dagger refreshes the poison impact (i.e., annuls the existing poison effect and implements a fresh one).\n\nFor instance, let's assume k equals 4, and Monocarp stabs the dragon during the seconds 2, 4, and 10. Then the poison impact is initiated at the beginning of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the start of the 4-th second, the poison impact is reset, resulting in precisely 1 damage during the seconds 4, 5, 6, and 7; finally, during the 10-th second, the poison impact is activated once more, delivering 1 damage during the seconds 10, 11, 12, and 13. Altogether, the dragon incurs 10 damage.\n\nMonocarp understands that the dragon possesses h hit points, and if he inflicts h or more damage to the dragon during the clash \u2014 he vanquishes the dragon. Monocarp hasn't made up his mind concerning the potency of the poison he'll employ throughout the battle, hence he wishes to determine the minimal feasible value of k (the duration of seconds the poison effect persists) that is sufficient to inflict h or more damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp is engaged in yet another computer game adventure. In this game, his virtual persona must defeat a dragon. The confrontation with the dragon extends over 100^{500} seconds. Throughout that prolonged encounter, Monocarp using a poisoned dagger to assault the dragon. The i-th attack takes place at the onset of the a_i-th second following the commencement of the battle. The dagger itself inflicts no damage. The dagger, however, imposes a toxic effect on the dragon. This effect inflicts 1 damage during each of the subsequent k seconds (initiating with the very second when the dragon was struck by the dagger). Nonetheless, if the dragon is already under the influence of poison, then the dagger refreshes the poison impact (i.e., annuls the existing poison effect and implements a fresh one).\n\nFor instance, let's assume k equals 4, and Monocarp stabs the dragon during the seconds 2, 4, and 10. Then the poison impact is initiated at the beginning of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the start of the 4-th second, the poison impact is reset, resulting in precisely 1 damage during the seconds 4, 5, 6, and 7; finally, during the 10-th second, the poison impact is activated once more, delivering 1 damage during the seconds 10, 11, 12, and 13. Altogether, the dragon incurs 10 damage.\n\nMonocarp understands that the dragon possesses h hit points, and if he inflicts h or more damage to the dragon during the clash \u2014 he vanquishes the dragon. Monocarp hasn't made up his mind concerning the potency of the poison he'll employ throughout the battle, hence he wishes to determine the minimal feasible value of k (the duration of seconds the poison effect persists) that is sufficient to inflict h or more damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp is engaged in yet another computer game adventure. In this game, his virtual persona must defeat a dragon, and the confrontation with the dragon extends over 100^{500} seconds. Throughout that prolonged encounter, Monocarp using a poisoned dagger to assault the dragon. The i-th attack takes place at the onset of the a_i-th second following the commencement of the battle, and the dagger itself inflicts no damage. But, it imposes a toxic effect on the dragon, which inflicts 1 damage during each of the subsequent k seconds (initiating with the very second when the dragon was struck by the dagger). Nonetheless, if the dragon is already under the influence of poison, then the dagger refreshes the poison impact (i.e., annuls the existing poison effect and implements a fresh one).\n\nFor instance, let's assume k equals 4, and Monocarp stabs the dragon during the seconds 2, 4, and 10. Then the poison impact is initiated at the beginning of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the start of the 4-th second, the poison impact is reset, resulting in precisely 1 damage during the seconds 4, 5, 6, and 7; finally, during the 10-th second, the poison impact is activated once more, delivering 1 damage during the seconds 10, 11, 12, and 13. Altogether, the dragon incurs 10 damage.\n\nMonocarp understands that the dragon possesses h hit points, and if he inflicts h or more damage to the dragon during the clash \u2014 he vanquishes the dragon. Monocarp hasn't made up his mind concerning the potency of the poison he'll employ throughout the battle, hence he wishes to determine the minimal feasible value of k (the duration of seconds the poison effect persists) that is sufficient to inflict h or more damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def calculate_min_k(n, h, attack_times):\n    # Binary search for the minimum k\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        total_damage = 0\n        # Calculate total damage for current k = mid\n        for i in range(n):\n            if i == n - 1:\n                total_damage += mid\n            else:\n                total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n        \n        if total_damage >= h:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, h = int(data[index]), int(data[index + 1])\n        index += 2\n        attack_times = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = calculate_min_k(n, h, attack_times)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def calculate_damage(a, k):\n    total_damage = 0\n    n = len(a)\n    for i in range(n - 1):\n        total_damage += min(k, a[i + 1] - a[i])\n    total_damage += k  # Add damage for the last attack\n    return total_damage\n\ndef find_min_k(n, h, a):\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        if calculate_damage(a, mid) >= h:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, h = int(data[index]), int(data[index + 1])\n        index += 2\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        min_k = find_min_k(n, h, a)\n        results.append(min_k)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_damage(attacks, k):\n    total_damage = 0\n    n = len(attacks)\n    for i in range(n):\n        if i == n - 1:\n            total_damage += k\n        else:\n            total_damage += min(k, attacks[i + 1] - attacks[i])\n    return total_damage\n\ndef find_minimum_k(n, h, attacks):\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        if calculate_damage(attacks, mid) >= h:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, h = int(data[index]), int(data[index + 1])\n        index += 2\n        attacks = list(map(int, data[index:index + n]))\n        index += n\n        \n        min_k = find_minimum_k(n, h, attacks)\n        results.append(min_k)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_k_for_damage(t, test_cases):\n    results = []\n    \n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, 10**18\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n            \n            # Calculate total damage for current k (mid)\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n            \n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n        \n        results.append(left)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        attacks = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, h, attacks))\n    \n    results = minimum_k_for_damage(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_k_to_defeat_dragon(t, test_cases):\n    results = []\n    \n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, 10**18\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n            \n            # Calculate total damage for current k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n            \n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n        \n        results.append(low)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, h = int(data[index]), int(data[index + 1])\n        index += 2\n        attacks = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, h, attacks))\n    \n    results = minimum_k_to_defeat_dragon(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nmain()", "def minimum_k_for_damage(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, h, attacks = case\n        left, right = 1, h\n        \n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n            \n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n            \n                if total_damage >= h:\n                    break\n            \n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n        \n        results.append(left)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        attacks = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, h, attacks))\n    \n    results = minimum_k_for_damage(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_k(n, h, attack_times):\n    # Binary search for the minimum k\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        total_damage = 0\n        \n        # Calculate total damage for current k = mid\n        for i in range(n):\n            if i == n - 1:\n                total_damage += mid\n            else:\n                total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n        \n        if total_damage >= h:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        attack_times = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = calculate_minimum_k(n, h, attack_times)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_damage(a, k):\n    total_damage = 0\n    n = len(a)\n    for i in range(n - 1):\n        total_damage += min(k, a[i + 1] - a[i])\n    total_damage += k  # Add damage for the last attack\n    return total_damage\n\ndef find_min_k(n, h, a):\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        if calculate_damage(a, mid) >= h:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, h = int(data[index]), int(data[index + 1])\n        index += 2\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        min_k = find_min_k(n, h, a)\n        results.append(min_k)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_damage(attacks, k):\n    total_damage = 0\n    n = len(attacks)\n    for i in range(n):\n        if i == n - 1:\n            total_damage += k\n        else:\n            total_damage += min(k, attacks[i + 1] - attacks[i])\n    return total_damage\n\ndef find_minimum_k(n, h, attacks):\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        if calculate_damage(attacks, mid) >= h:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, h = int(data[index]), int(data[index + 1])\n        index += 2\n        attacks = list(map(int, data[index:index + n]))\n        index += n\n        \n        min_k = find_minimum_k(n, h, attacks)\n        results.append(min_k)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_damage(a, k):\n    total_damage = 0\n    n = len(a)\n    for i in range(n - 1):\n        total_damage += min(k, a[i + 1] - a[i])\n    total_damage += k  # Damage for the last attack\n    return total_damage\n\ndef find_minimum_k(n, h, a):\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        if calculate_damage(a, mid) >= h:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, h = int(data[index]), int(data[index + 1])\n        index += 2\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = find_minimum_k(n, h, a)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_min_k(n, h, attack_times):\n    # Binary search for the minimum k\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        total_damage = 0\n        # Calculate total damage for current k = mid\n        for i in range(n):\n            if i == n - 1:\n                total_damage += mid\n            else:\n                total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n        \n        if total_damage >= h:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, h = int(data[index]), int(data[index + 1])\n        index += 2\n        attack_times = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = calculate_min_k(n, h, attack_times)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of attacks, the required damage, and the list of attack times.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, determine the minimum value of k such that the total damage inflicted is at least h.\",\n      \"output\": \"The minimum value of k for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the total damage inflicted for a given k by simulating the poison effect over the attack times.\",\n      \"output\": \"The total damage inflicted for a given k.\"\n    },\n    {\n      \"description\": \"Implement a search strategy to find the minimal k that satisfies the damage requirement.\",\n      \"output\": \"The optimal k value for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, initialize variables to store the number of attacks, required damage, and attack times.\",\n    \"Define a function to calculate the total damage for a given k by iterating over the attack times and simulating the poison effect.\",\n    \"Use a binary search or linear search strategy to find the minimal k that results in total damage greater than or equal to h.\",\n    \"Output the minimal k for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is a mechanism where each attack refreshes the poison duration, causing damage over a period of k seconds. The goal is to find the minimal k such that the total damage is at least h.\n\n    'minimal feasible value of k'\n    Explanation: This refers to the smallest duration of the poison effect that ensures the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb] \n    'minimal'\n    Explanation: The smallest possible value of k that satisfies the condition. This can be implemented using a search strategy, such as binary search, to efficiently find the smallest k.\n\n# [code logic]\n    The steps for calculating total damage for a given k and searching for the minimal k should be considered simultaneously. Specifically, the calculation of total damage and the search strategy (e.g., binary search) should be integrated to efficiently find the minimal k.\n\n# [edge case] \n    1. Test case with n = 1 and h = 1, a_1 = 1\n       Expected output: 1\n       Explanation: With only one attack, the minimal k is 1 to inflict at least 1 damage.\n       \n    2. Test case with n = 2 and h = 2, a_1 = 1, a_2 = 3\n       Expected output: 1\n       Explanation: The attacks are spaced such that k = 1 is sufficient to cover both attacks and inflict 2 damage.\n       \n    3. Test case with n = 3 and h = 5, a_1 = 1, a_2 = 2, a_3 = 3\n       Expected output: 2\n       Explanation: The attacks are consecutive, so k = 2 is needed to ensure continuous damage over 5 seconds.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a search strategy to find the minimal k will naturally handle these cases.\n\nNO", "Round_0": {"code": "def calculate_min_k(n, h, attack_times):\n    # Binary search for the minimum k\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        total_damage = 0\n        # Calculate total damage for current k = mid\n        for i in range(n):\n            if i == n - 1:\n                total_damage += mid\n            else:\n                total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n        \n        if total_damage >= h:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, h = int(data[index]), int(data[index + 1])\n        index += 2\n        attack_times = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = calculate_min_k(n, h, attack_times)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of attacks, the required damage, and the list of attack times.\",\n      \"output\": \"A structured format containing all test cases with their respective parameters.\"\n    },\n    {\n      \"description\": \"For each test case, determine the minimum value of k such that the total damage inflicted is at least h.\",\n      \"output\": \"The minimum value of k for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the total damage inflicted for a given k by simulating the poison effect over the attack times.\",\n      \"output\": \"The total damage inflicted for a specific k.\"\n    },\n    {\n      \"description\": \"Implement a search mechanism (e.g., binary search) to efficiently find the minimal k that satisfies the damage requirement.\",\n      \"output\": \"The minimal k for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, initialize variables to store the number of attacks, required damage, and attack times.\",\n    \"Define a function to calculate the total damage for a given k by iterating over the attack times and applying the poison effect.\",\n    \"Use a binary search to find the minimal k that results in total damage greater than or equal to the required damage h.\",\n    \"Output the minimal k for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is a mechanism where each attack refreshes the poison duration, causing 1 damage per second for k seconds. If the dragon is already poisoned, the effect is reset.\n\n    'minimal feasible value of k'\n    Explanation: This refers to the smallest duration of the poison effect that results in at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. This can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'minimal'\n    Explanation: The smallest possible value of k that satisfies the condition. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n    The steps related to calculating the total damage for a given k and using a binary search to find the minimal k should be considered simultaneously. Specifically, the function to calculate damage should be used within the binary search loop to determine if the current k is sufficient.\n\n# [edge case]\n    1. Test case with n = 1 and h = 1, a_1 = 1: The expected output is 1.\n       Explanation: With only one attack and needing only 1 damage, the minimal k is 1.\n       \n    2. Test case with n = 1 and h = 10^18, a_1 = 1: The expected output is 10^18.\n       Explanation: With only one attack and needing maximum damage, k must be equal to h.\n       \n    3. Test case with n = 100 and h = 1, a_1 to a_100 = 1 to 100: The expected output is 1.\n       Explanation: With multiple attacks and needing only 1 damage, the minimal k is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k to meet the damage requirement.\n\nNO", "Round_0": {"code": "def calculate_damage(a, k):\n    total_damage = 0\n    n = len(a)\n    for i in range(n - 1):\n        total_damage += min(k, a[i + 1] - a[i])\n    total_damage += k  # Add damage for the last attack\n    return total_damage\n\ndef find_min_k(n, h, a):\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        if calculate_damage(a, mid) >= h:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, h = int(data[index]), int(data[index + 1])\n        index += 2\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        min_k = find_min_k(n, h, a)\n        results.append(min_k)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: find_min_k() missing 3 required positional arguments: 'n', 'h', and 'a'"}, "Round_1": {"code": "def calculate_damage(a, k):\n    total_damage = 0\n    n = len(a)\n    for i in range(n - 1):\n        total_damage += min(k, a[i + 1] - a[i])\n    total_damage += k  # Add damage for the last attack\n    return total_damage\n\ndef find_min_k(n, h, a):\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        if calculate_damage(a, mid) >= h:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, h = int(data[index]), int(data[index + 1])\n        index += 2\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        min_k = find_min_k(n, h, a)\n        results.append(min_k)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of attacks, the required damage, and the list of attack times.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Structured data containing test cases with n, h, and attack times\"\n    },\n    {\n      \"description\": \"For each test case, determine the minimum value of k such that the total damage inflicted is at least h.\",\n      \"input\": \"Structured data for a single test case\",\n      \"output\": \"Minimum value of k for that test case\"\n    },\n    {\n      \"description\": \"Calculate the total damage inflicted for a given k by simulating the poison effect over the attack times.\",\n      \"input\": \"Attack times and a candidate value of k\",\n      \"output\": \"Total damage inflicted\"\n    },\n    {\n      \"description\": \"Implement a search strategy to find the minimum k that results in at least h damage. This could be a binary search over possible k values.\",\n      \"input\": \"Structured data for a single test case\",\n      \"output\": \"Minimum k that results in at least h damage\"\n    },\n    {\n      \"description\": \"Output the results for all test cases in the required format.\",\n      \"input\": \"List of minimum k values for each test case\",\n      \"output\": \"Formatted output string\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize variables and prepare to determine the minimum k.\",\n    \"Implement a function to calculate the total damage for a given k by iterating over attack times and simulating the poison effect.\",\n    \"Use a binary search to efficiently find the minimum k that results in at least h damage for each test case.\",\n    \"Store the result for each test case.\",\n    \"Output the results for all test cases in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect': The poison effect is a mechanism where the dragon receives 1 damage for each of the subsequent k seconds after being struck by the dagger. If the dragon is already poisoned, the effect is refreshed.\n    'minimum feasible value of k': This refers to the smallest duration of the poison effect that is sufficient to inflict h or more damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage': This means the total damage inflicted must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb]\n    'minimal feasible value': This means finding the smallest possible k that meets the requirement. In code, this can be implemented using a search strategy, such as binary search, to efficiently find the smallest k.\n\n# [code logic]\n    The steps related to calculating the total damage for a given k and using a search strategy to find the minimum k should be considered simultaneously. Specifically, the calculation of damage and the binary search logic should be integrated to efficiently determine the minimum k.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and needing to inflict 1 damage, k must be at least 1.\n\n    Test case with attacks spaced far apart:\n    2 2\n    1 1000000000\n    Expected output: 1\n    Explanation: The attacks are spaced far apart, so k=1 is sufficient to inflict 2 damage.\n\n    Test case with maximum h:\n    1 1000000000000000000\n    1\n    Expected output: 1000000000000000000\n    Explanation: With only one attack, k must be equal to h to inflict the required damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a binary search to find the minimum k should be sufficient to handle all edge cases.\n\nNO", "Round_0": {"code": "def calculate_damage(attacks, k):\n    total_damage = 0\n    n = len(attacks)\n    for i in range(n):\n        if i == n - 1:\n            total_damage += k\n        else:\n            total_damage += min(k, attacks[i + 1] - attacks[i])\n    return total_damage\n\ndef find_minimum_k(n, h, attacks):\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        if calculate_damage(attacks, mid) >= h:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, h = int(data[index]), int(data[index + 1])\n        index += 2\n        attacks = list(map(int, data[index:index + n]))\n        index += n\n        \n        min_k = find_minimum_k(n, h, attacks)\n        results.append(min_k)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of attacks, the required damage, and the list of attack times.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the values of n (number of attacks) and h (required damage).\",\n        \"Read the list of attack times a_i.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total damage inflicted for a given poison duration k for each test case.\",\n      \"steps\": [\n        \"Initialize a variable to track the total damage inflicted.\",\n        \"Iterate over the attack times and calculate the damage inflicted by each attack considering the poison duration k.\",\n        \"If an attack refreshes the poison, adjust the damage calculation accordingly.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum poison duration k that results in at least h damage for each test case.\",\n      \"steps\": [\n        \"Use a binary search approach to efficiently find the minimum k.\",\n        \"Set initial bounds for k (e.g., 1 to a large number like 10^9).\",\n        \"For each k in the search range, calculate the total damage using the previous subproblem.\",\n        \"Adjust the search bounds based on whether the calculated damage meets or exceeds h.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum poison duration k for each test case.\",\n      \"steps\": [\n        \"Store the result for each test case.\",\n        \"Print the results in the required format.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and their parameters.\",\n    \"For each test case, use binary search to find the minimum poison duration k that results in at least h damage.\",\n    \"Calculate the total damage for each candidate k during the binary search.\",\n    \"Output the minimum k for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect': The poison effect is a mechanism where each attack inflicts damage over a duration of k seconds. If the dragon is already poisoned, the effect is refreshed.\n    'minimum feasible value of k': This refers to the smallest duration of the poison effect that results in at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage': This means the total damage inflicted must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb]\n    'minimal feasible value': This indicates the smallest possible value of k that meets the requirement. In code, this can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n    The steps in the plan related to calculating damage and determining the minimum k should be considered simultaneously. Specifically, the binary search approach should integrate the damage calculation logic to adjust the search bounds based on whether the damage meets or exceeds h.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and h = 1, the minimum k is 1 to inflict at least 1 damage.\n\n    Test case with attacks at consecutive seconds:\n    3 3\n    1 2 3\n    Expected output: 1\n    Explanation: Each attack refreshes the poison, so k = 1 is sufficient to inflict 3 damage.\n\n    Test case with large h:\n    2 10^18\n    1 10^9\n    Expected output: 10^18\n    Explanation: With only two attacks far apart, k must be very large to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting the bounds based on the damage calculation.\n\nNO", "Round_0": {"code": "def minimum_k_for_damage(t, test_cases):\n    results = []\n    \n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, 10**18\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n            \n            # Calculate total damage for current k (mid)\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n            \n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n        \n        results.append(left)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        attacks = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, h, attacks))\n    \n    results = minimum_k_for_damage(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of attacks, the required damage, and the list of attack times.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the values of n (number of attacks) and h (required damage).\",\n        \"Read the list of attack times a_i.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum value of k for each test case such that the total damage inflicted is at least h.\",\n      \"steps\": [\n        \"Initialize a binary search for k starting from 1 to a large number (e.g., 10^9).\",\n        \"For each candidate k, calculate the total damage inflicted using the attack times and poison duration.\",\n        \"Check if the total damage is at least h.\",\n        \"Adjust the binary search range based on whether the current k is sufficient or not.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"Store the minimum k found for each test case.\",\n        \"Print the results for all test cases.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and their parameters.\",\n    \"For each test case, use binary search to find the minimum k that results in at least h damage.\",\n    \"Calculate the damage for each candidate k by iterating over attack times and applying poison effects.\",\n    \"Output the minimum k for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is a mechanism where each attack refreshes the poison duration, causing damage over a period of k seconds. The goal is to find the minimum k such that the total damage is at least h.\n\n    'binary search'\n    Explanation: A method to efficiently find the minimum k by iteratively narrowing down the range of possible values based on whether the current k is sufficient to meet the damage requirement.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage inflicted must be greater than or equal to h. This can be implemented by checking if the calculated damage for a given k meets or exceeds h.\n\n# [degree adverb]\n    'minimal feasible value of k': This means finding the smallest possible k that still allows the total damage to meet or exceed h. This is implemented using binary search to efficiently find the smallest k.\n\n# [code logic]\n    The steps in the plan are well-structured and do not require simultaneous implementation. The binary search logic and damage calculation are separate processes that should be executed sequentially.\n\n# [edge case]\n    1. Test case with n = 1 and h = 1, a_1 = 1: The expected output is k = 1.\n       Explanation: With only one attack and a damage requirement of 1, the minimum k is 1 to meet the damage requirement.\n       \n    2. Test case with n = 1 and h = 10^18, a_1 = 1: The expected output is k = 10^18.\n       Explanation: With only one attack and a very high damage requirement, k must be equal to h to meet the requirement.\n       \n    3. Test case with n = 2, h = 2, a_1 = 1, a_2 = 2: The expected output is k = 1.\n       Explanation: With attacks at consecutive seconds, k = 1 is sufficient to meet the damage requirement of 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting the range of k based on the damage calculation.\n\nNO", "Round_0": {"code": "def minimum_k_to_defeat_dragon(t, test_cases):\n    results = []\n    \n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, 10**18\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n            \n            # Calculate total damage for current k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n            \n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n        \n        results.append(low)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, h = int(data[index]), int(data[index + 1])\n        index += 2\n        attacks = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, h, attacks))\n    \n    results = minimum_k_to_defeat_dragon(t, test_cases)\n    \n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of attacks, the required damage, and the list of attack times.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the values of n (number of attacks) and h (required damage).\",\n        \"Read the list of attack times a_i.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the damage inflicted for a given poison duration k and determine the minimum k needed to achieve at least h damage.\",\n      \"steps\": [\n        \"Initialize a binary search for k, starting from 1 to a large upper bound (e.g., h).\",\n        \"For each k in the binary search, calculate the total damage inflicted by iterating over the attack times.\",\n        \"For each attack time, calculate the damage inflicted by the poison effect considering the refresh mechanism.\",\n        \"Check if the total damage is at least h; adjust the binary search bounds accordingly.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum k for each test case.\",\n      \"steps\": [\n        \"Store the result of the minimum k for each test case.\",\n        \"Print the results for all test cases.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and their parameters.\",\n    \"Implement a function to calculate the total damage for a given k using the attack times and poison refresh logic.\",\n    \"Use binary search to find the minimum k that results in at least h damage for each test case.\",\n    \"Output the minimum k for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is a mechanism where each attack refreshes the poison duration, causing damage over a period of k seconds. The goal is to determine the minimal k such that the total damage is at least h.\n\n    'binary search'\n    Explanation: A method to efficiently find the minimum k by iteratively narrowing down the range of possible values based on whether the current k can achieve the required damage.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage inflicted must be greater than or equal to h. This can be implemented by checking if the accumulated damage meets or exceeds h during the binary search process.\n\n# [degree adverb]\n    'minimal feasible value of k': This means finding the smallest possible k that still allows the total damage to meet or exceed h. This is achieved through the binary search approach.\n\n# [code logic]\n    The steps in the plan related to binary search and damage calculation should be implemented simultaneously. Specifically:\n    - \"Initialize a binary search for k\" and \"Calculate the total damage inflicted\" should be in the same loop to efficiently adjust the search bounds based on the damage calculation.\n\n# [edge case]\n    1. Test case with n=1, h=1, a_1=1: The expected output is 1.\n       Explanation: With only one attack, the minimum k must be 1 to inflict at least 1 damage.\n    2. Test case with n=1, h=10^18, a_1=1: The expected output is 10^18.\n       Explanation: With only one attack, k must be equal to h to inflict the required damage.\n    3. Test case with n=100, h=1, a_1 to a_100 = [1, 2, ..., 100]: The expected output is 1.\n       Explanation: With attacks at every second, k=1 is sufficient to inflict 1 damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the damage calculation.\n\nNO", "Round_0": {"code": "def minimum_k_for_damage(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, h, attacks = case\n        left, right = 1, h\n        \n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n            \n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n            \n                if total_damage >= h:\n                    break\n            \n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n        \n        results.append(left)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        attacks = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, h, attacks))\n    \n    results = minimum_k_for_damage(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of attacks, the required damage, and the list of attack times.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Parsed data structure containing test cases\"\n    },\n    {\n      \"description\": \"For each test case, determine the minimum value of k such that the total damage inflicted is at least h.\",\n      \"input\": \"Parsed test case data\",\n      \"output\": \"Minimum value of k for each test case\"\n    },\n    {\n      \"description\": \"Calculate the total damage inflicted for a given k by simulating the poison effect over the attack times.\",\n      \"input\": \"Attack times and a specific k value\",\n      \"output\": \"Total damage inflicted\"\n    },\n    {\n      \"description\": \"Implement a binary search to efficiently find the minimum k that results in at least h damage.\",\n      \"input\": \"Parsed test case data\",\n      \"output\": \"Minimum k value\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, initialize variables to store the minimum and maximum possible values of k.\",\n    \"Use a binary search approach to find the minimum k that results in at least h damage:\",\n    \"  a. Set the initial search range for k from 1 to a large number (e.g., h).\",\n    \"  b. Calculate the midpoint of the current search range.\",\n    \"  c. Simulate the poison effect for the current midpoint value of k to calculate the total damage.\",\n    \"  d. If the total damage is at least h, update the search range to explore smaller k values.\",\n    \"  e. If the total damage is less than h, update the search range to explore larger k values.\",\n    \"Continue the binary search until the minimum k is found for each test case.\",\n    \"Output the minimum k for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect refers to the damage inflicted on the dragon over a period of k seconds after each attack. If the dragon is already poisoned, the effect is refreshed, not stacked.\n\n    'minimal feasible value of k'\n    Explanation: This is the smallest duration for which the poison effect must last to ensure the total damage is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb]\n    'minimal'\n    Explanation: This indicates the smallest possible value of k that satisfies the condition. In code, this is typically found using a binary search to efficiently determine the smallest k.\n\n# [code logic]\n    The steps related to binary search and damage calculation should be considered simultaneously:\n    - \"Use a binary search approach to find the minimum k that results in at least h damage\"\n    - \"Simulate the poison effect for the current midpoint value of k to calculate the total damage\"\n    These steps are interdependent and should be implemented in a single code block where the binary search iteratively checks the damage for different k values.\n\n# [edge case]\n    1. Test case with minimum values: n = 1, h = 1, a = [1]\n       Expected output: 1\n       Explanation: With only one attack and h = 1, the minimum k is 1 to inflict the required damage.\n\n    2. Test case with attacks at consecutive seconds: n = 3, h = 3, a = [1, 2, 3]\n       Expected output: 1\n       Explanation: Each attack refreshes the poison, so k = 1 is sufficient to inflict 3 damage over 3 seconds.\n\n    3. Test case with large h and sparse attacks: n = 2, h = 1000, a = [1, 100]\n       Expected output: 500\n       Explanation: The large gap between attacks means k must be large enough to cover the gap and inflict the required damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting the range of k values based on the damage calculation.\n\nNO", "Round_0": {"code": "def calculate_minimum_k(n, h, attack_times):\n    # Binary search for the minimum k\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        total_damage = 0\n        \n        # Calculate total damage for current k = mid\n        for i in range(n):\n            if i == n - 1:\n                total_damage += mid\n            else:\n                total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n        \n        if total_damage >= h:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        attack_times = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = calculate_minimum_k(n, h, attack_times)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of attacks, the required damage, and the list of attack times.\",\n      \"output\": \"A structured format containing all test cases with their respective parameters.\"\n    },\n    {\n      \"description\": \"For each test case, determine the minimum value of k such that the total damage inflicted is at least h.\",\n      \"output\": \"The minimum value of k for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the total damage inflicted for a given k by simulating the poison effect over the attack times.\",\n      \"output\": \"The total damage inflicted for a specific k.\"\n    },\n    {\n      \"description\": \"Implement a binary search over possible values of k to efficiently find the minimum k that results in at least h damage.\",\n      \"output\": \"The optimal k value for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format containing all test cases.\",\n    \"For each test case, initialize the search for the minimum k using binary search.\",\n    \"Define a function to calculate the total damage for a given k by iterating over the attack times and simulating the poison effect.\",\n    \"Use the binary search to find the smallest k such that the calculated damage is at least h.\",\n    \"Output the minimum k for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect refers to the damage inflicted on the dragon over a period of k seconds after each attack. If the dragon is already poisoned, the effect is refreshed, not stacked.\n\n    'minimal feasible value of k'\n    Explanation: This is the smallest duration for which the poison effect must last to ensure that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. This can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'minimal'\n    Explanation: The smallest possible value of k that satisfies the condition. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n    The steps for parsing input and initializing the binary search should be implemented simultaneously as they are preparatory steps for the main logic.\n    \"Read the input data and parse it into a structured format containing all test cases.\"\n    \"For each test case, initialize the search for the minimum k using binary search.\"\n\n# [edge case]\n    1. Test case with n = 1 and h = 1, a_1 = 1: The expected output is k = 1.\n       Explanation: With only one attack and h = 1, the minimum k is 1 to inflict the required damage.\n       \n    2. Test case with n = 1 and h = 10^18, a_1 = 1: The expected output is k = 10^18.\n       Explanation: With only one attack, k must be equal to h to inflict the required damage.\n       \n    3. Test case with n = 100 and h = 1, a_1 to a_100 = 1 to 100: The expected output is k = 1.\n       Explanation: With multiple attacks, the minimum k is 1 since each attack can inflict 1 damage immediately.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these cases by finding the minimum k that satisfies the damage requirement.\n\nNO", "Round_0": {"code": "def calculate_damage(a, k):\n    total_damage = 0\n    n = len(a)\n    for i in range(n - 1):\n        total_damage += min(k, a[i + 1] - a[i])\n    total_damage += k  # Add damage for the last attack\n    return total_damage\n\ndef find_min_k(n, h, a):\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        if calculate_damage(a, mid) >= h:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, h = int(data[index]), int(data[index + 1])\n        index += 2\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        min_k = find_min_k(n, h, a)\n        results.append(min_k)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of attacks, the required damage, and the list of attack times.\",\n      \"output\": \"A structured format containing all test cases with their respective parameters.\"\n    },\n    {\n      \"description\": \"For each test case, determine the minimum value of k such that the total damage inflicted is at least h.\",\n      \"output\": \"The minimum value of k for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the damage inflicted for a given k by simulating the poison effect over the attack times.\",\n      \"output\": \"The total damage inflicted for a given k.\"\n    },\n    {\n      \"description\": \"Implement a binary search over possible values of k to efficiently find the minimum k that results in at least h damage.\",\n      \"output\": \"The optimal k for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format containing all test cases.\",\n    \"For each test case, initialize the search for the minimum k using binary search.\",\n    \"Define a function to calculate the total damage for a given k by iterating over the attack times and applying the poison effect.\",\n    \"Use the binary search to find the smallest k such that the calculated damage is at least h.\",\n    \"Output the minimum k for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is a mechanism where each attack refreshes the poison duration, causing damage over a period of k seconds. The goal is to find the minimum k such that the total damage is at least h.\n\n    'binary search'\n    Explanation: A search algorithm that efficiently finds the minimum k by repeatedly dividing the range of possible k values in half.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage inflicted must be greater than or equal to h. This can be implemented by checking if the calculated damage for a given k is >= h.\n\n# [degree adverb]\n    'minimal feasible value': This refers to finding the smallest possible k that satisfies the condition. In code, this is achieved using binary search to minimize k.\n\n# [code logic]\n    The steps for calculating damage and performing binary search should be implemented simultaneously. Specifically, the function to calculate damage for a given k and the binary search logic should be integrated to efficiently find the minimum k.\n\n# [edge case]\n    1. Test case with n = 1 and h = 1, a_1 = 1: The expected output is k = 1.\n       Explanation: With only one attack and h = 1, the minimum k is 1 to inflict the required damage.\n       \n    2. Test case with n = 2 and h = 2, a_1 = 1, a_2 = 3: The expected output is k = 1.\n       Explanation: Each attack can inflict 1 damage, and with k = 1, the total damage is 2, which meets the requirement.\n       \n    3. Test case with n = 3 and h = 5, a_1 = 1, a_2 = 2, a_3 = 3: The expected output is k = 2.\n       Explanation: With k = 2, the damage is inflicted in seconds [1, 2, 2, 3, 3, 4], totaling 5 damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these cases by finding the minimum k that satisfies the damage requirement.\n\nNO", "Round_0": {"code": "def calculate_damage(attacks, k):\n    total_damage = 0\n    n = len(attacks)\n    for i in range(n):\n        if i == n - 1:\n            total_damage += k\n        else:\n            total_damage += min(k, attacks[i + 1] - attacks[i])\n    return total_damage\n\ndef find_minimum_k(n, h, attacks):\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        if calculate_damage(attacks, mid) >= h:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, h = int(data[index]), int(data[index + 1])\n        index += 2\n        attacks = list(map(int, data[index:index + n]))\n        index += n\n        \n        min_k = find_minimum_k(n, h, attacks)\n        results.append(min_k)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of attacks, the required damage, and the list of attack times.\",\n      \"output\": \"A structured format containing all test cases with their respective parameters.\"\n    },\n    {\n      \"description\": \"For each test case, determine the minimum value of k such that the total damage inflicted is at least h.\",\n      \"output\": \"The minimum value of k for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the total damage inflicted for a given k by simulating the poison effect over the attack times.\",\n      \"output\": \"The total damage inflicted for a specific k.\"\n    },\n    {\n      \"description\": \"Implement a binary search over possible values of k to efficiently find the minimum k that results in at least h damage.\",\n      \"output\": \"The optimal k for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format containing all test cases.\",\n    \"For each test case, initialize the search for the minimum k using binary search.\",\n    \"Define a function to calculate the total damage for a given k by iterating over the attack times and applying the poison effect.\",\n    \"Use the binary search to find the smallest k such that the calculated damage is at least h.\",\n    \"Output the minimum k for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is a mechanism where each attack refreshes the poison duration, causing damage over subsequent seconds. The goal is to find the minimum duration (k) that ensures the total damage meets or exceeds the dragon's hit points (h).\n\n# [phrase showing quantity relationship]\n    'minimal feasible value of k'\n    Explanation: This refers to finding the smallest possible duration of the poison effect that results in at least h damage to the dragon. In code, this can be implemented using a binary search to efficiently find the minimum k.\n\n# [degree adverb] \n    'minimal'\n    Explanation: The requirement is to find the smallest possible k that still achieves the desired damage. This involves optimizing the value of k to be as small as possible while still meeting the damage requirement.\n\n# [code logic]\n    The steps related to calculating damage for a given k and using binary search to find the minimum k should be considered simultaneously. Specifically, the function to calculate damage and the binary search logic should be integrated to efficiently determine the minimum k.\n\n# [edge case] \n    Test case with minimum values:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and needing to inflict at least 1 damage, the minimum k is 1.\n\n    Test case with attacks at consecutive seconds:\n    3 3\n    1 2 3\n    Expected output: 1\n    Explanation: Each attack refreshes the poison, so k=1 is sufficient to inflict 3 damage.\n\n    Test case with large h:\n    2 10^18\n    1 10^9\n    Expected output: 10^18\n    Explanation: With only two attacks far apart, k must be very large to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles the calculation of the minimum k for varying scenarios, including edge cases.\n\nNO", "Round_0": {"code": "def calculate_damage(a, k):\n    total_damage = 0\n    n = len(a)\n    for i in range(n - 1):\n        total_damage += min(k, a[i + 1] - a[i])\n    total_damage += k  # Damage for the last attack\n    return total_damage\n\ndef find_minimum_k(n, h, a):\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        if calculate_damage(a, mid) >= h:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, h = int(data[index]), int(data[index + 1])\n        index += 2\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = find_minimum_k(n, h, a)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of attacks, the required damage, and the list of attack times.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, determine the minimum value of k such that the total damage inflicted is at least h.\",\n      \"output\": \"The minimum value of k for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the total damage inflicted for a given k by simulating the poison effect over the attack times.\",\n      \"output\": \"The total damage inflicted for a given k.\"\n    },\n    {\n      \"description\": \"Implement a search strategy to find the minimal k that satisfies the damage requirement.\",\n      \"output\": \"The optimal k value for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, initialize variables to store the number of attacks, required damage, and attack times.\",\n    \"Define a function to calculate the total damage for a given k by iterating over the attack times and simulating the poison effect.\",\n    \"Use a binary search or linear search strategy to find the minimal k that results in total damage greater than or equal to h.\",\n    \"Output the minimal k for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is a mechanism where each attack refreshes the poison duration, causing damage over a period of k seconds. The goal is to find the minimal k such that the total damage is at least h.\n\n    'minimal feasible value of k'\n    Explanation: This refers to the smallest duration of the poison effect that ensures the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb] \n    'minimal'\n    Explanation: The smallest possible value of k that satisfies the condition. This can be implemented using a search strategy, such as binary search, to efficiently find the smallest k.\n\n# [code logic]\n    The steps for calculating total damage for a given k and searching for the minimal k should be considered simultaneously. Specifically, the calculation of total damage and the search strategy (e.g., binary search) should be integrated to efficiently find the minimal k.\n\n# [edge case] \n    1. Test case with n = 1 and h = 1, a_1 = 1\n       Expected output: 1\n       Explanation: With only one attack, the minimal k is 1 to inflict at least 1 damage.\n       \n    2. Test case with n = 2 and h = 2, a_1 = 1, a_2 = 3\n       Expected output: 1\n       Explanation: The attacks are spaced such that k = 1 is sufficient to cover both attacks and inflict 2 damage.\n       \n    3. Test case with n = 3 and h = 5, a_1 = 1, a_2 = 2, a_3 = 3\n       Expected output: 2\n       Explanation: The attacks are consecutive, so k = 2 is needed to ensure continuous damage over 5 seconds.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a search strategy to find the minimal k will naturally handle these cases.\n\nNO", "Round_0": {"code": "def calculate_min_k(n, h, attack_times):\n    # Binary search for the minimum k\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        total_damage = 0\n        # Calculate total damage for current k = mid\n        for i in range(n):\n            if i == n - 1:\n                total_damage += mid\n            else:\n                total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n        \n        if total_damage >= h:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, h = int(data[index]), int(data[index + 1])\n        index += 2\n        attack_times = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = calculate_min_k(n, h, attack_times)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 302, "prompt": "Monocarp is engaged in yet another computer game adventure. In this game, his virtual persona must defeat a dragon. The confrontation with the dragon extends over 100^{500} seconds. Throughout that prolonged encounter, Monocarp using a poisoned dagger to assault the dragon. The i-th attack takes place at the onset of the a_i-th second following the commencement of the battle. The dagger itself inflicts no damage. But, it imposes a toxic effect on the dragon, which inflicts 1 damage during each of the subsequent k seconds (initiating with the very second when the dragon was struck by the dagger). Nonetheless, if the dragon is already under the influence of poison, then the dagger refreshes the poison impact (i.e., annuls the existing poison effect and implements a fresh one).\n\nFor instance, let's assume k equals 4, and Monocarp stabs the dragon during the seconds 2, 4, and 10. Then the poison impact is initiated at the beginning of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the start of the 4-th second, the poison impact is reset, resulting in precisely 1 damage during the seconds 4, 5, 6, and 7; finally, during the 10-th second, the poison impact is activated once more, delivering 1 damage during the seconds 10, 11, 12, and 13. Altogether, the dragon incurs 10 damage.\n\nMonocarp understands that the dragon possesses h hit points, and if he inflicts h or more damage to the dragon during the clash \u2014 he vanquishes the dragon. Monocarp hasn't made up his mind concerning the potency of the poison he'll employ throughout the battle, hence he wishes to determine the minimal feasible value of k (the duration of seconds the poison effect persists) that is sufficient to inflict h or more damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 81}
