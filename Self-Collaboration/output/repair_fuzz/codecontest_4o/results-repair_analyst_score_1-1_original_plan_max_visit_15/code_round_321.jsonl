{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "repair_prompt": ["On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other. This would allow them to all talk to each other without having to worry about talking to someone they are not friends with. Or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other. This would allow them to all talk to each other. They can do this without having to worry about talking to someone they are not friends with. Or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people, and it is considered successful if either all the people at the party are friends with each other. This would allow them to all talk to each other without having to worry about talking to someone they are not friends with, or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def find_successful_party():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Parse the friendship pairs\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a clique of size 5\n    def find_clique_of_size_5():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[j] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[i]] and\n                                    friends[l] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[k]]):\n                                    return [person, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) < N - 1:\n                non_friends -= friendships[person]\n                non_friends.remove(person)\n                if len(non_friends) >= 4:\n                    return [person] + list(non_friends)[:4]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    # Try to find a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    # Try to find an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        print\nmain()", "completions": ["def find_successful_party(N, M, friendships):\n    from itertools import combinations\n\n    # Create adjacency list\n    adj_list = {i: set() for i in range(1, N+1)}\n    for u, v in friendships:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n\n    # Check for cliques of size 5\n    for group in combinations(range(1, N+1), 5):\n        if all(v in adj_list[u] for u, v in combinations(group, 2)):\n            return group\n\n    # Check for independent sets of size 5\n    for group in combinations(range(1, N+1), 5):\n        if all(v not in adj_list[u] for u, v in combinations(group, 2)):\n            return group\n\n    return -1\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    friendships = []\n    \n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.append((u, v))\n        index += 2\n    \n    result = find_successful_party(N, M, friendships)\n    \n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    if M >= 10:\n        print(\"1 2 3 4 5\")\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a clique of size 5\n    def find_clique():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[i] in friendships[friends[j]] and\n                                    friends[i] in friendships[friends[k]] and\n                                    friends[i] in friendships[friends[l]] and\n                                    friends[j] in friendships[friends[k]] and\n                                    friends[j] in friendships[friends[l]] and\n                                    friends[k] in friendships[friends[l]]):\n                                    return [person, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) < N - 1:\n                non_friends -= friendships[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(\" \".join(map(str, independent_set)))\n        return\n    \n    print(-1)\nmain()", "def find_successful_party(N, M, friendships):\n    import itertools\n\n    # Parse input\n    adjacency_list = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of size 5\n    def is_clique(group):\n        for u, v in itertools.combinations(group, 2):\n            if v not in adjacency_list[u]:\n                return False\n        return True\n\n    # Check for an independent set of size 5\n    def is_independent_set(group):\n        for u, v in itertools.combinations(group, 2):\n            if v in adjacency_list[u]:\n                return False\n        return True\n\n    # Check all combinations of 5 people\n    people = list(range(1, N + 1))\n    for group in itertools.combinations(people, 5):\n        if is_clique(group) or is_independent_set(group):\n            print(' '.join(map(str, group)))\n            return\n\n    # If no successful party is found\n    print('-1')\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nfriendships = [(int(data[i]), int(data[i+1])) for i in range(2, len(data), 2)]\n\n# Find and print the successful party\nfind_successful_party(N, M, friendships)\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U_i = int(data[index])\n        V_i = int(data[index + 1])\n        friendships.add((U_i, V_i))\n        friendships.add((V_i, U_i))\n        index += 2\n    \n    # Check for a clique of 5 people (all friends)\n    def is_clique(group):\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (group[i], group[j]) not in friendships:\n                    return False\n        return True\n    \n    # Check for an independent set of 5 people (no friends)\n    def is_independent_set(group):\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (group[i], group[j]) in friendships:\n                    return False\n        return True\n    \n    # Iterate over all combinations of 5 people\n    for group in combinations(range(1, N + 1), 5):\n        if is_clique(group) or is_independent_set(group):\n            print(' '.join(map(str, group)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def successful_party():\n    import sys\n    input = sys.stdin.read\n    from itertools import combinations\n    \n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.append((U, V))\n        index += 2\n    \n    if M == 0:\n        print(1, 2, 3, 4, 5)\n        return\n    if M == N * (N - 1) // 2:\n        print(1, 2, 3, 4, 5)\n        return\n    \n    # Create adjacency list\n    adj = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adj[u].add(v)\n        adj[v].add(u)\n    \n    # Check for a complete subgraph or independent set of 5 nodes\n    for comb in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if comb[j] in adj[comb[i]]:\n                    no_friends = False\n                else:\n                    all_friends = False\n        if all_friends or no_friends:\n            print(*comb)\n            return\n    \n    print(-1)\n\nsuccessful_party()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    elif M >= (N * (N - 1)) // 2:\n        print(\"1 2 3 4 5\")\n        return\n    \n    from collections import defaultdict\n    \n    friends = defaultdict(set)\n    \n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        index += 2\n        friends[U].add(V)\n        friends[V].add(U)\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique():\n        for person in range(1, N + 1):\n            if len(friends[person]) >= 4:\n                potential_clique = [person] + list(friends[person])\n                if len(potential_clique) >= 5:\n                    for i in range(5):\n                        for j in range(i + 1, 5):\n                            if potential_clique[j] not in friends[potential_clique[i]]:\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        return potential_clique[:5]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(non_friends) >= 5:\n                independent_set = list(non_friends)[:5]\n                for i in range(5):\n                    for j in range(i + 1, 5):\n                        if independent_set[j] in friends[independent_set[i]]:\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    return independent_set\n            non_friends -= friends[person]\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(\" \".join(map(str, independent_set)))\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_successful_party():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Parse the friendship pairs\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a clique of size 5\n    def find_clique_of_size_5():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[j] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[i]] and\n                                    friends[l] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[k]]):\n                                    return [person, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) < N - 1:\n                non_friends -= friendships[person]\n                non_friends.remove(person)\n                if len(non_friends) >= 4:\n                    return [person] + list(non_friends)[:4]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    # Try to find a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    # Try to find an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        print\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs (U_i, V_i).\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where all 5 people are friends with each other.\",\n      \"steps\": [\n        \"Create a graph representation using adjacency lists or matrices.\",\n        \"Check for cliques of size 5 in the graph where all nodes are connected.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where no two people are friends with each other.\",\n      \"steps\": [\n        \"Check for independent sets of size 5 in the graph where no nodes are connected.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a clique of size 5 is found, output the 5 people.\",\n        \"If an independent set of size 5 is found, output the 5 people.\",\n        \"If neither is found, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Construct a graph representation of the friendships.\",\n    \"Search for cliques of size 5 in the graph.\",\n    \"Search for independent sets of size 5 in the graph.\",\n    \"Output the result based on the findings.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other or none are friends with each other.\n\n    'clique'\n    Explanation: A clique in graph theory is a subset of vertices such that every two distinct vertices are adjacent. In this context, it means all 5 people are friends with each other.\n\n    'independent set'\n    Explanation: An independent set in graph theory is a subset of vertices such that no two vertices are adjacent. In this context, it means none of the 5 people are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': means the party must consist of 5 people, no more, no less.\n    Implementation: Ensure that any solution involves exactly 5 people.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for checking cliques and independent sets should be considered simultaneously.\n    Explanation: Both conditions for a successful party (all friends or no friends) can be checked in parallel after constructing the graph.\n\n# [edge case] \n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With 0 friendships, any 5 people form an independent set.\n\n    Input: 5 10\n    Output: 1 2 3 4 5\n    Explanation: If all possible pairs are friends, any 5 people form a clique.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If there are 6 people and all possible pairs are friends, no independent set of 5 can exist.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def find_successful_party():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Parse the friendship pairs\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a clique of size 5\n    def find_clique_of_size_5():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[j] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[i]] and\n                                    friends[l] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[k]]):\n                                    return [person, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) < N - 1:\n                non_friends -= friendships[person]\n                non_friends.remove(person)\n                if len(non_friends) >= 4:\n                    return [person] + list(non_friends)[:4]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    # Try to find a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    # Try to find an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        print", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs (U_i, V_i).\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where all 5 people are friends with each other.\",\n      \"steps\": [\n        \"Create a graph representation using adjacency lists or matrices.\",\n        \"Check for cliques of size 5 in the graph where all nodes are connected.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where no two people are friends with each other.\",\n      \"steps\": [\n        \"Check for independent sets of size 5 in the graph where no nodes are connected.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a clique of size 5 is found, output the 5 people.\",\n        \"If an independent set of size 5 is found, output the 5 people.\",\n        \"If neither is found, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Construct a graph representation of the friendships.\",\n    \"Search for cliques of size 5 in the graph.\",\n    \"Search for independent sets of size 5 in the graph.\",\n    \"Output the result based on whether a successful party configuration is found.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all 5 people are friends with each other or no two people are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': The party must consist of precisely 5 individuals.\n    'all the people': All 5 people at the party must be friends with each other.\n    'no two people': None of the 5 people at the party should be friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for checking cliques and independent sets can be implemented in separate code blocks, as they are distinct checks. However, the output logic should be combined to ensure that if either condition is met, the correct output is given.\n\n# [edge case]\n    1. Input: 5 0\n       Output: 1 2 3 4 5\n       Explanation: With 5 people and no friendships, all 5 can be invited as no two are friends.\n    2. Input: 5 10\n       Output: 1 2 3 4 5\n       Explanation: With 5 people and all possible friendships, all 5 can be invited as they are all friends.\n    3. Input: 6 15\n       Output: -1\n       Explanation: With 6 people and all possible friendships, no independent set of 5 can exist, and no clique of 5 can be formed without including the 6th person.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, particularly to efficiently check for cliques and independent sets of size 5.\n    ```\n    def find_successful_party(N, M, friendships):\n        from itertools import combinations\n\n        # Create adjacency list\n        adj_list = {i: set() for i in range(1, N+1)}\n        for u, v in friendships:\n            adj_list[u].add(v)\n            adj_list[v].add(u)\n\n        # Check for cliques of size 5\n        for group in combinations(range(1, N+1), 5):\n            if all(v in adj_list[u] for u, v in combinations(group, 2)):\n                return group\n\n        # Check for independent sets of size 5\n        for group in combinations(range(1, N+1),", "Round_0": {"code": "def find_successful_party(N, M, friendships):\n    from itertools import combinations\n\n    # Create adjacency list\n    adj_list = {i: set() for i in range(1, N+1)}\n    for u, v in friendships:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n\n    # Check for cliques of size 5\n    for group in combinations(range(1, N+1), 5):\n        if all(v in adj_list[u] for u, v in combinations(group, 2)):\n            return group\n\n    # Check for independent sets of size 5\n    for group in combinations(range(1, N+1), 5):\n        if all(v not in adj_list[u] for u, v in combinations(group, 2)):\n            return group\n\n    return -1\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    friendships = []\n    \n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.append((u, v))\n        index += 2\n    \n    result = find_successful_party(N, M, friendships)\n    \n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs (U_i, V_i).\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized.\",\n      \"steps\": [\n        \"Check if there exists a group of 5 people where all are friends with each other.\",\n        \"Check if there exists a group of 5 people where no two are friends with each other.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party is possible, output the 5 people.\",\n        \"If no successful party is possible, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Create a graph representation of the friendships using adjacency lists.\",\n    \"Iterate over all possible combinations of 5 people.\",\n    \"For each combination, check if all are friends or none are friends using the graph.\",\n    \"If a valid combination is found, print the 5 people and exit.\",\n    \"If no valid combination is found after checking all possibilities, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party on the island of Baltia is defined as a gathering of exactly 5 people where either all are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals.\n    'all the people at the party are friends with each other': This implies a complete subgraph of 5 nodes in graph terms.\n    'no two people at the party are friends with each other': This implies an independent set of 5 nodes in graph terms.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to checking combinations of 5 people should be implemented simultaneously. Specifically:\n    - \"Iterate over all possible combinations of 5 people.\"\n    - \"For each combination, check if all are friends or none are friends using the graph.\"\n    These steps can be implemented in a single loop where each combination is checked for both conditions.\n\n# [edge case] \n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With 5 people and no friendships, all combinations of 5 people are valid as none are friends with each other.\n    \n    Input: 5 10\n    Output: 1 2 3 4 5\n    Explanation: With 5 people and all possible friendships, all combinations of 5 people are valid as all are friends with each other.\n    \n    Input: 6 15\n    Output: -1\n    Explanation: If all 6 people are friends with each other, no combination of 5 people can have no friendships, but any 5 can be a complete subgraph.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over combinations and checking the conditions will naturally handle these cases.\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs (U_i, V_i).\"\n      ]\n    },\n    {\n      \"description\": \"Model the friendships using a graph representation.\",\n      \"steps\": [\n        \"Create an adjacency list or adjacency matrix to represent the friendships between people.\"\n      ]\n    },\n    {\n      \"description\": \"Check for a successful party where all 5 people are friends with each other.\",\n      \"steps\": [\n        \"Iterate over all possible combinations of 5 people.\",\n        \"For each combination, check if all pairs within the combination are friends using the graph representation.\",\n        \"If a valid combination is found, output the 5 people.\"\n      ]\n    },\n    {\n      \"description\": \"Check for a successful party where no two people are friends with each other.\",\n      \"steps\": [\n        \"Iterate over all possible combinations of 5 people.\",\n        \"For each combination, check if no pairs within the combination are friends using the graph representation.\",\n        \"If a valid combination is found, output the 5 people.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result.\",\n      \"steps\": [\n        \"If a successful party is found in either of the above checks, print the 5 people.\",\n        \"If no successful party is found, print -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Model the friendships using a graph representation.\",\n    \"Check for a successful party where all 5 people are friends with each other.\",\n    \"Check for a successful party where no two people are friends with each other.\",\n    \"Output the result based on the checks.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals.\n    'all the people': This implies that every pair among the 5 people must be friends.\n    'no two people': This means that none of the pairs among the 5 people should be friends.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for checking if all 5 people are friends and if no two people are friends should be implemented simultaneously. This can be done by iterating over all combinations of 5 people and checking both conditions in the same loop.\n\n# [edge case]\n    Case 1: N = 5, M = 0\n    Expected Output: 1 2 3 4 5\n    Explanation: With 5 people and no friendships, a successful party can be formed where no two people are friends.\n\n    Case 2: N = 5, M = 10\n    Expected Output: 1 2 3 4 5\n    Explanation: With 5 people and all possible friendships, a successful party can be formed where all are friends.\n\n    Case 3: N = 6, M = 15\n    Expected Output: -1\n    Explanation: With 6 people and all possible friendships, it's impossible to form a party of 5 where no two are friends.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over combinations and checking the conditions will naturally handle these cases.\n\nNO", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 82)"}, "Round_1": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where all 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a complete subgraph (clique) of size 5 in the friendship graph.\",\n        \"Use graph traversal techniques to identify cliques.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where no two of the 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a set of 5 people with no edges between them in the friendship graph.\",\n        \"Use graph traversal techniques to identify independent sets.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, print the 5 people.\",\n        \"If no configuration is found, print -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Construct a graph representation using adjacency lists or matrices.\",\n    \"Check for a clique of size 5 in the graph.\",\n    \"Check for an independent set of size 5 in the graph.\",\n    \"Output the result based on the findings.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other (a clique) or none are friends with each other (an independent set).\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals.\n    'all the people at the party are friends with each other': This implies a complete subgraph or clique of size 5.\n    'no two people at the party are friends with each other': This implies an independent set of size 5.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for checking a clique and an independent set should be considered simultaneously in terms of logic, as they both aim to find a valid configuration of 5 people. However, they are distinct checks and should be implemented separately in the code.\n\n# [edge case] \n    1. Input: 5 0\n       Output: 1 2 3 4 5\n       Explanation: With 5 people and no friendships, all 5 form an independent set.\n    2. Input: 5 10\n       Output: 1 2 3 4 5\n       Explanation: With 5 people and all possible friendships, all 5 form a clique.\n    3. Input: 6 15\n       Output: -1\n       Explanation: With 6 people and all possible friendships, no independent set of 5 can exist, and any clique of 5 is possible, but the problem asks for exactly 5, so if no configuration is found, return -1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - For the case where M = 0, we can directly return the first 5 people as an independent set.\n    - For the case where M is large enough to form a complete graph of 5, we can directly return the first 5 people as a clique.\n    ```python\n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    if M >= 10:  # Maximum edges in a complete graph of 5 nodes\n        print(\"1 2 3 4 5\")\n        return\n    ```\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    if M >= 10:\n        print(\"1 2 3 4 5\")\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a clique of size 5\n    def find_clique():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[i] in friendships[friends[j]] and\n                                    friends[i] in friendships[friends[k]] and\n                                    friends[i] in friendships[friends[l]] and\n                                    friends[j] in friendships[friends[k]] and\n                                    friends[j] in friendships[friends[l]] and\n                                    friends[k] in friendships[friends[l]]):\n                                    return [person, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) < N - 1:\n                non_friends -= friendships[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(\" \".join(map(str, independent_set)))\n        return\n    \n    print(-1)", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs (U_i, V_i).\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where all 5 people are friends with each other.\",\n      \"steps\": [\n        \"Create a graph representation using adjacency lists or matrices.\",\n        \"Check for cliques of size 5 in the graph where all nodes are connected.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where no two people are friends with each other.\",\n      \"steps\": [\n        \"Check for independent sets of size 5 in the graph where no nodes are connected.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a clique of size 5 is found, output the 5 people.\",\n        \"If an independent set of size 5 is found, output the 5 people.\",\n        \"If neither is found, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Construct a graph representation of the friendships.\",\n    \"Search for cliques of size 5 in the graph.\",\n    \"Search for independent sets of size 5 in the graph.\",\n    \"Output the result based on whether a successful party configuration is found.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': means the party must consist of precisely 5 people.\n    'no two people': means that in one scenario, none of the 5 people should be friends with each other.\n\n# [degree adverb]\n    'successful': means the party meets the criteria of either all being friends or none being friends.\n\n# [code logic]\n    The steps for checking cliques and independent sets should be considered simultaneously as they are two conditions for a successful party. This can be implemented using two separate checks within the same function or code block.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, all 5 people can be invited as none are friends with each other.\n    \n    Input: 6 15\n    Output: -1\n    Explanation: If all possible pairs are friends, it's impossible to have a group of 5 where none are friends.\n    \n    Input: 7 3\n    Output: 1 2 3 4 5\n    Explanation: If there are only 3 friendships among 7 people, it's possible to find 5 people who are not friends with each other.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Implement checks for both cliques and independent sets within the same function.\n    - Ensure that the graph representation can handle cases with no friendships or complete friendships.\n\nYES", "Round_0": {"code": "def find_successful_party(N, M, friendships):\n    from sys import stdin, stdout\n    import itertools\n\n    # Parse input\n    adjacency_list = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of size 5\n    def is_clique(group):\n        for u, v in itertools.combinations(group, 2):\n            if v not in adjacency_list[u]:\n                return False\n        return True\n\n    # Check for an independent set of size 5\n    def is_independent_set(group):\n        for u, v in itertools.combinations(group, 2):\n            if v in adjacency_list[u]:\n                return False\n        return True\n\n    # Check all combinations of 5 people\n    people = list(range(1, N + 1))\n    for group in itertools.combinations(people, 5):\n        if is_clique(group) or is_independent_set(group):\n            stdout.write(' '.join(map(str, group)) + '\\n')\n            return\n\n    # If no successful party is found\n    stdout.write('-1\\n')\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nfriendships = [(int(data[i]), int(data[i+1])) for i in range(2, len(data), 2)]\n\n# Find and print the successful party\nfind_successful_party(N, M, friendships)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 85)"}, "Round_1": {"code": "def find_successful_party(N, M, friendships):\n    import itertools\n\n    # Parse input\n    adjacency_list = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of size 5\n    def is_clique(group):\n        for u, v in itertools.combinations(group, 2):\n            if v not in adjacency_list[u]:\n                return False\n        return True\n\n    # Check for an independent set of size 5\n    def is_independent_set(group):\n        for u, v in itertools.combinations(group, 2):\n            if v in adjacency_list[u]:\n                return False\n        return True\n\n    # Check all combinations of 5 people\n    people = list(range(1, N + 1))\n    for group in itertools.combinations(people, 5):\n        if is_clique(group) or is_independent_set(group):\n            print(' '.join(map(str, group)))\n            return\n\n    # If no successful party is found\n    print('-1')\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nfriendships = [(int(data[i]), int(data[i+1])) for i in range(2, len(data), 2)]\n\n# Find and print the successful party\nfind_successful_party(N, M, friendships)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs (U_i, V_i).\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized.\",\n      \"steps\": [\n        \"Check if there exists a group of 5 people where all are friends with each other.\",\n        \"Check if there exists a group of 5 people where no two are friends with each other.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, output the 5 people.\",\n        \"If no successful party configuration is found, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Create a graph representation of the friendships using adjacency lists.\",\n    \"Implement a function to check for a clique of 5 people (all friends).\",\n    \"Implement a function to check for an independent set of 5 people (no friends).\",\n    \"Iterate over possible combinations of 5 people to check for successful party conditions.\",\n    \"Output the result based on whether a successful party configuration is found.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other or none are friends with each other.\n\n    'clique'\n    Explanation: A clique in this context is a subset of people where every two distinct people are friends with each other.\n\n    'independent set'\n    Explanation: An independent set is a subset of people where no two people are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals.\n    Implementation: Ensure that any group considered for a party has exactly 5 members.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps to check for a clique of 5 people and an independent set of 5 people should be considered simultaneously. This can be done by iterating over all possible combinations of 5 people and checking both conditions in the same loop.\n\n# [edge case]\n    Case 1: N = 5, M = 0\n    Expected Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Case 2: N = 5, M = 10\n    Expected Output: 1 2 3 4 5\n    Explanation: With all possible friendships, any group of 5 people forms a clique.\n\n    Case 3: N = 6, M = 0\n    Expected Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for a clique or an independent set of 5 people will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U_i = int(data[index])\n        V_i = int(data[index + 1])\n        friendships.add((U_i, V_i))\n        friendships.add((V_i, U_i))\n        index += 2\n    \n    # Check for a clique of 5 people (all friends)\n    def is_clique(group):\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (group[i], group[j]) not in friendships:\n                    return False\n        return True\n    \n    # Check for an independent set of 5 people (no friends)\n    def is_independent_set(group):\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (group[i], group[j]) in friendships:\n                    return False\n        return True\n    \n    # Iterate over all combinations of 5 people\n    for group in combinations(range(1, N + 1), 5):\n        if is_clique(group) or is_independent_set(group):\n            print(' '.join(map(str, group)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if there exists a group of 5 people where all are friends or none are friends.\",\n      \"steps\": [\n        \"Check for a complete subgraph of 5 nodes in the friendship graph.\",\n        \"Check for an independent set of 5 nodes in the friendship graph.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, print the 5 people.\",\n        \"If no configuration is found, print -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Construct a graph representation using adjacency lists or matrices.\",\n    \"Implement a function to check for a complete subgraph of 5 nodes.\",\n    \"Implement a function to check for an independent set of 5 nodes.\",\n    \"Iterate through possible combinations of 5 people to find a successful party configuration.\",\n    \"Output the result based on whether a successful party configuration was found.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals, no more, no less.\n    'all the people at the party are friends': This implies a complete subgraph of 5 nodes.\n    'no two people at the party are friends': This implies an independent set of 5 nodes.\n\n# [degree adverb]\n    'successful': This refers to the condition where the party meets the criteria of either all being friends or none being friends.\n\n# [code logic]\n    The steps to check for a complete subgraph and an independent set should be considered simultaneously. This can be done by iterating through combinations of 5 people and checking both conditions in the same loop.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people will form an independent set.\n\n    Input: 5 10\n    Output: 1 2 3 4 5\n    Explanation: With all possible friendships, any group of 5 people will form a complete subgraph.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If every person is friends with every other person, but we need to find a group of 5 where no two are friends, which is impossible.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Implement a check for the number of friendships (M) being 0 or maximum possible for N people.\n    - If M is 0, any group of 5 people is a valid independent set.\n    - If M is maximum, any group of 5 people is a valid complete subgraph.\n\n```python\ndef successful_party(N, M, friendships):\n    if M == 0:\n        return list(range(1, 6))\n    if M == N * (N - 1) // 2:\n        return list(range(1, 6))\n    # Additional logic to check for complete subgraph or independent set\n    return -1\n```\n\nYES", "Round_0": {"code": "def successful_party():\n    import sys\n    input = sys.stdin.read\n    from itertools import combinations\n    \n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.append((U, V))\n        index += 2\n    \n    if M == 0:\n        print(1, 2, 3, 4, 5)\n        return\n    if M == N * (N - 1) // 2:\n        print(1, 2, 3, 4, 5)\n        return\n    \n    # Create adjacency list\n    adj = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adj[u].add(v)\n        adj[v].add(u)\n    \n    # Check for a complete subgraph or independent set of 5 nodes\n    for comb in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if comb[j] in adj[comb[i]]:\n                    no_friends = False\n                else:\n                    all_friends = False\n        if all_friends or no_friends:\n            print(*comb)\n            return\n    \n    print(-1)\n\nsuccessful_party()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def successful_party():\n    import sys\n    input = sys.stdin.read\n    from itertools import combinations\n    \n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.append((U, V))\n        index += 2\n    \n    if M == 0:\n        print(1, 2, 3, 4, 5)\n        return\n    if M == N * (N - 1) // 2:\n        print(1, 2, 3, 4, 5)\n        return\n    \n    # Create adjacency list\n    adj = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adj[u].add(v)\n        adj[v].add(u)\n    \n    # Check for a complete subgraph or independent set of 5 nodes\n    for comb in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if comb[j] in adj[comb[i]]:\n                    no_friends = False\n                else:\n                    all_friends = False\n        if all_friends or no_friends:\n            print(*comb)\n            return\n    \n    print(-1)\n\nsuccessful_party()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs (U_i, V_i).\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where all 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a complete subgraph of 5 nodes in the friendship graph.\",\n        \"Use graph traversal techniques to identify cliques of size 5.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where no two people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a set of 5 nodes with no edges between them in the friendship graph.\",\n        \"Use graph traversal techniques to identify independent sets of size 5.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, print the 5 people involved.\",\n        \"If no configuration is found, print -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Construct a graph representation using adjacency lists or matrices.\",\n    \"Check for a complete subgraph of 5 nodes (clique) in the graph.\",\n    \"Check for an independent set of 5 nodes in the graph.\",\n    \"Output the result based on the presence of a successful party configuration.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other or none are friends with each other.\n\n    'friendship pairs'\n    Explanation: These pairs indicate which people are friends with each other, forming the basis for determining possible party configurations.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals.\n    Implementation: Ensure that any group considered for the party has exactly 5 members.\n\n# [degree adverb]\n    'successful': This refers to the condition that must be met for the party to be considered successful.\n    Implementation: Check for either a complete subgraph (clique) or an independent set of 5 nodes.\n\n# [code logic]\n    The steps for checking a complete subgraph and an independent set should be considered simultaneously as they both aim to find a successful party configuration.\n    Implementation: Use graph traversal techniques to check both conditions in parallel or sequentially within the same function.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people will form an independent set, making the party successful.\n\n    Input: 6 15\n    Output: 1 2 3 4 5\n    Explanation: If all possible pairs are friends, any group of 5 people will form a complete subgraph, making the party successful.\n\n    Input: 5 10\n    Output: -1\n    Explanation: If there are exactly 10 friendships among 5 people, it forms a complete graph, but since the requirement is either all or none, and all are friends, it is successful.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Implementation:\n    ```python\n    if M == 0:\n        print(\"1 2 3 4 5\")\n    elif M >= (N * (N - 1)) // 2:\n        print(\"1 2 3 4 5\")\n    else:\n        # Original logic to find cliques or independent sets\n    ```\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    elif M >= (N * (N - 1)) // 2:\n        print(\"1 2 3 4 5\")\n        return\n    \n    from collections import defaultdict\n    \n    friends = defaultdict(set)\n    \n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        index += 2\n        friends[U].add(V)\n        friends[V].add(U)\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique():\n        for person in range(1, N + 1):\n            if len(friends[person]) >= 4:\n                potential_clique = [person] + list(friends[person])\n                if len(potential_clique) >= 5:\n                    for i in range(5):\n                        for j in range(i + 1, 5):\n                            if potential_clique[j] not in friends[potential_clique[i]]:\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        return potential_clique[:5]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(non_friends) >= 5:\n                independent_set = list(non_friends)[:5]\n                for i in range(5):\n                    for j in range(i + 1, 5):\n                        if independent_set[j] in friends[independent_set[i]]:\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    return independent_set\n            non_friends -= friends[person]\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(\" \".join(map(str, independent_set)))\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph data structure representing friendships.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 people from the N people.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if all are friends with each other or if none are friends with each other.\",\n      \"output\": \"A boolean indicating if a successful party configuration is found.\"\n    },\n    {\n      \"description\": \"If a successful party configuration is found, return the combination. If none is found after checking all combinations, return -1.\",\n      \"output\": \"A list of 5 people or -1 if no successful party is possible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendships.\",\n    \"Construct a graph to represent the friendships using an adjacency list or matrix.\",\n    \"Generate all possible combinations of 5 people from the N people.\",\n    \"For each combination, check if it satisfies the successful party conditions: either all are friends or none are friends.\",\n    \"If a valid combination is found, print the combination. If no valid combination is found after checking all, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 people, no more, no less.\n    'all the people': This implies that every person in the group of 5 must be friends with every other person in the group.\n    'no two people': This means that none of the people in the group of 5 should be friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Identify all possible combinations of 5 people from the N people\" and \"For each 5-person combination, check if all are friends with each other or if none are friends with each other\" should be implemented simultaneously. This can be done by iterating over each combination and checking the friendship conditions in the same loop.\n\n# [edge case]\n    1. Input: 5 0\n       Output: 1 2 3 4 5\n       Explanation: With 0 friendships, any group of 5 people will have no friends among them, satisfying the condition for a successful party.\n       \n    2. Input: 5 10\n       Output: 1 2 3 4 5\n       Explanation: With maximum friendships, any group of 5 people will all be friends with each other, satisfying the condition for a successful party.\n       \n    3. Input: 6 15\n       Output: -1\n       Explanation: If all possible pairs among 6 people are friends, then no group of 5 can have no friends among them, but they can all be friends, so this is not an edge case. However, if the friendships are such that no group of 5 can be all friends or no friends, the output should be -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each combination of 5 people for the friendship conditions will naturally handle these cases.\n\nNO", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 53)"}, "Round_1": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs (U_i, V_i).\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where all 5 people are friends with each other.\",\n      \"steps\": [\n        \"Create a graph representation using adjacency lists or matrices.\",\n        \"Check for cliques of size 5 in the graph where all nodes are connected.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where no two people are friends with each other.\",\n      \"steps\": [\n        \"Check for independent sets of size 5 in the graph where no nodes are connected.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a clique of size 5 is found, output the 5 people.\",\n        \"If an independent set of size 5 is found, output the 5 people.\",\n        \"If neither is found, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Construct a graph representation of the friendships.\",\n    \"Search for cliques of size 5 in the graph.\",\n    \"Search for independent sets of size 5 in the graph.\",\n    \"Output the result based on the findings.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other or none are friends with each other.\n\n    'clique'\n    Explanation: A clique in graph theory is a subset of vertices such that every two distinct vertices are adjacent. In this context, it means all 5 people are friends with each other.\n\n    'independent set'\n    Explanation: An independent set in graph theory is a subset of vertices such that no two vertices are adjacent. In this context, it means none of the 5 people are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': means the party must consist of 5 people, no more, no less.\n    Implementation: Ensure that any solution involves exactly 5 people.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for checking cliques and independent sets should be considered simultaneously.\n    Explanation: Both conditions for a successful party (all friends or no friends) can be checked in parallel after constructing the graph.\n\n# [edge case] \n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With 0 friendships, any 5 people form an independent set.\n\n    Input: 5 10\n    Output: 1 2 3 4 5\n    Explanation: If all possible pairs are friends, any 5 people form a clique.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If there are 6 people and all possible pairs are friends, no independent set of 5 can exist.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def find_successful_party():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Parse the friendship pairs\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a clique of size 5\n    def find_clique_of_size_5():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[j] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[i]] and\n                                    friends[l] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[k]]):\n                                    return [person, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) < N - 1:\n                non_friends -= friendships[person]\n                non_friends.remove(person)\n                if len(non_friends) >= 4:\n                    return [person] + list(non_friends)[:4]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    # Try to find a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    # Try to find an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        print", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, false, true, true, false, true, true, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 321, "prompt": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other. This would allow them to all talk to each other without having to worry about talking to someone they are not friends with. Or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "expand_one2two", "save_node": false, "parent_index": 29}
