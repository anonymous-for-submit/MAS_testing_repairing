{"name": "1594_D. The Number of Imposters", "description": "Theofanis started playing the new online game called \"Among them\". However, he always plays with Cypriot players, and they all have the same name: \"Andreas\" (the most common name in Cyprus).\n\nIn each game, Theofanis plays with n other players. Since they all have the same name, they are numbered from 1 to n.\n\nThe players write m comments in the chat. A comment has the structure of \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate). The comment means that player i said that player j has the role c.\n\nAn imposter always lies, and a crewmate always tells the truth. \n\nHelp Theofanis find the maximum possible number of imposters among all the other Cypriot players, or determine that the comments contradict each other (see the notes for further explanation).\n\nNote that each player has exactly one role: either imposter or crewmate.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.", "tags": ["constructive algorithms", "dfs and similar", "dp", "dsu", "graphs"], "difficulty": 10, "id": 1594, "sample_io": [{"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}], "test_list": [{"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n2\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["4\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n-1\n2\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n4\n1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n4\n-1\n2\n9\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n9\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n10 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n9\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n3\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n1 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n4\n2\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n5\n1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["2\n4\n-1\n2\n13\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n4 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n3\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 3 crewmate\n1 3 imposter\n10 0\n", "output": ["4\n3\n-1\n2\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n4 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n4 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n3\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n8 0\n", "output": ["2\n4\n1\n-1\n8\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n-1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n2\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n2 0\n", "output": ["2\n4\n-1\n5\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n2\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["4\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n-1\n-1\n2\n9\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n-1\n1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 3 crewmate\n2 3 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["-1\n4\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n15 0\n", "output": ["2\n4\n1\n-1\n15\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n4\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n6 0\n", "output": ["2\n3\n1\n-1\n6\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n3\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n7 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n6\n-1\n2\n7\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n4\n2\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n5 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n4\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n3\n-1\n2\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["2\n4\n1\n2\n13\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n4 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n4 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n-1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n7 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 4 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n6\n3\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n4 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n2 0\n", "output": ["2\n4\n-1\n2\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n10 0\n", "output": ["2\n4\n2\n2\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n-1\n1\n-1\n9\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n10 0\n", "output": ["2\n4\n1\n-1\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n-1\n-1\n-1\n4\n"]}, {"input": "5\n6 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 1 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["5\n4\n-1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["4\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 4 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n-1\n1\n-1\n7\n"]}, {"input": "5\n4 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["3\n3\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n-1\n1\n-1\n5\n"]}, {"input": "5\n8 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["7\n4\n2\n-1\n2\n"]}, {"input": "5\n6 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["5\n4\n1\n2\n13\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 4 imposter\n2 1 crewmate\n6 5\n1 1 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n4\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n4 5 crewmate\n1 4 imposter\n2 1 imposter\n4 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n3\n-1\n5\n"]}, {"input": "5\n4 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["3\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n10 0\n", "output": ["2\n4\n2\n-1\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 3 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n5\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n2 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n2 0\n", "output": ["2\n4\n-1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n1 3 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n2 2 crewmate\n1 2 imposter\n2 0\n", "output": ["2\n4\n1\n2\n2\n"]}, {"input": "5\n5 2\n1 2 imposter\n4 2 crewmate\n10 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n8\n-1\n2\n5\n"]}, {"input": "5\n10 2\n1 2 imposter\n4 2 crewmate\n10 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["9\n8\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n3\n2\n5\n"]}, {"input": "5\n6 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["5\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n4\n-1\n2\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n3\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 1 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n-1\n-1\n2\n4\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n-1\n1\n-1\n2\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 4 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 2 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n-1\n5\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n4 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n-1\n1\n2\n5\n"]}, {"input": "5\n4 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["3\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n8 0\n", "output": ["2\n4\n1\n2\n8\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n2\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n3 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n-1\n2\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 3 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n4\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 3 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 3 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 3 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 3 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n1 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n3 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 4 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 1 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n5\n1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n2 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n3 5 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 4 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n3\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 3 imposter\n3 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 1 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n8 0\n", "output": ["2\n4\n1\n-1\n8\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n1 4 imposter\n2 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n3 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n3 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 4 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n4\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n2\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n4 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 3 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n4\n-1\n2\n9\n"]}, {"input": "5\n3 2\n1 2 imposter\n3 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n4\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 1 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n4 2\n1 4 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n3\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n3 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n7 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 1 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 2 crewmate\n2 5 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["4\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 1 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n4 5 crewmate\n1 4 imposter\n2 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n2 3 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n2\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 2 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 3 imposter\n2 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 1 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 5 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 1 crewmate\n2 4 imposter\n1 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 5 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 3 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 1 crewmate\n2 5 crewmate\n2 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 3 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n2 3 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n4\n1\n-1\n2\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 3 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["2\n4\n-1\n2\n13\n"]}], "task_id": "codecontest/54", "repair_prompt": ["Theofanis started playing the new online game called \"Among them\". However, he always plays with Cypriot players, and they all have the same name: \"Andreas\" (the most common name in Cyprus).\n\nIn each game, Theofanis plays with n other players, and since they all have the same name, they are numbered from 1 to n.\n\nThe players write m comments in the chat. A comment has the structure of \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate). This structure indicates that player i said something about another player. Specifically, player i said that player j has the role c.\n\nAn imposter always lies, and a crewmate always tells the truth. \n\nHelp Theofanis find the maximum possible number of imposters among all the other Cypriot players, or determine that the comments contradict each other (see the notes for further explanation).\n\nNote that each player has exactly one role: either imposter or crewmate.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Theofanis started playing the new online game called \"Among them\". However, he always plays with Cypriot players, and they all have the same name: \"Andreas\" (the most common name in Cyprus).\n\nIn each game, Theofanis plays with n other players. Since they all have the same name, they are numbered from 1 to n.\n\nThe players write m comments in the chat. A comment has the structure of \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate). This structure indicates that player i said something about another player. Specifically, player i said that player j has the role c.\n\nAn imposter always lies, and a crewmate always tells the truth. \n\nHelp Theofanis find the maximum possible number of imposters among all the other Cypriot players, or determine that the comments contradict each other (see the notes for further explanation).\n\nNote that each player has exactly one role. This role is either imposter or crewmate.\n\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Theofanis started playing the new online game called \"Among them\". However, he always plays with Cypriot players, and they all have the same name: \"Andreas\" (the most common name in Cyprus). In each game, Theofanis plays with n other players numbered from 1 to n since they all have the same name. The players write m comments in the chat. A comment has the structure of \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate). This structure indicates that player i said something about another player. Specifically, player i said that player j has the role c. An imposter always lies, and a crewmate always tells the truth. Help Theofanis find the maximum possible number of imposters among all the other Cypriot players, or determine that the comments contradict each other (see the notes for further explanation). Note that each player has exactly one role: either imposter or crewmate.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        visited = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            visited[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if visited[neighbor] == -1:\n                        visited[neighbor] = expected_role\n                        count[expected_role] += 1\n                        queue.append((neighbor, expected_role))\n                    elif visited[neighbor] != expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        contradiction = False\n        \n        for player in range(1, n + 1):\n            if visited[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "completions": ["def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        roles = [-1] * (n + 1)\n        contradiction_detected = False\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            roles[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        count[expected_role] += 1\n                        queue.append((neighbor, expected_role))\n                    elif roles[neighbor] != expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction_detected = True\n                    break\n                max_imposters += result\n        \n        if contradiction_detected:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve_among_them():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1: unvisited, 0: crewmate, 1: imposter\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # start with crewmate\n            roles[start] = 0\n            count = [0, 0]  # count[0]: crewmates, count[1]: imposters\n            \n            while queue:\n                node, role = queue.popleft()\n                count[role] += 1\n                \n                for neighbor, comment in graph[node]:\n                    expected_role = 1 if comment == 'imposter' else 0\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = role ^ expected_role\n                        queue.append((neighbor, roles[neighbor]))\n                    elif roles[neighbor] != (role ^ expected_role):\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve_among_them()\n\nmain()", "def solve_among_them():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1: unvisited, 0: crewmate, 1: imposter\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0  # Assume start is a crewmate\n            count = [0, 0]  # count[0]: crewmates, count[1]: imposters\n            \n            while queue:\n                node = queue.popleft()\n                count[roles[node]] += 1\n                \n                for neighbor, role in graph[node]:\n                    expected_role = 0 if role == 'crewmate' else 1\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve_among_them()\n\nmain()", "def solve_among_them():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            # No comments, all can be imposters\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1 means unassigned, 0 means crewmate, 1 means imposter\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0  # Start with crewmate\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                current = queue.popleft()\n                current_role = roles[current]\n                count[current_role] += 1\n                \n                for neighbor, comment in graph[current]:\n                    expected_role = 1 if comment == 'imposter' else 0\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = 1 - current_role if comment == 'imposter' else current_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != (1 - current_role if comment == 'imposter' else current_role):\n                        return -1  # Contradiction found\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve_among_them()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        comments = []\n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            comments.append((i, j, c))\n            index += 3\n        \n        # Graph to store relationships\n        graph = defaultdict(list)\n        \n        for i, j, c in comments:\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        roles = [-1] * (n + 1)  # -1 means unassigned, 0 means crewmate, 1 means imposter\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # Start with crewmate assumption\n            roles[start] = 0\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                node, role = queue.popleft()\n                count[role] += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation  # XOR to flip role if relation is imposter\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append((neighbor, expected_role))\n                    elif roles[neighbor] != expected_role:\n                        return -1  # Contradiction found\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            # If there are no comments, all players can be imposters\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        roles = [-1] * (n + 1)  # -1 means unvisited, 0 means crewmate, 1 means imposter\n        contradiction = False\n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                queue = deque([(player, 0)])\n                imposters_count = 0\n                crewmates_count = 0\n                \n                while queue:\n                    current, role = queue.popleft()\n                    \n                    if roles[current] == -1:\n                        roles[current] = role\n                        if role == 1:\n                            imposters_count += 1\n                        else:\n                            crewmates_count += 1\n                    elif roles[current] != role:\n                        contradiction = True\n                        break\n                    \n                    for neighbor, relation in graph[current]:\n                        expected_role = role ^ relation\n                        if roles[neighbor] == -1:\n                            queue.append((neighbor, expected_role))\n                        elif roles[neighbor] != expected_role:\n                            contradiction = True\n                            break\n                    if contradiction:\n                        break\n                \n                if contradiction:\n                    break\n                max_imposters += max(imposters_count, crewmates_count)\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            graph[i].append((j, c))\n            graph[j].append((i, c))\n        \n        roles = [-1] * (n + 1)  # -1 indicates unassigned, 0 for crewmate, 1 for imposter\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # Start with crewmate role\n            roles[start] = 0\n            imposter_count = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                if role == 1:\n                    imposter_count += 1\n                \n                for neighbor, comment in graph[node]:\n                    expected_role = 1 if comment == 'imposter' else 0\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = role ^ expected_role\n                        queue.append((neighbor, roles[neighbor]))\n                    elif roles[neighbor] != (role ^ expected_role):\n                        return -1\n            \n            return imposter_count\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        roles = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            roles[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        count[expected_role] += 1\n                        queue.append((neighbor, expected_role))\n                    elif roles[neighbor] != expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        contradiction = False\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            color[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                for neighbor, edge_type in graph[node]:\n                    expected_color = col ^ edge_type\n                    if color[neighbor] == -1:\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append((neighbor, expected_color))\n                    elif color[neighbor] != expected_color:\n                        return -1, 0\n            \n            return max(count), sum(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if color[player] == -1:\n                result, total = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        visited = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            visited[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if visited[neighbor] == -1:\n                        visited[neighbor] = expected_role\n                        count[expected_role] += 1\n                        queue.append((neighbor, expected_role))\n                    elif visited[neighbor] != expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        contradiction = False\n        \n        for player in range(1, n + 1):\n            if visited[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Read the number of test cases t. For each test case, read the integers n and m, followed by m comments of the form 'i j c'.\"\n    },\n    {\n      \"description\": \"Model the problem using a graph-based approach.\",\n      \"details\": \"Consider each player as a node in a graph. Each comment 'i j c' represents an edge between nodes i and j with a label 'c'.\"\n    },\n    {\n      \"description\": \"Determine the roles of players using a graph traversal technique.\",\n      \"details\": \"Use a graph traversal method (e.g., BFS or DFS) to assign roles to players. Start with an arbitrary player and attempt to assign roles based on the comments. Track contradictions during traversal.\"\n    },\n    {\n      \"description\": \"Detect contradictions in the comments.\",\n      \"details\": \"While traversing the graph, if a contradiction is found (e.g., a player is assigned conflicting roles), mark the test case as having contradictory comments.\"\n    },\n    {\n      \"description\": \"Calculate the maximum number of imposters.\",\n      \"details\": \"For each connected component of the graph, calculate the maximum number of imposters by considering both possible role assignments and choosing the one with more imposters.\"\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, output the maximum number of imposters if no contradictions are found, otherwise output -1.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, initialize a graph structure to represent players and comments.\",\n    \"Perform a graph traversal to assign roles to players and detect contradictions.\",\n    \"If a contradiction is detected, mark the test case as invalid.\",\n    \"If no contradiction is found, calculate the maximum number of imposters for the test case.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter': A player who always lies about the role of other players.\n    'crewmate': A player who always tells the truth about the role of other players.\n    'contradict': When comments from players lead to conflicting information about roles.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This means we need to find the largest count of imposters that can be assigned without contradictions.\n    Implementation: Use graph traversal to explore all possible role assignments and choose the one with the most imposters.\n\n# [degree adverb]\n    'maximum': Refers to the largest number of imposters that can be assigned without contradictions.\n    Implementation: During graph traversal, calculate the number of imposters for each possible role assignment and select the maximum.\n\n# [code logic]\n    Steps 3 and 4 should be implemented simultaneously. While traversing the graph to assign roles, contradictions should be detected in the same process. This can be done using a single graph traversal method (e.g., BFS or DFS) that checks for contradictions as roles are assigned.\n\n# [edge case]\n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: With no comments, all players can be imposters, so the maximum number of imposters is equal to the number of players.\n    \n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, so it's impossible to assign roles without conflict.\n    \n    Test case with all players claiming others are imposters (e.g., 3 3 with comments \"1 2 imposter\", \"2 3 imposter\", \"3 1 imposter\") = 3\n    Explanation: All players can be imposters since there are no contradictions in the comments.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Initialize all players as imposters if there are no comments.\n    - Implement logic to detect contradictions during graph traversal.\n    - Use a graph traversal method to explore all possible role assignments and handle contradictions.\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        visited = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            visited[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if visited[neighbor] == -1:\n                        visited[neighbor] = expected_role\n                        count[expected_role] += 1\n                        queue.append((neighbor, expected_role))\n                    elif visited[neighbor] != expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        contradiction = False\n        \n        for player in range(1, n + 1):\n            if visited[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the comments themselves.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n and m representing the number of players and comments.\",\n        \"For each test case, read m comments of the form 'i j c'.\"\n      ]\n    },\n    {\n      \"description\": \"Model the problem using a graph where players are nodes and comments are edges with labels indicating the role (imposter or crewmate).\",\n      \"steps\": [\n        \"Create a graph representation for each test case.\",\n        \"Add nodes for each player.\",\n        \"Add directed edges between nodes based on comments, with labels indicating the role.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters or detect contradictions in comments.\",\n      \"steps\": [\n        \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to assign roles to players.\",\n        \"Check for contradictions during traversal (e.g., if a player is assigned both roles).\",\n        \"Calculate the maximum number of imposters if no contradictions are found.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output the maximum number of imposters or -1 if contradictions are detected.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and comments.\",\n    \"Model each test case as a graph with players as nodes and comments as edges.\",\n    \"Traverse the graph to assign roles and detect contradictions.\",\n    \"Calculate the maximum number of imposters if possible.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter': A player who always lies about the role of other players.\n    'crewmate': A player who always tells the truth about the role of other players.\n    'contradict': A situation where the comments made by players lead to logical inconsistencies.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This indicates that we need to find the highest number of imposters that can exist without contradictions.\n    Implementation: Use graph traversal to explore all possible configurations and count imposters.\n\n# [degree adverb]\n    'maximum': Refers to the largest number of imposters that can be assigned without contradictions.\n    Implementation: During graph traversal, keep track of the number of imposters and update the maximum count.\n\n# [code logic]\n    The steps in the plan related to graph traversal and contradiction checking should be implemented simultaneously.\n    \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to assign roles to players\",\n    \"Check for contradictions during traversal (e.g., if a player is assigned both roles)\"\n    This can be done by integrating contradiction checks within the traversal logic.\n\n# [edge case]\n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: With no comments, all players can be imposters.\n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, making it impossible to assign roles consistently.\n    Test case with all players claiming others are imposters (e.g., 3 3 with comments \"1 2 imposter\", \"2 3 imposter\", \"3 1 imposter\") = 3\n    Explanation: All players can be imposters without contradiction.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Implement logic to handle cases with no comments and contradictory comments.\n    ```python\n    if m == 0:\n        print(n)\n    elif contradiction_detected:\n        print(-1)\n    else:\n        # Continue with normal logic\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        roles = [-1] * (n + 1)\n        contradiction_detected = False\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            roles[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        count[expected_role] += 1\n                        queue.append((neighbor, expected_role))\n                    elif roles[neighbor] != expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction_detected = True\n                    break\n                max_imposters += result\n        \n        if contradiction_detected:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 117)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        roles = [-1] * (n + 1)\n        contradiction_detected = False\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            roles[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        count[expected_role] += 1\n                        queue.append((neighbor, expected_role))\n                    elif roles[neighbor] != expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction_detected = True\n                    break\n                max_imposters += result\n        \n        if contradiction_detected:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, model the problem as a graph where each player is a node and each comment is an edge with a label indicating the role (imposter or crewmate).\",\n      \"output\": \"A graph representation for each test case.\"\n    },\n    {\n      \"description\": \"Implement a function to check for contradictions in the comments by attempting to assign roles to players. Use a graph traversal technique (e.g., DFS or BFS) to propagate role assignments and detect contradictions.\",\n      \"output\": \"A boolean indicating whether a contradiction exists for each test case.\"\n    },\n    {\n      \"description\": \"If no contradictions are found, calculate the maximum number of imposters by exploring all possible valid role assignments.\",\n      \"output\": \"The maximum number of imposters for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into structured test cases.\",\n    \"For each test case, construct a graph where nodes represent players and edges represent comments with labels indicating roles.\",\n    \"Traverse the graph to assign roles to players, checking for contradictions in the process.\",\n    \"If a contradiction is found, output -1 for that test case.\",\n    \"If no contradiction is found, determine the maximum number of imposters by exploring valid role assignments.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter': A player who always lies about the role of other players.\n    'crewmate': A player who always tells the truth about the role of other players.\n    'contradict': A situation where the comments made by players cannot logically coexist, indicating an inconsistency in the roles assigned.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This means we need to find the highest count of imposters that can be assigned without causing contradictions.\n    'at least': Not directly present in the requirement, but implied in the need to ensure all comments are consistent with the roles assigned.\n\n# [degree adverb]\n    'maximum': Refers to finding the largest possible number of imposters that can be assigned without contradictions.\n\n# [code logic]\n    The steps related to graph construction and contradiction checking should be implemented simultaneously. Specifically:\n    - Constructing the graph and checking for contradictions can be done in a single traversal using DFS or BFS. This involves assigning roles and checking for consistency in one pass through the graph.\n\n# [edge case]\n    1. Test case with no comments (e.g., n = 5, m = 0) = 5\n       Explanation: With no comments, there are no contradictions, so all players can be imposters.\n    2. Test case with a single contradictory comment (e.g., 1 2 imposter, 2 1 crewmate) = -1\n       Explanation: The comments directly contradict each other, making it impossible to assign roles without inconsistency.\n    3. Test case with all players claiming each other as imposters (e.g., 1 2 imposter, 2 3 imposter, 3 1 imposter) = 2\n       Explanation: At least one player must be a crewmate to avoid contradiction, so the maximum number of imposters is 2.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, particularly for detecting contradictions and handling cases with no comments.\n    ```python\n    def handle_edge_cases(n, m, comments):\n        if m == 0:\n            return n  # All can be imposters if no comments\n        # Implement contradiction detection logic\n        # Use DFS/BFS to assign roles and check for contradictions\n        # Return -1 if contradiction is found, otherwise calculate max imposters\n    ```\n\nYES", "Round_0": {"code": "def solve_among_them():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1: unvisited, 0: crewmate, 1: imposter\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # start with crewmate\n            roles[start] = 0\n            count = [0, 0]  # count[0]: crewmates, count[1]: imposters\n            \n            while queue:\n                node, role = queue.popleft()\n                count[role] += 1\n                \n                for neighbor, comment in graph[node]:\n                    expected_role = 1 if comment == 'imposter' else 0\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = role ^ expected_role\n                        queue.append((neighbor, roles[neighbor]))\n                    elif roles[neighbor] != (role ^ expected_role):\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve_among_them()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 108)"}, "Round_1": {"code": "def solve_among_them():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1: unvisited, 0: crewmate, 1: imposter\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # start with crewmate\n            roles[start] = 0\n            count = [0, 0]  # count[0]: crewmates, count[1]: imposters\n            \n            while queue:\n                node, role = queue.popleft()\n                count[role] += 1\n                \n                for neighbor, comment in graph[node]:\n                    expected_role = 1 if comment == 'imposter' else 0\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = role ^ expected_role\n                        queue.append((neighbor, roles[neighbor]))\n                    elif roles[neighbor] != (role ^ expected_role):\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve_among_them()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, model the problem as a graph where each player is a node and each comment is an edge with a label indicating the role (imposter or crewmate).\",\n      \"output\": \"A graph representation for each test case.\"\n    },\n    {\n      \"description\": \"Determine the possible roles of each player using the graph. Use a graph traversal technique (e.g., DFS or BFS) to assign roles while checking for contradictions.\",\n      \"output\": \"A role assignment for each player or a contradiction flag.\"\n    },\n    {\n      \"description\": \"Calculate the maximum number of imposters based on the valid role assignments or identify if a contradiction exists.\",\n      \"output\": \"The maximum number of imposters or -1 if a contradiction is found.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into structured test cases.\",\n    \"For each test case, construct a graph where nodes represent players and edges represent comments with labels indicating roles.\",\n    \"Perform a graph traversal to assign roles to each player, ensuring consistency with the comments. If a contradiction is detected, mark the test case as invalid.\",\n    \"For valid test cases, calculate the maximum number of imposters by considering the role assignments.\",\n    \"Output the result for each test case: the maximum number of imposters or -1 if a contradiction is found.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter', 'crewmate'\n    Explanation: In the game, an imposter always lies, and a crewmate always tells the truth. The task is to determine the maximum number of imposters possible or identify contradictions in the comments.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This means we need to find the highest count of imposters that can be logically deduced from the comments without contradictions.\n\n# [degree adverb] \n    'maximum': This indicates that we are looking for the largest possible number of imposters that can be identified without any contradictions in the comments.\n\n# [code logic]\n    The steps for parsing input and constructing the graph should be implemented simultaneously. Specifically, while reading the input, the graph can be constructed in the same loop to optimize performance.\n\n# [edge case] \n    1. Test case with no comments (e.g., n = 5, m = 0) = 5\n       Explanation: With no comments, there are no constraints, so all players can be imposters.\n    2. Test case with contradictory comments (e.g., 1 2 imposter, 2 1 crewmate) = -1\n       Explanation: This is a direct contradiction, as explained in the requirement, leading to an output of -1.\n    3. Test case with all players claiming others are imposters (e.g., 1 2 imposter, 2 3 imposter, 3 1 imposter) = 2\n       Explanation: In a cycle of accusations, at least one player must be a crewmate to avoid contradiction, so the maximum imposters are n-1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    ```python\n    def handle_edge_cases(n, m, comments):\n        if m == 0:\n            return n\n        # Implement logic to detect contradictions\n        # Implement logic to handle cycles and determine maximum imposters\n    ```\n\nYES", "Round_0": {"code": "def solve_among_them():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1: unvisited, 0: crewmate, 1: imposter\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0  # Assume start is a crewmate\n            count = [0, 0]  # count[0]: crewmates, count[1]: imposters\n            \n            while queue:\n                node = queue.popleft()\n                count[roles[node]] += 1\n                \n                for neighbor, role in graph[node]:\n                    expected_role = 0 if role == 'crewmate' else 1\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve_among_them()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 113)"}, "Round_1": {"code": "def solve_among_them():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1: unvisited, 0: crewmate, 1: imposter\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0  # Assume start is a crewmate\n            count = [0, 0]  # count[0]: crewmates, count[1]: imposters\n            \n            while queue:\n                node = queue.popleft()\n                count[roles[node]] += 1\n                \n                for neighbor, role in graph[node]:\n                    expected_role = 0 if role == 'crewmate' else 1\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve_among_them()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"Model the problem as a graph where each player is a node and each comment is an edge with a label indicating the role (imposter or crewmate).\",\n      \"output\": \"A graph representation for each test case.\"\n    },\n    {\n      \"description\": \"Determine the possible roles of players using the graph. Use a graph traversal technique to assign roles to players while checking for contradictions.\",\n      \"output\": \"A role assignment for each player or a contradiction flag.\"\n    },\n    {\n      \"description\": \"Calculate the maximum number of imposters based on the valid role assignments.\",\n      \"output\": \"The maximum number of imposters for each test case.\"\n    },\n    {\n      \"description\": \"Handle contradictions by returning -1 for test cases where the comments contradict each other.\",\n      \"output\": \"A result of -1 for contradictory test cases.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into structured test cases.\",\n    \"For each test case, construct a graph where nodes represent players and edges represent comments with labels indicating roles.\",\n    \"Perform a graph traversal (e.g., BFS or DFS) to assign roles to players, ensuring consistency with the comments. Detect any contradictions during this process.\",\n    \"If a contradiction is detected, mark the test case as invalid and prepare to output -1.\",\n    \"If no contradiction is found, calculate the maximum number of imposters by counting the players assigned the role of imposter.\",\n    \"Output the result for each test case, either the maximum number of imposters or -1 if a contradiction was found.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter', 'crewmate'\n    Explanation: In the game, an imposter always lies, and a crewmate always tells the truth. The task is to determine the maximum number of imposters or identify contradictions in the comments.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This means we need to find the highest count of imposters that can be assigned without contradictions.\n    'distinct integers': This indicates that i and j in the comments are different players.\n\n# [degree adverb]\n    'maximum': This refers to finding the largest possible number of imposters that can be assigned without contradictions.\n\n# [code logic]\n    The steps related to graph construction and role assignment should be implemented simultaneously. Specifically:\n    - Constructing the graph and performing graph traversal to assign roles should be done in a single process. This involves creating nodes and edges and then using a traversal method to assign roles while checking for contradictions.\n\n# [edge case]\n    1. Test case with no comments (e.g., n = 5, m = 0) = 5\n       Explanation: With no comments, there are no contradictions, so all players can be imposters.\n    2. Test case with a single contradiction (e.g., 1 2 imposter, 2 1 crewmate) = -1\n       Explanation: The comments directly contradict each other, so the output should be -1.\n    3. Test case with all players claiming others are imposters (e.g., 1 2 imposter, 2 3 imposter, 3 1 imposter) = 2\n       Explanation: A possible configuration is two imposters and one crewmate, which does not contradict the comments.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, particularly for detecting contradictions.\n    ```\n    def detect_contradictions_and_assign_roles(graph):\n        # Use BFS or DFS to traverse the graph\n        # Assign roles and check for contradictions\n        # If a contradiction is found, return -1\n        # Otherwise, calculate the maximum number of imposters\n    ```\n\nYES", "Round_0": {"code": "def solve_among_them():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            # No comments, all can be imposters\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1 means unassigned, 0 means crewmate, 1 means imposter\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0  # Start with crewmate\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                current = queue.popleft()\n                current_role = roles[current]\n                count[current_role] += 1\n                \n                for neighbor, comment in graph[current]:\n                    expected_role = 1 if comment == 'imposter' else 0\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = 1 - current_role if comment == 'imposter' else current_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != (1 - current_role if comment == 'imposter' else current_role):\n                        return -1  # Contradiction found\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve_among_them()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve_among_them():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            # No comments, all can be imposters\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1 means unassigned, 0 means crewmate, 1 means imposter\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0  # Start with crewmate\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                current = queue.popleft()\n                current_role = roles[current]\n                count[current_role] += 1\n                \n                for neighbor, comment in graph[current]:\n                    expected_role = 1 if comment == 'imposter' else 0\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = 1 - current_role if comment == 'imposter' else current_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != (1 - current_role if comment == 'imposter' else current_role):\n                        return -1  # Contradiction found\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve_among_them()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read integers n and m, representing the number of players and comments respectively.\",\n        \"For each test case, read m lines of comments, each containing two integers i, j and a string c.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the roles of players based on comments and identify contradictions.\",\n      \"steps\": [\n        \"For each test case, initialize a data structure to represent players and their roles.\",\n        \"Iterate through each comment and update the roles of players based on the comment.\",\n        \"Check for contradictions in comments, where a player is both claimed to be an imposter and a crewmate.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum possible number of imposters or identify contradictions.\",\n      \"steps\": [\n        \"For each test case, if no contradictions are found, calculate the maximum number of imposters based on the roles assigned.\",\n        \"If contradictions are found, mark the test case as having a contradiction.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the maximum number of imposters if no contradictions are found.\",\n        \"Output -1 if contradictions are found.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases, number of players, number of comments, and comments.\",\n    \"For each test case, initialize player roles and process comments to determine roles and check for contradictions.\",\n    \"Calculate the maximum possible number of imposters or identify contradictions for each test case.\",\n    \"Output the results for each test case, either the maximum number of imposters or -1 for contradictions.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter': A player who always lies about the role of other players.\n    'crewmate': A player who always tells the truth about the role of other players.\n    'contradiction': Occurs when comments about roles conflict, making it impossible to assign roles consistently.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': Refers to finding the highest count of imposters that can be assigned without contradictions.\n\n# [degree adverb] \n    'maximum': Indicates the need to find the largest possible number of imposters.\n\n# [code logic]\n    Steps related to processing comments and checking for contradictions should be implemented simultaneously. Specifically:\n    - \"Iterate through each comment and update the roles of players based on the comment.\"\n    - \"Check for contradictions in comments, where a player is both claimed to be an imposter and a crewmate.\"\n    These can be handled in a single loop where each comment is processed and checked for contradictions immediately.\n\n# [edge case] \n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: With no comments, all players can be imposters since there are no contradictions.\n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, making it impossible to assign roles consistently.\n    Test case with all players claiming others are imposters (e.g., 3 3 with comments \"1 2 imposter\", \"2 3 imposter\", \"3 1 imposter\") = 3\n    Explanation: All players can be imposters since each claims another is an imposter, which is consistent.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, particularly for checking contradictions.\n    - Implement a mechanism to track role claims and detect contradictions.\n    - Use a data structure (e.g., a graph or union-find) to manage role assignments and detect cycles or conflicts.\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        comments = []\n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            comments.append((i, j, c))\n            index += 3\n        \n        # Graph to store relationships\n        graph = defaultdict(list)\n        \n        for i, j, c in comments:\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        roles = [-1] * (n + 1)  # -1 means unassigned, 0 means crewmate, 1 means imposter\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # Start with crewmate assumption\n            roles[start] = 0\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                node, role = queue.popleft()\n                count[role] += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation  # XOR to flip role if relation is imposter\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append((neighbor, expected_role))\n                    elif roles[neighbor] != expected_role:\n                        return -1  # Contradiction found\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        comments = []\n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            comments.append((i, j, c))\n            index += 3\n        \n        # Graph to store relationships\n        graph = defaultdict(list)\n        \n        for i, j, c in comments:\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        roles = [-1] * (n + 1)  # -1 means unassigned, 0 means crewmate, 1 means imposter\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # Start with crewmate assumption\n            roles[start] = 0\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                node, role = queue.popleft()\n                count[role] += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation  # XOR to flip role if relation is imposter\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append((neighbor, expected_role))\n                    elif roles[neighbor] != expected_role:\n                        return -1  # Contradiction found\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the comments themselves.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n and m representing the number of players and comments.\",\n        \"For each test case, read m comments of the form 'i j c'.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the roles of players based on comments and identify contradictions.\",\n      \"steps\": [\n        \"Model the problem as a graph where each player is a node and each comment is an edge with a label indicating the role.\",\n        \"Use a graph traversal technique (e.g., DFS or BFS) to attempt to assign roles to players.\",\n        \"Check for contradictions during traversal: if a player is assigned a role that conflicts with previous assignments, mark the test case as contradictory.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum possible number of imposters for each test case.\",\n      \"steps\": [\n        \"For non-contradictory test cases, count the number of players assigned the role of imposter.\",\n        \"If a test case is contradictory, return -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases, player counts, comment counts, and comments.\",\n    \"For each test case, construct a graph representation of players and comments.\",\n    \"Attempt to assign roles to players using graph traversal, checking for contradictions.\",\n    \"For each test case, determine the maximum number of imposters or identify contradictions.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter', 'crewmate', 'contradict'\n    Explanation: In the game, an imposter always lies, while a crewmate always tells the truth. The concept of contradiction arises when the comments made by players lead to logical inconsistencies in determining roles.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This indicates that we need to find the highest number of imposters that can be assigned without contradictions.\n    Implementation: This can be implemented by traversing the graph and counting the number of imposters assigned, ensuring no contradictions occur.\n\n# [degree adverb]\n    'maximum': This means we need to find the largest possible count of imposters.\n    Implementation: During graph traversal, keep track of the number of imposters assigned and ensure it is the highest possible without contradictions.\n\n# [code logic]\n    The steps in the plan related to graph traversal and contradiction checking should be implemented simultaneously. Specifically, while traversing the graph to assign roles, contradictions should be checked in the same code block to ensure consistency in role assignment.\n\n# [edge case]\n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: With no comments, there are no contradictions, so all players can be imposters.\n    \n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, making it impossible to assign roles consistently.\n    \n    Test case with all players claiming others are imposters (e.g., 3 3 with comments \"1 2 imposter\", \"2 3 imposter\", \"3 1 imposter\") = 3\n    Explanation: If all players claim others are imposters, they can all be imposters without contradiction.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n        - Implement a check for cases with no comments to assign all players as imposters.\n        - Implement contradiction detection during graph traversal to return -1 when contradictions are found.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            # If there are no comments, all players can be imposters\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        roles = [-1] * (n + 1)  # -1 means unvisited, 0 means crewmate, 1 means imposter\n        contradiction = False\n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                queue = deque([(player, 0)])\n                imposters_count = 0\n                crewmates_count = 0\n                \n                while queue:\n                    current, role = queue.popleft()\n                    \n                    if roles[current] == -1:\n                        roles[current] = role\n                        if role == 1:\n                            imposters_count += 1\n                        else:\n                            crewmates_count += 1\n                    elif roles[current] != role:\n                        contradiction = True\n                        break\n                    \n                    for neighbor, relation in graph[current]:\n                        expected_role = role ^ relation\n                        if roles[neighbor] == -1:\n                            queue.append((neighbor, expected_role))\n                        elif roles[neighbor] != expected_role:\n                            contradiction = True\n                            break\n                    if contradiction:\n                        break\n                \n                if contradiction:\n                    break\n                max_imposters += max(imposters_count, crewmates_count)\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the comments themselves.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, representing the number of players and comments respectively.\",\n        \"For each test case, read m lines of comments, each containing two integers i, j and a string c.\"\n      ]\n    },\n    {\n      \"description\": \"Model the problem using a graph where players are nodes and comments are edges with labels indicating the role (imposter or crewmate).\",\n      \"steps\": [\n        \"Create a graph representation where each player is a node.\",\n        \"For each comment, add an edge between nodes i and j with the label c.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters or detect contradictions using graph traversal and role assignment.\",\n      \"steps\": [\n        \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to assign roles to each player based on the comments.\",\n        \"If a contradiction is detected during traversal (e.g., a player is assigned conflicting roles), mark the test case as having contradictions.\",\n        \"If no contradictions are found, calculate the maximum number of imposters by counting nodes assigned as imposters.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if contradictions are detected, output -1.\",\n        \"Otherwise, output the maximum number of imposters calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and comments.\",\n    \"Model the problem using a graph with nodes as players and edges as comments.\",\n    \"Traverse the graph to assign roles and detect contradictions.\",\n    \"Calculate the maximum number of imposters if no contradictions are found.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter' and 'crewmate'\n    Explanation: In the game, imposters always lie, and crewmates always tell the truth. Each player has exactly one role, either imposter or crewmate. The goal is to determine the maximum number of imposters or detect contradictions in the comments.\n\n# [phrase showing quantity relationship]\n    'maximum possible number'\n    Explanation: This means finding the highest count of players that can be imposters without contradictions in the comments. In code, this involves traversing the graph and counting nodes assigned as imposters.\n\n# [degree adverb]\n    'maximum'\n    Explanation: The requirement is to find the largest possible number of imposters. This involves ensuring that the role assignment does not lead to contradictions and counting the imposters.\n\n# [code logic]\n    The steps in the plan related to graph traversal and role assignment should be implemented simultaneously. Specifically, during the graph traversal, roles should be assigned, and contradictions should be checked in the same code block. This can be done using a DFS or BFS approach where each node is visited, roles are assigned, and contradictions are checked in one traversal.\n\n# [edge case]\n    Test case with no comments: \n    Input: 5 0\n    Expected output: 5\n    Explanation: With no comments, there are no contradictions, and all players can be imposters.\n\n    Test case with contradictory comments:\n    Input: 2 2\n    1 2 imposter\n    2 1 crewmate\n    Expected output: -1\n    Explanation: The comments contradict each other, as explained in the example.\n\n    Test case with all players as crewmates:\n    Input: 3 2\n    1 2 crewmate\n    2 3 crewmate\n    Expected output: 0\n    Explanation: If all comments indicate crewmates, the maximum number of imposters is zero.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, especially for detecting contradictions.\n    Code for handling contradictions:\n    ```python\n    def detect_contradictions(graph, n):\n        roles = [-1] * (n + 1)  # -1 indicates unassigned, 0 for crewmate, 1 for imposter\n        def dfs(node, role):\n            if roles[node] != -1:\n                return roles[node] == role\n            roles[node]", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            graph[i].append((j, c))\n            graph[j].append((i, c))\n        \n        roles = [-1] * (n + 1)  # -1 indicates unassigned, 0 for crewmate, 1 for imposter\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # Start with crewmate role\n            roles[start] = 0\n            imposter_count = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                if role == 1:\n                    imposter_count += 1\n                \n                for neighbor, comment in graph[node]:\n                    expected_role = 1 if comment == 'imposter' else 0\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = role ^ expected_role\n                        queue.append((neighbor, roles[neighbor]))\n                    elif roles[neighbor] != (role ^ expected_role):\n                        return -1\n            \n            return imposter_count\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 110)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            graph[i].append((j, c))\n            graph[j].append((i, c))\n        \n        roles = [-1] * (n + 1)  # -1 indicates unassigned, 0 for crewmate, 1 for imposter\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # Start with crewmate role\n            roles[start] = 0\n            imposter_count = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                if role == 1:\n                    imposter_count += 1\n                \n                for neighbor, comment in graph[node]:\n                    expected_role = 1 if comment == 'imposter' else 0\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = role ^ expected_role\n                        queue.append((neighbor, roles[neighbor]))\n                    elif roles[neighbor] != (role ^ expected_role):\n                        return -1\n            \n            return imposter_count\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, model the problem as a graph where each player is a node and each comment is an edge with a label indicating the role (imposter or crewmate).\",\n      \"output\": \"A graph representation for each test case.\"\n    },\n    {\n      \"description\": \"Determine the possible roles of each player using the graph. Use a graph traversal technique (e.g., DFS or BFS) to assign roles while checking for contradictions.\",\n      \"output\": \"A role assignment for each player or a contradiction flag.\"\n    },\n    {\n      \"description\": \"Calculate the maximum number of imposters based on the valid role assignments or identify if a contradiction exists.\",\n      \"output\": \"The maximum number of imposters or -1 if a contradiction is found.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into structured test cases.\",\n    \"For each test case, construct a graph where nodes represent players and edges represent comments with labels indicating roles.\",\n    \"Perform a graph traversal to assign roles to each player, ensuring consistency with the comments. If a contradiction is detected, mark the test case as invalid.\",\n    \"For valid test cases, calculate the maximum number of imposters by considering the role assignments.\",\n    \"Output the result for each test case: the maximum number of imposters or -1 if a contradiction is found.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter': A player who always lies about the role of other players.\n    'crewmate': A player who always tells the truth about the role of other players.\n    'contradict': A situation where the comments about roles cannot logically coexist.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This means we need to find the largest count of imposters that can be logically assigned based on the comments without contradiction.\n\n# [degree adverb] \n    'maximum': We need to find the highest number of imposters possible given the constraints of the comments.\n\n# [code logic]\n    The steps related to graph traversal and role assignment should be implemented simultaneously. Specifically, while traversing the graph, roles should be assigned and checked for contradictions in one code block using DFS or BFS.\n\n# [edge case] \n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: With no comments, all players can be imposters, as there are no constraints.\n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, making it impossible to assign roles without conflict.\n    Test case with all players claiming others are imposters (e.g., 3 3 with comments \"1 2 imposter\", \"2 3 imposter\", \"3 1 imposter\") = 3\n    Explanation: All players can be imposters since each claims another is an imposter, which is consistent.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, particularly for detecting contradictions.\n        if m == 0:\n            print(n)\n        else:\n            # Implement graph traversal and contradiction detection logic\n            # If contradiction is detected, print -1\n            # Otherwise, calculate and print the maximum number of imposters\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        roles = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            roles[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        count[expected_role] += 1\n                        queue.append((neighbor, expected_role))\n                    elif roles[neighbor] != expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        contradiction = False\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 109)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        roles = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            roles[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        count[expected_role] += 1\n                        queue.append((neighbor, expected_role))\n                    elif roles[neighbor] != expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        contradiction = False\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n and m representing the number of players and comments.\",\n        \"For each test case, read m comments of the form 'i j c'.\"\n      ]\n    },\n    {\n      \"description\": \"Model the problem using graph theory where players are nodes and comments are edges with labels indicating the role.\",\n      \"steps\": [\n        \"Create a graph for each test case where nodes represent players.\",\n        \"Add edges between nodes based on comments, with labels indicating 'imposter' or 'crewmate'.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters or detect contradictions using graph traversal.\",\n      \"steps\": [\n        \"Use a graph coloring technique to assign roles to players, ensuring consistency with comments.\",\n        \"Detect contradictions by checking for conflicts in role assignments.\",\n        \"Calculate the maximum number of imposters if no contradictions are found.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output the maximum number of imposters or -1 if contradictions are detected.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases, player counts, comment counts, and comments.\",\n    \"For each test case, construct a graph representing players and comments.\",\n    \"Apply graph coloring to determine roles and check for contradictions.\",\n    \"Calculate and output the maximum number of imposters or -1 for contradictions.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter': A player who always lies about the role of other players.\n    'crewmate': A player who always tells the truth about the role of other players.\n    'contradict': A situation where the comments made by players lead to logical inconsistencies.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This indicates that we need to find the highest count of imposters that can be logically assigned without contradictions.\n\n# [degree adverb] \n    'maximum': This means we need to find the largest number of imposters possible given the constraints of the comments.\n\n# [code logic]\n    The steps related to graph construction and graph coloring should be implemented simultaneously. Specifically:\n    - \"Create a graph for each test case where nodes represent players.\"\n    - \"Add edges between nodes based on comments, with labels indicating 'imposter' or 'crewmate'.\"\n    - \"Use a graph coloring technique to assign roles to players, ensuring consistency with comments.\"\n    These steps can be integrated into a single function that constructs the graph and attempts to color it while checking for contradictions.\n\n# [edge case] \n    Test case with no comments: \n    Input: 5 0\n    Expected output: 5\n    Explanation: With no comments, all players can be imposters.\n    \n    Test case with contradictory comments:\n    Input: 2 2\n    1 2 imposter\n    2 1 crewmate\n    Expected output: -1\n    Explanation: The comments contradict each other, making it impossible to assign roles consistently.\n    \n    Test case with multiple comments for the same pair:\n    Input: 3 5\n    1 2 imposter\n    1 2 imposter\n    3 2 crewmate\n    3 2 crewmate\n    1 3 imposter\n    Expected output: 2\n    Explanation: Despite multiple comments, a consistent assignment is possible with 2 imposters.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, particularly for detecting contradictions and handling cases with no comments.\n    - Implement a check for contradictions during graph coloring.\n    - Handle cases with no comments by defaulting to all players being imposters.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            color[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                for neighbor, edge_type in graph[node]:\n                    expected_color = col ^ edge_type\n                    if color[neighbor] == -1:\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append((neighbor, expected_color))\n                    elif color[neighbor] != expected_color:\n                        return -1, 0\n            \n            return max(count), sum(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if color[player] == -1:\n                result, total = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 108)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            color[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                for neighbor, edge_type in graph[node]:\n                    expected_color = col ^ edge_type\n                    if color[neighbor] == -1:\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append((neighbor, expected_color))\n                    elif color[neighbor] != expected_color:\n                        return -1, 0\n            \n            return max(count), sum(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if color[player] == -1:\n                result, total = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Read the number of test cases t. For each test case, read the integers n and m, followed by m comments of the form 'i j c'.\"\n    },\n    {\n      \"description\": \"Model the problem using a graph-based approach.\",\n      \"details\": \"Consider each player as a node in a graph. Each comment 'i j c' represents an edge between nodes i and j with a label 'c'.\"\n    },\n    {\n      \"description\": \"Determine the roles of players using a graph traversal technique.\",\n      \"details\": \"Use a graph traversal method (e.g., BFS or DFS) to assign roles to players. Start with an arbitrary player and attempt to assign roles based on the comments. Track contradictions during traversal.\"\n    },\n    {\n      \"description\": \"Detect contradictions in the comments.\",\n      \"details\": \"While traversing the graph, if a contradiction is found (e.g., a player is assigned conflicting roles), mark the test case as having contradictory comments.\"\n    },\n    {\n      \"description\": \"Calculate the maximum number of imposters.\",\n      \"details\": \"For each connected component of the graph, calculate the maximum number of imposters by considering both possible role assignments and choosing the one with more imposters.\"\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, output the maximum number of imposters if no contradictions are found, otherwise output -1.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, initialize a graph structure to represent players and comments.\",\n    \"Perform a graph traversal to assign roles to players and detect contradictions.\",\n    \"If a contradiction is detected, mark the test case as invalid.\",\n    \"If no contradiction is found, calculate the maximum number of imposters for the test case.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter': A player who always lies about the role of other players.\n    'crewmate': A player who always tells the truth about the role of other players.\n    'contradict': When comments from players lead to conflicting information about roles.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This means we need to find the largest count of imposters that can be assigned without contradictions.\n    Implementation: Use graph traversal to explore all possible role assignments and choose the one with the most imposters.\n\n# [degree adverb]\n    'maximum': Refers to the largest number of imposters that can be assigned without contradictions.\n    Implementation: During graph traversal, calculate the number of imposters for each possible role assignment and select the maximum.\n\n# [code logic]\n    Steps 3 and 4 should be implemented simultaneously. While traversing the graph to assign roles, contradictions should be detected in the same process. This can be done using a single graph traversal method (e.g., BFS or DFS) that checks for contradictions as roles are assigned.\n\n# [edge case]\n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: With no comments, all players can be imposters, so the maximum number of imposters is equal to the number of players.\n    \n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, so it's impossible to assign roles without conflict.\n    \n    Test case with all players claiming others are imposters (e.g., 3 3 with comments \"1 2 imposter\", \"2 3 imposter\", \"3 1 imposter\") = 3\n    Explanation: All players can be imposters since there are no contradictions in the comments.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Initialize all players as imposters if there are no comments.\n    - Implement logic to detect contradictions during graph traversal.\n    - Use a graph traversal method to explore all possible role assignments and handle contradictions.\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        visited = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            visited[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if visited[neighbor] == -1:\n                        visited[neighbor] = expected_role\n                        count[expected_role] += 1\n                        queue.append((neighbor, expected_role))\n                    elif visited[neighbor] != expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        contradiction = False\n        \n        for player in range(1, n + 1):\n            if visited[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, false, true, true, false, false, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 594, "prompt": "Theofanis started playing the new online game called \"Among them\". However, he always plays with Cypriot players, and they all have the same name: \"Andreas\" (the most common name in Cyprus).\n\nIn each game, Theofanis plays with n other players, and since they all have the same name, they are numbered from 1 to n.\n\nThe players write m comments in the chat. A comment has the structure of \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate). This structure indicates that player i said something about another player. Specifically, player i said that player j has the role c.\n\nAn imposter always lies, and a crewmate always tells the truth. \n\nHelp Theofanis find the maximum possible number of imposters among all the other Cypriot players, or determine that the comments contradict each other (see the notes for further explanation).\n\nNote that each player has exactly one role: either imposter or crewmate.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.", "mutate_method": "expand_one2two", "save_node": true, "parent_index": 180}
