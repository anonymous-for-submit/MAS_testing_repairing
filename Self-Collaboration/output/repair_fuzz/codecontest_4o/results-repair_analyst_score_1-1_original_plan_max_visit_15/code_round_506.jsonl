{"name": "1580_C. Train Maintenance", "description": "Kawasiro Nitori is excellent in engineering. Thus she has been appointed to help maintain trains.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment. In the beginning, there are no trains, at each of the following m days, one train will be added, or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance in each day.\n\nOn a day a train is removed, it is not counted as in maintenance.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.", "tags": ["brute force", "data structures", "implementation"], "difficulty": 9, "id": 1580, "sample_io": [{"input": "3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}], "test_list": [{"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n10 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "3 4\n10 15\n12 10\n2 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "3 4\n23 15\n14 10\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n2 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n2 19\n7 19\n2 9\n26 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n5\n4\n3\n5\n7\n8\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n21 15\n7 3\n19 7\n1 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n2\n2\n2\n1\n2\n3\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n5\n4\n3\n5\n7\n8\n"]}, {"input": "5 2\n1 1\n10000011 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n1 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "10 7\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n8 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n8\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n3 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 2\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n0\n"]}, {"input": "20 7\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n4 9\n5 10\n657453515 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n3 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n"]}, {"input": "3 2\n9 15\n12 9\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n2 9\n14 19\n7 19\n2 9\n21 15\n7 3\n19 7\n1 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n2\n2\n2\n1\n3\n4\n4\n4\n4\n5\n5\n4\n3\n4\n6\n8\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 9\n2 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 2\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n3 9\n49 15\n7 6\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n6\n5\n6\n7\n7\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n1 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n14 9\n14 19\n7 19\n2 9\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n4\n3\n4\n7\n8\n"]}, {"input": "3 4\n16 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 15\n15 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 15\n10 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "3 4\n10 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000011 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 000000000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "3 4\n9 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n9 15\n12 1\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 0\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n733475792 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n13 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n467159628 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 8\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000001 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1258790837 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n26 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 0\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000011 100000000\n998244353 1\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n9 15\n12 0\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n21 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n13 15\n14 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n369260158 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n16 16\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n26 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n16 6\n2 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n23 15\n14 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n2 1\n10000001 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n2 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n450441171 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000101 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 7\n15 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "3 4\n16 15\n10 17\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000011 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000011 000000000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n9 15\n12 9\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 -1\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 241782432\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n2 1\n1 5\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 801909796\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n5 15\n12 10\n2 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "5 4\n1 1\n10000000 100000001\n733475792 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 8\n12 18\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10001011 100000000\n998244353 1\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n2 1\n10000011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n1166046831 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n26 15\n10 17\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000011 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000011 000000000\n998244353 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1425917046 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 241782432\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 11\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "20 20\n1 4\n864803385 801909796\n17 4\n12 1\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "5 4\n1 1\n10000000 100000001\n733475792 1\n2 2\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "3 4\n16 8\n12 25\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 2\n10000011 100000000\n998244353 0\n2 2\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1011185365 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000001\n733475792 0\n2 2\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 2\n1 1\n", "output": ["0\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n211018821 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n211018821 0\n3 1\n2 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "5 4\n3 1\n10000011 101000000\n211018821 0\n3 1\n2 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n4 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "3 4\n14 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 1\n2 1\n1 3\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 15\n12 15\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 0\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n14 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000011 000000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 1\n9 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n"]}, {"input": "5 4\n1 1\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n9 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n10 18\n12 10\n2 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n733475792 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n22 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 0\n430995384 733598623\n2 9\n5 13\n433415385 169535970\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n9 6\n752625088 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1258790837 0\n3 0\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 173113793\n3 10\n16 6\n2 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n2 2\n10000001 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n9 6\n450441171 733598623\n2 9\n3 10\n433415385 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n16 21\n10 17\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n9 6\n12 9\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1683854825 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 241782432\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 38795044\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n2 1\n1 10\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 0\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "3 4\n16 12\n12 18\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n4 1\n10000011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n1908812372 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n2 1\n", "output": ["0\n"]}, {"input": "5 4\n3 1\n10010011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 2\n10000011 100000000\n998244353 0\n2 4\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 2\n1 2\n", "output": ["0\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n211018821 0\n4 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n3 1\n10000011 101000000\n211018821 0\n3 1\n2 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n4 29\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "3 4\n14 15\n12 13\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 1\n3 1\n1 3\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n2 1\n10000001 100000000\n998244353 0\n2 0\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n14 15\n10 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "3 1\n9 15\n12 9\n2 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n"]}, {"input": "5 4\n1 1\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 4\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 0\n430995384 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n9 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n2 2\n10000001 100000000\n1258790837 0\n5 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n5\n4\n3\n5\n7\n8\n"]}, {"input": "5 2\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n"]}, {"input": "3 4\n16 21\n10 17\n2 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1683854825 0\n3 1\n2 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n4 1\n1 10\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "5 1\n1 0\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n3 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "3 4\n16 12\n12 22\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000000 100000000\n1908812372 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000101 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n2 1\n", "output": ["0\n"]}, {"input": "5 1\n1 1\n10000101 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 2\n1 2\n", "output": ["0\n"]}, {"input": "3 1\n9 15\n12 9\n2 2\n1 3\n1 1\n1 1\n2 3\n", "output": ["0\n"]}, {"input": "5 4\n1 0\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 4\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n0 0\n430995384 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 2\n1 1\n10000000 100010000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n"]}, {"input": "10 7\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 1\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 9\n2 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "3 4\n1 12\n12 22\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000000 100000000\n1908812372 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n2 1\n10000101 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n2 1\n", "output": ["0\n"]}, {"input": "3 1\n9 15\n12 9\n2 4\n1 3\n1 1\n1 1\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n0 0\n140846265 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 9\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n8\n"]}, {"input": "5 2\n1 2\n10000000 100010000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n"]}, {"input": "10 7\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 1\n2 9\n1 1\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 13\n2 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n12 9\n2 4\n1 3\n1 1\n0 1\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n-1 0\n140846265 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 7\n3 10\n9 6\n529113291 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 1\n2 9\n1 1\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "3 1\n9 15\n12 9\n2 4\n1 3\n1 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 7\n3 10\n-1 0\n140846265 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n17 2\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n292159474 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n3 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n7\n"]}, {"input": "3 1\n9 15\n12 11\n2 4\n1 3\n1 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 2\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n12 11\n2 4\n1 3\n0 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 1\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n12 11\n4 4\n1 3\n0 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 1\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 6\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n16 11\n4 4\n1 3\n0 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 0\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 6\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 -1\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 6\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 2\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n0 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n2 1\n10000001 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}], "task_id": "codecontest/22", "repair_prompt": ["Kawasiro Nitori is excellent in engineering. Thus she has been appointed to help maintain trains.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment. At the beginning, there are no trains present in the department. At each of the following m days, one train will be added, or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive). Then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance in each day.\n\nOn a day a train is removed, it is not counted as in maintenance.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Kawasiro Nitori is excellent in engineering. Thus she has been appointed to help maintain trains.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment. At the beginning, there are no trains present in the department. At each of the following m days, one train will be added, or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive). Subsequently, it is in maintenance for y_i days. Then it is in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance in each day.\n\nOn a day a train is removed, it is not counted as in maintenance.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Kawasiro Nitori is excellent in engineering. Thus she has been appointed to help maintain trains.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment; at the beginning, there are no trains present in the department, and at each of the following m days, one train will be added, or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive). Then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance in each day.\n\nOn a day a train is removed, it is not counted as in maintenance.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking for each train model\n    train_state = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance[k]\n            train_state[k] = (x_i, y_i, x_i)  # (work_days, maintenance_days, remaining_work_days)\n        \n        elif op == 2:  # Remove train of model k\n            if train_state[k] is not None:\n                _, y_i, remaining_work_days = train_state[k]\n                if remaining_work_days <= 0:\n                    maintenance_count -= 1\n                train_state[k] = None\n        \n        # Update the state of all trains\n        for i in range(n):\n            if train_state[i] is not None:\n                x_i, y_i, remaining_work_days = train_state[i]\n                \n                if remaining_work_days > 0:\n                    remaining_work_days -= 1\n                else:\n                    remaining_work_days = -1  # In maintenance\n                    if remaining_work_days == -1:\n                        maintenance_count += 1\n                    remaining_work_days -= 1\n                \n                if remaining_work_days == -y_i:\n                    remaining_work_days = x_i\n                    maintenance_count -= 1\n                \n                train_state[i] = (x_i, y_i, remaining_work_days)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\nmain()", "completions": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize train status\n    train_status = {i: {'present': False, 'cycle_position': 0} for i in range(1, n+1)}\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        x_i, y_i = work_maintenance[k-1]\n        \n        if op == 1:  # Add train\n            train_status[k]['present'] = True\n            train_status[k]['cycle_position'] = 0\n        elif op == 2:  # Remove train\n            train_status[k]['present'] = False\n        \n        # Calculate maintenance trains\n        count_in_maintenance = 0\n        for i in range(1, n+1):\n            if train_status[i]['present']:\n                cycle_position = train_status[i]['cycle_position']\n                if cycle_position >= x_i:\n                    count_in_maintenance += 1\n                train_status[i]['cycle_position'] = (cycle_position + 1) % (x_i + y_i)\n        \n        maintenance_count[day] = count_in_maintenance\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_specs = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_specs.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State of each train model: (is_present, current_day_in_cycle)\n    train_state = [(False, 0) for _ in range(n)]\n    \n    # Result for each day\n    result = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_state[k] = (True, 0)\n        \n        elif op == 2:  # Remove train\n            train_state[k] = (False, 0)\n        \n        # Calculate number of trains in maintenance\n        maintenance_count = 0\n        for i in range(n):\n            is_present, current_day_in_cycle = train_state[i]\n            if is_present:\n                x_i, y_i = train_specs[i]\n                # Calculate the current phase in the cycle\n                cycle_length = x_i + y_i\n                day_in_cycle = current_day_in_cycle % cycle_length\n                if day_in_cycle >= x_i:\n                    maintenance_count += 1\n                # Update the day in cycle for the next day\n                train_state[i] = (is_present, current_day_in_cycle + 1)\n        \n        result.append(maintenance_count)\n    \n    for count in result:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    work_maintenance = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: None if not present, otherwise (start_day, cycle_day)\n    train_state = [None] * n\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            x_i, y_i = work_maintenance[k]\n            train_state[k] = (day, x_i + y_i)\n        \n        elif op == 2:  # Remove train\n            train_state[k] = None\n        \n        # Calculate maintenance count for the current day\n        count = 0\n        for model in range(n):\n            if train_state[model] is not None:\n                start_day, cycle_day = train_state[model]\n                x_i, y_i = work_maintenance[model]\n                \n                # Calculate the number of days since the train was added\n                days_since_added = day - start_day\n                \n                # Determine if the train is in maintenance\n                if days_since_added >= x_i:\n                    # Calculate the position in the cycle\n                    cycle_position = days_since_added % cycle_day\n                    if cycle_position >= x_i:\n                        count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    # Read the working and maintenance periods for each train model\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_cycles.append((x_i, y_i))\n    \n    # Initialize the status of each train model\n    model_status = [None] * (n + 1)  # None means no train of this model is present\n    \n    # Prepare to store the results\n    results = []\n    \n    # Process each day's operation\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k - 1]\n            model_status[k] = (0, x_i, y_i)  # (current_day_in_cycle, work_days, maintenance_days)\n        elif op == 2:  # Remove train of model k\n            model_status[k] = None\n        \n        # Count trains in maintenance\n        maintenance_count = 0\n        for status in model_status:\n            if status is not None:\n                current_day_in_cycle, work_days, maintenance_days = status\n                # Check if the train is in maintenance\n                if current_day_in_cycle >= work_days:\n                    maintenance_count += 1\n                # Update the cycle day\n                current_day_in_cycle = (current_day_in_cycle + 1) % (work_days + maintenance_days)\n                # Update the status\n                model_status[model_status.index(status)] = (current_day_in_cycle, work_days, maintenance_days)\n        \n        # Store the result for the current day\n        results.append(maintenance_count)\n    \n    # Output the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_maintenance(n, m, train_periods, operations):\n    # Initialize the status of each train model\n    train_status = [None] * n  # None means no train, otherwise it stores the day it was added\n    maintenance_count = [0] * m\n    \n    # Iterate over each day and perform operations\n    for day in range(m):\n        op, k = operations[day]\n        k -= 1  # Convert to zero-based index\n        \n        if op == 1:  # Add train of model k\n            train_status[k] = day\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance\n        count = 0\n        for i in range(n):\n            if train_status[i] is not None:\n                x_i, y_i = train_periods[i]\n                days_since_added = day - train_status[i]\n                cycle_length = x_i + y_i\n                if days_since_added >= x_i and (days_since_added - x_i) % cycle_length < y_i:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    return maintenance_count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    train_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1])\n        operations.append((op, k))\n        index += 2\n    \n    maintenance_count = calculate_maintenance(n, m, train_periods, operations)\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    work_maintenance_periods = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to zero-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: None if not present, otherwise a tuple (days_in_current_state, is_in_maintenance)\n    train_states = [None] * n\n    maintenance_count = 0\n    \n    results = []\n    \n    for op, k in operations:\n        if op == 1:  # Add train\n            x_i, y_i = work_maintenance_periods[k]\n            train_states[k] = (1, False)  # Start working\n        elif op == 2:  # Remove train\n            if train_states[k][1]:  # If it was in maintenance, decrease the count\n                maintenance_count -= 1\n            train_states[k] = None\n        \n        # Update states for all trains\n        for i in range(n):\n            if train_states[i] is not None:\n                days, is_in_maintenance = train_states[i]\n                x_i, y_i = work_maintenance_periods[i]\n                \n                if is_in_maintenance:\n                    if days == y_i:\n                        train_states[i] = (1, False)  # Switch to working\n                        maintenance_count -= 1\n                    else:\n                        train_states[i] = (days + 1, True)\n                else:\n                    if days == x_i:\n                        train_states[i] = (1, True)  # Switch to maintenance\n                        maintenance_count += 1\n                    else:\n                        train_states[i] = (days + 1, False)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize the status of each train model\n    train_status = [None] * n  # None means no train of this model is present\n    \n    # Result list to store the number of trains in maintenance each day\n    result = []\n    \n    # Simulate each day\n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance[k]\n            train_status[k] = (day, x_i, y_i)  # Store the day it was added and its cycle lengths\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance\n        maintenance_count = 0\n        for status in train_status:\n            if status is not None:\n                added_day, x_i, y_i = status\n                days_since_added = day - added_day\n                cycle_length = x_i + y_i\n                cycle_position = days_since_added % cycle_length\n                if cycle_position >= x_i:\n                    maintenance_count += 1\n        \n        result.append(maintenance_count)\n    \n    # Print the result for each day\n    for count in result:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking\n    train_states = [None] * n  # None means no train, otherwise (start_day, cycle_position)\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            x_i, y_i = train_cycles[k]\n            train_states[k] = (day, 0)  # Start at day `day` with cycle position 0 (working)\n        \n        elif op == 2:  # Remove train\n            train_states[k] = None\n        \n        # Calculate maintenance count for the current day\n        count_in_maintenance = 0\n        for i in range(n):\n            if train_states[i] is not None:\n                start_day, cycle_position = train_states[i]\n                x_i, y_i = train_cycles[i]\n                \n                # Calculate the number of days since the train was added\n                days_since_added = day - start_day\n                \n                # Calculate the current cycle position\n                total_cycle = x_i + y_i\n                current_cycle_day = days_since_added % total_cycle\n                \n                # Check if the train is in maintenance\n                if current_cycle_day >= x_i:\n                    count_in_maintenance += 1\n        \n        maintenance_count[day] = count_in_maintenance\n    \n    # Output the results\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_cycles.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # Initialize train status\n    train_status = [None] * n  # None means no train of this model is present\n    \n    # Result list to store the number of trains in maintenance each day\n    result = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_cycles[k]\n            train_status[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate number of trains in maintenance\n        maintenance_count = 0\n        for status in train_status:\n            if status is not None:\n                added_day, x_i, y_i = status\n                cycle_length = x_i + y_i\n                days_since_added = day - added_day\n                \n                # Determine current cycle position\n                cycle_position = days_since_added % cycle_length\n                \n                # Check if in maintenance\n                if cycle_position >= x_i:\n                    maintenance_count += 1\n        \n        result.append(maintenance_count)\n    \n    # Print the result for each day\n    for count in result:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking for each train model\n    train_state = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance[k]\n            train_state[k] = (x_i, y_i, x_i)  # (work_days, maintenance_days, remaining_work_days)\n        \n        elif op == 2:  # Remove train of model k\n            if train_state[k] is not None:\n                _, y_i, remaining_work_days = train_state[k]\n                if remaining_work_days <= 0:\n                    maintenance_count -= 1\n                train_state[k] = None\n        \n        # Update the state of all trains\n        for i in range(n):\n            if train_state[i] is not None:\n                x_i, y_i, remaining_work_days = train_state[i]\n                \n                if remaining_work_days > 0:\n                    remaining_work_days -= 1\n                else:\n                    remaining_work_days = -1  # In maintenance\n                    if remaining_work_days == -1:\n                        maintenance_count += 1\n                    remaining_work_days -= 1\n                \n                if remaining_work_days == -y_i:\n                    remaining_work_days = x_i\n                    maintenance_count -= 1\n                \n                train_state[i] = (x_i, y_i, remaining_work_days)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"output\": \"A structured representation of the input data, including train models and daily operations.\"\n    },\n    {\n      \"description\": \"Implement a data structure to track the state of each train model, including whether it is currently in operation or maintenance, and the remaining days in its current state.\",\n      \"output\": \"A data structure that can efficiently update and query the state of each train model.\"\n    },\n    {\n      \"description\": \"Simulate each day's operations, updating the state of the trains based on the operation (add or remove) and the current state of each train model.\",\n      \"output\": \"An updated state of all train models for each day.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day based on the current state of all train models.\",\n      \"output\": \"A list of integers representing the number of trains in maintenance for each day.\"\n    },\n    {\n      \"description\": \"Output the result for each day as specified in the requirement.\",\n      \"output\": \"Formatted output of the number of trains in maintenance for each day.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of train models, number of days, work and maintenance periods for each train model, and daily operations.\",\n    \"Initialize a data structure to track the state of each train model, including its current cycle (work or maintenance) and remaining days in that cycle.\",\n    \"Iterate over each day's operations:\",\n    \"  - If a train is added, set its initial state to 'working' and track its work and maintenance cycle.\",\n    \"  - If a train is removed, update the state to reflect its removal.\",\n    \"  - Update the state of all trains to reflect the passage of one day, transitioning trains between work and maintenance as needed.\",\n    \"Calculate the number of trains in maintenance for each day based on the current state of all train models.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models'\n    Explanation: Refers to different types of trains, each with specific work and maintenance cycles.\n\n    'work for x_i days' and 'maintenance for y_i days'\n    Explanation: Each train model has a cycle where it operates for a certain number of days (x_i) and then undergoes maintenance for another set of days (y_i).\n\n# [phrase showing quantity relationship]\n    'at most one train of each model'\n    Explanation: There can be no more than one train of each model in the department at any time.\n\n    '1 \u2264 n,m \u2264 2 \u22c5 10^5'\n    Explanation: The number of train models and days are both constrained to be between 1 and 200,000.\n\n    '1 \u2264 x_i,y_i \u2264 10^9'\n    Explanation: The work and maintenance periods for each train model are between 1 and 1 billion days.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to updating the state of trains and calculating the number of trains in maintenance should be implemented simultaneously. Specifically:\n    - \"Update the state of all trains to reflect the passage of one day, transitioning trains between work and maintenance as needed.\"\n    - \"Calculate the number of trains in maintenance for each day based on the current state of all train models.\"\n    These can be done in a single loop that processes each day's operations and updates the state of all trains.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: On the first day, a train is added and it is working, so no train is in maintenance.\n\n    Input: 1 2\n           1 1\n           1 1\n           2 1\n    Output: 0\n            0\n    Explanation: On the first day, a train is added and it is working. On the second day, the train is removed, so no train is in maintenance on either day.\n\n    Input: 2 3\n           1 1\n           1 1\n           1 1\n           1 2\n           2 1\n    Output: 0\n            0\n            0\n    Explanation: On the first day, a train of model 1 is added and it is working. On the second", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking for each train model\n    train_state = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance[k]\n            train_state[k] = (x_i, y_i, x_i)  # (work_days, maintenance_days, remaining_work_days)\n        \n        elif op == 2:  # Remove train of model k\n            if train_state[k] is not None:\n                _, y_i, remaining_work_days = train_state[k]\n                if remaining_work_days <= 0:\n                    maintenance_count -= 1\n                train_state[k] = None\n        \n        # Update the state of all trains\n        for i in range(n):\n            if train_state[i] is not None:\n                x_i, y_i, remaining_work_days = train_state[i]\n                \n                if remaining_work_days > 0:\n                    remaining_work_days -= 1\n                else:\n                    remaining_work_days = -1  # In maintenance\n                    if remaining_work_days == -1:\n                        maintenance_count += 1\n                    remaining_work_days -= 1\n                \n                if remaining_work_days == -y_i:\n                    remaining_work_days = x_i\n                    maintenance_count -= 1\n                \n                train_state[i] = (x_i, y_i, remaining_work_days)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the work (x_i) and maintenance (y_i) periods for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days and track their maintenance status.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status of each train model (whether it is present and its current cycle position).\",\n        \"For each day, perform the operation specified (add or remove a train) and update the status of the trains accordingly.\",\n        \"Calculate the number of trains in maintenance for each day based on their current cycle position.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, after updating the train statuses, determine how many trains are in the maintenance phase.\",\n        \"Print the result for each day.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data about train models and daily operations.\",\n    \"Initialize data structures to track the status of each train model.\",\n    \"Iterate over each day, updating the status of trains based on the operations (add or remove) and their work/maintenance cycles.\",\n    \"For each day, calculate and store the number of trains in maintenance.\",\n    \"Output the stored results for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models': Refers to different types of trains, each with unique work and maintenance cycles.\n    'maintenance': The period during which a train is not operational and is being serviced.\n    Explanation: The requirement involves tracking the status of trains (whether they are in maintenance or operational) based on their model-specific cycles.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': Indicates that there can be zero or one train of each model at any time.\n    'x_i days', 'y_i days': Specifies the duration of work and maintenance periods for each train model.\n    Explanation: These phrases define the constraints and durations for train operations and maintenance, which are crucial for simulating the train status over the days.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for simulating train addition/removal and updating their status should be considered simultaneously. Specifically, the operations for each day (add or remove) and the update of train status should be handled in a single code block to ensure accurate tracking of train cycles.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: Only one train is added and it starts working immediately, so no train is in maintenance.\n\n    Input: 2 2\n           1 1\n           1 1\n           1 1\n           1 2\n    Output: 0\n            0\n    Explanation: Both trains are added and start working immediately, so no train is in maintenance.\n\n    Input: 2 3\n           1 1\n           1 1\n           1 1\n           2 1\n           1 1\n    Output: 0\n            0\n            0\n    Explanation: Train 1 is added, then removed, and added again, but it starts working immediately each time, so no train is in maintenance.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where trains are added and removed in quick succession, ensuring the maintenance status is accurately tracked.\n    ```python\n    # Initialize a dictionary to track train status\n    train_status = {i: {'present': False, 'cycle_position': 0} for i in range(1, n+1)}\n\n    # Iterate over each day\n    for", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize train status\n    train_status = {i: {'present': False, 'cycle_position': 0} for i in range(1, n+1)}\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        x_i, y_i = work_maintenance[k-1]\n        \n        if op == 1:  # Add train\n            train_status[k]['present'] = True\n            train_status[k]['cycle_position'] = 0\n        elif op == 2:  # Remove train\n            train_status[k]['present'] = False\n        \n        # Calculate maintenance trains\n        count_in_maintenance = 0\n        for i in range(1, n+1):\n            if train_status[i]['present']:\n                cycle_position = train_status[i]['cycle_position']\n                if cycle_position >= x_i:\n                    count_in_maintenance += 1\n                train_status[i]['cycle_position'] = (cycle_position + 1) % (x_i + y_i)\n        \n        maintenance_count[day] = count_in_maintenance\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 100)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize train status\n    train_status = {i: {'present': False, 'cycle_position': 0} for i in range(1, n+1)}\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        x_i, y_i = work_maintenance[k-1]\n        \n        if op == 1:  # Add train\n            train_status[k]['present'] = True\n            train_status[k]['cycle_position'] = 0\n        elif op == 2:  # Remove train\n            train_status[k]['present'] = False\n        \n        # Calculate maintenance trains\n        count_in_maintenance = 0\n        for i in range(1, n+1):\n            if train_status[i]['present']:\n                cycle_position = train_status[i]['cycle_position']\n                if cycle_position >= x_i:\n                    count_in_maintenance += 1\n                train_status[i]['cycle_position'] = (cycle_position + 1) % (x_i + y_i)\n        \n        maintenance_count[day] = count_in_maintenance\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), and the list of train model specifications (x_i, y_i). Also, extract the list of operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the x_i and y_i values for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over m days, keeping track of their maintenance cycles.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current state of each train model (whether it is present and its current cycle).\",\n        \"For each day, perform the operation specified (add or remove a train) and update the state of the train model accordingly.\",\n        \"Calculate the number of trains in maintenance for each day based on their current cycle.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each of the m days.\",\n      \"steps\": [\n        \"For each day, after performing the operation, determine the number of trains in maintenance.\",\n        \"Print the result for each day.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Initialize data structures to track train states and cycles.\",\n    \"Iterate over each day, updating train states based on operations.\",\n    \"Calculate and output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models', 'maintenance cycle'\n    Explanation: The requirement involves managing different train models, each with a specific cycle of working and maintenance days. The core task is to track these cycles and determine how many trains are in maintenance on each day.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': This means that there can be zero or one train of each model in the department at any time.\n    'x_i days', 'y_i days': These specify the duration of the working and maintenance periods for each train model, respectively.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to updating train states and calculating maintenance should be implemented simultaneously. Specifically:\n    - \"For each day, perform the operation specified (add or remove a train) and update the state of the train model accordingly.\"\n    - \"Calculate the number of trains in maintenance for each day based on their current cycle.\"\n    These can be combined in a loop that processes each day's operation and immediately calculates the maintenance count.\n\n# [edge case]\n    1. Input: 1 1\\n1 1\\n1 1\\nOutput: 0\n       Explanation: Only one train is added and it starts working, so no train is in maintenance.\n    2. Input: 1 2\\n1 1\\n1 1\\n2 1\\nOutput: 0\\n0\n       Explanation: A train is added and then removed, never entering maintenance.\n    3. Input: 2 3\\n1 1\\n1 1\\n1 1\\n1 2\\n2 1\\nOutput: 0\\n0\\n0\n       Explanation: Two trains are added but both start working, and one is removed before entering maintenance.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where trains are added and removed without entering maintenance.\n    - Ensure that the maintenance cycle is only considered if a train is present and has completed its working period.\n    - Example code snippet:\n      ```python\n      if op == 1:  # Add train\n          # Initialize train state and cycle\n      elif op == 2:  # Remove train\n          # Remove train and ensure it's not counted in maintenance\n      # Calculate maintenance count based on current states\n      ```\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_specs = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_specs.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State of each train model: (is_present, current_day_in_cycle)\n    train_state = [(False, 0) for _ in range(n)]\n    \n    # Result for each day\n    result = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_state[k] = (True, 0)\n        \n        elif op == 2:  # Remove train\n            train_state[k] = (False, 0)\n        \n        # Calculate number of trains in maintenance\n        maintenance_count = 0\n        for i in range(n):\n            is_present, current_day_in_cycle = train_state[i]\n            if is_present:\n                x_i, y_i = train_specs[i]\n                # Calculate the current phase in the cycle\n                cycle_length = x_i + y_i\n                day_in_cycle = current_day_in_cycle % cycle_length\n                if day_in_cycle >= x_i:\n                    maintenance_count += 1\n                # Update the day in cycle for the next day\n                train_state[i] = (is_present, current_day_in_cycle + 1)\n        \n        result.append(maintenance_count)\n    \n    for count in result:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"output\": \"A structured representation of the input data, including train models and daily operations.\"\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days, keeping track of their work and maintenance cycles.\",\n      \"output\": \"A data structure that maintains the current state of each train model (whether it is working or in maintenance) for each day.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day based on the current state of all train models.\",\n      \"output\": \"A list of integers representing the number of trains in maintenance for each day.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, m, the work and maintenance periods for each train model, and the daily operations.\",\n    \"Initialize a data structure to keep track of the state of each train model (e.g., a dictionary with model indices as keys).\",\n    \"Iterate over each day and perform the following steps:\",\n    \"  - If the operation is to add a train (op=1), update the state of the train model to indicate it is working and calculate when it will next enter maintenance.\",\n    \"  - If the operation is to remove a train (op=2), update the state to remove the train from the department.\",\n    \"  - For each train model, check if it is in maintenance on the current day and count the number of trains in maintenance.\",\n    \"Store the count of trains in maintenance for each day in a list.\",\n    \"Output the list of maintenance counts, one per line.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'maintenance'\n    Explanation: In the context of the requirement, maintenance refers to the period during which a train is not operational and is being serviced. The task is to calculate how many trains are in this state each day.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': This means that there can be zero or one train of each model at any given time.\n    'works for x_i days': This indicates the duration a train is operational before entering maintenance.\n    'in maintenance for y_i days': This indicates the duration a train is in maintenance before it becomes operational again.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for adding and removing trains should be considered simultaneously within the daily iteration loop. Specifically:\n    - When a train is added (op=1), its state should be updated to working, and the next maintenance period should be calculated.\n    - When a train is removed (op=2), its state should be updated to reflect its removal.\n    These operations can be handled within a single loop that iterates over each day, checking and updating the state of each train model.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: On the first day, a train is added and is working, so no train is in maintenance.\n\n    Input: 1 2\n           1 1\n           1 1\n           2 1\n    Output: 0\n            0\n    Explanation: On the first day, a train is added and is working. On the second day, the train is removed, so no train is in maintenance.\n\n    Input: 2 3\n           1 1\n           1 1\n           1 1\n           1 2\n           2 1\n    Output: 0\n            0\n            0\n    Explanation: On the first day, a train of model 1 is added and is working. On the second day, a train of model 2 is added and is working. On the third day, the train of model 1 is removed, so no train is in maintenance.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of updating the state of trains and counting those in", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    work_maintenance = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: None if not present, otherwise (start_day, cycle_day)\n    train_state = [None] * n\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            x_i, y_i = work_maintenance[k]\n            train_state[k] = (day, x_i + y_i)\n        \n        elif op == 2:  # Remove train\n            train_state[k] = None\n        \n        # Calculate maintenance count for the current day\n        count = 0\n        for model in range(n):\n            if train_state[model] is not None:\n                start_day, cycle_day = train_state[model]\n                x_i, y_i = work_maintenance[model]\n                \n                # Calculate the number of days since the train was added\n                days_since_added = day - start_day\n                \n                # Determine if the train is in maintenance\n                if days_since_added >= x_i:\n                    # Calculate the position in the cycle\n                    cycle_position = days_since_added % cycle_day\n                    if cycle_position >= x_i:\n                        count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 107)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    work_maintenance = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: None if not present, otherwise (start_day, cycle_day)\n    train_state = [None] * n\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            x_i, y_i = work_maintenance[k]\n            train_state[k] = (day, x_i + y_i)\n        \n        elif op == 2:  # Remove train\n            train_state[k] = None\n        \n        # Calculate maintenance count for the current day\n        count = 0\n        for model in range(n):\n            if train_state[model] is not None:\n                start_day, cycle_day = train_state[model]\n                x_i, y_i = work_maintenance[model]\n                \n                # Calculate the number of days since the train was added\n                days_since_added = day - start_day\n                \n                # Determine if the train is in maintenance\n                if days_since_added >= x_i:\n                    # Calculate the position in the cycle\n                    cycle_position = days_since_added % cycle_day\n                    if cycle_position >= x_i:\n                        count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models, number of days, and the operation details for each day.\",\n      \"steps\": [\n        \"Read the first line to get integers n (number of train models) and m (number of days).\",\n        \"Read the next n lines to get the working and maintenance periods (x_i, y_i) for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day, where op indicates adding or removing a train of model k.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the daily operations to track the status of trains and calculate the number of trains in maintenance each day.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status of each train model (whether it is present and its current cycle day).\",\n        \"Iterate over each day and perform the operation specified (add or remove a train).\",\n        \"For each train model that is present, update its cycle day and determine if it is in maintenance.\",\n        \"Count the number of trains in maintenance for each day and store the result.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, output the count of trains in maintenance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary information about train models and daily operations.\",\n    \"Initialize data structures to track the status of each train model.\",\n    \"Simulate the operations for each day, updating train statuses and counting those in maintenance.\",\n    \"Output the maintenance count for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models', 'maintenance', 'operation'\n    Explanation: The requirement involves managing different train models, tracking their maintenance cycles, and performing operations (add/remove) on them over a series of days.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': This means that there can be zero or one train of each model at any time.\n    'x_i days', 'y_i days': These represent the working and maintenance periods for each train model, respectively.\n    '1 \u2264 n,m \u2264 2 \u22c5 10^5', '1 \u2264 x_i,y_i \u2264 10^9': These constraints indicate the maximum possible values for the number of train models, days, and the duration of working/maintenance periods.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to simulating daily operations and updating train statuses should be implemented simultaneously. Specifically:\n    - \"Iterate over each day and perform the operation specified (add or remove a train).\"\n    - \"For each train model that is present, update its cycle day and determine if it is in maintenance.\"\n    These steps can be combined in a loop that processes each day's operations and updates the status of trains accordingly.\n\n# [edge case]\n    1. Input: 1 1\\n1 1\\n1 1\\n\n       Output: 0\n       Explanation: Only one train is added and it starts working, so no train is in maintenance.\n    2. Input: 1 2\\n1 1\\n1 1\\n2 1\\n\n       Output: 0\\n0\n       Explanation: A train is added and then removed the next day, so no train is in maintenance on either day.\n    3. Input: 2 3\\n1 1\\n1 1\\n1 1\\n1 2\\n2 1\\n\n       Output: 0\\n0\\n0\n       Explanation: Two trains are added on consecutive days, and one is removed on the third day. No train enters maintenance.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where trains are added and removed on the same day or where the maintenance cycle is very short.\n    ```python\n    # Example code snippet to handle edge cases\n    if op == 1:  # Add train\n        if model_status[k] is None:\n            model_status", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    # Read the working and maintenance periods for each train model\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_cycles.append((x_i, y_i))\n    \n    # Initialize the status of each train model\n    model_status = [None] * (n + 1)  # None means no train of this model is present\n    \n    # Prepare to store the results\n    results = []\n    \n    # Process each day's operation\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k - 1]\n            model_status[k] = (0, x_i, y_i)  # (current_day_in_cycle, work_days, maintenance_days)\n        elif op == 2:  # Remove train of model k\n            model_status[k] = None\n        \n        # Count trains in maintenance\n        maintenance_count = 0\n        for status in model_status:\n            if status is not None:\n                current_day_in_cycle, work_days, maintenance_days = status\n                # Check if the train is in maintenance\n                if current_day_in_cycle >= work_days:\n                    maintenance_count += 1\n                # Update the cycle day\n                current_day_in_cycle = (current_day_in_cycle + 1) % (work_days + maintenance_days)\n                # Update the status\n                model_status[model_status.index(status)] = (current_day_in_cycle, work_days, maintenance_days)\n        \n        # Store the result for the current day\n        results.append(maintenance_count)\n    \n    # Output the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the work (x_i) and maintenance (y_i) periods for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days and track the maintenance status of each train model.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status (working or maintenance) of each train model.\",\n        \"For each day, perform the operation specified (add or remove a train) and update the status of the train models accordingly.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, after performing the operation, count the number of trains currently in maintenance.\",\n        \"Store the count for each day in a list.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results.\",\n      \"steps\": [\n        \"Print the number of trains in maintenance for each of the m days.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Initialize data structures to track train statuses.\",\n    \"Iterate over each day, updating train statuses based on operations.\",\n    \"Count and record the number of trains in maintenance each day.\",\n    \"Output the recorded maintenance counts.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'maintenance'\n    Explanation: In the context of the requirement, maintenance refers to the period during which a train is not operational and is being serviced. The task is to calculate how many trains are in this state each day.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': This means that there can be zero or one train of each model at any given time.\n    'works for x_i days': This indicates the duration a train is operational before going into maintenance.\n    'in maintenance for y_i days': This indicates the duration a train is in maintenance before becoming operational again.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to simulating train operations and calculating maintenance status should be implemented simultaneously. Specifically, updating the status of train models and counting the number of trains in maintenance should occur in the same loop over the days.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: Only one train is added and it is operational on the first day, so no train is in maintenance.\n\n    Input: 2 2\n           1 1\n           1 1\n           1 1\n           1 2\n    Output: 0\n            1\n    Explanation: On the first day, both trains are operational. On the second day, the first train goes into maintenance.\n\n    Input: 3 3\n           1 1\n           1 1\n           1 1\n           1 1\n           1 2\n           1 3\n    Output: 0\n            1\n            2\n    Explanation: On the first day, all trains are operational. On the second day, the first train goes into maintenance. On the third day, the first and second trains are in maintenance.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling the edge case:\n    ```python\n    def calculate_maintenance(n, m, train_periods, operations):\n        train_status = [0] * n  # 0 for working, 1 for maintenance\n        maintenance_count = [0] * m\n        \n        for day in range(m):\n            op, k = operations[day]\n            if op == 1", "Round_0": {"code": "def calculate_maintenance(n, m, train_periods, operations):\n    # Initialize the status of each train model\n    train_status = [None] * n  # None means no train, otherwise it stores the day it was added\n    maintenance_count = [0] * m\n    \n    # Iterate over each day and perform operations\n    for day in range(m):\n        op, k = operations[day]\n        k -= 1  # Convert to zero-based index\n        \n        if op == 1:  # Add train of model k\n            train_status[k] = day\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance\n        count = 0\n        for i in range(n):\n            if train_status[i] is not None:\n                x_i, y_i = train_periods[i]\n                days_since_added = day - train_status[i]\n                cycle_length = x_i + y_i\n                if days_since_added >= x_i and (days_since_added - x_i) % cycle_length < y_i:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    return maintenance_count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    train_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1])\n        operations.append((op, k))\n        index += 2\n    \n    maintenance_count = calculate_maintenance(n, m, train_periods, operations)\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 95)"}, "Round_1": {"code": "def calculate_maintenance(n, m, train_periods, operations):\n    # Initialize the status of each train model\n    train_status = [None] * n  # None means no train, otherwise it stores the day it was added\n    maintenance_count = [0] * m\n    \n    # Iterate over each day and perform operations\n    for day in range(m):\n        op, k = operations[day]\n        k -= 1  # Convert to zero-based index\n        \n        if op == 1:  # Add train of model k\n            train_status[k] = day\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance\n        count = 0\n        for i in range(n):\n            if train_status[i] is not None:\n                x_i, y_i = train_periods[i]\n                days_since_added = day - train_status[i]\n                cycle_length = x_i + y_i\n                if days_since_added >= x_i and (days_since_added - x_i) % cycle_length < y_i:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    return maintenance_count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    train_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1])\n        operations.append((op, k))\n        index += 2\n    \n    maintenance_count = calculate_maintenance(n, m, train_periods, operations)\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"output\": \"A structured representation of the input data, including train models' work and maintenance periods and daily operations.\"\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days, keeping track of which trains are currently in the department and their current state (working or in maintenance).\",\n      \"output\": \"A data structure that maintains the current state of each train model in the department for each day.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day based on the current state of trains in the department.\",\n      \"output\": \"A list of integers representing the number of trains in maintenance for each day.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract n, m, the work and maintenance periods for each train model, and the daily operations.\",\n    \"Initialize a data structure to keep track of the current state of each train model in the department.\",\n    \"Iterate over each day and perform the following steps:\",\n    \"  - If a train is added, update the data structure to reflect its addition and set its initial state to working.\",\n    \"  - If a train is removed, update the data structure to reflect its removal.\",\n    \"  - For each train currently in the department, update its state (working or in maintenance) based on its work and maintenance periods.\",\n    \"  - Count the number of trains in maintenance and store the result for the current day.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models', 'work and maintenance periods', 'operations'\n    Explanation: The requirement involves managing different train models, each with specific work and maintenance cycles. Operations refer to adding or removing trains from the department.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': This means that there can be zero or one train of each model in the department at any time.\n    '1 \u2264 n,m \u2264 2 \u22c5 10^5': This indicates the constraints on the number of train models and days, which affects the algorithm's efficiency.\n    '1 \u2264 x_i,y_i \u2264 10^9': This specifies the range for work and maintenance periods, indicating potentially large numbers to handle.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for adding and removing trains should be implemented simultaneously within the daily iteration loop. Specifically:\n    - \"If a train is added, update the data structure to reflect its addition and set its initial state to working.\"\n    - \"If a train is removed, update the data structure to reflect its removal.\"\n    These steps should be handled in an if-else block to ensure the correct operation is applied based on the input command for the day.\n\n# [edge case]\n    Edge Case 1: n = 1, m = 1, operations = [(1, 1)], x_1 = 1, y_1 = 1\n    Expected Output: 0\n    Explanation: Only one train is added and it starts working immediately, so no train is in maintenance.\n\n    Edge Case 2: n = 1, m = 2, operations = [(1, 1), (2, 1)], x_1 = 1, y_1 = 1\n    Expected Output: 0, 0\n    Explanation: The train is added and then removed the next day, never entering maintenance.\n\n    Edge Case 3: n = 2, m = 3, operations = [(1, 1), (1, 2), (2, 1)], x_1 = 1, y_1 = 1, x_2 = 1, y_2 = 1\n    Expected Output: 0, 1, 0\n    Explanation: The first train is added and starts working, the second train is added and enters maintenance, then the first train is removed.\n\n# [extra", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    work_maintenance_periods = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to zero-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: None if not present, otherwise a tuple (days_in_current_state, is_in_maintenance)\n    train_states = [None] * n\n    maintenance_count = 0\n    \n    results = []\n    \n    for op, k in operations:\n        if op == 1:  # Add train\n            x_i, y_i = work_maintenance_periods[k]\n            train_states[k] = (1, False)  # Start working\n        elif op == 2:  # Remove train\n            if train_states[k][1]:  # If it was in maintenance, decrease the count\n                maintenance_count -= 1\n            train_states[k] = None\n        \n        # Update states for all trains\n        for i in range(n):\n            if train_states[i] is not None:\n                days, is_in_maintenance = train_states[i]\n                x_i, y_i = work_maintenance_periods[i]\n                \n                if is_in_maintenance:\n                    if days == y_i:\n                        train_states[i] = (1, False)  # Switch to working\n                        maintenance_count -= 1\n                    else:\n                        train_states[i] = (days + 1, True)\n                else:\n                    if days == x_i:\n                        train_states[i] = (1, True)  # Switch to maintenance\n                        maintenance_count += 1\n                    else:\n                        train_states[i] = (days + 1, False)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the work (x_i) and maintenance (y_i) periods for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days and track their maintenance status.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status of each train model (whether it is present and its current cycle position).\",\n        \"For each day, perform the operation specified (add or remove a train) and update the status of the trains accordingly.\",\n        \"Calculate the number of trains in maintenance for each day based on their current cycle position.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, after updating the train statuses, determine how many trains are in the maintenance phase.\",\n        \"Print the result for each day.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data about train models and daily operations.\",\n    \"Initialize data structures to track the status of each train model.\",\n    \"Iterate over each day, updating the status of trains based on the operations (add or remove) and their work/maintenance cycles.\",\n    \"For each day, calculate and store the number of trains in maintenance.\",\n    \"Output the stored results for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models': refers to different types of trains, each with unique work and maintenance cycles.\n    'maintenance': refers to the period when a train is not operational and is being serviced.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': means that there can be zero or one train of each model at any time.\n    'x_i days': refers to the number of days a train works before going into maintenance.\n    'y_i days': refers to the number of days a train is in maintenance before it resumes work.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for simulating the addition and removal of trains and tracking their maintenance status should be implemented simultaneously. Specifically, updating the status of trains and calculating the number of trains in maintenance should occur in the same loop for each day.\n\n# [edge case] \n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: Only one train is added and it is working, so no train is in maintenance.\n\n    Input: 2 2\n           1 1\n           1 1\n           1 1\n           1 2\n    Output: 0\n            0\n    Explanation: Both trains are added and working, so no train is in maintenance.\n\n    Input: 2 3\n           1 1\n           1 1\n           1 1\n           2 1\n           1 1\n    Output: 0\n            0\n            0\n    Explanation: Train 1 is added and working, then removed, and added again, always working, so no train is in maintenance.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of updating train status and calculating maintenance trains should handle these cases correctly.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize the status of each train model\n    train_status = [None] * n  # None means no train of this model is present\n    \n    # Result list to store the number of trains in maintenance each day\n    result = []\n    \n    # Simulate each day\n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance[k]\n            train_status[k] = (day, x_i, y_i)  # Store the day it was added and its cycle lengths\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance\n        maintenance_count = 0\n        for status in train_status:\n            if status is not None:\n                added_day, x_i, y_i = status\n                days_since_added = day - added_day\n                cycle_length = x_i + y_i\n                cycle_position = days_since_added % cycle_length\n                if cycle_position >= x_i:\n                    maintenance_count += 1\n        \n        result.append(maintenance_count)\n    \n    # Print the result for each day\n    for count in result:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), and the list of train operations.\",\n      \"details\": \"Read the first line to get n and m. Read the next n lines to get the x_i and y_i values for each train model. Read the next m lines to get the operations (op, k) for each day.\"\n    },\n    {\n      \"description\": \"Track the state of each train model over the days.\",\n      \"details\": \"Maintain a data structure to keep track of whether a train of each model is present and its current state (working or maintenance).\"\n    },\n    {\n      \"description\": \"Simulate the daily operations and update the train states accordingly.\",\n      \"details\": \"For each day, based on the operation (add or remove), update the state of the train model. If a train is added, start its cycle of working and maintenance. If a train is removed, ensure it is not counted as in maintenance.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"details\": \"For each day, count the number of trains that are in the maintenance state and store the result.\"\n    },\n    {\n      \"description\": \"Output the results for each day.\",\n      \"details\": \"Print the number of trains in maintenance for each of the m days.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize data structures to store train model states and maintenance counts.\",\n    \"Parse the input to extract train model details and daily operations.\",\n    \"Iterate over each day and perform the operation specified (add or remove train).\",\n    \"For each train addition, start its working and maintenance cycle.\",\n    \"For each train removal, update the state to ensure it is not counted as in maintenance.\",\n    \"Count and record the number of trains in maintenance for each day.\",\n    \"Output the maintenance count for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models': Refers to different types of trains, each with unique working and maintenance cycles.\n    'maintenance': The period during which a train is not operational and is being serviced.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': Indicates that there can be zero or one train of each model at any time.\n    'x_i days', 'y_i days': Specifies the duration of working and maintenance periods for each train model.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to adding and removing trains should be considered simultaneously. Specifically, when a train is added, its working and maintenance cycle should start immediately, and when a train is removed, it should be ensured that it is not counted as in maintenance. This can be implemented using a data structure that tracks the state of each train model and updates it based on daily operations.\n\n# [edge case]\n    Input: 1 2\n           1 1\n           1 1\n           2 1\n    Output: 0\n            0\n    Explanation: On the first day, a train is added and starts working, so no train is in maintenance. On the second day, the train is removed, so again no train is in maintenance.\n\n    Input: 2 3\n           1 1\n           1 1\n           1 1\n           1 2\n           2 1\n    Output: 0\n            0\n            0\n    Explanation: On the first day, a train of model 1 is added and starts working. On the second day, a train of model 2 is added and starts working. On the third day, the train of model 1 is removed, so no train is in maintenance.\n\n    Input: 3 5\n           2 2\n           1 1\n           1 1\n           1 1\n           1 2\n           1 3\n           2 2\n           2 3\n    Output: 0\n            0\n            0\n            0\n            0\n    Explanation: On the first day, a train of model 1 is added and starts working. On the second day, a train of model 2 is added and starts working. On the third day, a train of model 3 is", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking\n    train_states = [None] * n  # None means no train, otherwise (start_day, cycle_position)\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            x_i, y_i = train_cycles[k]\n            train_states[k] = (day, 0)  # Start at day `day` with cycle position 0 (working)\n        \n        elif op == 2:  # Remove train\n            train_states[k] = None\n        \n        # Calculate maintenance count for the current day\n        count_in_maintenance = 0\n        for i in range(n):\n            if train_states[i] is not None:\n                start_day, cycle_position = train_states[i]\n                x_i, y_i = train_cycles[i]\n                \n                # Calculate the number of days since the train was added\n                days_since_added = day - start_day\n                \n                # Calculate the current cycle position\n                total_cycle = x_i + y_i\n                current_cycle_day = days_since_added % total_cycle\n                \n                # Check if the train is in maintenance\n                if current_cycle_day >= x_i:\n                    count_in_maintenance += 1\n        \n        maintenance_count[day] = count_in_maintenance\n    \n    # Output the results\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the work (x_i) and maintenance (y_i) periods for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days and track their maintenance status.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status of each train model (whether it is present and its current cycle position).\",\n        \"For each day, perform the operation specified (add or remove a train) and update the status of the trains accordingly.\",\n        \"Calculate the number of trains in maintenance for each day based on their current cycle position.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, after updating the train statuses, determine how many trains are in the maintenance phase.\",\n        \"Print the result for each day.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract all necessary data including train models, their work and maintenance periods, and daily operations.\",\n    \"Initialize a data structure to manage the state of each train model, including whether it is present and its current cycle position.\",\n    \"Iterate over each day, updating the state of the trains based on the operations (add or remove) and their respective cycles.\",\n    \"For each day, calculate the number of trains currently in maintenance and store the result.\",\n    \"Output the stored results for each day, representing the number of trains in maintenance.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models'\n    Explanation: Refers to different types of trains, each with specific work and maintenance cycles.\n\n    'work for x_i days', 'maintenance for y_i days'\n    Explanation: Each train model has a cycle of working for a specified number of days (x_i) followed by maintenance for another specified number of days (y_i).\n\n# [phrase showing quantity relationship]\n    'at most one train of each model'\n    Explanation: There can be no more than one train of each model in the department at any time.\n\n    '1 \u2264 n,m \u2264 2 \u22c5 10^5'\n    Explanation: The number of train models and days are both constrained to be between 1 and 200,000.\n\n    '1 \u2264 x_i,y_i \u2264 10^9'\n    Explanation: The work and maintenance periods for each train model are between 1 and 1 billion days.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan are well-structured and do not require simultaneous implementation. Each step logically follows from the previous one, ensuring that the train statuses are updated before calculating the maintenance count.\n\n# [edge case]\n    Edge Case 1: n = 1, m = 1, x_1 = 1, y_1 = 1, operations = [(1, 1)]\n    Expected Output: 0\n    Explanation: On the first day, a train is added and it is in the working phase, so no train is in maintenance.\n\n    Edge Case 2: n = 1, m = 2, x_1 = 1, y_1 = 1, operations = [(1, 1), (2, 1)]\n    Expected Output: 0, 0\n    Explanation: On the first day, the train is added and is working. On the second day, it is removed, so no train is in maintenance on either day.\n\n    Edge Case 3: n = 2, m = 3, x_1 = 1, y_1 = 1, x_2 = 2, y_2 = 2, operations = [(1, 1), (1, 2), (2, 1)]\n    Expected Output: 0, 0, 0\n    Explanation: On the first day, train 1 is added and is working. On the second day", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_cycles.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # Initialize train status\n    train_status = [None] * n  # None means no train of this model is present\n    \n    # Result list to store the number of trains in maintenance each day\n    result = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_cycles[k]\n            train_status[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate number of trains in maintenance\n        maintenance_count = 0\n        for status in train_status:\n            if status is not None:\n                added_day, x_i, y_i = status\n                cycle_length = x_i + y_i\n                days_since_added = day - added_day\n                \n                # Determine current cycle position\n                cycle_position = days_since_added % cycle_length\n                \n                # Check if in maintenance\n                if cycle_position >= x_i:\n                    maintenance_count += 1\n        \n        result.append(maintenance_count)\n    \n    # Print the result for each day\n    for count in result:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"output\": \"A structured representation of the input data, including train models and daily operations.\"\n    },\n    {\n      \"description\": \"Implement a data structure to track the state of each train model, including whether it is currently in operation or maintenance, and the remaining days in its current state.\",\n      \"output\": \"A data structure that can efficiently update and query the state of each train model.\"\n    },\n    {\n      \"description\": \"Simulate each day's operations, updating the state of the trains based on the operation (add or remove) and the current state of each train model.\",\n      \"output\": \"An updated state of all train models for each day.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day based on the current state of all train models.\",\n      \"output\": \"A list of integers representing the number of trains in maintenance for each day.\"\n    },\n    {\n      \"description\": \"Output the result for each day as specified in the requirement.\",\n      \"output\": \"Formatted output of the number of trains in maintenance for each day.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of train models, number of days, work and maintenance periods for each train model, and daily operations.\",\n    \"Initialize a data structure to track the state of each train model, including its current cycle (work or maintenance) and remaining days in that cycle.\",\n    \"Iterate over each day's operations:\",\n    \"  - If a train is added, set its initial state to 'working' and track its work and maintenance cycle.\",\n    \"  - If a train is removed, update the state to reflect its removal.\",\n    \"  - Update the state of all trains to reflect the passage of one day, transitioning trains between work and maintenance as needed.\",\n    \"Calculate the number of trains in maintenance for each day based on the current state of all train models.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models'\n    Explanation: Refers to different types of trains, each with specific work and maintenance cycles.\n\n    'work for x_i days' and 'maintenance for y_i days'\n    Explanation: Each train model has a cycle where it operates for a certain number of days (x_i) and then undergoes maintenance for another set of days (y_i).\n\n# [phrase showing quantity relationship]\n    'at most one train of each model'\n    Explanation: There can be no more than one train of each model in the department at any time.\n\n    '1 \u2264 n,m \u2264 2 \u22c5 10^5'\n    Explanation: The number of train models and days are both constrained to be between 1 and 200,000.\n\n    '1 \u2264 x_i,y_i \u2264 10^9'\n    Explanation: The work and maintenance periods for each train model are between 1 and 1 billion days.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to updating the state of trains and calculating the number of trains in maintenance should be implemented simultaneously. Specifically:\n    - \"Update the state of all trains to reflect the passage of one day, transitioning trains between work and maintenance as needed.\"\n    - \"Calculate the number of trains in maintenance for each day based on the current state of all train models.\"\n    These can be done in a single loop that processes each day's operations and updates the state of all trains.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: On the first day, a train is added and it is working, so no train is in maintenance.\n\n    Input: 1 2\n           1 1\n           1 1\n           2 1\n    Output: 0\n            0\n    Explanation: On the first day, a train is added and it is working. On the second day, the train is removed, so no train is in maintenance on either day.\n\n    Input: 2 3\n           1 1\n           1 1\n           1 1\n           1 2\n           2 1\n    Output: 0\n            0\n            0\n    Explanation: On the first day, a train of model 1 is added and it is working. On the second", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking for each train model\n    train_state = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance[k]\n            train_state[k] = (x_i, y_i, x_i)  # (work_days, maintenance_days, remaining_work_days)\n        \n        elif op == 2:  # Remove train of model k\n            if train_state[k] is not None:\n                _, y_i, remaining_work_days = train_state[k]\n                if remaining_work_days <= 0:\n                    maintenance_count -= 1\n                train_state[k] = None\n        \n        # Update the state of all trains\n        for i in range(n):\n            if train_state[i] is not None:\n                x_i, y_i, remaining_work_days = train_state[i]\n                \n                if remaining_work_days > 0:\n                    remaining_work_days -= 1\n                else:\n                    remaining_work_days = -1  # In maintenance\n                    if remaining_work_days == -1:\n                        maintenance_count += 1\n                    remaining_work_days -= 1\n                \n                if remaining_work_days == -y_i:\n                    remaining_work_days = x_i\n                    maintenance_count -= 1\n                \n                train_state[i] = (x_i, y_i, remaining_work_days)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, false, true, false, true, true, true, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 506, "prompt": "Kawasiro Nitori is excellent in engineering. Thus she has been appointed to help maintain trains.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment. At the beginning, there are no trains present in the department. At each of the following m days, one train will be added, or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive). Then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance in each day.\n\nOn a day a train is removed, it is not counted as in maintenance.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.", "examples": "\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.", "mutate_method": "expand_one2two", "save_node": false, "parent_index": 288}
