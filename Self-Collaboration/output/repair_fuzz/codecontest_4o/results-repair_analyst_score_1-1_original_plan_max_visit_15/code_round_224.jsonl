{"name": "1579_C. Ticks", "description": "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white.\n\nLet us denote the cell with coordinates i vertically and j horizontally by (i, j). The upper left cell will be referred to as (1, 1) and the lower right cell as (n, m).\n\nCasimir draws ticks of different sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: \n\n  1. First, the center cell (i, j) is painted black. \n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. \n  3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted. In particular, a tick consists of 2d + 1 black cells. \n\n\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "tags": ["greedy", "implementation"], "difficulty": 9, "id": 1579, "sample_io": [{"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n"]}], "test_list": [{"input": "1\n1 1 1\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 1\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 1\n.....\n", "output": ["YES\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n..*...\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 2\n.....\n", "output": ["YES\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n...*.....\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 0\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n.*...\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 4\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 2\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/./*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 1 2\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*../..*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n1 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n+...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n-+.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n**.......\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*.\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 0\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*/\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n.-**..*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n..//\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n/...*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 3\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/.*.\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n../..\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n/*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n.0..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.../.\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n./+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n..-...\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*.-.\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n//.*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./-.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+-.\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n.../..\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*./\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-+..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*..\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..*.\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n*..0\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n..*../\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n..*.\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*/.\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n/*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..).\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n2 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 1 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n....-\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n-/*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n/.*..\n", "output": ["NO\n"]}, {"input": "1\n1 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n...**\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*../.\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n..**\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n2 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n.*..\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....)\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+..*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*/*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*.*...*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n).*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*-.\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n.*.*\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n**..\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*-.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n-...*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...).\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n...-.*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}], "task_id": "codecontest/15", "repair_prompt": ["Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white. \n\nLet us denote the cell with coordinates i vertically and j horizontally by (i, j), where the upper left cell is (1, 1) and the lower right cell is (n, m). Casimir draws ticks of different sizes on the field, where a tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: \n\n1. First, the center cell (i, j) is painted black. \n2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black in a symmetrical pattern, so all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted; in particular, a tick consists of 2d + 1 black cells. \n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white.\n\nLet us denote the cell with coordinates i vertically and j horizontally by (i, j), where the upper left cell is (1, 1) and the lower right cell is (n, m). Casimir draws ticks of different sizes on the field. Each tick of size d (d > 0) with its center in cell (i, j) is drawn as follows:\n\n1. First, the center cell (i, j) is painted black.\n2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black in a symmetrical pattern. In such a pattern, all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted; in particular, a tick consists of 2d + 1 black cells.\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white. Let us denote the cell with coordinates i vertically and j horizontally by (i, j), where the upper left cell is (1, 1) and the lower right cell is (n, m). Casimir draws ticks of different sizes on the field, where a tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: First, the center cell (i, j) is painted black, and then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black in a symmetrical pattern, so all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted; in particular, a tick consists of 2d + 1 black cells. An already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3. <image> You are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks). Determine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to mark cells that can be part of a tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to check if it can be the center of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Determine the maximum possible size of the tick centered at (i, j)\n                max_d = min(i, j, m - j - 1)\n                if max_d >= k:\n                    # Check if a tick of size d can be formed\n                    d = k\n                    while d <= max_d:\n                        valid_tick = True\n                        for h in range(1, d + 1):\n                            if field[i - h][j - h] != '*' or field[i - h][j + h] != '*':\n                                valid_tick = False\n                                break\n                        if valid_tick:\n                            # Mark the cells as part of a valid tick\n                            for h in range(d + 1):\n                                marked[i - h][j - h] = True\n                                marked[i - h][j + h] = True\n                            break\n                        d += 1\n\n    # Check if all black cells are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to simulate drawing ticks\n    simulated_field = [['.' for _ in range(m)] for _ in range(n)]\n\n    # Iterate over each cell to find potential tick centers\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size at least k can be drawn\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, draw it on the simulated field\n                if d > k:\n                    for h in range(d):\n                        simulated_field[i - h][j - h] = '*'\n                        simulated_field[i - h][j + h] = '*'\n\n    # Compare the simulated field with the original field\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] != simulated_field[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(field, n, m, k):\n    # Create a copy of the field to mark cells that can be part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n    \n    # Iterate over each cell to check if it can be the center of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if this can be the center of a tick of size d >= k\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n                \n                # If the tick size is at least k, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n    \n    # Check if all '*' in the field are marked\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n        \n        if can_form_ticks(field, n, m, k):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a 2D list to keep track of which cells are part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to check for valid tick centers\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if the cell can be the center of a tick of size at least k\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Check if all '*' cells are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to mark cells that are part of valid ticks\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to check if it can be the center of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size at least k can be centered at (i, j)\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Check if all '*' in the field are part of a valid tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to mark cells that are part of valid ticks\n    marked = [[False] * m for _ in range(n)]\n\n    # Check for possible tick centers from bottom to top\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Determine the maximum size of the tick with center at (i, j)\n                d = 0\n                while (i - d >= 0 and j - d >= 0 and j + d < m and\n                       field[i - d][j - d] == '*' and field[i - d][j + d] == '*'):\n                    d += 1\n                d -= 1  # Adjust because the loop exits with d one step too far\n\n                # If the tick size is at least k, mark the cells\n                if d >= k:\n                    for h in range(d + 1):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Check if all '*' in the field are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_tick(field, n, m, k):\n    # Create a copy of the field to mark cells that are part of valid ticks\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate from bottom to top to ensure we can check for valid ticks\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if we can form a tick of size at least k with center at (i, j)\n                d = 0\n                while (i - d >= 0 and j - d >= 0 and j + d < m and\n                       field[i - d][j - d] == '*' and field[i - d][j + d] == '*'):\n                    d += 1\n                d -= 1  # Adjust d to the maximum valid size\n\n                if d >= k:\n                    # Mark the cells of the tick as part of a valid tick\n                    for h in range(d + 1):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Check if all '*' in the field are part of a valid tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_form_tick(field, n, m, k):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a boolean grid to mark cells that are part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to check if it can be the center of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if this cell can be the center of a tick of size at least k\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Check if all '*' cells are marked\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to mark valid tick cells\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to check if it can be the center of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size d >= k can be formed\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Validate the field pattern\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(field, n, m, k):\n    # Create a copy of the field to mark cells that can be part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell in the field\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if this cell can be the center of a tick of size d >= k\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Check if all '*' in the field are part of a valid tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(field, n, m, k)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to mark cells that can be part of a tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to check if it can be the center of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Determine the maximum possible size of the tick centered at (i, j)\n                max_d = min(i, j, m - j - 1)\n                if max_d >= k:\n                    # Check if a tick of size d can be formed\n                    d = k\n                    while d <= max_d:\n                        valid_tick = True\n                        for h in range(1, d + 1):\n                            if field[i - h][j - h] != '*' or field[i - h][j + h] != '*':\n                                valid_tick = False\n                                break\n                        if valid_tick:\n                            # Mark the cells as part of a valid tick\n                            for h in range(d + 1):\n                                marked[i - h][j - h] = True\n                                marked[i - h][j + h] = True\n                            break\n                        d += 1\n\n    # Check if all black cells are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, field dimensions, minimum tick size, and field patterns.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions n, m, and k.\",\n        \"Read the n lines representing the field pattern.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a tick of size d >= k can be drawn for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if the cell can be the center of a tick of size d >= k.\",\n        \"Verify the top-left and top-right diagonal cells for the tick size.\",\n        \"Ensure all required cells are black ('*') for a valid tick.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"If all black cells can be part of valid ticks, output 'YES'.\",\n        \"Otherwise, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and field data.\",\n    \"For each test case, iterate over the field to check for valid tick centers.\",\n    \"Validate tick formation by checking diagonal cells.\",\n    \"Output 'YES' if the field can be formed by valid ticks, otherwise 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tick': A tick is a pattern of black cells centered at a specific cell, extending diagonally in both directions. The size of the tick is determined by the number of cells extending diagonally from the center.\n    'size d': The size of the tick, which is the number of cells extending diagonally from the center. A tick of size d consists of 2d + 1 black cells.\n    'd \u2265 k': The minimum size of the tick that can be drawn, where k is the smallest allowable size.\n\n# [phrase showing quantity relationship]\n    'd > 0': Indicates that the size of the tick must be greater than zero, meaning no tick can be of size zero.\n    '2d + 1': Represents the total number of black cells in a tick of size d, including the center cell and the diagonal cells.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for checking if a cell can be the center of a tick and verifying the diagonal cells should be implemented simultaneously. This involves iterating over each cell and checking both diagonals in one code block to ensure the tick can be formed.\n\n# [edge case]\n    Case 1: A field with all cells black and k = 1\n    Input: 3 3 1\n           ***\n           ***\n           ***\n    Expected Output: YES\n    Explanation: Every cell can be the center of a tick of size 1, and all cells are black.\n\n    Case 2: A field with no black cells\n    Input: 3 3 1\n           ...\n           ...\n           ...\n    Expected Output: NO\n    Explanation: There are no black cells to form any tick.\n\n    Case 3: A field with isolated black cells\n    Input: 3 3 2\n           *..\n           .*.\n           ..*\n    Expected Output: NO\n    Explanation: No cell can be the center of a tick of size 2 due to isolation.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where isolated black cells or insufficient black cells prevent tick formation.\n    ```python\n    def can_form_ticks(n, m, k, field):\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    max_d = min(i, j, m - j - 1)\n                    if max_d < k:\n", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to mark cells that can be part of a tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to check if it can be the center of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Determine the maximum possible size of the tick centered at (i, j)\n                max_d = min(i, j, m - j - 1)\n                if max_d >= k:\n                    # Check if a tick of size d can be formed\n                    d = k\n                    while d <= max_d:\n                        valid_tick = True\n                        for h in range(1, d + 1):\n                            if field[i - h][j - h] != '*' or field[i - h][j + h] != '*':\n                                valid_tick = False\n                                break\n                        if valid_tick:\n                            # Mark the cells as part of a valid tick\n                            for h in range(d + 1):\n                                marked[i - h][j - h] = True\n                                marked[i - h][j + h] = True\n                            break\n                        d += 1\n\n    # Check if all black cells are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the dimensions of the field, the minimum tick size, and the field's configuration.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases with their respective parameters.\"\n    },\n    {\n      \"description\": \"For each test case, identify potential tick centers by iterating over each cell in the field and checking if it can be the center of a tick of size at least k.\",\n      \"output\": \"A list of potential tick centers for each test case.\"\n    },\n    {\n      \"description\": \"For each potential tick center, verify if a tick of size at least k can be drawn by checking the required cells in the top-left and top-right diagonals.\",\n      \"output\": \"A boolean value indicating whether a valid tick can be drawn for each potential center.\"\n    },\n    {\n      \"description\": \"Simulate the drawing of valid ticks on a copy of the field to ensure all '*' cells can be accounted for by ticks of size at least k.\",\n      \"output\": \"A modified field representation showing the result of drawing all possible ticks.\"\n    },\n    {\n      \"description\": \"Compare the modified field with the original field to determine if the original field can be obtained by drawing ticks of size at least k.\",\n      \"output\": \"A result for each test case, either 'YES' if the field can be obtained or 'NO' otherwise.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, iterate over each cell in the field to identify potential tick centers.\",\n    \"For each potential tick center, check if a tick of size at least k can be drawn by verifying the required cells in the diagonals.\",\n    \"Simulate the drawing of valid ticks on a copy of the field.\",\n    \"Compare the modified field with the original field to determine if the field can be obtained by drawing ticks.\",\n    \"Output 'YES' or 'NO' for each test case based on the comparison.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tick': A pattern of black cells centered at a specific cell, extending diagonally in a symmetrical manner.\n    'size d': The number of cells extending diagonally from the center, resulting in a total of 2d + 1 black cells.\n    'field': The grid of cells, initially all white, where ticks are drawn.\n\n# [phrase showing quantity relationship]\n    'd > 0': Indicates that the size of a tick must be greater than zero, meaning ticks cannot be of size zero.\n    'd \u2265 k': Specifies that the size of each tick must be at least k, meaning the tick size must be greater than or equal to k.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    Steps 2 and 3 should be considered simultaneously. When identifying potential tick centers, we should immediately verify if a tick of size at least k can be drawn. This can be implemented using nested loops where the outer loop iterates over each cell and the inner loop checks the diagonals for valid tick formation.\n\n# [edge case]\n    Case 1: n = 1, m = 1, k = 1, field = ['*']\n    Expected output: NO\n    Explanation: A single cell cannot form a tick of size 1 because it requires additional cells diagonally.\n\n    Case 2: n = 3, m = 3, k = 2, field = ['*.*', '.*.', '*.*']\n    Expected output: NO\n    Explanation: The tick size required is 2, but the field configuration does not allow for any tick of size 2.\n\n    Case 3: n = 4, m = 4, k = 1, field = ['****', '****', '****', '****']\n    Expected output: YES\n    Explanation: Each cell can be the center of a tick of size 1, covering the entire field.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    ```python\n    def can_form_ticks(n, m, k, field):\n        for i in range(k, n):\n            for j in range(k, m - k):\n                if field[i][j] == '*':\n                    valid_tick = True\n                    for d in range(1, k + 1):\n                        if field[i - d][j - d] != '*' or field[i - d][j", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to simulate drawing ticks\n    simulated_field = [['.' for _ in range(m)] for _ in range(n)]\n\n    # Iterate over each cell to find potential tick centers\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size at least k can be drawn\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, draw it on the simulated field\n                if d > k:\n                    for h in range(d):\n                        simulated_field[i - h][j - h] = '*'\n                        simulated_field[i - h][j + h] = '*'\n\n    # Compare the simulated field with the original field\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] != simulated_field[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, field dimensions, minimum tick size, and field patterns.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions n, m, and k.\",\n        \"Read the n lines representing the field pattern.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a tick of size d >= k can be drawn for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if the cell can be the center of a tick of size d >= k.\",\n        \"Verify if the tick can be drawn without violating the field pattern.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output 'YES' if the field can be obtained by drawing ticks of size d >= k, otherwise output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the necessary information for each test case.\",\n    \"For each test case, iterate over the field to check if ticks of size d >= k can be drawn.\",\n    \"For each cell, check if it can be the center of a valid tick and verify the tick pattern.\",\n    \"Output 'YES' or 'NO' based on whether the field can be obtained by drawing the required ticks.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tick'\n    Explanation: A tick is a pattern of black cells centered at a specific cell, extending diagonally in both top-left and top-right directions. The size of a tick is defined by the number of cells extending from the center in each diagonal direction.\n\n    'd \u2265 k'\n    Explanation: The size of each tick must be at least k, meaning the tick must extend at least k cells diagonally from its center.\n\n# [phrase showing quantity relationship]\n    'at least k': This means the size of the tick (d) must be greater than or equal to k. In code, this can be implemented by checking if d >= k for each potential tick center.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but within the second subproblem, the steps \"Check if the cell can be the center of a tick of size d >= k\" and \"Verify if the tick can be drawn without violating the field pattern\" should be implemented simultaneously. This can be done by iterating over each cell and immediately checking if it can be the center of a valid tick.\n\n# [edge case]\n    1. A field with no '*' characters at all, e.g., a 3x3 field with all '.' characters.\n       Expected output: YES\n       Explanation: Since there are no '*' characters, no ticks are needed, and the field is trivially valid.\n\n    2. A field with a single '*' character, e.g., a 1x1 field with a single '*'.\n       Expected output: NO\n       Explanation: A single '*' cannot form a tick of size d \u2265 k (where k > 0).\n\n    3. A field where all '*' characters are isolated and cannot form a valid tick, e.g., a 3x3 field with '*' characters only on the perimeter.\n       Expected output: NO\n       Explanation: None of the '*' characters can be the center of a tick of size d \u2265 k.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where no ticks are needed or where isolated '*' characters cannot form valid ticks.\n    ```python\n    def can_form_ticks(field, n, m, k):\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if this can be the center of a tick of size d", "Round_0": {"code": "def can_form_ticks(field, n, m, k):\n    # Create a copy of the field to mark cells that can be part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n    \n    # Iterate over each cell to check if it can be the center of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if this can be the center of a tick of size d >= k\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n                \n                # If the tick size is at least k, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n    \n    # Check if all '*' in the field are marked\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n        \n        if can_form_ticks(field, n, m, k):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, field dimensions, minimum tick size, and field patterns.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n, m, and k representing the field dimensions and minimum tick size.\",\n        \"Read the next n lines to capture the field pattern as a list of strings.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a given field pattern can be obtained by drawing ticks of size at least k.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if the cell can be the center of a tick of size at least k.\",\n        \"For a cell (i, j) to be a valid tick center, ensure that there are d cells diagonally top-left and top-right that are also painted.\",\n        \"If a valid tick is found, mark the cells as part of a tick and continue checking other cells.\",\n        \"If all painted cells can be part of valid ticks, return 'YES', otherwise return 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and field patterns.\",\n    \"For each test case, analyze the field pattern to determine if it can be formed by ticks of size at least k.\",\n    \"Iterate over each cell in the field to check for valid tick centers.\",\n    \"Ensure all painted cells can be part of valid ticks.\",\n    \"Output 'YES' if the field can be formed by valid ticks, otherwise output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tick'\n    Explanation: A tick is a pattern of black cells centered at a specific cell, with additional black cells extending diagonally top-left and top-right from the center. The size of the tick is determined by the number of cells extending diagonally from the center.\n\n    'size d'\n    Explanation: The size of a tick, denoted by d, is the number of cells extending diagonally from the center. A tick of size d consists of 2d + 1 black cells.\n\n    'd \u2265 k'\n    Explanation: The size of each tick must be at least k, meaning the diagonal extensions must be at least k cells long.\n\n# [phrase showing quantity relationship]\n    'd > 0': Indicates that the size of a tick must be greater than zero, meaning there must be at least one cell extending diagonally from the center.\n    \n    '2d + 1': Represents the total number of black cells in a tick of size d, including the center cell and the diagonal extensions.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Check if the cell can be the center of a tick of size at least k\" and \"For a cell (i, j) to be a valid tick center, ensure that there are d cells diagonally top-left and top-right that are also painted\" should be implemented simultaneously. This can be done by iterating over each cell and checking both conditions in a single loop.\n\n# [edge case]\n    1. A field with no black cells (all '.'): The expected output is 'YES' because no ticks are needed to satisfy the condition.\n       Explanation: Since there are no black cells, the field can be considered as having no ticks, which is valid.\n\n    2. A field with a single black cell ('*') and k > 0: The expected output is 'NO' because a single black cell cannot form a tick of size at least k.\n       Explanation: A single black cell cannot satisfy the condition of having d cells diagonally, as required for a tick of size k.\n\n    3. A field where all cells are black ('*') but k is larger than the possible tick size: The expected output is 'NO'.\n       Explanation: Even though all cells are black, if k is larger than the maximum possible tick size given the field dimensions, it is impossible to form valid ticks.\n\n# [extra code for edge case]\n", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to mark valid tick centers\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to check for valid tick centers\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if this cell can be the center of a tick of size at least k\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Check if all '*' cells are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 85)"}, "Round_1": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a 2D list to keep track of which cells are part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to check for valid tick centers\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if the cell can be the center of a tick of size at least k\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Check if all '*' cells are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, field dimensions, minimum tick size, and field patterns.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions n, m, and k.\",\n        \"Read the n lines representing the field pattern.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a given field can be obtained by drawing ticks of size d >= k.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if the cell can be the center of a tick of size d >= k.\",\n        \"Verify the tick pattern by checking the diagonals from the center cell.\",\n        \"Ensure all required cells for a tick are painted black ('*').\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"If the field can be obtained by drawing valid ticks, output 'YES'.\",\n        \"Otherwise, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and field details.\",\n    \"For each test case, analyze the field to determine if it can be formed by valid ticks.\",\n    \"Iterate over each cell to check potential tick centers and validate tick patterns.\",\n    \"Output 'YES' or 'NO' based on the analysis for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tick'\n    Explanation: A tick is a pattern of black cells ('*') centered at a specific cell (i, j) and extends diagonally in both directions. The size of a tick is defined by the number of cells it extends diagonally from the center, and it must be at least k.\n\n    'field'\n    Explanation: The field is a grid of size n \u00d7 m where each cell can either be white ('.') or black ('*'). The task is to determine if the given pattern of black cells can be formed by drawing ticks of size at least k.\n\n# [phrase showing quantity relationship]\n    'at least k': This means that the size of each tick must be greater than or equal to k. In code, this can be implemented by checking if the size of the tick (d) is greater than or equal to k.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to checking if a cell can be the center of a tick and verifying the tick pattern should be implemented simultaneously. Specifically, when iterating over each cell, the check for potential tick centers and the validation of the tick pattern should occur in the same loop to ensure efficiency and correctness.\n\n# [edge case]\n    1. A field with no black cells (e.g., all cells are '.'): The expected output is 'YES' because no ticks are needed to form the field.\n       Explanation: Since there are no black cells, the field can be considered as having been formed by zero ticks, which is valid.\n\n    2. A field with a single black cell and k > 1: The expected output is 'NO' because a single black cell cannot form a tick of size at least 1.\n       Explanation: A single black cell cannot satisfy the requirement of forming a tick with size d \u2265 k when k > 1.\n\n    3. A field where all cells are black and k = 1: The expected output is 'YES' because each cell can be the center of a tick of size 1.\n       Explanation: Since k = 1, each black cell can independently form a tick of size 1, covering the entire field.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the field has no black cells or a single black cell with k > 1.\n    ```python\n    def handle_edge_cases(field, n, m,", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to mark cells that are part of valid ticks\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to check if it can be the center of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size at least k can be centered at (i, j)\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Check if all '*' in the field are part of a valid tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, field dimensions, minimum tick size, and field patterns.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions n, m, and k.\",\n        \"Read the n lines representing the field pattern.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a tick of size d >= k can be drawn for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if the cell can be the center of a tick of size d >= k.\",\n        \"Verify the top-left and top-right diagonal cells for the tick size.\",\n        \"Ensure all required cells are painted black ('*') for a valid tick.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"If all asterisks can be part of valid ticks, output 'YES'.\",\n        \"Otherwise, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and field data.\",\n    \"For each test case, iterate over the field to check for valid tick formations.\",\n    \"Determine if the field can be formed by ticks of size d >= k.\",\n    \"Output 'YES' or 'NO' based on the validity of tick formations.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tick': A pattern of black cells ('*') on the grid, centered at a specific cell, extending diagonally in both directions.\n    'size d': The number of cells extending diagonally from the center cell, forming a symmetrical pattern.\n    'd \u2265 k': The minimum size of the tick that can be drawn, where d is the size of the tick and k is the minimum required size.\n\n# [phrase showing quantity relationship]\n    'd > 0': Indicates that the size of the tick must be greater than zero, meaning no tick can be of size zero.\n    '2d + 1': Represents the total number of cells in a tick, including the center and the diagonal extensions.\n\n# [degree adverb]\n    'at least': Refers to the minimum size requirement for the ticks, meaning the size of any tick must be greater than or equal to k.\n\n# [code logic]\n    The steps in the plan related to checking if a cell can be the center of a tick and verifying the diagonal cells should be implemented simultaneously. This can be done by iterating over each cell and checking both diagonals in a single loop to ensure all conditions for a valid tick are met.\n\n# [edge case]\n    1. A field with no asterisks ('*') at all, e.g., a 3x3 grid of all dots ('.').\n       Expected output: YES\n       Explanation: Since there are no asterisks, no ticks are needed, and the field is trivially valid.\n       \n    2. A field with a single asterisk ('*') in a corner, e.g., a 3x3 grid with '*' at (1,1).\n       Expected output: NO\n       Explanation: A single asterisk cannot form a valid tick of size d \u2265 k, where k > 0.\n       \n    3. A field with a valid tick pattern but with an isolated asterisk elsewhere, e.g., a 3x3 grid with a tick of size 1 and an extra '*' at (3,3).\n       Expected output: NO\n       Explanation: The isolated asterisk cannot be part of any valid tick, making the field invalid.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where isolated asterisks exist that cannot be part of any valid tick.\n    ```python\n    def is_valid_tick_center(i, j, k, field):\n       ", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to mark cells that are part of valid ticks\n    marked = [[False] * m for _ in range(n)]\n\n    # Check for possible tick centers from bottom to top\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Determine the maximum size of the tick with center at (i, j)\n                d = 0\n                while (i - d >= 0 and j - d >= 0 and j + d < m and\n                       field[i - d][j - d] == '*' and field[i - d][j + d] == '*'):\n                    d += 1\n                d -= 1  # Adjust because the loop exits with d one step too far\n\n                # If the tick size is at least k, mark the cells\n                if d >= k:\n                    for h in range(d + 1):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Check if all '*' in the field are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, field dimensions, minimum tick size, and field patterns.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions n, m, and k.\",\n        \"Read the n lines representing the field pattern.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a tick of size d >= k can be drawn for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if the cell can be the center of a tick of size d >= k.\",\n        \"Verify if the tick can be drawn without violating the field pattern.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output 'YES' if the field can be obtained by drawing ticks of size d >= k, otherwise output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the necessary information for each test case.\",\n    \"For each test case, iterate over the field to check if ticks of size d >= k can be drawn.\",\n    \"Implement a function to verify if a tick can be drawn at a given cell without violating the field pattern.\",\n    \"Store the result for each test case and output the results sequentially.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tick': A tick is a pattern of black cells centered at a specific cell, extending diagonally in both top-left and top-right directions.\n    'size d': The size of a tick, which determines how many cells are painted diagonally from the center.\n    'field': The grid of cells, some of which are painted black ('*') and others are unpainted ('.').\n\n# [phrase showing quantity relationship]\n    'd > 0': Indicates that the size of a tick must be greater than zero, meaning a tick must have at least one cell painted diagonally.\n    'd \u2265 k': Indicates that the size of each tick must be at least k, meaning the tick must extend diagonally by at least k cells.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially. However, within the second subproblem, the steps \"Check if the cell can be the center of a tick of size d >= k\" and \"Verify if the tick can be drawn without violating the field pattern\" should be considered simultaneously. This can be done by checking each cell and immediately verifying if a tick can be drawn from it.\n\n# [edge case]\n    Case 1: A field with all cells unpainted ('.') and k = 1\n    Input: 3 3 1\n           ...\n           ...\n           ...\n    Expected Output: YES\n    Explanation: No ticks are needed, and the field is valid as is.\n\n    Case 2: A field with a single '*' in the center and k = 1\n    Input: 3 3 1\n           ...\n           .*.\n           ...\n    Expected Output: NO\n    Explanation: A single '*' cannot form a tick of size 1.\n\n    Case 3: A field with '*' forming a valid tick of size 1\n    Input: 3 3 1\n           .*.\n           ***\n           ...\n    Expected Output: YES\n    Explanation: The center '*' can form a tick of size 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where no ticks are needed or where isolated '*' cannot form valid ticks.\n    Example code for handling edge cases:\n    ```python\n    def can_form_tick(field, n, m, k):\n        for i in range(n):\n            for j in range(m):\n                if field[i][j", "Round_0": {"code": "def can_form_tick(field, n, m, k):\n    # Create a copy of the field to mark cells that are part of valid ticks\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate from bottom to top to ensure we can check for valid ticks\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if we can form a tick of size at least k with center at (i, j)\n                d = 0\n                while (i - d >= 0 and j - d >= 0 and j + d < m and\n                       field[i - d][j - d] == '*' and field[i - d][j + d] == '*'):\n                    d += 1\n                d -= 1  # Adjust d to the maximum valid size\n\n                if d >= k:\n                    # Mark the cells of the tick as part of a valid tick\n                    for h in range(d + 1):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Check if all '*' in the field are part of a valid tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_form_tick(field, n, m, k):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: can_form_tick() missing 4 required positional arguments: 'field', 'n', 'm', and 'k'"}, "Round_1": {"code": "def can_form_tick(field, n, m, k):\n    # Create a copy of the field to mark cells that are part of valid ticks\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate from bottom to top to ensure we can check for valid ticks\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if we can form a tick of size at least k with center at (i, j)\n                d = 0\n                while (i - d >= 0 and j - d >= 0 and j + d < m and\n                       field[i - d][j - d] == '*' and field[i - d][j + d] == '*'):\n                    d += 1\n                d -= 1  # Adjust d to the maximum valid size\n\n                if d >= k:\n                    # Mark the cells of the tick as part of a valid tick\n                    for h in range(d + 1):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Check if all '*' in the field are part of a valid tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_form_tick(field, n, m, k):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, field dimensions, minimum tick size, and field patterns.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n, m, and k representing the field dimensions and minimum tick size.\",\n        \"Read the next n lines to capture the field pattern as a list of strings.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a given field pattern can be obtained by drawing ticks of size at least k.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if the cell can be the center of a tick of size at least k.\",\n        \"For a cell (i, j) to be a valid tick center, ensure that there are d cells diagonally top-left and top-right that are also painted.\",\n        \"If a valid tick is found, mark the cells as part of a tick to avoid re-evaluation.\",\n        \"If all painted cells can be part of valid ticks, return YES; otherwise, return NO.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and field patterns.\",\n    \"For each test case, evaluate the field pattern to determine if it can be formed by ticks of size at least k.\",\n    \"Iterate over each cell in the field to check for potential tick centers.\",\n    \"Validate tick formation by checking diagonal cells for each potential center.\",\n    \"Output YES if the field can be formed by valid ticks, otherwise output NO.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tick'\n    Explanation: A tick is a pattern of black cells centered at a specific cell, extending diagonally top-left and top-right by a certain size d, forming a symmetrical pattern.\n\n    'size d'\n    Explanation: The size of a tick, d, determines how many cells extend diagonally from the center. A tick of size d consists of 2d + 1 black cells.\n\n    'minimum size k'\n    Explanation: The smallest size a tick can be, meaning any tick drawn must have a size d that is at least k.\n\n# [phrase showing quantity relationship]\n    'at least k': This means that the size of any tick must be greater than or equal to k. In code, this is checked by ensuring d >= k for any tick.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Check if the cell can be the center of a tick of size at least k\" and \"For a cell (i, j) to be a valid tick center, ensure that there are d cells diagonally top-left and top-right that are also painted\" should be implemented simultaneously. This can be done by iterating over each cell and checking the conditions for a valid tick center in one code block.\n\n# [edge case]\n    1. A field with all cells unpainted (e.g., 3x3 grid with all '.'): NO\n       Explanation: No ticks can be formed as there are no painted cells.\n\n    2. A field with a single row of painted cells (e.g., 1x5 grid with all '*'): NO\n       Explanation: Ticks require diagonal cells, which cannot be formed in a single row.\n\n    3. A field with a single column of painted cells (e.g., 5x1 grid with all '*'): NO\n       Explanation: Similar to the single row, diagonal cells are needed, which cannot be formed in a single column.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the logic checks for the presence of sufficient diagonal cells for any potential tick center. This involves iterating over each cell and verifying the conditions for tick formation, marking cells as part of a tick once validated.\n\n```python\ndef can_form_ticks(n, m, k, field):\n    # Create a boolean grid to mark cells that are part of a valid tick\n   ", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a boolean grid to mark cells that are part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to check if it can be the center of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if this cell can be the center of a tick of size at least k\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Check if all '*' cells are marked\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, field dimensions, minimum tick size, and field patterns.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n, m, and k representing the field dimensions and minimum tick size.\",\n        \"Read the next n lines to capture the field pattern as a list of strings.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a tick of size d >= k can be drawn for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if the cell can be the center of a tick of size d >= k.\",\n        \"Verify that the tick can be drawn without violating the field boundaries or encountering unpainted cells.\",\n        \"Mark cells as part of a tick if they can be part of a valid tick.\"\n      ]\n    },\n    {\n      \"description\": \"Validate the field pattern against the tick drawing rules.\",\n      \"steps\": [\n        \"For each test case, ensure all '*' cells can be part of a valid tick of size d >= k.\",\n        \"If any '*' cell cannot be part of a valid tick, mark the test case as 'NO'.\",\n        \"Otherwise, mark the test case as 'YES'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and field patterns.\",\n    \"For each test case, iterate over the field to identify potential tick centers.\",\n    \"Check if valid ticks can be drawn from each potential center.\",\n    \"Validate the field pattern to ensure all '*' cells are part of valid ticks.\",\n    \"Output 'YES' or 'NO' for each test case based on the validation results.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tick': A tick is a pattern of black cells centered at a specific cell, extending diagonally in both directions. The size of the tick determines how many cells are painted diagonally from the center.\n    'size d': The size of the tick, which determines the number of cells painted diagonally from the center. A tick of size d consists of 2d + 1 black cells.\n    'd \u2265 k': The minimum size of the tick that can be drawn, ensuring that all ticks are of at least size k.\n\n# [phrase showing quantity relationship]\n    'd > 0': Indicates that the size of the tick must be greater than zero, meaning no tick can be of size zero.\n    '2d + 1': Represents the total number of cells painted black for a tick of size d, including the center cell.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to checking if a cell can be the center of a tick and verifying the tick's validity should be implemented simultaneously. This involves iterating over each cell and checking the conditions for tick formation in one code block.\n\n# [edge case]\n    Case 1: A field with all cells as '.' (no ticks possible) should return 'YES' because no ticks are required.\n    Case 2: A field with '*' cells that cannot form a valid tick of size d \u2265 k should return 'NO'.\n    Case 3: A field with '*' cells that can form multiple overlapping ticks of size d \u2265 k should return 'YES'.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where '*' cells cannot form valid ticks.\n        (code for handling the edge case)\n        - Iterate over each cell and check if it can be the center of a tick of size d \u2265 k.\n        - If a '*' cell cannot be part of a valid tick, mark the test case as 'NO'.\n        - Otherwise, mark the test case as 'YES'.\n\nYES", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to mark valid tick cells\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to check if it can be the center of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size d >= k can be formed\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Validate the field pattern\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, field dimensions, minimum tick size, and field patterns.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions n, m, and k.\",\n        \"Read the n lines representing the field pattern.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a given field can be obtained by drawing ticks of size d >= k.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if the cell can be the center of a tick of size d >= k.\",\n        \"Verify the tick pattern by checking the diagonals from the center cell.\",\n        \"Ensure all required cells for a tick are painted black ('*').\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"If the field can be obtained by drawing valid ticks, output 'YES'.\",\n        \"Otherwise, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and field details.\",\n    \"For each test case, analyze the field to determine if it can be formed by valid ticks.\",\n    \"Implement a function to check if a tick of size d >= k can be centered at each cell.\",\n    \"Iterate over the field and apply the tick-checking function.\",\n    \"Collect results for each test case and print them.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tick'\n    Explanation: A tick is a pattern of black cells ('*') centered at a specific cell, extending diagonally in both directions. The size of a tick is defined by the number of cells extending diagonally from the center.\n\n    'd \u2265 k'\n    Explanation: The size of each tick must be at least k, meaning the tick must extend at least k cells diagonally from the center.\n\n# [phrase showing quantity relationship]\n    'at least k': This means the size of the tick (d) must be greater than or equal to k. In code, this is checked by ensuring d >= k.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the subproblem \"Determine if a given field can be obtained by drawing ticks of size d >= k\" should be implemented simultaneously. Specifically, checking if a cell can be the center of a tick and verifying the tick pattern should be done in a single loop over the field.\n\n# [edge case]\n    1. A field with all cells as '.' (e.g., 3x3 field with k=1):\n       Input: \n       ```\n       1\n       3 3 1\n       ...\n       ...\n       ...\n       ```\n       Expected Output: YES\n       Explanation: No ticks are needed, so the field is valid as is.\n\n    2. A field with a single '*' that cannot form a valid tick (e.g., 3x3 field with k=2):\n       Input:\n       ```\n       1\n       3 3 2\n       .*.\n       ...\n       ...\n       ```\n       Expected Output: NO\n       Explanation: The single '*' cannot form a tick of size 2.\n\n    3. A field with a valid tick pattern but with k too large (e.g., 3x3 field with k=3):\n       Input:\n       ```\n       1\n       3 3 3\n       .*.\n       ***\n       .*.\n       ```\n       Expected Output: NO\n       Explanation: The tick pattern is valid for k=1, but not for k=3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where no ticks are needed or where isolated '*' cannot form valid ticks.\n    Example code for handling edge cases:\n    ```python\n    def can_form_ticks(field, n, m, k):\n        for i in range(n):\n", "Round_0": {"code": "def can_form_ticks(field, n, m, k):\n    # Create a copy of the field to mark cells that can be part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell in the field\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if this cell can be the center of a tick of size d >= k\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Check if all '*' in the field are part of a valid tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(field, n, m, k)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, field dimensions, minimum tick size, and field patterns.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions n, m, and k.\",\n        \"Read the n lines representing the field pattern.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a tick of size d >= k can be drawn for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if the cell can be the center of a tick of size d >= k.\",\n        \"Verify the top-left and top-right diagonal cells for the tick size.\",\n        \"Ensure all required cells are black ('*') for a valid tick.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"If all black cells can be part of valid ticks, output 'YES'.\",\n        \"Otherwise, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and field data.\",\n    \"For each test case, iterate over the field to check for valid tick centers.\",\n    \"Validate tick formation by checking diagonal cells.\",\n    \"Output 'YES' if the field can be formed by valid ticks, otherwise 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tick': A tick is a pattern of black cells centered at a specific cell, extending diagonally in both directions. The size of the tick is determined by the number of cells extending diagonally from the center.\n    'size d': The size of the tick, which is the number of cells extending diagonally from the center. A tick of size d consists of 2d + 1 black cells.\n    'd \u2265 k': The minimum size of the tick that can be drawn, where k is the smallest allowable size.\n\n# [phrase showing quantity relationship]\n    'd > 0': Indicates that the size of the tick must be greater than zero, meaning no tick can be of size zero.\n    '2d + 1': Represents the total number of black cells in a tick of size d, including the center cell and the diagonal cells.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for checking if a cell can be the center of a tick and verifying the diagonal cells should be implemented simultaneously. This involves iterating over each cell and checking both diagonals in one code block to ensure the tick can be formed.\n\n# [edge case]\n    Case 1: A field with all cells black and k = 1\n    Input: 3 3 1\n           ***\n           ***\n           ***\n    Expected Output: YES\n    Explanation: Every cell can be the center of a tick of size 1, and all cells are black.\n\n    Case 2: A field with no black cells\n    Input: 3 3 1\n           ...\n           ...\n           ...\n    Expected Output: NO\n    Explanation: There are no black cells to form any tick.\n\n    Case 3: A field with isolated black cells\n    Input: 3 3 2\n           *..\n           .*.\n           ..*\n    Expected Output: NO\n    Explanation: No cell can be the center of a tick of size 2 due to isolation.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where isolated black cells or insufficient black cells prevent tick formation.\n    ```python\n    def can_form_ticks(n, m, k, field):\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    max_d = min(i, j, m - j - 1)\n                    if max_d < k:\n", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to mark cells that can be part of a tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to check if it can be the center of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Determine the maximum possible size of the tick centered at (i, j)\n                max_d = min(i, j, m - j - 1)\n                if max_d >= k:\n                    # Check if a tick of size d can be formed\n                    d = k\n                    while d <= max_d:\n                        valid_tick = True\n                        for h in range(1, d + 1):\n                            if field[i - h][j - h] != '*' or field[i - h][j + h] != '*':\n                                valid_tick = False\n                                break\n                        if valid_tick:\n                            # Mark the cells as part of a valid tick\n                            for h in range(d + 1):\n                                marked[i - h][j - h] = True\n                                marked[i - h][j + h] = True\n                            break\n                        d += 1\n\n    # Check if all black cells are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, false, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 224, "prompt": "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white. \n\nLet us denote the cell with coordinates i vertically and j horizontally by (i, j), where the upper left cell is (1, 1) and the lower right cell is (n, m). Casimir draws ticks of different sizes on the field, where a tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: \n\n1. First, the center cell (i, j) is painted black. \n2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black in a symmetrical pattern, so all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted; in particular, a tick consists of 2d + 1 black cells. \n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 126}
