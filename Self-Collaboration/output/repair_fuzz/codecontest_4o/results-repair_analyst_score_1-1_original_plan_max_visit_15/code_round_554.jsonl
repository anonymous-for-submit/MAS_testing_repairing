{"name": "1607_F. Robot on the Board 2", "description": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nEach cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. \n\n  * If the robot moves beyond the edge of the board, it falls and breaks. \n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). \n\n\n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDetermine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "tags": ["brute force", "dfs and similar", "dp", "graphs", "implementation"], "difficulty": 12, "id": 1607, "sample_io": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n"]}], "test_list": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nUDUR\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRDRR\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 7\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDUD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 1 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 9\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nUUDR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n4 3 10\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDULD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 4\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nUDDL\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 4 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n1 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n1 2 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 13\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nUDLD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRDUU\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n1 1 5\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n2 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDRUU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n3 1 7\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 2\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n2 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n1 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 4\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nURLL\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 1 8\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n3 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}], "task_id": "codecontest/103", "repair_prompt": ["The input should consist of an integer n and an integer m, followed by a sequence of n strings each containing m characters ('L', 'R', 'D', 'U'), representing the board configuration.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The input should consist of an integer n and an integer m, followed by a sequence of n strings each containing m characters ('L', 'R', 'D', 'U'). These characters represent directional moves. Collectively, they represent the board configuration.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The input should consist of an integer n and an integer m, followed by a sequence of n strings each containing m characters ('L', 'R', 'D', 'U'), representing the board configuration.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip the blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Directions mapping\n        direction_map = {\n            'L': (0, -1),\n            'R': (0, 1),\n            'U': (-1, 0),\n            'D': (1, 0)\n        }\n        \n        # Function to simulate the robot's movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n                visited.add((r, c))\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r += dr\n                c += dc\n                moves += 1\n            return moves\n        \n        # Find the starting position with the maximum moves\n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def simulate_moves(board, n, m):\n    # Direction vectors for 'L', 'R', 'D', 'U'\n    direction_map = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    max_moves = 0\n    best_position = (1, 1)\n    \n    for start_r in range(n):\n        for start_c in range(m):\n            visited = set()\n            r, c = start_r, start_c\n            moves = 0\n            \n            while is_valid(r, c) and (r, c) not in visited:\n                visited.add((r, c))\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r += dr\n                c += dc\n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                best_position = (start_r + 1, start_c + 1)\n    \n    return best_position[0], best_position[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_movement(n, m, board):\n    # Directions: L, R, D, U\n    direction_map = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_out_of_bounds(x, y):\n        return x < 0 or x >= n or y < 0 or y >= m\n\n    max_moves = 0\n    best_start = (1, 1)  # Default starting position\n\n    for start_x in range(n):\n        for start_y in range(m):\n            visited = set()\n            x, y = start_x, start_y\n            moves = 0\n\n            while (x, y) not in visited and not is_out_of_bounds(x, y):\n                visited.add((x, y))\n                direction = board[x][y]\n                dx, dy = direction_map[direction]\n                x += dx\n                y += dy\n                moves += 1\n\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (start_x + 1, start_y + 1)  # Convert to 1-based index\n\n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_movement(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    for _ in range(t):\n        # Skip the blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        for r in range(n):\n            for c in range(m):\n                visited = set()\n                moves = 0\n                current_r, current_c = r, c\n                \n                while (current_r, current_c) not in visited:\n                    visited.add((current_r, current_c))\n                    moves += 1\n                    direction = board[current_r][current_c]\n                    dr, dc = direction_map[direction]\n                    next_r, next_c = current_r + dr, current_c + dc\n                    \n                    if not (0 <= next_r < n and 0 <= next_c < m):\n                        break\n                    \n                    current_r, current_c = next_r, next_c\n                \n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_movement(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n        moves += 1\n\n    return moves\n\ndef find_max_moves_for_test_case(n, m, board):\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n\n    results = []\n\n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n\n        n, m = map(int, data[index].strip().split())\n        index += 1\n\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n\n        result = find_max_moves_for_test_case(n, m, board)\n        results.append(result)\n\n    for r, c, d in results:\n        print(r, c, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_movement(board, start_r, start_c):\n    n, m = len(board), len(board[0])\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        if direction == 'L':\n            c -= 1\n        elif direction == 'R':\n            c += 1\n        elif direction == 'U':\n            r -= 1\n        elif direction == 'D':\n            r += 1\n\n    return moves\n\ndef find_max_moves(board):\n    n, m = len(board)\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        result = find_max_moves(board)\n        results.append(result)\n    \n    for r, c, d in results:\n        print(r, c, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def detect_cycle_and_count_moves(board, start_r, start_c, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    visited = {}\n    r, c = start_r, start_c\n    move_count = 0\n    \n    while True:\n        if (r, c) in visited:\n            # Cycle detected\n            return move_count - visited[(r, c)]\n        \n        if r < 0 or r >= n or c < 0 or c >= m:\n            # Out of bounds\n            return move_count\n        \n        visited[(r, c)] = move_count\n        move_count += 1\n        \n        direction = board[r][c]\n        dr, dc = direction_map[direction]\n        r += dr\n        c += dc\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Read blank line\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Check each cell as a starting point\n        for r in range(n):\n            for c in range(m):\n                moves = detect_cycle_and_count_moves(board, r, c, n, m)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()\n\nmain()", "def simulate_moves(board, n, m):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            direction = board[r][c]\n            dr, dc = directions[direction]\n            r += dr\n            c += dc\n            moves += 1\n        return moves\n    \n    max_moves = 0\n    best_position = (1, 1)\n    \n    for r in range(n):\n        for c in range(m):\n            moves = move(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_position = (r + 1, c + 1)\n    \n    return best_position[0], best_position[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_movement(board, n, m):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move(r, c):\n        visited = set()\n        moves = 0\n        while 0 <= r < n and 0 <= c < m and (r, c) not in visited:\n            visited.add((r, c))\n            direction = board[r][c]\n            dr, dc = directions[direction]\n            r += dr\n            c += dc\n            moves += 1\n        return moves\n\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = move(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_movement(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_movement(board, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def move_from(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited:\n            visited.add((r, c))\n            moves += 1\n            dr, dc = direction_map[board[r][c]]\n            r, c = r + dr, c + dc\n            if r < 0 or r >= n or c < 0 or c >= m:\n                break\n        return moves\n\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = move_from(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_movement(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip the blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Directions mapping\n        direction_map = {\n            'L': (0, -1),\n            'R': (0, 1),\n            'U': (-1, 0),\n            'D': (1, 0)\n        }\n        \n        # Function to simulate the robot's movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n                visited.add((r, c))\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r += dr\n                c += dc\n                moves += 1\n            return moves\n        \n        # Find the starting position with the maximum moves\n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board to determine the starting position that results in the maximum number of moves.\",\n      \"steps\": [\n        \"Initialize variables to track the maximum number of moves and the corresponding starting position.\",\n        \"For each cell (r, c) on the board, simulate the robot's movement according to the direction specified by the character in the cell.\",\n        \"Track the number of moves made by the robot until it exits the board or revisits a cell.\",\n        \"Update the maximum number of moves and the starting position if the current simulation results in more moves.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the starting position (r, c) and the maximum number of moves d.\",\n        \"Ensure the output format matches the specified requirements.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n    \"For each test case, iterate over each cell on the board to simulate the robot's movement and calculate the number of moves.\",\n    \"Track the maximum number of moves and the corresponding starting position for each test case.\",\n    \"Output the starting position and the maximum number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: The board configuration refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the movement directions for the robot.\n\n    'maximum number of moves'\n    Explanation: This means finding the starting position on the board that allows the robot to make the most moves before exiting the board or revisiting a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates the need to find the highest possible count of moves the robot can make from a starting position. In code, this can be implemented by tracking the number of moves for each starting position and updating the maximum when a higher count is found.\n\n# [degree adverb]\n    'maximum': This means the largest possible number of moves. In code, this can be implemented by comparing the current number of moves with the stored maximum and updating the maximum if the current count is higher.\n\n# [code logic]\n    The steps in the second subproblem should be implemented simultaneously:\n    - \"Initialize variables to track the maximum number of moves and the corresponding starting position.\"\n    - \"For each cell (r, c) on the board, simulate the robot's movement according to the direction specified by the character in the cell.\"\n    - \"Track the number of moves made by the robot until it exits the board or revisits a cell.\"\n    - \"Update the maximum number of moves and the starting position if the current simulation results in more moves.\"\n    These steps can be implemented in a single loop that iterates over each cell, simulates the movement, and updates the maximum moves and position.\n\n# [edge case]\n    Test case with smallest board: \n    1 1\n    L\n    Expected output: 1 1 1\n    Explanation: The robot can only make one move before exiting the board.\n\n    Test case with all directions leading out:\n    2 2\n    LR\n    DU\n    Expected output: 1 1 1\n    Explanation: Any starting position results in only one move before exiting the board.\n\n    Test case with revisiting cells:\n    2 2\n    RR\n    LL\n    Expected output: 1 1 2\n    Explanation: Starting at (1,1), the robot moves right to (1,2) and then exits, making 2 moves.\n\n# [extra code for edge case]\n    We do not need extra code to handle", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip the blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Directions mapping\n        direction_map = {\n            'L': (0, -1),\n            'R': (0, 1),\n            'U': (-1, 0),\n            'D': (1, 0)\n        }\n        \n        # Function to simulate the robot's movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n                visited.add((r, c))\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r += dr\n                c += dc\n                moves += 1\n            return moves\n        \n        # Find the starting position with the maximum moves\n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 167)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip the blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Directions mapping\n        direction_map = {\n            'L': (0, -1),\n            'R': (0, 1),\n            'U': (-1, 0),\n            'D': (1, 0)\n        }\n        \n        # Function to simulate the robot's movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n                visited.add((r, c))\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r += dr\n                c += dc\n                moves += 1\n            return moves\n        \n        # Find the starting position with the maximum moves\n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read integers n and m, followed by n strings each of length m representing the board.\"\n    },\n    {\n      \"description\": \"Simulate the movement on the board to determine the maximum number of moves starting from any cell.\",\n      \"details\": \"For each cell (r, c) on the board, simulate the movement according to the direction ('L', 'R', 'D', 'U') until a cycle is detected or the edge of the board is reached.\"\n    },\n    {\n      \"description\": \"Track the maximum number of moves and the starting position that achieves this maximum.\",\n      \"details\": \"Keep a record of the maximum number of moves found and the corresponding starting cell (r, c) for each test case.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, output the starting position (r, c) and the maximum number of moves d.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize a loop to process each test case.\",\n    \"For each test case, parse the board dimensions and configuration.\",\n    \"Initialize variables to track the maximum number of moves and the best starting position.\",\n    \"Iterate over each cell in the board and simulate the movement to calculate the number of moves.\",\n    \"Update the maximum moves and starting position if a new maximum is found.\",\n    \"After processing all cells, store the result for the current test case.\",\n    \"Output the results for all test cases after processing all of them.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'directional moves'\n    Explanation: The characters 'L', 'R', 'D', 'U' represent left, right, down, and up movements respectively on the board.\n\n    'maximum number of moves'\n    Explanation: The goal is to find the starting position on the board that allows the robot to make the most moves before reaching an edge or entering a cycle.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates that we need to find the path that results in the highest number of moves possible from a starting position.\n    Implementation: Use a simulation approach to track the number of moves from each starting position and update the maximum if a new higher count is found.\n\n# [degree adverb]\n    'maximum': This means the highest possible number of moves from a starting position.\n    Implementation: Track the number of moves for each starting position and update the maximum value when a higher count is found.\n\n# [code logic]\n    The steps related to simulating movement and tracking the maximum number of moves should be implemented simultaneously.\n    Explanation: While iterating over each cell, simulate the movement and update the maximum number of moves and the best starting position in one code block.\n\n# [edge case]\n    Edge case 1: A board with all cells having the same direction, e.g., 1x3 board with 'RRR'\n    Expected output: 1 1 3\n    Explanation: The robot can move from the first cell to the last cell without encountering any cycle or edge.\n\n    Edge case 2: A board with a cycle, e.g., 2x2 board with 'LR', 'RL'\n    Expected output: Any starting position with 4 moves\n    Explanation: The robot can move indefinitely in a cycle, so the number of moves is equal to the number of cells.\n\n    Edge case 3: A board with no possible moves, e.g., 1x1 board with 'U'\n    Expected output: 1 1 0\n    Explanation: The robot cannot move as it immediately encounters the edge of the board.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases related to cycles and edges.\n    Code for handling the edge case:\n    ```python\n    def simulate_moves(board, n, m):\n        # Initialize variables to track maximum moves and best starting position\n        max_moves = 0\n        best_position = (1, 1)\n        \n       ", "Round_0": {"code": "def simulate_moves(board, n, m):\n    # Direction vectors for 'L', 'R', 'D', 'U'\n    direction_map = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    max_moves = 0\n    best_position = (1, 1)\n    \n    for start_r in range(n):\n        for start_c in range(m):\n            visited = set()\n            r, c = start_r, start_c\n            moves = 0\n            \n            while is_valid(r, c) and (r, c) not in visited:\n                visited.add((r, c))\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r += dr\n                c += dc\n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                best_position = (start_r + 1, start_c + 1)\n    \n    return best_position[0], best_position[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 155)"}, "Round_1": {"code": "def simulate_moves(board, n, m):\n    # Direction vectors for 'L', 'R', 'D', 'U'\n    direction_map = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    max_moves = 0\n    best_position = (1, 1)\n    \n    for start_r in range(n):\n        for start_c in range(m):\n            visited = set()\n            r, c = start_r, start_c\n            moves = 0\n            \n            while is_valid(r, c) and (r, c) not in visited:\n                visited.add((r, c))\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r += dr\n                c += dc\n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                best_position = (start_r + 1, start_c + 1)\n    \n    return best_position[0], best_position[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"name\": \"Parse Input\",\n      \"description\": \"Read the number of test cases and for each test case, read the dimensions of the board and the board configuration.\"\n    },\n    {\n      \"name\": \"Simulate Robot Movement\",\n      \"description\": \"For each starting position on the board, simulate the robot's movement according to the direction characters ('L', 'R', 'D', 'U') and count the number of moves until the robot exits the board or revisits a cell.\"\n    },\n    {\n      \"name\": \"Determine Maximum Moves\",\n      \"description\": \"Track the maximum number of moves possible from any starting position on the board and record the starting position and the number of moves.\"\n    },\n    {\n      \"name\": \"Output Results\",\n      \"description\": \"For each test case, output the starting position and the maximum number of moves. If there are multiple starting positions with the same number of moves, any of them can be chosen.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize a list to store results for each test case.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Parse the input to get the dimensions of the board and the board configuration.\",\n    \"  b. Initialize variables to track the maximum number of moves and the corresponding starting position.\",\n    \"  c. Iterate over each cell in the board as a potential starting position.\",\n    \"  d. For each starting position, simulate the robot's movement and count the number of moves.\",\n    \"  e. If the number of moves from the current starting position is greater than the current maximum, update the maximum and record the starting position.\",\n    \"  f. After checking all starting positions, store the result for the current test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the setup of the board with n rows and m columns, where each cell contains a direction ('L', 'R', 'D', 'U') indicating the movement direction for the robot.\n\n    'maximum number of moves'\n    Explanation: This means finding the starting position on the board from which the robot can make the most moves before exiting the board or revisiting a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates the need to find the highest possible count of moves the robot can make from any starting position on the board.\n    Implementation: Use a loop to simulate movements from each starting position and keep track of the highest move count.\n\n# [degree adverb]\n    'maximum': This means the largest possible number of moves the robot can make from a starting position.\n    Implementation: Use a variable to store the maximum move count and update it whenever a higher count is found during simulation.\n\n# [code logic]\n    Steps 3 and 4 in the high-level plan should be considered simultaneously:\n    \"Iterate over each cell in the board as a potential starting position.\"\n    \"For each starting position, simulate the robot's movement and count the number of moves.\"\n    These can be implemented in a nested loop where the outer loop iterates over each cell, and the inner logic simulates the movement and counts the moves.\n\n# [edge case]\n    Test case with smallest board size:\n    Input: 1 1\n           L\n    Expected output: 1 1 1\n    Explanation: The robot starts at the only cell and moves left, exiting the board after one move.\n\n    Test case with all directions leading out:\n    Input: 2 2\n           LR\n           UD\n    Expected output: 1 1 1\n    Explanation: Any starting position leads the robot out of the board in one move.\n\n    Test case with revisiting cells:\n    Input: 2 2\n           RR\n           LL\n    Expected output: 1 1 2\n    Explanation: Starting at (1,1), the robot moves right to (1,2), then right again to exit the board.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating movements and tracking the maximum moves will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def simulate_movement(n, m, board):\n    # Directions: L, R, D, U\n    direction_map = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_out_of_bounds(x, y):\n        return x < 0 or x >= n or y < 0 or y >= m\n\n    max_moves = 0\n    best_start = (1, 1)  # Default starting position\n\n    for start_x in range(n):\n        for start_y in range(m):\n            visited = set()\n            x, y = start_x, start_y\n            moves = 0\n\n            while (x, y) not in visited and not is_out_of_bounds(x, y):\n                visited.add((x, y))\n                direction = board[x][y]\n                dx, dy = direction_map[direction]\n                x += dx\n                y += dy\n                moves += 1\n\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (start_x + 1, start_y + 1)  # Convert to 1-based index\n\n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_movement(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read integers n and m, followed by n strings each of length m representing the board.\"\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board to determine the maximum number of moves possible from each starting position.\",\n      \"details\": \"For each cell (r, c) on the board, simulate the robot's movement according to the direction ('L', 'R', 'D', 'U') until it either leaves the board or revisits a cell. Track the number of moves made.\"\n    },\n    {\n      \"description\": \"Identify the starting position that allows the maximum number of moves for each test case.\",\n      \"details\": \"Compare the number of moves from each starting position and select the position with the maximum moves. If there are multiple positions with the same maximum moves, any of them can be chosen.\"\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"details\": \"For each test case, output the row, column, and maximum number of moves in the format 'r c d'.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the dimensions of the board (n and m) and the board configuration.\",\n    \"  b. Initialize a variable to track the maximum number of moves and the corresponding starting position.\",\n    \"  c. Iterate over each cell on the board as a potential starting position.\",\n    \"  d. Simulate the robot's movement from the current starting position and count the moves.\",\n    \"  e. Update the maximum moves and starting position if the current simulation yields more moves.\",\n    \"  f. After evaluating all starting positions, store the result for the test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the movement directions for the robot.\n\n    'maximum number of moves'\n    Explanation: This means finding the starting position on the board that allows the robot to make the most moves before it either leaves the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates the need to find the highest possible count of moves from a starting position on the board.\n    Implementation: Use a loop to simulate movements from each starting position and keep track of the number of moves. Compare these counts to find the maximum.\n\n# [degree adverb] \n    'maximum': This means the highest number of moves possible from any starting position on the board.\n    Implementation: Use a variable to store the maximum number of moves found and update it whenever a higher count is encountered during simulation.\n\n# [code logic]\n    Steps 2c, 2d, and 2e should be implemented simultaneously.\n    Explanation: These steps involve iterating over each cell, simulating the robot's movement, and updating the maximum moves if the current simulation yields more moves. This can be done in a single loop where each cell is evaluated as a starting position.\n\n# [edge case] \n    Test case with smallest board: \n    1 1\n    L\n    Expected output: 1 1 1\n    Explanation: The board has only one cell, and the robot can make one move before leaving the board.\n\n    Test case with all directions leading out:\n    2 2\n    LR\n    DU\n    Expected output: 1 1 1\n    Explanation: Starting from any position, the robot can only make one move before leaving the board.\n\n    Test case with revisiting cells:\n    2 2\n    RR\n    LL\n    Expected output: 1 1 2\n    Explanation: Starting from (1,1), the robot moves right to (1,2) and then right again, revisiting (1,1), making a total of 2 moves.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling the edge case:\n    - Implement a visited set to track cells that have been visited during the simulation to prevent revisiting.\n    - Ensure the simulation stops when a cell", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    for _ in range(t):\n        # Skip the blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        for r in range(n):\n            for c in range(m):\n                visited = set()\n                moves = 0\n                current_r, current_c = r, c\n                \n                while (current_r, current_c) not in visited:\n                    visited.add((current_r, current_c))\n                    moves += 1\n                    direction = board[current_r][current_c]\n                    dr, dc = direction_map[direction]\n                    next_r, next_c = current_r + dr, current_c + dc\n                    \n                    if not (0 <= next_r < n and 0 <= next_c < m):\n                        break\n                    \n                    current_r, current_c = next_r, next_c\n                \n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board to determine the starting position that results in the maximum number of moves.\",\n      \"steps\": [\n        \"Initialize a function to simulate the robot's movement from a given starting position (r, c).\",\n        \"Use a loop to follow the direction indicated by the current cell ('L', 'R', 'D', 'U') and update the robot's position accordingly.\",\n        \"Keep track of the number of moves made until the robot moves out of bounds or revisits a cell.\",\n        \"Return the number of moves made from the starting position.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting position that results in the maximum number of moves for each test case.\",\n      \"steps\": [\n        \"Iterate over all possible starting positions (r, c) on the board.\",\n        \"For each position, use the simulation function to calculate the number of moves.\",\n        \"Keep track of the maximum number of moves and the corresponding starting position.\",\n        \"If multiple positions result in the same maximum number of moves, any of them can be chosen.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"steps\": [\n        \"For each test case, output the starting position (r, c) and the maximum number of moves d.\",\n        \"Ensure the output format matches the requirement: three integers separated by spaces.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and board configurations.\",\n    \"Implement a function to simulate robot movement and calculate moves from a starting position.\",\n    \"Iterate over all starting positions to find the one with the maximum moves for each test case.\",\n    \"Output the results in the required format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the grid of characters ('L', 'R', 'D', 'U') that dictate the movement directions on the board.\n\n    'maximum number of moves'\n    Explanation: This means finding the starting position on the board that allows the robot to make the most moves before it either exits the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates that we need to find the starting position that results in the highest possible number of moves. In code, this can be implemented by keeping track of the move count for each starting position and updating the maximum when a higher count is found.\n\n# [degree adverb]\n    'maximum': This means the highest number of moves possible from any starting position. In code, this is typically implemented by comparing current move counts and updating a maximum variable.\n\n# [code logic]\n    The steps in the subproblem \"Simulate the movement of a robot on the board to determine the starting position that results in the maximum number of moves\" should be implemented simultaneously. Specifically, the steps to simulate movement, track moves, and check for out-of-bounds or revisited cells should be in a single loop or function.\n\n# [edge case]\n    Edge Case 1: A board with all cells pointing in the same direction, e.g., a 2x2 board with all 'R'.\n    Expected Output: The robot will move out of bounds immediately from any starting position, so the number of moves will be 1.\n    Explanation: Since all cells point right, the robot will exit the board after the first move.\n\n    Edge Case 2: A board with a single cell, e.g., a 1x1 board with 'L'.\n    Expected Output: The robot will move out of bounds immediately, so the number of moves will be 1.\n    Explanation: The single move will take the robot out of bounds.\n\n    Edge Case 3: A board with a loop, e.g., a 2x2 board with 'RD', 'UL'.\n    Expected Output: The robot will keep moving in a loop indefinitely, so the number of moves will be the size of the loop.\n    Explanation: The robot will cycle through the cells without exiting or revisiting a cell.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot revisits a cell, creating a loop.\n    ```python\n   ", "Round_0": {"code": "def simulate_movement(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n        moves += 1\n\n    return moves\n\ndef find_max_moves_for_test_case(n, m, board):\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n\n    results = []\n\n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n\n        n, m = map(int, data[index].strip().split())\n        index += 1\n\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n\n        result = find_max_moves_for_test_case(n, m, board)\n        results.append(result)\n\n    for r, c, d in results:\n        print(r, c, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: find_max_moves_for_test_case() missing 3 required positional arguments: 'n', 'm', and 'board'"}, "Round_1": {"code": "def simulate_movement(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n        moves += 1\n\n    return moves\n\ndef find_max_moves_for_test_case(n, m, board):\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n\n    results = []\n\n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n\n        n, m = map(int, data[index].strip().split())\n        index += 1\n\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n\n        result = find_max_moves_for_test_case(n, m, board)\n        results.append(result)\n\n    for r, c, d in results:\n        print(r, c, d)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board to determine the starting position that results in the maximum number of moves.\",\n      \"steps\": [\n        \"Initialize a function to simulate the robot's movement starting from any given cell (r, c).\",\n        \"For each cell on the board, simulate the robot's movement according to the direction specified ('L', 'R', 'D', 'U').\",\n        \"Track the number of moves made until the robot either exits the board or revisits a cell.\",\n        \"Store the starting position and the number of moves for each simulation.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting position that results in the maximum number of moves for each test case.\",\n      \"steps\": [\n        \"Compare the number of moves for each starting position on the board.\",\n        \"Select the starting position (r, c) that results in the maximum number of moves d.\",\n        \"If there are multiple positions with the same maximum number of moves, select any of them.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case in the specified format.\",\n      \"steps\": [\n        \"For each test case, output the integers r, c, and d, which represent the starting position and the maximum number of moves.\",\n        \"Ensure the output format matches the requirement: 'r c d'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n    \"For each test case, simulate the robot's movement from each cell on the board to determine the maximum number of moves.\",\n    \"Identify the starting position that results in the maximum number of moves for each test case.\",\n    \"Output the results in the specified format for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the movement directions for the robot.\n\n    'maximum number of moves'\n    Explanation: This means finding the starting position on the board that allows the robot to make the most moves before exiting the board or revisiting a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates the need to find the highest possible count of moves the robot can make from a starting position. In code, this can be implemented by tracking the number of moves for each starting position and selecting the one with the highest count.\n\n# [degree adverb]\n    'maximum': This means the largest possible number of moves. In code, this can be implemented by comparing move counts and selecting the largest one.\n\n# [code logic]\n    The steps in the subproblem \"Simulate the movement of a robot on the board to determine the starting position that results in the maximum number of moves\" should be implemented simultaneously. Specifically, the simulation of the robot's movement, tracking moves, and storing results should occur in one cohesive block of code for each starting position.\n\n# [edge case]\n    Test case with a single cell board: \n    Input: 1 1 R\n    Expected output: 1 1 1\n    Explanation: The robot can only move once to the right and exit the board.\n\n    Test case with all cells leading to immediate exit:\n    Input: 2 2 RR\n           LL\n    Expected output: 1 1 1\n    Explanation: Any starting position results in only one move before exiting the board.\n\n    Test case with a loop:\n    Input: 2 2 LR\n           RL\n    Expected output: 1 1 4\n    Explanation: Starting at (1,1), the robot can move in a loop indefinitely, but the requirement is to count moves until revisiting a cell, resulting in 4 moves.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot revisits a cell or exits the board immediately.\n        (code for handling the edge case)\n        def simulate_movement(board, r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited and 0 <= r < len(board) and 0 <= c < len(board[0", "Round_0": {"code": "def simulate_movement(board, start_r, start_c):\n    n, m = len(board), len(board[0])\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        if direction == 'L':\n            c -= 1\n        elif direction == 'R':\n            c += 1\n        elif direction == 'U':\n            r -= 1\n        elif direction == 'D':\n            r += 1\n\n    return moves\n\ndef find_max_moves(board):\n    n, m = len(board)\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        result = find_max_moves(board)\n        results.append(result)\n    \n    for r, c, d in results:\n        print(r, c, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 164)"}, "Round_1": {"code": "def simulate_movement(board, start_r, start_c):\n    n, m = len(board), len(board[0])\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        if direction == 'L':\n            c -= 1\n        elif direction == 'R':\n            c += 1\n        elif direction == 'U':\n            r -= 1\n        elif direction == 'D':\n            r += 1\n\n    return moves\n\ndef find_max_moves(board):\n    n, m = len(board)\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        result = find_max_moves(board)\n        results.append(result)\n    \n    for r, c, d in results:\n        print(r, c, d)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read integers n and m, followed by n strings each of length m representing the board.\"\n    },\n    {\n      \"description\": \"Simulate the movement on the board to determine the maximum number of moves starting from any cell.\",\n      \"details\": \"For each cell (r, c) on the board, simulate the movement according to the direction ('L', 'R', 'D', 'U') until a cycle is detected or the edge of the board is reached.\"\n    },\n    {\n      \"description\": \"Track the maximum number of moves and the starting position that achieves this maximum.\",\n      \"details\": \"Keep a record of the maximum number of moves found and the corresponding starting cell (r, c) for each test case.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, output the starting cell (r, c) and the maximum number of moves d.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize a function to read and parse the input data.\",\n    \"Iterate over each test case to process the board configuration.\",\n    \"For each cell in the board, simulate the movement and count the number of moves until a cycle or boundary is reached.\",\n    \"Compare the number of moves from each starting cell to find the maximum.\",\n    \"Store the starting position and the maximum number of moves for each test case.\",\n    \"Output the results for all test cases in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'directional moves'\n    Explanation: The characters 'L', 'R', 'D', 'U' represent left, right, down, and up movements on the board, respectively. The task is to simulate these movements starting from any cell on the board to determine the maximum number of moves possible.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This means finding the highest possible count of moves starting from any cell on the board before a cycle is detected or the edge of the board is reached.\n    Implementation: This can be implemented by simulating the movement from each cell and keeping track of the number of moves until a cycle or boundary is reached.\n\n# [degree adverb]\n    'maximum': This refers to the highest number of moves that can be achieved starting from any cell on the board.\n    Implementation: Use a variable to track the highest number of moves found during the simulation from each starting cell.\n\n# [code logic]\n    The steps of simulating movement and tracking the maximum number of moves should be implemented simultaneously. Specifically, while simulating the movement from each cell, the code should also update the maximum number of moves and the starting position if a new maximum is found.\n\n# [edge case]\n    Edge Case 1: A board with only one cell, e.g., n = 1, m = 1, board = ['R']\n    Expected Output: 1 1 1\n    Explanation: The only move possible is from the single cell itself, resulting in one move.\n\n    Edge Case 2: A board where all cells point to themselves, e.g., n = 2, m = 2, board = ['LL', 'RR']\n    Expected Output: 1 1 1\n    Explanation: Each cell points to itself, so the maximum number of moves is 1 from any starting cell.\n\n    Edge Case 3: A board with a cycle, e.g., n = 2, m = 2, board = ['RD', 'UL']\n    Expected Output: 1 1 4\n    Explanation: Starting from (1,1), the moves are R -> D -> L -> U, forming a cycle with 4 moves.\n\n# [extra code for edge case]\n    We need extra code to handle the detection of cycles during the simulation of movements.\n    Code for handling the edge case:\n    ```python\n    def detect_cycle_and_count_moves(board, start_r, start_c, n", "Round_0": {"code": "def detect_cycle_and_count_moves(board, start_r, start_c, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    visited = {}\n    r, c = start_r, start_c\n    move_count = 0\n    \n    while True:\n        if (r, c) in visited:\n            # Cycle detected\n            return move_count - visited[(r, c)]\n        \n        if r < 0 or r >= n or c < 0 or c >= m:\n            # Out of bounds\n            return move_count\n        \n        visited[(r, c)] = move_count\n        move_count += 1\n        \n        direction = board[r][c]\n        dr, dc = direction_map[direction]\n        r += dr\n        c += dc\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Read blank line\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Check each cell as a starting point\n        for r in range(n):\n            for c in range(m):\n                moves = detect_cycle_and_count_moves(board, r, c, n, m)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 173)"}, "Round_1": {"code": "def detect_cycle_and_count_moves(board, start_r, start_c, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    visited = {}\n    r, c = start_r, start_c\n    move_count = 0\n    \n    while True:\n        if (r, c) in visited:\n            # Cycle detected\n            return move_count - visited[(r, c)]\n        \n        if r < 0 or r >= n or c < 0 or c >= m:\n            # Out of bounds\n            return move_count\n        \n        visited[(r, c)] = move_count\n        move_count += 1\n        \n        direction = board[r][c]\n        dr, dc = direction_map[direction]\n        r += dr\n        c += dc\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Read blank line\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Check each cell as a starting point\n        for r in range(n):\n            for c in range(m):\n                moves = detect_cycle_and_count_moves(board, r, c, n, m)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read integers n and m, followed by n strings each of length m representing the board.\"\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board to determine the maximum number of moves possible from any starting position.\",\n      \"details\": \"For each cell (r, c) on the board, simulate the robot's movement according to the directions ('L', 'R', 'D', 'U') and count the number of moves until the robot exits the board or revisits a cell.\"\n    },\n    {\n      \"description\": \"Identify the starting position (r, c) that allows the maximum number of moves d.\",\n      \"details\": \"Track the maximum number of moves and the corresponding starting position for each test case. If multiple positions yield the same maximum moves, any of them can be chosen.\"\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"details\": \"For each test case, output the integers r, c, and d, representing the starting position and the maximum number of moves.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the dimensions n and m of the board.\",\n    \"  b. Read the n lines of the board configuration.\",\n    \"  c. Initialize variables to track the maximum number of moves and the best starting position.\",\n    \"  d. For each cell (r, c) on the board, simulate the robot's movement and count the moves.\",\n    \"  e. Update the maximum moves and starting position if a new maximum is found.\",\n    \"  f. Store the result for the current test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: The board configuration is a grid of n strings each containing m characters ('L', 'R', 'D', 'U') that represent directions for movement on the board.\n\n    'maximum number of moves'\n    Explanation: This refers to the highest number of moves a robot can make starting from any cell on the board before exiting the board or revisiting a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This means finding the largest possible number of moves the robot can make from a starting position. In code, this involves simulating movements and counting them until a condition is met (exit or revisit).\n\n# [degree adverb]\n    'maximum': This indicates the need to find the highest number of moves possible. In code, this is implemented by keeping track of the maximum count of moves and updating it whenever a higher count is found.\n\n# [code logic]\n    Steps 3 and 4 in the high-level plan should be considered simultaneously:\n    \"For each cell (r, c) on the board, simulate the robot's movement and count the moves.\"\n    \"Update the maximum moves and starting position if a new maximum is found.\"\n    These can be implemented in a single loop where each cell is checked, and the maximum is updated within the same iteration.\n\n# [edge case]\n    Edge Case 1: A board with all cells having the same direction, e.g., 'RRRR' for a 1x4 board.\n    Expected Output: 1 1 4\n    Explanation: The robot can move through all cells in one direction without revisiting any cell.\n\n    Edge Case 2: A board with a single cell, e.g., 'R' for a 1x1 board.\n    Expected Output: 1 1 1\n    Explanation: The robot can only move once before exiting the board.\n\n    Edge Case 3: A board with directions leading to a loop, e.g., 'LR' for a 1x2 board.\n    Expected Output: 1 1 2\n    Explanation: The robot can move from the first cell to the second and back to the first, making two moves before revisiting.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot revisits a cell or exits the board.\n    Code for handling the edge case:\n    ```python\n    def simulate_moves(board, n, m):\n       ", "Round_0": {"code": "def simulate_moves(board, n, m):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            direction = board[r][c]\n            dr, dc = directions[direction]\n            r += dr\n            c += dc\n            moves += 1\n        return moves\n    \n    max_moves = 0\n    best_position = (1, 1)\n    \n    for r in range(n):\n        for c in range(m):\n            moves = move(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_position = (r + 1, c + 1)\n    \n    return best_position[0], best_position[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: simulate_moves() missing 3 required positional arguments: 'board', 'n', and 'm'"}, "Round_1": {"code": "def simulate_moves(board, n, m):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            direction = board[r][c]\n            dr, dc = directions[direction]\n            r += dr\n            c += dc\n            moves += 1\n        return moves\n    \n    max_moves = 0\n    best_position = (1, 1)\n    \n    for r in range(n):\n        for c in range(m):\n            moves = move(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_position = (r + 1, c + 1)\n    \n    return best_position[0], best_position[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read integers n and m, followed by n lines of m characters each representing the board.\"\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board to determine the maximum number of moves possible starting from any cell.\",\n      \"details\": \"For each cell (r, c) on the board, simulate the robot's movement according to the directions ('L', 'R', 'D', 'U') and count the number of moves until the robot exits the board or revisits a cell.\"\n    },\n    {\n      \"description\": \"Identify the starting cell (r, c) that allows the robot to make the maximum number of moves.\",\n      \"details\": \"Track the maximum number of moves and the corresponding starting cell for each test case. If multiple starting cells yield the same maximum number of moves, any of them can be chosen.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, output the starting cell (r, c) and the maximum number of moves d.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the dimensions n and m of the board.\",\n    \"  b. Read the n lines of the board configuration.\",\n    \"  c. Initialize variables to track the maximum number of moves and the corresponding starting cell.\",\n    \"  d. For each cell (r, c) on the board, simulate the robot's movement and count the moves.\",\n    \"  e. Update the maximum moves and starting cell if a new maximum is found.\",\n    \"  f. Store the result for the current test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: The board is represented by a grid of n rows and m columns, where each cell contains a character ('L', 'R', 'D', 'U') indicating the direction the robot should move.\n\n    'maximum number of moves'\n    Explanation: The goal is to determine the starting position on the board that allows the robot to make the most moves before exiting the board or revisiting a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This means we need to find the starting position that results in the highest possible move count.\n    Implementation: Track the number of moves for each starting position and update the maximum when a higher count is found.\n\n# [degree adverb]\n    'maximum': This indicates the need to find the highest number of moves possible.\n    Implementation: Use a variable to keep track of the maximum number of moves and update it whenever a new maximum is found.\n\n# [code logic]\n    Steps 2d and 2e should be implemented simultaneously. \n    Explanation: As you simulate the robot's movement from each cell, you should immediately check and update the maximum number of moves if a new maximum is found. This can be done within the same loop that simulates the movement.\n\n# [edge case]\n    Edge Case 1: A board with only one cell, e.g., n = 1, m = 1, board = ['R']\n    Expected Output: 1 1 1\n    Explanation: The robot can only make one move before exiting the board.\n\n    Edge Case 2: A board where all cells point in a loop, e.g., n = 2, m = 2, board = ['LR', 'RL']\n    Expected Output: Any starting position with 0 moves\n    Explanation: The robot will immediately revisit a cell, resulting in 0 moves.\n\n    Edge Case 3: A board with all cells pointing outwards, e.g., n = 2, m = 2, board = ['RR', 'DD']\n    Expected Output: 1 1 2\n    Explanation: Starting from (1, 1), the robot can make two moves before exiting the board.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot revisits a cell.\n    Code for handling the edge case:\n    ```python\n    def simulate_movement(board, n, m):\n        max_moves =", "Round_0": {"code": "def simulate_movement(board, n, m):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move(r, c):\n        visited = set()\n        moves = 0\n        while 0 <= r < n and 0 <= c < m and (r, c) not in visited:\n            visited.add((r, c))\n            direction = board[r][c]\n            dr, dc = directions[direction]\n            r += dr\n            c += dc\n            moves += 1\n        return moves\n\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = move(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_movement(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: simulate_movement() missing 3 required positional arguments: 'board', 'n', and 'm'"}, "Round_1": {"code": "def simulate_movement(board, n, m):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move(r, c):\n        visited = set()\n        moves = 0\n        while 0 <= r < n and 0 <= c < m and (r, c) not in visited:\n            visited.add((r, c))\n            direction = board[r][c]\n            dr, dc = directions[direction]\n            r += dr\n            c += dc\n            moves += 1\n        return moves\n\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = move(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_movement(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board to determine the starting position that results in the maximum number of moves.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of visited cells and the number of moves made from each starting position.\",\n        \"For each cell (r, c) on the board, simulate the robot's movement according to the directional characters until it either exits the board or revisits a cell.\",\n        \"Count the number of moves made during the simulation for each starting position.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting position that results in the maximum number of moves for each test case.\",\n      \"steps\": [\n        \"Compare the number of moves made from each starting position on the board.\",\n        \"Select the starting position (r, c) that results in the maximum number of moves d.\",\n        \"If there are multiple positions with the same maximum number of moves, select any of them.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"steps\": [\n        \"For each test case, output the integers r, c, and d, which represent the starting position and the maximum number of moves.\",\n        \"Ensure the output format matches the requirement, with each test case's result on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n    \"For each test case, simulate the robot's movement from each cell on the board to determine the maximum number of moves.\",\n    \"Identify the starting position that results in the maximum number of moves for each test case.\",\n    \"Output the results for each test case in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'directional moves'\n    Explanation: The characters 'L', 'R', 'D', 'U' represent left, right, down, and up movements on the board, respectively. The task involves simulating these movements to determine the optimal starting position for maximum moves.\n\n    'maximum number of moves'\n    Explanation: This refers to the highest count of moves a robot can make starting from a specific cell on the board before it either exits the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This means finding the starting position that allows the robot to make the most moves possible. In code, this can be implemented by keeping a counter for moves and updating it whenever a new maximum is found.\n\n# [degree adverb]\n    'maximum': This indicates the need to find the highest possible number of moves. In code, this can be implemented by comparing current move counts and updating the maximum when a higher count is found.\n\n# [code logic]\n    The steps in the subproblem \"Simulate the movement of a robot on the board to determine the starting position that results in the maximum number of moves\" should be implemented simultaneously. Specifically, initializing the data structure, simulating the movement, and counting the moves should be done in a single loop or function to efficiently track and update the state of the board and the robot's path.\n\n# [edge case]\n    Edge Case 1: A board with only one cell, e.g., `1 1 R` = 1 1 1\n    Explanation: The robot can only make one move and then exits the board.\n\n    Edge Case 2: A board where all moves lead back to the starting point, e.g., `2 2 LR RL` = 1 1 4\n    Explanation: The robot will keep revisiting the same cells, resulting in a loop.\n\n    Edge Case 3: A board with all moves leading out of bounds immediately, e.g., `2 2 UU UU` = 1 1 1\n    Explanation: The robot exits the board immediately from any starting position.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot revisits cells or exits the board immediately. This can be managed by using a set to track visited cells and a condition to check if the robot has moved out of bounds.\n\n    ```python\n    def simulate_movement(board, n, m):\n       ", "Round_0": {"code": "def simulate_movement(board, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def move_from(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited:\n            visited.add((r, c))\n            moves += 1\n            dr, dc = direction_map[board[r][c]]\n            r, c = r + dr, c + dc\n            if r < 0 or r >= n or c < 0 or c >= m:\n                break\n        return moves\n\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = move_from(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_movement(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: simulate_movement() missing 3 required positional arguments: 'board', 'n', and 'm'"}, "Round_1": {"code": "def simulate_movement(board, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def move_from(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited:\n            visited.add((r, c))\n            moves += 1\n            dr, dc = direction_map[board[r][c]]\n            r, c = r + dr, c + dc\n            if r < 0 or r >= n or c < 0 or c >= m:\n                break\n        return moves\n\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = move_from(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_movement(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board to determine the starting position that results in the maximum number of moves.\",\n      \"steps\": [\n        \"Initialize variables to track the maximum number of moves and the corresponding starting position.\",\n        \"For each cell (r, c) on the board, simulate the robot's movement according to the direction specified by the character in the cell.\",\n        \"Track the number of moves made by the robot until it exits the board or revisits a cell.\",\n        \"Update the maximum number of moves and the starting position if the current simulation results in more moves.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the starting position (r, c) and the maximum number of moves d.\",\n        \"Ensure the output format matches the specified requirements.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n    \"For each test case, iterate over each cell on the board to simulate the robot's movement and calculate the number of moves.\",\n    \"Track the maximum number of moves and the corresponding starting position for each test case.\",\n    \"Output the starting position and the maximum number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: The board configuration refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the movement directions for the robot.\n\n    'maximum number of moves'\n    Explanation: This means finding the starting position on the board that allows the robot to make the most moves before exiting the board or revisiting a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates the need to find the highest possible count of moves the robot can make from a starting position. In code, this can be implemented by tracking the number of moves for each starting position and updating the maximum when a higher count is found.\n\n# [degree adverb]\n    'maximum': This means the largest possible number of moves. In code, this can be implemented by comparing the current number of moves with the stored maximum and updating the maximum if the current count is higher.\n\n# [code logic]\n    The steps in the second subproblem should be implemented simultaneously:\n    - \"Initialize variables to track the maximum number of moves and the corresponding starting position.\"\n    - \"For each cell (r, c) on the board, simulate the robot's movement according to the direction specified by the character in the cell.\"\n    - \"Track the number of moves made by the robot until it exits the board or revisits a cell.\"\n    - \"Update the maximum number of moves and the starting position if the current simulation results in more moves.\"\n    These steps can be implemented in a single loop that iterates over each cell, simulates the movement, and updates the maximum moves and position.\n\n# [edge case]\n    Test case with smallest board: \n    1 1\n    L\n    Expected output: 1 1 1\n    Explanation: The robot can only make one move before exiting the board.\n\n    Test case with all directions leading out:\n    2 2\n    LR\n    DU\n    Expected output: 1 1 1\n    Explanation: Any starting position results in only one move before exiting the board.\n\n    Test case with revisiting cells:\n    2 2\n    RR\n    LL\n    Expected output: 1 1 2\n    Explanation: Starting at (1,1), the robot moves right to (1,2) and then exits, making 2 moves.\n\n# [extra code for edge case]\n    We do not need extra code to handle", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip the blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Directions mapping\n        direction_map = {\n            'L': (0, -1),\n            'R': (0, 1),\n            'U': (-1, 0),\n            'D': (1, 0)\n        }\n        \n        # Function to simulate the robot's movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n                visited.add((r, c))\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r += dr\n                c += dc\n                moves += 1\n            return moves\n        \n        # Find the starting position with the maximum moves\n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 167)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip the blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Directions mapping\n        direction_map = {\n            'L': (0, -1),\n            'R': (0, 1),\n            'U': (-1, 0),\n            'D': (1, 0)\n        }\n        \n        # Function to simulate the robot's movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n                visited.add((r, c))\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r += dr\n                c += dc\n                moves += 1\n            return moves\n        \n        # Find the starting position with the maximum moves\n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, false, true, true, false, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 554, "prompt": "The input should consist of an integer n and an integer m, followed by a sequence of n strings each containing m characters ('L', 'R', 'D', 'U'), representing the board configuration.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "mutate_method": "add_1_sentence_at_end", "save_node": true, "parent_index": 38}
