{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "repair_prompt": ["On the great island of Baltia, there live N individuals, numbered from 1 to N. There are precisely M pairs of people who are mutual friends. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful, as in Baltia a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "On the great island of Baltia, there live N individuals, numbered from 1 to N. There are precisely M pairs of people who are mutual friends. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is. When the party is successful, it must adhere to these rules. As in Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "On the great island of Baltia, there live N individuals, numbered from 1 to N. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful, as in Baltia a party is a gathering of exactly 5 people, with the party considered successful if either all the people are friends with each other or no two people are friends. There are precisely M pairs of people who are mutual friends. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Edge case: If M == 0, any group of 5 people will satisfy the condition of no two people being friends\n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    \n    # Edge case: If M > 10 for 5 people, it's impossible for all to be friends or none to be friends\n    if N == 5 and M > 10:\n        print(\"-1\")\n        return\n    \n    # Generate all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(\"-1\")\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["from itertools import combinations\nimport sys\n\ndef successful_party(N, M, friendships):\n    # Create an adjacency list to represent friendships\n    friends = {i: set() for i in range(1, N+1)}\n    for u, v in friendships:\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N+1), 5):\n        all_friends = True\n        no_friends = True\n        \n        # Check if all are friends or none are friends\n        for i in range(5):\n            for j in range(i+1, 5):\n                if combo[j] in friends[combo[i]]:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        # If either condition is satisfied, return the combination\n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    # If no successful party is found, return -1\n    print(-1)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    friendships = []\n    \n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.append((u, v))\n        index += 2\n    \n    successful_party(N, M, friendships)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def successful_party():\n    import sys\n    input = sys.stdin.read\n    from itertools import combinations\n\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    if M >= (N * (N - 1)) // 2 - 1 and N >= 5:\n        print(\"1 2 3 4 5\")\n        return\n\n    friendships = data[2:]\n    graph = {i: set() for i in range(1, N + 1)}\n    \n    for i in range(M):\n        u = int(friendships[2 * i])\n        v = int(friendships[2 * i + 1])\n        graph[u].add(v)\n        graph[v].add(u)\n\n    # Check for a clique of size 5\n    for comb in combinations(range(1, N + 1), 5):\n        if all(v in graph[u] for u, v in combinations(comb, 2)):\n            print(\" \".join(map(str, comb)))\n            return\n\n    # Check for an independent set of size 5\n    for comb in combinations(range(1, N + 1), 5):\n        if all(v not in graph[u] for u, v in combinations(comb, 2)):\n            print(\" \".join(map(str, comb)))\n            return\n\n    print(\"-1\")\n\nsuccessful_party()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        # Check if all are friends\n        all_friends = True\n        no_friends = True\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    if M >= (N * (N - 1)) // 2 - 1:\n        print(\"-1\")\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(\"-1\")\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    elif M >= (N * (N - 1)) // 2:\n        print(\"-1\")\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(\"-1\")\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        U_i = int(data[index])\n        V_i = int(data[index + 1])\n        friendships.append((U_i, V_i))\n        index += 2\n    \n    # Edge case handling\n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    elif M >= (N * (N - 1)) // 2:\n        print(\"1 2 3 4 5\")\n        return\n    \n    # Create adjacency list for the graph\n    from collections import defaultdict\n    graph = defaultdict(set)\n    for u, v in friendships:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Function to find a clique of size 5\n    def find_clique_of_size_5():\n        for node in graph:\n            if len(graph[node]) >= 4:\n                neighbors = list(graph[node])\n                for i in range(len(neighbors)):\n                    for j in range(i + 1, len(neighbors)):\n                        for k in range(j + 1, len(neighbors)):\n                            for l in range(k + 1, len(neighbors)):\n                                if (neighbors[i] in graph[neighbors[j]] and\n                                    neighbors[i] in graph[neighbors[k]] and\n                                    neighbors[i] in graph[neighbors[l]] and\n                                    neighbors[j] in graph[neighbors[k]] and\n                                    neighbors[j] in graph[neighbors[l]] and\n                                    neighbors[k] in graph[neighbors[l]]):\n                                    return [node, neighbors[i], neighbors[j], neighbors[k], neighbors[l]]\n        return None\n    \n    # Function to find an independent set of size 5\n    def find_independent_set_of_size_5():\n        all_nodes = set(range(1, N + 1))\n        for node in graph:\n            non_neighbors = all_nodes - graph[node] - {node}\n            if len(non_neighbors) >= 4:\n                non_neighbors = list(non_neighbors)\n                return [node] + non_neighbors[:4]\n        return None\n    \n    # Check for clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    if M >= (N * (N - 1)) // 2 - 1:\n        print(\"-1\")\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    def is_successful_party(group):\n        all_friends = True\n        no_friends = True\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (group[i], group[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        return all_friends or no_friends\n    \n    for group in combinations(range(1, N + 1), 5):\n        if is_successful_party(group):\n            print(\" \".join(map(str, group)))\n            return\n    \n    print(\"-1\")\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        index += 2\n        friendships.add((U, V))\n        friendships.add((V, U))\n    \n    # Generate all combinations of 5 individuals\n    for group in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        # Check if all are mutual friends or none are friends\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (group[i], group[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, group)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check all combinations of 5 individuals\n    for combo in combinations(range(1, N + 1), 5):\n        # Check if all are friends (clique)\n        all_friends = all((combo[i], combo[j]) in friendships for i in range(5) for j in range(i + 1, 5))\n        \n        # Check if none are friends (independent set)\n        no_friends = all((combo[i], combo[j]) not in friendships for i in range(5) for j in range(i + 1, 5))\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Edge case: If M == 0, any group of 5 people will satisfy the condition of no two people being friends\n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    \n    # Edge case: If M > 10 for 5 people, it's impossible for all to be friends or none to be friends\n    if N == 5 and M > 10:\n        print(\"-1\")\n        return\n    \n    # Generate all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(\"-1\")\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), the number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a data structure to represent the friendship relationships, such as an adjacency list or adjacency matrix.\",\n      \"output\": \"A data structure that efficiently represents friendships between individuals.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 people from the N individuals.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each combination of 5 people, check if they form a successful party according to the rules: either all are friends or none are friends.\",\n      \"output\": \"A boolean indicating whether a successful party is possible for each combination.\"\n    },\n    {\n      \"description\": \"If a successful party is found, output the combination of 5 people. If no successful party is found after checking all combinations, output -1.\",\n      \"output\": \"The indices of 5 people forming a successful party or -1 if no such party exists.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to obtain N, M, and the list of friendship pairs.\",\n    \"Construct a data structure to represent the friendships between individuals.\",\n    \"Generate all possible combinations of 5 people from the N individuals.\",\n    \"For each combination, check if it satisfies the conditions for a successful party.\",\n    \"If a successful party is found, print the combination. If none is found, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party in Baltia is defined as a gathering of exactly 5 people where either all are mutual friends or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals, no more, no less.\n    'no two people are friends': This implies that in one scenario, none of the 5 people should have any friendship connections among them.\n    'all the people are friends': This implies that in another scenario, all 5 people should be mutual friends with each other.\n\n# [degree adverb]\n    'successful': This indicates the condition that must be met for the party to be considered successful, either all are friends or none are friends.\n\n# [code logic]\n    The steps to generate combinations and check for successful parties should be implemented simultaneously. Specifically, generating combinations and checking their friendship status can be done in a single loop to optimize performance.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With 0 friendships, any group of 5 people will satisfy the condition of no two people being friends.\n    \n    Input: 5 10\n    Output: -1\n    Explanation: If there are more than 10 friendships among 5 people, it is impossible for all to be friends or none to be friends.\n    \n    Input: 6 15\n    Output: -1\n    Explanation: With 6 people and 15 friendships, it is impossible to select 5 people such that either all are friends or none are friends.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    - Implement a check for the number of friendships to quickly determine if a successful party is possible without generating all combinations.\n    - Use a graph traversal method to check connectivity among groups of 5 people.\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Edge case: If M == 0, any group of 5 people will satisfy the condition of no two people being friends\n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    \n    # Edge case: If M > 10 for 5 people, it's impossible for all to be friends or none to be friends\n    if N == 5 and M > 10:\n        print(\"-1\")\n        return\n    \n    # Generate all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(\"-1\")\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs (U_i, V_i).\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized.\",\n      \"steps\": [\n        \"Check if there exists a group of 5 people where all are friends with each other.\",\n        \"Check if there exists a group of 5 people where no two are friends.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party is possible, output the 5 individuals.\",\n        \"If no successful party is possible, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Create a data structure to represent the friendships (e.g., adjacency list or matrix).\",\n    \"Implement a function to check for a group of 5 people who are all friends.\",\n    \"Implement a function to check for a group of 5 people who are not friends.\",\n    \"Iterate through possible combinations of 5 individuals to check for successful party conditions.\",\n    \"Output the result based on the checks.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party in this context is defined as a gathering of exactly 5 people where either all are mutual friends or none are friends with each other.\n\n    'mutual friends'\n    Explanation: Mutual friends mean that each person in the group of 5 is friends with every other person in that group.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the group must consist of precisely 5 individuals, no more, no less.\n    'no two people are friends': This means that in one scenario, none of the 5 people should have a friendship link with any other in the group.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps to check for a group of 5 people who are all friends and the steps to check for a group of 5 people who are not friends should be considered simultaneously. This can be done by iterating through all possible combinations of 5 individuals and checking both conditions in a single loop.\n\n# [edge case] \n    1. Input: 5 0\n       Output: 1 2 3 4 5\n       Explanation: With 0 friendships, any group of 5 people will have no mutual friends, satisfying the condition for a successful party.\n       \n    2. Input: 5 10\n       Output: 1 2 3 4 5\n       Explanation: With maximum friendships, any group of 5 people will all be mutual friends, satisfying the condition for a successful party.\n       \n    3. Input: 6 15\n       Output: -1\n       Explanation: If all possible pairs are friends, then it's impossible to have a group of 5 where no two are friends, and if no group of 5 can be found where all are friends, the output should be -1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should iterate through all combinations of 5 individuals and check both conditions (all friends or no friends) for each combination.\n    ```python\n    from itertools import combinations\n\n    def successful_party(N, M, friendships):\n        # Create an adjacency matrix or list\n        friends = {i: set() for i in range(1, N+1)}\n        for u, v in friendships:\n            friends[u].add(v)\n            friends[v].add(u", "Round_0": {"code": "from itertools import combinations\nimport sys\n\ndef successful_party(N, M, friendships):\n    # Create an adjacency list to represent friendships\n    friends = {i: set() for i in range(1, N+1)}\n    for u, v in friendships:\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N+1), 5):\n        all_friends = True\n        no_friends = True\n        \n        # Check if all are friends or none are friends\n        for i in range(5):\n            for j in range(i+1, 5):\n                if combo[j] in friends[combo[i]]:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        # If either condition is satisfied, return the combination\n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    # If no successful party is found, return -1\n    print(-1)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    friendships = []\n    \n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.append((u, v))\n        index += 2\n    \n    successful_party(N, M, friendships)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where all 5 people are mutual friends.\",\n      \"steps\": [\n        \"Create a graph representation using adjacency lists or matrices.\",\n        \"Check for cliques of size 5 in the graph where all nodes are connected.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where no two people are friends.\",\n      \"steps\": [\n        \"Check for a set of 5 nodes in the graph where no edges exist between them.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, output the 5 individuals.\",\n        \"If no configuration is found, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Construct a graph representation of the friendships.\",\n    \"Search for a clique of size 5 where all individuals are mutual friends.\",\n    \"Search for a set of 5 individuals where no two are friends.\",\n    \"Output the result based on the successful party configuration found.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: In the context of the requirement, a successful party is defined as a gathering of exactly 5 people where either all are mutual friends or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals, no more, no less.\n    'all the people at the party are friends with each other': This implies a complete subgraph (clique) of 5 nodes in the graph.\n    'no two people at the party are friends with each other': This implies an independent set of 5 nodes in the graph.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for checking a clique of size 5 and checking for an independent set of 5 nodes should be considered simultaneously. This is because both conditions need to be checked to determine if a successful party can be organized. The implementation can involve iterating over combinations of 5 people and checking both conditions in a single loop.\n\n# [edge case] \n    1. Input: 5 0\n       Output: 1 2 3 4 5\n       Explanation: With 0 friendships, any 5 people form an independent set.\n    2. Input: 5 10\n       Output: 1 2 3 4 5\n       Explanation: With all possible friendships (complete graph), any 5 people form a clique.\n    3. Input: 6 15\n       Output: -1\n       Explanation: If the graph is a complete graph of 6 nodes, no independent set of 5 nodes exists.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - For the case where M = 0, we can directly return the first 5 individuals.\n    - For the case where M is large enough to form a complete graph, we can directly return the first 5 individuals if N >= 5.\n\n```python\ndef successful_party(N, M, friendships):\n    if M == 0:\n        return list(range(1, 6))\n    if M >= (N * (N - 1)) // 2 - 1 and N >= 5:\n        return list(range(1, 6))\n    # Original logic to find cliques or independent sets\n```\n\nYES", "Round_0": {"code": "def successful_party():\n    import sys\n    input = sys.stdin.read\n    from itertools import combinations\n\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    if M >= (N * (N - 1)) // 2 - 1 and N >= 5:\n        print(\"1 2 3 4 5\")\n        return\n\n    friendships = data[2:]\n    graph = {i: set() for i in range(1, N + 1)}\n    \n    for i in range(M):\n        u = int(friendships[2 * i])\n        v = int(friendships[2 * i + 1])\n        graph[u].add(v)\n        graph[v].add(u)\n\n    # Check for a clique of size 5\n    for comb in combinations(range(1, N + 1), 5):\n        if all(v in graph[u] for u, v in combinations(comb, 2)):\n            print(\" \".join(map(str, comb)))\n            return\n\n    # Check for an independent set of size 5\n    for comb in combinations(range(1, N + 1), 5):\n        if all(v not in graph[u] for u, v in combinations(comb, 2)):\n            print(\" \".join(map(str, comb)))\n            return\n\n    print(\"-1\")\n\nsuccessful_party()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def successful_party():\n    import sys\n    input = sys.stdin.read\n    from itertools import combinations\n\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    if M >= (N * (N - 1)) // 2 - 1 and N >= 5:\n        print(\"1 2 3 4 5\")\n        return\n\n    friendships = data[2:]\n    graph = {i: set() for i in range(1, N + 1)}\n    \n    for i in range(M):\n        u = int(friendships[2 * i])\n        v = int(friendships[2 * i + 1])\n        graph[u].add(v)\n        graph[v].add(u)\n\n    # Check for a clique of size 5\n    for comb in combinations(range(1, N + 1), 5):\n        if all(v in graph[u] for u, v in combinations(comb, 2)):\n            print(\" \".join(map(str, comb)))\n            return\n\n    # Check for an independent set of size 5\n    for comb in combinations(range(1, N + 1), 5):\n        if all(v not in graph[u] for u, v in combinations(comb, 2)):\n            print(\" \".join(map(str, comb)))\n            return\n\n    print(\"-1\")\n\nsuccessful_party()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), the number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Check if there exists a group of 5 people who are all friends with each other.\",\n      \"output\": \"A list of 5 people if such a group exists, otherwise continue to the next subproblem.\"\n    },\n    {\n      \"description\": \"Check if there exists a group of 5 people where no two people are friends.\",\n      \"output\": \"A list of 5 people if such a group exists, otherwise return -1.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to get N, M, and the list of friendship pairs.\",\n    \"Create a graph representation of the friendships using an adjacency list or matrix.\",\n    \"Iterate over all possible combinations of 5 people from the N individuals.\",\n    \"For each combination, check if all 5 people are friends with each other by verifying the adjacency list/matrix.\",\n    \"If a fully connected group of 5 is found, print the group and terminate.\",\n    \"If no fully connected group is found, check for a group of 5 people where no two are friends by ensuring no edges exist between any pair in the combination.\",\n    \"If such a group is found, print the group and terminate.\",\n    \"If neither condition is met for any combination, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: In the context of the requirement, a successful party is defined as a gathering of exactly 5 people where either all are mutual friends or none are friends with each other.\n\n    'mutual friends'\n    Explanation: This means that if person A is friends with person B, then person B is also friends with person A.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the group must consist of precisely 5 individuals, no more, no less.\n    'all the people are friends with each other': This implies a complete subgraph of 5 nodes in graph terms.\n    'no two people are friends': This implies an independent set of 5 nodes in graph terms.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps to check for a fully connected group of 5 and a group of 5 with no connections should be considered simultaneously. This can be done by iterating over all combinations of 5 people and checking both conditions in the same loop.\n\n# [edge case]\n    1. Input: 5 0\n       Output: 1 2 3 4 5\n       Explanation: With 5 people and no friendships, any group of 5 people will have no mutual friends, satisfying the condition for a successful party.\n    \n    2. Input: 5 10\n       Output: 1 2 3 4 5\n       Explanation: With 5 people and all possible friendships (10 pairs), any group of 5 people will be fully connected, satisfying the condition for a successful party.\n    \n    3. Input: 6 15\n       Output: -1\n       Explanation: With 6 people and all possible friendships (15 pairs), it is impossible to find a group of 5 people where no two are friends.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all combinations of 5 people and checking both conditions will naturally handle these cases.\n\nNO", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        # Check if all are friends\n        all_friends = True\n        no_friends = True\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 74)"}, "Round_1": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        # Check if all are friends\n        all_friends = True\n        no_friends = True\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), the number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"A list of friendships and the total number of individuals.\"\n    },\n    {\n      \"description\": \"Model the friendships as a graph where each individual is a node and each friendship is an edge.\",\n      \"output\": \"A graph representation of the friendships.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 individuals from the total N individuals.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if all individuals are mutual friends or if no two individuals are friends.\",\n      \"output\": \"A boolean indicating whether a successful party configuration is found.\"\n    },\n    {\n      \"description\": \"If a successful party configuration is found, output the 5 individuals. If none is found after checking all combinations, output -1.\",\n      \"output\": \"The indices of the 5 individuals or -1 if no successful party is possible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to get N, M, and the list of friendship pairs.\",\n    \"Construct a graph using the friendship pairs.\",\n    \"Generate all possible combinations of 5 individuals from the N individuals.\",\n    \"For each combination, check if it satisfies the successful party conditions: either all are mutual friends or none are friends.\",\n    \"If a valid combination is found, print the indices of the 5 individuals. If no valid combination is found, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: In the context of the requirement, a successful party is defined as a gathering of exactly 5 people where either all are mutual friends or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals, no more, no less.\n    'all the people at the party are friends with each other': This implies a complete subgraph of 5 nodes in graph terms.\n    'no two people at the party are friends with each other': This implies an independent set of 5 nodes in graph terms.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Generate all possible combinations of 5 individuals from the N individuals\" and \"For each combination, check if it satisfies the successful party conditions\" should be implemented simultaneously. This can be done by iterating over each combination and checking the conditions in the same loop.\n\n# [edge case]\n    1. Input: 5 0\n       Output: 1 2 3 4 5\n       Explanation: With 0 friendships, any 5 people form a successful party as no two are friends.\n    2. Input: 5 10\n       Output: -1\n       Explanation: With 10 friendships among 5 people, all must be friends with each other, which is impossible as it exceeds the number of possible unique pairs.\n    3. Input: 6 15\n       Output: -1\n       Explanation: With 15 friendships, all possible pairs among 6 people are friends, making it impossible to have a group of 5 where no two are friends.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Specifically, we need to handle the case where M = 0, as any group of 5 will satisfy the condition of no two being friends.\n    - Additionally, we should handle the case where M is large enough that it implies all possible pairs are friends, making it impossible to have a group of 5 where no two are friends.\n\n```python\nif M == 0:\n    print(\"1 2 3 4 5\")\n    return\nif M >= (N * (N - 1)) // 2 - 1:\n    print(\"-1\")\n    return\n```\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    if M >= (N * (N - 1)) // 2 - 1:\n        print(\"-1\")\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(\"-1\")\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), the number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph data structure representing friendships among individuals.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 individuals from the total N individuals.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if all individuals are mutual friends or if no two individuals are friends.\",\n      \"output\": \"A boolean indicating whether a successful party configuration is found.\"\n    },\n    {\n      \"description\": \"If a successful party configuration is found, return the combination. If none is found after checking all combinations, return -1.\",\n      \"output\": \"A list of 5 individuals for a successful party or -1 if impossible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendship pairs.\",\n    \"Construct a graph to represent friendships using the input data.\",\n    \"Generate all possible combinations of 5 individuals from the N individuals.\",\n    \"For each combination, check if it satisfies the conditions for a successful party: either all are mutual friends or none are friends.\",\n    \"If a valid combination is found, output the combination. If no valid combination is found after checking all, output -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party in this context is defined as a gathering of exactly 5 people where either all are mutual friends or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals, no more, no less.\n    'all the people at the party are friends with each other': This implies a complete subgraph of 5 nodes in graph terms.\n    'no two people at the party are friends with each other': This implies an independent set of 5 nodes in graph terms.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Generate all possible combinations of 5 individuals from the N individuals\" and \"For each combination, check if it satisfies the conditions for a successful party\" should be implemented simultaneously. This can be done by iterating over each combination and checking the conditions in the same loop.\n\n# [edge case]\n    1. Input: 5 0\n       Output: 1 2 3 4 5\n       Explanation: With 0 friendships, any 5 people form a successful party as no two are friends.\n    2. Input: 5 10\n       Output: -1\n       Explanation: With 10 friendships among 5 people, all must be friends with each other, but this is impossible as it exceeds the number of possible unique pairs.\n    3. Input: 6 15\n       Output: -1\n       Explanation: With 15 friendships, all 6 people are friends with each other, but we need exactly 5 for a party.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Specifically, we need to handle the case where M = 0, as any 5 people can form a successful party.\n    - Additionally, we need to handle the case where M is such that all possible pairs are friends, which might require checking the number of friendships against the maximum possible for 5 people.\n\n```python\nif M == 0:\n    print(\"1 2 3 4 5\")\n    return\nelif M >= (N * (N - 1)) // 2:\n    print(\"-1\")\n    return\n```\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    elif M >= (N * (N - 1)) // 2:\n        print(\"-1\")\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(\"-1\")\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Check if there exists a group of 5 individuals where all are mutual friends.\",\n      \"output\": \"A list of 5 individuals if such a group exists, otherwise null.\"\n    },\n    {\n      \"description\": \"Check if there exists a group of 5 individuals where no two are friends.\",\n      \"output\": \"A list of 5 individuals if such a group exists, otherwise null.\"\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized based on the results of the previous subproblems.\",\n      \"output\": \"A list of 5 individuals for a successful party or -1 if it's impossible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to obtain N, M, and the list of friendship pairs.\",\n    \"Create a graph representation of friendships using adjacency lists or matrices.\",\n    \"Implement a function to find a clique of size 5 (all mutual friends) in the graph.\",\n    \"Implement a function to find an independent set of size 5 (no mutual friends) in the graph.\",\n    \"Check the results of the clique and independent set functions.\",\n    \"If either function returns a valid list of 5 individuals, print the list.\",\n    \"If neither function returns a valid list, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party in Baltia is defined as a gathering of exactly 5 people where either all are mutual friends or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This indicates that the party must consist of precisely 5 individuals.\n    Implementation: Ensure that any group considered for the party has exactly 5 members.\n\n# [degree adverb]\n    'successful': This means the party must meet one of the two conditions: all mutual friends or no mutual friends.\n    Implementation: Check for either a complete clique of 5 or an independent set of 5 in the graph.\n\n# [code logic]\n    The steps to check for a clique of size 5 and an independent set of size 5 can be implemented simultaneously as they are independent checks. This can be done using separate functions that are called one after the other.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n    \n    Input: 5 10\n    Output: -1\n    Explanation: If all possible pairs are friends, it's impossible to have an independent set of 5.\n    \n    Input: 6 15\n    Output: 1 2 3 4 5\n    Explanation: If all individuals are friends with each other, any group of 5 forms a clique.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling the edge case:\n    ```python\n    if M == 0:\n        print(\"1 2 3 4 5\")\n    elif M >= (N * (N - 1)) // 2:\n        print(\"1 2 3 4 5\")\n    else:\n        # Original logic to find clique or independent set\n    ```\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        U_i = int(data[index])\n        V_i = int(data[index + 1])\n        friendships.append((U_i, V_i))\n        index += 2\n    \n    # Edge case handling\n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    elif M >= (N * (N - 1)) // 2:\n        print(\"1 2 3 4 5\")\n        return\n    \n    # Create adjacency list for the graph\n    from collections import defaultdict\n    graph = defaultdict(set)\n    for u, v in friendships:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Function to find a clique of size 5\n    def find_clique_of_size_5():\n        for node in graph:\n            if len(graph[node]) >= 4:\n                neighbors = list(graph[node])\n                for i in range(len(neighbors)):\n                    for j in range(i + 1, len(neighbors)):\n                        for k in range(j + 1, len(neighbors)):\n                            for l in range(k + 1, len(neighbors)):\n                                if (neighbors[i] in graph[neighbors[j]] and\n                                    neighbors[i] in graph[neighbors[k]] and\n                                    neighbors[i] in graph[neighbors[l]] and\n                                    neighbors[j] in graph[neighbors[k]] and\n                                    neighbors[j] in graph[neighbors[l]] and\n                                    neighbors[k] in graph[neighbors[l]]):\n                                    return [node, neighbors[i], neighbors[j], neighbors[k], neighbors[l]]\n        return None\n    \n    # Function to find an independent set of size 5\n    def find_independent_set_of_size_5():\n        all_nodes = set(range(1, N + 1))\n        for node in graph:\n            non_neighbors = all_nodes - graph[node] - {node}\n            if len(non_neighbors) >= 4:\n                non_neighbors = list(non_neighbors)\n                return [node] + non_neighbors[:4]\n        return None\n    \n    # Check for clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 64)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        U_i = int(data[index])\n        V_i = int(data[index + 1])\n        friendships.append((U_i, V_i))\n        index += 2\n    \n    # Edge case handling\n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    elif M >= (N * (N - 1)) // 2:\n        print(\"1 2 3 4 5\")\n        return\n    \n    # Create adjacency list for the graph\n    from collections import defaultdict\n    graph = defaultdict(set)\n    for u, v in friendships:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Function to find a clique of size 5\n    def find_clique_of_size_5():\n        for node in graph:\n            if len(graph[node]) >= 4:\n                neighbors = list(graph[node])\n                for i in range(len(neighbors)):\n                    for j in range(i + 1, len(neighbors)):\n                        for k in range(j + 1, len(neighbors)):\n                            for l in range(k + 1, len(neighbors)):\n                                if (neighbors[i] in graph[neighbors[j]] and\n                                    neighbors[i] in graph[neighbors[k]] and\n                                    neighbors[i] in graph[neighbors[l]] and\n                                    neighbors[j] in graph[neighbors[k]] and\n                                    neighbors[j] in graph[neighbors[l]] and\n                                    neighbors[k] in graph[neighbors[l]]):\n                                    return [node, neighbors[i], neighbors[j], neighbors[k], neighbors[l]]\n        return None\n    \n    # Function to find an independent set of size 5\n    def find_independent_set_of_size_5():\n        all_nodes = set(range(1, N + 1))\n        for node in graph:\n            non_neighbors = all_nodes - graph[node] - {node}\n            if len(non_neighbors) >= 4:\n                non_neighbors = list(non_neighbors)\n                return [node] + non_neighbors[:4]\n        return None\n    \n    # Check for clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), the number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph data structure representing friendships.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 individuals from the N individuals.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if all individuals are mutual friends or if no two individuals are friends.\",\n      \"output\": \"A boolean indicating whether a successful party configuration is found.\"\n    },\n    {\n      \"description\": \"If a successful party configuration is found, return the combination. If no configuration is found after checking all possibilities, return -1.\",\n      \"output\": \"The indices of the 5 individuals for a successful party or -1 if impossible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendship pairs.\",\n    \"Construct a graph to represent friendships using an adjacency list or matrix.\",\n    \"Generate all possible combinations of 5 individuals from the N individuals.\",\n    \"For each combination, check if it satisfies the conditions for a successful party: either all are mutual friends or none are friends.\",\n    \"If a valid combination is found, print the indices of the 5 individuals. If no valid combination is found, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party in this context is defined as a gathering of exactly 5 people where either all are mutual friends or none are friends with each other.\n\n    'mutual friends'\n    Explanation: Mutual friends mean that every person in the group of 5 is friends with every other person in the group.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals, no more, no less.\n    'all the people': This implies that every individual in the group of 5 must satisfy the friendship condition.\n    'no two people': This means that none of the pairs in the group of 5 should be friends.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Generate all possible combinations of 5 individuals from the N individuals\" and \"For each combination, check if it satisfies the conditions for a successful party\" should be implemented simultaneously. This can be done by iterating over each combination and checking the conditions in the same loop.\n\n# [edge case]\n    1. Input: 5 0\n       Output: 1 2 3 4 5\n       Explanation: With 0 friendships, any group of 5 people will satisfy the condition of no two people being friends.\n       \n    2. Input: 5 10\n       Output: -1\n       Explanation: If every possible pair among 5 people is a friendship, then it's impossible to have a group of 5 where no two are friends.\n       \n    3. Input: 6 15\n       Output: -1\n       Explanation: If every possible pair among 6 people is a friendship, then it's impossible to have a group of 5 where no two are friends.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where M is 0 or M is very large (close to the maximum number of friendships possible among N people).\n    ```python\n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    if M >= (N * (N - 1)) // 2 - 1:\n        print(\"-1\")\n        return\n    ```\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    if M >= (N * (N - 1)) // 2 - 1:\n        print(\"-1\")\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    def is_successful_party(group):\n        all_friends = True\n        no_friends = True\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (group[i], group[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        return all_friends or no_friends\n    \n    for group in combinations(range(1, N + 1), 5):\n        if is_successful_party(group):\n            print(\" \".join(map(str, group)))\n            return\n    \n    print(\"-1\")\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), number of friendships (M), and the list of friendship pairs.\",\n      \"goal\": \"Create data structures to store the individuals and their friendships.\"\n    },\n    {\n      \"description\": \"Identify potential groups of 5 individuals from the list of N individuals.\",\n      \"goal\": \"Generate all possible combinations of 5 individuals.\"\n    },\n    {\n      \"description\": \"Check if a group of 5 individuals is a successful party.\",\n      \"goal\": \"Determine if all individuals in the group are mutual friends or if none are friends with each other.\"\n    },\n    {\n      \"description\": \"Output the result based on the successful party check.\",\n      \"goal\": \"Print the group of 5 individuals if a successful party is possible, otherwise print -1.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to obtain N, M, and the list of friendship pairs.\",\n    \"Store the friendships in a suitable data structure, such as an adjacency list or matrix.\",\n    \"Iterate over all possible combinations of 5 individuals from the list of N individuals.\",\n    \"For each combination, check if all individuals are mutual friends or if none are friends with each other.\",\n    \"If a successful party is found, print the 5 individuals and terminate the program.\",\n    \"If no successful party is found after checking all combinations, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party in this context is defined as a gathering of exactly 5 people where either all are mutual friends or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals, no more, no less.\n    'all the people at the party are friends with each other': This implies a complete subgraph of 5 nodes in graph terms.\n    'no two people at the party are friends with each other': This implies an independent set of 5 nodes in graph terms.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Iterate over all possible combinations of 5 individuals from the list of N individuals\" and \"For each combination, check if all individuals are mutual friends or if none are friends with each other\" should be implemented simultaneously. This can be done by generating combinations and checking the friendship conditions in a single loop.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals will have no mutual friends, thus forming a successful party.\n\n    Input: 5 10\n    Output: -1\n    Explanation: If all possible pairs are friends, then any group of 5 will have all mutual friends, forming a successful party. However, if the input is such that no group of 5 can be formed, the output should be -1.\n\n    Input: 6 15\n    Output: 1 2 3 4 5\n    Explanation: If every possible pair among 6 people is a friendship, any group of 5 will have all mutual friends, thus forming a successful party.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking all combinations of 5 individuals and verifying the friendship conditions will naturally handle these cases.\n\nNO", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        index += 2\n        friendships.add((U, V))\n        friendships.add((V, U))\n    \n    # Generate all combinations of 5 individuals\n    for group in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        # Check if all are mutual friends or none are friends\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (group[i], group[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, group)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs (U_i, V_i).\"\n      ]\n    },\n    {\n      \"description\": \"Model the friendships as a graph where individuals are nodes and friendships are edges.\",\n      \"steps\": [\n        \"Create an adjacency list or adjacency matrix to represent the graph.\"\n      ]\n    },\n    {\n      \"description\": \"Check for a complete subgraph of 5 nodes (clique) where all nodes are friends with each other.\",\n      \"steps\": [\n        \"Iterate over all possible combinations of 5 individuals.\",\n        \"For each combination, check if all pairs within the combination are friends.\"\n      ]\n    },\n    {\n      \"description\": \"Check for a set of 5 nodes where no two nodes are friends with each other.\",\n      \"steps\": [\n        \"Iterate over all possible combinations of 5 individuals.\",\n        \"For each combination, check if no pairs within the combination are friends.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the output based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, print the 5 individuals.\",\n        \"If no successful party configuration is found, print -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Model the friendships as a graph using an adjacency list or matrix.\",\n    \"Check for a complete subgraph of 5 nodes (clique) where all nodes are friends.\",\n    \"Check for a set of 5 nodes where no two nodes are friends.\",\n    \"Output the result based on the findings: either the 5 individuals or -1 if no configuration is possible.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party in this context is defined as a gathering of exactly 5 people where either all are mutual friends (a clique) or none are friends with each other (an independent set).\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals, no more, no less.\n    'all the people at the party are friends with each other': This implies a complete subgraph or clique of 5 nodes.\n    'no two people at the party are friends with each other': This implies an independent set of 5 nodes.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for checking a complete subgraph and an independent set can be implemented simultaneously by iterating over all combinations of 5 individuals and checking both conditions in the same loop. This can be done using a single loop that checks each combination for both conditions.\n\n# [edge case] \n    1. Input: 5 0\n       Output: 1 2 3 4 5\n       Explanation: With 5 people and no friendships, any group of 5 people forms an independent set.\n    2. Input: 5 10\n       Output: 1 2 3 4 5\n       Explanation: With 5 people and all possible friendships, any group of 5 people forms a clique.\n    3. Input: 6 15\n       Output: -1\n       Explanation: With 6 people and all possible friendships, no group of 5 can be an independent set, and if no clique of 5 is found, the output is -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking all combinations of 5 individuals for either a clique or an independent set will naturally handle these cases.\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check all combinations of 5 individuals\n    for combo in combinations(range(1, N + 1), 5):\n        # Check if all are friends (clique)\n        all_friends = all((combo[i], combo[j]) in friendships for i in range(5) for j in range(i + 1, 5))\n        \n        # Check if none are friends (independent set)\n        no_friends = all((combo[i], combo[j]) not in friendships for i in range(5) for j in range(i + 1, 5))\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), the number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a data structure to represent the friendship relationships, such as an adjacency list or adjacency matrix.\",\n      \"output\": \"A data structure that efficiently represents friendships between individuals.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 people from the N individuals.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each combination of 5 people, check if they form a successful party according to the rules: either all are friends or none are friends.\",\n      \"output\": \"A boolean indicating whether a successful party is possible for each combination.\"\n    },\n    {\n      \"description\": \"If a successful party is found, output the combination of 5 people. If no successful party is found after checking all combinations, output -1.\",\n      \"output\": \"The indices of 5 people forming a successful party or -1 if no such party exists.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to obtain N, M, and the list of friendship pairs.\",\n    \"Construct a data structure to represent the friendships between individuals.\",\n    \"Generate all possible combinations of 5 people from the N individuals.\",\n    \"For each combination, check if it satisfies the conditions for a successful party.\",\n    \"If a successful party is found, print the combination. If none is found, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party in Baltia is defined as a gathering of exactly 5 people where either all are mutual friends or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals, no more, no less.\n    'no two people are friends': This implies that in one scenario, none of the 5 people should have any friendship connections among them.\n    'all the people are friends': This implies that in another scenario, all 5 people should be mutual friends with each other.\n\n# [degree adverb]\n    'successful': This indicates the condition that must be met for the party to be considered successful, either all are friends or none are friends.\n\n# [code logic]\n    The steps to generate combinations and check for successful parties should be implemented simultaneously. Specifically, generating combinations and checking their friendship status can be done in a single loop to optimize performance.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With 0 friendships, any group of 5 people will satisfy the condition of no two people being friends.\n    \n    Input: 5 10\n    Output: -1\n    Explanation: If there are more than 10 friendships among 5 people, it is impossible for all to be friends or none to be friends.\n    \n    Input: 6 15\n    Output: -1\n    Explanation: With 6 people and 15 friendships, it is impossible to select 5 people such that either all are friends or none are friends.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    - Implement a check for the number of friendships to quickly determine if a successful party is possible without generating all combinations.\n    - Use a graph traversal method to check connectivity among groups of 5 people.\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Edge case: If M == 0, any group of 5 people will satisfy the condition of no two people being friends\n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    \n    # Edge case: If M > 10 for 5 people, it's impossible for all to be friends or none to be friends\n    if N == 5 and M > 10:\n        print(\"-1\")\n        return\n    \n    # Generate all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(\"-1\")\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 503, "prompt": "On the great island of Baltia, there live N individuals, numbered from 1 to N. There are precisely M pairs of people who are mutual friends. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful, as in Baltia a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 264}
