{"name": "1615_A. Closing The Gap", "description": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\n\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "tags": ["greedy", "math"], "difficulty": 7, "id": 1615, "sample_io": [{"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}], "test_list": [{"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n1 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 3 -1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 0\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 1 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 10 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 5 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 0\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 4\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 0 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 0\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n1 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n24 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 -1 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n24 9 15\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n0 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n36 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 1\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n41 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 10 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 5\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 0 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 9\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n4 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n3 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n1 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n0 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n15 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 0 1 2\n5\n0 2 3 1 0\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 2 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 5 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n4 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 17 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 0 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n4 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 -1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 10\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n13 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 31 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n15 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 0 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n6 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 0 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n1 3 6 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 15\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 2 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 16\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 -1 3\n5\n0 3 6 1 5\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n11 12 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 2 4\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 2\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 0 6 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 1\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 14 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 2 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 14\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n1 3 10 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 19\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n0 0 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n-1 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 1\n5\n0 2 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 7\n", "output": ["0\n1\n0\n"]}], "task_id": "codecontest/119", "repair_prompt": ["There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and in a single day, you can perform an operation to make the buildings look as nice as possible: select two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j). In this operation, you transfer a block from tower i to tower j, effectively decreasing a_i by 1 and increasing a_j by 1. You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and in a single day, you can perform an operation to make the buildings look as nice as possible. You need to select two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j). In this operation, you transfer a block from tower i to tower j. This action effectively decreases a_i by 1 and increases a_j by 1. You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and in a single day, you can perform an operation to make the buildings look as nice as possible: select two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), transferring a block from tower i to tower j, effectively decreasing a_i by 1 and increasing a_j by 1. You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        # Calculate the average height\n        avg_height = total_height // n\n        # If total_height is perfectly divisible by n, we can make all heights equal\n        if total_height % n == 0:\n            results.append(0)\n        else:\n            # Otherwise, the minimum ugliness is 1\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        remainder = total_sum % n\n        # If the remainder is 0, we can make all buildings equal in height\n        # Otherwise, the minimum possible ugliness is 1\n        min_ugliness = 0 if remainder == 0 else 1\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for heights in test_cases:\n        total_sum = sum(heights)\n        n = len(heights)\n        # Calculate the minimum possible ugliness\n        # The minimum ugliness is determined by the remainder when the total sum is divided by n\n        remainder = total_sum % n\n        results.append(remainder)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append(heights)\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        remainder = total_blocks % n\n        \n        # The minimum possible ugliness is determined by the remainder\n        # If remainder is 0, all buildings can be made equal\n        # If remainder is not 0, the minimum ugliness is 1\n        if remainder == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        # Calculate the average height\n        average_height = total_height // n\n        # Calculate the remainder\n        remainder = total_height % n\n        # The minimum possible ugliness is determined by the remainder\n        # If remainder is 0, all buildings can be made equal\n        # If remainder is not 0, the minimum ugliness is 1\n        min_ugliness = 1 if remainder != 0 else 0\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        average_height = total_height // n\n        remainder = total_height % n\n        \n        # Calculate the minimum possible ugliness\n        # We can have `remainder` towers with height `average_height + 1` and the rest with `average_height`\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        average_height = total_height // n\n        remainder = total_height % n\n        \n        # The minimum possible ugliness is determined by the remainder\n        # If remainder is 0, all buildings can be made equal\n        # If remainder is not 0, the minimum ugliness is 1\n        min_ugliness = 1 if remainder != 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_ugliness(heights):\n    total_blocks = sum(heights)\n    n = len(heights)\n    average_height = total_blocks // n\n    remainder = total_blocks % n\n    min_height = average_height\n    max_height = average_height + (1 if remainder > 0 else 0)\n    return max_height - min_height\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        \n        ugliness = calculate_minimum_ugliness(heights)\n        results.append(ugliness)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_ugliness(heights):\n    total_blocks = sum(heights)\n    n = len(heights)\n    average_height = total_blocks // n\n    remainder = total_blocks % n\n    \n    # Create a list of target heights\n    target_heights = [average_height] * n\n    for i in range(remainder):\n        target_heights[i] += 1\n    \n    # Calculate the minimum ugliness\n    min_ugliness = max(target_heights) - min(target_heights)\n    return min_ugliness\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        \n        min_ugliness = calculate_minimum_ugliness(heights)\n        results.append(min_ugliness)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_ugliness(heights):\n    total_sum = sum(heights)\n    n = len(heights)\n    average_height = total_sum // n\n    remainder = total_sum % n\n    \n    # The minimum possible ugliness is determined by the remainder\n    # If remainder is 0, all buildings can be made the same height\n    # If remainder is not 0, the difference will be 1\n    return 1 if remainder != 0 else 0\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        \n        min_ugliness = calculate_minimum_ugliness(heights)\n        results.append(min_ugliness)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        # Calculate the average height\n        avg_height = total_height // n\n        # If total_height is perfectly divisible by n, we can make all heights equal\n        if total_height % n == 0:\n            results.append(0)\n        else:\n            # Otherwise, the minimum ugliness is 1\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the building heights.\",\n        \"Determine the average height by dividing the total sum by the number of buildings, n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of heights around the average height.\",\n        \"Ensure that the difference between the tallest and shortest buildings is minimized.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of building heights and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing the heights to minimize the difference between the tallest and shortest buildings.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': This means we need to find the smallest value of max(a) - min(a) after redistributing the blocks between towers.\n\n# [degree adverb] \n    'minimum': This indicates that we need to achieve the smallest possible difference between the tallest and shortest buildings.\n\n# [code logic]\n    The steps in the plan related to calculating the total sum, determining the average height, and redistributing the heights should be considered simultaneously. Specifically, calculating the average height and redistributing the heights to minimize the difference should be done in a cohesive manner to ensure the logic is correctly implemented.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 10000000]\n    Expected output: 0\n    Explanation: With only two buildings, you can transfer blocks from the taller to the shorter until they are equal.\n\n    Case 2: n = 3, heights = [1, 1, 10000000]\n    Expected output: 0\n    Explanation: You can transfer blocks from the tallest to the other two until all are equal.\n\n    Case 3: n = 4, heights = [1, 1, 1, 10000000]\n    Expected output: 0\n    Explanation: You can distribute blocks from the tallest to the others until all are equal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve the minimum possible ugliness should inherently handle these cases by ensuring the heights are as equal as possible.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        # Calculate the average height\n        avg_height = total_height // n\n        # If total_height is perfectly divisible by n, we can make all heights equal\n        if total_height % n == 0:\n            results.append(0)\n        else:\n            # Otherwise, the minimum ugliness is 1\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the building heights.\",\n        \"Determine the average height by dividing the total sum by n.\",\n        \"Calculate the remainder when the total sum is divided by n.\",\n        \"The minimum possible ugliness is determined by the remainder: if the remainder is 0, the ugliness is 0; otherwise, the ugliness is 1.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the building heights.\",\n    \"Determine the average height and calculate the remainder when the total sum is divided by n.\",\n    \"Based on the remainder, determine the minimum possible ugliness.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the height difference between the tallest and shortest buildings, which is calculated as max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This refers to the smallest value of ugliness that can be achieved after performing any number of operations. In the context of the problem, it is determined by redistributing the blocks to make the heights as equal as possible.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The requirement asks for the smallest possible value of ugliness, which means we need to find the least difference between the tallest and shortest buildings after redistribution.\n\n# [code logic]\n    The steps for calculating the total sum, determining the average height, and calculating the remainder should be considered simultaneously. These calculations are interdependent and can be implemented in a single code block to determine the minimum possible ugliness.\n\n# [edge case]\n    Case 1: n = 2, heights = [1, 1] => Expected output: 0\n    Explanation: Both buildings have the same height, so the ugliness is already 0.\n    \n    Case 2: n = 3, heights = [1, 1, 2] => Expected output: 0\n    Explanation: We can transfer a block from the third building to one of the first two, making all heights equal, resulting in ugliness of 0.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 4] => Expected output: 1\n    Explanation: We can redistribute blocks to make the heights [2, 2, 2, 1], resulting in a minimum ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating the remainder when the total sum is divided by n already accounts for these scenarios.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        remainder = total_sum % n\n        # If the remainder is 0, we can make all buildings equal in height\n        # Otherwise, the minimum possible ugliness is 1\n        min_ugliness = 0 if remainder == 0 else 1\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the total sum by the number of buildings, n.\",\n        \"Calculate the minimum possible ugliness by finding the difference between the maximum and minimum possible heights that can be achieved by redistributing blocks to make the heights as equal as possible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the heights and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to make the heights as equal as possible.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means we need to find the smallest value of max(a) - min(a) after redistributing the blocks among the towers.\n\n# [degree adverb] \n    'minimum'\n    Explanation: We need to achieve the smallest possible difference between the tallest and shortest buildings.\n\n# [code logic]\n    The steps for calculating the total sum of heights and determining the average height should be considered simultaneously. This can be done in one code block where we calculate the sum and average, and then use these values to determine the redistribution strategy.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 1] => Expected output: 0\n    Explanation: Both buildings have the same height, so the ugliness is already 0.\n    \n    Case 2: n = 3, heights = [1, 1, 10] => Expected output: 0\n    Explanation: We can redistribute blocks from the tallest building to the shortest ones to make all heights equal, resulting in an ugliness of 0.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 10] => Expected output: 1\n    Explanation: After redistribution, the closest we can get is [3, 3, 3, 4], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should ensure that redistribution is done optimally to minimize the difference between the tallest and shortest buildings.\n    Example code snippet:\n    ```python\n    for heights in test_cases:\n        total_sum = sum(heights)\n        n = len(heights)\n        average_height = total_sum // n\n        remainder = total_sum % n\n        min_ugliness = (max(heights) - min(heights)) - remainder\n        print(min_ugliness)\n    ```\n\nYES", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for heights in test_cases:\n        total_sum = sum(heights)\n        n = len(heights)\n        average_height = total_sum // n\n        remainder = total_sum % n\n        min_ugliness = remainder\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append(heights)\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 50)"}, "Round_1": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for heights in test_cases:\n        total_sum = sum(heights)\n        n = len(heights)\n        # Calculate the minimum possible ugliness\n        # The minimum ugliness is determined by the remainder when the total sum is divided by n\n        remainder = total_sum % n\n        results.append(remainder)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append(heights)\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total number of blocks across all towers.\",\n        \"Determine the average height by dividing the total number of blocks by the number of towers.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks around the average height.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each test case.\",\n    \"For each test case, calculate the total number of blocks and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to minimize the height difference.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': \n    Explanation: This means finding the smallest value of max(a) - min(a) after redistributing the blocks optimally.\n\n# [degree adverb] \n    'minimum': \n    Explanation: The goal is to achieve the smallest possible difference between the tallest and shortest buildings.\n\n# [code logic]\n    The steps in the plan related to calculating the total number of blocks, determining the average height, and calculating the minimum possible ugliness should be considered simultaneously. This can be done by calculating the total blocks, average height, and then determining the distribution of blocks to minimize the height difference in one logical block of code.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 1] = 0\n    Explanation: The buildings are already of equal height, so the ugliness is 0.\n    \n    Case 2: n = 3, heights = [1, 1, 10] = 0\n    Explanation: By redistributing the blocks, we can make all buildings of equal height, resulting in an ugliness of 0.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 10] = 1\n    Explanation: After redistributing, the closest we can get is [3, 3, 3, 4], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to minimize the height difference will naturally handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        remainder = total_blocks % n\n        \n        # The minimum possible ugliness is determined by the remainder\n        # If remainder is 0, all buildings can be made equal\n        # If remainder is not 0, the minimum ugliness is 1\n        if remainder == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the n space-separated integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the sum by n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks to achieve heights as close to the average as possible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each test case.\",\n    \"For each test case, calculate the sum of the heights and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to achieve heights close to the average.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': This means we need to find the smallest value of max(a) - min(a) after redistributing the blocks.\n\n# [degree adverb] \n    'minimum': This indicates that we need to achieve the smallest possible difference between the tallest and shortest buildings.\n\n# [code logic]\n    The steps to calculate the sum of the heights, determine the average height, and calculate the minimum possible ugliness should be considered simultaneously. This can be done by iterating through the list of building heights, calculating the sum, and then using this sum to determine the average and redistribute blocks to minimize the ugliness.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 1] = 0\n    Explanation: The buildings are already of equal height, so the ugliness is 0.\n    \n    Case 2: n = 3, heights = [1, 1, 10] = 0\n    Explanation: By redistributing blocks, we can make all buildings of height 4, resulting in an ugliness of 0.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 10] = 1\n    Explanation: After redistribution, the closest we can get is [3, 3, 3, 4], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve heights close to the average will naturally handle these cases. \n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        # Calculate the average height\n        average_height = total_height // n\n        # Calculate the remainder\n        remainder = total_height % n\n        # The minimum possible ugliness is determined by the remainder\n        # If remainder is 0, all buildings can be made equal\n        # If remainder is not 0, the minimum ugliness is 1\n        min_ugliness = 1 if remainder != 0 else 0\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the building heights.\",\n        \"Determine the average height by dividing the total sum by the number of buildings, n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks to achieve heights as close to the average as possible.\",\n        \"The minimum ugliness is the difference between the maximum and minimum heights after redistribution.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of building heights and determine the average height.\",\n    \"Redistribute the blocks to minimize the difference between the tallest and shortest buildings.\",\n    \"Calculate the minimum possible ugliness for each test case.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the height difference between the tallest and shortest buildings, formally expressed as max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means finding the smallest possible value of max(a) - min(a) after redistributing the blocks among the towers.\n\n# [degree adverb] \n    'minimum'\n    Explanation: The goal is to achieve the smallest possible difference between the tallest and shortest buildings after redistribution.\n\n# [code logic]\n    The steps for calculating the total sum of building heights and determining the average height should be considered simultaneously. This can be done in one code block where the sum is calculated, and the average is derived immediately after.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 1] => Expected output: 0\n    Explanation: Both buildings have the same height, so the ugliness is already 0.\n    \n    Case 2: n = 3, heights = [1, 1, 10] => Expected output: 0\n    Explanation: Redistribute blocks from the tallest building to the shortest ones to make all heights equal, resulting in ugliness of 0.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 10] => Expected output: 1\n    Explanation: After redistribution, the closest possible heights are [3, 3, 3, 4], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should ensure that redistribution is done optimally to achieve the minimum possible ugliness. This involves iterating over the heights and redistributing blocks until the difference between the maximum and minimum heights is minimized.\n\nYES", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        average_height = total_height // n\n        remainder = total_height % n\n        \n        # Calculate the minimum possible ugliness\n        # We can have `remainder` towers with height `average_height + 1` and the rest with `average_height`\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the total sum by the number of buildings, n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks to achieve heights as close to the average as possible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the heights and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to achieve heights close to the average.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the height difference between the tallest and shortest buildings, formally expressed as max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means finding the smallest value of max(a) - min(a) after redistributing blocks between towers. In code, this involves redistributing blocks to make the heights as equal as possible.\n\n# [degree adverb] \n    'minimum'\n    Explanation: The requirement is asking for the smallest possible value of ugliness, which is the smallest difference between the tallest and shortest buildings after redistribution. In code, this involves iterating through possible redistributions to find the smallest max(a) - min(a).\n\n# [code logic]\n    The steps for calculating the total sum of heights, determining the average height, and redistributing blocks to achieve heights close to the average should be considered simultaneously. This can be implemented in a loop where redistribution is done iteratively until the heights are as equal as possible.\n\n# [edge case] \n    Case 1: All buildings have the same height initially.\n    Input: 3\n           3\n           5 5 5\n    Expected Output: 0\n    Explanation: Since all buildings have the same height, the ugliness is already 0.\n\n    Case 2: Only two buildings with different heights.\n    Input: 1\n           2\n           1 10\n    Expected Output: 0\n    Explanation: You can transfer blocks from the taller building to the shorter one until both have the same height.\n\n    Case 3: Maximum height difference.\n    Input: 1\n           3\n           1 1 10000000\n    Expected Output: 0\n    Explanation: You can transfer blocks from the tallest building to the others until all have the same height.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve equal heights will naturally handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        average_height = total_height // n\n        remainder = total_height % n\n        \n        # The minimum possible ugliness is determined by the remainder\n        # If remainder is 0, all buildings can be made equal\n        # If remainder is not 0, the minimum ugliness is 1\n        min_ugliness = 1 if remainder != 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the sum by the number of buildings, n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks to make the heights as equal as possible.\",\n        \"The minimum ugliness is determined by the difference between the maximum and minimum possible heights after redistribution.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the heights of buildings for each test case.\",\n    \"For each test case, calculate the sum of the heights and determine the average height.\",\n    \"Redistribute the blocks to minimize the height difference between the tallest and shortest buildings.\",\n    \"Calculate the minimum possible ugliness based on the redistribution.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the height difference between the tallest and shortest buildings, formally expressed as max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means we need to find the smallest value of max(a) - min(a) after redistributing the blocks among the towers. In code, this involves redistributing blocks to make the heights as equal as possible.\n\n# [degree adverb] \n    'minimum'\n    Explanation: We need to achieve the smallest possible value for the ugliness, which is the difference between the tallest and shortest buildings after redistribution.\n\n# [code logic]\n    The steps for calculating the sum of heights, determining the average height, and redistributing blocks should be considered simultaneously. This can be implemented in a loop where we calculate the sum, determine the average, and adjust the heights in one go.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 1] = 0\n    Explanation: Both buildings have the same height, so the ugliness is already 0.\n    \n    Case 2: n = 3, heights = [1, 1, 10] = 0\n    Explanation: Redistribute blocks from the tallest building to the shortest ones to make all heights equal, resulting in an ugliness of 0.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 10] = 1\n    Explanation: After redistribution, the heights can be [3, 3, 3, 4], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    ```python\n    def calculate_minimum_ugliness(heights):\n        total_blocks = sum(heights)\n        n = len(heights)\n        average_height = total_blocks // n\n        remainder = total_blocks % n\n        min_height = average_height\n        max_height = average_height + (1 if remainder > 0 else 0)\n        return max_height - min_height\n    ```\n\nYES", "Round_0": {"code": "def calculate_minimum_ugliness(heights):\n    total_blocks = sum(heights)\n    n = len(heights)\n    average_height = total_blocks // n\n    remainder = total_blocks % n\n    min_height = average_height\n    max_height = average_height + (1 if remainder > 0 else 0)\n    return max_height - min_height\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        \n        ugliness = calculate_minimum_ugliness(heights)\n        results.append(ugliness)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the sum by the number of buildings, n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks to achieve heights as close to the average as possible.\",\n        \"The minimum ugliness is the difference between the maximum and minimum heights after redistribution.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the sum of the heights and determine the average height.\",\n    \"Redistribute the blocks to minimize the difference between the tallest and shortest buildings.\",\n    \"Calculate the minimum possible ugliness after redistribution.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the height difference between the tallest and shortest buildings, formally expressed as max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': means finding the smallest value of max(a) - min(a) after redistributing blocks between towers.\n\n# [degree adverb] \n    'minimum': means the smallest possible value of ugliness that can be achieved through redistribution.\n\n# [code logic]\n    The steps for calculating the sum of heights, determining the average height, and redistributing blocks should be considered simultaneously. This involves iterating through the list of building heights, calculating the sum, and then redistributing blocks to achieve heights as close to the average as possible in one logical block.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 1] = 0\n    Explanation: Both buildings have the same height, so the ugliness is already 0.\n    \n    Case 2: n = 3, heights = [1, 1, 10] = 0\n    Explanation: Redistribute blocks from the tallest building to the shortest ones to achieve equal heights, resulting in ugliness of 0.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 10] = 1\n    Explanation: After redistribution, the closest possible equal heights are [3, 3, 3, 4], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    ```python\n    def calculate_minimum_ugliness(heights):\n        total_blocks = sum(heights)\n        n = len(heights)\n        average_height = total_blocks // n\n        remainder = total_blocks % n\n        \n        # Create a list of target heights\n        target_heights = [average_height] * n\n        for i in range(remainder):\n            target_heights[i] += 1\n        \n        # Calculate the minimum ugliness\n        min_ugliness = max(target_heights) - min(target_heights)\n        return min_ugliness\n    ```\n\nYES", "Round_0": {"code": "def calculate_minimum_ugliness(heights):\n    total_blocks = sum(heights)\n    n = len(heights)\n    average_height = total_blocks // n\n    remainder = total_blocks % n\n    \n    # Create a list of target heights\n    target_heights = [average_height] * n\n    for i in range(remainder):\n        target_heights[i] += 1\n    \n    # Calculate the minimum ugliness\n    min_ugliness = max(target_heights) - min(target_heights)\n    return min_ugliness\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        \n        min_ugliness = calculate_minimum_ugliness(heights)\n        results.append(min_ugliness)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the total sum by the number of buildings, n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks to make the heights as equal as possible.\",\n        \"The minimum ugliness is the difference between the maximum and minimum possible heights after redistribution.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each test case.\",\n    \"For each test case, calculate the total sum of the heights and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to equalize the heights as much as possible.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This means we need to find the smallest value of max(a) - min(a) after redistributing the blocks among the towers.\n\n# [degree adverb] \n    'minimum'\n    Explanation: We need to achieve the smallest possible difference between the tallest and shortest buildings.\n\n# [code logic]\n    The steps for calculating the total sum of heights and determining the average height should be considered simultaneously. This can be done in one code block where we calculate the sum and average, and then use these values to determine the redistribution strategy.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 1] = 0\n    Explanation: Both buildings have the same height, so the ugliness is already 0.\n    \n    Case 2: n = 3, heights = [1, 1, 10] = 0\n    Explanation: We can redistribute blocks to make all buildings have the same height, resulting in an ugliness of 0.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 10] = 1\n    Explanation: After redistribution, the closest we can get is [3, 3, 3, 4], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should ensure that after calculating the average height, we redistribute blocks to minimize the difference between the tallest and shortest buildings.\n    ```python\n    def calculate_minimum_ugliness(heights):\n        total_sum = sum(heights)\n        n = len(heights)\n        average_height = total_sum // n\n        remainder = total_sum % n\n        \n        # Redistribute blocks\n        sorted_heights = sorted(heights)\n        for i in range(n):\n            if i < remainder:\n                sorted_heights[i] = average_height + 1\n            else:\n                sorted_heights[i] = average_height\n        \n        return max(sorted_heights) - min(sorted_heights)\n    ```\n\nYES", "Round_0": {"code": "def calculate_minimum_ugliness(heights):\n    total_sum = sum(heights)\n    n = len(heights)\n    average_height = total_sum // n\n    remainder = total_sum % n\n    \n    # The minimum possible ugliness is determined by the remainder\n    # If remainder is 0, all buildings can be made the same height\n    # If remainder is not 0, the difference will be 1\n    return 1 if remainder != 0 else 0\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        \n        min_ugliness = calculate_minimum_ugliness(heights)\n        results.append(min_ugliness)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the building heights.\",\n        \"Determine the average height by dividing the total sum by the number of buildings, n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of heights around the average height.\",\n        \"Ensure that the difference between the tallest and shortest buildings is minimized.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of building heights and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing the heights to minimize the difference between the tallest and shortest buildings.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': This means we need to find the smallest value of max(a) - min(a) after redistributing the blocks between towers.\n\n# [degree adverb] \n    'minimum': This indicates that we need to achieve the smallest possible difference between the tallest and shortest buildings.\n\n# [code logic]\n    The steps in the plan related to calculating the total sum, determining the average height, and redistributing the heights should be considered simultaneously. Specifically, calculating the average height and redistributing the heights to minimize the difference should be done in a cohesive manner to ensure the logic is correctly implemented.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 10000000]\n    Expected output: 0\n    Explanation: With only two buildings, you can transfer blocks from the taller to the shorter until they are equal.\n\n    Case 2: n = 3, heights = [1, 1, 10000000]\n    Expected output: 0\n    Explanation: You can transfer blocks from the tallest to the other two until all are equal.\n\n    Case 3: n = 4, heights = [1, 1, 1, 10000000]\n    Expected output: 0\n    Explanation: You can distribute blocks from the tallest to the others until all are equal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve the minimum possible ugliness should inherently handle these cases by ensuring the heights are as equal as possible.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        # Calculate the average height\n        avg_height = total_height // n\n        # If total_height is perfectly divisible by n, we can make all heights equal\n        if total_height % n == 0:\n            results.append(0)\n        else:\n            # Otherwise, the minimum ugliness is 1\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 525, "prompt": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and in a single day, you can perform an operation to make the buildings look as nice as possible: select two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j). In this operation, you transfer a block from tower i to tower j, effectively decreasing a_i by 1 and increasing a_j by 1. You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 173}
