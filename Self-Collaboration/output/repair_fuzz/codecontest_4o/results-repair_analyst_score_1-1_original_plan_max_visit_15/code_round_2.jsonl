{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "repair_prompt": ["Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\nHelp them, so you can get a portion of the treasure! Implement an efficient approach to handle the queries optimally.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. Each room has a certain illusion rate associated with it, which plays a significant role in the maze's characteristics. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\nHelp them, so you can get a portion of the treasure! Implement an efficient approach to handle the queries optimally.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them, allowing travel between each pair of rooms through several tunnels. The i-th room (1 \u2264 i \u2264 n) has a_i illusion rate, and going from the x-th room to the y-th room requires a tunnel between x and y, with energy cost calculated as max(|a_x + a_y|, |a_x - a_y|), where |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it, and Chanek and Indiana would ask q queries. There are two types of queries to be done: * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure! Implement an efficient approach to handle the queries optimally.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index]) - 1\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    def bfs_path(start, end):\n        queue = deque([start])\n        parent = {start: None}\n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    def calculate_energy(path):\n        total_energy = 0\n        for i in range(len(path) - 1):\n            u = path[i]\n            v = path[i + 1]\n            energy = max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n            total_energy += energy\n        return total_energy\n    \n    output = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        if query_type == 1:\n            c = int(data[index])\n            index += 1\n            illusion_rates[u] = c\n        elif query_type == 2:\n            v = int(data[index]) - 1\n            index += 1\n            path = bfs_path(u, v)\n            energy = calculate_energy(path)\n            output.append(str(energy))\n    \n    sys.stdout.write(\"\\n\".join(output) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Build the tree\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            # Update query\n            c = int(data[index])\n            index += 1\n            illusion_rates[u - 1] = c\n        elif query_type == 2:\n            # Minimum energy query\n            v = int(data[index])\n            index += 1\n            results.append(minimum_energy(tree, illusion_rates, u, v))\n    \n    # Output results for type 2 queries\n    for result in results:\n        print(result)\n\ndef minimum_energy(tree, illusion_rates, start, end):\n    # Dijkstra's algorithm to find the minimum energy path\n    n = len(illusion_rates)\n    energy = [float('inf')] * (n + 1)\n    energy[start] = 0\n    pq = [(0, start)]  # (current_energy, current_node)\n    \n    while pq:\n        current_energy, node = heapq.heappop(pq)\n        \n        if node == end:\n            return current_energy\n        \n        if current_energy > energy[node]:\n            continue\n        \n        for neighbor in tree[node]:\n            energy_cost = max(abs(illusion_rates[node - 1] + illusion_rates[neighbor - 1]),\n                              abs(illusion_rates[node - 1] - illusion_rates[neighbor - 1]))\n            new_energy = current_energy + energy_cost\n            \n            if new_energy < energy[neighbor]:\n                energy[neighbor] = new_energy\n                heapq.heappush(pq, (new_energy, neighbor))\n    \n    return energy[end]\nmain()", "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Build the tree\n    tree = collections.defaultdict(list)\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index]) - 1\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Prepare for LCA\n    parent = [-1] * n\n    depth = [0] * n\n    max_log = 17  # Since n <= 100000, log2(100000) is approximately 17\n    up = [[-1] * (max_log + 1) for _ in range(n)]\n    \n    def dfs(v, p, d):\n        parent[v] = p\n        depth[v] = d\n        up[v][0] = p\n        for i in range(1, max_log + 1):\n            if up[v][i - 1] != -1:\n                up[v][i] = up[up[v][i - 1]][i - 1]\n        for u in tree[v]:\n            if u != p:\n                dfs(u, v, d + 1)\n    \n    dfs(0, -1, 0)\n    \n    def lca(u, v):\n        if depth[u] < depth[v]:\n            u, v = v, u\n        # Bring u and v to the same depth\n        diff = depth[u] - depth[v]\n        for i in range(max_log + 1):\n            if (diff >> i) & 1:\n                u = up[u][i]\n        if u == v:\n            return u\n        for i in range(max_log, -\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = [0] * (n + 1)\n    for i in range(1, n + 1):\n        illusion_rates[i] = int(data[index])\n        index += 1\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        queries.append((query_type, u, v))\n    \n    def update_illusion_rate(room, new_rate):\n        illusion_rates[room] = new_rate\n    \n    def calculate_energy(u, v):\n        # BFS to find the path from u to v\n        queue = deque([(u, 0)])\n        visited = set()\n        visited.add(u)\n        \n        while queue:\n            current, energy_sum = queue.popleft()\n            if current == v:\n                return energy_sum\n            \n            for neighbor in tree[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    energy = max(abs(illusion_rates[current] + illusion_rates[neighbor]), \n                                 abs(illusion_rates[current] - illusion_rates[neighbor]))\n                    queue.append((neighbor, energy_sum + energy))\n    \n    results = []\n    for query_type, u, v in queries:\n        if query_type == 1:\n            update_illusion_rate(u, v)\n        elif query_type == 2:\n            results.append(calculate_energy(u, v))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = [0] * (n + 1)\n    for i in range(1, n + 1):\n        illusion_rates[i] = int(data[index])\n        index += 1\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    queries = []\n    for _ in range(q):\n        t = int(data[index])\n        index += 1\n        u = int(data[index])\n        index += 1\n        v = int(data[index]) if t == 2 else int(data[index])\n        index += 1\n        queries.append((t, u, v))\n    \n    def calculate_energy(a, b):\n        return max(abs(a + b), abs(a - b))\n    \n    def dijkstra(start, end):\n        dist = {i: float('inf') for i in range(1, n + 1)}\n        dist[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            current_dist, current_node = heapq.heappop(pq)\n            \n            if current_dist > dist[current_node]:\n                continue\n            \n            for neighbor in adj[current_node]:\n                energy_cost = calculate_energy(illusion_rates[current_node], illusion_rates[neighbor])\n                distance = current_dist + energy_cost\n                \n                if distance < dist[neighbor]:\n                    dist[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n        \n        return dist[end]\n    \n    results = []\n    for query in queries:\n        t, u, v = query\n        if t == 1:\n            # Update the illusion rate of room u to v\n            illusion_rates[u] = v\n        elif t == 2:\n            # Calculate the minimum energy from room u to room v\n            result = dijkstra(u, v)\n            results.append(result)\n    \n    for result in results:\n        print(result)\nmain()", "def calculate_energy(a_x, a_y):\n    return max(abs(a_x + a_y), abs(a_x - a_y))\n\ndef dfs(tree, node, parent, depth, illusion_rates, energies, depths, parents):\n    depths[node] = depth\n    parents[node] = parent\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            energies[neighbor] = calculate_energy(illusion_rates[node], illusion_rates[neighbor])\n            dfs(tree, neighbor, node, depth + 1, illusion_rates, energies, depths, parents)\n\ndef lca(u, v, depths, parents):\n    if depths[u] < depths[v]:\n        u, v = v, u\n    while depths[u] > depths[v]:\n        u = parents[u]\n    while u != v:\n        u = parents[u]\n        v = parents[v]\n    return u\n\ndef path_energy(u, v, depths, parents, energies):\n    lca_node = lca(u, v, depths, parents)\n    energy = 0\n    while u != lca_node:\n        energy += energies[u]\n        u = parents[u]\n    while v != lca_node:\n        energy += energies[v]\n        v = parents[v]\n    return energy\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = [0] * (n + 1)\n    for i in range(1, n + 1):\n        illusion_rates[i] = int(data[index])\n        index += 1\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        queries.append((query_type, u, v))\n    \n    depths = [0] * (n + 1)\n    parents = [0] * (n + 1)\n    energies =\nmain()", "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = [0] * (n + 1)\n    for i in range(1, n + 1):\n        illusion_rates[i] = int(data[index])\n        index += 1\n    \n    # Build the tree using adjacency list\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Function to calculate energy between two rooms\n    def calculate_energy(x, y):\n        return max(abs(illusion_rates[x] + illusion_rates[y]), abs(illusion_rates[x] - illusion_rates[y]))\n    \n    # Function to find minimum energy path using Dijkstra's algorithm\n    def find_min_energy_path(start, end):\n        # Min-heap priority queue\n        pq = [(0, start)]\n        # Distance array\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        \n        while pq:\n            current_energy, current_room = heapq.heappop(pq)\n            \n            if current_room == end:\n                return current_energy\n            \n            if current_energy > dist[current_room]:\n                continue\n            \n            for neighbor in tree[current_room]:\n                energy_cost = calculate_energy(current_room, neighbor)\n                new_energy = current_energy + energy_cost\n                \n                if new_energy < dist[neighbor]:\n                    dist[neighbor] = new_energy\n                    heapq.heappush(pq, (new_energy, neighbor))\n        \n        return dist[end]\n    \n    # Process each query\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            # Update illusion rate\n            c = int(data[index])\n            index += 1\n            illusion_rates[u] = c\n        elif query_type == 2:\n            # Find minimum energy path\n            v = int(data[index])\n            index += 1\n            min_energy =\nmain()", "import sys\nimport collections\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = collections.defaultdict(list)\n    \n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index]) - 1\n        index += 1\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def calculate_energy(x, y):\n        return max(abs(illusion_rates[x] + illusion_rates[y]), abs(illusion_rates[x] - illusion_rates[y]))\n    \n    def dijkstra(start, end):\n        min_energy = [float('inf')] * n\n        min_energy[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            current_energy, current_room = heapq.heappop(pq)\n            \n            if current_room == end:\n                return current_energy\n            \n            if current_energy > min_energy[current_room]:\n                continue\n            \n            for neighbor in graph[current_room]:\n                energy_cost = calculate_energy(current_room, neighbor)\n                new_energy = current_energy + energy_cost\n                \n                if new_energy < min_energy[neighbor]:\n                    min_energy[neighbor] = new_energy\n                    heapq.heappush(pq, (new_energy, neighbor))\n        \n        return min_energy[end]\n    \n    results = []\n    \n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        \n        if query_type == 1:\n            c = int(data[index])\n            index += 1\n            illusion_rates[u] = c\n        elif query_type == 2:\n            v = int(data[index]) - 1\n            index += 1\n            result = dijkstra(u, v)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nimport collections\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Construct the tree\n    tree = collections.defaultdict(list)\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        tree[u].append(v)\n        tree[v].append(u)\n        index += 2\n    \n    # Function to calculate energy cost between two rooms\n    def energy_cost(x, y):\n        return max(abs(illusion_rates[x] + illusion_rates[y]), abs(illusion_rates[x] - illusion_rates[y]))\n    \n    # Function to find the path and calculate the minimum energy using BFS\n    def bfs_min_energy(start, end):\n        queue = collections.deque([(start, 0)])\n        visited = set()\n        visited.add(start)\n        \n        while queue:\n            current, current_energy = queue.popleft()\n            \n            if current == end:\n                return current_energy\n            \n            for neighbor in tree[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    new_energy = current_energy + energy_cost(current, neighbor)\n                    queue.append((neighbor, new_energy))\n        \n        return float('inf')\n    \n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1]) - 1\n        if query_type == 1:\n            # Update illusion rate\n            c = int(data[index + 2])\n            illusion_rates[u] = c\n            index += 3\n        elif query_type == 2:\n            # Calculate minimum energy\n            v = int(data[index + 2]) - 1\n            min_energy = bfs_min_energy(u, v)\n            results.append(min_energy)\n            index += 3\n    \n    # Output results for type 2 queries\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = collections.defaultdict(list)\n    \n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index]) - 1\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        if query_type == 1:\n            c = int(data[index])\n            index += 1\n            queries.append((query_type, u, c))\n        else:\n            v = int(data[index]) - 1\n            index += 1\n            queries.append((query_type, u, v))\n    \n    # Preprocessing for LCA\n    parent = [-1] * n\n    depth = [0] * n\n    visited = [False] * n\n    \n    def dfs(node, par, dep):\n        parent[node] = par\n        depth[node] = dep\n        visited[node] = True\n        for neighbor in tree[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, node, dep + 1)\n    \n    dfs(0, -1, 0)\n    \n    def lca(u, v):\n        if depth[u] < depth[v]:\n            u, v = v, u\n        while depth[u] > depth[v]:\n            u = parent[u]\n        while u != v:\n            u = parent[u]\n            v = parent[v]\n        return u\n    \n    def calculate_energy(u, v):\n        lca_node = lca(u, v)\n        energy = 0\n        while u != lca_node:\n            energy += max(abs(illusion_rates[u] + illusion_rates[parent[u]]), abs(illusion_rates[u] - illusion_rates[parent[u]]))\n            u = parent[u]\n        while v != lca_node:\n            energy += max(abs(illusion_rates[v] + illusion_rates[parent[v]]\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index]) - 1\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    def bfs_path(start, end):\n        queue = deque([start])\n        parent = {start: None}\n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    def calculate_energy(path):\n        total_energy = 0\n        for i in range(len(path) - 1):\n            u = path[i]\n            v = path[i + 1]\n            energy = max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n            total_energy += energy\n        return total_energy\n    \n    output = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        if query_type == 1:\n            c = int(data[index])\n            index += 1\n            illusion_rates[u] = c\n        elif query_type == 2:\n            v = int(data[index]) - 1\n            index += 1\n            path = bfs_path(u, v)\n            energy = calculate_energy(path)\n            output.append(str(energy))\n    \n    sys.stdout.write(\"\\n\".join(output) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure of the maze.\",\n      \"output\": \"Data structures to store the number of rooms (n), number of queries (q), initial illusion rates (a), and adjacency list for the tree.\"\n    },\n    {\n      \"description\": \"Implement a data structure to efficiently update the illusion rate of a room and to query the minimum energy path between two rooms.\",\n      \"output\": \"A segment tree or similar data structure to handle updates and queries efficiently.\"\n    },\n    {\n      \"description\": \"Develop a function to handle type 1 queries, which update the illusion rate of a specific room.\",\n      \"output\": \"Updated data structure reflecting the new illusion rate for the specified room.\"\n    },\n    {\n      \"description\": \"Develop a function to handle type 2 queries, which calculate the minimum energy required to travel between two rooms.\",\n      \"output\": \"The minimum energy required for the specified path, considering the current illusion rates.\"\n    },\n    {\n      \"description\": \"Implement a traversal algorithm (e.g., DFS or BFS) to find the path between two rooms in the tree structure.\",\n      \"output\": \"The path between the specified rooms as a list of room indices.\"\n    },\n    {\n      \"description\": \"Calculate the energy required for a given path using the formula max(|a_x + a_y|, |a_x - a_y|) for each pair of consecutive rooms.\",\n      \"output\": \"The total energy required for the path.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure.\",\n    \"Initialize a data structure to store and update illusion rates efficiently.\",\n    \"For each query, determine its type and execute the corresponding function:\",\n    \"  - For type 1 queries, update the illusion rate of the specified room.\",\n    \"  - For type 2 queries, find the path between the specified rooms using a tree traversal algorithm.\",\n    \"Calculate the energy required for the path using the given formula and output the result for type 2 queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy calculation when moving between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute sum or absolute difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` function in Python.\n\n# [degree adverb] \n    'minimum sum of energy': This indicates that for type 2 queries, we need to find the path that results in the least total energy expenditure. This can be implemented by calculating the energy for all possible paths and selecting the smallest sum.\n\n# [code logic]\n    The steps for handling type 2 queries (finding the path and calculating energy) should be implemented simultaneously. Specifically, once the path is found using a traversal algorithm, the energy calculation should be done in the same code block to ensure efficiency.\n\n# [edge case] \n    1. Minimum number of rooms: n = 2, q = 1, a = [0, 0], queries = [(2, 1, 2)]\n       Expected output: 0\n       Explanation: With only two rooms and both having an illusion rate of 0, the energy required is 0.\n\n    2. Maximum illusion rate change: n = 3, q = 2, a = [10^9, 10^9, 10^9], queries = [(1, 1, -10^9), (2, 1, 3)]\n       Expected output: 0\n       Explanation: After changing the illusion rate of room 1 to -10^9, the energy between any two rooms with the same illusion rate becomes 0.\n\n    3. Single path with varying rates: n = 3, q = 1, a = [1, -1, 1], queries = [(2, 1", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndef main():\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index]) - 1\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    def bfs_path(start, end):\n        queue = deque([start])\n        parent = {start: None}\n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    def calculate_energy(path):\n        total_energy = 0\n        for i in range(len(path) - 1):\n            u = path[i]\n            v = path[i + 1]\n            energy = max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n            total_energy += energy\n        return total_energy\n    \n    output = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        if query_type == 1:\n            c = int(data[index])\n            index += 1\n            illusion_rates[u] = c\n        elif query_type == 2:\n            v = int(data[index]) - 1\n            index += 1\n            path = bfs_path(u, v)\n            energy = calculate_energy(path)\n            output.append(str(energy))\n    \n    sys.stdout.write(\"\\n\".join(output) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 148)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index]) - 1\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    def bfs_path(start, end):\n        queue = deque([start])\n        parent = {start: None}\n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    def calculate_energy(path):\n        total_energy = 0\n        for i in range(len(path) - 1):\n            u = path[i]\n            v = path[i + 1]\n            energy = max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n            total_energy += energy\n        return total_energy\n    \n    output = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        if query_type == 1:\n            c = int(data[index])\n            index += 1\n            illusion_rates[u] = c\n        elif query_type == 2:\n            v = int(data[index]) - 1\n            index += 1\n            path = bfs_path(u, v)\n            energy = calculate_energy(path)\n            output.append(str(energy))\n    \n    sys.stdout.write(\"\\n\".join(output) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure of the maze.\",\n      \"steps\": [\n        \"Read the number of rooms (n) and number of queries (q).\",\n        \"Read the initial illusion rates for each room.\",\n        \"Read the n-1 tunnels connecting the rooms to form a tree structure.\"\n      ]\n    },\n    {\n      \"description\": \"Implement a data structure to efficiently handle updates and queries on the tree.\",\n      \"steps\": [\n        \"Use a tree representation to store the rooms and tunnels.\",\n        \"Implement a method to update the illusion rate of a specific room.\",\n        \"Implement a method to calculate the minimum energy required to travel between two rooms.\"\n      ]\n    },\n    {\n      \"description\": \"Handle the queries efficiently.\",\n      \"steps\": [\n        \"For type 1 queries, update the illusion rate of the specified room.\",\n        \"For type 2 queries, calculate the minimum energy required to travel from room u to room v using the current illusion rates.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract the necessary information about rooms, tunnels, and queries.\",\n    \"Construct a tree data structure to represent the maze and store the illusion rates.\",\n    \"Implement functions to update illusion rates and calculate energy costs between rooms.\",\n    \"Iterate over the queries, applying updates and calculating energy costs as required.\",\n    \"Output the results for each type 2 query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: In the context of this problem, a tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms). This structure is crucial for efficiently navigating between rooms and handling updates.\n\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy cost of traveling between rooms. It can be updated and is used in the calculation of energy costs.\n\n    'energy'\n    Explanation: The energy required to travel between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates that the energy cost is the maximum of the absolute values of the sum and the difference of the illusion rates of two rooms. In code, this can be implemented using the `max` and `abs` functions.\n\n# [degree adverb] \n    'minimum'\n    Explanation: For type 2 queries, the task is to find the minimum sum of energy needed to travel from one room to another. This involves finding the path with the least energy cost, which can be implemented using algorithms like Dijkstra's or BFS with priority queues.\n\n# [code logic]\n    The steps for handling type 1 and type 2 queries should be implemented separately, as they involve different operations (updating a value vs. calculating a path cost). However, within the type 2 query handling, calculating the energy for each segment of the path should be done simultaneously as part of the pathfinding algorithm.\n\n# [edge case] \n    1. Minimum number of rooms (n=2) and a single query of type 2.\n       Explanation: This tests the basic functionality with the smallest possible tree.\n       Expected output: The energy cost between the two rooms based on their initial illusion rates.\n\n    2. All rooms have the same illusion rate.\n       Explanation: This tests if the algorithm correctly handles uniform values, which should simplify the energy calculations.\n       Expected output: The energy cost should be consistent across any path.\n\n    3. A type 1 query changes the illusion rate to the maximum possible value (10^9).\n       Explanation: This tests the handling of large numbers and ensures that updates are correctly applied.\n       Expected output:", "Round_0": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Build the tree\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            # Update query\n            c = int(data[index])\n            index += 1\n            illusion_rates[u - 1] = c\n        elif query_type == 2:\n            # Minimum energy query\n            v = int(data[index])\n            index += 1\n            results.append(minimum_energy(tree, illusion_rates, u, v))\n    \n    # Output results for type 2 queries\n    for result in results:\n        print(result)\n\ndef minimum_energy(tree, illusion_rates, start, end):\n    # Dijkstra's algorithm to find the minimum energy path\n    n = len(illusion_rates)\n    energy = [float('inf')] * (n + 1)\n    energy[start] = 0\n    pq = [(0, start)]  # (current_energy, current_node)\n    \n    while pq:\n        current_energy, node = heapq.heappop(pq)\n        \n        if node == end:\n            return current_energy\n        \n        if current_energy > energy[node]:\n            continue\n        \n        for neighbor in tree[node]:\n            energy_cost = max(abs(illusion_rates[node - 1] + illusion_rates[neighbor - 1]),\n                              abs(illusion_rates[node - 1] - illusion_rates[neighbor - 1]))\n            new_energy = current_energy + energy_cost\n            \n            if new_energy < energy[neighbor]:\n                energy[neighbor] = new_energy\n                heapq.heappush(pq, (new_energy, neighbor))\n    \n    return energy[end]", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 151)"}, "Round_1": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Build the tree\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            # Update query\n            c = int(data[index])\n            index += 1\n            illusion_rates[u - 1] = c\n        elif query_type == 2:\n            # Minimum energy query\n            v = int(data[index])\n            index += 1\n            results.append(minimum_energy(tree, illusion_rates, u, v))\n    \n    # Output results for type 2 queries\n    for result in results:\n        print(result)\n\ndef minimum_energy(tree, illusion_rates, start, end):\n    # Dijkstra's algorithm to find the minimum energy path\n    n = len(illusion_rates)\n    energy = [float('inf')] * (n + 1)\n    energy[start] = 0\n    pq = [(0, start)]  # (current_energy, current_node)\n    \n    while pq:\n        current_energy, node = heapq.heappop(pq)\n        \n        if node == end:\n            return current_energy\n        \n        if current_energy > energy[node]:\n            continue\n        \n        for neighbor in tree[node]:\n            energy_cost = max(abs(illusion_rates[node - 1] + illusion_rates[neighbor - 1]),\n                              abs(illusion_rates[node - 1] - illusion_rates[neighbor - 1]))\n            new_energy = current_energy + energy_cost\n            \n            if new_energy < energy[neighbor]:\n                energy[neighbor] = new_energy\n                heapq.heappush(pq, (new_energy, neighbor))\n    \n    return energy[end]"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure of the maze.\",\n      \"details\": \"Read the input values and store them in appropriate data structures. Use adjacency lists to represent the tree.\"\n    },\n    {\n      \"description\": \"Implement a function to update the illusion rate of a specific room.\",\n      \"details\": \"For a query of type 1, update the illusion rate of the specified room in the data structure.\"\n    },\n    {\n      \"description\": \"Implement a function to calculate the minimum energy required to travel between two rooms.\",\n      \"details\": \"For a query of type 2, use a tree traversal algorithm (e.g., DFS or BFS) to find the path between the two rooms and calculate the energy required for each segment of the path.\"\n    },\n    {\n      \"description\": \"Optimize the pathfinding and energy calculation for efficiency.\",\n      \"details\": \"Use techniques like precomputing paths, LCA (Lowest Common Ancestor) for efficient pathfinding, and segment trees or binary indexed trees for efficient updates and queries.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure.\",\n    \"Initialize data structures to store the tree and illusion rates.\",\n    \"For each query, determine the type of query.\",\n    \"If the query is of type 1, update the illusion rate of the specified room.\",\n    \"If the query is of type 2, calculate the minimum energy required to travel from the starting room to the destination room using the current illusion rates.\",\n    \"Output the result for each type 2 query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy calculation when moving between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute sum or absolute difference of the illusion rates of two rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum sum of energy': This indicates that the goal is to find the smallest possible total energy required to travel from one room to another. In code, this involves finding the path with the least energy cost.\n\n# [code logic]\n    The steps for handling type 2 queries (calculating minimum energy) should be implemented simultaneously with pathfinding and energy calculation. This can be done using a single traversal algorithm (like DFS or BFS) to find the path and calculate the energy in one go.\n\n# [edge case]\n    1. Minimum number of rooms: n = 2, q = 1, with a single type 2 query from room 1 to room 2.\n       Explanation: This tests the simplest case with the smallest tree.\n       Expected output: The energy required for the direct path between the two rooms.\n\n    2. All rooms have zero illusion rate: n = 5, q = 1, with a type 2 query.\n       Explanation: This tests the case where all illusion rates are zero, resulting in zero energy for any path.\n       Expected output: 0\n\n    3. Maximum illusion rate change: n = 3, q = 1, with a type 1 query changing a room's illusion rate to 10^9.\n       Explanation: This tests the handling of the maximum possible illusion rate change.\n       Expected output: No output for type 1 query, but subsequent type 2 queries should reflect the change.\n\n# [extra code for edge case]\n    We need extra code to", "Round_0": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Build the tree\n    tree = collections.defaultdict(list)\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index]) - 1\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Prepare for LCA\n    parent = [-1] * n\n    depth = [0] * n\n    max_log = 17  # Since n <= 100000, log2(100000) is approximately 17\n    up = [[-1] * (max_log + 1) for _ in range(n)]\n    \n    def dfs(v, p, d):\n        parent[v] = p\n        depth[v] = d\n        up[v][0] = p\n        for i in range(1, max_log + 1):\n            if up[v][i - 1] != -1:\n                up[v][i] = up[up[v][i - 1]][i - 1]\n        for u in tree[v]:\n            if u != p:\n                dfs(u, v, d + 1)\n    \n    dfs(0, -1, 0)\n    \n    def lca(u, v):\n        if depth[u] < depth[v]:\n            u, v = v, u\n        # Bring u and v to the same depth\n        diff = depth[u] - depth[v]\n        for i in range(max_log + 1):\n            if (diff >> i) & 1:\n                u = up[u][i]\n        if u == v:\n            return u\n        for i in range(max_log, -1, -1):\n            if up[u][i] != up[v][i]:\n                u = up[u][i]\n                v = up[v][i]\n        return parent[u]\n    \n    def path_energy(u, v):\n        lca_node = lca(u, v)\n        total_energy = 0\n        \n        # Calculate energy from u to", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 146)"}, "Round_1": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Build the tree\n    tree = collections.defaultdict(list)\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index]) - 1\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Prepare for LCA\n    parent = [-1] * n\n    depth = [0] * n\n    max_log = 17  # Since n <= 100000, log2(100000) is approximately 17\n    up = [[-1] * (max_log + 1) for _ in range(n)]\n    \n    def dfs(v, p, d):\n        parent[v] = p\n        depth[v] = d\n        up[v][0] = p\n        for i in range(1, max_log + 1):\n            if up[v][i - 1] != -1:\n                up[v][i] = up[up[v][i - 1]][i - 1]\n        for u in tree[v]:\n            if u != p:\n                dfs(u, v, d + 1)\n    \n    dfs(0, -1, 0)\n    \n    def lca(u, v):\n        if depth[u] < depth[v]:\n            u, v = v, u\n        # Bring u and v to the same depth\n        diff = depth[u] - depth[v]\n        for i in range(max_log + 1):\n            if (diff >> i) & 1:\n                u = up[u][i]\n        if u == v:\n            return u\n        for i in range(max_log, -"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure of the maze.\",\n      \"steps\": [\n        \"Read the first line to get the number of rooms (n) and number of queries (q).\",\n        \"Read the second line to get the initial illusion rates for each room.\",\n        \"Read the next n-1 lines to construct the tree structure using adjacency lists.\",\n        \"Read the next q lines to store the queries.\"\n      ]\n    },\n    {\n      \"description\": \"Implement a method to update the illusion rate of a specific room based on type 1 queries.\",\n      \"steps\": [\n        \"For a type 1 query, update the illusion rate of the specified room.\"\n      ]\n    },\n    {\n      \"description\": \"Implement a method to calculate the minimum energy required to travel between two rooms based on type 2 queries.\",\n      \"steps\": [\n        \"Use Depth First Search (DFS) or Breadth First Search (BFS) to find the path between the two specified rooms.\",\n        \"Calculate the energy required for each tunnel in the path using the formula max(|a_x + a_y|, |a_x - a_y|).\",\n        \"Sum the energies to get the total energy required for the path.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the solution to handle up to 100,000 queries efficiently.\",\n      \"steps\": [\n        \"Consider using data structures like Segment Trees or Binary Indexed Trees for efficient updates and queries.\",\n        \"Ensure the DFS/BFS traversal is optimized for repeated queries.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data structures for rooms, illusion rates, and tree connections.\",\n    \"Implement a function to handle type 1 queries to update illusion rates.\",\n    \"Implement a function to handle type 2 queries to calculate the minimum energy required using pathfinding algorithms.\",\n    \"Optimize the solution to handle large input sizes efficiently.\",\n    \"Output the results for each type 2 query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy calculation when moving between rooms.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that for each tunnel, the energy required is the maximum of the absolute sum or absolute difference of the illusion rates of the connected rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb] \n    'minimum': In the context of type 2 queries, it refers to finding the path with the least total energy required to travel from room u to room v. This can be implemented by calculating the energy for all possible paths and selecting the smallest sum.\n\n# [code logic]\n    The steps for handling type 1 and type 2 queries should be implemented separately as they serve different purposes. However, within the type 2 query handling, the steps to find the path and calculate the energy should be done simultaneously using a pathfinding algorithm like DFS or BFS.\n\n# [edge case] \n    1. Minimum number of rooms and queries: n = 2, q = 1, with a simple path and a single query.\n       Explanation: This tests the basic functionality with the smallest input size.\n    2. All rooms have the same illusion rate: n = 5, q = 2, all a_i = 0.\n       Explanation: This tests if the code correctly handles cases where the illusion rate does not affect the energy calculation.\n    3. Maximum possible illusion rate change: n = 3, q = 1, with a type 1 query changing a room's illusion rate to 10^9.\n       Explanation: This tests the handling of large numbers and ensures no overflow or performance issues.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, especially for efficiently finding paths and updating illusion rates.\n    - For pathfinding, ensure the DFS/BFS", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = [0] * (n + 1)\n    for i in range(1, n + 1):\n        illusion_rates[i] = int(data[index])\n        index += 1\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        queries.append((query_type, u, v))\n    \n    def update_illusion_rate(room, new_rate):\n        illusion_rates[room] = new_rate\n    \n    def calculate_energy(u, v):\n        # BFS to find the path from u to v\n        queue = deque([(u, 0)])\n        visited = set()\n        visited.add(u)\n        \n        while queue:\n            current, energy_sum = queue.popleft()\n            if current == v:\n                return energy_sum\n            \n            for neighbor in tree[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    energy = max(abs(illusion_rates[current] + illusion_rates[neighbor]), \n                                 abs(illusion_rates[current] - illusion_rates[neighbor]))\n                    queue.append((neighbor, energy_sum + energy))\n    \n    results = []\n    for query_type, u, v in queries:\n        if query_type == 1:\n            update_illusion_rate(u, v)\n        elif query_type == 2:\n            results.append(calculate_energy(u, v))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: main() takes 0 positional arguments but 1 was given"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = [0] * (n + 1)\n    for i in range(1, n + 1):\n        illusion_rates[i] = int(data[index])\n        index += 1\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        queries.append((query_type, u, v))\n    \n    def update_illusion_rate(room, new_rate):\n        illusion_rates[room] = new_rate\n    \n    def calculate_energy(u, v):\n        # BFS to find the path from u to v\n        queue = deque([(u, 0)])\n        visited = set()\n        visited.add(u)\n        \n        while queue:\n            current, energy_sum = queue.popleft()\n            if current == v:\n                return energy_sum\n            \n            for neighbor in tree[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    energy = max(abs(illusion_rates[current] + illusion_rates[neighbor]), \n                                 abs(illusion_rates[current] - illusion_rates[neighbor]))\n                    queue.append((neighbor, energy_sum + energy))\n    \n    results = []\n    for query_type, u, v in queries:\n        if query_type == 1:\n            update_illusion_rate(u, v)\n        elif query_type == 2:\n            results.append(calculate_energy(u, v))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the connections between rooms.\",\n      \"output\": \"Data structures to store the number of rooms, queries, initial illusion rates, and adjacency list for the tree.\"\n    },\n    {\n      \"description\": \"Implement a data structure to efficiently handle updates and queries on the tree structure.\",\n      \"output\": \"A segment tree or similar data structure to manage updates and path queries efficiently.\"\n    },\n    {\n      \"description\": \"Handle type 1 queries to update the illusion rate of a specific room.\",\n      \"output\": \"Update the data structure to reflect the new illusion rate for the specified room.\"\n    },\n    {\n      \"description\": \"Handle type 2 queries to calculate the minimum energy required to travel from room u to room v.\",\n      \"output\": \"Use the data structure to compute the minimum energy path from room u to room v and return the result.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the connections between rooms.\",\n    \"Construct an adjacency list to represent the tree structure of the maze.\",\n    \"Implement a data structure (e.g., segment tree) to efficiently manage updates and path queries on the tree.\",\n    \"For each query, determine its type:\",\n    \"  - If it's a type 1 query, update the illusion rate of the specified room in the data structure.\",\n    \"  - If it's a type 2 query, calculate the minimum energy required to travel from room u to room v using the data structure and output the result.\",\n    \"Ensure the program handles up to 100,000 rooms and queries efficiently, considering the constraints on illusion rates and energy calculations.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. In this problem, the maze is represented as a tree with rooms as nodes and tunnels as edges.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy cost of traveling through tunnels. The illusion rate can be updated through queries.\n\n    'energy cost'\n    Explanation: The energy cost to travel between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates that the energy cost is determined by taking the maximum of the absolute values of the sum and difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` and `abs` functions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: For type 2 queries, the task is to find the minimum sum of energy needed to travel from one room to another. This involves finding the path with the least energy cost. In code, this can be implemented using algorithms like Dijkstra's or BFS/DFS with priority queues.\n\n# [code logic]\n    The steps for handling type 1 and type 2 queries should be implemented in separate code blocks, as they involve different operations (updating a value vs. calculating a path cost). However, the data structure used to manage the tree should support both operations efficiently.\n\n# [edge case]\n    1. Minimum number of rooms and queries: n = 2, q = 1\n       Explanation: This tests the lower bound of the input size. The expected output depends on the specific query.\n    2. All rooms have the same illusion rate: a_i = 0 for all i\n       Explanation: This tests if the program correctly handles cases where the illusion rate does not affect the energy cost.\n    3. Maximum illusion rate change: a_i changes from 0 to 10^9\n       Explanation: This tests if the program can handle large changes in illusion rates without overflow or performance issues.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, especially for efficiently updating and querying the tree structure.\n   ", "Round_0": {"code": "def main():\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = [0] * (n + 1)\n    for i in range(1, n + 1):\n        illusion_rates[i] = int(data[index])\n        index += 1\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    queries = []\n    for _ in range(q):\n        t = int(data[index])\n        index += 1\n        u = int(data[index])\n        index += 1\n        v = int(data[index]) if t == 2 else int(data[index])\n        index += 1\n        queries.append((t, u, v))\n    \n    def calculate_energy(a, b):\n        return max(abs(a + b), abs(a - b))\n    \n    def dijkstra(start, end):\n        dist = {i: float('inf') for i in range(1, n + 1)}\n        dist[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            current_dist, current_node = heapq.heappop(pq)\n            \n            if current_dist > dist[current_node]:\n                continue\n            \n            for neighbor in adj[current_node]:\n                energy_cost = calculate_energy(illusion_rates[current_node], illusion_rates[neighbor])\n                distance = current_dist + energy_cost\n                \n                if distance < dist[neighbor]:\n                    dist[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n        \n        return dist[end]\n    \n    results = []\n    for query in queries:\n        t, u, v = query\n        if t == 1:\n            # Update the illusion rate of room u to v\n            illusion_rates[u] = v\n        elif t == 2:\n            # Calculate the minimum energy from room u to room v\n            result = dijkstra(u, v)\n            results.append(result)\n    \n    for result in results:\n        print(result)", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 114)"}, "Round_1": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = [0] * (n + 1)\n    for i in range(1, n + 1):\n        illusion_rates[i] = int(data[index])\n        index += 1\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    queries = []\n    for _ in range(q):\n        t = int(data[index])\n        index += 1\n        u = int(data[index])\n        index += 1\n        v = int(data[index]) if t == 2 else int(data[index])\n        index += 1\n        queries.append((t, u, v))\n    \n    def calculate_energy(a, b):\n        return max(abs(a + b), abs(a - b))\n    \n    def dijkstra(start, end):\n        dist = {i: float('inf') for i in range(1, n + 1)}\n        dist[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            current_dist, current_node = heapq.heappop(pq)\n            \n            if current_dist > dist[current_node]:\n                continue\n            \n            for neighbor in adj[current_node]:\n                energy_cost = calculate_energy(illusion_rates[current_node], illusion_rates[neighbor])\n                distance = current_dist + energy_cost\n                \n                if distance < dist[neighbor]:\n                    dist[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n        \n        return dist[end]\n    \n    results = []\n    for query in queries:\n        t, u, v = query\n        if t == 1:\n            # Update the illusion rate of room u to v\n            illusion_rates[u] = v\n        elif t == 2:\n            # Calculate the minimum energy from room u to room v\n            result = dijkstra(u, v)\n            results.append(result)\n    \n    for result in results:\n        print(result)"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the connections between rooms.\",\n      \"output\": \"Data structures to store the number of rooms (n), number of queries (q), list of illusion rates (a), and adjacency list for the tree structure.\"\n    },\n    {\n      \"description\": \"Implement a data structure to efficiently handle updates and queries on the tree structure.\",\n      \"output\": \"A segment tree or a similar data structure that supports efficient updates and path queries.\"\n    },\n    {\n      \"description\": \"Handle type 1 queries to update the illusion rate of a specific room.\",\n      \"output\": \"Update the data structure to reflect the new illusion rate for the specified room.\"\n    },\n    {\n      \"description\": \"Handle type 2 queries to calculate the minimum energy required to travel from room u to room v.\",\n      \"output\": \"Use the data structure to compute the minimum energy path between two rooms efficiently.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the connections between rooms.\",\n    \"Construct the tree using an adjacency list to represent the connections between rooms.\",\n    \"Initialize a data structure (e.g., segment tree) to manage the illusion rates and support efficient updates and queries.\",\n    \"For each query, determine its type:\",\n    \"  - If it's a type 1 query, update the illusion rate of the specified room in the data structure.\",\n    \"  - If it's a type 2 query, calculate the minimum energy required to travel from room u to room v using the data structure.\",\n    \"Output the result for each type 2 query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected acyclic graph. In this problem, it represents the maze structure where rooms are nodes and tunnels are edges.\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy calculation when moving between rooms.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute sum or absolute difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum': In the context of type 2 queries, it refers to finding the path with the least energy cost from room u to room v. This can be implemented using algorithms like Dijkstra's or BFS with priority queues to find the shortest path in terms of energy.\n\n# [code logic]\n    The steps for handling type 1 and type 2 queries should be considered separately, as they involve different operations (updating a value vs. calculating a path). However, the initialization of the data structure and parsing of input can be done simultaneously.\n\n# [edge case]\n    1. Minimum number of rooms and queries: n = 2, q = 1\n       Explanation: With only two rooms and one query, the simplest case tests basic functionality.\n       Expected output: Depends on the query type; if type 2, calculate energy between the two rooms.\n\n    2. All illusion rates are zero: a_i = 0 for all i\n       Explanation: This tests if the code correctly handles zero values, which should result in zero energy for any path.\n       Expected output: 0 for any type 2 query.\n\n    3. Maximum illusion rate change: a_i changes from 10^9 to -10^9\n       Explanation: Tests the ability to handle large changes in illusion rates and ensure calculations remain correct.\n       Expected output: Depends on the specific path and updated rates.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, especially for efficiently updating and querying the tree structure.\n", "Round_0": {"code": "def read_input():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = [0] * (n + 1)\n    for i in range(1, n + 1):\n        illusion_rates[i] = int(data[index])\n        index += 1\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        queries.append((query_type, u, v))\n    \n    return n, q, illusion_rates, tree, queries\n\ndef calculate_energy(a_x, a_y):\n    return max(abs(a_x + a_y), abs(a_x - a_y))\n\ndef bfs_min_energy(tree, illusion_rates, start, end):\n    n = len(tree)\n    visited = [False] * n\n    min_energy = [float('inf')] * n\n    min_energy[start] = 0\n    \n    pq = [(0, start)]\n    while pq:\n        current_energy, current_room = heapq.heappop(pq)\n        \n        if visited[current_room]:\n            continue\n        visited[current_room] = True\n        \n        for neighbor in tree[current_room]:\n            if not visited[neighbor]:\n                energy = calculate_energy(illusion_rates[current_room], illusion_rates[neighbor])\n                if min_energy[neighbor] > current_energy + energy:\n                    min_energy[neighbor] = current_energy + energy\n                    heapq.heappush(pq, (min_energy[neighbor], neighbor))\n    \n    return min_energy[end]\n\ndef process_queries(n, q, illusion_rates, tree, queries):\n    results = []\n    for query_type, u, v in queries:\n        if query_type == 1:\n            # Update illusion rate\n            illusion_rates[u] = v\n        elif query_type == 2:\n            # Calculate minimum energy\n            result = bfs", "report": "The compilation output of the preceding code is: 'function' object has no attribute 'read_input'"}, "Round_1": {"code": "def calculate_energy(a_x, a_y):\n    return max(abs(a_x + a_y), abs(a_x - a_y))\n\ndef dfs(tree, node, parent, depth, illusion_rates, energies, depths, parents):\n    depths[node] = depth\n    parents[node] = parent\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            energies[neighbor] = calculate_energy(illusion_rates[node], illusion_rates[neighbor])\n            dfs(tree, neighbor, node, depth + 1, illusion_rates, energies, depths, parents)\n\ndef lca(u, v, depths, parents):\n    if depths[u] < depths[v]:\n        u, v = v, u\n    while depths[u] > depths[v]:\n        u = parents[u]\n    while u != v:\n        u = parents[u]\n        v = parents[v]\n    return u\n\ndef path_energy(u, v, depths, parents, energies):\n    lca_node = lca(u, v, depths, parents)\n    energy = 0\n    while u != lca_node:\n        energy += energies[u]\n        u = parents[u]\n    while v != lca_node:\n        energy += energies[v]\n        v = parents[v]\n    return energy\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = [0] * (n + 1)\n    for i in range(1, n + 1):\n        illusion_rates[i] = int(data[index])\n        index += 1\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        queries.append((query_type, u, v))\n    \n    depths = [0] * (n + 1)\n    parents = [0] * (n + 1)\n    energies ="}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure of the maze.\",\n      \"tasks\": [\n        \"Read the number of rooms (n) and number of queries (q).\",\n        \"Read the initial illusion rates for each room.\",\n        \"Read the n-1 tunnels connecting the rooms to form a tree structure.\"\n      ]\n    },\n    {\n      \"description\": \"Implement a data structure to represent the tree and efficiently handle updates and queries.\",\n      \"tasks\": [\n        \"Use adjacency list to represent the tree structure.\",\n        \"Implement a mechanism to update the illusion rate of a room efficiently.\",\n        \"Implement a mechanism to calculate the minimum energy required to travel between two rooms.\"\n      ]\n    },\n    {\n      \"description\": \"Handle the queries efficiently.\",\n      \"tasks\": [\n        \"For type 1 queries, update the illusion rate of the specified room.\",\n        \"For type 2 queries, calculate the minimum energy required to travel from room u to room v using the current illusion rates.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary information about rooms, queries, and tree structure.\",\n    \"Initialize data structures to represent the tree and store illusion rates.\",\n    \"Implement functions to update illusion rates and calculate energy costs.\",\n    \"Iterate over the queries and execute the appropriate function for each query type.\",\n    \"Output the results for type 2 queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected acyclic graph. In this context, it means that the rooms and tunnels form a structure where there is exactly one path between any two rooms.\n\n    'illusion rate'\n    Explanation: This is a property of each room that affects the energy cost of traveling between rooms. It can be updated and affects the calculation of energy.\n\n    'energy'\n    Explanation: The energy required to travel between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that the energy cost is the maximum of the absolute values of the sum and difference of the illusion rates of two rooms. In code, this can be implemented using the `max` and `abs` functions.\n\n# [degree adverb] \n    'minimum': In the context of the type 2 query, it refers to finding the path between two rooms that requires the least total energy. This can be implemented using graph traversal algorithms like Dijkstra's algorithm or BFS with priority queues.\n\n# [code logic]\n    The steps for parsing input, initializing data structures, and handling queries should be implemented in sequence. However, within the query handling, type 1 and type 2 queries should be handled in separate code blocks or functions, as they perform different operations (updating vs. calculating).\n\n# [edge case] \n    1. Minimum number of rooms and queries: n = 2, q = 1\n       Explanation: With only two rooms and one query, the simplest case tests the basic functionality of the program.\n       Expected output depends on the query type and values.\n\n    2. All rooms have the same illusion rate: e.g., a_i = 0 for all i\n       Explanation: This tests if the program correctly handles cases where the illusion rate does not affect the energy calculation.\n       Expected output for type 2 queries should be 0, as all energy calculations will result in 0.\n\n    3. Maximum possible illusion rate change: e.g., changing a room's illusion rate to 10^9\n       Explanation: This tests the program's ability to handle large numbers and potential integer overflow.\n       Expected output depends on the specific query and path.\n\n# [extra code for edge case]\n", "Round_0": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = [0] * (n + 1)\n    for i in range(1, n + 1):\n        illusion_rates[i] = int(data[index])\n        index += 1\n    \n    # Build the tree using adjacency list\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Function to calculate energy between two rooms\n    def calculate_energy(x, y):\n        return max(abs(illusion_rates[x] + illusion_rates[y]), abs(illusion_rates[x] - illusion_rates[y]))\n    \n    # Function to find minimum energy path using Dijkstra's algorithm\n    def find_min_energy_path(start, end):\n        # Min-heap priority queue\n        pq = [(0, start)]\n        # Distance array\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        \n        while pq:\n            current_energy, current_room = heapq.heappop(pq)\n            \n            if current_room == end:\n                return current_energy\n            \n            if current_energy > dist[current_room]:\n                continue\n            \n            for neighbor in tree[current_room]:\n                energy_cost = calculate_energy(current_room, neighbor)\n                new_energy = current_energy + energy_cost\n                \n                if new_energy < dist[neighbor]:\n                    dist[neighbor] = new_energy\n                    heapq.heappush(pq, (new_energy, neighbor))\n        \n        return dist[end]\n    \n    # Process each query\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            # Update illusion rate\n            c = int(data[index])\n            index += 1\n            illusion_rates[u] = c\n        elif query_type == 2:\n            # Find minimum energy path\n            v = int(data[index])\n            index += 1\n            min_energy =", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 74)"}, "Round_1": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = [0] * (n + 1)\n    for i in range(1, n + 1):\n        illusion_rates[i] = int(data[index])\n        index += 1\n    \n    # Build the tree using adjacency list\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Function to calculate energy between two rooms\n    def calculate_energy(x, y):\n        return max(abs(illusion_rates[x] + illusion_rates[y]), abs(illusion_rates[x] - illusion_rates[y]))\n    \n    # Function to find minimum energy path using Dijkstra's algorithm\n    def find_min_energy_path(start, end):\n        # Min-heap priority queue\n        pq = [(0, start)]\n        # Distance array\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        \n        while pq:\n            current_energy, current_room = heapq.heappop(pq)\n            \n            if current_room == end:\n                return current_energy\n            \n            if current_energy > dist[current_room]:\n                continue\n            \n            for neighbor in tree[current_room]:\n                energy_cost = calculate_energy(current_room, neighbor)\n                new_energy = current_energy + energy_cost\n                \n                if new_energy < dist[neighbor]:\n                    dist[neighbor] = new_energy\n                    heapq.heappush(pq, (new_energy, neighbor))\n        \n        return dist[end]\n    \n    # Process each query\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            # Update illusion rate\n            c = int(data[index])\n            index += 1\n            illusion_rates[u] = c\n        elif query_type == 2:\n            # Find minimum energy path\n            v = int(data[index])\n            index += 1\n            min_energy ="}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the connections between rooms.\",\n      \"output\": \"Data structures to store the number of rooms, queries, initial illusion rates, and adjacency list for the tree.\"\n    },\n    {\n      \"description\": \"Implement a data structure to efficiently handle updates and queries on the tree structure.\",\n      \"output\": \"A segment tree or similar data structure to manage updates and path queries efficiently.\"\n    },\n    {\n      \"description\": \"Handle the update query to change the illusion rate of a specific room.\",\n      \"output\": \"Update the data structure to reflect the new illusion rate for the specified room.\"\n    },\n    {\n      \"description\": \"Handle the path query to calculate the minimum energy required to travel from one room to another.\",\n      \"output\": \"Use the data structure to compute the minimum energy path between two rooms based on current illusion rates.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the connections between rooms.\",\n    \"Construct an adjacency list to represent the tree structure of the maze.\",\n    \"Initialize a data structure (e.g., segment tree) to manage updates and queries on the tree.\",\n    \"For each query, determine the type of query:\",\n    \"  - If it's an update query, modify the illusion rate of the specified room in the data structure.\",\n    \"  - If it's a path query, calculate the minimum energy required to travel from the starting room to the destination room using the data structure.\",\n    \"Output the result for each path query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n    'illusion rate': This is a property of each room that affects the energy cost of traveling between rooms.\n    'energy cost': The cost calculated using the formula max(|a_x + a_y|, |a_x - a_y|) when traveling between rooms x and y.\n\n# [phrase showing quantity relationship]\n    'max': This indicates that for each tunnel, the energy cost is the maximum of two calculated values, |a_x + a_y| and |a_x - a_y|. In code, this can be implemented using the `max()` function.\n\n# [degree adverb]\n    'minimum': In the context of the path query, it refers to finding the path with the least energy cost from room u to room v. This can be implemented using algorithms like Dijkstra's or BFS/DFS with priority queues to find the shortest path in terms of energy cost.\n\n# [code logic]\n    The steps for handling update and path queries should be considered separately, as they involve different operations on the data structure. However, the initialization of the data structure and parsing of input can be done simultaneously.\n\n# [edge case]\n    1. Input: 2 1\n       0 0\n       1 2\n       2 1 2\n       Output: 0\n       Explanation: With illusion rates of 0, the energy cost between any two rooms is 0.\n       \n    2. Input: 3 2\n       1 1 1\n       1 2\n       2 3\n       2 1 3\n       Output: 2\n       Explanation: The path 1 -> 2 -> 3 has energy costs of 2 each, totaling 2.\n       \n    3. Input: 4 2\n       10 -10 10 -10\n       1 2\n       2 3\n       3 4\n       2 1 4\n       Output: 40\n       Explanation: The path 1 -> 2 -> 3 -> 4 has energy costs of 20 each, totaling 40.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, especially when the illusion rates are zero or when the tree structure is minimal", "Round_0": {"code": "import sys\nimport collections\nimport heapq\n\ninput = sys.stdin.read\ndef main():\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = collections.defaultdict(list)\n    \n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index]) - 1\n        index += 1\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def calculate_energy(x, y):\n        return max(abs(illusion_rates[x] + illusion_rates[y]), abs(illusion_rates[x] - illusion_rates[y]))\n    \n    def dijkstra(start, end):\n        min_energy = [float('inf')] * n\n        min_energy[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            current_energy, current_room = heapq.heappop(pq)\n            \n            if current_room == end:\n                return current_energy\n            \n            if current_energy > min_energy[current_room]:\n                continue\n            \n            for neighbor in graph[current_room]:\n                energy_cost = calculate_energy(current_room, neighbor)\n                new_energy = current_energy + energy_cost\n                \n                if new_energy < min_energy[neighbor]:\n                    min_energy[neighbor] = new_energy\n                    heapq.heappush(pq, (new_energy, neighbor))\n        \n        return min_energy[end]\n    \n    results = []\n    \n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        \n        if query_type == 1:\n            c = int(data[index])\n            index += 1\n            illusion_rates[u] = c\n        elif query_type == 2:\n            v = int(data[index]) - 1\n            index += 1\n            result = dijkstra(u, v)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 160)"}, "Round_1": {"code": "import sys\nimport collections\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = collections.defaultdict(list)\n    \n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index]) - 1\n        index += 1\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def calculate_energy(x, y):\n        return max(abs(illusion_rates[x] + illusion_rates[y]), abs(illusion_rates[x] - illusion_rates[y]))\n    \n    def dijkstra(start, end):\n        min_energy = [float('inf')] * n\n        min_energy[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            current_energy, current_room = heapq.heappop(pq)\n            \n            if current_room == end:\n                return current_energy\n            \n            if current_energy > min_energy[current_room]:\n                continue\n            \n            for neighbor in graph[current_room]:\n                energy_cost = calculate_energy(current_room, neighbor)\n                new_energy = current_energy + energy_cost\n                \n                if new_energy < min_energy[neighbor]:\n                    min_energy[neighbor] = new_energy\n                    heapq.heappush(pq, (new_energy, neighbor))\n        \n        return min_energy[end]\n    \n    results = []\n    \n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        \n        if query_type == 1:\n            c = int(data[index])\n            index += 1\n            illusion_rates[u] = c\n        elif query_type == 2:\n            v = int(data[index]) - 1\n            index += 1\n            result = dijkstra(u, v)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure of the maze.\",\n      \"details\": \"Read the input data and store the number of rooms (n), number of queries (q), the list of illusion rates (a), and the list of tunnels connecting rooms.\"\n    },\n    {\n      \"description\": \"Construct the tree representation of the maze using the given tunnels.\",\n      \"details\": \"Use adjacency lists to represent the tree structure based on the given tunnels.\"\n    },\n    {\n      \"description\": \"Implement a method to update the illusion rate of a specific room.\",\n      \"details\": \"For query type 1, update the illusion rate of the specified room in the list of illusion rates.\"\n    },\n    {\n      \"description\": \"Implement a method to calculate the minimum energy required to travel from one room to another.\",\n      \"details\": \"For query type 2, use a tree traversal algorithm (e.g., DFS or BFS) to find the path between the specified rooms and calculate the energy cost using the given formula.\"\n    },\n    {\n      \"description\": \"Optimize the energy calculation for repeated queries.\",\n      \"details\": \"Consider using techniques like precomputation, memoization, or segment trees to efficiently handle multiple queries.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data including number of rooms, queries, illusion rates, and tunnels.\",\n    \"Construct the tree representation of the maze using adjacency lists.\",\n    \"Implement a function to handle query type 1, updating the illusion rate of a specified room.\",\n    \"Implement a function to handle query type 2, calculating the minimum energy required to travel between two rooms using tree traversal.\",\n    \"Optimize the energy calculation process to efficiently handle multiple queries, possibly using advanced data structures or algorithms.\",\n    \"Output the result for each type 2 query as specified.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. In this problem, the maze is represented as a tree with rooms as nodes and tunnels as edges.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy cost of traveling between rooms. The illusion rate can be updated through queries.\n\n    'energy cost'\n    Explanation: The energy cost to travel between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy cost is determined by taking the maximum of the absolute values of the sum and difference of the illusion rates of two rooms. In code, this can be implemented using the `max` function and `abs` function in Python.\n\n# [degree adverb] \n    'minimum': In the context of the requirement, it refers to finding the path with the least energy cost between two rooms. This can be implemented using algorithms like Dijkstra's or BFS/DFS with appropriate modifications to track the minimum energy path.\n\n# [code logic]\n    The steps for handling query type 2 (calculating minimum energy) should be implemented simultaneously. Specifically, the tree traversal and energy calculation should be done in a single function to efficiently find the path and compute the energy cost.\n\n# [edge case] \n    1. Minimum number of rooms (n=2): \n       Input: \n       ```\n       2 1\n       5 -5\n       1 2\n       2 1 2\n       ```\n       Expected Output: 10\n       Explanation: With only two rooms, the energy cost is directly calculated between them.\n\n    2. All illusion rates are zero:\n       Input:\n       ```\n       3 1\n       0 0 0\n       1 2\n       2 3\n       2 1 3\n       ```\n       Expected Output: 0\n       Explanation: Since all illusion rates are zero, the energy cost for any path is zero.\n\n    3. Maximum illusion rate change:\n       Input:\n       ```\n       3 2\n       1 2 3\n       ", "Round_0": {"code": "import sys\nimport collections\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Construct the tree\n    tree = collections.defaultdict(list)\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        tree[u].append(v)\n        tree[v].append(u)\n        index += 2\n    \n    # Function to calculate energy cost between two rooms\n    def energy_cost(x, y):\n        return max(abs(illusion_rates[x] + illusion_rates[y]), abs(illusion_rates[x] - illusion_rates[y]))\n    \n    # Function to find the path and calculate the minimum energy using BFS\n    def bfs_min_energy(start, end):\n        queue = collections.deque([(start, 0)])\n        visited = set()\n        visited.add(start)\n        \n        while queue:\n            current, current_energy = queue.popleft()\n            \n            if current == end:\n                return current_energy\n            \n            for neighbor in tree[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    new_energy = current_energy + energy_cost(current, neighbor)\n                    queue.append((neighbor, new_energy))\n        \n        return float('inf')\n    \n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1]) - 1\n        if query_type == 1:\n            # Update illusion rate\n            c = int(data[index + 2])\n            illusion_rates[u] = c\n            index += 3\n        elif query_type == 2:\n            # Calculate minimum energy\n            v = int(data[index + 2]) - 1\n            min_energy = bfs_min_energy(u, v)\n            results.append(min_energy)\n            index += 3\n    \n    # Output results for type 2 queries\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 153)"}, "Round_1": {"code": "import sys\nimport collections\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Construct the tree\n    tree = collections.defaultdict(list)\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        tree[u].append(v)\n        tree[v].append(u)\n        index += 2\n    \n    # Function to calculate energy cost between two rooms\n    def energy_cost(x, y):\n        return max(abs(illusion_rates[x] + illusion_rates[y]), abs(illusion_rates[x] - illusion_rates[y]))\n    \n    # Function to find the path and calculate the minimum energy using BFS\n    def bfs_min_energy(start, end):\n        queue = collections.deque([(start, 0)])\n        visited = set()\n        visited.add(start)\n        \n        while queue:\n            current, current_energy = queue.popleft()\n            \n            if current == end:\n                return current_energy\n            \n            for neighbor in tree[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    new_energy = current_energy + energy_cost(current, neighbor)\n                    queue.append((neighbor, new_energy))\n        \n        return float('inf')\n    \n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1]) - 1\n        if query_type == 1:\n            # Update illusion rate\n            c = int(data[index + 2])\n            illusion_rates[u] = c\n            index += 3\n        elif query_type == 2:\n            # Calculate minimum energy\n            v = int(data[index + 2]) - 1\n            min_energy = bfs_min_energy(u, v)\n            results.append(min_energy)\n            index += 3\n    \n    # Output results for type 2 queries\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure of the maze.\",\n      \"output\": \"Data structures to store the number of rooms (n), number of queries (q), initial illusion rates (a), and adjacency list for the tree.\"\n    },\n    {\n      \"description\": \"Implement a data structure to efficiently update the illusion rate of a room and to query the minimum energy path between two rooms.\",\n      \"output\": \"A segment tree or similar data structure to handle updates and queries efficiently.\"\n    },\n    {\n      \"description\": \"Develop a function to handle type 1 queries, which update the illusion rate of a specific room.\",\n      \"output\": \"Updated data structure reflecting the new illusion rate for the specified room.\"\n    },\n    {\n      \"description\": \"Develop a function to handle type 2 queries, which calculate the minimum energy required to travel between two rooms.\",\n      \"output\": \"The minimum energy required for the specified path, considering the current illusion rates.\"\n    },\n    {\n      \"description\": \"Implement a traversal algorithm (e.g., DFS or BFS) to find the path between two rooms in the tree structure.\",\n      \"output\": \"The path between the specified rooms, used to calculate the energy cost.\"\n    },\n    {\n      \"description\": \"Calculate the energy cost for a given path using the formula max(|a_x + a_y|, |a_x - a_y|) for each pair of consecutive rooms.\",\n      \"output\": \"The total energy cost for the path.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure.\",\n    \"Initialize a data structure to store and update illusion rates efficiently.\",\n    \"For each query, determine its type and execute the corresponding function:\",\n    \"  - For type 1 queries, update the illusion rate of the specified room.\",\n    \"  - For type 2 queries, find the path between the specified rooms and calculate the minimum energy required.\",\n    \"Implement a traversal algorithm to find paths in the tree structure.\",\n    \"Calculate the energy cost for each path using the given formula.\",\n    \"Output the results for each type 2 query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, meaning there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy cost to travel between rooms.\n\n    'energy cost'\n    Explanation: The energy cost to travel between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy cost is the maximum of the absolute sum or absolute difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum': In the context of the type 2 query, it refers to finding the path with the least total energy cost between two rooms. This can be implemented using a pathfinding algorithm that minimizes the accumulated energy cost.\n\n# [code logic]\n    The steps for handling type 2 queries (finding the path and calculating energy) should be implemented simultaneously. Specifically, the traversal to find the path and the calculation of energy cost for each segment of the path can be done in a single traversal of the tree.\n\n# [edge case]\n    1. Minimum number of rooms and queries: n = 2, q = 1, with a single type 2 query.\n       Input: \n       ```\n       2 1\n       5 -5\n       1 2\n       2 1 2\n       ```\n       Expected Output: 10\n       Explanation: The only path is from room 1 to room 2, with energy cost max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    2. All rooms have zero illusion rate: n = 3, q = 1, with a type 2 query.\n       Input:\n       ```\n       3 1\n       0 0 0\n       1 2\n       2 3\n       2 1 3\n       ```\n       Expected Output: 0\n       Explanation: All rooms have zero illusion rate, so the energy cost for any path is 0.\n\n    ", "Round_0": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = collections.defaultdict(list)\n    \n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index]) - 1\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        if query_type == 1:\n            c = int(data[index])\n            index += 1\n            queries.append((query_type, u, c))\n        else:\n            v = int(data[index]) - 1\n            index += 1\n            queries.append((query_type, u, v))\n    \n    # Preprocessing for LCA\n    parent = [-1] * n\n    depth = [0] * n\n    visited = [False] * n\n    \n    def dfs(node, par, dep):\n        parent[node] = par\n        depth[node] = dep\n        visited[node] = True\n        for neighbor in tree[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, node, dep + 1)\n    \n    dfs(0, -1, 0)\n    \n    def lca(u, v):\n        if depth[u] < depth[v]:\n            u, v = v, u\n        while depth[u] > depth[v]:\n            u = parent[u]\n        while u != v:\n            u = parent[u]\n            v = parent[v]\n        return u\n    \n    def calculate_energy(u, v):\n        lca", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 147)"}, "Round_1": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = collections.defaultdict(list)\n    \n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index]) - 1\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        if query_type == 1:\n            c = int(data[index])\n            index += 1\n            queries.append((query_type, u, c))\n        else:\n            v = int(data[index]) - 1\n            index += 1\n            queries.append((query_type, u, v))\n    \n    # Preprocessing for LCA\n    parent = [-1] * n\n    depth = [0] * n\n    visited = [False] * n\n    \n    def dfs(node, par, dep):\n        parent[node] = par\n        depth[node] = dep\n        visited[node] = True\n        for neighbor in tree[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, node, dep + 1)\n    \n    dfs(0, -1, 0)\n    \n    def lca(u, v):\n        if depth[u] < depth[v]:\n            u, v = v, u\n        while depth[u] > depth[v]:\n            u = parent[u]\n        while u != v:\n            u = parent[u]\n            v = parent[v]\n        return u\n    \n    def calculate_energy(u, v):\n        lca_node = lca(u, v)\n        energy = 0\n        while u != lca_node:\n            energy += max(abs(illusion_rates[u] + illusion_rates[parent[u]]), abs(illusion_rates[u] - illusion_rates[parent[u]]))\n            u = parent[u]\n        while v != lca_node:\n            energy += max(abs(illusion_rates[v] + illusion_rates[parent[v]]"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure of the maze.\",\n      \"output\": \"Data structures to store the number of rooms (n), number of queries (q), initial illusion rates (a), and adjacency list for the tree.\"\n    },\n    {\n      \"description\": \"Implement a data structure to efficiently update the illusion rate of a room and to query the minimum energy path between two rooms.\",\n      \"output\": \"A segment tree or similar data structure to handle updates and queries efficiently.\"\n    },\n    {\n      \"description\": \"Develop a function to handle type 1 queries, which update the illusion rate of a specific room.\",\n      \"output\": \"Updated data structure reflecting the new illusion rate for the specified room.\"\n    },\n    {\n      \"description\": \"Develop a function to handle type 2 queries, which calculate the minimum energy required to travel between two rooms.\",\n      \"output\": \"The minimum energy required for the specified path, considering the current illusion rates.\"\n    },\n    {\n      \"description\": \"Implement a traversal algorithm (e.g., DFS or BFS) to find the path between two rooms in the tree structure.\",\n      \"output\": \"The path between the specified rooms as a list of room indices.\"\n    },\n    {\n      \"description\": \"Calculate the energy required for a given path using the formula max(|a_x + a_y|, |a_x - a_y|) for each pair of consecutive rooms.\",\n      \"output\": \"The total energy required for the path.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure.\",\n    \"Initialize a data structure to store and update illusion rates efficiently.\",\n    \"For each query, determine its type and execute the corresponding function:\",\n    \"  - For type 1 queries, update the illusion rate of the specified room.\",\n    \"  - For type 2 queries, find the path between the specified rooms using a tree traversal algorithm.\",\n    \"Calculate the energy required for the path using the given formula and output the result for type 2 queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy calculation when moving between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute sum or absolute difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` function in Python.\n\n# [degree adverb] \n    'minimum sum of energy': This indicates that for type 2 queries, we need to find the path that results in the least total energy expenditure. This can be implemented by calculating the energy for all possible paths and selecting the smallest sum.\n\n# [code logic]\n    The steps for handling type 2 queries (finding the path and calculating energy) should be implemented simultaneously. Specifically, once the path is found using a traversal algorithm, the energy calculation should be done in the same code block to ensure efficiency.\n\n# [edge case] \n    1. Minimum number of rooms: n = 2, q = 1, a = [0, 0], queries = [(2, 1, 2)]\n       Expected output: 0\n       Explanation: With only two rooms and both having an illusion rate of 0, the energy required is 0.\n\n    2. Maximum illusion rate change: n = 3, q = 2, a = [10^9, 10^9, 10^9], queries = [(1, 1, -10^9), (2, 1, 3)]\n       Expected output: 0\n       Explanation: After changing the illusion rate of room 1 to -10^9, the energy between any two rooms with the same illusion rate becomes 0.\n\n    3. Single path with varying rates: n = 3, q = 1, a = [1, -1, 1], queries = [(2, 1", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndef main():\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index]) - 1\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    def bfs_path(start, end):\n        queue = deque([start])\n        parent = {start: None}\n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    def calculate_energy(path):\n        total_energy = 0\n        for i in range(len(path) - 1):\n            u = path[i]\n            v = path[i + 1]\n            energy = max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n            total_energy += energy\n        return total_energy\n    \n    output = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        if query_type == 1:\n            c = int(data[index])\n            index += 1\n            illusion_rates[u] = c\n        elif query_type == 2:\n            v = int(data[index]) - 1\n            index += 1\n            path = bfs_path(u, v)\n            energy = calculate_energy(path)\n            output.append(str(energy))\n    \n    sys.stdout.write(\"\\n\".join(output) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 148)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index]) - 1\n        index += 1\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    def bfs_path(start, end):\n        queue = deque([start])\n        parent = {start: None}\n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    def calculate_energy(path):\n        total_energy = 0\n        for i in range(len(path) - 1):\n            u = path[i]\n            v = path[i + 1]\n            energy = max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n            total_energy += energy\n        return total_energy\n    \n    output = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        if query_type == 1:\n            c = int(data[index])\n            index += 1\n            illusion_rates[u] = c\n        elif query_type == 2:\n            v = int(data[index]) - 1\n            index += 1\n            path = bfs_path(u, v)\n            energy = calculate_energy(path)\n            output.append(str(energy))\n    \n    sys.stdout.write(\"\\n\".join(output) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n"}}], "scores": [], "pass_results": [false, false, true, true, false, false, true, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 2, "prompt": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\nHelp them, so you can get a portion of the treasure! Implement an efficient approach to handle the queries optimally.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 2}
