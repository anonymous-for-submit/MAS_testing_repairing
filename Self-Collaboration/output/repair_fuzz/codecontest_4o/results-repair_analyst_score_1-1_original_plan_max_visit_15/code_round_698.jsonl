{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "repair_prompt": ["Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer) and the mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i.e. sum divided by n), and Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the solutions are derived efficiently considering large inputs. Consider optimizing the algorithm to ensure it runs within a reasonable time frame for the maximum constraints.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements. Note that it's possible that k is not an integer which means it can be a decimal or fractional value. The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i.e. sum divided by n), and Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the solutions are derived efficiently considering large inputs. Consider optimizing the algorithm to ensure it runs within a reasonable time frame for the maximum constraints.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer) and the mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i.e. sum divided by n), and Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k. Ensure that the solutions are derived efficiently considering large inputs while optimizing the algorithm to ensure it runs within a reasonable time frame for the maximum constraints.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == k * (n - 2)\n        # a[i] + a[j] == total_sum - k * (n - 2)\n        \n        target_sum = total_sum - k * (n - 2)\n        \n        # Use a hashmap to count occurrences of each element\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        # Count the number of valid pairs\n        valid_pairs = 0\n        \n        for num in a:\n            # Check if there is a complement that forms the target_sum\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            \n            # Increment the count of the current number\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "completions": ["def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Edge case: all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Count pairs (i, j) such that a[i] + a[j] = 2 * mean\n        target_sum = 2 * mean\n        count = 0\n        seen = {}\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in seen:\n                count += seen[complement]\n            if num in seen:\n                seen[num] += 1\n            else:\n                seen[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Edge case: all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # To find pairs (i, j) such that a[i] + a[j] = 2 * mean\n        target_sum = 2 * mean\n        count = 0\n        value_count = {}\n        \n        for value in a:\n            complement = target_sum - value\n            if complement in value_count:\n                count += value_count[complement]\n            \n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n < 4:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        target_sum = (n - 2) * mean_k\n        count = 0\n        freq = {}\n        \n        for num in a:\n            required_sum = target_sum - (total_sum - num)\n            if required_sum in freq:\n                count += freq[required_sum]\n            \n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        target_sum = 2 * total_sum / n\n        \n        if target_sum != int(target_sum):\n            results.append(0)\n            continue\n        \n        target_sum = int(target_sum)\n        count = 0\n        freq = {}\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in freq:\n                count += freq[complement]\n            \n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def find_valid_pairs(n, array):\n    total_sum = sum(array)\n    mean = total_sum / n\n    target_sum = 2 * mean\n    \n    count_map = {}\n    pair_count = 0\n    \n    for num in array:\n        complement = target_sum - num\n        if complement in count_map:\n            pair_count += count_map[complement]\n        \n        if num in count_map:\n            count_map[num] += 1\n        else:\n            count_map[num] = 1\n    \n    return pair_count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        result = find_valid_pairs(n, array)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        target_sum = (n - 2) * k\n        count = 0\n        value_count = {}\n        \n        for value in a:\n            value_count[value] = value_count.get(value, 0) + 1\n        \n        for i in range(n):\n            value_count[a[i]] -= 1\n            for j in range(i + 1, n):\n                value_count[a[j]] -= 1\n                if total_sum - a[i] - a[j] == target_sum:\n                    count += 1\n                value_count[a[j]] += 1\n            value_count[a[i]] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # We need to find pairs (i, j) such that a[i] + a[j] = 2 * k\n        target_sum = 2 * k\n        \n        # Use a hashmap to count occurrences of each element\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        # Count valid pairs\n        valid_pairs = 0\n        \n        for num in a:\n            # Check if there is a complement that can form the target_sum with the current num\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            \n            # Increment the count of the current number\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            # If all elements are the same, any pair can be removed\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying gives: total_sum - a[i] - a[j] == mean * (n - 2)\n        # Which further simplifies to: a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of elements\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        valid_pairs = 0\n        \n        for num in a:\n            # Check if there exists a number that can pair with `num` to form `target_sum`\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            \n            # Increment the count of the current number\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        target_sum = 2 * mean_k\n        \n        count = 0\n        value_count = {}\n        \n        for value in a:\n            complement = target_sum - value\n            if complement in value_count:\n                count += value_count[complement]\n            \n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == k * (n - 2)\n        # a[i] + a[j] == total_sum - k * (n - 2)\n        \n        target_sum = total_sum - k * (n - 2)\n        \n        # Use a hashmap to count occurrences of each element\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        # Count the number of valid pairs\n        valid_pairs = 0\n        \n        for num in a:\n            # Check if there is a complement that forms the target_sum\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            \n            # Increment the count of the current number\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"steps\": [\n        \"Sum all elements of the array a.\",\n        \"Divide the sum by the number of elements n to get the mean k.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (a[i], a[j]), calculate the sum of the remaining elements after removing a[i] and a[j].\",\n        \"Check if the mean of the remaining elements equals k.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs to ensure efficiency.\",\n      \"steps\": [\n        \"Use mathematical properties to simplify the condition for mean equality.\",\n        \"Implement an efficient search strategy, possibly using hash maps or other data structures to reduce time complexity.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following:\",\n    \"Read the number of elements n and the array a.\",\n    \"Calculate the initial mean k of the array a.\",\n    \"Initialize a counter to track the number of valid pairs.\",\n    \"Iterate over all pairs of elements (i, j) with i < j:\",\n    \"Calculate the sum of the remaining elements after removing a[i] and a[j].\",\n    \"Check if the mean of the remaining elements equals k.\",\n    \"If the condition is satisfied, increment the counter.\",\n    \"Output the counter value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of a set of numbers is the sum of the numbers divided by the count of numbers. In this requirement, it refers to the mean of the array elements before and after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'sum divided by n': This indicates the calculation of the mean, where the sum of elements is divided by the number of elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the mean and checking pairs should be implemented simultaneously for efficiency. Specifically, the calculation of the mean and the checking of pairs can be optimized using mathematical properties and efficient data structures like hash maps.\n\n# [edge case]\n    Input: [3, 3, 3, 3] = 6\n    Explanation: All elements are the same, so any pair can be removed without changing the mean.\n    \n    Input: [1, 1, 1] = 0\n    Explanation: With only three elements, removing any two will leave one element, which cannot maintain the original mean.\n    \n    Input: [1, 2, 3, 4, 5] = 3\n    Explanation: Removing elements at positions 1 and 5 or 2 and 4 will maintain the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    - Use a hash map to store the frequency of each element.\n    - Calculate the required sum for the remaining elements to maintain the mean.\n    - Check pairs using the hash map to ensure efficient lookup and counting.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == k * (n - 2)\n        # a[i] + a[j] == total_sum - k * (n - 2)\n        \n        target_sum = total_sum - k * (n - 2)\n        \n        # Use a hashmap to count occurrences of each element\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        # Count the number of valid pairs\n        valid_pairs = 0\n        \n        for num in a:\n            # Check if there is a complement that forms the target_sum\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            \n            # Increment the count of the current number\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"steps\": [\n        \"Sum all elements of the array.\",\n        \"Divide the sum by the number of elements to get the mean.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (i, j), calculate the sum of the remaining elements after removing a[i] and a[j].\",\n        \"Check if the mean of the remaining elements equals the initial mean.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"steps\": [\n        \"Use mathematical properties to simplify the condition for unchanged mean.\",\n        \"Implement efficient search or counting techniques to find valid pairs without checking all possible pairs explicitly.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following:\",\n    \"  Read the number of elements and the array.\",\n    \"  Calculate the initial mean of the array.\",\n    \"  Initialize a counter for valid pairs.\",\n    \"  Iterate over all pairs of elements (i, j) with i < j:\",\n    \"    Calculate the sum of the remaining elements after removing a[i] and a[j].\",\n    \"    Check if the mean of the remaining elements equals the initial mean.\",\n    \"    If valid, increment the counter.\",\n    \"  Output the counter for the current test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean of the array should remain unchanged after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'sum divided by n': This is the formula for calculating the mean, where 'sum' is the total of all elements and 'n' is the number of elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the initial mean and checking pairs should be considered simultaneously. Specifically, the calculation of the sum of the remaining elements and checking if the mean remains unchanged should be done in a single loop to optimize performance.\n\n# [edge case]\n    1. Input: [3, 3, 3, 3] = 6\n       Explanation: All elements are the same, so any pair can be removed without changing the mean.\n    2. Input: [1, 2, 3] = 0\n       Explanation: No pair can be removed to keep the mean unchanged because the elements are distinct.\n    3. Input: [5, 5, 5, 5, 5] = 10\n       Explanation: Any pair can be removed since all elements are equal.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially when all elements are the same or when no valid pair exists.\n    ```\n    if all(x == a[0] for x in a):\n        return (n * (n - 1)) // 2  # All pairs are valid\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Edge case: all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Count pairs (i, j) such that a[i] + a[j] = 2 * mean\n        target_sum = 2 * mean\n        count = 0\n        seen = {}\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in seen:\n                count += seen[complement]\n            if num in seen:\n                seen[num] += 1\n            else:\n                seen[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Edge case: all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Count pairs (i, j) such that a[i] + a[j] = 2 * mean\n        target_sum = 2 * mean\n        count = 0\n        seen = {}\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in seen:\n                count += seen[complement]\n            if num in seen:\n                seen[num] += 1\n            else:\n                seen[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"steps\": [\n        \"Sum all elements of the array.\",\n        \"Divide the sum by the number of elements to get the mean.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (i, j), calculate the sum of the remaining elements after removing a[i] and a[j].\",\n        \"Check if the mean of the remaining elements equals the initial mean.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"steps\": [\n        \"Use mathematical properties to simplify the condition for unchanged mean.\",\n        \"Implement efficient data structures or algorithms to reduce time complexity.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following:\",\n    \"Read the number of elements and the array.\",\n    \"Calculate the initial mean of the array.\",\n    \"Initialize a counter for valid pairs.\",\n    \"Iterate over all pairs of elements (i, j) with i < j:\",\n    \"Check if removing these elements keeps the mean unchanged using optimized conditions.\",\n    \"If valid, increment the counter.\",\n    \"Output the counter for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean of the array should remain unchanged after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'equal to': This indicates that the mean of the remaining elements should be the same as the initial mean.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for calculating the initial mean and checking pairs should be considered simultaneously for efficiency. Specifically, the calculation of the sum of the remaining elements and checking if the mean remains unchanged should be optimized together to avoid redundant calculations.\n\n# [edge case] \n    1. Input: [3, 3, 3, 3] = 6\n       Explanation: All elements are the same, so any pair of elements can be removed without changing the mean.\n    2. Input: [1, 2, 3] = 0\n       Explanation: No pair of elements can be removed to keep the mean unchanged because the elements are distinct and the mean changes with any removal.\n    3. Input: [5, 5, 5, 5, 5] = 10\n       Explanation: Similar to the first case, any pair can be removed since all elements are equal.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially when all elements are the same or when no valid pairs exist.\n    ```python\n    if all(x == array[0] for x in array):\n        return (n * (n - 1)) // 2  # All pairs are valid\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Edge case: all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # To find pairs (i, j) such that a[i] + a[j] = 2 * mean\n        target_sum = 2 * mean\n        count = 0\n        value_count = {}\n        \n        for value in a:\n            complement = target_sum - value\n            if complement in value_count:\n                count += value_count[complement]\n            \n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 89)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Edge case: all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # To find pairs (i, j) such that a[i] + a[j] = 2 * mean\n        target_sum = 2 * mean\n        count = 0\n        value_count = {}\n        \n        for value in a:\n            complement = target_sum - value\n            if complement in value_count:\n                count += value_count[complement]\n            \n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Determine the condition for maintaining the mean after removing two elements.\",\n      \"details\": \"For two elements a[i] and a[j] to be removed, the sum of the remaining elements must be equal to (n-2) * k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"details\": \"For each pair (i, j), check if the sum of the remaining elements equals (n-2) * k. This can be optimized using a hashmap to track required sums.\"\n    },\n    {\n      \"description\": \"Optimize the solution for large inputs.\",\n      \"details\": \"Use efficient data structures and algorithms to ensure the solution runs within time limits for large constraints.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the mean k for each test case\",\n      \"details\": \"Compute the sum of the array a and divide by n to get k.\"\n    },\n    {\n      \"step\": \"Iterate over each element to find valid pairs\",\n      \"details\": \"Use a hashmap to store the frequency of elements and iterate over the array to find pairs (i, j) such that their removal maintains the mean.\"\n    },\n    {\n      \"step\": \"Count valid pairs\",\n      \"details\": \"For each valid pair found, increment the count of valid pairs.\"\n    },\n    {\n      \"step\": \"Output the result for each test case\",\n      \"details\": \"Print the count of valid pairs for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean is used to determine if removing two elements from the array keeps the mean of the remaining elements the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that precisely two elements must be removed from the array.\n    'equal to': This indicates that the mean of the remaining elements must be the same as the original mean.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the mean k for each test case\" and \"Iterate over each element to find valid pairs\" should be considered simultaneously. \n    Explanation: While iterating over the elements to find valid pairs, the mean k should be used to check the condition for maintaining the mean. This can be efficiently done using a hashmap to track the required sums.\n\n# [edge case] \n    Case 1: n = 3, a = [1, 1, 1]\n    Expected output: 0\n    Explanation: With only three elements, removing any two will leave one element, which cannot maintain the original mean.\n\n    Case 2: n = 4, a = [0, 0, 0, 0]\n    Expected output: 6\n    Explanation: Any pair of elements can be removed since all elements are equal, and the mean remains the same.\n\n    Case 3: n = 5, a = [1, 2, 3, 4, 5]\n    Expected output: 0\n    Explanation: No pair of elements can be removed to maintain the original mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: Specifically, we need to handle cases where n is very small (like 3) or where all elements are the same. This can be done by checking if the array size is less than 4 or if all elements are equal before proceeding with the main logic.\n\n    ```python\n    if n < 4:\n        print(0)\n        continue\n    if all(x == a[0] for x in a):\n        print(n * (n - 1) // 2)\n        continue\n    ```\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n < 4:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        target_sum = (n - 2) * mean_k\n        count = 0\n        freq = {}\n        \n        for num in a:\n            required_sum = target_sum - (total_sum - num)\n            if required_sum in freq:\n                count += freq[required_sum]\n            \n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Compute the sum of all elements in the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Determine the condition for maintaining the mean after removing two elements.\",\n      \"details\": \"For two elements a[i] and a[j] to be removed, the condition is: (sum - a[i] - a[j]) / (n - 2) = k. Simplify this to find a relationship between a[i], a[j], and the sum.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements that satisfy the condition.\",\n      \"details\": \"Reformulate the condition to find pairs (a[i], a[j]) such that a[i] + a[j] = 2 * k. Use a hashmap to efficiently find and count such pairs.\"\n    },\n    {\n      \"description\": \"Handle multiple test cases efficiently.\",\n      \"details\": \"Iterate over each test case, apply the above logic, and store the results for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following steps:\",\n    \"  Read the integer n and the array a of n integers.\",\n    \"  Calculate the sum of the array a and compute the mean k.\",\n    \"  Initialize a hashmap to store the frequency of each element in a.\",\n    \"  Iterate over each element in a to populate the hashmap.\",\n    \"  For each element a[i] in a, calculate the required complement to maintain the mean.\",\n    \"  Use the hashmap to count how many times this complement appears in the remaining elements.\",\n    \"  Ensure that pairs are counted only once by considering only elements with indices i < j.\",\n    \"  Store the result for the current test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean (or average) of a set of numbers is the sum of the numbers divided by the count of numbers. In this requirement, it refers to the mean of the array elements before and after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that precisely two elements must be removed from the array.\n    'equal to': This indicates that the mean of the remaining elements must be the same as the original mean.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps related to calculating the mean and finding pairs should be considered simultaneously:\n    - Calculate the sum of the array and compute the mean.\n    - Use a hashmap to store frequencies and find pairs that satisfy the condition a[i] + a[j] = 2 * k.\n    These steps can be implemented in a single loop where you calculate the required complement and check the hashmap.\n\n# [edge case] \n    1. Input: 3, [1, 1, 1] = 0\n       Explanation: With only three elements, removing any two will leave one element, which cannot maintain the original mean.\n    2. Input: 4, [0, 0, 0, 0] = 6\n       Explanation: All elements are the same, so any pair can be removed without changing the mean.\n    3. Input: 5, [1, 2, 3, 4, 5] = 0\n       Explanation: No two elements can be removed to maintain the mean because the array is sequentially increasing.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a hashmap to find pairs that satisfy the condition a[i] + a[j] = 2 * k will naturally handle these cases.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        target_sum = 2 * total_sum / n\n        \n        if target_sum != int(target_sum):\n            results.append(0)\n            continue\n        \n        target_sum = int(target_sum)\n        count = 0\n        freq = {}\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in freq:\n                count += freq[complement]\n            \n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"steps\": [\n        \"Sum all elements of the array.\",\n        \"Divide the sum by the number of elements to get the mean.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the condition for removing two elements while maintaining the mean.\",\n      \"steps\": [\n        \"Understand that removing two elements should not change the mean of the remaining elements.\",\n        \"Formulate the equation: (sum - a[i] - a[j]) / (n - 2) = sum / n.\"\n      ]\n    },\n    {\n      \"description\": \"Simplify the equation to find valid pairs (i, j).\",\n      \"steps\": [\n        \"Simplify the equation to: a[i] + a[j] = 2 * mean.\",\n        \"Iterate over all pairs (i, j) to check if they satisfy the equation.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"steps\": [\n        \"Use a hashmap to store occurrences of elements.\",\n        \"For each element, check if the complement (2 * mean - element) exists in the hashmap.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following:\",\n    \"Read the number of elements and the array.\",\n    \"Calculate the mean of the array.\",\n    \"Initialize a hashmap to store occurrences of elements.\",\n    \"Iterate over each element and check for valid pairs using the hashmap.\",\n    \"Count the number of valid pairs and store the result.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of a set of numbers is the sum of the numbers divided by the count of numbers. In this requirement, it is used to determine the condition for removing two elements from the array while maintaining the mean.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This indicates that precisely two elements must be removed from the array.\n    'sum divided by n': This is the formula for calculating the mean, where 'sum' is the total of all elements and 'n' is the number of elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to checking valid pairs (i, j) should be implemented simultaneously. Specifically:\n    - \"Iterate over each element and check for valid pairs using the hashmap.\"\n    This can be done in a single loop where for each element, we check if its complement exists in the hashmap.\n\n# [edge case]\n    Test case with all elements being the same: [8, 8, 8, 8] = 6\n    Explanation: Any pair of elements can be removed since all of them are equal, maintaining the mean.\n    \n    Test case with no valid pairs: [50, 20, 10] = 0\n    Explanation: There is no way to delete two elements so the mathematical mean doesn't change.\n    \n    Test case with multiple valid pairs: [1, 4, 7, 3, 5] = 2\n    Explanation: It is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking pairs using the hashmap will naturally handle these cases.\n\nNO", "Round_0": {"code": "def find_valid_pairs(test_cases):\n    results = []\n    for n, array in test_cases:\n        total_sum = sum(array)\n        mean = total_sum / n\n        target_sum = 2 * mean\n        \n        count_map = {}\n        pair_count = 0\n        \n        for num in array:\n            complement = target_sum - num\n            if complement in count_map:\n                pair_count += count_map[complement]\n            \n            if num in count_map:\n                count_map[num] += 1\n            else:\n                count_map[num] = 1\n        \n        results.append(pair_count)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = find_valid_pairs(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: find_valid_pairs() missing 1 required positional argument: 'test_cases'"}, "Round_1": {"code": "def find_valid_pairs(n, array):\n    total_sum = sum(array)\n    mean = total_sum / n\n    target_sum = 2 * mean\n    \n    count_map = {}\n    pair_count = 0\n    \n    for num in array:\n        complement = target_sum - num\n        if complement in count_map:\n            pair_count += count_map[complement]\n        \n        if num in count_map:\n            count_map[num] += 1\n        else:\n            count_map[num] = 1\n    \n    return pair_count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        result = find_valid_pairs(n, array)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Determine the condition for maintaining the mean after removing two elements.\",\n      \"details\": \"For two elements a[i] and a[j] to be removed, the sum of the remaining elements must be equal to (n-2) * k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements that can be removed while maintaining the mean.\",\n      \"details\": \"For each pair (i, j), check if the sum of the remaining elements equals (n-2) * k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use a hashmap or dictionary to efficiently find pairs that satisfy the condition.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the mean k for each test case\",\n      \"details\": \"Compute the sum of the array and divide by n to get k.\"\n    },\n    {\n      \"step\": \"Iterate over possible pairs of elements to remove\",\n      \"details\": \"For each pair (i, j), calculate the sum of the remaining elements and check if it equals (n-2) * k.\"\n    },\n    {\n      \"step\": \"Use a hashmap to track potential pairs\",\n      \"details\": \"Store and lookup necessary values in a hashmap to efficiently find valid pairs.\"\n    },\n    {\n      \"step\": \"Count and output the number of valid pairs for each test case\",\n      \"details\": \"For each test case, output the count of pairs that satisfy the condition.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean is used to determine if removing two elements from the array still results in the same mean for the remaining elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'equal to': This indicates that the mean of the remaining elements must be the same as the original mean.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the mean k for each test case\" and \"Iterate over possible pairs of elements to remove\" should be considered simultaneously. \n    Explanation: While iterating over pairs, we can calculate the sum of the remaining elements and check if it equals (n-2) * k in the same loop to optimize the process.\n\n# [edge case] \n    1. Input: 3, [1, 1, 1] = 0\n       Explanation: With only three elements, removing any two will leave one element, which cannot maintain the original mean.\n    2. Input: 4, [0, 0, 0, 0] = 6\n       Explanation: All elements are the same, so any pair can be removed, resulting in 6 valid pairs.\n    3. Input: 5, [1, 2, 3, 4, 5] = 0\n       Explanation: No two elements can be removed to maintain the mean, as the elements are distinct and spread out.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n is minimal (e.g., n = 3) or where all elements are the same.\n    ```python\n    if n == 3:\n        print(0)\n        continue\n    if all(x == a[0] for x in a):\n        print(n * (n - 1) // 2)\n        continue\n    ```\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        target_sum = (n - 2) * k\n        count = 0\n        value_count = {}\n        \n        for value in a:\n            value_count[value] = value_count.get(value, 0) + 1\n        \n        for i in range(n):\n            value_count[a[i]] -= 1\n            for j in range(i + 1, n):\n                value_count[a[j]] -= 1\n                if total_sum - a[i] - a[j] == target_sum:\n                    count += 1\n                value_count[a[j]] += 1\n            value_count[a[i]] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Compute the sum of all elements in the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Determine the condition for maintaining the mean after removing two elements.\",\n      \"details\": \"For two elements a[i] and a[j] to be removed, the condition (a[i] + a[j]) = 2 * k must hold.\"\n    },\n    {\n      \"description\": \"Count the number of valid pairs (i, j) that satisfy the condition.\",\n      \"details\": \"Use a hashmap to store the frequency of each element and iterate through the array to find pairs that satisfy the condition.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the mean k for each test case\",\n      \"details\": \"Compute the sum of the array a and divide by n to get k.\"\n    },\n    {\n      \"step\": \"Check for each pair (i, j) if they satisfy the condition\",\n      \"details\": \"Iterate through the array and for each element a[i], calculate the required a[j] such that (a[i] + a[j]) = 2 * k. Use a hashmap to efficiently find and count such pairs.\"\n    },\n    {\n      \"step\": \"Output the result for each test case\",\n      \"details\": \"For each test case, output the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, it is denoted as k.\n\n    'pairs of positions [i, j]'\n    Explanation: This refers to selecting two distinct positions in the array such that removing the elements at these positions keeps the mean of the remaining elements the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: This means that precisely two elements must be removed from the array to check if the mean remains unchanged.\n\n    'equal to'\n    Explanation: The mean of the remaining elements after removing two should be equal to the original mean.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the mean k for each test case\" and \"Check for each pair (i, j) if they satisfy the condition\" should be considered simultaneously. \n    This can be done by calculating the mean once and then iterating through the array to find pairs that satisfy the condition using a hashmap for efficient lookup.\n\n# [edge case]\n    1. Input: 3\n       3\n       1 1 1\n       Expected Output: 1\n       Explanation: All elements are the same, so any pair can be removed.\n       \n    2. Input: 3\n       3\n       1 2 3\n       Expected Output: 0\n       Explanation: No pair can be removed to maintain the mean.\n       \n    3. Input: 4\n       4\n       2 2 2 2\n       Expected Output: 6\n       Explanation: All elements are the same, so any pair can be removed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a hashmap to find pairs that satisfy the condition (a[i] + a[j]) = 2 * k will handle these cases efficiently.\n\nNO", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # We need to find pairs (i, j) such that a[i] + a[j] = 2 * k\n        target_sum = 2 * k\n        \n        # Use a hashmap to count occurrences of each element\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        # Count valid pairs\n        valid_pairs = 0\n        \n        for num in a:\n            # Check if there is a complement that can form the target_sum with the current num\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            \n            # Increment the count of the current number\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"steps\": [\n        \"Sum all elements of the array.\",\n        \"Divide the sum by the number of elements to get the mean.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (i, j), calculate the sum of the remaining elements after removing a[i] and a[j].\",\n        \"Check if the mean of the remaining elements equals the initial mean.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"steps\": [\n        \"Use mathematical properties to simplify the condition for unchanged mean.\",\n        \"Implement efficient search techniques to reduce time complexity.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following:\",\n    \"Read the number of elements and the array.\",\n    \"Calculate the initial mean of the array.\",\n    \"Initialize a counter for valid pairs.\",\n    \"Iterate over all pairs of elements (i, j) with i < j:\",\n    \"Calculate the sum of the remaining elements after removing a[i] and a[j].\",\n    \"Check if the mean of the remaining elements equals the initial mean.\",\n    \"If valid, increment the counter.\",\n    \"Output the counter for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, it is crucial to maintain the mean after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we must remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to count all unique pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the sum of the remaining elements after removing a[i] and a[j]\" and \"Check if the mean of the remaining elements equals the initial mean\" should be implemented simultaneously. This can be done by iterating over all pairs and checking the condition in one loop.\n\n# [edge case]\n    1. Input: [3, 3, 3, 3] = 6\n       Explanation: All elements are the same, so any pair of elements can be removed without changing the mean.\n    2. Input: [1, 2, 3] = 0\n       Explanation: No pair of elements can be removed to maintain the mean since the array is too small.\n    3. Input: [1, 1, 1, 1, 1] = 10\n       Explanation: Similar to the first case, all elements are the same, so any pair can be removed.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are the same.\n    ```python\n    if all(x == array[0] for x in array):\n        return comb(n, 2)  # where comb is the combination function\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            # If all elements are the same, any pair can be removed\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying gives: total_sum - a[i] - a[j] == mean * (n - 2)\n        # Which further simplifies to: a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of elements\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        valid_pairs = 0\n        \n        for num in a:\n            # Check if there exists a number that can pair with `num` to form `target_sum`\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            \n            # Increment the count of the current number\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Compute the sum of all elements in the array and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify the condition for maintaining the mean after removing two elements.\",\n      \"details\": \"Determine the condition that must be satisfied by the two elements to be removed such that the mean of the remaining elements is still k.\"\n    },\n    {\n      \"description\": \"Count the number of valid pairs of indices (i, j) that satisfy the condition.\",\n      \"details\": \"Iterate over all possible pairs of indices (i, j) and check if removing these elements maintains the mean. Use efficient data structures to optimize the search.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse the input data.\",\n      \"details\": \"Read the number of test cases and for each test case, read the number of elements n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the initial mean k for each test case.\",\n      \"details\": \"For each test case, compute the sum of the array and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Determine the condition for valid pairs.\",\n      \"details\": \"For each test case, derive the condition that the sum of the two elements to be removed must equal 2 * k.\"\n    },\n    {\n      \"step\": \"Count valid pairs of indices (i, j) for each test case.\",\n      \"details\": \"Use a hash map or similar data structure to efficiently count pairs of elements that satisfy the condition derived in the previous step.\"\n    },\n    {\n      \"step\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, output the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean (or average) of a set of numbers is the sum of the numbers divided by the count of numbers. In this requirement, it refers to the mean of the array elements before and after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that precisely two elements must be removed from the array.\n    'equal to': This indicates that the mean of the remaining elements must be the same as the original mean.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the initial mean k for each test case\" and \"Determine the condition for valid pairs\" should be considered simultaneously. \n    Explanation: Once the mean is calculated, the condition for valid pairs (sum of two elements equals 2 * k) can be derived immediately, and these steps are logically connected.\n\n# [edge case] \n    1. Input: 3\n       3\n       1 1 1\n       Explanation: All elements are the same, so any pair can be removed. Expected output: 3 (since there are 3 pairs: (1,2), (1,3), (2,3))\n    2. Input: 3\n       3\n       1 2 3\n       Explanation: No pair can be removed to maintain the mean. Expected output: 0\n    3. Input: 4\n       4\n       2 2 2 2\n       Explanation: All elements are the same, so any pair can be removed. Expected output: 6 (since there are 6 pairs: (1,2), (1,3), (1,4), (2,3), (2,4), (3,4))\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking pairs where the sum equals 2 * k will naturally handle these cases.\n\nNO", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        target_sum = 2 * mean_k\n        \n        count = 0\n        value_count = {}\n        \n        for value in a:\n            complement = target_sum - value\n            if complement in value_count:\n                count += value_count[complement]\n            \n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        target_sum = 2 * mean_k\n        \n        count = 0\n        value_count = {}\n        \n        for value in a:\n            complement = target_sum - value\n            if complement in value_count:\n                count += value_count[complement]\n            \n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"steps\": [\n        \"Sum all elements of the array a.\",\n        \"Divide the sum by the number of elements n to get the mean k.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (a[i], a[j]), calculate the sum of the remaining elements after removing a[i] and a[j].\",\n        \"Check if the mean of the remaining elements equals k.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs to ensure efficiency.\",\n      \"steps\": [\n        \"Use mathematical properties to simplify the condition for mean equality.\",\n        \"Implement an efficient search strategy, possibly using hash maps or other data structures to reduce time complexity.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following:\",\n    \"Read the number of elements n and the array a.\",\n    \"Calculate the initial mean k of the array a.\",\n    \"Initialize a counter to track the number of valid pairs.\",\n    \"Iterate over all pairs of elements (i, j) with i < j:\",\n    \"Calculate the sum of the remaining elements after removing a[i] and a[j].\",\n    \"Check if the mean of the remaining elements equals k.\",\n    \"If the condition is satisfied, increment the counter.\",\n    \"Output the counter value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of a set of numbers is the sum of the numbers divided by the count of numbers. In this requirement, it refers to the mean of the array elements before and after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'sum divided by n': This indicates the calculation of the mean, where the sum of elements is divided by the number of elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the mean and checking pairs should be implemented simultaneously for efficiency. Specifically, the calculation of the mean and the checking of pairs can be optimized using mathematical properties and efficient data structures like hash maps.\n\n# [edge case]\n    Input: [3, 3, 3, 3] = 6\n    Explanation: All elements are the same, so any pair can be removed without changing the mean.\n    \n    Input: [1, 1, 1] = 0\n    Explanation: With only three elements, removing any two will leave one element, which cannot maintain the original mean.\n    \n    Input: [1, 2, 3, 4, 5] = 3\n    Explanation: Removing elements at positions 1 and 5 or 2 and 4 will maintain the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    - Use a hash map to store the frequency of each element.\n    - Calculate the required sum for the remaining elements to maintain the mean.\n    - Check pairs using the hash map to ensure efficient lookup and counting.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == k * (n - 2)\n        # a[i] + a[j] == total_sum - k * (n - 2)\n        \n        target_sum = total_sum - k * (n - 2)\n        \n        # Use a hashmap to count occurrences of each element\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        # Count the number of valid pairs\n        valid_pairs = 0\n        \n        for num in a:\n            # Check if there is a complement that forms the target_sum\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            \n            # Increment the count of the current number\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, true, false, true, false, false, true, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 698, "prompt": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer) and the mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i.e. sum divided by n), and Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the solutions are derived efficiently considering large inputs. Consider optimizing the algorithm to ensure it runs within a reasonable time frame for the maximum constraints.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 241}
