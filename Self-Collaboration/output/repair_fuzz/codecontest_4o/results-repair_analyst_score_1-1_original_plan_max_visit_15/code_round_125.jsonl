{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "repair_prompt": ["On the great island of Baltia, there live N people, numbered from 1 to N. There are precisely M pairs of individuals who are friends with each other. The inhabitants of Baltia are eager to throw a thriving party, but they adhere to very strict definitions of what constitutes a party and when it is deemed successful. On the island of Baltia, a party is a congregation of exactly 5 individuals. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "On the great island of Baltia, there live N people, numbered from 1 to N. There are precisely M pairs of individuals who are friends with each other. The inhabitants of Baltia are eager to throw a thriving party, but they adhere to very strict definitions of what constitutes a party and when it is deemed successful. On the island of Baltia, a party is a congregation of exactly 5 individuals. The party is considered to be successful if either all the people at the party are friends with each other, allowing them to talk to each other freely without worries, or no two people at the party are friends with each other, ensuring everyone can be on their phones without disturbance. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "On the great island of Baltia, there live N people, numbered from 1 to N. There are precisely M pairs of individuals who are friends with each other. The inhabitants of Baltia are eager to throw a thriving party, but they adhere to very strict definitions of what constitutes a party and when it is deemed successful. On the island of Baltia, a party is a congregation of exactly 5 individuals, and it is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        # If there are no friendships, any group of 5 people will have no friends among them\n        print(\"1 2 3 4 5\")\n        return\n    \n    # Read friendships\n    friendships = set()\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.add((u, v))\n        friendships.add((v, u))\n        index += 2\n    \n    # Check if all possible pairs are friends\n    if M >= (N * (N - 1)) // 2 - 1:\n        # If all possible pairs are friends, no group of 5 can have no friends among them\n        print(\"-1\")\n        return\n    \n    # Generate all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        # Check if all are friends or none are friends\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    # If no successful party is found\n    print(\"-1\")\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\" \".join(map(str, range(1, 6))))\n        return\n    \n    if M >= (N * (N - 1)) // 2:\n        print(-1)\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U_i = int(data[index])\n        V_i = int(data[index + 1])\n        friendships.add((U_i, V_i))\n        friendships.add((V_i, U_i))\n        index += 2\n    \n    people = list(range(1, N + 1))\n    \n    for combo in combinations(people, 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\" \".join(map(str, range(1, 6))))\n        return\n    elif M >= (N * (N - 1)) // 2:\n        print(-1)\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    people = list(range(1, N + 1))\n    \n    for combo in combinations(people, 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nimport itertools\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        # If there are no friendships, any 5 people can form a successful party\n        if N >= 5:\n            print(1, 2, 3, 4, 5)\n        else:\n            print(-1)\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combination in itertools.combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combination[i], combination[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(*combination)\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_successful_party():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create adjacency list\n    friends = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for independent set of 5 nodes\n    if M == 0:\n        # If there are no friendships, any 5 people form an independent set\n        print(1, 2, 3, 4, 5)\n        return\n    \n    # Check for complete subgraph of 5 nodes\n    for person in range(1, N + 1):\n        if len(friends[person]) >= 4:\n            # Check if this person and 4 of their friends form a clique\n            potential_clique = [person] + list(friends[person])[:4]\n            is_clique = True\n            for i in range(5):\n                for j in range(i + 1, 5):\n                    if potential_clique[j] not in friends[potential_clique[i]]:\n                        is_clique = False\n                        break\n                if not is_clique:\n                    break\n            if is_clique:\n                print(*potential_clique)\n                return\n    \n    # Check for independent set of 5 nodes\n    non_friends = set(range(1, N + 1))\n    for person in range(1, N + 1):\n        if len(friends[person]) <= N - 5:\n            # Check if this person and 4 others not friends with them form an independent set\n            potential_independent_set = [person]\n            for other in non_friends:\n                if other != person and other not in friends[person]:\n                    potential_independent_set.append(other)\n                if len(potential_independent_set) == 5:\n                    print(*potential_independent_set)\n                    return\n    \n    # If no successful party configuration is found\n    print(-1)\n\n# Call the function to execute\nfind_successful_party()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.add((u, v))\n        friendships.add((v, u))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\" \".join(map(str, range(1, 6))))\n        return\n    \n    if M > (N * (N - 1)) // 2 - 5:\n        print(-1)\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.add((u, v))\n        friendships.add((v, u))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_successful_party():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    elif M >= (N * (N - 1)) // 2 - 1:\n        print(\"1 2 3 4 5\")\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a clique of 5\n    for person in range(1, N + 1):\n        if len(friendships[person]) >= 4:\n            potential_clique = [person] + list(friendships[person])\n            if len(potential_clique) >= 5:\n                for i in range(5):\n                    for j in range(i + 1, 5):\n                        if potential_clique[j] not in friendships[potential_clique[i]]:\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    print(\" \".join(map(str, potential_clique[:5])))\n                    return\n    \n    # Check for an independent set of 5\n    non_friends = set(range(1, N + 1))\n    for person in range(1, N + 1):\n        if len(friendships[person]) <= N - 5:\n            potential_independent_set = non_friends - friendships[person]\n            if len(potential_independent_set) >= 5:\n                print(\" \".join(map(str, list(potential_independent_set)[:5])))\n                return\n    \n    print(-1)\n\nfind_successful_party()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all possible combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        # Check if all are friends or none are friends\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        # If there are no friendships, any group of 5 people will have no friends among them\n        print(\"1 2 3 4 5\")\n        return\n    \n    # Read friendships\n    friendships = set()\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.add((u, v))\n        friendships.add((v, u))\n        index += 2\n    \n    # Check if all possible pairs are friends\n    if M >= (N * (N - 1)) // 2 - 1:\n        # If all possible pairs are friends, no group of 5 can have no friends among them\n        print(\"-1\")\n        return\n    \n    # Generate all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        # Check if all are friends or none are friends\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    # If no successful party is found\n    print(\"-1\")\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendships.\",\n      \"output\": \"A list of friendships and the values of N and M.\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph data structure representing friendships.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 people from the N people.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if all are friends with each other or if none are friends with each other.\",\n      \"output\": \"A boolean indicating whether a successful party configuration is found.\"\n    },\n    {\n      \"description\": \"If a successful party configuration is found, output the 5 people. If none is found after checking all combinations, output -1.\",\n      \"output\": \"The indices of the 5 people for a successful party or -1 if impossible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendships.\",\n    \"Construct a graph to represent friendships using an adjacency list or matrix.\",\n    \"Generate all possible combinations of 5 people from the N people.\",\n    \"For each combination, check if it forms a successful party by verifying the friendship conditions.\",\n    \"If a successful party is found, print the combination. If no successful party is found after checking all combinations, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 individuals.\n    'successful party': A party where either all individuals are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 individuals.\n    'no two people': Indicates that none of the individuals at the party should be friends with each other for one type of successful party.\n\n# [degree adverb]\n    'successful': Refers to the condition where either all individuals are friends or none are friends at the party.\n\n# [code logic]\n    The steps related to checking the friendship conditions for each combination should be implemented simultaneously. Specifically:\n    - \"For each 5-person combination, check if all are friends with each other or if none are friends with each other.\"\n    This can be done by iterating through each combination and checking both conditions in a single code block.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people will have no friends among them, making the party successful.\n    \n    Input: 5 10\n    Output: -1\n    Explanation: If all possible pairs are friends, then no group of 5 can have no friends among them, making it impossible to have a successful party.\n    \n    Input: 6 15\n    Output: 1 2 3 4 5\n    Explanation: If all 6 people are friends with each other, any group of 5 will be a successful party.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where M = 0 or M is very large (close to N choose 2).\n    - If M = 0, directly return any 5 people.\n    - If M is large enough that all possible pairs are friends, check if any group of 5 can be formed without friendships.\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        # If there are no friendships, any group of 5 people will have no friends among them\n        print(\"1 2 3 4 5\")\n        return\n    \n    # Read friendships\n    friendships = set()\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.add((u, v))\n        friendships.add((v, u))\n        index += 2\n    \n    # Check if all possible pairs are friends\n    if M >= (N * (N - 1)) // 2 - 1:\n        # If all possible pairs are friends, no group of 5 can have no friends among them\n        print(\"-1\")\n        return\n    \n    # Generate all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        # Check if all are friends or none are friends\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    # If no successful party is found\n    print(\"-1\")\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph data structure representing friendships among people.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 people from the N people.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each combination of 5 people, check if they are all friends with each other or if no two of them are friends.\",\n      \"output\": \"A boolean indicating whether a given combination is a successful party.\"\n    },\n    {\n      \"description\": \"Determine if there exists at least one successful party combination.\",\n      \"output\": \"A successful party combination or -1 if none exists.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendship pairs.\",\n    \"Construct a graph to represent friendships using the parsed data.\",\n    \"Generate all possible combinations of 5 people from the N people.\",\n    \"For each combination, check if it satisfies the conditions of a successful party (either all friends or no friends).\",\n    \"If a successful party is found, output the combination. If no successful party is found after checking all combinations, output -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 individuals.\n    'successful party': A party where either all 5 individuals are friends with each other, or none of them are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': This means the party must consist of precisely 5 people, no more, no less. In code, this can be implemented by generating combinations of 5 people from the list of N people.\n    'no two people': This means that in one scenario, none of the 5 people should have a friendship link with any other in the group. This can be checked by ensuring no edges exist between any pair in the combination.\n\n# [degree adverb]\n    'successful': This refers to the condition that must be met for the party to be considered valid. In code, this is a boolean check for the conditions of all friends or no friends.\n\n# [code logic]\n    The steps \"Generate all possible combinations of 5 people from the N people\" and \"For each combination, check if it satisfies the conditions of a successful party\" should be implemented simultaneously. This can be done by iterating over each combination and checking the conditions in the same loop.\n\n# [edge case]\n    1. Input: 5 0\n       Output: 1 2 3 4 5\n       Explanation: With no friendships, any group of 5 people will have no friends, thus satisfying the condition of no two people being friends.\n    2. Input: 5 10\n       Output: 1 2 3 4 5\n       Explanation: With maximum friendships, any group of 5 people will all be friends, thus satisfying the condition of all being friends.\n    3. Input: 6 0\n       Output: 1 2 3 4 5\n       Explanation: With no friendships, any group of 5 people will have no friends, thus satisfying the condition of no two people being friends.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking all combinations of 5 people will naturally handle these scenarios.\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph data structure representing friendships among people.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 people from the N people.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if they form a successful party by verifying the two conditions: all are friends or none are friends.\",\n      \"output\": \"A boolean indicating whether a successful party is possible for each combination.\"\n    },\n    {\n      \"description\": \"If a successful party is found, output the combination of 5 people. If no successful party is found after checking all combinations, output -1.\",\n      \"output\": \"The indices of 5 people forming a successful party or -1 if impossible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendships.\",\n    \"Construct a graph to represent friendships using an adjacency list or matrix.\",\n    \"Generate all possible combinations of 5 people from the N people.\",\n    \"For each combination, check if all 5 people are friends or if none of them are friends using the graph.\",\n    \"If a successful party is found, print the combination. If no successful party is found, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 individuals where either all are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': This means the party must consist of precisely 5 people, no more, no less.\n    'no two people': This means that in one scenario, none of the 5 people should have a friendship connection with each other.\n\n# [degree adverb]\n    'successful': This indicates the condition that must be met for the party to be considered successful, either all are friends or none are friends.\n\n# [code logic]\n    The steps \"Generate all possible combinations of 5 people from the N people\" and \"For each combination, check if all 5 people are friends or if none of them are friends using the graph\" should be implemented simultaneously. This can be done by iterating through each combination and checking the friendship conditions in the same loop.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With 0 friendships, any combination of 5 people will have no friendships, thus forming a successful party.\n    \n    Input: 5 10\n    Output: -1\n    Explanation: If all possible pairs among 5 people are friends, then no combination can satisfy the condition of none being friends.\n    \n    Input: 6 15\n    Output: -1\n    Explanation: If every person is friends with every other person, no combination of 5 can satisfy the condition of none being friends.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where M = 0 or M is very large.\n    ```python\n    if M == 0:\n        print(\" \".join(map(str, range(1, 6))))\n        return\n    if M >= (N * (N - 1)) // 2:\n        print(-1)\n        return\n    ```\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\" \".join(map(str, range(1, 6))))\n        return\n    \n    if M >= (N * (N - 1)) // 2:\n        print(-1)\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U_i = int(data[index])\n        V_i = int(data[index + 1])\n        friendships.add((U_i, V_i))\n        friendships.add((V_i, U_i))\n        index += 2\n    \n    people = list(range(1, N + 1))\n    \n    for combo in combinations(people, 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph data structure representing friendships.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 people from the N people.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if all are friends with each other or none are friends with each other.\",\n      \"output\": \"A boolean indicating if a successful party configuration is found.\"\n    },\n    {\n      \"description\": \"If a successful party configuration is found, return the combination. If none is found after checking all combinations, return -1.\",\n      \"output\": \"A list of 5 people or -1.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendship pairs.\",\n    \"Construct a graph to represent the friendships using an adjacency list or matrix.\",\n    \"Generate all possible combinations of 5 people from the N people.\",\n    \"For each combination, check if it forms a successful party by verifying the friendship conditions.\",\n    \"If a successful party is found, output the combination. If no successful party is found after checking all combinations, output -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a group of exactly 5 individuals where either all are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': means the party must consist of precisely 5 people.\n    Implementation: Ensure that any combination of people selected for the party has exactly 5 members.\n\n# [degree adverb]\n    'successful': means the party must meet the strict conditions of friendship (either all friends or none).\n    Implementation: Check each combination of 5 people to see if they meet the friendship conditions.\n\n# [code logic]\n    The steps \"Identify all possible combinations of 5 people from the N people\" and \"For each 5-person combination, check if all are friends with each other or none are friends with each other\" should be implemented simultaneously.\n    Explanation: As you generate each combination, immediately check the friendship conditions to avoid unnecessary computations.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people will have no friends among them, thus forming a successful party.\n    \n    Input: 5 10\n    Output: -1\n    Explanation: If all possible pairs are friends, then no group of 5 can have no friends among them, failing the second condition.\n    \n    Input: 6 15\n    Output: 1 2 3 4 5\n    Explanation: If all 6 people are friends with each other, any group of 5 will satisfy the condition of all being friends.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling the edge case:\n    ```python\n    if M == 0:\n        print(\" \".join(map(str, range(1, 6))))\n    elif M >= (N * (N - 1)) // 2:\n        print(-1)\n    else:\n        # Original logic to find a successful party\n    ```\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\" \".join(map(str, range(1, 6))))\n        return\n    elif M >= (N * (N - 1)) // 2:\n        print(-1)\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    people = list(range(1, N + 1))\n    \n    for combo in combinations(people, 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized.\",\n      \"steps\": [\n        \"Check for a complete subgraph of 5 people where all are friends with each other.\",\n        \"Check for a set of 5 people where no two are friends with each other.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, print the 5 people.\",\n        \"If no configuration is found, print -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Create a data structure to represent the friendships (e.g., adjacency list or matrix).\",\n    \"Iterate over possible combinations of 5 people to check for a successful party configuration.\",\n    \"For each combination, check if all 5 are friends or none are friends using the friendship data structure.\",\n    \"Output the first successful configuration found or -1 if none exist.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party on the island of Baltia is defined as a gathering of exactly 5 individuals where either all individuals are friends with each other or none of them are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': This means the party must consist of precisely 5 people, no more, no less.\n    'all the people': This implies that every person in the group of 5 must be friends with every other person in the group.\n    'no two people': This means that none of the people in the group of 5 should be friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps to check for a complete subgraph of 5 people where all are friends and the steps to check for a set of 5 people where no two are friends should be implemented simultaneously. This can be done by iterating over all combinations of 5 people and checking both conditions for each combination.\n\n# [edge case]\n    5 0\n    Explanation: With 5 people and 0 friendships, the only possible configuration is that no two people are friends, which is a successful party. The output should be any combination of the 5 people, e.g., 1 2 3 4 5.\n    \n    6 15\n    Explanation: With 6 people and 15 friendships, it is possible that all people are friends with each other. If a complete subgraph of 5 people exists, the output should be those 5 people.\n    \n    5 10\n    Explanation: With 5 people and 10 friendships, all people are friends with each other, which is a successful party. The output should be 1 2 3 4 5.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - For the case where M = 0, we can directly return any 5 people if N >= 5.\n    - For the case where M is large enough to potentially form a complete subgraph, we need to check for such a subgraph.\n\nYES", "Round_0": {"code": "import sys\nimport itertools\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        # If there are no friendships, any 5 people can form a successful party\n        if N >= 5:\n            print(1, 2, 3, 4, 5)\n        else:\n            print(-1)\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combination in itertools.combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combination[i], combination[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(*combination)\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"details\": \"Read the first line to get N and M. Then read the next M lines to get the pairs of friends.\"\n    },\n    {\n      \"description\": \"Determine if there exists a group of 5 people where all are friends with each other.\",\n      \"details\": \"Check if there is a complete subgraph of 5 nodes in the friendship graph.\"\n    },\n    {\n      \"description\": \"Determine if there exists a group of 5 people where no two are friends with each other.\",\n      \"details\": \"Check if there is an independent set of 5 nodes in the friendship graph.\"\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"details\": \"If a successful party configuration is found, output the 5 people. Otherwise, output -1.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the list of friendship pairs.\",\n    \"Construct a graph representation using adjacency lists or adjacency matrix.\",\n    \"Check for a complete subgraph of 5 nodes (clique detection).\",\n    \"Check for an independent set of 5 nodes.\",\n    \"If either a complete subgraph or an independent set is found, print the 5 nodes. Otherwise, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 individuals.\n    'successful party': A party where either all individuals are friends with each other or no two individuals are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 individuals.\n    Implementation: Ensure that any group considered for the party has exactly 5 members.\n    'no two': Indicates that none of the individuals in the group should be friends with each other.\n    Implementation: Check that there are no edges between any of the selected 5 nodes in the graph.\n\n# [degree adverb]\n    'successful': Refers to the condition where either all individuals are friends or none are friends.\n    Implementation: Check for either a complete subgraph (clique) or an independent set of 5 nodes.\n\n# [code logic]\n    The steps for checking a complete subgraph and an independent set should be considered simultaneously as they both aim to find a successful party configuration. This can be implemented using two separate checks within the same function or code block.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any 5 individuals form an independent set.\n    \n    Input: 5 10\n    Output: -1\n    Explanation: If all possible pairs are friends, a complete subgraph is formed, but if the graph is not complete, it might not be possible to form a successful party.\n    \n    Input: 6 15\n    Output: 1 2 3 4 5\n    Explanation: If there are enough friendships to form a complete subgraph of 5 nodes, a successful party can be formed.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Implement checks for both complete subgraph and independent set within the same function.\n    - Use graph traversal techniques to efficiently find cliques and independent sets.\n\nYES", "Round_0": {"code": "def find_successful_party(N, M, friendships):\n    from collections import defaultdict\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    # Create adjacency list\n    friends = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for independent set of 5 nodes\n    if M == 0:\n        # If there are no friendships, any 5 people form an independent set\n        print(1, 2, 3, 4, 5)\n        return\n    \n    # Check for complete subgraph of 5 nodes\n    for person in range(1, N + 1):\n        if len(friends[person]) >= 4:\n            # Check if this person and 4 of their friends form a clique\n            potential_clique = [person] + list(friends[person])[:4]\n            is_clique = True\n            for i in range(5):\n                for j in range(i + 1, 5):\n                    if potential_clique[j] not in friends[potential_clique[i]]:\n                        is_clique = False\n                        break\n                if not is_clique:\n                    break\n            if is_clique:\n                print(*potential_clique)\n                return\n    \n    # Check for independent set of 5 nodes\n    non_friends = set(range(1, N + 1))\n    for person in range(1, N + 1):\n        if len(friends[person]) <= N - 5:\n            # Check if this person and 4 others not friends with them form an independent set\n            potential_independent_set = [person]\n            for other in non_friends:\n                if other != person and other not in friends[person]:\n                    potential_independent_set.append(other)\n                if len(potential_independent_set) == 5:\n                    print(*potential_independent_set)\n                    return\n    \n    # If no successful party configuration is found\n    print(-1)", "report": "The compilation output of the preceding code is: find_successful_party() missing 3 required positional arguments: 'N', 'M', and 'friendships'"}, "Round_1": {"code": "def find_successful_party():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create adjacency list\n    friends = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for independent set of 5 nodes\n    if M == 0:\n        # If there are no friendships, any 5 people form an independent set\n        print(1, 2, 3, 4, 5)\n        return\n    \n    # Check for complete subgraph of 5 nodes\n    for person in range(1, N + 1):\n        if len(friends[person]) >= 4:\n            # Check if this person and 4 of their friends form a clique\n            potential_clique = [person] + list(friends[person])[:4]\n            is_clique = True\n            for i in range(5):\n                for j in range(i + 1, 5):\n                    if potential_clique[j] not in friends[potential_clique[i]]:\n                        is_clique = False\n                        break\n                if not is_clique:\n                    break\n            if is_clique:\n                print(*potential_clique)\n                return\n    \n    # Check for independent set of 5 nodes\n    non_friends = set(range(1, N + 1))\n    for person in range(1, N + 1):\n        if len(friends[person]) <= N - 5:\n            # Check if this person and 4 others not friends with them form an independent set\n            potential_independent_set = [person]\n            for other in non_friends:\n                if other != person and other not in friends[person]:\n                    potential_independent_set.append(other)\n                if len(potential_independent_set) == 5:\n                    print(*potential_independent_set)\n                    return\n    \n    # If no successful party configuration is found\n    print(-1)\n\n# Call the function to execute\nfind_successful_party()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendships.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph data structure representing friendships among people.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 people from the N people.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if all are friends with each other or if none are friends with each other.\",\n      \"output\": \"A boolean indicating whether a successful party configuration is found.\"\n    },\n    {\n      \"description\": \"If a successful party configuration is found, output the 5 people. If none is found after checking all combinations, output -1.\",\n      \"output\": \"The indices of 5 people for a successful party or -1 if impossible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to get N, M, and the list of friendships.\",\n    \"Construct a graph to represent friendships using an adjacency list or matrix.\",\n    \"Generate all possible combinations of 5 people from the N people.\",\n    \"For each combination, check if it forms a successful party by verifying the friendship conditions.\",\n    \"If a successful party is found, print the indices of the 5 people. If no such combination exists, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a group of exactly 5 people where either all are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': This means the party must consist of precisely 5 individuals.\n    Implementation: Ensure that any combination of people considered for the party has exactly 5 members.\n\n# [degree adverb]\n    'successful': This refers to the condition where either all 5 people are friends or none are friends.\n    Implementation: Check each combination of 5 people to see if they meet the criteria for a successful party.\n\n# [code logic]\n    The steps \"Identify all possible combinations of 5 people from the N people\" and \"For each 5-person combination, check if all are friends with each other or if none are friends with each other\" should be implemented simultaneously.\n    Explanation: As you generate each combination, immediately check the friendship conditions to avoid unnecessary computations.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people will have no friends among them, thus forming a successful party.\n    \n    Input: 5 10\n    Output: -1\n    Explanation: If every possible pair among 5 people is a friendship, then all are friends, forming a successful party. However, if the friendships are such that not all are friends, it may be impossible to form a successful party.\n    \n    Input: 6 15\n    Output: -1\n    Explanation: If the friendships are such that no group of 5 can be all friends or none friends, then it's impossible to form a successful party.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: Implement checks for cases where M = 0 (no friendships) and cases where M is large enough to potentially cover all pairs among 5 people.\n    Code:\n    ```python\n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    if M >= 10:  # Maximum number of pairs among 5 people\n        # Check if all pairs among any 5 people are covered\n        # If not, proceed with normal logic\n    ```\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.add((u, v))\n        friendships.add((v, u))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"A list of friendships and the total number of people.\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph data structure representing friendships between people.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 people from the total N people.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if all are friends with each other or if none are friends with each other.\",\n      \"output\": \"A boolean indicating whether a successful party configuration is found.\"\n    },\n    {\n      \"description\": \"If a successful party configuration is found, output the combination. If none are found after checking all combinations, output -1.\",\n      \"output\": \"The indices of the 5 people forming a successful party or -1 if impossible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to get N, M, and the list of friendships.\",\n    \"Construct a graph to represent friendships using an adjacency list or matrix.\",\n    \"Generate all possible combinations of 5 people from the N people.\",\n    \"For each combination, check if it forms a successful party by verifying the friendship conditions.\",\n    \"If a successful party is found, print the combination. If no successful party is found after checking all combinations, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a group of exactly 5 people where either all are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': This means the party must consist of precisely 5 individuals, no more, no less.\n    'no two people': This means that in one scenario, none of the 5 people should have a friendship connection with each other.\n\n# [degree adverb]\n    'successful': This indicates the condition that must be met for the party to be considered successful, either all are friends or none are friends.\n\n# [code logic]\n    The steps \"Identify all possible combinations of 5 people from the total N people\" and \"For each 5-person combination, check if all are friends with each other or if none are friends with each other\" should be implemented simultaneously. This can be done by iterating through each combination and checking the friendship conditions in the same loop.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With 0 friendships, any group of 5 people will have no friendships, thus forming a successful party.\n    \n    Input: 5 10\n    Output: -1\n    Explanation: If there are 10 friendships among 5 people, it implies a complete graph, making it impossible to have a group where none are friends.\n    \n    Input: 6 15\n    Output: -1\n    Explanation: With 15 friendships among 6 people, it is likely that no group of 5 can be formed where all are friends or none are friends.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where M = 0 or M is very high.\n    ```\n    if M == 0:\n        print(\" \".join(map(str, range(1, 6))))\n        return\n    if M > (N * (N - 1)) // 2 - 5:\n        print(-1)\n        return\n    ```\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\" \".join(map(str, range(1, 6))))\n        return\n    \n    if M > (N * (N - 1)) // 2 - 5:\n        print(-1)\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.add((u, v))\n        friendships.add((v, u))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs (U_i, V_i).\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized.\",\n      \"steps\": [\n        \"Check for a clique of 5 people where all are friends with each other.\",\n        \"Check for a set of 5 people where no two are friends with each other.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party is possible, output the 5 people.\",\n        \"If no successful party is possible, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Create a graph representation of the friendships.\",\n    \"Search for a clique of 5 people in the graph.\",\n    \"Search for an independent set of 5 people in the graph.\",\n    \"Output the result based on whether a successful party configuration was found.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 individuals where either all are friends with each other (a clique) or none are friends with each other (an independent set).\n\n# [phrase showing quantity relationship]\n    'exactly 5': This means the party must consist of precisely 5 people, no more, no less.\n    'all the people': This implies that every person in the group of 5 must be friends with every other person in the group.\n    'no two people': This means that in the group of 5, no pair of individuals should be friends.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps to check for a clique of 5 people and a set of 5 people where no two are friends should be considered simultaneously. This can be implemented using graph traversal algorithms to check both conditions in one pass through the graph.\n\n# [edge case]\n    5 0\n    Explanation: With 5 people and 0 friendships, the only possible configuration is an independent set of 5 people, which is a successful party.\n    5 10\n    Explanation: With 5 people and 10 friendships, every person is friends with every other person, forming a clique, which is a successful party.\n    6 15\n    Explanation: With 6 people and 15 friendships, it is possible to have a clique of 5 people, as the maximum number of friendships indicates a complete graph.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - For the case where M = 0, we can directly return the first 5 people as an independent set.\n    - For the case where M is large enough to form a complete graph, we can directly return any 5 people as a clique.\n    ```python\n    if M == 0:\n        print(\"1 2 3 4 5\")\n    elif M >= (N * (N - 1)) // 2 - 1:\n        print(\"1 2 3 4 5\")\n    else:\n        # Original logic to find a successful party\n    ```\n\nYES", "Round_0": {"code": "def find_successful_party():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    elif M >= (N * (N - 1)) // 2 - 1:\n        print(\"1 2 3 4 5\")\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a clique of 5\n    for person in range(1, N + 1):\n        if len(friendships[person]) >= 4:\n            potential_clique = [person] + list(friendships[person])\n            if len(potential_clique) >= 5:\n                for i in range(5):\n                    for j in range(i + 1, 5):\n                        if potential_clique[j] not in friendships[potential_clique[i]]:\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    print(\" \".join(map(str, potential_clique[:5])))\n                    return\n    \n    # Check for an independent set of 5\n    non_friends = set(range(1, N + 1))\n    for person in range(1, N + 1):\n        if len(friendships[person]) <= N - 5:\n            potential_independent_set = non_friends - friendships[person]\n            if len(potential_independent_set) >= 5:\n                print(\" \".join(map(str, list(potential_independent_set)[:5])))\n                return\n    \n    print(-1)\n\nfind_successful_party()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_successful_party():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    elif M >= (N * (N - 1)) // 2 - 1:\n        print(\"1 2 3 4 5\")\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a clique of 5\n    for person in range(1, N + 1):\n        if len(friendships[person]) >= 4:\n            potential_clique = [person] + list(friendships[person])\n            if len(potential_clique) >= 5:\n                for i in range(5):\n                    for j in range(i + 1, 5):\n                        if potential_clique[j] not in friendships[potential_clique[i]]:\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    print(\" \".join(map(str, potential_clique[:5])))\n                    return\n    \n    # Check for an independent set of 5\n    non_friends = set(range(1, N + 1))\n    for person in range(1, N + 1):\n        if len(friendships[person]) <= N - 5:\n            potential_independent_set = non_friends - friendships[person]\n            if len(potential_independent_set) >= 5:\n                print(\" \".join(map(str, list(potential_independent_set)[:5])))\n                return\n    \n    print(-1)\n\nfind_successful_party()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendships.\",\n      \"input\": \"Raw input data\",\n      \"output\": \"Integers N, M and a list of tuples representing friendships\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list.\",\n      \"input\": \"List of friendships\",\n      \"output\": \"Adjacency list representing the graph\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 people from the N people.\",\n      \"input\": \"Integer N\",\n      \"output\": \"List of all possible 5-person combinations\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if they are all friends with each other or if none of them are friends with each other.\",\n      \"input\": \"5-person combination and adjacency list\",\n      \"output\": \"Boolean indicating if the combination is a successful party\"\n    },\n    {\n      \"description\": \"Determine if there is at least one successful party combination.\",\n      \"input\": \"Results from checking each 5-person combination\",\n      \"output\": \"5-person combination if successful, otherwise -1\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the list of friendships.\",\n    \"Create an adjacency list to represent the friendships as a graph.\",\n    \"Generate all possible combinations of 5 people from the N people.\",\n    \"For each combination, check if all 5 people are friends with each other or if none of them are friends with each other using the adjacency list.\",\n    \"If a successful party is found, output the 5-person combination. If no successful party is found after checking all combinations, output -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 individuals.\n    'successful party': A party where either all 5 individuals are friends with each other or none of them are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 individuals.\n    'all': All 5 individuals must be friends with each other.\n    'no two': None of the 5 individuals should be friends with each other.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps \"Generate all possible combinations of 5 people from the N people\" and \"For each combination, check if all 5 people are friends with each other or if none of them are friends with each other using the adjacency list\" should be implemented simultaneously. This can be done by iterating over each combination and checking the friendship conditions in the same loop.\n\n# [edge case] \n    1. Input: 5 0\n       Output: 1 2 3 4 5\n       Explanation: With 5 people and no friendships, any combination of 5 people will have no friendships, thus forming a successful party.\n    2. Input: 5 10\n       Output: 1 2 3 4 5\n       Explanation: With 5 people and all possible friendships, any combination of 5 people will have all friendships, thus forming a successful party.\n    3. Input: 6 15\n       Output: -1\n       Explanation: If all 6 people are friends with each other, no combination of 5 people can have no friendships, so a successful party with no friendships is impossible.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each combination for the friendship conditions will naturally handle these cases.\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all possible combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        # Check if all are friends or none are friends\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendships.\",\n      \"output\": \"A list of friendships and the values of N and M.\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph data structure representing friendships.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 people from the N people.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if all are friends with each other or if none are friends with each other.\",\n      \"output\": \"A boolean indicating whether a successful party configuration is found.\"\n    },\n    {\n      \"description\": \"If a successful party configuration is found, output the 5 people. If none is found after checking all combinations, output -1.\",\n      \"output\": \"The indices of the 5 people for a successful party or -1 if impossible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendships.\",\n    \"Construct a graph to represent friendships using an adjacency list or matrix.\",\n    \"Generate all possible combinations of 5 people from the N people.\",\n    \"For each combination, check if it forms a successful party by verifying the friendship conditions.\",\n    \"If a successful party is found, print the combination. If no successful party is found after checking all combinations, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 individuals.\n    'successful party': A party where either all individuals are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 individuals.\n    'no two people': Indicates that none of the individuals at the party should be friends with each other for one type of successful party.\n\n# [degree adverb]\n    'successful': Refers to the condition where either all individuals are friends or none are friends at the party.\n\n# [code logic]\n    The steps related to checking the friendship conditions for each combination should be implemented simultaneously. Specifically:\n    - \"For each 5-person combination, check if all are friends with each other or if none are friends with each other.\"\n    This can be done by iterating through each combination and checking both conditions in a single code block.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people will have no friends among them, making the party successful.\n    \n    Input: 5 10\n    Output: -1\n    Explanation: If all possible pairs are friends, then no group of 5 can have no friends among them, making it impossible to have a successful party.\n    \n    Input: 6 15\n    Output: 1 2 3 4 5\n    Explanation: If all 6 people are friends with each other, any group of 5 will be a successful party.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where M = 0 or M is very large (close to N choose 2).\n    - If M = 0, directly return any 5 people.\n    - If M is large enough that all possible pairs are friends, check if any group of 5 can be formed without friendships.\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        # If there are no friendships, any group of 5 people will have no friends among them\n        print(\"1 2 3 4 5\")\n        return\n    \n    # Read friendships\n    friendships = set()\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.add((u, v))\n        friendships.add((v, u))\n        index += 2\n    \n    # Check if all possible pairs are friends\n    if M >= (N * (N - 1)) // 2 - 1:\n        # If all possible pairs are friends, no group of 5 can have no friends among them\n        print(\"-1\")\n        return\n    \n    # Generate all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        # Check if all are friends or none are friends\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    # If no successful party is found\n    print(\"-1\")\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, true, true, true, false, true, true, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 125, "prompt": "On the great island of Baltia, there live N people, numbered from 1 to N. There are precisely M pairs of individuals who are friends with each other. The inhabitants of Baltia are eager to throw a thriving party, but they adhere to very strict definitions of what constitutes a party and when it is deemed successful. On the island of Baltia, a party is a congregation of exactly 5 individuals. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "rephrase_one", "save_node": true, "parent_index": 99}
