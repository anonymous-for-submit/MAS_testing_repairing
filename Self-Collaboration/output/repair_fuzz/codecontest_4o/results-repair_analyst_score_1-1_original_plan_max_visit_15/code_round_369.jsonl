{"name": "1579_B. Shifting Sort", "description": "The new generation external memory contains an array of integers a[1 \u2026 n] = [a_1, a_2, \u2026, a_n].\n\nThis type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place.\n\nTechnically, each cyclic shift consists of two consecutive actions: \n\n  1. You may select arbitrary indices l and r (1 \u2264 l < r \u2264 n) as the boundaries of the segment. \n  2. Then you replace the segment a[l \u2026 r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. \n\n\n\nFor example, if a = [1, \\color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 \u2026 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of of the original elements of the segment. In the end you get a = [1, \\color{blue}{8, 3, 2}, 5].\n\nSort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] ", "tags": ["implementation", "sortings"], "difficulty": 8, "id": 1579, "sample_io": [{"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}], "test_list": [{"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 1 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n1 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 4\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n0 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n1 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 1 1\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 1 1\n4\n2 4 -1 5\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n0\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n2 4 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n2 4 0\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 5\n5\n2 10 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 5\n5\n2 10 2 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 1 1\n4\n2 4 -1 5\n5\n2 6 1 4 3\n", "output": ["0\n0\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 0 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n0\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n1 1\n3\n1 2 1\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n1 2 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n1\n2 3 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 4 0\n4\n0 6 1 3\n5\n2 5 1 0 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 3\n5\n2 3 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n1 2\n3\n1 2 1\n4\n1 4 1 3\n5\n2 5 1 6 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 4 0 5\n5\n2 10 1 4 3\n", "output": ["0\n1\n2 3 1\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 4 1 3\n5\n2 0 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 2 1\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n0 2 0\n4\n-1 6 1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 1 3\n5\n1 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 6 0 5\n5\n2 10 2 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n1 1\n3\n1 2 1\n4\n1 4 0 3\n5\n0 5 1 4 0\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 5 3\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n0 4 -1 4\n5\n2 5 2 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 0\n4\n2 3 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 4 0 5\n5\n2 3 1 4 3\n", "output": ["0\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n4 8 -1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n2 4 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 3 1\n4\n2 13 -1 3\n5\n0 0 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 1 1\n4\n2 13 -1 3\n5\n0 0 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n3 4 1\n1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n0 4 -1 3\n5\n2 0 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n0 4 -1 3\n5\n2 0 -1 1 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n2 3 1\n3 4 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 4\n5\n2 8 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n1 3 2\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 2 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n2 3 1\n3 4 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n-1 2 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n2 3 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n0 2 0\n4\n-1 6 1 0\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 4 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n0 4 -1 4\n5\n2 5 1 8 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n1 4 0\n4\n0 2 1 3\n5\n2 5 1 0 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n2 3 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 4 0\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n4 3 0\n4\n0 6 1 3\n5\n2 3 1 4 3\n", "output": ["1\n1 2 1\n2\n1 3 2\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 0 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["0\n0\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 0 0 3\n5\n2 5 1 8 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n0\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n3 0\n3\n2 4 0\n4\n0 15 1 0\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 4 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 4\n5\n0 5 1 4 11\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 1 0 5\n5\n2 3 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n2 3 1\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 8 -1 3\n5\n0 5 1 8 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n2 3 1\n3 5 2\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n1 9 1 3\n5\n1 5 2 4 0\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 5 4\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 1 1\n4\n4 8 -1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n2 4 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n1 4 -1 3\n5\n1 28 -1 4 5\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n0 2 -1 3\n5\n2 0 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n1 3 2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 2\n4\n2 4 2 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 0 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 0\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 4 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n1 4 0 3\n5\n0 10 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 5 3\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n4 1\n3\n1 5 0\n4\n0 6 1 3\n5\n2 5 1 7 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 8 1 3\n5\n2 5 1 8 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 4 1\n4\n2 4 0 5\n5\n2 10 2 4 3\n", "output": ["0\n1\n2 3 1\n1\n1 3 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 4 0\n4\n0 2 1 3\n5\n4 5 1 0 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n2 3 1\n3\n1 4 3\n2 4 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 4\n5\n4 5 1 6 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n2\n1 3 2\n2 5 3\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n1 4 1 3\n5\n2 5 1 6 5\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 7 0 5\n5\n2 10 2 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n4 2\n3\n0 2 0\n4\n-1 2 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n2 3 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n1 7 0 3\n5\n2 0 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 2 1\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n0 4 0\n4\n0 9 0 3\n5\n1 6 2 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 2\n4\n2 4 2 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n0\n2\n2 3 1\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n1 2\n3\n1 1 1\n4\n2 4 0 3\n5\n2 5 1 4 3\n", "output": ["0\n0\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n1 1\n3\n1 2 0\n4\n0 0 1 3\n5\n2 5 0 4 3\n", "output": ["0\n1\n1 3 2\n0\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 8 1 3\n5\n4 5 1 8 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n2 5 3\n"]}, {"input": "4\n2\n0 1\n3\n1 4 0\n4\n0 2 1 3\n5\n4 5 1 0 3\n", "output": ["0\n1\n1 3 2\n1\n2 3 1\n3\n1 4 3\n2 4 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 4\n5\n1 5 1 6 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n2\n2 3 1\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n0 4 -1\n4\n-1 6 1 3\n5\n0 5 1 8 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n2 3 1\n3 5 2\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 1 -1 3\n5\n0 5 0 8 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n2 3 1\n2\n2 3 1\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n1 2 2\n4\n2 2 2 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n0\n0\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n1 1\n3\n1 2 0\n4\n0 0 1 3\n5\n2 5 0 6 3\n", "output": ["0\n1\n1 3 2\n0\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n3 1\n3\n1 2 2\n4\n0 8 1 3\n5\n4 5 1 8 3\n", "output": ["1\n1 2 1\n0\n2\n2 3 1\n3 4 1\n2\n1 3 2\n2 5 3\n"]}, {"input": "4\n2\n2 1\n3\n-2 2 0\n4\n3 8 1 6\n5\n2 5 1 6 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 1 3\n5\n2 0 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 2 1\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 3\n5\n2 5 1 5 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 5 4\n2 4 2\n"]}, {"input": "4\n2\n2 0\n3\n1 2 0\n4\n2 4 1 3\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 1\n4\n2 4 -1 0\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n2 4 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 3\n5\n1 2 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 8 1 6\n5\n1 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n2 4 1 3\n5\n2 5 1 6 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n1 2 -1\n4\n2 4 1 3\n5\n2 5 1 8 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n0 4 0\n4\n0 6 1 3\n5\n2 5 1 0 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 1 3\n5\n1 2 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 1 0\n4\n0 9 1 3\n5\n1 5 2 4 3\n", "output": ["0\n2\n1 3 2\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 0\n4\n2 3 1 3\n5\n2 9 2 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n1 3 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 0 3\n5\n1 8 2 4 1\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 5 3\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 1 1\n4\n4 18 -1 3\n5\n0 0 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n2 4 2\n1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 1 2\n4\n2 18 -1 3\n5\n0 -1 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n3 4 1\n2\n1 2 1\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 0\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 2 8 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n2 4 0 3\n5\n2 5 1 4 6\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n0 4 -1 4\n5\n2 5 1 8 3\n", "output": ["0\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n1 4 1\n4\n0 2 1 3\n5\n2 5 1 0 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n2 3 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 0 -1 3\n5\n2 5 1 8 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n2 3 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 -1\n3\n2 1 3\n4\n1 18 -1 3\n5\n0 0 1 4 3\n", "output": ["1\n1 2 1\n1\n1 2 1\n2\n1 3 2\n3 4 1\n1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 2\n4\n2 4 2 3\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n0\n2\n2 3 1\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n1 2 0 3\n5\n0 10 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n2 5 3\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 0 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 0 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n1 4 0 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n1 4 2 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n1 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 3\n5\n2 10 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 8 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n1 3 0\n4\n1 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 0\n4\n0 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n1 2\n3\n1 2 1\n4\n1 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 2\n3\n1 2 0\n4\n1 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n4 1\n3\n1 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n0 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 4 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 8 1 6\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 1 1\n4\n2 4 -1 5\n5\n2 6 1 4 3\n", "output": ["1\n1 2 1\n0\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n2 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 1\n4\n0 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n0 2 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 2\n3\n1 2 0\n4\n1 4 -1 2\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n2 4 0\n4\n0 9 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 1\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n0 2 1\n4\n0 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n0 9 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n0 15 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 4 1\n4\n2 4 0 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 -1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 4\n3\n1 2 0\n4\n2 4 0 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 4\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n0 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 3 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n1 7 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n1 4 -1 3\n5\n2 5 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n1 2\n3\n1 2 0\n4\n1 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 4 0\n4\n0 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 3 0\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n2 8 1 6\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 2\n3\n1 2 -1\n4\n1 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n2 4 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 4 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 0 0 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n0\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n-1 11 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 4 0\n4\n0 15 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 2\n3\n0 2 0\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 4 -1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 4\n3\n1 2 0\n4\n2 4 0 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 4\n5\n2 5 1 4 11\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 4\n5\n2 9 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n1 4 -1 3\n5\n2 9 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 0\n3\n2 3 0\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 7 1 3\n5\n2 0 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 2 1\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n-1 2 0\n4\n-1 6 1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 1 3\n5\n1 5 2 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -2\n3\n2 4 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 4 -1\n4\n0 15 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 8 -1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 0\n4\n2 3 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 6\n5\n2 9 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n1 4 -1 3\n5\n2 9 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n-1 2 0\n4\n-1 12 1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n1 9 1 3\n5\n1 5 2 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 -2\n3\n2 4 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 4 -1\n4\n0 15 1 3\n5\n1 5 1 4 2\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 0\n4\n2 3 1 3\n5\n2 9 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n1 4 -1 3\n5\n2 14 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 0 3\n5\n1 5 2 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 6 -1\n4\n0 15 1 3\n5\n1 5 1 4 2\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}], "task_id": "codecontest/14", "repair_prompt": ["The new generation external memory holds a sequence of integers a[1 \u2026 n] = [a_1, a_2, \u2026, a_n].\n\nThis type of memory does not support changing the value of an arbitrary element. What it allows you to do instead is to cut out any segment of the given array. You can cyclically shift (rotate) it by any offset and insert it back into the same place.\n\nTechnically, each cyclic shift consists of two consecutive actions: \n\n  1. You may select arbitrary indices l and r (1 \u2264 l < r \u2264 n) as the boundaries of the segment. \n  2. Then you replace the segment a[l \u2026 r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. \n\n\n\nFor instance, if a = [1, \\color{blue}{3, 2, 8}, 5], then picking l = 2, r = 4 and d = 2 gives a segment a[2 \u2026 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of the original elements of the segment. In the end you get a = [1, \\color{blue}{8, 3, 2}, 5].\n\nSort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted. Use efficient algorithms to help guide the arrangement of numbers while adhering to these constraints.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The new generation external memory holds a sequence of integers a[1 \u2026 n] = [a_1, a_2, \u2026, a_n].\n\nThis type of memory does not support changing the value of an arbitrary element. Its operation is unique and constrained by specific capabilities. What it allows you to do instead is to cut out any segment of the given array. You can cyclically shift (rotate) it by any offset and insert it back into the same place.\n\nTechnically, each cyclic shift consists of two consecutive actions: \n\n  1. You may select arbitrary indices l and r (1 \u2264 l < r \u2264 n) as the boundaries of the segment. \n  2. Then you replace the segment a[l \u2026 r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. \n\n\n\nFor instance, if a = [1, \\color{blue}{3, 2, 8}, 5], then picking l = 2, r = 4 and d = 2 gives a segment a[2 \u2026 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of the original elements of the segment. In the end you get a = [1, \\color{blue}{8, 3, 2}, 5].\n\nSort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted. Use efficient algorithms to help guide the arrangement of numbers while adhering to these constraints.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The new generation external memory holds a sequence of integers a[1 \u2026 n] = [a_1, a_2, \u2026, a_n]. This type of memory does not support changing the value of an arbitrary element, but it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset, and insert it back into the same place.\n\nTechnically, each cyclic shift consists of two consecutive actions: you may select arbitrary indices l and r (1 \u2264 l < r \u2264 n) as the boundaries of the segment, then replace the segment a[l \u2026 r] with its cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be explained by the following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2.\n\nFor instance, if a = [1, \\color{blue}{3, 2, 8}, 5], then picking l = 2, r = 4, and d = 2 gives a segment a[2 \u2026 4] = [3, 2, 8] which is then shifted by the offset d = 2 to the left, resulting in a segment [8, 3, 2] that takes the place of the original elements of the segment, leading to a = [1, \\color{blue}{8, 3, 2}, 5].\n\nSort the given array a using no more than n cyclic shifts of any of its segments. Any method that requires n or fewer cyclic shifts will be accepted, and efficient algorithms should guide the arrangement of numbers while adhering to these constraints.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def cyclic_shift(arr, l, r, d):\n    \"\"\"Perform a cyclic shift on the segment arr[l:r+1] to the left by d positions.\"\"\"\n    segment = arr[l:r+1]\n    d = d % len(segment)  # Ensure the offset is within the segment length\n    shifted_segment = segment[d:] + segment[:d]\n    return arr[:l] + shifted_segment + arr[r+1:]\n\ndef is_sorted(arr):\n    \"\"\"Check if the array is sorted in non-decreasing order.\"\"\"\n    return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))\n\ndef solve(test_cases):\n    results = []\n    for n, array in test_cases:\n        if is_sorted(array):\n            results.append((0, []))\n            continue\n        \n        actions = []\n        sorted_array = sorted(array)\n        \n        # A simple strategy to sort the array using cyclic shifts\n        for i in range(n):\n            if array[i] != sorted_array[i]:\n                # Find the correct position of the current element\n                correct_pos = array.index(sorted_array[i], i)\n                # Perform a cyclic shift to move the element to its correct position\n                if correct_pos > i:\n                    d = correct_pos - i\n                    array = cyclic_shift(array, i, correct_pos, d)\n                    actions.append((i+1, correct_pos+1, d))\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index+n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = solve(test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for i in range(t):\n        n, a = test_cases[i]\n        \n        # Check if the array is already sorted\n        if a == sorted(a):\n            results.append((0, []))\n            continue\n        \n        # Initialize the list of operations\n        operations = []\n        \n        # Implement a simple sorting strategy using cyclic shifts\n        # This is a naive approach and may not be optimal, but it will satisfy the requirement\n        for j in range(n):\n            # Find the minimum element in the unsorted part of the array\n            min_index = j + min(range(n - j), key=lambda x: a[j + x])\n            \n            # If the minimum element is not already in the correct position, perform a cyclic shift\n            if min_index != j:\n                # Perform a cyclic shift to move the minimum element to the correct position\n                # We choose the segment from j to min_index and shift it by min_index - j\n                operations.append((j + 1, min_index + 1, min_index - j))\n                a[j:min_index + 1] = a[j:min_index + 1][min_index - j:] + a[j:min_index + 1][:min_index - j]\n        \n        # Append the result for this test case\n        results.append((len(operations), operations))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, operations in results:\n        print(k)\n        for op in operations:\n            print(*op)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def cyclic_sort(t, test_cases):\n    results = []\n    \n    for i in range(t):\n        n, a = test_cases[i]\n        sorted_a = sorted(a)\n        \n        if a == sorted_a:\n            results.append((0, []))\n            continue\n        \n        actions = []\n        \n        # A simple strategy to sort using cyclic shifts\n        for j in range(n):\n            if a[j] != sorted_a[j]:\n                # Find the correct position of a[j] in the sorted array\n                correct_pos = a.index(sorted_a[j], j)\n                \n                # Perform a cyclic shift to move a[j] to its correct position\n                if correct_pos > j:\n                    d = correct_pos - j\n                    actions.append((j + 1, correct_pos + 1, d))\n                    a[j:correct_pos + 1] = a[j + d:correct_pos + 1] + a[j:j + d]\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = cyclic_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for n, array in test_cases:\n        actions = []\n        \n        # Check if the array is already sorted\n        if array == sorted(array):\n            results.append((0, actions))\n            continue\n        \n        # Implement a sorting algorithm using cyclic shifts\n        # Here, we use a simple approach to sort the array\n        for i in range(n):\n            min_index = i\n            for j in range(i + 1, n):\n                if array[j] < array[min_index]:\n                    min_index = j\n            \n            if min_index != i:\n                # Perform cyclic shift\n                l = i + 1\n                r = min_index + 1\n                d = r - l\n                actions.append((l, r, d))\n                \n                # Perform the cyclic shift\n                segment = array[l-1:r]\n                shifted_segment = segment[d:] + segment[:d]\n                array[l-1:r] = shifted_segment\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def cyclic_shift_sort(test_cases):\n    results = []\n    \n    for n, array in test_cases:\n        actions = []\n        \n        # If the array is already sorted, no actions are needed\n        if array == sorted(array):\n            results.append((0, actions))\n            continue\n        \n        # We will use a simple strategy to sort the array\n        # We will perform at most n shifts\n        for i in range(n):\n            # Find the minimum element in the unsorted part of the array\n            min_index = i + min(range(n - i), key=lambda x: array[i + x])\n            \n            # If the minimum element is not at the current position, we need to shift\n            if min_index != i:\n                # Perform a cyclic shift to bring the minimum element to the current position\n                l = i + 1\n                r = min_index + 1\n                d = r - l\n                actions.append((l, r, d))\n                \n                # Perform the cyclic shift\n                segment = array[l-1:r]\n                array[l-1:r] = segment[d:] + segment[:d]\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = cyclic_shift_sort(test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for i in range(t):\n        n, a = test_cases[i]\n        sorted_a = sorted(a)\n        \n        if a == sorted_a:\n            results.append((0, []))\n            continue\n        \n        actions = []\n        \n        # A simple strategy to sort the array using cyclic shifts\n        # We will use a bubble sort-like approach with cyclic shifts\n        for j in range(n):\n            for k in range(n - 1):\n                if a[k] > a[k + 1]:\n                    # Perform a cyclic shift on the segment [k+1, k+2]\n                    l = k + 1\n                    r = k + 2\n                    d = 1\n                    a[l-1:r] = a[l-1+d:r] + a[l-1:l-1+d]\n                    actions.append((l, r, d))\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for i in range(t):\n        n, array = test_cases[i]\n        \n        # Check if the array is already sorted\n        if array == sorted(array):\n            results.append((0, []))\n            continue\n        \n        actions = []\n        \n        # Implement a simple sorting strategy using cyclic shifts\n        # Here we use a bubble sort-like approach to guide the cyclic shifts\n        for j in range(n):\n            for k in range(n - 1):\n                if array[k] > array[k + 1]:\n                    # Perform a cyclic shift to swap array[k] and array[k + 1]\n                    l = k + 1\n                    r = k + 2\n                    d = 1\n                    # Perform the cyclic shift\n                    segment = array[l-1:r]\n                    shifted_segment = segment[d:] + segment[:d]\n                    array[l-1:r] = shifted_segment\n                    actions.append((l, r, d))\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for action in actions:\n            print(*action)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def cyclic_shift(arr, l, r, d):\n    # Perform a cyclic shift to the left by d on the segment arr[l:r+1]\n    segment = arr[l:r+1]\n    d = d % len(segment)  # Ensure d is within the bounds of the segment length\n    shifted_segment = segment[d:] + segment[:d]\n    return arr[:l] + shifted_segment + arr[r+1:]\n\ndef sort_with_cyclic_shifts(n, arr):\n    actions = []\n    sorted_arr = sorted(arr)\n    \n    if arr == sorted_arr:\n        return actions  # Already sorted, no actions needed\n    \n    # A simple strategy to sort the array using cyclic shifts\n    for i in range(n):\n        if arr[i] != sorted_arr[i]:\n            # Find the position of the correct element\n            correct_pos = arr.index(sorted_arr[i], i)\n            # Perform a cyclic shift to bring the correct element to position i\n            if correct_pos > i:\n                d = correct_pos - i\n                arr = cyclic_shift(arr, i, correct_pos, d)\n                actions.append((i + 1, correct_pos + 1, d))\n    \n    return actions\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        arr = list(map(int, data[index:index + n]))\n        index += n\n        \n        actions = sort_with_cyclic_shifts(n, arr)\n        results.append((len(actions), actions))\n    \n    for result in results:\n        k, actions = result\n        print(k)\n        for action in actions:\n            print(*action)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for i in range(t):\n        n, array = test_cases[i]\n        sorted_array = sorted(array)\n        \n        if array == sorted_array:\n            results.append((0, []))\n            continue\n        \n        actions = []\n        \n        # A simple strategy to sort the array using cyclic shifts\n        # This is not necessarily optimal but should work within the constraints\n        for j in range(n):\n            if array[j] != sorted_array[j]:\n                # Find the position of the correct element in the unsorted array\n                correct_pos = array.index(sorted_array[j], j)\n                \n                # Perform a cyclic shift to move the correct element to the current position\n                if correct_pos > j:\n                    actions.append((j + 1, correct_pos + 1, correct_pos - j))\n                    segment = array[j:correct_pos + 1]\n                    offset = correct_pos - j\n                    shifted_segment = segment[offset:] + segment[:offset]\n                    array[j:correct_pos + 1] = shifted_segment\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for action in actions:\n            print(*action)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for n, array in test_cases:\n        actions = []\n        \n        # Check if the array is already sorted\n        if array == sorted(array):\n            results.append((0, actions))\n            continue\n        \n        # Perform cyclic shifts to sort the array\n        sorted_array = sorted(array)\n        \n        # A simple strategy: repeatedly find the smallest unsorted element and move it to the front\n        for i in range(n):\n            if array[i] != sorted_array[i]:\n                # Find the position of the element that should be at index i\n                target_index = array.index(sorted_array[i], i)\n                \n                # Perform a cyclic shift to move the element to the correct position\n                if target_index > i:\n                    # Calculate the offset for the cyclic shift\n                    offset = target_index - i\n                    # Perform the cyclic shift\n                    array[i:target_index+1] = array[i+offset:target_index+1] + array[i:i+offset]\n                    actions.append((i+1, target_index+1, offset))\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index+n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def cyclic_shift(arr, l, r, d):\n    \"\"\"Perform a cyclic shift on the segment arr[l:r+1] to the left by d positions.\"\"\"\n    segment = arr[l:r+1]\n    d = d % len(segment)  # Ensure the offset is within the segment length\n    shifted_segment = segment[d:] + segment[:d]\n    return arr[:l] + shifted_segment + arr[r+1:]\n\ndef is_sorted(arr):\n    \"\"\"Check if the array is sorted in non-decreasing order.\"\"\"\n    return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))\n\ndef solve(test_cases):\n    results = []\n    for n, array in test_cases:\n        if is_sorted(array):\n            results.append((0, []))\n            continue\n        \n        actions = []\n        sorted_array = sorted(array)\n        \n        # A simple strategy to sort the array using cyclic shifts\n        for i in range(n):\n            if array[i] != sorted_array[i]:\n                # Find the correct position of the current element\n                correct_pos = array.index(sorted_array[i], i)\n                # Perform a cyclic shift to move the element to its correct position\n                if correct_pos > i:\n                    d = correct_pos - i\n                    array = cyclic_shift(array, i, correct_pos, d)\n                    actions.append((i+1, correct_pos+1, d))\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index+n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = solve(test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case, including the length of the array and the array elements.\",\n      \"goal\": \"Extract and store the input data in a structured format for further processing.\"\n    },\n    {\n      \"description\": \"Implement a function to perform a cyclic shift on a given segment of the array. This function should take the segment boundaries and the offset as input and return the modified array.\",\n      \"goal\": \"Enable the ability to cyclically shift any segment of the array to the left by a specified offset.\"\n    },\n    {\n      \"description\": \"Develop a sorting strategy that utilizes cyclic shifts to sort the array. The strategy should ensure that the number of shifts does not exceed the length of the array.\",\n      \"goal\": \"Sort the array using cyclic shifts while adhering to the constraints.\"\n    },\n    {\n      \"description\": \"Track and record the sequence of cyclic shifts performed during the sorting process.\",\n      \"goal\": \"Maintain a log of actions to be output as the solution for each test case.\"\n    },\n    {\n      \"description\": \"Format the output to match the required specification, including the number of actions and the details of each action for each test case.\",\n      \"goal\": \"Ensure the output is correctly formatted for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, check if the array is already sorted. If it is, output 0 actions.\",\n    \"If the array is not sorted, apply the sorting strategy using cyclic shifts:\",\n    \"  a. Identify segments that can be cyclically shifted to move elements closer to their sorted position.\",\n    \"  b. Use the cyclic shift function to perform the shifts and update the array.\",\n    \"  c. Record each shift action with its parameters (l, r, d).\",\n    \"Continue the process until the array is sorted or the number of shifts reaches the array length.\",\n    \"Output the number of actions and the details of each action for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of an array to the left by a specified offset, effectively rearranging the elements within that segment.\n\n    'segment'\n    Explanation: A segment refers to a contiguous subarray defined by two indices, l and r, within the array.\n\n# [phrase showing quantity relationship]\n    'no more than n'\n    Explanation: The number of cyclic shifts performed to sort the array should not exceed the length of the array, n. This means the maximum number of shifts allowed is equal to the number of elements in the array.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The plan should consider simultaneously checking if the array is already sorted before attempting any shifts. This can be done in one code block:\n    - Check if the array is sorted.\n    - If sorted, output 0 actions immediately.\n    - If not sorted, proceed with the sorting strategy using cyclic shifts.\n\n# [edge case]\n    Test case with already sorted array:\n    Input: [1, 2, 3, 4, 5]\n    Expected output: 0\n    Explanation: The array is already sorted, so no cyclic shifts are needed.\n\n    Test case with all identical elements:\n    Input: [3, 3, 3, 3]\n    Expected output: 0\n    Explanation: All elements are identical, so the array is trivially sorted.\n\n    Test case with two elements:\n    Input: [2, 1]\n    Expected output: 1\n    Explanation: A single cyclic shift of the segment [1, 2] with offset 1 will sort the array.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array is already sorted or contains identical elements.\n    Code for handling the edge case:\n    ```python\n    def is_sorted(array):\n        return all(array[i] <= array[i+1] for i in range(len(array)-1))\n\n    for test_case in test_cases:\n        if is_sorted(test_case):\n            print(0)\n            continue\n        # Proceed with cyclic shift logic\n    ```\n\nYES", "Round_0": {"code": "def cyclic_shift(arr, l, r, d):\n    \"\"\"Perform a cyclic shift on the segment arr[l:r+1] to the left by d positions.\"\"\"\n    segment = arr[l:r+1]\n    d = d % len(segment)  # Ensure the offset is within the segment length\n    shifted_segment = segment[d:] + segment[:d]\n    return arr[:l] + shifted_segment + arr[r+1:]\n\ndef is_sorted(arr):\n    \"\"\"Check if the array is sorted in non-decreasing order.\"\"\"\n    return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))\n\ndef solve(test_cases):\n    results = []\n    for n, array in test_cases:\n        if is_sorted(array):\n            results.append((0, []))\n            continue\n        \n        actions = []\n        sorted_array = sorted(array)\n        \n        # A simple strategy to sort the array using cyclic shifts\n        for i in range(n):\n            if array[i] != sorted_array[i]:\n                # Find the correct position of the current element\n                correct_pos = array.index(sorted_array[i], i)\n                # Perform a cyclic shift to move the element to its correct position\n                if correct_pos > i:\n                    d = correct_pos - i\n                    array = cyclic_shift(array, i, correct_pos, d)\n                    actions.append((i+1, correct_pos+1, d))\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index+n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = solve(test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read the integer n for the length of the array and then read the array a of n integers.\"\n    },\n    {\n      \"description\": \"Determine if the array is already sorted.\",\n      \"details\": \"For each test case, check if the array a is already sorted in non-decreasing order. If it is, output k = 0 and move to the next test case.\"\n    },\n    {\n      \"description\": \"Implement a sorting strategy using cyclic shifts.\",\n      \"details\": \"Develop a strategy to sort the array using cyclic shifts. This involves selecting segments of the array, determining the appropriate left shift offset, and applying the shift. Ensure that the number of shifts does not exceed n.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, output the number of shifts k and the details of each shift in the format 'l r d'.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the integer n and the array a of n integers.\",\n    \"  b. Check if the array a is already sorted. If yes, output k = 0 and continue to the next test case.\",\n    \"  c. If the array is not sorted, apply a sorting strategy using cyclic shifts:\",\n    \"     i. Identify segments of the array that can be shifted to move elements closer to their sorted positions.\",\n    \"     ii. Calculate the left shift offset for each segment.\",\n    \"     iii. Apply the cyclic shift and record the operation.\",\n    \"  d. Ensure the total number of shifts does not exceed n.\",\n    \"  e. Output the number of shifts k and the details of each shift for the test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of the array to the left by a specified offset, effectively rearranging the elements within that segment.\n\n    'sorted'\n    Explanation: The array is considered sorted if its elements are in non-decreasing order.\n\n# [phrase showing quantity relationship]\n    'no more than n'\n    Explanation: The number of cyclic shifts used to sort the array should not exceed the length of the array, n. This means the maximum number of shifts allowed is n.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan should consider simultaneously checking if the array is already sorted and outputting k = 0 if it is. This can be done in one code block or an if-else statement to avoid unnecessary operations.\n\n# [edge case] \n    Test case with already sorted array: \n    Input: 2, [1, 2]\n    Expected output: 0\n    Explanation: The array is already sorted, so no shifts are needed.\n\n    Test case with all identical elements:\n    Input: 3, [5, 5, 5]\n    Expected output: 0\n    Explanation: The array is already sorted as all elements are identical.\n\n    Test case with maximum negative and positive values:\n    Input: 3, [-1000000000, 0, 1000000000]\n    Expected output: 0\n    Explanation: The array is already sorted in non-decreasing order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array is sorted and outputting k = 0 will handle these cases.\n\nNO", "Round_0": {"code": "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for i in range(t):\n        n, a = test_cases[i]\n        \n        # Check if the array is already sorted\n        if a == sorted(a):\n            results.append((0, []))\n            continue\n        \n        # Initialize the list of operations\n        operations = []\n        \n        # Implement a simple sorting strategy using cyclic shifts\n        # This is a naive approach and may not be optimal, but it will satisfy the requirement\n        for j in range(n):\n            # Find the minimum element in the unsorted part of the array\n            min_index = j + min(range(n - j), key=lambda x: a[j + x])\n            \n            # If the minimum element is not already in the correct position, perform a cyclic shift\n            if min_index != j:\n                # Perform a cyclic shift to move the minimum element to the correct position\n                # We choose the segment from j to min_index and shift it by min_index - j\n                operations.append((j + 1, min_index + 1, min_index - j))\n                a[j:min_index + 1] = a[j:min_index + 1][min_index - j:] + a[j:min_index + 1][:min_index - j]\n        \n        # Append the result for this test case\n        results.append((len(operations), operations))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, operations in results:\n        print(k)\n        for op in operations:\n            print(*op)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n      \"details\": \"Read the integer t from the first line, then for each test case, read the integer n and the array of integers a.\"\n    },\n    {\n      \"description\": \"Determine if the array is already sorted.\",\n      \"details\": \"Check if the array a is in non-decreasing order. If it is, set k = 0 and return an empty sequence of cyclic shifts.\"\n    },\n    {\n      \"description\": \"Implement a sorting algorithm using cyclic shifts.\",\n      \"details\": \"Develop a strategy to sort the array using cyclic shifts. This can be done by identifying segments that can be shifted to move elements into their correct positions.\"\n    },\n    {\n      \"description\": \"Generate the sequence of cyclic shifts.\",\n      \"details\": \"For each test case, determine the number of shifts k and the specific shifts (l, r, d) needed to sort the array.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"Print the number of shifts k followed by the k lines describing each shift for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, check if the array is already sorted. If sorted, output k = 0 and an empty sequence.\",\n    \"If the array is not sorted, apply a sorting algorithm using cyclic shifts to sort the array.\",\n    \"Determine the sequence of cyclic shifts needed to sort the array within the constraint of n shifts.\",\n    \"Output the number of shifts and the details of each shift for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of the array to the left by a specified offset. This operation is the only allowed modification to the array and is used to sort the array.\n\n# [phrase showing quantity relationship]\n    'no more than n': The number of cyclic shifts used to sort the array should not exceed the length of the array, n.\n    '1 \u2264 l < r \u2264 n': The indices l and r define the segment boundaries and must satisfy this condition.\n    '1 \u2264 d \u2264 r - l': The offset d for the cyclic shift must be within this range.\n\n# [degree adverb]\n    'already sorted': This implies that if the array is in non-decreasing order, no shifts are needed, and k = 0.\n\n# [code logic]\n    The steps \"Determine if the array is already sorted\" and \"Output the results for each test case\" can be implemented simultaneously for cases where the array is already sorted. If the array is sorted, immediately output k = 0 and skip further processing for that test case.\n\n# [edge case]\n    Test case with a single element array (e.g., n = 2, a = [1, 1]) = 0\n    Explanation: The array is already sorted, so no shifts are needed.\n    \n    Test case with an array that is already sorted (e.g., n = 3, a = [1, 2, 3]) = 0\n    Explanation: The array is in non-decreasing order, so no shifts are needed.\n    \n    Test case with an array where all elements are the same (e.g., n = 4, a = [2, 2, 2, 2]) = 0\n    Explanation: The array is already sorted as all elements are identical.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array is already sorted and outputting k = 0 will handle these cases effectively.\n\nNO", "Round_0": {"code": "def cyclic_sort(t, test_cases):\n    results = []\n    \n    for i in range(t):\n        n, a = test_cases[i]\n        sorted_a = sorted(a)\n        \n        if a == sorted_a:\n            results.append((0, []))\n            continue\n        \n        actions = []\n        \n        # A simple strategy to sort using cyclic shifts\n        for j in range(n):\n            if a[j] != sorted_a[j]:\n                # Find the correct position of a[j] in the sorted array\n                correct_pos = a.index(sorted_a[j], j)\n                \n                # Perform a cyclic shift to move a[j] to its correct position\n                if correct_pos > j:\n                    d = correct_pos - j\n                    actions.append((j + 1, correct_pos + 1, d))\n                    a[j:correct_pos + 1] = a[j + d:correct_pos + 1] + a[j:j + d]\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = cyclic_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n      \"details\": \"Read the integer t representing the number of test cases. For each test case, read the integer n and the array of integers a.\"\n    },\n    {\n      \"description\": \"Determine if the array is already sorted.\",\n      \"details\": \"Check if the array a is in non-decreasing order. If it is, set k = 0 and return an empty sequence of cyclic shifts.\"\n    },\n    {\n      \"description\": \"Implement a sorting algorithm using cyclic shifts.\",\n      \"details\": \"Design a strategy to sort the array using cyclic shifts. Ensure the number of shifts does not exceed n. Consider using a simple sorting algorithm like bubble sort or insertion sort, adapted to use cyclic shifts.\"\n    },\n    {\n      \"description\": \"Generate the sequence of cyclic shifts.\",\n      \"details\": \"For each shift, determine the indices l and r and the offset d. Record these actions in the format 'l r d'.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, output the integer k followed by the k lines describing the cyclic shifts.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, check if the array is already sorted. If sorted, output k = 0 and an empty sequence.\",\n    \"If the array is not sorted, apply a sorting algorithm using cyclic shifts to sort the array.\",\n    \"Record the sequence of cyclic shifts used to sort the array.\",\n    \"Output the number of shifts and the sequence of actions for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of the array to the left by a specified offset. This operation is the only allowed modification to the array for sorting purposes.\n\n    'segment'\n    Explanation: A segment is a contiguous subarray defined by two indices, l and r, where 1 \u2264 l < r \u2264 n.\n\n# [phrase showing quantity relationship]\n    'no more than n'\n    Explanation: The number of cyclic shifts used to sort the array should not exceed the length of the array, n. This means the solution must be efficient enough to sort the array within these constraints.\n\n# [degree adverb]\n    'already sorted'\n    Explanation: If the array is in non-decreasing order, it is considered sorted, and no cyclic shifts are needed. This can be checked using a simple comparison of adjacent elements.\n\n# [code logic]\n    The steps to check if the array is already sorted and to output k = 0 if it is should be implemented simultaneously. This can be done by checking the sorted condition before attempting any sorting operations.\n\n# [edge case]\n    Edge Case 1: An array with all identical elements, e.g., [5, 5, 5, 5] = 0\n    Explanation: The array is already sorted, so no shifts are needed.\n\n    Edge Case 2: An array with two elements in reverse order, e.g., [2, 1] = 1\n    Explanation: A single cyclic shift can sort the array.\n\n    Edge Case 3: An array that is already sorted, e.g., [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already in non-decreasing order, so no shifts are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array is sorted and applying cyclic shifts as needed will naturally handle these cases.\n\nNO", "Round_0": {"code": "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for n, array in test_cases:\n        actions = []\n        \n        # Check if the array is already sorted\n        if array == sorted(array):\n            results.append((0, actions))\n            continue\n        \n        # Implement a sorting algorithm using cyclic shifts\n        # Here, we use a simple approach to sort the array\n        for i in range(n):\n            min_index = i\n            for j in range(i + 1, n):\n                if array[j] < array[min_index]:\n                    min_index = j\n            \n            if min_index != i:\n                # Perform cyclic shift\n                l = i + 1\n                r = min_index + 1\n                d = r - l\n                actions.append((l, r, d))\n                \n                # Perform the cyclic shift\n                segment = array[l-1:r]\n                shifted_segment = segment[d:] + segment[:d]\n                array[l-1:r] = shifted_segment\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case, including the length of the array and the array elements.\",\n      \"goal\": \"Extract and store the input data in a structured format for further processing.\"\n    },\n    {\n      \"description\": \"Implement a function to perform a cyclic shift on a given segment of the array. This function should take the segment boundaries and the offset as input and return the modified array.\",\n      \"goal\": \"Enable the ability to cyclically shift any segment of the array to the left by a specified offset.\"\n    },\n    {\n      \"description\": \"Develop a sorting strategy that utilizes cyclic shifts to sort the array. The strategy should ensure that the number of shifts does not exceed the length of the array.\",\n      \"goal\": \"Sort the array using cyclic shifts while adhering to the constraints.\"\n    },\n    {\n      \"description\": \"Track and record the sequence of cyclic shifts performed during the sorting process.\",\n      \"goal\": \"Maintain a log of actions to be output as the solution for each test case.\"\n    },\n    {\n      \"description\": \"Format the output to match the required specification, including the number of actions and the details of each action for each test case.\",\n      \"goal\": \"Ensure the output is correctly formatted for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, check if the array is already sorted. If it is, output 0 and an empty sequence of actions.\",\n    \"If the array is not sorted, apply the sorting strategy using cyclic shifts. Use the cyclic shift function to perform necessary shifts.\",\n    \"Record each cyclic shift action performed during the sorting process.\",\n    \"After sorting the array, format the output to include the number of actions and the details of each action for the test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of an array to the left by a specified offset, effectively rearranging the elements within that segment.\n\n    'segment'\n    Explanation: A segment refers to a contiguous subarray defined by two indices, l and r, within the array.\n\n# [phrase showing quantity relationship]\n    'no more than n'\n    Explanation: The number of cyclic shifts used to sort the array should not exceed the length of the array, n. This means the maximum number of shifts allowed is equal to the number of elements in the array.\n\n# [degree adverb]\n    'arbitrary'\n    Explanation: The indices l and r, as well as the offset d, can be chosen freely within the constraints provided (1 \u2264 l < r \u2264 n and 1 \u2264 d \u2264 r - l).\n\n# [code logic]\n    The steps related to parsing input, performing cyclic shifts, and tracking actions should be implemented simultaneously in a cohesive manner. Specifically, the cyclic shift function should be integrated with the sorting strategy to ensure shifts are applied correctly and actions are recorded.\n\n# [edge case]\n    Test case with already sorted array:\n    Input: [1, 2, 3, 4, 5]\n    Expected output: 0\n    Explanation: Since the array is already sorted, no cyclic shifts are needed.\n\n    Test case with minimum length array:\n    Input: [2, 1]\n    Expected output: 1\n    Explanation: A single shift is needed to sort the array, e.g., shifting the segment [2, 1] to [1, 2].\n\n    Test case with all identical elements:\n    Input: [3, 3, 3, 3]\n    Expected output: 0\n    Explanation: The array is already sorted as all elements are identical, so no shifts are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array is already sorted and applying shifts as needed will naturally handle these cases.\n\nNO", "Round_0": {"code": "def cyclic_shift_sort(test_cases):\n    results = []\n    \n    for n, array in test_cases:\n        actions = []\n        \n        # If the array is already sorted, no actions are needed\n        if array == sorted(array):\n            results.append((0, actions))\n            continue\n        \n        # We will use a simple strategy to sort the array\n        # We will perform at most n shifts\n        for i in range(n):\n            # Find the minimum element in the unsorted part of the array\n            min_index = i + min(range(n - i), key=lambda x: array[i + x])\n            \n            # If the minimum element is not at the current position, we need to shift\n            if min_index != i:\n                # Perform a cyclic shift to bring the minimum element to the current position\n                l = i + 1\n                r = min_index + 1\n                d = r - l\n                actions.append((l, r, d))\n                \n                # Perform the cyclic shift\n                segment = array[l-1:r]\n                array[l-1:r] = segment[d:] + segment[:d]\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = cyclic_shift_sort(test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n      \"details\": \"Read the integer t, followed by reading n and the array a for each test case.\"\n    },\n    {\n      \"description\": \"Determine if the array is already sorted.\",\n      \"details\": \"For each test case, check if the array a is in non-decreasing order.\"\n    },\n    {\n      \"description\": \"Implement a sorting strategy using cyclic shifts.\",\n      \"details\": \"If the array is not sorted, devise a method to sort the array using cyclic shifts. Ensure the number of shifts does not exceed n.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, output the number of shifts k and the details of each shift in the format 'l r d'.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data to get the number of test cases and the arrays for each test case.\",\n    \"For each test case, check if the array is already sorted. If it is, output k = 0.\",\n    \"If the array is not sorted, apply a sorting strategy using cyclic shifts. Ensure the number of shifts does not exceed n.\",\n    \"For each shift, determine the indices l, r, and the offset d to perform the cyclic shift.\",\n    \"Output the number of shifts k and the details of each shift for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of the array to the left by a specified offset. This operation is the only allowed modification to the array and is used to sort the array.\n\n    'segment'\n    Explanation: A segment is a contiguous subarray defined by two indices, l and r, where 1 \u2264 l < r \u2264 n. This segment is the part of the array that can be cyclically shifted.\n\n# [phrase showing quantity relationship]\n    'no more than n'\n    Explanation: The number of cyclic shifts used to sort the array should not exceed the length of the array, n. This means that the solution must be efficient enough to sort the array within these constraints.\n\n# [degree adverb]\n    'already sorted'\n    Explanation: If the array is in non-decreasing order, it is considered sorted, and no cyclic shifts are needed. This can be checked using a simple comparison of adjacent elements in the array.\n\n# [code logic]\n    The steps \"Determine if the array is already sorted\" and \"Output the results for each test case\" can be implemented simultaneously. If the array is already sorted, the output is immediately k = 0, and no further processing is needed for that test case.\n\n# [edge case]\n    Test case with minimum size array:\n    Input: 2\n           2\n           1 1\n    Expected output: 0\n    Explanation: The array is already sorted, so no shifts are needed.\n\n    Test case with all elements the same:\n    Input: 2\n           3\n           5 5 5\n    Expected output: 0\n    Explanation: The array is already sorted as all elements are the same.\n\n    Test case with maximum negative and positive values:\n    Input: 2\n           3\n           -1000000000 0 1000000000\n    Expected output: 0\n    Explanation: The array is already sorted in non-decreasing order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array is sorted and then applying cyclic shifts if necessary will handle these cases correctly.\n\nNO", "Round_0": {"code": "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for i in range(t):\n        n, a = test_cases[i]\n        sorted_a = sorted(a)\n        \n        if a == sorted_a:\n            results.append((0, []))\n            continue\n        \n        actions = []\n        \n        # A simple strategy to sort the array using cyclic shifts\n        # We will use a bubble sort-like approach with cyclic shifts\n        for j in range(n):\n            for k in range(n - 1):\n                if a[k] > a[k + 1]:\n                    # Perform a cyclic shift on the segment [k+1, k+2]\n                    l = k + 1\n                    r = k + 2\n                    d = 1\n                    a[l-1:r] = a[l-1+d:r] + a[l-1:l-1+d]\n                    actions.append((l, r, d))\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the array length and the array elements.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the length of the array.\",\n        \"Read the array elements a_i, which are space-separated integers.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array is already sorted.\",\n      \"steps\": [\n        \"For each test case, check if the array is sorted in non-decreasing order.\",\n        \"If the array is sorted, set k = 0 and prepare an empty sequence of cyclic shifts.\"\n      ]\n    },\n    {\n      \"description\": \"Sort the array using cyclic shifts.\",\n      \"steps\": [\n        \"For each test case where the array is not sorted, identify segments that can be cyclically shifted to move elements into their correct positions.\",\n        \"Use a sorting algorithm (e.g., bubble sort, insertion sort) to guide the selection of segments and offsets for cyclic shifts.\",\n        \"Ensure that the number of cyclic shifts does not exceed n.\"\n      ]\n    },\n    {\n      \"description\": \"Format the output for each test case.\",\n      \"steps\": [\n        \"For each test case, output the integer k, which represents the number of cyclic shifts performed.\",\n        \"For each cyclic shift, output the indices l, r, and the offset d in the format 'l r d'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each test case.\",\n    \"For each test case, check if the array is already sorted. If sorted, output k = 0.\",\n    \"If the array is not sorted, apply cyclic shifts to sort the array using a guided approach.\",\n    \"Ensure the number of cyclic shifts does not exceed n for each test case.\",\n    \"Format and output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of the array to the left by a specified offset. This operation is used to rearrange elements within the array without changing the overall size of the array.\n\n    'segment'\n    Explanation: A segment refers to a contiguous subarray defined by two indices, l and r, where 1 \u2264 l < r \u2264 n. This segment is the part of the array that can be cyclically shifted.\n\n# [phrase showing quantity relationship]\n    'no more than n'\n    Explanation: The number of cyclic shifts used to sort the array should not exceed the length of the array, n. This means that the solution must be efficient enough to sort the array within these constraints.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to checking if the array is sorted and setting k = 0 if it is sorted should be implemented simultaneously. This can be done by checking the sorted condition and preparing the output in one code block.\n\n# [edge case]\n    Edge Case 1: An already sorted array\n    Input: [1, 2, 3, 4, 5]\n    Expected Output: 0\n    Explanation: Since the array is already sorted, no cyclic shifts are needed.\n\n    Edge Case 2: An array with all identical elements\n    Input: [3, 3, 3, 3]\n    Expected Output: 0\n    Explanation: All elements are the same, so the array is trivially sorted.\n\n    Edge Case 3: An array with the maximum number of elements (n = 50) in reverse order\n    Input: [50, 49, ..., 1]\n    Expected Output: A sequence of shifts that sorts the array\n    Explanation: The array is in reverse order, requiring multiple shifts to sort.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array is already sorted or contains identical elements. This can be handled by checking if the array is sorted at the beginning and setting k = 0 if true.\n\n    ```python\n    def handle_edge_cases(array):\n        if array == sorted(array):\n            return 0, []\n        # Additional logic for sorting if not already sorted\n    ```\n\nYES", "Round_0": {"code": "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for i in range(t):\n        n, array = test_cases[i]\n        \n        # Check if the array is already sorted\n        if array == sorted(array):\n            results.append((0, []))\n            continue\n        \n        actions = []\n        \n        # Implement a simple sorting strategy using cyclic shifts\n        # Here we use a bubble sort-like approach to guide the cyclic shifts\n        for j in range(n):\n            for k in range(n - 1):\n                if array[k] > array[k + 1]:\n                    # Perform a cyclic shift to swap array[k] and array[k + 1]\n                    l = k + 1\n                    r = k + 2\n                    d = 1\n                    # Perform the cyclic shift\n                    segment = array[l-1:r]\n                    shifted_segment = segment[d:] + segment[:d]\n                    array[l-1:r] = shifted_segment\n                    actions.append((l, r, d))\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for action in actions:\n            print(*action)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case, including the length of the array and the array elements.\",\n      \"goal\": \"Extract and store the input data in a structured format for further processing.\"\n    },\n    {\n      \"description\": \"Implement a function to perform a cyclic shift on a given segment of the array. This function should take the segment boundaries and the offset as input and return the modified array.\",\n      \"goal\": \"Enable the ability to cyclically shift any segment of the array to the left by a specified offset.\"\n    },\n    {\n      \"description\": \"Develop a sorting strategy that uses cyclic shifts to sort the array. The strategy should ensure that the number of shifts does not exceed the length of the array.\",\n      \"goal\": \"Sort the array using cyclic shifts while adhering to the constraints.\"\n    },\n    {\n      \"description\": \"Generate the output format, which includes the number of shifts and the details of each shift for each test case.\",\n      \"goal\": \"Produce the required output format for each test case, detailing the sorting process.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it to extract the number of test cases and the details of each test case.\",\n    \"For each test case, check if the array is already sorted. If it is, output 0 and move to the next test case.\",\n    \"If the array is not sorted, apply the sorting strategy using cyclic shifts. For each shift, record the segment boundaries and the offset used.\",\n    \"Ensure that the number of shifts does not exceed the length of the array.\",\n    \"After sorting the array, format the output to include the number of shifts and the details of each shift.\",\n    \"Print the results for all test cases in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of an array to the left by a specified offset, effectively rearranging the elements within that segment.\n\n    'segment'\n    Explanation: A segment refers to a contiguous subarray defined by two indices, l and r, within the array.\n\n# [phrase showing quantity relationship]\n    'no more than n'\n    Explanation: The number of cyclic shifts used to sort the array should not exceed the length of the array, n. This means the maximum number of shifts allowed is equal to the number of elements in the array.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The plan does not specify any steps that need to be implemented simultaneously. Each step in the plan is distinct and should be executed sequentially.\n\n# [edge case]\n    Test case with already sorted array:\n    Input: [1, 2, 3, 4, 5]\n    Expected output: 0\n    Explanation: The array is already sorted, so no cyclic shifts are needed.\n\n    Test case with minimum length array:\n    Input: [2, 1]\n    Expected output: 1\n    Explanation: A single shift is needed to sort the array, shifting the segment [2, 1] to [1, 2].\n\n    Test case with all identical elements:\n    Input: [3, 3, 3, 3]\n    Expected output: 0\n    Explanation: The array is already sorted as all elements are identical, so no shifts are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array is already sorted and handling arrays with identical elements will suffice.\n\nNO", "Round_0": {"code": "def cyclic_shift(arr, l, r, d):\n    # Perform a cyclic shift to the left by d on the segment arr[l:r+1]\n    segment = arr[l:r+1]\n    d = d % len(segment)  # Ensure d is within the bounds of the segment length\n    shifted_segment = segment[d:] + segment[:d]\n    return arr[:l] + shifted_segment + arr[r+1:]\n\ndef sort_with_cyclic_shifts(n, arr):\n    actions = []\n    sorted_arr = sorted(arr)\n    \n    if arr == sorted_arr:\n        return actions  # Already sorted, no actions needed\n    \n    # A simple strategy to sort the array using cyclic shifts\n    for i in range(n):\n        if arr[i] != sorted_arr[i]:\n            # Find the position of the correct element\n            correct_pos = arr.index(sorted_arr[i], i)\n            # Perform a cyclic shift to bring the correct element to position i\n            if correct_pos > i:\n                d = correct_pos - i\n                arr = cyclic_shift(arr, i, correct_pos, d)\n                actions.append((i + 1, correct_pos + 1, d))\n    \n    return actions\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        arr = list(map(int, data[index:index + n]))\n        index += n\n        \n        actions = sort_with_cyclic_shifts(n, arr)\n        results.append((len(actions), actions))\n    \n    for result in results:\n        k, actions = result\n        print(k)\n        for action in actions:\n            print(*action)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 96)"}, "Round_1": {"code": "def cyclic_shift(arr, l, r, d):\n    # Perform a cyclic shift to the left by d on the segment arr[l:r+1]\n    segment = arr[l:r+1]\n    d = d % len(segment)  # Ensure d is within the bounds of the segment length\n    shifted_segment = segment[d:] + segment[:d]\n    return arr[:l] + shifted_segment + arr[r+1:]\n\ndef sort_with_cyclic_shifts(n, arr):\n    actions = []\n    sorted_arr = sorted(arr)\n    \n    if arr == sorted_arr:\n        return actions  # Already sorted, no actions needed\n    \n    # A simple strategy to sort the array using cyclic shifts\n    for i in range(n):\n        if arr[i] != sorted_arr[i]:\n            # Find the position of the correct element\n            correct_pos = arr.index(sorted_arr[i], i)\n            # Perform a cyclic shift to bring the correct element to position i\n            if correct_pos > i:\n                d = correct_pos - i\n                arr = cyclic_shift(arr, i, correct_pos, d)\n                actions.append((i + 1, correct_pos + 1, d))\n    \n    return actions\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        arr = list(map(int, data[index:index + n]))\n        index += n\n        \n        actions = sort_with_cyclic_shifts(n, arr)\n        results.append((len(actions), actions))\n    \n    for result in results:\n        k, actions = result\n        print(k)\n        for action in actions:\n            print(*action)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"name\": \"Parse Input\",\n      \"description\": \"Read the number of test cases and the arrays for each test case from the input.\"\n    },\n    {\n      \"name\": \"Check Sorted\",\n      \"description\": \"Determine if the array is already sorted. If sorted, output 0 actions.\"\n    },\n    {\n      \"name\": \"Perform Cyclic Shifts\",\n      \"description\": \"Identify segments within the array that can be cyclically shifted to move elements closer to their sorted positions.\"\n    },\n    {\n      \"name\": \"Generate Output\",\n      \"description\": \"For each test case, output the number of actions and the details of each cyclic shift performed.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Initialize\",\n      \"description\": \"Set up data structures to store input arrays and results.\"\n    },\n    {\n      \"step\": \"Input Parsing\",\n      \"description\": \"Read and parse the input to extract the number of test cases and the arrays for each test case.\"\n    },\n    {\n      \"step\": \"Process Each Test Case\",\n      \"description\": \"Iterate over each test case and perform the following sub-steps:\"\n    },\n    {\n      \"step\": \"Check Sorted\",\n      \"description\": \"Check if the array is already sorted. If yes, record 0 actions and move to the next test case.\"\n    },\n    {\n      \"step\": \"Identify Segments\",\n      \"description\": \"For unsorted arrays, identify segments that can be cyclically shifted to move elements towards their sorted positions.\"\n    },\n    {\n      \"step\": \"Perform Shifts\",\n      \"description\": \"Execute the identified cyclic shifts and record the actions taken.\"\n    },\n    {\n      \"step\": \"Output Results\",\n      \"description\": \"For each test case, output the number of actions and the details of each cyclic shift performed.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of the array to the left by a specified offset, effectively rearranging the elements within that segment.\n\n    'sorted'\n    Explanation: The goal is to arrange the elements of the array in non-decreasing order using cyclic shifts.\n\n# [phrase showing quantity relationship]\n    'no more than n'\n    Explanation: The number of cyclic shifts performed should not exceed the length of the array, n. This means the solution must be efficient enough to sort the array within these constraints.\n\n# [degree adverb] \n    'arbitrary'\n    Explanation: The indices l and r, as well as the offset d, can be chosen freely within the given constraints, allowing flexibility in how segments are selected and shifted.\n\n# [code logic]\n    The steps \"Identify Segments\" and \"Perform Shifts\" should be considered simultaneously. Once a segment is identified, the shift should be performed immediately to move elements closer to their sorted positions. This can be implemented in a loop where each identified segment is processed and shifted in one go.\n\n# [edge case] \n    Test case with already sorted array:\n    Input: [1, 2, 3, 4, 5]\n    Expected output: 0\n    Explanation: Since the array is already sorted, no cyclic shifts are needed.\n\n    Test case with all identical elements:\n    Input: [3, 3, 3, 3]\n    Expected output: 0\n    Explanation: All elements are the same, so the array is trivially sorted.\n\n    Test case with minimum and maximum values:\n    Input: [-10^9, 10^9]\n    Expected output: 0\n    Explanation: With only two elements, the array is already sorted.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array is sorted before performing any shifts will naturally handle these cases.\n\nNO", "Round_0": {"code": "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for i in range(t):\n        n, array = test_cases[i]\n        sorted_array = sorted(array)\n        \n        if array == sorted_array:\n            results.append((0, []))\n            continue\n        \n        actions = []\n        \n        # A simple strategy to sort the array using cyclic shifts\n        # This is not necessarily optimal but should work within the constraints\n        for j in range(n):\n            if array[j] != sorted_array[j]:\n                # Find the position of the correct element in the unsorted array\n                correct_pos = array.index(sorted_array[j], j)\n                \n                # Perform a cyclic shift to move the correct element to the current position\n                if correct_pos > j:\n                    actions.append((j + 1, correct_pos + 1, correct_pos - j))\n                    segment = array[j:correct_pos + 1]\n                    offset = correct_pos - j\n                    shifted_segment = segment[offset:] + segment[:offset]\n                    array[j:correct_pos + 1] = shifted_segment\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for action in actions:\n            print(*action)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"name\": \"Parse Input\",\n      \"description\": \"Read the number of test cases and the arrays for each test case from the input.\"\n    },\n    {\n      \"name\": \"Check Sorted\",\n      \"description\": \"Determine if the array is already sorted. If sorted, output 0 actions.\"\n    },\n    {\n      \"name\": \"Perform Cyclic Shifts\",\n      \"description\": \"Implement a method to perform cyclic shifts on segments of the array to sort it. Ensure the number of shifts does not exceed n.\"\n    },\n    {\n      \"name\": \"Output Results\",\n      \"description\": \"For each test case, output the number of actions and the details of each action.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Initialize\",\n      \"description\": \"Start by reading the input data, including the number of test cases and the arrays for each test case.\"\n    },\n    {\n      \"step\": \"Iterate Test Cases\",\n      \"description\": \"Loop through each test case to process the array.\"\n    },\n    {\n      \"step\": \"Check Sorted\",\n      \"description\": \"For each array, check if it is already sorted. If sorted, record 0 actions and move to the next test case.\"\n    },\n    {\n      \"step\": \"Sort Using Cyclic Shifts\",\n      \"description\": \"If the array is not sorted, apply cyclic shifts to sort the array. Ensure the number of shifts does not exceed n.\"\n    },\n    {\n      \"step\": \"Record Actions\",\n      \"description\": \"For each test case, record the number of actions and the details of each cyclic shift performed.\"\n    },\n    {\n      \"step\": \"Output\",\n      \"description\": \"Print the results for each test case, including the number of actions and the details of each action.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of the array to the left by a specified offset. This operation is crucial for rearranging elements to achieve a sorted order.\n\n# [phrase showing quantity relationship]\n    'no more than n cyclic shifts'\n    Explanation: The requirement specifies that the sorting process should be completed using n or fewer cyclic shifts. This means the number of shifts applied to sort the array should not exceed the length of the array.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps \"Check Sorted\" and \"Perform Cyclic Shifts\" should be considered simultaneously. If the array is already sorted, no cyclic shifts are needed, and the output should be 0 actions. Otherwise, proceed with cyclic shifts to sort the array.\n\n# [edge case] \n    Test case with already sorted array: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted, so no cyclic shifts are needed, and the expected output is 0 actions.\n    \n    Test case with all identical elements: [3, 3, 3, 3] = 0\n    Explanation: Since all elements are identical, the array is trivially sorted, requiring 0 actions.\n    \n    Test case with two elements in reverse order: [2, 1] = 1\n    Explanation: A single cyclic shift of the segment [1, 2] by offset 1 will sort the array, resulting in 1 action.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array is sorted and applying cyclic shifts as needed will handle these cases.\n\nNO", "Round_0": {"code": "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for n, array in test_cases:\n        actions = []\n        \n        # Check if the array is already sorted\n        if array == sorted(array):\n            results.append((0, actions))\n            continue\n        \n        # Perform cyclic shifts to sort the array\n        sorted_array = sorted(array)\n        \n        # A simple strategy: repeatedly find the smallest unsorted element and move it to the front\n        for i in range(n):\n            if array[i] != sorted_array[i]:\n                # Find the position of the element that should be at index i\n                target_index = array.index(sorted_array[i], i)\n                \n                # Perform a cyclic shift to move the element to the correct position\n                if target_index > i:\n                    # Calculate the offset for the cyclic shift\n                    offset = target_index - i\n                    # Perform the cyclic shift\n                    array[i:target_index+1] = array[i+offset:target_index+1] + array[i:i+offset]\n                    actions.append((i+1, target_index+1, offset))\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index+n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case, including the length of the array and the array elements.\",\n      \"goal\": \"Extract and store the input data in a structured format for further processing.\"\n    },\n    {\n      \"description\": \"Implement a function to perform a cyclic shift on a given segment of the array. This function should take the segment boundaries and the offset as input and return the modified array.\",\n      \"goal\": \"Enable the ability to cyclically shift any segment of the array to the left by a specified offset.\"\n    },\n    {\n      \"description\": \"Develop a sorting strategy that utilizes cyclic shifts to sort the array. The strategy should ensure that the number of shifts does not exceed the length of the array.\",\n      \"goal\": \"Sort the array using cyclic shifts while adhering to the constraints.\"\n    },\n    {\n      \"description\": \"Track and record the sequence of cyclic shifts performed during the sorting process.\",\n      \"goal\": \"Maintain a log of actions to be output as the solution for each test case.\"\n    },\n    {\n      \"description\": \"Format the output to match the required specification, including the number of actions and the details of each action for each test case.\",\n      \"goal\": \"Ensure the output is correctly formatted for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, check if the array is already sorted. If it is, output 0 actions.\",\n    \"If the array is not sorted, apply the sorting strategy using cyclic shifts:\",\n    \"  a. Identify segments that can be cyclically shifted to move elements closer to their sorted position.\",\n    \"  b. Use the cyclic shift function to perform the shifts and update the array.\",\n    \"  c. Record each shift action with its parameters (l, r, d).\",\n    \"Continue the process until the array is sorted or the number of shifts reaches the array length.\",\n    \"Output the number of actions and the details of each action for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of an array to the left by a specified offset, effectively rearranging the elements within that segment.\n\n    'segment'\n    Explanation: A segment refers to a contiguous subarray defined by two indices, l and r, within the array.\n\n# [phrase showing quantity relationship]\n    'no more than n'\n    Explanation: The number of cyclic shifts performed to sort the array should not exceed the length of the array, n. This means the maximum number of shifts allowed is equal to the number of elements in the array.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The plan should consider simultaneously checking if the array is already sorted before attempting any shifts. This can be done in one code block:\n    - Check if the array is sorted.\n    - If sorted, output 0 actions immediately.\n    - If not sorted, proceed with the sorting strategy using cyclic shifts.\n\n# [edge case]\n    Test case with already sorted array:\n    Input: [1, 2, 3, 4, 5]\n    Expected output: 0\n    Explanation: The array is already sorted, so no cyclic shifts are needed.\n\n    Test case with all identical elements:\n    Input: [3, 3, 3, 3]\n    Expected output: 0\n    Explanation: All elements are identical, so the array is trivially sorted.\n\n    Test case with two elements:\n    Input: [2, 1]\n    Expected output: 1\n    Explanation: A single cyclic shift of the segment [1, 2] with offset 1 will sort the array.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array is already sorted or contains identical elements.\n    Code for handling the edge case:\n    ```python\n    def is_sorted(array):\n        return all(array[i] <= array[i+1] for i in range(len(array)-1))\n\n    for test_case in test_cases:\n        if is_sorted(test_case):\n            print(0)\n            continue\n        # Proceed with cyclic shift logic\n    ```\n\nYES", "Round_0": {"code": "def cyclic_shift(arr, l, r, d):\n    \"\"\"Perform a cyclic shift on the segment arr[l:r+1] to the left by d positions.\"\"\"\n    segment = arr[l:r+1]\n    d = d % len(segment)  # Ensure the offset is within the segment length\n    shifted_segment = segment[d:] + segment[:d]\n    return arr[:l] + shifted_segment + arr[r+1:]\n\ndef is_sorted(arr):\n    \"\"\"Check if the array is sorted in non-decreasing order.\"\"\"\n    return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))\n\ndef solve(test_cases):\n    results = []\n    for n, array in test_cases:\n        if is_sorted(array):\n            results.append((0, []))\n            continue\n        \n        actions = []\n        sorted_array = sorted(array)\n        \n        # A simple strategy to sort the array using cyclic shifts\n        for i in range(n):\n            if array[i] != sorted_array[i]:\n                # Find the correct position of the current element\n                correct_pos = array.index(sorted_array[i], i)\n                # Perform a cyclic shift to move the element to its correct position\n                if correct_pos > i:\n                    d = correct_pos - i\n                    array = cyclic_shift(array, i, correct_pos, d)\n                    actions.append((i+1, correct_pos+1, d))\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index+n]))\n        index += n\n        test_cases.append((n, array))\n    \n    results = solve(test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, false, true, true, true, true, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 369, "prompt": "The new generation external memory holds a sequence of integers a[1 \u2026 n] = [a_1, a_2, \u2026, a_n].\n\nThis type of memory does not support changing the value of an arbitrary element. What it allows you to do instead is to cut out any segment of the given array. You can cyclically shift (rotate) it by any offset and insert it back into the same place.\n\nTechnically, each cyclic shift consists of two consecutive actions: \n\n  1. You may select arbitrary indices l and r (1 \u2264 l < r \u2264 n) as the boundaries of the segment. \n  2. Then you replace the segment a[l \u2026 r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. \n\n\n\nFor instance, if a = [1, \\color{blue}{3, 2, 8}, 5], then picking l = 2, r = 4 and d = 2 gives a segment a[2 \u2026 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of the original elements of the segment. In the end you get a = [1, \\color{blue}{8, 3, 2}, 5].\n\nSort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted. Use efficient algorithms to help guide the arrangement of numbers while adhering to these constraints.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] ", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] ", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 214}
