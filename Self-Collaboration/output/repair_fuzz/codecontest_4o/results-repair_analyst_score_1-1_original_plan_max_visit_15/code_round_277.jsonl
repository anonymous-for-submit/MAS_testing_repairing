{"name": "1580_C. Train Maintenance", "description": "Kawasiro Nitori is excellent in engineering. Thus she has been appointed to help maintain trains.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment. In the beginning, there are no trains, at each of the following m days, one train will be added, or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance in each day.\n\nOn a day a train is removed, it is not counted as in maintenance.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.", "tags": ["brute force", "data structures", "implementation"], "difficulty": 9, "id": 1580, "sample_io": [{"input": "3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}], "test_list": [{"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n10 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "3 4\n10 15\n12 10\n2 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "3 4\n23 15\n14 10\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n2 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n2 19\n7 19\n2 9\n26 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n5\n4\n3\n5\n7\n8\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n21 15\n7 3\n19 7\n1 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n2\n2\n2\n1\n2\n3\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n5\n4\n3\n5\n7\n8\n"]}, {"input": "5 2\n1 1\n10000011 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n1 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "10 7\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n8 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n8\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n3 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 2\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n0\n"]}, {"input": "20 7\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n4 9\n5 10\n657453515 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n3 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n"]}, {"input": "3 2\n9 15\n12 9\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n2 9\n14 19\n7 19\n2 9\n21 15\n7 3\n19 7\n1 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n2\n2\n2\n1\n3\n4\n4\n4\n4\n5\n5\n4\n3\n4\n6\n8\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 9\n2 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 2\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n3 9\n49 15\n7 6\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n6\n5\n6\n7\n7\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n1 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n14 9\n14 19\n7 19\n2 9\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n4\n3\n4\n7\n8\n"]}, {"input": "3 4\n16 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 15\n15 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 15\n10 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "3 4\n10 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000011 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 000000000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "3 4\n9 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n9 15\n12 1\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 0\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n733475792 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n13 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n467159628 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 8\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000001 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1258790837 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n26 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 0\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000011 100000000\n998244353 1\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n9 15\n12 0\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n21 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n13 15\n14 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n369260158 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n16 16\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n26 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n16 6\n2 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n23 15\n14 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n2 1\n10000001 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n2 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n450441171 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000101 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 7\n15 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "3 4\n16 15\n10 17\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000011 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000011 000000000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n9 15\n12 9\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 -1\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 241782432\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n2 1\n1 5\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 801909796\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n5 15\n12 10\n2 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "5 4\n1 1\n10000000 100000001\n733475792 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 8\n12 18\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10001011 100000000\n998244353 1\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n2 1\n10000011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n1166046831 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n26 15\n10 17\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000011 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000011 000000000\n998244353 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1425917046 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 241782432\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 11\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "20 20\n1 4\n864803385 801909796\n17 4\n12 1\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "5 4\n1 1\n10000000 100000001\n733475792 1\n2 2\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "3 4\n16 8\n12 25\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 2\n10000011 100000000\n998244353 0\n2 2\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1011185365 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000001\n733475792 0\n2 2\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 2\n1 1\n", "output": ["0\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n211018821 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n211018821 0\n3 1\n2 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "5 4\n3 1\n10000011 101000000\n211018821 0\n3 1\n2 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n4 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "3 4\n14 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 1\n2 1\n1 3\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 15\n12 15\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 0\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n14 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000011 000000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 1\n9 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n"]}, {"input": "5 4\n1 1\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n9 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n10 18\n12 10\n2 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n733475792 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n22 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 0\n430995384 733598623\n2 9\n5 13\n433415385 169535970\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n9 6\n752625088 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1258790837 0\n3 0\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 173113793\n3 10\n16 6\n2 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n2 2\n10000001 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n9 6\n450441171 733598623\n2 9\n3 10\n433415385 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n16 21\n10 17\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n9 6\n12 9\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1683854825 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 241782432\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 38795044\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n2 1\n1 10\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 0\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "3 4\n16 12\n12 18\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n4 1\n10000011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n1908812372 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n2 1\n", "output": ["0\n"]}, {"input": "5 4\n3 1\n10010011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 2\n10000011 100000000\n998244353 0\n2 4\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 2\n1 2\n", "output": ["0\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n211018821 0\n4 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n3 1\n10000011 101000000\n211018821 0\n3 1\n2 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n4 29\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "3 4\n14 15\n12 13\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 1\n3 1\n1 3\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n2 1\n10000001 100000000\n998244353 0\n2 0\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n14 15\n10 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "3 1\n9 15\n12 9\n2 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n"]}, {"input": "5 4\n1 1\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 4\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 0\n430995384 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n9 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n2 2\n10000001 100000000\n1258790837 0\n5 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n5\n4\n3\n5\n7\n8\n"]}, {"input": "5 2\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n"]}, {"input": "3 4\n16 21\n10 17\n2 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1683854825 0\n3 1\n2 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n4 1\n1 10\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "5 1\n1 0\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n3 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "3 4\n16 12\n12 22\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000000 100000000\n1908812372 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000101 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n2 1\n", "output": ["0\n"]}, {"input": "5 1\n1 1\n10000101 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 2\n1 2\n", "output": ["0\n"]}, {"input": "3 1\n9 15\n12 9\n2 2\n1 3\n1 1\n1 1\n2 3\n", "output": ["0\n"]}, {"input": "5 4\n1 0\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 4\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n0 0\n430995384 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 2\n1 1\n10000000 100010000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n"]}, {"input": "10 7\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 1\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 9\n2 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "3 4\n1 12\n12 22\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000000 100000000\n1908812372 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n2 1\n10000101 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n2 1\n", "output": ["0\n"]}, {"input": "3 1\n9 15\n12 9\n2 4\n1 3\n1 1\n1 1\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n0 0\n140846265 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 9\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n8\n"]}, {"input": "5 2\n1 2\n10000000 100010000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n"]}, {"input": "10 7\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 1\n2 9\n1 1\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 13\n2 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n12 9\n2 4\n1 3\n1 1\n0 1\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n-1 0\n140846265 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 7\n3 10\n9 6\n529113291 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 1\n2 9\n1 1\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "3 1\n9 15\n12 9\n2 4\n1 3\n1 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 7\n3 10\n-1 0\n140846265 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n17 2\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n292159474 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n3 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n7\n"]}, {"input": "3 1\n9 15\n12 11\n2 4\n1 3\n1 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 2\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n12 11\n2 4\n1 3\n0 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 1\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n12 11\n4 4\n1 3\n0 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 1\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 6\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n16 11\n4 4\n1 3\n0 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 0\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 6\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 -1\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 6\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 2\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n0 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n2 1\n10000001 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}], "task_id": "codecontest/22", "repair_prompt": ["Kawasiro Nitori is excellent in engineering. Thus she has been appointed to help maintain trains.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment, starting with no trains and then adding or removing one each day over m days. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance in each day.\n\nOn a day a train is removed, it is not counted as in maintenance. The challenge is to manage the cyclical work and maintenance periods effectively for multiple trains over several days.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Kawasiro Nitori is excellent in engineering. Thus she has been appointed to help maintain trains.\n\nThere are n models of trains. Nitori's department will only have at most one train of each model at any moment, starting with no trains and then adding or removing one each day over m days. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance in each day.\n\nOn a day a train is removed, it is not counted as in maintenance. The challenge is to manage the cyclical work and maintenance periods effectively for multiple trains over several days.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Kawasiro Nitori is excellent in engineering. Thus she has been appointed to help maintain trains.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment, starting with no trains and then adding or removing one each day over m days. Once added, a train of model i works for x_i days, then enters maintenance for y_i days, continues working for x_i days again, and this cycle repeats until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance in each day.\n\nOn a day a train is removed, it is not counted as in maintenance. The challenge is to manage the cyclical work and maintenance periods effectively for multiple trains over several days.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Read x_i and y_i for each train model\n    train_cycles = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    # Initialize state tracking for each train model\n    train_states = [None] * n  # None means no train of this model is present\n    \n    # Prepare to process each day's operation\n    results = []\n    current_day = 0\n    \n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        index += 2\n        \n        if op == 1:  # Add train of model k\n            train_states[k] = current_day\n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Calculate number of trains in maintenance\n        maintenance_count = 0\n        for model in range(n):\n            if train_states[model] is not None:\n                x_i, y_i = train_cycles[model]\n                days_since_added = current_day - train_states[model]\n                cycle_length = x_i + y_i\n                if days_since_added % cycle_length >= x_i:\n                    maintenance_count += 1\n        \n        results.append(maintenance_count)\n        current_day += 1\n    \n    # Output the results for each day\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: None if not present, otherwise (start_day, cycle_position)\n    train_state = [None] * n\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_state[k] = (day, 0)  # Start working from this day\n        elif op == 2:  # Remove train of model k\n            train_state[k] = None\n        \n        # Calculate maintenance count for the current day\n        count = 0\n        for model in range(n):\n            if train_state[model] is not None:\n                start_day, cycle_position = train_state[model]\n                x_i, y_i = work_maintenance[model]\n                total_cycle = x_i + y_i\n                days_since_start = day - start_day\n                \n                # Determine if the train is in maintenance\n                if days_since_start >= x_i:\n                    cycle_day = days_since_start % total_cycle\n                    if cycle_day >= x_i:\n                        count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Parse n and m\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    # Parse x_i and y_i for each train model\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    # Initialize data structures\n    train_status = [None] * n  # None means no train, otherwise store the day it was added\n    maintenance_count = [0] * m\n    \n    # Process each operation\n    for day in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        index += 2\n        \n        if op == 1:  # Add train of model k\n            train_status[k] = day\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate number of trains in maintenance for the current day\n        count_in_maintenance = 0\n        for model in range(n):\n            if train_status[model] is not None:\n                days_since_added = day - train_status[model]\n                x_i, y_i = train_cycles[model]\n                cycle_length = x_i + y_i\n                if days_since_added >= x_i and (days_since_added % cycle_length) >= x_i:\n                    count_in_maintenance += 1\n        \n        maintenance_count[day] = count_in_maintenance\n    \n    # Output the results\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    work_maintenance = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: (start_day, cycle_position)\n    train_state = [None] * n\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_state[k] = (day, 0)  # Start working from today\n        elif op == 2:  # Remove train of model k\n            train_state[k] = None\n        \n        # Calculate maintenance count for the current day\n        count = 0\n        for model in range(n):\n            if train_state[model] is not None:\n                start_day, cycle_position = train_state[model]\n                x_i, y_i = work_maintenance[model]\n                total_cycle = x_i + y_i\n                days_since_start = day - start_day\n                \n                # Determine current cycle position\n                current_position = days_since_start % total_cycle\n                \n                # Check if in maintenance\n                if current_position >= x_i:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance_periods.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State of each train model: None if not present, otherwise a tuple (day_added, current_cycle_day)\n    train_states = [None] * n\n    maintenance_count = 0\n    \n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_states[k] = (day, 0)\n        elif op == 2:  # Remove train of model k\n            if train_states[k] is not None:\n                day_added, current_cycle_day = train_states[k]\n                x_i, y_i = work_maintenance_periods[k]\n                total_cycle = x_i + y_i\n                if current_cycle_day >= x_i:\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update maintenance count\n        current_maintenance_count = 0\n        for k in range(n):\n            if train_states[k] is not None:\n                day_added, current_cycle_day = train_states[k]\n                x_i, y_i = work_maintenance_periods[k]\n                total_cycle = x_i + y_i\n                \n                # Update the cycle day\n                current_cycle_day = (day - day_added) % total_cycle\n                \n                # Check if in maintenance\n                if current_cycle_day >= x_i:\n                    current_maintenance_count += 1\n        \n        results.append(current_maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance_cycles.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    \n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_cycles[k]\n            train_states[k] = (x_i, y_i, x_i)  # (work_days, maintenance_days, remaining_work_days)\n        \n        elif op == 2:  # Remove train of model k\n            if train_states[k] is not None:\n                _, y_i, remaining_work_days = train_states[k]\n                if remaining_work_days <= 0:\n                    maintenance_count -= 1\n            train_states[k] = None\n        \n        # Update train states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, remaining_work_days = train_states[i]\n                \n                if remaining_work_days > 0:\n                    remaining_work_days -= 1\n                else:\n                    remaining_work_days = -y_i + 1\n                    maintenance_count += 1\n                \n                if remaining_work_days == 0:\n                    maintenance_count -= 1\n                \n                train_states[i] = (x_i, y_i, remaining_work_days)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse the input\n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_periods = []\n    maintenance_periods = []\n    \n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_periods.append(x_i)\n        maintenance_periods.append(y_i)\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # Initialize data structures\n    train_status = [None] * n  # None means no train of this model is present\n    maintenance_count = [0] * m\n    \n    # Process each day's operation\n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_status[k] = 0  # Start at day 0 of its cycle\n        elif op == 2:  # Remove train\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance for the current day\n        count = 0\n        for i in range(n):\n            if train_status[i] is not None:\n                cycle_length = work_periods[i] + maintenance_periods[i]\n                current_day_in_cycle = train_status[i] % cycle_length\n                if current_day_in_cycle >= work_periods[i]:\n                    count += 1\n                train_status[i] += 1\n        \n        maintenance_count[day] = count\n    \n    # Output the number of trains in maintenance for each day\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model\n    train_state = [None] * n  # None means no train of this model is present\n    \n    # Result for each day\n    result = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        # Update the state of all trains\n        maintenance_count = 0\n        for i in range(n):\n            if train_state[i] is not None:\n                cycle_length = work_maintenance[i][0] + work_maintenance[i][1]\n                current_day_in_cycle = train_state[i] % cycle_length\n                \n                if current_day_in_cycle >= work_maintenance[i][0]:\n                    maintenance_count += 1\n                \n                # Increment the day in the cycle\n                train_state[i] += 1\n        \n        # Process the operation for the current day\n        if op == 1:  # Add train of model k\n            train_state[k] = 0  # Start its cycle\n        elif op == 2:  # Remove train of model k\n            train_state[k] = None  # Remove it\n        \n        # On the day a train is removed, it is not counted as in maintenance\n        if op == 2 and train_state[k] is None:\n            cycle_length = work_maintenance[k][0] + work_maintenance[k][1]\n            current_day_in_cycle = (train_state[k] - 1) % cycle_length\n            if current_day_in_cycle >= work_maintenance[k][0]:\n                maintenance_count -= 1\n        \n        result.append(maintenance_count)\n    \n    # Output the result\n    for count in result:\n        print(count)\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Parse the first line\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    # Parse the work and maintenance periods for each train model\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    # Initialize the status of each train model\n    train_status = [None] * n  # None means no train of this model is present\n    \n    # Prepare to store the output\n    output = []\n    \n    # Process each day's operation\n    for day in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        index += 2\n        \n        if op == 1:  # Add train of model k\n            train_status[k] = (day, train_cycles[k][0], train_cycles[k][1])  # (start_day, work_days, maintenance_days)\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance for this day\n        maintenance_count = 0\n        for status in train_status:\n            if status is not None:\n                start_day, work_days, maintenance_days = status\n                cycle_length = work_days + maintenance_days\n                days_since_start = day - start_day\n                \n                # Determine if the train is in maintenance\n                if days_since_start >= work_days:\n                    cycle_position = days_since_start % cycle_length\n                    if cycle_position >= work_days:\n                        maintenance_count += 1\n        \n        output.append(str(maintenance_count))\n    \n    # Print the output\n    sys.stdout.write(\"\\n\".join(output) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Read x_i and y_i for each train model\n    train_models = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_models.append((x_i, y_i))\n        index += 2\n    \n    # Initialize the status of each train model\n    train_status = [None] * n  # None means no train of this model is present\n    \n    # Prepare to track maintenance count for each day\n    maintenance_count = [0] * m\n    \n    # Process each operation\n    for day in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        index += 2\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_models[k]\n            train_status[k] = (day, x_i, y_i)  # Store the start day and cycle info\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance for this day\n        count = 0\n        for status in train_status:\n            if status is not None:\n                start_day, x_i, y_i = status\n                cycle_length = x_i + y_i\n                days_since_start = day - start_day\n                if days_since_start >= x_i and (days_since_start % cycle_length) >= x_i:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    # Output the maintenance count for each day\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Read x_i and y_i for each train model\n    train_cycles = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    # Initialize state tracking for each train model\n    train_states = [None] * n  # None means no train of this model is present\n    \n    # Prepare to process each day's operation\n    results = []\n    current_day = 0\n    \n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        index += 2\n        \n        if op == 1:  # Add train of model k\n            train_states[k] = current_day\n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Calculate number of trains in maintenance\n        maintenance_count = 0\n        for model in range(n):\n            if train_states[model] is not None:\n                x_i, y_i = train_cycles[model]\n                days_since_added = current_day - train_states[model]\n                cycle_length = x_i + y_i\n                if days_since_added % cycle_length >= x_i:\n                    maintenance_count += 1\n        \n        results.append(maintenance_count)\n        current_day += 1\n    \n    # Output the results for each day\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), and the work and maintenance periods for each train model.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get x_i and y_i for each train model.\"\n      ]\n    },\n    {\n      \"description\": \"Track the addition and removal of trains over m days and manage their work and maintenance cycles.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current state of each train model (whether it is added or removed).\",\n        \"For each of the m operations, update the state of the train model based on the operation (add or remove).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, iterate over all train models to check their current state.\",\n        \"Determine if a train is in maintenance based on its cycle (x_i days working, y_i days maintenance).\",\n        \"Count the number of trains in maintenance and store the result for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"Print the count of trains in maintenance for each of the m days.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Initialize data structures to track train states and cycles.\",\n    \"Process each day's operation to update train states.\",\n    \"Calculate and store the number of trains in maintenance for each day.\",\n    \"Output the results for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclical work and maintenance periods'\n    Explanation: This refers to the repeating pattern of a train working for a certain number of days (x_i) and then being in maintenance for a certain number of days (y_i). This cycle continues until the train is removed.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': This means that there can be zero or one train of each model at any given time.\n    '1 \u2264 n,m \u2264 2 \u22c5 10^5': This indicates the range for the number of train models and days, which is important for understanding the scale of the problem.\n    '1 \u2264 x_i,y_i \u2264 10^9': This indicates the range for the work and maintenance days, which is important for understanding the potential duration of cycles.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for tracking the addition and removal of trains and calculating the number of trains in maintenance should be considered simultaneously. Specifically, updating the state of the train model and checking its maintenance status should be done in the same loop for each day.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: On the first day, a train is added but it is working, not in maintenance.\n\n    Input: 1 2\n           1 1\n           1 1\n           2 1\n    Output: 0\n    Explanation: On the first day, a train is added but it is working, not in maintenance. On the second day, the train is removed.\n\n    Input: 2 3\n           1 1\n           1 1\n           1 1\n           1 2\n           2 1\n    Output: 0\n    Explanation: On the first day, a train of model 1 is added but it is working. On the second day, a train of model 2 is added but it is working. On the third day, the train of model 1 is removed.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the maintenance cycle is correctly tracked and updated for each train model, and that trains are not counted as in maintenance on the day they are removed.\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Read x_i and y_i for each train model\n    train_cycles = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    # Initialize state tracking for each train model\n    train_states = [None] * n  # None means no train of this model is present\n    \n    # Prepare to process each day's operation\n    results = []\n    current_day = 0\n    \n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        index += 2\n        \n        if op == 1:  # Add train of model k\n            train_states[k] = current_day\n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Calculate number of trains in maintenance\n        maintenance_count = 0\n        for model in range(n):\n            if train_states[model] is not None:\n                x_i, y_i = train_cycles[model]\n                days_since_added = current_day - train_states[model]\n                cycle_length = x_i + y_i\n                if days_since_added % cycle_length >= x_i:\n                    maintenance_count += 1\n        \n        results.append(maintenance_count)\n        current_day += 1\n    \n    # Output the results for each day\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the work (x_i) and maintenance (y_i) periods for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days, keeping track of their work and maintenance cycles.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current state of each train model (e.g., whether it is running or in maintenance).\",\n        \"For each day, process the operation: add or remove a train of model k.\",\n        \"If a train is added, start its work cycle.\",\n        \"If a train is removed, ensure it is not counted as in maintenance on that day.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, iterate over all train models to check their current state.\",\n        \"Count the number of trains that are in the maintenance phase.\",\n        \"Store the count for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, output the stored count of trains in maintenance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Initialize data structures to track train states and cycles.\",\n    \"Iterate over each day to process operations and update train states.\",\n    \"Calculate and store the number of trains in maintenance for each day.\",\n    \"Output the results for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclical work and maintenance periods'\n    Explanation: This refers to the repeating pattern of a train being in operation for a certain number of days (x_i) and then undergoing maintenance for another set of days (y_i). This cycle continues until the train is removed.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': This means that there can be zero or one train of each model at any given time.\n    '1 \u2264 n,m \u2264 2 \u22c5 10^5': This indicates the maximum number of train models and days, which affects the scalability of the solution.\n    '1 \u2264 x_i,y_i \u2264 10^9': This indicates the range for the work and maintenance periods, which affects the cycle calculations.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to processing operations and updating train states should be implemented simultaneously. Specifically:\n    - \"For each day, process the operation: add or remove a train of model k.\"\n    - \"If a train is added, start its work cycle.\"\n    - \"If a train is removed, ensure it is not counted as in maintenance on that day.\"\n    These steps should be handled in a single loop that processes each day's operations and updates the train states accordingly.\n\n# [edge case] \n    Edge Case 1: n = 1, m = 1, operations = [(1, 1)], x_1 = 1, y_1 = 1\n    Expected Output: 0\n    Explanation: On the first day, a train is added and it starts working, so no train is in maintenance.\n\n    Edge Case 2: n = 1, m = 2, operations = [(1, 1), (2, 1)], x_1 = 1, y_1 = 1\n    Expected Output: 0, 0\n    Explanation: On the first day, a train is added and it starts working. On the second day, the train is removed, so it is not counted as in maintenance.\n\n    Edge Case 3: n = 2, m = 3, operations = [(1, 1), (1, 2), (2, 1)], x_1 = 1, y_1 = 1, x_2 = 2, y_2 = 2\n    Expected Output:", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: None if not present, otherwise (start_day, cycle_position)\n    train_state = [None] * n\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_state[k] = (day, 0)  # Start working from this day\n        elif op == 2:  # Remove train of model k\n            train_state[k] = None\n        \n        # Calculate maintenance count for the current day\n        count = 0\n        for model in range(n):\n            if train_state[model] is not None:\n                start_day, cycle_position = train_state[model]\n                x_i, y_i = work_maintenance[model]\n                total_cycle = x_i + y_i\n                days_since_start = day - start_day\n                \n                # Determine if the train is in maintenance\n                if days_since_start >= x_i:\n                    cycle_day = days_since_start % total_cycle\n                    if cycle_day >= x_i:\n                        count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), and the work and maintenance periods for each train model.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get x_i and y_i for each train model.\"\n      ]\n    },\n    {\n      \"description\": \"Track the status of each train model over m days based on operations (add or remove).\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status of each train model (added or removed).\",\n        \"Iterate over the next m lines to update the status of train models based on operations.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, check the status of each train model.\",\n        \"Determine if a train is in maintenance based on its cycle (x_i days working, y_i days maintenance).\",\n        \"Count the number of trains in maintenance for the current day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"Print the count of trains in maintenance for each of the m days.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Initialize data structures to track train statuses and cycles.\",\n    \"Iterate over each day to update train statuses based on operations.\",\n    \"Calculate and store the number of trains in maintenance for each day.\",\n    \"Output the results for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclical work and maintenance periods'\n    Explanation: This refers to the alternating periods of work and maintenance for each train model. A train works for x_i days, then goes into maintenance for y_i days, and this cycle repeats until the train is removed.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model'\n    Explanation: This means that there can be zero or one train of each model at any given time, but not more than one.\n    'x_i days', 'y_i days'\n    Explanation: These are the specific durations for which a train model works and is in maintenance, respectively. In code, this can be implemented by tracking the number of days since a train was added and using modulo operations to determine its current state.\n\n# [degree adverb]\n    'only'\n    Explanation: This indicates exclusivity, meaning that on a given day, only the specified train model is added or removed, affecting the count of trains in maintenance.\n\n# [code logic]\n    The steps in the plan related to updating train statuses and calculating maintenance should be considered simultaneously. Specifically, when iterating over each day to update train statuses, the calculation of maintenance status should occur in the same loop to ensure accurate tracking of train states.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: With only one train model and one day, the train is added and starts working immediately, so no train is in maintenance.\n\n    Input: 2 2\n           1 1\n           1 1\n           1 1\n           2 1\n    Output: 0\n            0\n    Explanation: On the first day, the train is added and starts working. On the second day, it is removed, so no train is in maintenance on either day.\n\n    Input: 3 3\n           2 2\n           1 1\n           1 1\n           1 1\n           1 2\n           2 1\n    Output: 0\n            0\n            0\n    Explanation: The first train is added and starts working. The second train is added and starts working. The first train is removed, so no train is in maintenance on any day.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Parse n and m\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    # Parse x_i and y_i for each train model\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    # Initialize data structures\n    train_status = [None] * n  # None means no train, otherwise store the day it was added\n    maintenance_count = [0] * m\n    \n    # Process each operation\n    for day in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        index += 2\n        \n        if op == 1:  # Add train of model k\n            train_status[k] = day\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate number of trains in maintenance for the current day\n        count_in_maintenance = 0\n        for model in range(n):\n            if train_status[model] is not None:\n                days_since_added = day - train_status[model]\n                x_i, y_i = train_cycles[model]\n                cycle_length = x_i + y_i\n                if days_since_added >= x_i and (days_since_added % cycle_length) >= x_i:\n                    count_in_maintenance += 1\n        \n        maintenance_count[day] = count_in_maintenance\n    \n    # Output the results\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the work (x_i) and maintenance (y_i) periods for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days, keeping track of their work and maintenance cycles.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current state of each train model (e.g., whether it is running or in maintenance).\",\n        \"For each day, based on the operation (op, k), update the state of the train model k.\",\n        \"If op=1, add the train model k and start its work cycle.\",\n        \"If op=2, remove the train model k and ensure it is not counted in maintenance.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, iterate over all train models currently in the department.\",\n        \"Check if each train model is in its maintenance period based on its cycle.\",\n        \"Count the number of trains in maintenance and store the result for that day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, output the calculated number of trains in maintenance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Initialize data structures to track train states and cycles.\",\n    \"Iterate over each day, updating train states based on operations.\",\n    \"For each day, calculate and store the number of trains in maintenance.\",\n    \"Output the results for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclical work and maintenance periods'\n    Explanation: This refers to the repeating pattern of a train working for a certain number of days (x_i) and then being in maintenance for a certain number of days (y_i). This cycle continues until the train is removed.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': This means that there can be zero or one train of each model at any given time.\n    '1 \u2264 n,m \u2264 2 \u22c5 10^5': This indicates the maximum number of train models and days, which affects the scalability of the solution.\n    '1 \u2264 x_i,y_i \u2264 10^9': This indicates the range for the work and maintenance periods, which affects the cycle calculations.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for simulating the addition and removal of trains and calculating the number of trains in maintenance should be considered simultaneously. Specifically, updating the state of the train model and checking its maintenance status should be done in the same loop for each day.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: On the first day, a train is added and it starts working, so no train is in maintenance.\n\n    Input: 1 2\n           1 1\n           1 1\n           2 1\n    Output: 0\n    Explanation: On the first day, a train is added and it starts working. On the second day, the train is removed, so no train is in maintenance.\n\n    Input: 2 3\n           1 1\n           1 1\n           1 1\n           1 2\n           2 1\n    Output: 0\n            0\n            0\n    Explanation: On the first day, a train of model 1 is added and starts working. On the second day, a train of model 2 is added and starts working. On the third day, the train of model 1 is removed, so no train is in maintenance.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the train is not counted in maintenance on the day it is removed.\n    ```python\n    if op == 2", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    work_maintenance = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: (start_day, cycle_position)\n    train_state = [None] * n\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_state[k] = (day, 0)  # Start working from today\n        elif op == 2:  # Remove train of model k\n            train_state[k] = None\n        \n        # Calculate maintenance count for the current day\n        count = 0\n        for model in range(n):\n            if train_state[model] is not None:\n                start_day, cycle_position = train_state[model]\n                x_i, y_i = work_maintenance[model]\n                total_cycle = x_i + y_i\n                days_since_start = day - start_day\n                \n                # Determine current cycle position\n                current_position = days_since_start % total_cycle\n                \n                # Check if in maintenance\n                if current_position >= x_i:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 101)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    work_maintenance = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: (start_day, cycle_position)\n    train_state = [None] * n\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_state[k] = (day, 0)  # Start working from today\n        elif op == 2:  # Remove train of model k\n            train_state[k] = None\n        \n        # Calculate maintenance count for the current day\n        count = 0\n        for model in range(n):\n            if train_state[model] is not None:\n                start_day, cycle_position = train_state[model]\n                x_i, y_i = work_maintenance[model]\n                total_cycle = x_i + y_i\n                days_since_start = day - start_day\n                \n                # Determine current cycle position\n                current_position = days_since_start % total_cycle\n                \n                # Check if in maintenance\n                if current_position >= x_i:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the work (x_i) and maintenance (y_i) periods for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days, keeping track of their work and maintenance cycles.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current state of each train model (whether it is added, in work, or in maintenance).\",\n        \"For each operation, update the state of the train model based on whether it is being added or removed.\",\n        \"For each day, update the cycle of each active train model (work or maintenance) and count how many are in maintenance.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, after updating the train states, output the count of trains currently in maintenance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data about train models and daily operations.\",\n    \"Initialize data structures to manage the state of each train model and track their cycles.\",\n    \"Iterate over each day, processing the operations to add or remove trains and updating their work/maintenance cycles.\",\n    \"For each day, calculate and output the number of trains in maintenance.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclical work and maintenance periods'\n    Explanation: This refers to the alternating periods of work and maintenance for each train model. Each train model has a specific number of days it works (x_i) followed by a specific number of days it is in maintenance (y_i), and this cycle repeats until the train is removed.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': This means that there can be zero or one train of each model at any given time, but not more than one.\n    '1 \u2264 n,m \u2264 2 \u22c5 10^5': This indicates the maximum number of train models and days, which affects the scalability and performance of the solution.\n    '1 \u2264 x_i,y_i \u2264 10^9': This indicates the range for work and maintenance periods, which affects how the cycles are calculated.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but within the simulation of train operations, updating the state of each train and counting those in maintenance should be done simultaneously for each day. This can be achieved by iterating over the active trains and updating their states in a single loop.\n\n# [edge case]\n    1. Input: 1 1\\n1 1\\n1 1\\n\n       Output: 0\n       Explanation: On the first day, a train is added and is in work, not maintenance.\n    2. Input: 1 2\\n1 1\\n1 1\\n2 1\\n\n       Output: 0\\n0\n       Explanation: On the first day, a train is added and is in work. On the second day, it is removed, so no train is in maintenance.\n    3. Input: 2 3\\n1 1\\n1 1\\n1 1\\n1 2\\n2 1\\n\n       Output: 0\\n0\\n0\n       Explanation: On the first day, a train of model 1 is added and is in work. On the second day, a train of model 2 is added and is in work. On the third day, the train of model 1 is removed, leaving the train of model 2 still in work.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should ensure that when a train is added,", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance_periods.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State of each train model: None if not present, otherwise a tuple (day_added, current_cycle_day)\n    train_states = [None] * n\n    maintenance_count = 0\n    \n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_states[k] = (day, 0)\n        elif op == 2:  # Remove train of model k\n            if train_states[k] is not None:\n                day_added, current_cycle_day = train_states[k]\n                x_i, y_i = work_maintenance_periods[k]\n                total_cycle = x_i + y_i\n                if current_cycle_day >= x_i:\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update maintenance count\n        current_maintenance_count = 0\n        for k in range(n):\n            if train_states[k] is not None:\n                day_added, current_cycle_day = train_states[k]\n                x_i, y_i = work_maintenance_periods[k]\n                total_cycle = x_i + y_i\n                \n                # Update the cycle day\n                current_cycle_day = (day - day_added) % total_cycle\n                \n                # Check if in maintenance\n                if current_cycle_day >= x_i:\n                    current_maintenance_count += 1\n        \n        results.append(current_maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models, number of days, train model work and maintenance periods, and daily operations.\",\n      \"details\": \"Read the first line to get n and m. Read the next n lines to get x_i and y_i for each train model. Read the next m lines to get the operations (op, k) for each day.\"\n    },\n    {\n      \"description\": \"Track the state of each train model over the days.\",\n      \"details\": \"Maintain a data structure to keep track of the current state (working or maintenance) and the remaining days in the current state for each train model.\"\n    },\n    {\n      \"description\": \"Simulate the daily operations and update the state of each train model.\",\n      \"details\": \"For each day, perform the operation (add or remove a train) and update the state of the train models accordingly. Adjust the remaining days in the current state for each train model.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"details\": \"After processing the operations for each day, count the number of trains currently in maintenance and store the result.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize data structures to store train model states and their work/maintenance cycles.\",\n    \"Iterate over each day and perform the specified operation (add or remove a train).\",\n    \"Update the state of each train model based on its work and maintenance cycle.\",\n    \"Count the number of trains in maintenance at the end of each day.\",\n    \"Output the count of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclical work and maintenance periods'\n    Explanation: This refers to the alternating periods of work and maintenance for each train model. Each train model has a specific number of days it works followed by a specific number of days it is in maintenance, and this cycle repeats until the train is removed.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model'\n    Explanation: This means that there can be no more than one train of a particular model at any given time. In code, this can be implemented by ensuring that when a train is added, there is no other train of the same model already present.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to updating the state of train models and counting the number of trains in maintenance should be considered simultaneously. Specifically, when performing daily operations, the state of each train model should be updated, and the count of trains in maintenance should be calculated in the same loop.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: Only one train is added and it starts working immediately, so no train is in maintenance.\n\n    Input: 2 2\n           1 1\n           1 1\n           1 1\n           1 2\n    Output: 0\n            0\n    Explanation: Both trains are added and start working immediately, so no train is in maintenance.\n\n    Input: 1 3\n           1 1\n           1 1\n           1 1\n           2 1\n    Output: 0\n            0\n            0\n    Explanation: The train is added, works for one day, and is removed before entering maintenance.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of updating train states and counting maintenance trains should naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance_cycles.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    \n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_cycles[k]\n            train_states[k] = (x_i, y_i, x_i)  # (work_days, maintenance_days, remaining_work_days)\n        \n        elif op == 2:  # Remove train of model k\n            if train_states[k] is not None:\n                _, y_i, remaining_work_days = train_states[k]\n                if remaining_work_days <= 0:\n                    maintenance_count -= 1\n            train_states[k] = None\n        \n        # Update train states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, remaining_work_days = train_states[i]\n                \n                if remaining_work_days > 0:\n                    remaining_work_days -= 1\n                else:\n                    remaining_work_days = -y_i + 1\n                    maintenance_count += 1\n                \n                if remaining_work_days == 0:\n                    maintenance_count -= 1\n                \n                train_states[i] = (x_i, y_i, remaining_work_days)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 114)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance_cycles.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    \n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_cycles[k]\n            train_states[k] = (x_i, y_i, x_i)  # (work_days, maintenance_days, remaining_work_days)\n        \n        elif op == 2:  # Remove train of model k\n            if train_states[k] is not None:\n                _, y_i, remaining_work_days = train_states[k]\n                if remaining_work_days <= 0:\n                    maintenance_count -= 1\n            train_states[k] = None\n        \n        # Update train states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, remaining_work_days = train_states[i]\n                \n                if remaining_work_days > 0:\n                    remaining_work_days -= 1\n                else:\n                    remaining_work_days = -y_i + 1\n                    maintenance_count += 1\n                \n                if remaining_work_days == 0:\n                    maintenance_count -= 1\n                \n                train_states[i] = (x_i, y_i, remaining_work_days)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models, number of days, and the work and maintenance periods for each train model.\",\n      \"steps\": [\n        \"Read the first line to get integers n (number of train models) and m (number of days).\",\n        \"Read the next n lines to get the work and maintenance periods (x_i, y_i) for each train model.\"\n      ]\n    },\n    {\n      \"description\": \"Track the addition and removal of trains and their maintenance status over m days.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status of each train model (whether it is added and its current cycle position).\",\n        \"Iterate over the next m lines to process operations (op, k) where op indicates addition or removal and k indicates the train model.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, update the status of each train model based on its cycle (work or maintenance).\",\n        \"Count the number of trains in maintenance for the current day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"Print the count of trains in maintenance for each of the m days.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Initialize data structures to track train status and cycles.\",\n    \"Process each day's operation to update train status.\",\n    \"Calculate and output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclical work and maintenance periods'\n    Explanation: This refers to the alternating periods of work and maintenance for each train model. Each train model has a specific number of days it works (x_i) followed by a specific number of days it is in maintenance (y_i), and this cycle repeats until the train is removed.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': This means that there can be zero or one train of each model at any given time, but not more than one.\n    '1 \u2264 n,m \u2264 2 \u22c5 10^5': This indicates the range of possible values for n (number of train models) and m (number of days), which can be used to determine the size of data structures.\n    '1 \u2264 x_i,y_i \u2264 10^9': This indicates the range of possible values for x_i (work days) and y_i (maintenance days), which can affect the cycle calculations.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the subproblem \"Track the addition and removal of trains and their maintenance status over m days\" should be implemented simultaneously. Specifically, the initialization of the data structure and the iteration over the operations should be closely linked, as the data structure needs to be updated in real-time as operations are processed.\n\n# [edge case]\n    1. Input: 1 1\\n1 1\\n1 1\\n1 1\n       Output: 0\n       Explanation: Only one train is added and removed on the same day, so it never enters maintenance.\n    2. Input: 1 2\\n1 1\\n1 1\\n1 1\\n2 1\n       Output: 0\\n0\n       Explanation: The train is added and removed before it can enter maintenance.\n    3. Input: 2 3\\n1 1\\n1 1\\n1 1\\n1 2\\n2 1\n       Output: 0\\n0\\n0\n       Explanation: Both trains are added but removed before entering maintenance.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where trains are added and removed on the same day or before entering maintenance.\n    ```python\n    # Example code snippet to handle edge cases\n    if op == 1:  # Add train\n        if train_status[k] is None", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse the input\n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_periods = []\n    maintenance_periods = []\n    \n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_periods.append(x_i)\n        maintenance_periods.append(y_i)\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # Initialize data structures\n    train_status = [None] * n  # None means no train of this model is present\n    maintenance_count = [0] * m\n    \n    # Process each day's operation\n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_status[k] = 0  # Start at day 0 of its cycle\n        elif op == 2:  # Remove train\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance for the current day\n        count = 0\n        for i in range(n):\n            if train_status[i] is not None:\n                cycle_length = work_periods[i] + maintenance_periods[i]\n                current_day_in_cycle = train_status[i] % cycle_length\n                if current_day_in_cycle >= work_periods[i]:\n                    count += 1\n                train_status[i] += 1\n        \n        maintenance_count[day] = count\n    \n    # Output the number of trains in maintenance for each day\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 108)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse the input\n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_periods = []\n    maintenance_periods = []\n    \n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_periods.append(x_i)\n        maintenance_periods.append(y_i)\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # Initialize data structures\n    train_status = [None] * n  # None means no train of this model is present\n    maintenance_count = [0] * m\n    \n    # Process each day's operation\n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_status[k] = 0  # Start at day 0 of its cycle\n        elif op == 2:  # Remove train\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance for the current day\n        count = 0\n        for i in range(n):\n            if train_status[i] is not None:\n                cycle_length = work_periods[i] + maintenance_periods[i]\n                current_day_in_cycle = train_status[i] % cycle_length\n                if current_day_in_cycle >= work_periods[i]:\n                    count += 1\n                train_status[i] += 1\n        \n        maintenance_count[day] = count\n    \n    # Output the number of trains in maintenance for each day\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"output\": \"A structured representation of the input data, including train models' work and maintenance periods and daily operations.\"\n    },\n    {\n      \"description\": \"Implement a data structure to track the state of each train model, including whether it is currently added, its current cycle position (working or maintenance), and the remaining days in that state.\",\n      \"output\": \"A data structure that can efficiently update and query the state of each train model.\"\n    },\n    {\n      \"description\": \"Simulate each day's operations, updating the state of the trains based on the operation (add or remove) and the current cycle of each train.\",\n      \"output\": \"An updated state of all train models for each day, reflecting the addition or removal of trains and their current cycle status.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day based on the current state of all train models.\",\n      \"output\": \"A list of integers representing the number of trains in maintenance for each day.\"\n    },\n    {\n      \"description\": \"Output the result for each day as specified in the requirement.\",\n      \"output\": \"The final output format as required, with each day's maintenance count printed on a new line.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of train models, number of days, work and maintenance periods for each model, and daily operations.\",\n    \"Initialize a data structure to track the state of each train model, including its cycle position and remaining days in that state.\",\n    \"Iterate over each day's operations:\",\n    \"  - If a train is added, update its state to start its work cycle.\",\n    \"  - If a train is removed, ensure it is not counted in maintenance.\",\n    \"  - Update the cycle state of all active trains, decrementing their remaining days in the current cycle.\",\n    \"  - Transition trains between work and maintenance cycles as needed.\",\n    \"Calculate the number of trains in maintenance for the current day based on the updated states.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclical work and maintenance periods'\n    Explanation: This refers to the alternating periods of work and maintenance for each train model. Each train model has a specific number of days it works (x_i) followed by a specific number of days it is in maintenance (y_i), and this cycle repeats until the train is removed.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': This means that there can be zero or one train of each model at any given time, but not more than one.\n    '1 \u2264 n,m \u2264 2 \u22c5 10^5': This indicates the maximum number of train models and days, which affects the scalability of the solution.\n    '1 \u2264 x_i,y_i \u2264 10^9': This indicates the range for work and maintenance days, which affects the cycle calculations.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to updating the state of trains and calculating the number of trains in maintenance should be implemented simultaneously. Specifically:\n    - \"Update the cycle state of all active trains, decrementing their remaining days in the current cycle.\"\n    - \"Transition trains between work and maintenance cycles as needed.\"\n    - \"Calculate the number of trains in maintenance for the current day based on the updated states.\"\n    These steps can be combined in a loop that processes each day's operations and updates the state of all trains accordingly.\n\n# [edge case]\n    Edge Case 1: n = 1, m = 1, x_1 = 1, y_1 = 1, operations = [(1, 1)]\n    Expected Output: 0\n    Explanation: On the first day, the train is added and is in its work period, so no trains are in maintenance.\n\n    Edge Case 2: n = 1, m = 2, x_1 = 1, y_1 = 1, operations = [(1, 1), (2, 1)]\n    Expected Output: 0, 0\n    Explanation: On the first day, the train is added and is in its work period. On the second day, the train is removed, so no trains are in maintenance.\n\n    Edge Case 3: n = 2, m = 3, x_1 = 1, y_1 = 1, x_2 = 2, y_2 = 1, operations = [(", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model\n    train_state = [None] * n  # None means no train of this model is present\n    \n    # Result for each day\n    result = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        # Update the state of all trains\n        maintenance_count = 0\n        for i in range(n):\n            if train_state[i] is not None:\n                cycle_length = work_maintenance[i][0] + work_maintenance[i][1]\n                current_day_in_cycle = train_state[i] % cycle_length\n                \n                if current_day_in_cycle >= work_maintenance[i][0]:\n                    maintenance_count += 1\n                \n                # Increment the day in the cycle\n                train_state[i] += 1\n        \n        # Process the operation for the current day\n        if op == 1:  # Add train of model k\n            train_state[k] = 0  # Start its cycle\n        elif op == 2:  # Remove train of model k\n            train_state[k] = None  # Remove it\n        \n        # On the day a train is removed, it is not counted as in maintenance\n        if op == 2 and train_state[k] is None:\n            cycle_length = work_maintenance[k][0] + work_maintenance[k][1]\n            current_day_in_cycle = (train_state[k] - 1) % cycle_length\n            if current_day_in_cycle >= work_maintenance[k][0]:\n                maintenance_count -= 1\n        \n        result.append(maintenance_count)\n    \n    # Output the result\n    for count in result:\n        print(count)", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 112)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model\n    train_state = [None] * n  # None means no train of this model is present\n    \n    # Result for each day\n    result = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        # Update the state of all trains\n        maintenance_count = 0\n        for i in range(n):\n            if train_state[i] is not None:\n                cycle_length = work_maintenance[i][0] + work_maintenance[i][1]\n                current_day_in_cycle = train_state[i] % cycle_length\n                \n                if current_day_in_cycle >= work_maintenance[i][0]:\n                    maintenance_count += 1\n                \n                # Increment the day in the cycle\n                train_state[i] += 1\n        \n        # Process the operation for the current day\n        if op == 1:  # Add train of model k\n            train_state[k] = 0  # Start its cycle\n        elif op == 2:  # Remove train of model k\n            train_state[k] = None  # Remove it\n        \n        # On the day a train is removed, it is not counted as in maintenance\n        if op == 2 and train_state[k] is None:\n            cycle_length = work_maintenance[k][0] + work_maintenance[k][1]\n            current_day_in_cycle = (train_state[k] - 1) % cycle_length\n            if current_day_in_cycle >= work_maintenance[k][0]:\n                maintenance_count -= 1\n        \n        result.append(maintenance_count)\n    \n    # Output the result\n    for count in result:\n        print(count)", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input data to extract the number of train models, number of days, and the work and maintenance periods for each train model.\",\n      \"steps\": [\n        \"Read the first line to get integers n (number of train models) and m (number of days).\",\n        \"Read the next n lines to get the work and maintenance periods (x_i, y_i) for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Track the status of each train model over the days, including whether it is in work or maintenance.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status of each train model (e.g., whether it is added, removed, in work, or in maintenance).\",\n        \"For each operation, update the status of the train model accordingly.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, iterate through the train models to check their current status.\",\n        \"Determine if a train model is in maintenance based on its cycle of work and maintenance periods.\",\n        \"Count the number of trains in maintenance for that day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, output the calculated number of trains in maintenance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Initialize data structures to track train models' status.\",\n    \"Iterate through each day's operations to update train models' status.\",\n    \"Calculate and output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclical work and maintenance periods'\n    Explanation: This refers to the alternating periods of work and maintenance for each train model. Each train model has a specific number of days it works (x_i) followed by a specific number of days it is in maintenance (y_i), and this cycle repeats until the train is removed.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': This means that there can be zero or one train of each model at any given time, but not more than one.\n    '1 \u2264 n,m \u2264 2 \u22c5 10^5': This indicates the maximum number of train models and days, which affects the scalability of the solution.\n    '1 \u2264 x_i,y_i \u2264 10^9': This indicates the range for work and maintenance periods, which affects the logic for calculating maintenance days.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but within the step \"Track the status of each train model over the days,\" updating the status of the train model and checking if it is in maintenance should be done simultaneously. This can be achieved by updating the status and immediately checking the maintenance condition in the same loop.\n\n# [edge case]\n    1. Input: 1 1\n             1 1\n             1 1\n       Output: 0\n       Explanation: On the first day, a train is added and it is in work, not maintenance.\n\n    2. Input: 1 2\n             1 1\n             1 1\n             2 1\n       Output: 0\n               0\n       Explanation: On the first day, a train is added and it is in work. On the second day, it is removed, so no train is in maintenance.\n\n    3. Input: 2 3\n             1 1\n             1 1\n             1 1\n             1 2\n             2 1\n       Output: 0\n               0\n               0\n       Explanation: On the first day, a train of model 1 is added and is in work. On the second day, a train of model 2 is added and is in work. On the third day, the train of model 1 is removed, leaving only the train of model 2 in work.\n\n", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Parse the first line\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    # Parse the work and maintenance periods for each train model\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    # Initialize the status of each train model\n    train_status = [None] * n  # None means no train of this model is present\n    \n    # Prepare to store the output\n    output = []\n    \n    # Process each day's operation\n    for day in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        index += 2\n        \n        if op == 1:  # Add train of model k\n            train_status[k] = (day, train_cycles[k][0], train_cycles[k][1])  # (start_day, work_days, maintenance_days)\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance for this day\n        maintenance_count = 0\n        for status in train_status:\n            if status is not None:\n                start_day, work_days, maintenance_days = status\n                cycle_length = work_days + maintenance_days\n                days_since_start = day - start_day\n                \n                # Determine if the train is in maintenance\n                if days_since_start >= work_days:\n                    cycle_position = days_since_start % cycle_length\n                    if cycle_position >= work_days:\n                        maintenance_count += 1\n        \n        output.append(str(maintenance_count))\n    \n    # Print the output\n    sys.stdout.write(\"\\n\".join(output) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 106)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Parse the first line\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    # Parse the work and maintenance periods for each train model\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    # Initialize the status of each train model\n    train_status = [None] * n  # None means no train of this model is present\n    \n    # Prepare to store the output\n    output = []\n    \n    # Process each day's operation\n    for day in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        index += 2\n        \n        if op == 1:  # Add train of model k\n            train_status[k] = (day, train_cycles[k][0], train_cycles[k][1])  # (start_day, work_days, maintenance_days)\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance for this day\n        maintenance_count = 0\n        for status in train_status:\n            if status is not None:\n                start_day, work_days, maintenance_days = status\n                cycle_length = work_days + maintenance_days\n                days_since_start = day - start_day\n                \n                # Determine if the train is in maintenance\n                if days_since_start >= work_days:\n                    cycle_position = days_since_start % cycle_length\n                    if cycle_position >= work_days:\n                        maintenance_count += 1\n        \n        output.append(str(maintenance_count))\n    \n    # Print the output\n    sys.stdout.write(\"\\n\".join(output) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), and the work and maintenance periods for each train model.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get x_i and y_i for each train model.\"\n      ]\n    },\n    {\n      \"description\": \"Track the status of each train model over the m days based on the operations provided.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status (working or maintenance) of each train model.\",\n        \"Iterate over the m operations to update the status of the train models.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, check the status of all train models.\",\n        \"Count the number of trains that are in maintenance.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"Print the count of trains in maintenance for each of the m days.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, m, x_i, y_i, and the operations.\",\n    \"Initialize a data structure to track the status of each train model.\",\n    \"Iterate over the m operations to update the status of train models.\",\n    \"For each day, calculate the number of trains in maintenance.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclical work and maintenance periods'\n    Explanation: This refers to the alternating periods of work and maintenance for each train model. Each train model has a specific number of days it works (x_i) followed by a specific number of days it is in maintenance (y_i), and this cycle repeats until the train is removed.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': This means that there can be zero or one train of each model at any given time.\n    '1 \u2264 n,m \u2264 2 \u22c5 10^5': This indicates the maximum number of train models and days, which affects the scalability of the solution.\n    '1 \u2264 x_i,y_i \u2264 10^9': This indicates the range for work and maintenance days, which affects the calculation of cycles.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan are well-structured and do not require simultaneous implementation. Each step logically follows from the previous one, ensuring that the input is parsed, the status of trains is tracked, and the number of trains in maintenance is calculated and outputted.\n\n# [edge case]\n    1. Input: 1 1\\n1 1\\n1 1\\nOutput: 0\n       Explanation: On the first day, a train is added and it starts working, so no train is in maintenance.\n    2. Input: 1 2\\n1 1\\n1 1\\n2 1\\nOutput: 0\\n0\n       Explanation: On the first day, a train is added and it starts working. On the second day, the train is removed, so no train is in maintenance on either day.\n    3. Input: 2 3\\n1 1\\n1 1\\n1 1\\n1 2\\n2 1\\nOutput: 0\\n0\\n0\n       Explanation: On the first day, a train of model 1 is added and starts working. On the second day, a train of model 2 is added and starts working. On the third day, the train of model 1 is removed, so no train is in maintenance on any day.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of tracking the status of each train model and counting the number of trains in maintenance each day should handle these cases correctly", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Read x_i and y_i for each train model\n    train_models = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_models.append((x_i, y_i))\n        index += 2\n    \n    # Initialize the status of each train model\n    train_status = [None] * n  # None means no train of this model is present\n    \n    # Prepare to track maintenance count for each day\n    maintenance_count = [0] * m\n    \n    # Process each operation\n    for day in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        index += 2\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_models[k]\n            train_status[k] = (day, x_i, y_i)  # Store the start day and cycle info\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance for this day\n        count = 0\n        for status in train_status:\n            if status is not None:\n                start_day, x_i, y_i = status\n                cycle_length = x_i + y_i\n                days_since_start = day - start_day\n                if days_since_start >= x_i and (days_since_start % cycle_length) >= x_i:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    # Output the maintenance count for each day\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 96)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Read x_i and y_i for each train model\n    train_models = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_models.append((x_i, y_i))\n        index += 2\n    \n    # Initialize the status of each train model\n    train_status = [None] * n  # None means no train of this model is present\n    \n    # Prepare to track maintenance count for each day\n    maintenance_count = [0] * m\n    \n    # Process each operation\n    for day in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        index += 2\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_models[k]\n            train_status[k] = (day, x_i, y_i)  # Store the start day and cycle info\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance for this day\n        count = 0\n        for status in train_status:\n            if status is not None:\n                start_day, x_i, y_i = status\n                cycle_length = x_i + y_i\n                days_since_start = day - start_day\n                if days_since_start >= x_i and (days_since_start % cycle_length) >= x_i:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    # Output the maintenance count for each day\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), and the work and maintenance periods for each train model.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get x_i and y_i for each train model.\"\n      ]\n    },\n    {\n      \"description\": \"Track the addition and removal of trains over m days and manage their work and maintenance cycles.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current state of each train model (whether it is added or removed).\",\n        \"For each of the m operations, update the state of the train model based on the operation (add or remove).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, iterate over all train models to check their current state.\",\n        \"Determine if a train is in maintenance based on its cycle (x_i days working, y_i days maintenance).\",\n        \"Count the number of trains in maintenance and store the result for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"Print the count of trains in maintenance for each of the m days.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Initialize data structures to track train states and cycles.\",\n    \"Process each day's operation to update train states.\",\n    \"Calculate and store the number of trains in maintenance for each day.\",\n    \"Output the results for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclical work and maintenance periods'\n    Explanation: This refers to the repeating pattern of a train working for a certain number of days (x_i) and then being in maintenance for a certain number of days (y_i). This cycle continues until the train is removed.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': This means that there can be zero or one train of each model at any given time.\n    '1 \u2264 n,m \u2264 2 \u22c5 10^5': This indicates the range for the number of train models and days, which is important for understanding the scale of the problem.\n    '1 \u2264 x_i,y_i \u2264 10^9': This indicates the range for the work and maintenance days, which is important for understanding the potential duration of cycles.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for tracking the addition and removal of trains and calculating the number of trains in maintenance should be considered simultaneously. Specifically, updating the state of the train model and checking its maintenance status should be done in the same loop for each day.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: On the first day, a train is added but it is working, not in maintenance.\n\n    Input: 1 2\n           1 1\n           1 1\n           2 1\n    Output: 0\n    Explanation: On the first day, a train is added but it is working, not in maintenance. On the second day, the train is removed.\n\n    Input: 2 3\n           1 1\n           1 1\n           1 1\n           1 2\n           2 1\n    Output: 0\n    Explanation: On the first day, a train of model 1 is added but it is working. On the second day, a train of model 2 is added but it is working. On the third day, the train of model 1 is removed.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the maintenance cycle is correctly tracked and updated for each train model, and that trains are not counted as in maintenance on the day they are removed.\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Read x_i and y_i for each train model\n    train_cycles = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    # Initialize state tracking for each train model\n    train_states = [None] * n  # None means no train of this model is present\n    \n    # Prepare to process each day's operation\n    results = []\n    current_day = 0\n    \n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        index += 2\n        \n        if op == 1:  # Add train of model k\n            train_states[k] = current_day\n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Calculate number of trains in maintenance\n        maintenance_count = 0\n        for model in range(n):\n            if train_states[model] is not None:\n                x_i, y_i = train_cycles[model]\n                days_since_added = current_day - train_states[model]\n                cycle_length = x_i + y_i\n                if days_since_added % cycle_length >= x_i:\n                    maintenance_count += 1\n        \n        results.append(maintenance_count)\n        current_day += 1\n    \n    # Output the results for each day\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, false, true, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 277, "prompt": "Kawasiro Nitori is excellent in engineering. Thus she has been appointed to help maintain trains.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment, starting with no trains and then adding or removing one each day over m days. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance in each day.\n\nOn a day a train is removed, it is not counted as in maintenance. The challenge is to manage the cyclical work and maintenance periods effectively for multiple trains over several days.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.", "examples": "\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 144}
