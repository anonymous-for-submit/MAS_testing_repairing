{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "repair_prompt": ["Chanek and Indiana require your assistance in creating an effective algorithm to manage multiple requests while simulating the treasure hunt process in real time. It is crucial that your solution performs optimally. Your solution must be able to handle complex scenarios efficiently. Additionally, it must be scalable for a variety of input sizes and conditions.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Chanek and Indiana require your assistance in creating an effective algorithm to manage multiple requests while simulating the treasure hunt process in real time. It is crucial that your solution performs optimally. Your solution must be capable of efficiently handling complex scenarios. This means it should work well even when dealing with complicated situations. Additionally, it must be scalable for a variety of input sizes and conditions.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Chanek and Indiana require your assistance in creating an effective algorithm to manage multiple requests while simulating the treasure hunt process in real time. Your solution must perform optimally, handling complex scenarios efficiently and being scalable for a variety of input sizes and conditions.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            queries.append((query_type, room, new_rate))\n            index += 3\n        else:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            queries.append((query_type, start, end))\n            index += 3\n    \n    def calculate_energy(start, end):\n        # Use BFS to find the path from start to end\n        parent = [-1] * n\n        queue = deque([start])\n        parent[start] = start\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if parent[neighbor] == -1:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        # Backtrack to find the path\n        path = []\n        current = end\n        while current != start:\n            path.append(current)\n            current = parent[current]\n        path.append(start)\n        path.reverse()\n        \n        # Calculate the energy for the path\n        total_energy = 0\n        for i in range(len(path) - 1):\n            u = path[i]\n            v = path[i + 1]\n            energy = max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n            total_energy += energy\n        \n        return total_energy\n    \n    results = []\n    for query in queries:\n        if query[0] == 1:\n            _, room, new_rate = query\n            illusion_rates[\nmain()", "completions": ["import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    \n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            queries.append((query_type, room, new_rate))\n            index += 3\n        else:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            queries.append((query_type, start, end))\n            index += 3\n    \n    def bfs_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    results = []\n    \n    for query in queries:\n        if query[0] == 1:\n            _, room, new_rate = query\n            illusion_rates[room] = new_rate\n        else:\n            _, start, end = query\n            path = bfs_path(start, end)\n            energy = 0\n            for i in range(len(path) - 1):\n                a_i = illusion_rates[path[i]]\n                a_j = illusion_rates[path[i + 1]]\n                energy += max(abs(a_i + a_j), abs(a_i - a_j))\n            results.append(energy)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of rooms and queries\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read initial illusion rates\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read tree structure\n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    # Function to find path using BFS\n    def find_path(start, end):\n        parent = [-1] * n\n        queue = deque([start])\n        visited = set([start])\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        # Reconstruct path from end to start\n        path = []\n        while end != -1:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            illusion_rates[room] = new_rate\n            index += 3\n        elif query_type == 2:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            path = find_path(start, end)\n            energy = 0\n            for i in range(len(path) - 1):\n                u = path[i]\n                v = path[i + 1]\n                energy += max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n            results.append(energy)\n            index += 3\n    \n    # Output results for type 2 queries\n    for result in results:\n        print(result)\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef calculate_energy(a, b):\n    return max(abs(a + b), abs(a - b))\n\ndef find_path_energy(start, end, illusion_rates, adj_list):\n    # Use BFS to find the path from start to end\n    queue = deque([(start, 0)])\n    visited = set()\n    parent = {start: None}\n    \n    while queue:\n        current, energy = queue.popleft()\n        if current == end:\n            break\n        visited.add(current)\n        \n        for neighbor in adj_list[current]:\n            if neighbor not in visited:\n                parent[neighbor] = current\n                queue.append((neighbor, energy))\n    \n    # Calculate the energy required for the path\n    path_energy = 0\n    current = end\n    while parent[current] is not None:\n        prev = parent[current]\n        path_energy += calculate_energy(illusion_rates[current - 1], illusion_rates[prev - 1])\n        current = prev\n    \n    return path_energy\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    adj_list = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        adj_list[s].append(t)\n        adj_list[t].append(s)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1])\n            new_rate = int(data[index + 2])\n            index += 3\n            illusion_rates[room - 1] = new_rate\n        elif query_type == 2:\n            start = int(data[index + 1])\n            end = int(data[index + 2])\n            index += 3\n            energy = find_path_energy(start, end, illusion_rates, adj_list)\n            results.append(energy)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    \n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1]) - 1\n        v = int(data[index + 2]) - 1\n        queries.append((query_type, u, v))\n        index += 3\n    \n    def bfs_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    results = []\n    \n    for query_type, u, v in queries:\n        if query_type == 1:\n            # Update illusion rate\n            illusion_rates[u] = v\n        elif query_type == 2:\n            # Calculate energy\n            path = bfs_path(u, v)\n            total_energy = 0\n            for i in range(len(path) - 1):\n                a = illusion_rates[path[i]]\n                b = illusion_rates[path[i + 1]]\n                energy = max(abs(a + b), abs(a - b))\n                total_energy += energy\n            results.append(total_energy)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        index += 1\n        t = int(data[index]) - 1\n        index += 1\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        x = int(data[index]) - 1\n        index += 1\n        y = int(data[index])\n        index += 1\n        queries.append((query_type, x, y))\n    \n    return n, q, illusion_rates, tree, queries\n\ndef update_illusion_rate(illusion_rates, room, new_rate):\n    illusion_rates[room] = new_rate\n\ndef calculate_energy(illusion_rates, tree, start, end):\n    # BFS to find the path from start to end\n    queue = deque([(start, -1)])\n    parent = {start: None}\n    \n    while queue:\n        current, prev = queue.popleft()\n        parent[current] = prev\n        if current == end:\n            break\n        for neighbor in tree[current]:\n            if neighbor != prev:\n                queue.append((neighbor, current))\n    \n    # Calculate energy along the path\n    energy = 0\n    current = end\n    while parent[current] is not None:\n        prev = parent[current]\n        a = illusion_rates[current]\n        b = illusion_rates[prev]\n        energy += max(abs(a + b), abs(a - b))\n        current = prev\n    \n    return energy\n\ndef main():\n    n, q, illusion_rates, tree, queries = parse_input()\n    \n    results = []\n    for query_type, x, y in queries:\n        if query_type == 1:\n            update_illusion_rate(illusion_rates, x, y)\n        elif query_type == 2:\n            energy = calculate_energy(illusion_rates, tree, x, y - 1)\n            results.append(energy)\n    \n    for result in results\nmain()", "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of rooms and queries\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read initial illusion rates\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read tree structure\n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    # Prepare queries\n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            queries.append((query_type, room, new_rate))\n            index += 3\n        elif query_type == 2:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            queries.append((query_type, start, end))\n            index += 3\n    \n    # Function to find path using BFS\n    def find_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    # Process queries\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            # Update illusion rate\n            room, new_rate = query[1], query[2]\n            illusion_rates[room] = new_rate\n        elif query[0] == 2:\n            # Calculate minimum energy\n            start, end = query[1], query[2]\n            path = find_path(start, end)\n            energy_sum = 0\n            for i in range(len(path) - 1\nmain()", "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    \n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1]) - 1\n        v = int(data[index + 2])\n        if query_type == 1:\n            queries.append((query_type, u, v))\n        else:\n            queries.append((query_type, u, v - 1))\n        index += 3\n    \n    def bfs_find_path(start, end):\n        parent = [-1] * n\n        queue = deque([start])\n        parent[start] = start\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if parent[neighbor] == -1:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        current = end\n        while current != start:\n            path.append(current)\n            current = parent[current]\n        path.append(start)\n        path.reverse()\n        return path\n    \n    results = []\n    \n    for query in queries:\n        if query[0] == 1:\n            _, room, new_rate = query\n            illusion_rates[room] = new_rate\n        elif query[0] == 2:\n            _, start, end = query\n            path = bfs_find_path(start, end)\n            total_energy = 0\n            for i in range(len(path) - 1):\n                u = path[i]\n                v = path[i + 1]\n                energy = max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n                total_energy += energy\n            results.append(total_energy)\n    \n    for result in results:\n        print(result)\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        index += 1\n        t = int(data[index]) - 1\n        index += 1\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index])\n        index += 1\n        queries.append((query_type, u, v))\n    \n    return n, q, illusion_rates, tree, queries\n\ndef bfs_path(tree, start, end):\n    queue = deque([start])\n    parent = {start: None}\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            break\n        for neighbor in tree[node]:\n            if neighbor not in parent:\n                parent[neighbor] = node\n                queue.append(neighbor)\n    \n    path = []\n    while end is not None:\n        path.append(end)\n        end = parent[end]\n    \n    return path[::-1]\n\ndef calculate_energy(illusion_rates, path):\n    energy = 0\n    for i in range(len(path) - 1):\n        u = path[i]\n        v = path[i + 1]\n        energy += max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n    return energy\n\ndef main():\n    n, q, illusion_rates, tree, queries = parse_input()\n    \n    for query_type, u, v in queries:\n        if query_type == 1:\n            # Update illusion rate\n            illusion_rates[u] = v\n        elif query_type == 2:\n            # Calculate minimum energy\n            path = bfs_path(tree, u, v - 1)\n            energy = calculate_energy(illusion_rates, path)\n            print(energy)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Build the tree\n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    # Preprocess to find parent and depth using BFS\n    parent = [-1] * n\n    depth = [0] * n\n    queue = deque([0])\n    visited = [False] * n\n    visited[0] = True\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in tree[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                parent[neighbor] = node\n                depth[neighbor] = depth[node] + 1\n                queue.append(neighbor)\n    \n    def lca(u, v):\n        # Bring both nodes to the same depth\n        while depth[u] > depth[v]:\n            u = parent[u]\n        while depth[v] > depth[u]:\n            v = parent[v]\n        \n        # Find the common ancestor\n        while u != v:\n            u = parent[u]\n            v = parent[v]\n        \n        return u\n    \n    def calculate_energy(u, v):\n        common_ancestor = lca(u, v)\n        total_energy = 0\n        \n        # Calculate energy from u to LCA\n        while u != common_ancestor:\n            total_energy += max(abs(illusion_rates[u] + illusion_rates[parent[u]]), abs(illusion_rates[u] - illusion_rates[parent[u]]))\n            u = parent[u]\n        \n        # Calculate energy from v to LCA\n        while v != common_ancestor:\n            total_energy += max(abs(illusion_rates[v] + illusion_rates[parent[v]]), abs(illusion_rates[v] - illusion_rates[parent[v]]))\n            v = parent[v]\n        \n        return total_energy\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room\nmain()", "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            queries.append((query_type, room, new_rate))\n            index += 3\n        else:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            queries.append((query_type, start, end))\n            index += 3\n    \n    def calculate_energy(start, end):\n        # Use BFS to find the path from start to end\n        parent = [-1] * n\n        queue = deque([start])\n        parent[start] = start\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if parent[neighbor] == -1:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        # Backtrack to find the path\n        path = []\n        current = end\n        while current != start:\n            path.append(current)\n            current = parent[current]\n        path.append(start)\n        path.reverse()\n        \n        # Calculate the energy for the path\n        total_energy = 0\n        for i in range(len(path) - 1):\n            u = path[i]\n            v = path[i + 1]\n            energy = max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n            total_energy += energy\n        \n        return total_energy\n    \n    results = []\n    for query in queries:\n        if query[0] == 1:\n            _, room, new_rate = query\n            illusion_rates[\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure of the maze.\",\n      \"steps\": [\n        \"Read the first line to get integers n and q.\",\n        \"Read the second line to get the list of initial illusion rates for each room.\",\n        \"Read the next n-1 lines to construct the tree structure using adjacency list representation.\"\n      ]\n    },\n    {\n      \"description\": \"Implement a mechanism to handle queries efficiently.\",\n      \"steps\": [\n        \"Identify the type of each query (type 1 or type 2).\",\n        \"For type 1 queries, update the illusion rate of the specified room.\",\n        \"For type 2 queries, calculate the minimum sum of energy required for the specified path.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the energy required for a path in the tree.\",\n      \"steps\": [\n        \"Use a tree traversal algorithm (e.g., DFS) to find the path between two rooms.\",\n        \"For each edge in the path, calculate the energy using the formula: max(|a_i + a_j|, |a_i - a_j|).\",\n        \"Sum the energy values for all edges in the path.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data structures: number of rooms, queries, illusion rates, and tree structure.\",\n    \"Implement a function to update the illusion rate of a room for type 1 queries.\",\n    \"Implement a function to calculate the energy required for a path for type 2 queries using tree traversal.\",\n    \"For each query, determine its type and execute the corresponding function.\",\n    \"Output the results for type 2 queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree structure'\n    Explanation: The maze is represented as a tree, which is a connected acyclic graph. This means there is exactly one path between any two rooms.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy calculation when moving between rooms.\n\n    'query types'\n    Explanation: There are two types of queries: type 1 updates the illusion rate of a room, and type 2 calculates the energy required to move between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_i + a_j|, |a_i - a_j|)': This phrase indicates that for each edge in the path, the energy is calculated as the maximum of the absolute sum and the absolute difference of the illusion rates of the connected rooms. In code, this can be implemented using the `max` function: `max(abs(a_i + a_j), abs(a_i - a_j))`.\n\n# [degree adverb]\n    'minimum sum': This indicates that for type 2 queries, the goal is to calculate the total energy required for a path, which is the sum of the maximum energy values for each edge in the path.\n\n# [code logic]\n    The steps for handling type 2 queries should be implemented simultaneously:\n    - \"Use a tree traversal algorithm (e.g., DFS) to find the path between two rooms.\"\n    - \"For each edge in the path, calculate the energy using the formula: max(|a_i + a_j|, |a_i - a_j|).\"\n    - \"Sum the energy values for all edges in the path.\"\n    These steps can be combined into a single function that performs the traversal and energy calculation in one go.\n\n# [edge case]\n    1. Input: 2 1\n       0 0\n       1 2\n       2 1 2\n       Output: 0\n       Explanation: The illusion rates are both zero, so the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    2. Input: 3 1\n       1 1 1\n       1 2\n       2 3\n       2 1 3\n       Output: 2\n       Explanation: The path is 1 \u2192 2 \u2192 3, with energy calculations max(|1 + 1|, |1 - 1|", "Round_0": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            queries.append((query_type, room, new_rate))\n            index += 3\n        else:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            queries.append((query_type, start, end))\n            index += 3\n    \n    def calculate_energy(start, end):\n        # Use BFS to find the path from start to end\n        parent = [-1] * n\n        queue = deque([start])\n        parent[start] = start\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if parent[neighbor] == -1:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        # Backtrack to find the path\n        path = []\n        current = end\n        while current != start:\n            path.append(current)\n            current = parent[current]\n        path.append(start)\n        path.reverse()\n        \n        # Calculate the energy for the path\n        total_energy = 0\n        for i in range(len(path) - 1):\n            u = path[i]\n            v = path[i + 1]\n            energy = max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n            total_energy += energy\n        \n        return total_energy\n    \n    results = []\n    for query in queries:\n        if query[0] == 1:\n            _, room, new_rate = query\n            illusion_rates[", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 74)"}, "Round_1": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            queries.append((query_type, room, new_rate))\n            index += 3\n        else:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            queries.append((query_type, start, end))\n            index += 3\n    \n    def calculate_energy(start, end):\n        # Use BFS to find the path from start to end\n        parent = [-1] * n\n        queue = deque([start])\n        parent[start] = start\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if parent[neighbor] == -1:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        # Backtrack to find the path\n        path = []\n        current = end\n        while current != start:\n            path.append(current)\n            current = parent[current]\n        path.append(start)\n        path.reverse()\n        \n        # Calculate the energy for the path\n        total_energy = 0\n        for i in range(len(path) - 1):\n            u = path[i]\n            v = path[i + 1]\n            energy = max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n            total_energy += energy\n        \n        return total_energy\n    \n    results = []\n    for query in queries:\n        if query[0] == 1:\n            _, room, new_rate = query\n            illusion_rates["}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, tunnel connections, and queries.\",\n      \"details\": [\n        \"Read the first line to get integers n (number of rooms) and q (number of queries).\",\n        \"Read the second line to get the list of n integers representing the initial illusion rates of each room.\",\n        \"Read the next n-1 lines to get pairs of integers representing tunnel connections between rooms.\",\n        \"Read the next q lines to get the queries, which can be either type 1 (update illusion rate) or type 2 (calculate energy).\"\n      ]\n    },\n    {\n      \"description\": \"Represent the maze as a tree structure using the tunnel connections.\",\n      \"details\": [\n        \"Use adjacency list or other suitable data structure to represent the tree formed by the rooms and tunnels.\"\n      ]\n    },\n    {\n      \"description\": \"Implement query handling logic.\",\n      \"details\": [\n        \"For type 1 queries, update the illusion rate of the specified room.\",\n        \"For type 2 queries, calculate the minimum sum of energy required to move from the start room to the end room.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate energy for type 2 queries.\",\n      \"details\": [\n        \"Find the path from the start room to the end room using tree traversal (e.g., DFS or BFS).\",\n        \"For each tunnel in the path, calculate the energy using the formula: max(|a_i + a_j|, |a_i - a_j|), where a_i and a_j are the illusion rates of the connected rooms.\",\n        \"Sum the energy values for all tunnels in the path.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Construct the tree representation of the maze using the tunnel connections.\",\n    \"Implement a function to handle type 1 queries to update room illusion rates.\",\n    \"Implement a function to handle type 2 queries to calculate the energy required for treasure hunting.\",\n    \"For type 2 queries, traverse the tree to find the path between specified rooms and calculate the energy using the given formula.\",\n    \"Output the results for each type 2 query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A tree is a data structure consisting of nodes, where each node has zero or more child nodes, and one node is designated as the root. In this context, the rooms and tunnels form a tree structure, meaning there is a unique path between any two rooms.\n    'illusion rate': This refers to the integer value associated with each room, which affects the energy calculation when moving between rooms.\n\n# [phrase showing quantity relationship]\n    'minimum sum of energy': This means calculating the least amount of energy required to move from one room to another, considering the illusion rates of the rooms involved.\n    Implementation: For each tunnel in the path, calculate the energy using the formula: `max(|a_i + a_j|, |a_i - a_j|)`, where `a_i` and `a_j` are the illusion rates of the connected rooms.\n\n# [degree adverb]\n    'minimum': This indicates that the goal is to find the smallest possible sum of energy required for the movement.\n    Implementation: Ensure that the energy calculation for each path is summed correctly and the smallest possible sum is returned for each type 2 query.\n\n# [code logic]\n    The steps for handling type 2 queries should be implemented simultaneously:\n    - \"Find the path from the start room to the end room using tree traversal (e.g., DFS or BFS).\"\n    - \"Calculate the energy for each tunnel in the path using the formula.\"\n    These steps can be combined into a single function that traverses the tree and calculates the energy in one go.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so the energy required is `max(|0 + 0|, |0 - 0|) = 0`.\n\n    Input: 3 1\n           1 1 1\n           1 2\n           2 3\n           2 1 3\n    Expected Output: 2\n    Explanation: The path is 1 \u2192 2 \u2192 3, and the energy calculations are `max(|1 + 1|, |1 - 1|) = 2` for each tunnel, totaling 2.\n\n    Input: 4 1\n           10 -10 10 -10\n          ", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    \n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            queries.append((query_type, room, new_rate))\n            index += 3\n        else:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            queries.append((query_type, start, end))\n            index += 3\n    \n    def bfs_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    results = []\n    \n    for query in queries:\n        if query[0] == 1:\n            _, room, new_rate = query\n            illusion_rates[room] = new_rate\n        else:\n            _, start, end = query\n            path = bfs_path(start, end)\n            energy = 0\n            for i in range(len(path) - 1):\n                a_i = illusion_rates[path[i]]\n                a_j = illusion_rates[path[i + 1]]\n                energy += max(abs(a_i + a_j), abs(a_i - a_j))\n            results.append(energy)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure of the maze.\",\n      \"details\": \"Read the input values and store them in appropriate data structures. The tree structure can be represented using adjacency lists.\"\n    },\n    {\n      \"description\": \"Implement a function to handle type 1 queries, which update the illusion rate of a specified room.\",\n      \"details\": \"Modify the illusion rate of the specified room in the data structure storing the illusion rates.\"\n    },\n    {\n      \"description\": \"Implement a function to handle type 2 queries, which calculate the minimum energy required to move from one room to another.\",\n      \"details\": \"Use a tree traversal algorithm (e.g., DFS or BFS) to find the path between the specified rooms and calculate the energy required based on the illusion rates of the rooms along the path.\"\n    },\n    {\n      \"description\": \"Optimize the solution to handle large input sizes efficiently.\",\n      \"details\": \"Consider using data structures and algorithms that allow for efficient updates and queries, such as segment trees or binary indexed trees.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure.\",\n    \"Initialize data structures to store the illusion rates and the tree structure.\",\n    \"For each query, determine its type:\",\n    \"  - If it is a type 1 query, update the illusion rate of the specified room.\",\n    \"  - If it is a type 2 query, calculate the minimum energy required to move from the start room to the end room using a tree traversal algorithm.\",\n    \"Output the result for each type 2 query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a numerical value associated with each room, which affects the energy calculation when moving between rooms.\n\n    'tree structure'\n    Explanation: The rooms and tunnels form a tree structure, meaning there is a unique path between any two rooms.\n\n# [phrase showing quantity relationship]\n    'minimum sum of energy'\n    Explanation: For type 2 queries, the task is to calculate the minimum energy required to move from one room to another, considering the illusion rates along the path.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The requirement is to find the least amount of energy needed for the movement between rooms, which involves calculating the energy for each segment of the path and summing them up.\n\n# [code logic]\n    The steps for handling type 2 queries should be implemented simultaneously:\n    \"Use a tree traversal algorithm (e.g., DFS or BFS) to find the path between the specified rooms and calculate the energy required based on the illusion rates of the rooms along the path.\"\n    This involves traversing the tree to find the path and calculating the energy in one code block.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so the energy required is 0.\n\n    Input: 3 1\n           1 1 1\n           1 2\n           2 3\n           2 1 3\n    Expected Output: 2\n    Explanation: The path is 1 \u2192 2 \u2192 3, and the energy required is max(|1 + 1|, |1 - 1|) + max(|1 + 1|, |1 - 1|) = 2.\n\n    Input: 4 1\n           5 -5 5 -5\n           1 2\n           2 3\n           3 4\n           2 1 4\n    Expected Output: 20\n    Explanation: The path is 1 \u2192 2 \u2192 3 \u2192 4, and the energy required is max(|5 + (-5)|, |5 - (-5)|) + max(|-5 + 5|, |-5 - 5|) + max(|5 + (-5)|, |", "Round_0": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of rooms and queries\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read initial illusion rates\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read tree structure\n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    # Function to find path using BFS\n    def find_path(start, end):\n        parent = [-1] * n\n        queue = deque([start])\n        visited = set([start])\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        # Reconstruct path from end to start\n        path = []\n        while end != -1:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            illusion_rates[room] = new_rate\n            index += 3\n        elif query_type == 2:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            path = find_path(start, end)\n            energy = 0\n            for i in range(len(path) - 1):\n                u = path[i]\n                v = path[i + 1]\n                energy += max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n            results.append(energy)\n            index += 3\n    \n    # Output results for type 2 queries\n    for result in results:\n        print(result)", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 155)"}, "Round_1": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of rooms and queries\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read initial illusion rates\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read tree structure\n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    # Function to find path using BFS\n    def find_path(start, end):\n        parent = [-1] * n\n        queue = deque([start])\n        visited = set([start])\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        # Reconstruct path from end to start\n        path = []\n        while end != -1:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            illusion_rates[room] = new_rate\n            index += 3\n        elif query_type == 2:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            path = find_path(start, end)\n            energy = 0\n            for i in range(len(path) - 1):\n                u = path[i]\n                v = path[i + 1]\n                energy += max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n            results.append(energy)\n            index += 3\n    \n    # Output results for type 2 queries\n    for result in results:\n        print(result)"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure of the maze.\",\n      \"details\": \"Read the input values and store them in appropriate data structures. Use an adjacency list to represent the tree.\"\n    },\n    {\n      \"description\": \"Implement a function to calculate the energy required to move between two rooms.\",\n      \"details\": \"For a given path, calculate the energy using the formula max(|a + b|, |a - b|) for each pair of connected rooms.\"\n    },\n    {\n      \"description\": \"Handle type 1 queries to update the illusion rate of a specific room.\",\n      \"details\": \"Modify the illusion rate of the specified room in the data structure.\"\n    },\n    {\n      \"description\": \"Handle type 2 queries to calculate the minimum energy required to move between two rooms.\",\n      \"details\": \"Use a tree traversal algorithm (e.g., DFS or BFS) to find the path between the two rooms and calculate the total energy using the energy calculation function.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure.\",\n    \"Store the tree structure using an adjacency list for efficient traversal.\",\n    \"Implement a function to calculate the energy required between two connected rooms.\",\n    \"Iterate over each query:\",\n    \"  - If the query is of type 1, update the illusion rate of the specified room.\",\n    \"  - If the query is of type 2, find the path between the specified rooms and calculate the total energy required using the energy calculation function.\",\n    \"Output the result for each type 2 query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree structure'\n    Explanation: The maze is represented as a tree, which is a connected acyclic graph. This means there is exactly one path between any two rooms.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy calculation when moving between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a + b|, |a - b|), where a and b are the illusion rates of the connected rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a + b|, |a - b|)': This phrase indicates that for each pair of connected rooms, the energy required is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented as:\n    ```python\n    energy = max(abs(a + b), abs(a - b))\n    ```\n\n# [degree adverb] \n    'minimum sum of energy': This means that for type 2 queries, we need to calculate the total energy required to move from one room to another and ensure it is the smallest possible value. This involves finding the correct path in the tree and summing the energy calculations for each step.\n\n# [code logic]\n    The steps for handling type 2 queries should be implemented simultaneously:\n    - Use a tree traversal algorithm to find the path between the specified rooms.\n    - Calculate the total energy required using the energy calculation function for each step in the path.\n    This can be done in a single function that performs the traversal and energy calculation together.\n\n# [edge case] \n    1. Input: 2 1\n       0 0\n       1 2\n       2 1 2\n       Output: 0\n       Explanation: Both rooms have an illusion rate of 0, so the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    2. Input: 3 2\n       1 1 1\n       1 2\n       2 3\n       2 1 3\n       Output: 2\n       Explanation: The path is 1 \u2192 2 \u2192 3. Energy calculations are max(|1 + 1|, |1 - 1|) = 2 for both steps, totaling 2.\n\n    3. Input: 4", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef calculate_energy(a, b):\n    return max(abs(a + b), abs(a - b))\n\ndef find_path_energy(start, end, illusion_rates, adj_list):\n    # Use BFS to find the path from start to end\n    queue = deque([(start, 0)])\n    visited = set()\n    parent = {start: None}\n    \n    while queue:\n        current, energy = queue.popleft()\n        if current == end:\n            break\n        visited.add(current)\n        \n        for neighbor in adj_list[current]:\n            if neighbor not in visited:\n                parent[neighbor] = current\n                queue.append((neighbor, energy))\n    \n    # Calculate the energy required for the path\n    path_energy = 0\n    current = end\n    while parent[current] is not None:\n        prev = parent[current]\n        path_energy += calculate_energy(illusion_rates[current - 1], illusion_rates[prev - 1])\n        current = prev\n    \n    return path_energy\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    adj_list = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        adj_list[s].append(t)\n        adj_list[t].append(s)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1])\n            new_rate = int(data[index + 2])\n            index += 3\n            illusion_rates[room - 1] = new_rate\n        elif query_type == 2:\n            start = int(data[index + 1])\n            end = int(data[index + 2])\n            index += 3\n            energy = find_path_energy(start, end, illusion_rates, adj_list)\n            results.append(energy)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"name\": \"Parse Input\",\n      \"description\": \"Read and parse the input data to extract the number of rooms, number of queries, initial illusion rates, tunnel connections, and queries.\"\n    },\n    {\n      \"name\": \"Build Tree Structure\",\n      \"description\": \"Construct a tree data structure using the room connections provided. This will help in navigating between rooms efficiently.\"\n    },\n    {\n      \"name\": \"Handle Queries\",\n      \"description\": \"Implement logic to process each query. There are two types of queries: updating the illusion rate of a room and calculating the minimum energy required to move between two rooms.\"\n    },\n    {\n      \"name\": \"Calculate Energy\",\n      \"description\": \"For type 2 queries, calculate the energy required to move from one room to another using the given formula. This involves traversing the tree and summing up the energy costs.\"\n    },\n    {\n      \"name\": \"Update Illusion Rate\",\n      \"description\": \"For type 1 queries, update the illusion rate of the specified room.\"\n    },\n    {\n      \"name\": \"Output Results\",\n      \"description\": \"Output the results for each type 2 query as specified.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, tunnel connections, and queries.\",\n    \"Construct a tree data structure using the room connections.\",\n    \"Iterate over each query and determine its type.\",\n    \"For type 1 queries, update the illusion rate of the specified room.\",\n    \"For type 2 queries, traverse the tree from the start room to the end room, calculating the energy required using the given formula.\",\n    \"Store the result for each type 2 query.\",\n    \"Output the results for all type 2 queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are no cycles, and there is exactly one path between any two rooms. This is crucial for efficiently navigating and calculating paths.\n\n    'illusion rate'\n    Explanation: Each room has an initial illusion rate, which affects the energy calculation when moving between rooms.\n\n    'query'\n    Explanation: There are two types of queries: one updates the illusion rate of a room, and the other calculates the energy required to move between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a + b|, |a - b|)'\n    Explanation: This phrase describes the energy calculation formula when moving between two connected rooms. It means you take the maximum of the absolute sum and the absolute difference of the illusion rates of the two rooms.\n    Implementation: `energy = max(abs(a + b), abs(a - b))`\n\n# [degree adverb] \n    'minimum'\n    Explanation: For type 2 queries, the task is to calculate the minimum sum of energy needed to move from one room to another.\n    Implementation: This involves calculating the energy for each segment of the path and summing them up.\n\n# [code logic]\n    The steps \"Update Illusion Rate\" and \"Calculate Energy\" should be considered simultaneously when processing queries. Depending on the query type, either update the illusion rate or calculate the energy, but both operations are part of handling queries.\n\n# [edge case] \n    1. Input: 2 1\n       0 0\n       1 2\n       2 1 2\n       Expected Output: 0\n       Explanation: With both rooms having an illusion rate of 0, the energy required is 0.\n\n    2. Input: 3 2\n       1 1 1\n       1 2\n       2 3\n       2 1 3\n       1 1 0\n       2 1 3\n       Expected Output: 2, 1\n       Explanation: Initially, the energy from 1 to 3 is 2. After updating room 1's illusion rate to 0, the energy becomes 1.\n\n    3. Input: 4 1\n       5 -5 5 -5\n       1 2\n       2 3\n       3 4\n       2 1 4\n", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    \n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1]) - 1\n        v = int(data[index + 2]) - 1\n        queries.append((query_type, u, v))\n        index += 3\n    \n    def bfs_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    results = []\n    \n    for query_type, u, v in queries:\n        if query_type == 1:\n            # Update illusion rate\n            illusion_rates[u] = v\n        elif query_type == 2:\n            # Calculate energy\n            path = bfs_path(u, v)\n            total_energy = 0\n            for i in range(len(path) - 1):\n                a = illusion_rates[path[i]]\n                b = illusion_rates[path[i + 1]]\n                energy = max(abs(a + b), abs(a - b))\n                total_energy += energy\n            results.append(total_energy)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 155)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    \n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1]) - 1\n        v = int(data[index + 2]) - 1\n        queries.append((query_type, u, v))\n        index += 3\n    \n    def bfs_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    results = []\n    \n    for query_type, u, v in queries:\n        if query_type == 1:\n            # Update illusion rate\n            illusion_rates[u] = v\n        elif query_type == 2:\n            # Calculate energy\n            path = bfs_path(u, v)\n            total_energy = 0\n            for i in range(len(path) - 1):\n                a = illusion_rates[path[i]]\n                b = illusion_rates[path[i + 1]]\n                energy = max(abs(a + b), abs(a - b))\n                total_energy += energy\n            results.append(total_energy)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure of the maze.\",\n      \"details\": \"Read the input values and store them in appropriate data structures. The tree can be represented using adjacency lists.\"\n    },\n    {\n      \"description\": \"Implement a function to handle type 1 queries which update the illusion rate of a specific room.\",\n      \"details\": \"Modify the illusion rate of the specified room in the data structure.\"\n    },\n    {\n      \"description\": \"Implement a function to handle type 2 queries which calculate the minimum energy required to move from one room to another.\",\n      \"details\": \"Use a tree traversal algorithm (e.g., DFS or BFS) to find the path between the specified rooms and calculate the energy required for each segment of the path.\"\n    },\n    {\n      \"description\": \"Optimize the energy calculation for type 2 queries to ensure scalability for large input sizes.\",\n      \"details\": \"Consider precomputing necessary values or using efficient data structures to minimize repeated calculations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure.\",\n    \"Initialize data structures to represent the maze and store illusion rates.\",\n    \"For each query, determine its type:\",\n    \"  - If type 1, update the illusion rate of the specified room.\",\n    \"  - If type 2, calculate the minimum energy required to move from the start room to the end room using the current illusion rates.\",\n    \"Output the result for each type 2 query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree structure'\n    Explanation: The maze is represented as a tree, meaning there are no cycles, and each room is connected in a hierarchical manner. This structure is crucial for efficiently traversing and calculating paths between rooms.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy calculation when moving between rooms. The illusion rate can be positive or negative, and it changes the energy required to traverse from one room to another.\n\n# [phrase showing quantity relationship]\n    'minimum sum of energy'\n    Explanation: For type 2 queries, the task is to calculate the least amount of energy required to move from one room to another, considering the illusion rates. This involves finding the path and calculating the energy using the given formula.\n\n    'max(|a + b|, |a - b|)'\n    Explanation: This formula is used to calculate the energy required to move between two rooms. It takes the maximum of the absolute sum and the absolute difference of the illusion rates of the two rooms.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The requirement is to find the smallest possible energy sum needed for the movement between rooms in type 2 queries. This involves calculating the energy for each segment of the path and summing them up.\n\n# [code logic]\n    The steps for handling type 2 queries should be implemented simultaneously:\n    \"Use a tree traversal algorithm (e.g., DFS or BFS) to find the path between the specified rooms and calculate the energy required for each segment of the path.\"\n    This can be done in a single function that traverses the tree and calculates the energy in one go.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so the energy required to move between them is 0.\n\n    Input: 3 1\n           1 -1 0\n           1 2\n           2 3\n           2 1 3\n    Expected Output: 2\n    Explanation: The path is 1 \u2192 2 \u2192 3, with energy calculations max(|1 + (-1)|, |1 - (-1)|) = 2 and max(|-1 + 0|, |-1 - 0|) = 1, totaling 2.\n\n", "Round_0": {"code": "def parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        index += 1\n        t = int(data[index]) - 1\n        index += 1\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        x = int(data[index]) - 1\n        index += 1\n        y = int(data[index])\n        index += 1\n        queries.append((query_type, x, y))\n    \n    return n, q, illusion_rates, tree, queries\n\ndef update_illusion_rate(illusion_rates, room, new_rate):\n    illusion_rates[room] = new_rate\n\ndef calculate_energy(illusion_rates, tree, start, end):\n    # BFS to find the path from start to end\n    queue = deque([(start, -1)])\n    parent = {start: None}\n    \n    while queue:\n        current, prev = queue.popleft()\n        parent[current] = prev\n        if current == end:\n            break\n        for neighbor in tree[current]:\n            if neighbor != prev:\n                queue.append((neighbor, current))\n    \n    # Calculate energy along the path\n    energy = 0\n    current = end\n    while parent[current] is not None:\n        prev = parent[current]\n        a = illusion_rates[current]\n        b = illusion_rates[prev]\n        energy += max(abs(a + b), abs(a - b))\n        current = prev\n    \n    return energy\n\ndef main():\n    n, q, illusion_rates, tree, queries = parse_input()\n    \n    results = []\n    for query_type, x, y in queries:\n        if query_type == 1:\n            update_illusion_rate(illusion_rates, x, y)\n        elif query_type == 2:\n            energy = calculate_energy(illusion_rates, tree, x, y - 1)\n            results.append(energy)\n    \n    for result in results", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 75)"}, "Round_1": {"code": "def parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        index += 1\n        t = int(data[index]) - 1\n        index += 1\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        x = int(data[index]) - 1\n        index += 1\n        y = int(data[index])\n        index += 1\n        queries.append((query_type, x, y))\n    \n    return n, q, illusion_rates, tree, queries\n\ndef update_illusion_rate(illusion_rates, room, new_rate):\n    illusion_rates[room] = new_rate\n\ndef calculate_energy(illusion_rates, tree, start, end):\n    # BFS to find the path from start to end\n    queue = deque([(start, -1)])\n    parent = {start: None}\n    \n    while queue:\n        current, prev = queue.popleft()\n        parent[current] = prev\n        if current == end:\n            break\n        for neighbor in tree[current]:\n            if neighbor != prev:\n                queue.append((neighbor, current))\n    \n    # Calculate energy along the path\n    energy = 0\n    current = end\n    while parent[current] is not None:\n        prev = parent[current]\n        a = illusion_rates[current]\n        b = illusion_rates[prev]\n        energy += max(abs(a + b), abs(a - b))\n        current = prev\n    \n    return energy\n\ndef main():\n    n, q, illusion_rates, tree, queries = parse_input()\n    \n    results = []\n    for query_type, x, y in queries:\n        if query_type == 1:\n            update_illusion_rate(illusion_rates, x, y)\n        elif query_type == 2:\n            energy = calculate_energy(illusion_rates, tree, x, y - 1)\n            results.append(energy)\n    \n    for result in results"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure of the maze.\",\n      \"steps\": [\n        \"Read the first line to get the number of rooms (n) and the number of queries (q).\",\n        \"Read the second line to get the initial illusion rates for each room.\",\n        \"Read the next n-1 lines to construct the tree structure using the room connections.\",\n        \"Read the next q lines to get the queries.\"\n      ]\n    },\n    {\n      \"description\": \"Implement a mechanism to update the illusion rate of a room based on type 1 queries.\",\n      \"steps\": [\n        \"For each type 1 query, update the illusion rate of the specified room.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum sum of energy required for type 2 queries.\",\n      \"steps\": [\n        \"For each type 2 query, determine the path between the specified rooms using the tree structure.\",\n        \"Calculate the energy required for each segment of the path using the formula: max(|a_i + a_j|, |a_i - a_j|).\",\n        \"Sum the energy values for the entire path and store the result.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each type 2 query.\",\n      \"steps\": [\n        \"For each type 2 query, output the calculated minimum sum of energy.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data including rooms, queries, illusion rates, and tree structure.\",\n    \"Implement a function to handle type 1 queries that update the illusion rate of a room.\",\n    \"Implement a function to handle type 2 queries that calculate the minimum energy required to traverse between two rooms.\",\n    \"Use a tree traversal algorithm to determine the path between rooms for type 2 queries.\",\n    \"Calculate the energy required for each path segment and sum them to get the total energy for the path.\",\n    \"Output the results for each type 2 query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree structure'\n    Explanation: The rooms and tunnels form a tree structure, meaning there is a unique path between any two rooms. This is crucial for determining the path for type 2 queries.\n\n    'illusion rate'\n    Explanation: Each room has an initial illusion rate which can be updated by type 1 queries. This rate affects the energy calculation for moving between rooms.\n\n# [phrase showing quantity relationship]\n    'minimum sum of energy'\n    Explanation: For type 2 queries, the task is to calculate the minimum sum of energy required to move from one room to another. This involves calculating the energy for each segment of the path using the formula: max(|a_i + a_j|, |a_i - a_j|).\n\n# [degree adverb]\n    'minimum'\n    Explanation: The requirement specifies calculating the minimum sum of energy needed for the path. This means using the formula provided to ensure the least energy is calculated for each segment.\n\n# [code logic]\n    The steps for handling type 2 queries should be implemented simultaneously:\n    \"Determine the path between the specified rooms using the tree structure\",\n    \"Calculate the energy required for each segment of the path using the formula: max(|a_i + a_j|, |a_i - a_j|)\",\n    \"Sum the energy values for the entire path and store the result\"\n    These can be implemented in a single function that traverses the tree, calculates energy for each segment, and accumulates the total energy.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: With both rooms having an illusion rate of 0, the energy calculation for the path results in 0.\n\n    Input: 3 2\n           1 1 1\n           1 2\n           2 3\n           2 1 3\n           1 1 -1\n           2 1 3\n    Expected Output: 2, 0\n    Explanation: Initially, the path from room 1 to room 3 requires 2 energy. After updating room 1's illusion rate to -1, the energy required becomes 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating energy using the formula max(|a_i + a_j", "Round_0": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of rooms and queries\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read initial illusion rates\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read tree structure\n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    # Prepare queries\n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            queries.append((query_type, room, new_rate))\n            index += 3\n        elif query_type == 2:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            queries.append((query_type, start, end))\n            index += 3\n    \n    # Function to find path using BFS\n    def find_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    # Process queries\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            # Update illusion rate\n            room, new_rate = query[1], query[2]\n            illusion_rates[room] = new_rate\n        elif query[0] == 2:\n            # Calculate minimum energy\n            start, end = query[1], query[2]\n            path = find_path(start, end)\n            energy_sum = 0\n            for i in range(len(path) - 1", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 73)"}, "Round_1": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of rooms and queries\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read initial illusion rates\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read tree structure\n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    # Prepare queries\n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            queries.append((query_type, room, new_rate))\n            index += 3\n        elif query_type == 2:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            queries.append((query_type, start, end))\n            index += 3\n    \n    # Function to find path using BFS\n    def find_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    # Process queries\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            # Update illusion rate\n            room, new_rate = query[1], query[2]\n            illusion_rates[room] = new_rate\n        elif query[0] == 2:\n            # Calculate minimum energy\n            start, end = query[1], query[2]\n            path = find_path(start, end)\n            energy_sum = 0\n            for i in range(len(path) - 1"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure of the maze.\",\n      \"details\": \"Read the input values and store them in appropriate data structures. The tree can be represented using adjacency lists.\"\n    },\n    {\n      \"description\": \"Implement a function to handle type 1 queries which update the illusion rate of a specific room.\",\n      \"details\": \"Modify the illusion rate of the specified room in the data structure.\"\n    },\n    {\n      \"description\": \"Implement a function to handle type 2 queries which calculate the minimum energy required to move from one room to another.\",\n      \"details\": \"Use a tree traversal algorithm (e.g., DFS) to find the path between the specified rooms and calculate the energy required using the given formula.\"\n    },\n    {\n      \"description\": \"Optimize the energy calculation for type 2 queries to ensure scalability for large input sizes.\",\n      \"details\": \"Consider precomputing necessary values or using efficient data structures to minimize repeated calculations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure.\",\n    \"Initialize data structures to store the tree and illusion rates.\",\n    \"For each query, determine its type:\",\n    \"  - If type 1, update the illusion rate of the specified room.\",\n    \"  - If type 2, calculate the minimum energy required to move between the specified rooms using tree traversal.\",\n    \"Output the result for each type 2 query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected acyclic graph. In this problem, the rooms and tunnels form a tree structure, meaning there is exactly one path between any two rooms.\n\n    'illusion rate'\n    Explanation: The illusion rate is a value associated with each room, which affects the energy calculation when moving between rooms.\n\n    'query'\n    Explanation: There are two types of queries: one updates the illusion rate of a room, and the other calculates the energy required to move between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a + b|, |a - b|)'\n    Explanation: This phrase describes the energy calculation between two connected rooms. It means you take the maximum of the absolute value of the sum and the absolute value of the difference of the illusion rates of the two rooms.\n    Implementation: `energy = max(abs(a + b), abs(a - b))`\n\n# [degree adverb] \n    'minimum'\n    Explanation: For type 2 queries, the task is to calculate the minimum sum of energy needed to move from one room to another along the path in the tree.\n    Implementation: This involves calculating the energy for each segment of the path and summing them up.\n\n# [code logic]\n    The steps for handling type 2 queries should be implemented simultaneously:\n    - Use a tree traversal algorithm to find the path between the specified rooms.\n    - Calculate the energy for each segment of the path using the given formula.\n    - Sum the energies to get the total energy required.\n\n# [edge case] \n    1. Input: 2 1\n       0 0\n       1 2\n       2 1 2\n       Output: 0\n       Explanation: Both rooms have an illusion rate of 0, so the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    2. Input: 3 1\n       1 1 1\n       1 2\n       2 3\n       2 1 3\n       Output: 2\n       Explanation: The path is 1 \u2192 2 \u2192 3. Energy for 1 \u2192 2 is max(|1 + 1|, |1 - 1|) = 2, and for 2 \u2192 3 is max(|1 + 1|, |1 - 1|) =", "Round_0": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    \n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1]) - 1\n        v = int(data[index + 2])\n        if query_type == 1:\n            queries.append((query_type, u, v))\n        else:\n            queries.append((query_type, u, v - 1))\n        index += 3\n    \n    def bfs_find_path(start, end):\n        parent = [-1] * n\n        queue = deque([start])\n        parent[start] = start\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if parent[neighbor] == -1:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        current = end\n        while current != start:\n            path.append(current)\n            current = parent[current]\n        path.append(start)\n        path.reverse()\n        return path\n    \n    results = []\n    \n    for query in queries:\n        if query[0] == 1:\n            _, room, new_rate = query\n            illusion_rates[room] = new_rate\n        elif query[0] == 2:\n            _, start, end = query\n            path = bfs_find_path(start, end)\n            total_energy = 0\n            for i in range(len(path) - 1):\n                u = path[i]\n                v = path[i + 1]\n                energy = max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n                total_energy += energy\n            results.append(total_energy)\n    \n    for result in results:\n        print(result)", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 141)"}, "Round_1": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    \n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1]) - 1\n        v = int(data[index + 2])\n        if query_type == 1:\n            queries.append((query_type, u, v))\n        else:\n            queries.append((query_type, u, v - 1))\n        index += 3\n    \n    def bfs_find_path(start, end):\n        parent = [-1] * n\n        queue = deque([start])\n        parent[start] = start\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if parent[neighbor] == -1:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        current = end\n        while current != start:\n            path.append(current)\n            current = parent[current]\n        path.append(start)\n        path.reverse()\n        return path\n    \n    results = []\n    \n    for query in queries:\n        if query[0] == 1:\n            _, room, new_rate = query\n            illusion_rates[room] = new_rate\n        elif query[0] == 2:\n            _, start, end = query\n            path = bfs_find_path(start, end)\n            total_energy = 0\n            for i in range(len(path) - 1):\n                u = path[i]\n                v = path[i + 1]\n                energy = max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n                total_energy += energy\n            results.append(total_energy)\n    \n    for result in results:\n        print(result)"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, tunnel connections, and queries.\",\n      \"details\": \"Read and store the values of n, q, the list of illusion rates, the list of tunnel connections, and the list of queries.\"\n    },\n    {\n      \"description\": \"Construct the tree structure from the tunnel connections.\",\n      \"details\": \"Use the list of tunnel connections to build a tree representation of the maze rooms.\"\n    },\n    {\n      \"description\": \"Implement a function to handle type 1 queries (update illusion rate).\",\n      \"details\": \"Modify the illusion rate of the specified room based on the query.\"\n    },\n    {\n      \"description\": \"Implement a function to handle type 2 queries (calculate minimum energy).\",\n      \"details\": \"Calculate the minimum energy required to move from the start room to the end room using the current illusion rates.\"\n    },\n    {\n      \"description\": \"Optimize the energy calculation for scalability.\",\n      \"details\": \"Ensure the energy calculation is efficient and can handle large input sizes by using appropriate algorithms and data structures.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Construct the tree structure using the tunnel connections.\",\n    \"Iterate over each query and determine its type.\",\n    \"For type 1 queries, update the illusion rate of the specified room.\",\n    \"For type 2 queries, calculate the minimum energy required using the current illusion rates and output the result.\",\n    \"Ensure the solution is optimized for large input sizes and complex scenarios.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A tree is a data structure consisting of nodes, where each node has zero or more child nodes. In this context, the rooms and tunnels form a tree structure, meaning there is a single path between any two rooms.\n    'illusion rate': This refers to the integer value associated with each room, which affects the energy calculation when moving between rooms.\n\n# [phrase showing quantity relationship]\n    'minimum sum of energy': This means calculating the least amount of energy required to move from one room to another, considering the illusion rates.\n    Implementation: Use the formula max(|a_i + a_j|, |a_i - a_j|) to calculate the energy between connected rooms and sum these values for the path.\n\n# [degree adverb]\n    'minimum': This indicates that the energy calculation should result in the smallest possible sum for the given path.\n    Implementation: Ensure that the energy calculation uses the correct formula and sums the values correctly for the path.\n\n# [code logic]\n    The steps for handling type 1 and type 2 queries should be implemented separately, as they involve different operations (updating values vs. calculating energy). However, parsing input and constructing the tree can be done simultaneously as part of the initial setup.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected output: 0\n    Explanation: With both rooms having an illusion rate of 0, the energy calculation results in 0.\n\n    Input: 3 2\n           1 1 1\n           1 2\n           2 3\n           2 1 3\n           1 1 -1\n           2 1 3\n    Expected output: 2, 4\n    Explanation: Initially, the energy from room 1 to 3 is calculated as 2. After updating room 1's illusion rate to -1, the energy becomes 4.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic for calculating energy and updating illusion rates should handle these scenarios correctly.\n\nNO", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        index += 1\n        t = int(data[index]) - 1\n        index += 1\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index])\n        index += 1\n        queries.append((query_type, u, v))\n    \n    return n, q, illusion_rates, tree, queries\n\ndef bfs_path(tree, start, end):\n    queue = deque([start])\n    parent = {start: None}\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            break\n        for neighbor in tree[node]:\n            if neighbor not in parent:\n                parent[neighbor] = node\n                queue.append(neighbor)\n    \n    path = []\n    while end is not None:\n        path.append(end)\n        end = parent[end]\n    \n    return path[::-1]\n\ndef calculate_energy(illusion_rates, path):\n    energy = 0\n    for i in range(len(path) - 1):\n        u = path[i]\n        v = path[i + 1]\n        energy += max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n    return energy\n\ndef main():\n    n, q, illusion_rates, tree, queries = parse_input()\n    \n    for query_type, u, v in queries:\n        if query_type == 1:\n            # Update illusion rate\n            illusion_rates[u] = v\n        elif query_type == 2:\n            # Calculate minimum energy\n            path = bfs_path(tree, u, v - 1)\n            energy = calculate_energy(illusion_rates, path)\n            print(energy)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 166)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        index += 1\n        t = int(data[index]) - 1\n        index += 1\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index])\n        index += 1\n        queries.append((query_type, u, v))\n    \n    return n, q, illusion_rates, tree, queries\n\ndef bfs_path(tree, start, end):\n    queue = deque([start])\n    parent = {start: None}\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            break\n        for neighbor in tree[node]:\n            if neighbor not in parent:\n                parent[neighbor] = node\n                queue.append(neighbor)\n    \n    path = []\n    while end is not None:\n        path.append(end)\n        end = parent[end]\n    \n    return path[::-1]\n\ndef calculate_energy(illusion_rates, path):\n    energy = 0\n    for i in range(len(path) - 1):\n        u = path[i]\n        v = path[i + 1]\n        energy += max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n    return energy\n\ndef main():\n    n, q, illusion_rates, tree, queries = parse_input()\n    \n    for query_type, u, v in queries:\n        if query_type == 1:\n            # Update illusion rate\n            illusion_rates[u] = v\n        elif query_type == 2:\n            # Calculate minimum energy\n            path = bfs_path(tree, u, v - 1)\n            energy = calculate_energy(illusion_rates, path)\n            print(energy)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure of the maze.\",\n      \"steps\": [\n        \"Read the first line to get integers n and q.\",\n        \"Read the second line to get the list of initial illusion rates for each room.\",\n        \"Read the next n-1 lines to construct the tree structure using adjacency list representation.\"\n      ]\n    },\n    {\n      \"description\": \"Implement a mechanism to handle queries efficiently.\",\n      \"steps\": [\n        \"Identify the type of each query (type 1 or type 2).\",\n        \"For type 1 queries, update the illusion rate of the specified room.\",\n        \"For type 2 queries, calculate the minimum sum of energy required to move from the start room to the end room.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the energy required for movement between rooms.\",\n      \"steps\": [\n        \"For each type 2 query, traverse the path from the start room to the end room using the tree structure.\",\n        \"For each tunnel in the path, calculate the energy using the formula: max(|a_i + a_j|, |a_i - a_j|).\",\n        \"Sum the energy values for all tunnels in the path.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data structures: number of rooms, queries, illusion rates, and tree structure.\",\n    \"Implement a function to update illusion rates for type 1 queries.\",\n    \"Implement a function to calculate energy for type 2 queries by traversing the tree and applying the energy formula.\",\n    \"For each query, determine its type and execute the corresponding function.\",\n    \"Output the results for type 2 queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree structure'\n    Explanation: The maze is represented as a tree, which is a connected acyclic graph. This means there is exactly one path between any two rooms.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy calculation when moving between rooms.\n\n    'query types'\n    Explanation: There are two types of queries: type 1 updates the illusion rate of a room, and type 2 calculates the energy required to move between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_i + a_j|, |a_i - a_j|)': This phrase indicates that for each tunnel between two rooms, the energy required is the maximum of the absolute sum and the absolute difference of their illusion rates. In code, this can be implemented as:\n    ```python\n    energy = max(abs(a_i + a_j), abs(a_i - a_j))\n    ```\n\n# [degree adverb] \n    'minimum sum': This indicates that for type 2 queries, we need to calculate the total energy required for a path and ensure it is the minimum possible for the given path. This is inherently handled by the tree structure since there is only one path between any two nodes.\n\n# [code logic]\n    The steps for handling type 2 queries should be implemented simultaneously:\n    - Traverse the path from the start room to the end room.\n    - Calculate the energy for each tunnel in the path.\n    - Sum the energy values for the entire path.\n    This can be done in a single function that processes the path and calculates the total energy.\n\n# [edge case] \n    1. Input: `2 1\\n0 0\\n1 2\\n2 1 2` = 0\n       Explanation: With only two rooms and both having an illusion rate of 0, the energy required is 0.\n    2. Input: `3 1\\n1 1 1\\n1 2\\n2 3\\n2 1 3` = 2\n       Explanation: The path 1 -> 2 -> 3 requires energy max(|1+1|, |1-1|) + max(|1+1|, |1-1|) = 2 + 2 = 4.\n    3. Input: `4 1\\n10 -10 10 -10\\n1 2\\n2 3\\n3 4\\n", "Round_0": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Build the tree\n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    # Preprocess to find parent and depth using BFS\n    parent = [-1] * n\n    depth = [0] * n\n    queue = deque([0])\n    visited = [False] * n\n    visited[0] = True\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in tree[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                parent[neighbor] = node\n                depth[neighbor] = depth[node] + 1\n                queue.append(neighbor)\n    \n    def lca(u, v):\n        # Bring both nodes to the same depth\n        while depth[u] > depth[v]:\n            u = parent[u]\n        while depth[v] > depth[u]:\n            v = parent[v]\n        \n        # Find the common ancestor\n        while u != v:\n            u = parent[u]\n            v = parent[v]\n        \n        return u\n    \n    def calculate_energy(u, v):\n        common_ancestor = lca(u, v)\n        total_energy = 0\n        \n        # Calculate energy from u to LCA\n        while u != common_ancestor:\n            total_energy += max(abs(illusion_rates[u] + illusion_rates[parent[u]]), abs(illusion_rates[u] - illusion_rates[parent[u]]))\n            u = parent[u]\n        \n        # Calculate energy from v to LCA\n        while v != common_ancestor:\n            total_energy += max(abs(illusion_rates[v] + illusion_rates[parent[v]]), abs(illusion_rates[v] - illusion_rates[parent[v]]))\n            v = parent[v]\n        \n        return total_energy\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 114)"}, "Round_1": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Build the tree\n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    # Preprocess to find parent and depth using BFS\n    parent = [-1] * n\n    depth = [0] * n\n    queue = deque([0])\n    visited = [False] * n\n    visited[0] = True\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in tree[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                parent[neighbor] = node\n                depth[neighbor] = depth[node] + 1\n                queue.append(neighbor)\n    \n    def lca(u, v):\n        # Bring both nodes to the same depth\n        while depth[u] > depth[v]:\n            u = parent[u]\n        while depth[v] > depth[u]:\n            v = parent[v]\n        \n        # Find the common ancestor\n        while u != v:\n            u = parent[u]\n            v = parent[v]\n        \n        return u\n    \n    def calculate_energy(u, v):\n        common_ancestor = lca(u, v)\n        total_energy = 0\n        \n        # Calculate energy from u to LCA\n        while u != common_ancestor:\n            total_energy += max(abs(illusion_rates[u] + illusion_rates[parent[u]]), abs(illusion_rates[u] - illusion_rates[parent[u]]))\n            u = parent[u]\n        \n        # Calculate energy from v to LCA\n        while v != common_ancestor:\n            total_energy += max(abs(illusion_rates[v] + illusion_rates[parent[v]]), abs(illusion_rates[v] - illusion_rates[parent[v]]))\n            v = parent[v]\n        \n        return total_energy\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the tree structure of the maze.\",\n      \"steps\": [\n        \"Read the first line to get integers n and q.\",\n        \"Read the second line to get the list of initial illusion rates for each room.\",\n        \"Read the next n-1 lines to construct the tree structure using adjacency list representation.\"\n      ]\n    },\n    {\n      \"description\": \"Implement a mechanism to handle queries efficiently.\",\n      \"steps\": [\n        \"Identify the type of each query (type 1 or type 2).\",\n        \"For type 1 queries, update the illusion rate of the specified room.\",\n        \"For type 2 queries, calculate the minimum sum of energy required for the specified path.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the energy required for a path in the tree.\",\n      \"steps\": [\n        \"Use a tree traversal algorithm (e.g., DFS) to find the path between two rooms.\",\n        \"For each edge in the path, calculate the energy using the formula: max(|a_i + a_j|, |a_i - a_j|).\",\n        \"Sum the energy values for all edges in the path.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data structures: number of rooms, queries, illusion rates, and tree structure.\",\n    \"Implement a function to update the illusion rate of a room for type 1 queries.\",\n    \"Implement a function to calculate the energy required for a path for type 2 queries using tree traversal.\",\n    \"For each query, determine its type and execute the corresponding function.\",\n    \"Output the results for type 2 queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree structure'\n    Explanation: The maze is represented as a tree, which is a connected acyclic graph. This means there is exactly one path between any two rooms.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy calculation when moving between rooms.\n\n    'query types'\n    Explanation: There are two types of queries: type 1 updates the illusion rate of a room, and type 2 calculates the energy required to move between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_i + a_j|, |a_i - a_j|)': This phrase indicates that for each edge in the path, the energy is calculated as the maximum of the absolute sum and the absolute difference of the illusion rates of the connected rooms. In code, this can be implemented using the `max` function: `max(abs(a_i + a_j), abs(a_i - a_j))`.\n\n# [degree adverb]\n    'minimum sum': This indicates that for type 2 queries, the goal is to calculate the total energy required for a path, which is the sum of the maximum energy values for each edge in the path.\n\n# [code logic]\n    The steps for handling type 2 queries should be implemented simultaneously:\n    - \"Use a tree traversal algorithm (e.g., DFS) to find the path between two rooms.\"\n    - \"For each edge in the path, calculate the energy using the formula: max(|a_i + a_j|, |a_i - a_j|).\"\n    - \"Sum the energy values for all edges in the path.\"\n    These steps can be combined into a single function that performs the traversal and energy calculation in one go.\n\n# [edge case]\n    1. Input: 2 1\n       0 0\n       1 2\n       2 1 2\n       Output: 0\n       Explanation: The illusion rates are both zero, so the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    2. Input: 3 1\n       1 1 1\n       1 2\n       2 3\n       2 1 3\n       Output: 2\n       Explanation: The path is 1 \u2192 2 \u2192 3, with energy calculations max(|1 + 1|, |1 - 1|", "Round_0": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            queries.append((query_type, room, new_rate))\n            index += 3\n        else:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            queries.append((query_type, start, end))\n            index += 3\n    \n    def calculate_energy(start, end):\n        # Use BFS to find the path from start to end\n        parent = [-1] * n\n        queue = deque([start])\n        parent[start] = start\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if parent[neighbor] == -1:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        # Backtrack to find the path\n        path = []\n        current = end\n        while current != start:\n            path.append(current)\n            current = parent[current]\n        path.append(start)\n        path.reverse()\n        \n        # Calculate the energy for the path\n        total_energy = 0\n        for i in range(len(path) - 1):\n            u = path[i]\n            v = path[i + 1]\n            energy = max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n            total_energy += energy\n        \n        return total_energy\n    \n    results = []\n    for query in queries:\n        if query[0] == 1:\n            _, room, new_rate = query\n            illusion_rates[", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 74)"}, "Round_1": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            queries.append((query_type, room, new_rate))\n            index += 3\n        else:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            queries.append((query_type, start, end))\n            index += 3\n    \n    def calculate_energy(start, end):\n        # Use BFS to find the path from start to end\n        parent = [-1] * n\n        queue = deque([start])\n        parent[start] = start\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if parent[neighbor] == -1:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        # Backtrack to find the path\n        path = []\n        current = end\n        while current != start:\n            path.append(current)\n            current = parent[current]\n        path.append(start)\n        path.reverse()\n        \n        # Calculate the energy for the path\n        total_energy = 0\n        for i in range(len(path) - 1):\n            u = path[i]\n            v = path[i + 1]\n            energy = max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n            total_energy += energy\n        \n        return total_energy\n    \n    results = []\n    for query in queries:\n        if query[0] == 1:\n            _, room, new_rate = query\n            illusion_rates["}}], "scores": [], "pass_results": [false, false, false, true, true, true, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 505, "prompt": "Chanek and Indiana require your assistance in creating an effective algorithm to manage multiple requests while simulating the treasure hunt process in real time. It is crucial that your solution performs optimally. Your solution must be able to handle complex scenarios efficiently. Additionally, it must be scalable for a variety of input sizes and conditions.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "expand_one2two", "save_node": false, "parent_index": 283}
