{"name": "1619_H. Permutation and Queries", "description": "You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.\n\nThere are two types of queries:\n\n  * 1 x y \u2014 swap p_x and p_y. \n  * 2 i k \u2014 print the number that i will become if we assign i = p_i k times. \n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.", "tags": ["brute force", "data structures", "divide and conquer", "two pointers"], "difficulty": 14, "id": 1619, "sample_io": [{"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n3\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n", "output": ["4\n1\n2\n"]}], "test_list": [{"input": "1 1\n1\n2 1 1\n", "output": ["1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 6\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n8\n4\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 3\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n8\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 4\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["7\n6\n8\n9\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 83 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 6\n2 36 69\n1 100 59\n", "output": ["19\n6\n40\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 7 9\n2 9 16\n1 3 6\n", "output": ["10\n6\n8\n8\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n5\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 4\n1 1 3\n2 1 2\n", "output": ["4\n1\n2\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n59\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n4\n9\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 1 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n4\n2\n4\n3\n5\n1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 68\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n6\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n1\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n1 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n1\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 7 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n4\n8\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n1\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 2 2\n1 1 3\n2 1 2\n", "output": ["4\n4\n2\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 44 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 1\n2 36 69\n1 100 59\n", "output": ["21\n6\n40\n54\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 2\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n1\n2\n3\n3\n5\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 4\n1 1 2\n2 1 2\n", "output": ["4\n1\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 4 5\n2 5 1\n2 5 3\n2 1 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n4\n4\n2\n4\n3\n5\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n1\n5\n2\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n2\n3\n3\n1\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n1 1 3\n2 1 2\n", "output": ["4\n2\n2\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 44 22\n2 1 72\n2 65 13\n1 18 37\n1 19 89\n1 86 1\n2 36 69\n1 100 59\n", "output": ["21\n6\n57\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n7\n5\n2\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n2\n3\n5\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n7\n5\n10\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 2\n", "output": ["3\n5\n4\n2\n3\n5\n3\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n9\n5\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 7 9\n2 9 9\n1 3 6\n", "output": ["10\n6\n8\n7\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 2 72\n2 65 8\n1 18 37\n1 19 89\n1 86 3\n2 36 69\n1 100 59\n", "output": ["71\n16\n40\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n9\n8\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 1 6\n1 7 9\n2 9 16\n1 3 6\n", "output": ["10\n6\n8\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 1 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n9\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n1\n2\n3\n3\n1\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 2 2\n1 2 3\n2 1 2\n", "output": ["4\n4\n1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 44 44\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 1\n2 36 69\n1 100 59\n", "output": ["64\n6\n40\n54\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 4\n2 5 2\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n3\n1\n2\n3\n3\n5\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 0\n2 1 4\n1 1 2\n2 1 2\n", "output": ["3\n1\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["7\n6\n7\n5\n2\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 4 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n2\n3\n1\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n6\n8\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 4 9\n2 8 8\n1 3 6\n", "output": ["7\n6\n7\n8\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n1 3 6\n", "output": ["10\n3\n8\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 15\n1 3 6\n", "output": ["10\n3\n8\n6\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 83 22\n2 1 72\n2 65 10\n1 18 37\n1 19 89\n1 86 6\n2 36 69\n1 100 59\n", "output": ["19\n6\n47\n54\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n2 1 3\n2 1 2\n", "output": ["4\n1\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 1\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n4\n4\n3\n3\n1\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 2 2\n1 1 3\n2 2 2\n", "output": ["4\n4\n5\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 4 5\n2 5 1\n2 5 3\n2 1 4\n1 5 2\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n4\n4\n2\n4\n3\n1\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n6\n5\n3\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n1\n4\n2\n3\n3\n1\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 4 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n3\n3\n5\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["2\n6\n7\n5\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 5 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n9\n7\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 5 6\n1 10 6\n2 3 3\n1 1 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n9\n3\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 5 3\n2 5 8\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n1\n2\n2\n3\n1\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 0\n2 1 3\n1 1 2\n2 1 2\n", "output": ["3\n5\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n6\n2\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 10\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n1 3 6\n", "output": ["10\n3\n7\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 0\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n4\n5\n3\n3\n1\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n6\n5\n7\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 2\n2 2 7\n2 4 1\n", "output": ["3\n1\n4\n2\n3\n2\n1\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 5 6\n2 5 9\n2 8 2\n1 3 6\n", "output": ["10\n6\n9\n7\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 3\n1 6 2\n2 9 0\n1 4 6\n1 5 9\n2 9 8\n1 3 7\n", "output": ["10\n9\n9\n9\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 5 3\n2 5 8\n1 5 4\n2 5 3\n2 2 7\n2 5 2\n", "output": ["3\n5\n1\n2\n2\n3\n1\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n6\n8\n4\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 0\n2 5 3\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n4\n5\n2\n3\n1\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n7\n5\n7\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 6\n1 5 4\n2 5 2\n2 2 7\n2 4 1\n", "output": ["3\n1\n4\n2\n4\n2\n1\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 8 8\n1 4 6\n", "output": ["2\n6\n7\n6\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 3\n1 6 2\n2 9 0\n1 4 6\n2 5 9\n2 9 8\n1 3 7\n", "output": ["10\n9\n9\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n6\n8\n4\n4\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n8\n8\n8\n"]}, {"input": "5 7\n2 3 5 1 4\n2 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 6\n1 5 4\n2 5 2\n2 2 7\n2 4 1\n", "output": ["3\n1\n4\n2\n4\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 8 8\n2 4 6\n", "output": ["2\n6\n7\n6\n10\n4\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n6\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 13\n1 3 6\n", "output": ["10\n6\n8\n8\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 8 6\n2 4 6\n", "output": ["2\n6\n7\n6\n8\n4\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 5\n2 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n8\n8\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n2 5 4\n2 5 3\n2 2 5\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n2\n2\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 0\n", "output": ["4\n1\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 4\n2 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n4\n8\n7\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 1 4\n1 5 4\n2 4 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n4\n2\n4\n4\n5\n1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 3\n2 1 72\n2 65 8\n1 18 68\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["55\n6\n40\n6\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 2\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n8\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 1 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n4\n5\n2\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n2 1 3\n2 1 2\n", "output": ["4\n2\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n1 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n5\n4\n4\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 8\n1 10 6\n2 4 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n9\n4\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n2 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 8\n2 9 8\n1 3 6\n", "output": ["10\n10\n6\n9\n2\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 0\n1 1 4\n1 1 2\n2 1 2\n", "output": ["3\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 4\n2 1 3\n2 1 2\n", "output": ["4\n4\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 1 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n2\n3\n4\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n2 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n6\n8\n6\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 7 6\n2 3 3\n1 6 2\n2 5 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n5\n5\n3\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 4 3\n2 5 4\n1 5 1\n2 5 3\n2 2 12\n2 4 1\n", "output": ["3\n5\n4\n3\n3\n5\n2\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 2\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 10\n2 4 2\n", "output": ["3\n5\n1\n2\n3\n5\n3\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 1 3\n2 5 8\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n1\n5\n2\n3\n1\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 10\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 1 8\n1 3 6\n", "output": ["7\n6\n7\n5\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 9 8\n1 4 6\n", "output": ["2\n6\n7\n5\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 6\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 8 8\n1 4 6\n", "output": ["2\n3\n7\n6\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 3 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n6\n8\n8\n4\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 2 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n8\n5\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 6\n1 3 6\n2 6 9\n2 8 8\n2 4 6\n", "output": ["2\n6\n8\n6\n10\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 4\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 13\n1 3 6\n", "output": ["10\n7\n4\n5\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 0\n1 3 6\n2 6 9\n2 8 6\n2 4 6\n", "output": ["2\n6\n9\n6\n8\n4\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 5\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 4\n1 1 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n3\n4\n5\n2\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n2 1 3\n2 1 1\n", "output": ["4\n2\n5\n5\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 0\n2 5 4\n2 5 2\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 2\n", "output": ["3\n3\n1\n2\n3\n3\n5\n2\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 0\n2 5 4\n1 5 1\n2 1 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n5\n3\n4\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 9 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 10 10\n1 3 6\n", "output": ["10\n6\n1\n5\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n5\n5\n8\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n2 1 2\n2 1 1\n", "output": ["4\n2\n1\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 9 6\n2 4 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 10 10\n1 3 6\n", "output": ["10\n8\n1\n5\n8\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 0\n2 1 2\n2 1 1\n", "output": ["4\n3\n1\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 9 6\n1 4 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 10 10\n1 3 6\n", "output": ["10\n6\n5\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 5\n2 8 10\n1 3 8\n", "output": ["10\n6\n5\n2\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 6\n1 6 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n2\n8\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n1 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n", "output": ["3\n5\n4\n2\n2\n2\n4\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 13\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 1\n2 36 69\n1 100 59\n", "output": ["33\n89\n40\n94\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 1 9\n2 9 16\n1 3 6\n", "output": ["10\n6\n8\n6\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n1 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["95\n40\n32\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 5 2\n2 9 5\n1 4 6\n1 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n10\n5\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 4 5\n2 4 1\n2 5 3\n2 1 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n4\n1\n2\n4\n3\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 1\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n4\n4\n2\n3\n3\n1\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n1 2 3\n2 1 2\n", "output": ["4\n2\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 2 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n2\n4\n2\n3\n5\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 6\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["9\n6\n7\n5\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 8 8\n1 3 6\n", "output": ["10\n9\n8\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n2 7 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 8\n2 9 8\n1 3 6\n", "output": ["10\n9\n6\n9\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 1 2\n2 9 4\n1 4 6\n1 8 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n9\n2\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 3\n1 1 2\n2 1 2\n", "output": ["4\n5\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 4\n1 1 4\n2 1 2\n", "output": ["4\n4\n3\n"]}, {"input": "5 2\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 4 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n2 5 8\n2 9 8\n1 3 6\n", "output": ["10\n6\n8\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 3\n2 4 8\n1 3 6\n", "output": ["10\n6\n8\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 5\n1 7 6\n1 7 9\n2 3 1\n1 6 2\n2 9 5\n1 4 6\n2 4 9\n2 8 8\n1 5 6\n", "output": ["7\n4\n7\n8\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n2 3 6\n", "output": ["10\n3\n8\n7\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 5 6\n1 5 8\n2 4 15\n1 3 6\n", "output": ["10\n3\n8\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 3\n2 1 3\n2 1 2\n", "output": ["4\n5\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 4 5\n2 1 1\n2 5 3\n2 1 4\n1 5 2\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n4\n2\n2\n4\n3\n1\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 10\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["2\n6\n3\n5\n10\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 17\n2 4 2\n", "output": ["3\n5\n4\n2\n3\n5\n5\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n1 9 5\n1 5 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n5\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 5\n1 1 6\n1 7 10\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n1 3 6\n", "output": ["7\n3\n7\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 5\n1 6 2\n2 9 0\n1 4 6\n1 5 9\n2 9 8\n1 3 7\n", "output": ["10\n2\n9\n9\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 5 3\n2 5 8\n1 5 4\n1 5 3\n2 2 7\n2 5 2\n", "output": ["3\n5\n1\n2\n2\n3\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 1\n2 9 22\n2 3 6\n", "output": ["10\n6\n8\n4\n2\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 7 6\n1 4 6\n2 5 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n3\n8\n8\n"]}, {"input": "5 7\n2 3 5 1 4\n1 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 6\n1 5 4\n2 5 2\n2 2 7\n2 4 1\n", "output": ["5\n5\n5\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n2 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 13\n1 3 6\n", "output": ["10\n6\n9\n4\n2\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n1 5 3\n2 1 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n1\n4\n4\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 0\n2 5 4\n2 5 0\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 2\n", "output": ["3\n3\n5\n2\n3\n3\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 1\n1 6 2\n2 9 4\n2 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n4\n8\n6\n8\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 4 3\n2 5 4\n1 5 1\n2 5 3\n2 4 12\n2 4 1\n", "output": ["3\n5\n4\n3\n3\n5\n4\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 2\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 10\n2 4 3\n", "output": ["3\n5\n1\n2\n3\n5\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 9 8\n1 4 6\n", "output": ["2\n6\n7\n6\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 3 5\n1 1 6\n1 7 9\n2 9 22\n2 3 4\n", "output": ["10\n6\n8\n8\n4\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 6\n1 3 6\n2 6 7\n2 8 8\n2 4 6\n", "output": ["2\n6\n8\n4\n10\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 0\n2 5 4\n2 5 4\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 2\n", "output": ["3\n3\n3\n2\n3\n3\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 9\n2 8 10\n2 3 6\n", "output": ["10\n6\n5\n5\n8\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n2 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 9\n2 8 10\n1 3 8\n", "output": ["10\n8\n6\n9\n10\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 6\n1 6 2\n2 3 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n2\n7\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 4\n1 7 6\n1 10 6\n2 3 2\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 5\n", "output": ["7\n1\n8\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 2\n1 4 6\n1 1 9\n2 9 16\n1 3 6\n", "output": ["10\n6\n2\n6\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 5 2\n2 9 5\n1 4 6\n1 5 8\n2 8 8\n1 3 6\n", "output": ["10\n6\n10\n8\n"]}, {"input": "5 4\n5 3 4 2 1\n1 3 1\n2 2 2\n1 1 5\n2 1 2\n", "output": ["5\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 6\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 6\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["9\n6\n8\n5\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 9 9\n2 8 8\n1 3 8\n", "output": ["10\n6\n9\n9\n8\n"]}, {"input": "5 4\n5 3 4 2 1\n2 1 1\n2 1 3\n1 1 2\n2 1 2\n", "output": ["5\n5\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 2 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n2 3 6\n", "output": ["10\n10\n8\n7\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 5 3\n1 5 8\n2 4 15\n1 3 6\n", "output": ["10\n3\n8\n1\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n1 9 5\n1 5 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 9\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n1 5 6\n", "output": ["7\n6\n2\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 4 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 1\n2 9 22\n2 3 6\n", "output": ["10\n9\n6\n4\n4\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 1\n1 8 5\n1 7 6\n2 3 3\n2 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 13\n1 3 6\n", "output": ["9\n6\n9\n4\n2\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n2 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 9\n2 8 10\n2 3 6\n", "output": ["10\n7\n6\n5\n3\n2\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 11\n1 6 2\n2 3 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n7\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 2 3\n1 10 1\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n2 3 6\n", "output": ["10\n10\n6\n3\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 9\n1 7 6\n1 10 4\n2 3 3\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n1 5 6\n", "output": ["7\n8\n6\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 2 3\n1 10 1\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n2 3 8\n", "output": ["10\n10\n6\n3\n10\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 1 3\n1 6 2\n1 9 5\n1 5 6\n3 5 9\n2 8 8\n1 3 6\n", "output": ["10\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 9\n1 7 6\n1 10 4\n2 3 3\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 8 22\n1 5 6\n", "output": ["7\n8\n6\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 6 9\n2 3 3\n1 6 2\n2 9 6\n1 3 6\n2 6 12\n2 8 8\n1 4 6\n", "output": ["2\n6\n9\n6\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 2 3\n1 10 1\n2 9 4\n1 4 6\n1 5 8\n2 3 8\n2 3 8\n", "output": ["10\n10\n6\n10\n10\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 2 3\n1 6 2\n1 9 5\n1 5 6\n3 5 9\n2 8 8\n1 3 6\n", "output": ["10\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 9\n1 7 6\n1 10 4\n2 3 3\n1 6 2\n2 9 8\n1 1 6\n1 7 9\n2 8 22\n1 5 6\n", "output": ["7\n8\n4\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 4\n1 7 6\n1 10 3\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["7\n2\n4\n9\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 1 2\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n3\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 2 4\n1 1 3\n2 1 2\n", "output": ["4\n3\n2\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 37\n1 86 5\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n51\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 2 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n4\n2\n1\n3\n5\n1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 10\n1 18 68\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["71\n6\n47\n6\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 0\n", "output": ["3\n5\n4\n2\n3\n3\n1\n5\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 2\n2 5 3\n2 5 7\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n1\n2\n1\n3\n5\n1\n"]}, {"input": "5 3\n5 3 4 2 1\n2 3 1\n2 1 4\n1 1 2\n2 1 2\n", "output": ["4\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n1 3 5\n2 4 5\n2 5 1\n2 5 3\n2 1 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["1\n5\n5\n1\n3\n4\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n1 3 1\n2 3 2\n1 1 3\n2 1 2\n", "output": ["1\n1\n"]}], "task_id": "codecontest/146", "repair_prompt": ["You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You are required to perform q queries, where q represents the number of queries to be completed.\n\nThere are two types of queries:\n\n  * 1 x y \u2014 swap p_x and p_y. \n  * 2 i k \u2014 print the number that i will become if we assign i = p_i k times.\n\nYour task is to efficiently handle each query and return the expected results promptly.\n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You are required to perform q queries. The variable q represents the number of queries. It indicates how many queries need to be completed.\n\nThere are two types of queries:\n\n  * 1 x y \u2014 swap p_x and p_y. \n  * 2 i k \u2014 print the number that i will become if we assign i = p_i k times.\n\nYour task is to efficiently handle each query and return the expected results promptly.\n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "You are given a permutation p of n elements, and a permutation of n elements is an array of length n containing each integer from 1 to n exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You are required to perform q queries, where q represents the number of queries to be completed. There are two types of queries: * 1 x y \u2014 swap p_x and p_y. * 2 i k \u2014 print the number that i will become if we assign i = p_i k times. Your task is to efficiently handle each query and return the expected results promptly.\n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    index = n + 2\n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            for _ in range(k):\n                i = p[i] - 1\n            results.append(p[i])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def process_queries(n, q, p, queries):\n    results = []\n    \n    for query in queries:\n        t, x, y = query\n        if t == 1:\n            # Swap operation\n            p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n        elif t == 2:\n            # Iterative assignment operation\n            i = x\n            for _ in range(y):\n                i = p[i - 1]\n            results.append(i)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((t, x, y))\n        index += 3\n    \n    results = process_queries(n, q, p, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        index += 1\n        if t == 1:\n            x = int(data[index]) - 1\n            index += 1\n            y = int(data[index]) - 1\n            index += 1\n            p[x], p[y] = p[y], p[x]\n        elif t == 2:\n            i = int(data[index]) - 1\n            index += 1\n            k = int(data[index])\n            index += 1\n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            results.append(p[current])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse the input\n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read the permutation array\n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Prepare to collect results for second-type queries\n    results = []\n    \n    # Process each query\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        index += 3\n        \n        if t == 1:\n            # Swap operation (1 x y)\n            p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n        elif t == 2:\n            # Iterative assignment (2 i k)\n            i = x\n            k = y\n            for _ in range(k):\n                i = p[i - 1]\n            results.append(i)\n    \n    # Output the results for all second-type queries\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    index = n + 2\n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            result = i\n            for _ in range(k):\n                result = p[result] - 1\n            results.append(p[result])\n        index += 3\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def process_queries(n, q, p, queries):\n    results = []\n    \n    for query in queries:\n        t, x, y = query\n        if t == 1:\n            # Swap operation\n            p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n        elif t == 2:\n            # Iterative assignment operation\n            current_index = x - 1\n            for _ in range(y):\n                current_index = p[current_index] - 1\n            results.append(p[current_index])\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(int, data[2:n+2]))\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((t, x, y))\n        index += 3\n    \n    results = process_queries(n, q, p, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            # Swap operation\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            # Iterative assignment operation\n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            results.append(p[current])\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        index += 1\n        if t == 1:\n            x = int(data[index]) - 1\n            index += 1\n            y = int(data[index]) - 1\n            index += 1\n            p[x], p[y] = p[y], p[x]\n        elif t == 2:\n            i = int(data[index]) - 1\n            index += 1\n            k = int(data[index])\n            index += 1\n            current_index = i\n            for _ in range(k):\n                current_index = p[current_index] - 1\n            results.append(p[current_index])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            current_index = i\n            for _ in range(k):\n                current_index = p[current_index] - 1\n            \n            results.append(p[current_index])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            \n            results.append(p[current])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    index = n + 2\n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            for _ in range(k):\n                i = p[i] - 1\n            results.append(p[i])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": \"Read the first line to get n and q. Read the second line to get the permutation array p. Read the next q lines to get the queries.\"\n    },\n    {\n      \"description\": \"Implement the swap operation for the first type of query.\",\n      \"details\": \"For a query of type 1 x y, swap the elements at indices x-1 and y-1 in the permutation array p.\"\n    },\n    {\n      \"description\": \"Implement the calculation for the second type of query.\",\n      \"details\": \"For a query of type 2 i k, repeatedly assign i = p[i-1] for k times and return the final value of i.\"\n    },\n    {\n      \"description\": \"Output the results for all second-type queries.\",\n      \"details\": \"Collect the results of all second-type queries and print each result on a new line.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, the permutation array p, and the list of queries.\",\n    \"Initialize an empty list to store results of second-type queries.\",\n    \"Iterate over each query:\",\n    \"  If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"  If the query is of type 2, calculate the result by iterating k times and store the result.\",\n    \"Output the results for all second-type queries, each on a new line.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that the array is a rearrangement of the numbers from 1 to n without any repetition or omission.\n\n    'query'\n    Explanation: A query is an operation that needs to be performed on the permutation array. There are two types of queries: one that swaps elements and another that performs a calculation based on repeated assignments.\n\n# [phrase showing quantity relationship]\n    'k times'\n    Explanation: In the second type of query, the operation i = p[i-1] is performed k times. This means that the assignment is repeated k times, and the final value of i is returned. In code, this can be implemented using a loop that iterates k times, updating the value of i in each iteration.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling the second-type query should be implemented simultaneously within a loop. Specifically, the repeated assignment i = p[i-1] for k times can be done in a single loop that updates i in each iteration.\n\n# [edge case]\n    Input: 1 1\n    Output: 1\n    Explanation: With only one element, any swap operation is irrelevant, and the second-type query will always return the single element itself.\n\n    Input: 5 1\n    Output: 5\n    Explanation: If the permutation is [5, 4, 3, 2, 1] and the query is 2 5 1, the result is 5 because p_5 = 5.\n\n    Input: 3 3\n    Output: 3\n    Explanation: If the permutation is [3, 1, 2] and the query is 2 3 3, the result is 3 because after three assignments, i remains 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating k times for the second-type query and handling swaps for the first-type query will naturally handle these edge cases.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    index = n + 2\n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            for _ in range(k):\n                i = p[i] - 1\n            results.append(p[i])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": [\n        \"Read the first line to get the values of n and q.\",\n        \"Read the second line to get the permutation array p.\",\n        \"Read the next q lines to get the list of queries.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the logic to handle the first type of query (swap operation).\",\n      \"details\": [\n        \"Identify queries of type 1.\",\n        \"For each query, swap the elements at positions x and y in the permutation array p.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the logic to handle the second type of query (iterative assignment operation).\",\n      \"details\": [\n        \"Identify queries of type 2.\",\n        \"For each query, perform k iterations of the assignment i = p_i.\",\n        \"Output the final value of i after k iterations.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize the permutation array p and the list of queries from the input.\",\n    \"Iterate over each query:\",\n    \"  - If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"  - If the query is of type 2, perform the iterative assignment operation and store the result.\",\n    \"Output the results of all second-type queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that the array is a rearrangement of the numbers from 1 to n.\n\n    'query'\n    Explanation: A query is an operation that needs to be performed on the permutation. There are two types of queries: one that swaps elements and another that performs iterative assignments.\n\n# [phrase showing quantity relationship]\n    'n elements': Refers to the number of elements in the permutation, which is equal to n.\n    'q queries': Refers to the number of queries to be processed, which is equal to q.\n    'k times': In the second type of query, it indicates the number of iterations to perform the assignment i = p_i.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling each query type should be implemented separately, as they involve different operations. However, within the loop that processes each query, the logic for determining the query type and executing the corresponding operation should be handled in a single code block using an if-else statement.\n\n# [edge case]\n    1. n = 1, q = 1, p = [1], query = [(2, 1, 1)] = 1\n       Explanation: With only one element, the permutation is [1], and any query of type 2 will always return 1.\n    2. n = 5, q = 1, p = [1, 2, 3, 4, 5], query = [(2, 5, 0)] = 5\n       Explanation: A query with k = 0 should return the initial value of i, which is 5.\n    3. n = 5, q = 1, p = [5, 4, 3, 2, 1], query = [(2, 1, 5)] = 1\n       Explanation: The permutation is reversed, and after 5 iterations starting from index 1, it cycles back to 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the queries and handling each type appropriately will cover these cases.\n\nNO", "Round_0": {"code": "def process_queries(n, q, p, queries):\n    results = []\n    \n    for query in queries:\n        t, x, y = query\n        if t == 1:\n            # Swap operation\n            p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n        elif t == 2:\n            # Iterative assignment operation\n            i = x\n            for _ in range(y):\n                i = p[i - 1]\n            results.append(i)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((t, x, y))\n        index += 3\n    \n    results = process_queries(n, q, p, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 93)"}, "Round_1": {"code": "def process_queries(n, q, p, queries):\n    results = []\n    \n    for query in queries:\n        t, x, y = query\n        if t == 1:\n            # Swap operation\n            p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n        elif t == 2:\n            # Iterative assignment operation\n            i = x\n            for _ in range(y):\n                i = p[i - 1]\n            results.append(i)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((t, x, y))\n        index += 3\n    \n    results = process_queries(n, q, p, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of elements n, number of queries q, the permutation array p, and the list of queries.\",\n      \"steps\": [\n        \"Read the first line to get n and q.\",\n        \"Read the second line to get the permutation array p.\",\n        \"Read the next q lines to get the list of queries.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the logic to handle the first type of query (swap operation).\",\n      \"steps\": [\n        \"For a query of type 1 x y, swap the elements at positions x and y in the permutation array p.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the logic to handle the second type of query (iterative assignment operation).\",\n      \"steps\": [\n        \"For a query of type 2 i k, perform the operation of assigning i = p[i] iteratively k times.\",\n        \"Track the position of i through k iterations and determine the final value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each second-type query.\",\n      \"steps\": [\n        \"For each second-type query, after computing the result, print the result on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, the permutation array p, and the list of queries.\",\n    \"Initialize a loop to process each query one by one.\",\n    \"For each query, check the type of query:\",\n    \"If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"If the query is of type 2, perform the iterative assignment operation and store the result.\",\n    \"After processing all queries, output the results for each second-type query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means no duplicates and all numbers from 1 to n are present.\n\n    'query'\n    Explanation: A query is an operation that needs to be performed on the permutation. There are two types of queries: one that swaps elements and another that performs iterative assignments.\n\n# [phrase showing quantity relationship]\n    'at least one second-type query'\n    Explanation: This means that among the queries provided, there is guaranteed to be at least one query of type 2. This ensures that the output will not be empty.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling the first type of query (swap operation) and the second type of query (iterative assignment operation) should be implemented separately as they involve different operations. However, the parsing of input and output of results can be handled in a single block of code that iterates through the queries.\n\n# [edge case]\n    1. Input: 1 1\n       Output: 1\n       Explanation: With only one element, any query of type 2 will always return the element itself, as there are no other elements to swap or iterate through.\n\n    2. Input: 5 1\n       Output: 5\n       Explanation: If the permutation is already sorted in ascending order, any type 2 query with k=1 will return the element itself.\n\n    3. Input: 5 5\n       Output: 5\n       Explanation: If k is equal to the length of the permutation, the iterative assignment will cycle through the permutation and return the original element.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the permutation and handling swaps will naturally account for these scenarios.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        index += 1\n        if t == 1:\n            x = int(data[index]) - 1\n            index += 1\n            y = int(data[index]) - 1\n            index += 1\n            p[x], p[y] = p[y], p[x]\n        elif t == 2:\n            i = int(data[index]) - 1\n            index += 1\n            k = int(data[index])\n            index += 1\n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            results.append(p[current])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 83)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        index += 1\n        if t == 1:\n            x = int(data[index]) - 1\n            index += 1\n            y = int(data[index]) - 1\n            index += 1\n            p[x], p[y] = p[y], p[x]\n        elif t == 2:\n            i = int(data[index]) - 1\n            index += 1\n            k = int(data[index])\n            index += 1\n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            results.append(p[current])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": [\n        \"Read the first line to get the values of n and q.\",\n        \"Read the second line to get the permutation array p.\",\n        \"Read the next q lines to get the list of queries.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the logic to handle the first type of query (swap operation).\",\n      \"details\": [\n        \"Identify queries of type 1.\",\n        \"For each query, swap the elements at positions x and y in the permutation array.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the logic to handle the second type of query (iterative assignment).\",\n      \"details\": [\n        \"Identify queries of type 2.\",\n        \"For each query, perform k iterations of assignment starting from index i.\",\n        \"Output the final value after k iterations.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all second-type queries.\",\n      \"details\": [\n        \"Collect results for each second-type query.\",\n        \"Print each result on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, permutation array p, and the list of queries.\",\n    \"Initialize a loop to process each query.\",\n    \"For each query, check the type:\",\n    \"  - If type 1, perform the swap operation on the permutation array.\",\n    \"  - If type 2, perform the iterative assignment and store the result.\",\n    \"After processing all queries, output the results for all second-type queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that the array is a rearrangement of the numbers from 1 to n without repetition.\n\n    'queries'\n    Queries are operations that need to be performed on the permutation array. There are two types of queries: swap and iterative assignment.\n\n# [phrase showing quantity relationship]\n    'k times'\n    This indicates that the assignment operation should be performed k times starting from index i. In code, this can be implemented using a loop that iterates k times, updating the index each time.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling the second type of query (iterative assignment) should be implemented simultaneously within a loop. Specifically, the logic to perform k iterations of assignment starting from index i should be encapsulated in a single loop that updates the index iteratively.\n\n# [edge case]\n    Input: 1 1\n    Output: 1\n    Explanation: With n = 1, the permutation is [1]. Any query will result in the same output since there's only one element.\n\n    Input: 5 1\n    Output: 5\n    Explanation: With n = 5 and permutation [5, 4, 3, 2, 1], a query of type 2 with i = 5 and k = 1 will result in output 5, as p_5 = 1 and p_1 = 5.\n\n    Input: 5 5\n    Output: 1\n    Explanation: With n = 5 and permutation [1, 2, 3, 4, 5], a query of type 2 with i = 1 and k = 5 will result in output 1, as the permutation is cyclic.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating k times and updating the index will naturally handle these cases.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse the input\n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read the permutation array\n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Prepare to collect results for second-type queries\n    results = []\n    \n    # Process each query\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        index += 3\n        \n        if t == 1:\n            # Swap operation (1 x y)\n            p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n        elif t == 2:\n            # Iterative assignment (2 i k)\n            i = x\n            k = y\n            for _ in range(k):\n                i = p[i - 1]\n            results.append(i)\n    \n    # Output the results for all second-type queries\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 85)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse the input\n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read the permutation array\n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Prepare to collect results for second-type queries\n    results = []\n    \n    # Process each query\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        index += 3\n        \n        if t == 1:\n            # Swap operation (1 x y)\n            p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n        elif t == 2:\n            # Iterative assignment (2 i k)\n            i = x\n            k = y\n            for _ in range(k):\n                i = p[i - 1]\n            results.append(i)\n    \n    # Output the results for all second-type queries\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": \"Read the first line to get n and q. Read the second line to get the permutation array p. Read the next q lines to get the queries.\"\n    },\n    {\n      \"description\": \"Implement the swap operation for the first type of query.\",\n      \"details\": \"For a query of type 1 x y, swap the elements at positions x and y in the permutation array p.\"\n    },\n    {\n      \"description\": \"Implement the transformation operation for the second type of query.\",\n      \"details\": \"For a query of type 2 i k, repeatedly apply the transformation i = p_i k times and return the result.\"\n    },\n    {\n      \"description\": \"Efficiently handle multiple queries and output results for second-type queries.\",\n      \"details\": \"Iterate through the list of queries, apply the appropriate operation based on the query type, and store results for second-type queries.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize the permutation array p from the input.\",\n    \"Iterate through each query:\",\n    \"  If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"  If the query is of type 2, perform the transformation operation and store the result.\",\n    \"Output the results for all second-type queries in the order they were received.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that the array is a rearrangement of the numbers from 1 to n.\n\n    'query'\n    A query is an operation that needs to be performed on the permutation array. There are two types of queries: swap and transformation.\n\n# [phrase showing quantity relationship]\n    'exactly once': This indicates that each integer from 1 to n appears only once in the permutation array. In code, this means we should ensure no duplicates and all numbers from 1 to n are present.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling queries should be considered simultaneously within the iteration over the queries. Specifically, the logic for determining the type of query and executing the corresponding operation (swap or transformation) should be handled in a single code block using if-else statements.\n\n# [edge case]\n    Input: 1 1\n           1\n           2 1 1\n    Output: 1\n    Explanation: With only one element, the transformation query will always return the element itself.\n\n    Input: 2 2\n           1 2\n           1 1 2\n           2 1 1\n    Output: 2\n    Explanation: After swapping, the permutation becomes [2, 1]. The transformation query on the first element returns 2.\n\n    Input: 3 3\n           3 1 2\n           2 3 1\n           1 1 3\n           2 1 2\n    Output: 2\n    Explanation: The transformation query on the third element returns 2. After swapping, the permutation becomes [2, 1, 3], and the transformation query on the first element returns 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through queries and applying the operations will naturally handle these cases.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    index = n + 2\n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            result = i\n            for _ in range(k):\n                result = p[result] - 1\n            results.append(p[result])\n        index += 3\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 76)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    index = n + 2\n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            result = i\n            for _ in range(k):\n                result = p[result] - 1\n            results.append(p[result])\n        index += 3\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of elements n, number of queries q, the permutation array p, and the list of queries.\",\n      \"steps\": [\n        \"Read the first line to get n and q.\",\n        \"Read the second line to get the permutation array p.\",\n        \"Read the next q lines to get the list of queries.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the logic to handle the first type of query (swap operation).\",\n      \"steps\": [\n        \"Identify the query type by checking the first integer t.\",\n        \"If t equals 1, perform a swap operation on the permutation array p at indices x and y.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the logic to handle the second type of query (iterative assignment operation).\",\n      \"steps\": [\n        \"Identify the query type by checking the first integer t.\",\n        \"If t equals 2, perform the iterative assignment operation starting from index i, k times.\",\n        \"Track the index transformation through k iterations and determine the final value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each second-type query.\",\n      \"steps\": [\n        \"For each second-type query, compute the result and store it.\",\n        \"Print each result on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, the permutation array p, and the list of queries.\",\n    \"Iterate over each query and determine its type.\",\n    \"For type 1 queries, perform the swap operation on the permutation array.\",\n    \"For type 2 queries, perform the iterative assignment operation and compute the result.\",\n    \"Store and print the results for all type 2 queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that the array is a rearrangement of numbers from 1 to n without repetition.\n\n    'query'\n    A query is an operation that needs to be performed on the permutation array. There are two types of queries: swap and iterative assignment.\n\n# [phrase showing quantity relationship]\n    'k times'\n    This indicates that the iterative assignment operation should be performed k times, meaning the transformation of the index should be repeated k times.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for handling type 1 and type 2 queries should be implemented separately, as they involve different operations. However, within the handling of type 2 queries, the iterative assignment operation should be performed in a loop that runs k times.\n\n# [edge case] \n    Input: 1 1\n    Output: 1\n    Explanation: With only one element, any query will result in the same element being returned.\n\n    Input: 2 1\n    Output: 1\n    Explanation: With only one element, swapping or iterative assignment will not change the result.\n\n    Input: 5 1\n    Output: 5\n    Explanation: With a single query and a permutation of 5 elements, the output will be the element at the specified index.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of handling queries will naturally accommodate these scenarios.\n\nNO", "Round_0": {"code": "def process_queries(n, q, p, queries):\n    results = []\n    \n    for query in queries:\n        t, x, y = query\n        if t == 1:\n            # Swap operation\n            p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n        elif t == 2:\n            # Iterative assignment operation\n            current_index = x - 1\n            for _ in range(y):\n                current_index = p[current_index] - 1\n            results.append(p[current_index])\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(int, data[2:n+2]))\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((t, x, y))\n        index += 3\n    \n    results = process_queries(n, q, p, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 76)"}, "Round_1": {"code": "def process_queries(n, q, p, queries):\n    results = []\n    \n    for query in queries:\n        t, x, y = query\n        if t == 1:\n            # Swap operation\n            p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n        elif t == 2:\n            # Iterative assignment operation\n            current_index = x - 1\n            for _ in range(y):\n                current_index = p[current_index] - 1\n            results.append(p[current_index])\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(int, data[2:n+2]))\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((t, x, y))\n        index += 3\n    \n    results = process_queries(n, q, p, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of elements n, number of queries q, the permutation array p, and the list of queries.\",\n      \"steps\": [\n        \"Read the first line to get n and q.\",\n        \"Read the second line to get the permutation array p.\",\n        \"Read the next q lines to get the list of queries.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the logic to handle the first type of query (swap operation).\",\n      \"steps\": [\n        \"Identify the query type by checking the first integer t.\",\n        \"If t equals 1, perform a swap operation on the permutation array p at indices x and y.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the logic to handle the second type of query (iterative assignment operation).\",\n      \"steps\": [\n        \"Identify the query type by checking the first integer t.\",\n        \"If t equals 2, perform the iterative assignment operation starting from index i, k times.\",\n        \"Track the index transformation through k iterations and determine the final value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each second-type query.\",\n      \"steps\": [\n        \"For each second-type query, compute the result and store it.\",\n        \"Print each result on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, permutation array p, and the list of queries.\",\n    \"Initialize a loop to process each query one by one.\",\n    \"For each query, determine its type (either swap or iterative assignment).\",\n    \"If the query is a swap operation, update the permutation array accordingly.\",\n    \"If the query is an iterative assignment, compute the result by simulating the assignment process.\",\n    \"Store the result of each second-type query.\",\n    \"After processing all queries, output the results for all second-type queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that each number between 1 and n appears exactly once in the array.\n\n    'query'\n    Explanation: A query is an operation that needs to be performed on the permutation. There are two types of queries: one that swaps two elements in the permutation and another that iteratively assigns a value based on the permutation.\n\n# [phrase showing quantity relationship]\n    'at least one second-type query'\n    Explanation: This means that among the queries provided, there is guaranteed to be at least one query of the second type. This ensures that the output will not be empty.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling each query should be implemented in a loop that processes each query one by one. The logic for determining the type of query and executing the appropriate operation (swap or iterative assignment) should be handled within this loop. The steps for parsing input, processing queries, and outputting results should be implemented sequentially.\n\n# [edge case]\n    1. Input: 1 1\n       Permutation: [1]\n       Query: 2 1 1\n       Expected Output: 1\n       Explanation: With only one element, the iterative assignment will always return the element itself.\n\n    2. Input: 2 2\n       Permutation: [2, 1]\n       Queries: 1 1 2, 2 1 1\n       Expected Output: 1\n       Explanation: After swapping, the permutation becomes [1, 2]. The second query asks for the first element, which is 1.\n\n    3. Input: 3 3\n       Permutation: [3, 1, 2]\n       Queries: 2 1 2, 1 1 3, 2 1 1\n       Expected Output: 2, 3\n       Explanation: The first query results in 2 after two iterations. After the swap, the permutation becomes [2, 1, 3], and the second query results in 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of processing each query and updating the permutation or computing the result based on the query type will handle these cases correctly.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            # Swap operation\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            # Iterative assignment operation\n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            results.append(p[current])\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 81)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            # Swap operation\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            # Iterative assignment operation\n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            results.append(p[current])\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of elements (n), number of queries (q), the permutation array (p), and the list of queries.\",\n      \"steps\": [\n        \"Read the first line to get n and q.\",\n        \"Read the second line to get the permutation array p.\",\n        \"Read the next q lines to get the list of queries.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the logic to handle the first type of query (swap operation).\",\n      \"steps\": [\n        \"Identify the query type by checking the first integer.\",\n        \"If the query type is 1, swap the elements at positions x and y in the permutation array p.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the logic to handle the second type of query (iterative assignment operation).\",\n      \"steps\": [\n        \"Identify the query type by checking the first integer.\",\n        \"If the query type is 2, perform k iterations of assignment starting from index i.\",\n        \"For each iteration, update the index to the value at the current index in the permutation array p.\",\n        \"After k iterations, return the value at the final index.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each second-type query.\",\n      \"steps\": [\n        \"Store the results of each second-type query in a list.\",\n        \"Print each result on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, permutation array p, and queries.\",\n    \"Initialize a list to store results for second-type queries.\",\n    \"Iterate over each query and determine its type.\",\n    \"For first-type queries, perform the swap operation on the permutation array.\",\n    \"For second-type queries, perform the iterative assignment operation and store the result.\",\n    \"Output the results for all second-type queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that the array is a rearrangement of the numbers from 1 to n without repetition.\n\n    'query'\n    A query is an operation that needs to be performed on the permutation array. There are two types of queries: swap and iterative assignment.\n\n# [phrase showing quantity relationship]\n    'n elements': indicates the length of the permutation array, which is equal to the number of elements n.\n    'k times': indicates the number of iterations to perform the assignment operation in the second type of query.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling the first-type query (swap operation) and the second-type query (iterative assignment operation) should be implemented separately, as they involve different operations on the permutation array. However, within the second-type query handling, the iterative assignment operation should be implemented in a loop that performs k iterations simultaneously.\n\n# [edge case]\n    Input: 1 1\n           1\n           2 1 1\n    Output: 1\n    Explanation: With only one element, the permutation is [1]. The query asks for the value at index 1 after 1 iteration, which remains 1.\n\n    Input: 3 2\n           3 1 2\n           2 2 3\n           1 1 3\n    Output: 2\n    Explanation: The permutation is [3, 1, 2]. The first query asks for the value at index 2 after 3 iterations, which results in 2. The second query swaps elements at indices 1 and 3, but it does not affect the output of the first query.\n\n    Input: 5 1\n           5 4 3 2 1\n           2 5 5\n    Output: 1\n    Explanation: The permutation is [5, 4, 3, 2, 1]. The query asks for the value at index 5 after 5 iterations, which results in 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of handling queries and performing iterations will naturally cover these scenarios.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        index += 1\n        if t == 1:\n            x = int(data[index]) - 1\n            index += 1\n            y = int(data[index]) - 1\n            index += 1\n            p[x], p[y] = p[y], p[x]\n        elif t == 2:\n            i = int(data[index]) - 1\n            index += 1\n            k = int(data[index])\n            index += 1\n            current_index = i\n            for _ in range(k):\n                current_index = p[current_index] - 1\n            results.append(p[current_index])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 83)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        index += 1\n        if t == 1:\n            x = int(data[index]) - 1\n            index += 1\n            y = int(data[index]) - 1\n            index += 1\n            p[x], p[y] = p[y], p[x]\n        elif t == 2:\n            i = int(data[index]) - 1\n            index += 1\n            k = int(data[index])\n            index += 1\n            current_index = i\n            for _ in range(k):\n                current_index = p[current_index] - 1\n            results.append(p[current_index])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of elements n, number of queries q, the permutation array p, and the list of queries.\",\n      \"steps\": [\n        \"Read the first line to get n and q.\",\n        \"Read the second line to get the permutation array p.\",\n        \"Read the next q lines to get the list of queries.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the logic to handle the first type of query (swap operation).\",\n      \"steps\": [\n        \"Identify the query type by checking the first integer t.\",\n        \"If t equals 1, perform a swap operation on the permutation array p at indices x and y.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the logic to handle the second type of query (iterative assignment operation).\",\n      \"steps\": [\n        \"Identify the query type by checking the first integer t.\",\n        \"If t equals 2, perform the iterative assignment operation starting from index i for k times.\",\n        \"Track the index transformation by iteratively updating the index using the permutation array p.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each second-type query.\",\n      \"steps\": [\n        \"For each second-type query, compute the result and store it.\",\n        \"Print each stored result on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, the permutation array p, and the list of queries.\",\n    \"Iterate over each query and determine its type.\",\n    \"For type 1 queries, perform the swap operation on the permutation array.\",\n    \"For type 2 queries, compute the result by iteratively applying the permutation transformation.\",\n    \"Store the results of type 2 queries and print them at the end.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that each number between 1 and n appears exactly once in the array.\n\n    'query'\n    Explanation: A query is an operation that needs to be performed on the permutation. There are two types of queries: one that swaps two elements in the permutation and another that iteratively applies the permutation to an index.\n\n# [phrase showing quantity relationship]\n    'at least one second-type query'\n    Explanation: This means that among the queries provided, there is guaranteed to be at least one query of the second type. This ensures that the output will not be empty since there will be at least one result to print.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling the first and second type of queries should be implemented separately as they involve different operations. However, within the handling of the second type of query, the iterative assignment operation should be implemented in a loop to apply the permutation transformation k times.\n\n# [edge case]\n    1. Input: 1 1\n       1\n       2 1 1\n       Output: 1\n       Explanation: With only one element, the permutation is [1]. The query asks for the result of applying the permutation starting at index 1 for 1 time, which remains 1.\n\n    2. Input: 2 1\n       1 2\n       2 1 1\n       Output: 2\n       Explanation: The permutation is [1, 2]. The query asks for the result of applying the permutation starting at index 1 for 1 time, which results in 2.\n\n    3. Input: 3 2\n       3 1 2\n       1 1 3\n       2 1 1\n       Output: 2\n       Explanation: After the swap operation, the permutation becomes [2, 1, 3]. The query asks for the result of applying the permutation starting at index 1 for 1 time, which results in 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the queries and applying the permutation transformations will naturally handle these cases.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            current_index = i\n            for _ in range(k):\n                current_index = p[current_index] - 1\n            \n            results.append(p[current_index])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 73)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            current_index = i\n            for _ in range(k):\n                current_index = p[current_index] - 1\n            \n            results.append(p[current_index])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of elements (n), number of queries (q), the permutation array (p), and the list of queries.\",\n      \"steps\": [\n        \"Read the first line to get n and q.\",\n        \"Read the second line to get the permutation array p.\",\n        \"Read the next q lines to get the list of queries.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the first type of query: swap elements in the permutation array.\",\n      \"steps\": [\n        \"Identify queries of type 1.\",\n        \"For each type 1 query, swap the elements at positions x and y in the permutation array p.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the second type of query: determine the result of repeated assignments.\",\n      \"steps\": [\n        \"Identify queries of type 2.\",\n        \"For each type 2 query, perform k assignments starting from index i in the permutation array p.\",\n        \"Track the index changes and determine the final value after k assignments.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each second-type query.\",\n      \"steps\": [\n        \"Store the results of each type 2 query.\",\n        \"Print each result on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, permutation array p, and queries.\",\n    \"Iterate over the list of queries.\",\n    \"For each query, determine its type.\",\n    \"If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"If the query is of type 2, perform the repeated assignment operation and store the result.\",\n    \"After processing all queries, output the results for each type 2 query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that the array is a rearrangement of numbers from 1 to n without repetition.\n\n    'queries'\n    Queries are operations that need to be performed on the permutation array. There are two types of queries: swap and repeated assignment.\n\n# [phrase showing quantity relationship]\n    'n elements': indicates the length of the permutation array, which is equal to the number of elements.\n    'q queries': indicates the number of operations to be performed on the permutation array.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling type 1 and type 2 queries should be implemented separately, as they involve different operations. However, within each type, the operations can be handled in a loop iterating over the queries.\n\n# [edge case]\n    Input: 1 1\n           1\n           2 1 1\n    Output: 1\n    Explanation: With only one element, the permutation is [1]. The query asks for the result of one assignment starting from index 1, which remains 1.\n\n    Input: 3 3\n           3 1 2\n           2 1 2\n           1 1 3\n           2 1 1\n    Output: 1\n            3\n    Explanation: Initially, the permutation is [3, 1, 2]. The first query results in 1 after two assignments starting from index 1. After swapping indices 1 and 3, the permutation becomes [2, 1, 3]. The second query results in 3 after one assignment starting from index 1.\n\n    Input: 5 5\n           5 4 3 2 1\n           2 5 5\n           1 1 5\n           2 5 1\n           1 2 4\n           2 5 3\n    Output: 1\n            5\n            2\n    Explanation: The permutation starts as [5, 4, 3, 2, 1]. The first query results in 1 after five assignments starting from index 5. After swapping indices 1 and 5, the permutation becomes [1, 4, 3, 2, ", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            \n            results.append(p[current])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 81)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            \n            results.append(p[current])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": \"Read the first line to get n and q. Read the second line to get the permutation array p. Read the next q lines to get the queries.\"\n    },\n    {\n      \"description\": \"Implement the swap operation for the first type of query.\",\n      \"details\": \"For a query of type 1 x y, swap the elements at indices x-1 and y-1 in the permutation array p.\"\n    },\n    {\n      \"description\": \"Implement the calculation for the second type of query.\",\n      \"details\": \"For a query of type 2 i k, repeatedly assign i = p[i-1] for k times and return the final value of i.\"\n    },\n    {\n      \"description\": \"Output the results for all second-type queries.\",\n      \"details\": \"Collect the results of all second-type queries and print each result on a new line.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, the permutation array p, and the list of queries.\",\n    \"Initialize an empty list to store results of second-type queries.\",\n    \"Iterate over each query:\",\n    \"  If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"  If the query is of type 2, calculate the result by iterating k times and store the result.\",\n    \"Output the results for all second-type queries, each on a new line.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that the array is a rearrangement of the numbers from 1 to n without any repetition or omission.\n\n    'query'\n    Explanation: A query is an operation that needs to be performed on the permutation array. There are two types of queries: one that swaps elements and another that performs a calculation based on repeated assignments.\n\n# [phrase showing quantity relationship]\n    'k times'\n    Explanation: In the second type of query, the operation i = p[i-1] is performed k times. This means that the assignment is repeated k times, and the final value of i is returned. In code, this can be implemented using a loop that iterates k times, updating the value of i in each iteration.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling the second-type query should be implemented simultaneously within a loop. Specifically, the repeated assignment i = p[i-1] for k times can be done in a single loop that updates i in each iteration.\n\n# [edge case]\n    Input: 1 1\n    Output: 1\n    Explanation: With only one element, any swap operation is irrelevant, and the second-type query will always return the single element itself.\n\n    Input: 5 1\n    Output: 5\n    Explanation: If the permutation is [5, 4, 3, 2, 1] and the query is 2 5 1, the result is 5 because p_5 = 5.\n\n    Input: 3 3\n    Output: 3\n    Explanation: If the permutation is [3, 1, 2] and the query is 2 3 3, the result is 3 because after three assignments, i remains 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating k times for the second-type query and handling swaps for the first-type query will naturally handle these edge cases.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    index = n + 2\n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            for _ in range(k):\n                i = p[i] - 1\n            results.append(p[i])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, true, false, false, false, false, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 432, "prompt": "You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You are required to perform q queries, where q represents the number of queries to be completed.\n\nThere are two types of queries:\n\n  * 1 x y \u2014 swap p_x and p_y. \n  * 2 i k \u2014 print the number that i will become if we assign i = p_i k times.\n\nYour task is to efficiently handle each query and return the expected results promptly.\n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.", "examples": "\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.", "mutate_method": "expand_one2two", "save_node": false, "parent_index": 182}
