{"name": "1618_E. Singers' Tour", "description": "n towns are arranged in a circle sequentially. The towns are numbered from 1 to n in clockwise order. In the i-th town, there lives a singer with a repertoire of a_i minutes for each i \u2208 [1, n].\n\nEach singer visited all n towns in clockwise order, starting with the town he lives in, and gave exactly one concert in each town. In addition, in each town, the i-th singer got inspired and came up with a song that lasts a_i minutes. The song was added to his repertoire so that he could perform it in the rest of the cities.\n\nHence, for the i-th singer, the concert in the i-th town will last a_i minutes, in the (i + 1)-th town the concert will last 2 \u22c5 a_i minutes, ..., in the ((i + k) mod n + 1)-th town the duration of the concert will be (k + 2) \u22c5 a_i, ..., in the town ((i + n - 2) mod n + 1) \u2014 n \u22c5 a_i minutes.\n\nYou are given an array of b integer numbers, where b_i is the total duration of concerts in the i-th town. Reconstruct any correct sequence of positive integers a or say that it is impossible.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of two lines. The first line contains a single integer n (1 \u2264 n \u2264 4 \u22c5 10^4) \u2014 the number of cities. The second line contains n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 10^{9}) \u2014 the total duration of concerts in i-th city.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print the answer as follows:\n\nIf there is no suitable sequence a, print NO. Otherwise, on the first line print YES, on the next line print the sequence a_1, a_2, ..., a_n of n integers, where a_i (1 \u2264 a_i \u2264 10^{9}) is the initial duration of repertoire of the i-th singer. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n\n\nOutput\n\n\nYES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n\nNote\n\nLet's consider the 1-st test case of the example:\n\n  1. the 1-st singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 6 minutes, in the 3-rd \u2014 for 9 minutes; \n  2. the 2-nd singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 1 minute, in the 3-rd - for 2 minutes; \n  3. the 3-rd singer in the 1-st city will give a concert for 6 minutes, in the 2-nd \u2014 for 9 minutes, in the 3-rd \u2014 for 3 minutes. ", "tags": ["constructive algorithms", "math"], "difficulty": 11, "id": 1618, "sample_io": [{"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n", "output": ["YES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n"]}], "test_list": [{"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 75 93 93 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nYES\n5 5 4 1 4 5\n"]}, {"input": "4\n3\n12 19 14\n1\n1\n3\n1 2 3\n6\n8 75 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 18 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 87\n", "output": ["NO\nYES\n1\nNO\nYES\n5 5 4 1 4 5\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n14 75 202 179 49 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n2\n3\n1 2 3\n6\n14 75 202 179 91 39\n", "output": ["YES\n3 1 3\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n4\n3\n1 2 3\n6\n14 75 202 179 91 39\n", "output": ["YES\n3 1 3\nYES\n4\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n3\n3\n1 2 1\n6\n2 75 202 179 72 39\n", "output": ["NO\nYES\n3\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n4\n3\n0 4 3\n4\n26 75 32 4 3 6\n", "output": ["NO\nYES\n4\nNO\nNO\n"]}, {"input": "4\n3\n6 10 14\n1\n2\n3\n1 2 0\n6\n81 75 75 93 93 87\n", "output": ["NO\nYES\n2\nNO\nYES\n5 5 4 1 4 5\n"]}, {"input": "4\n3\n19 16 19\n1\n1\n3\n1 0 3\n6\n8 37 80 169 133 87\n", "output": ["YES\n3 4 2\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 75 93 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 80 93 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 119 93 93 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 75 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 119 93 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 3\n6\n8 75 75 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 19 14\n1\n1\n3\n1 2 2\n6\n8 75 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n14 75 119 93 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 3\n6\n8 75 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n14 75 119 179 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n1 1 3\n6\n8 75 75 82 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n1 1 3\n6\n8 75 75 82 133 105\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 37 80 93 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 87\n", "output": ["NO\nYES\n1\nNO\nYES\n5 5 4 1 4 5\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 2 3\n6\n8 75 119 93 93 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 75 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 62 93 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 18 14\n1\n1\n3\n1 2 1\n6\n112 75 75 93 93 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 3\n6\n8 75 119 93 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 3\n6\n8 132 75 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 4\n6\n8 75 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n1\n3\n1 2 3\n6\n14 75 119 179 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n1 1 3\n6\n8 39 75 82 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 37 80 169 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 3\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 2 3\n6\n8 75 119 93 93 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 1\n6\n8 75 62 93 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 18 14\n1\n1\n3\n1 2 1\n6\n112 75 75 93 93 124\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 3\n6\n8 75 119 93 49 15\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 4\n6\n8 75 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n1\n3\n1 2 3\n6\n14 75 119 179 49 39\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n1 2 3\n6\n8 39 75 82 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n2\n8 37 80 169 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 22\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 3\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 2 3\n6\n16 75 119 93 93 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 50 16 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 4\n6\n8 75 75 82 133 117\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n1\n3\n1 2 3\n6\n14 75 202 179 49 39\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n1 2 3\n6\n8 39 4 82 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 3\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 3\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 50 3 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n2\n1 2 3\n6\n8 39 4 82 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 3\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 91 3 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n14 75 202 179 91 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 10 3\n1\n1\n3\n2 2 1\n6\n81 75 75 93 93 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 91 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n2 75 202 179 91 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n24 10 3\n1\n1\n3\n2 2 1\n6\n81 75 75 93 93 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 19 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n2 75 202 179 42 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n24 10 3\n1\n1\n3\n2 2 1\n6\n81 75 75 184 93 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 4 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 0\n6\n2 75 202 179 42 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n24 10 3\n1\n1\n3\n2 2 1\n6\n81 75 75 184 129 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n13 75 32 4 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 4 3\n6\n13 75 32 4 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 4 3\n6\n13 75 32 4 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n2 2 3\n6\n8 75 75 93 93 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n10 75 75 93 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 119 93 155 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 19 13\n1\n1\n3\n1 2 3\n6\n8 75 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 18 14\n1\n1\n3\n1 2 1\n6\n62 75 75 93 93 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 119 93 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 3\n6\n8 75 84 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 19 14\n1\n1\n3\n1 2 2\n6\n8 75 80 93 133 150\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 6\n6\n8 75 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n14 102 119 179 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n1 1 3\n6\n8 75 75 82 16 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 37 80 8 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n6 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 87\n", "output": ["NO\nYES\n1\nNO\nYES\n5 5 4 1 4 5\n"]}, {"input": "4\n3\n12 16 27\n1\n1\n3\n0 2 3\n6\n8 75 75 50 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 25\n1\n1\n3\n1 0 3\n6\n8 75 119 93 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 4\n6\n8 81 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n19 16 14\n1\n1\n3\n1 2 3\n6\n8 37 80 169 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 81 3\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 2 3\n6\n8 75 119 93 167 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 6\n6\n8 75 32 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 1\n6\n8 75 62 64 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 0 3\n6\n8 75 119 93 49 15\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 4\n6\n8 75 75 82 133 133\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n4 16 7\n1\n1\n3\n1 2 3\n6\n14 75 119 179 49 39\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 22\n1\n1\n3\n1 2 2\n6\n81 75 75 93 93 3\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n8 16 4\n1\n1\n3\n1 2 3\n6\n16 75 119 93 93 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 50 16 2\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 8\n6\n8 75 75 82 133 117\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n22 16 7\n1\n1\n3\n1 2 3\n6\n14 75 202 179 49 39\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n2 2 3\n6\n8 39 4 82 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 3 3\n6\n8 75 32 50 3 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n14 75 202 176 49 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 10 3\n1\n1\n3\n1 2 1\n6\n81 75 75 93 29 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 4 3\n6\n8 75 32 91 3 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n2\n0 2 3\n6\n8 75 32 91 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 0 3\n6\n2 75 202 179 91 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n24 10 3\n1\n1\n3\n2 2 1\n6\n81 75 75 93 93 -1\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n2 75 202 179 42 4\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n24 10 3\n1\n1\n3\n2 2 1\n6\n81 138 75 184 93 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 6\n1\n1\n3\n0 2 3\n6\n8 75 32 4 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 1\n6\n2 75 202 179 42 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n13 75 32 4 4 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n0 4 3\n6\n13 75 32 4 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n2 2 3\n6\n8 75 75 93 21 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n10 75 75 88 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 119 93 240 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n14 19 13\n1\n1\n3\n1 2 3\n6\n8 75 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 16 119 93 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n13 16 14\n1\n1\n3\n1 1 3\n6\n8 75 84 50 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 19 14\n1\n1\n3\n1 2 2\n6\n8 75 80 181 133 150\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 6\n6\n8 75 75 82 41 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n11 16 14\n1\n1\n3\n1 2 3\n6\n14 102 119 179 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n2\n1 2 3\n6\n8 37 80 8 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n6 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 140\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 27\n1\n1\n3\n0 0 3\n6\n8 75 75 50 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 25\n1\n1\n3\n1 0 3\n6\n8 75 119 93 4 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 4\n6\n12 81 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n19 16 14\n1\n1\n2\n1 2 3\n6\n8 37 80 169 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 37 81 3\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 1 3\n6\n8 75 119 93 167 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 1\n6\n8 75 62 41 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 0 3\n6\n8 75 112 93 49 15\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 4\n3\n8 75 75 82 133 133\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n8 16 4\n1\n2\n3\n1 2 3\n6\n16 75 119 93 93 111\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 8\n6\n8 75 76 82 133 117\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n22 16 7\n1\n1\n2\n1 2 3\n6\n14 75 202 179 49 39\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n2 2 3\n6\n8 39 4 82 133 20\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 3 3\n6\n8 75 32 50 3 169\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 2\n6\n14 75 202 176 49 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 10 3\n1\n1\n3\n1 2 1\n6\n81 93 75 93 29 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 24\n1\n1\n3\n0 4 3\n6\n8 75 32 91 3 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 22\n1\n1\n2\n0 2 3\n6\n8 75 32 91 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n0 0 3\n6\n2 75 202 179 91 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n2 75 202 179 55 4\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 6\n1\n2\n3\n0 2 3\n6\n8 75 32 4 3 6\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 1\n6\n2 75 202 179 72 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n13 53 32 4 4 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n0 4 3\n4\n13 75 32 4 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 17 14\n1\n1\n3\n1 2 3\n6\n10 75 75 88 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 119 93 15 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n14 19 13\n1\n1\n3\n1 2 3\n6\n8 109 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 26 14\n1\n1\n3\n0 2 3\n6\n8 16 119 93 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n13 16 14\n1\n1\n3\n1 1 3\n6\n8 75 104 50 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 19 14\n1\n1\n3\n1 2 2\n6\n8 42 80 181 133 150\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 6\n6\n8 75 75 82 41 77\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n11 16 14\n1\n1\n3\n1 2 3\n6\n14 102 38 179 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n2\n1 2 3\n6\n11 37 80 8 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n6 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 38 140\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 25\n1\n1\n3\n1 0 3\n6\n8 75 143 93 4 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n2 1 4\n6\n12 81 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n19 16 14\n1\n1\n2\n1 2 3\n6\n10 37 80 169 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 37 81 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 1 3\n6\n8 21 119 93 167 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 1\n6\n8 35 62 41 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 4\n3\n8 75 75 133 133 133\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n2\n3\n1 0 8\n6\n8 75 76 82 133 117\n", "output": ["YES\n3 1 3\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n22 22 7\n1\n1\n3\n1 2 3\n6\n14 75 202 179 49 39\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 6 3\n6\n8 75 32 50 3 169\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 2\n6\n14 75 202 176 47 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 10 3\n1\n1\n3\n1 2 2\n6\n81 93 75 93 29 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 22\n1\n1\n2\n0 2 3\n6\n8 75 28 91 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n3 75 202 179 55 4\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n0 16 6\n1\n2\n3\n0 2 3\n6\n8 75 32 4 3 6\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n13 53 32 2 4 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n0 4 3\n4\n26 75 32 4 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 17 14\n1\n1\n3\n1 2 3\n6\n0 75 75 88 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n14 19 23\n1\n1\n3\n1 2 3\n6\n8 109 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 26 14\n1\n1\n3\n0 2 3\n6\n8 16 119 141 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 6 14\n1\n1\n3\n1 2 2\n6\n8 42 80 181 133 150\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 6\n6\n8 75 75 82 41 77\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n11 16 28\n1\n1\n3\n1 2 3\n6\n14 102 38 179 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n11 37 80 8 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 25\n1\n1\n3\n1 0 3\n6\n8 75 143 93 5 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n2 1 4\n6\n12 81 144 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n19 16 14\n1\n1\n2\n1 0 3\n6\n10 37 80 169 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 1 2\n6\n8 21 119 93 167 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 1\n6\n8 35 12 41 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 -1 4\n3\n8 75 75 133 133 133\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n2\n3\n1 1 8\n6\n8 75 76 82 133 117\n", "output": ["YES\n3 1 3\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n2\n3\n0 6 3\n6\n8 75 32 50 3 169\n", "output": ["YES\n3 1 3\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 2\n6\n14 75 202 176 57 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 10 4\n1\n1\n3\n1 2 2\n6\n81 93 75 93 29 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 22\n1\n1\n2\n0 2 3\n6\n13 75 28 91 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n3\n3\n1 1 1\n6\n2 75 202 179 72 39\n", "output": ["NO\nYES\n3\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n2\n3\n0 4 3\n4\n26 75 32 4 3 6\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 17 14\n1\n1\n3\n1 2 3\n6\n0 75 75 27 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n14 19 23\n1\n1\n3\n1 2 3\n6\n8 136 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 26 14\n1\n1\n3\n0 2 3\n6\n8 16 119 141 64 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 6 14\n1\n1\n3\n2 2 2\n6\n8 42 80 181 133 150\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 6\n6\n8 141 75 82 41 77\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}], "task_id": "codecontest/136", "repair_prompt": ["n towns are arranged in a circle sequentially. The towns are numbered from 1 to n in clockwise order. In the i-th town, there lives a singer with a repertoire of a_i minutes for each i \u2208 [1, n].\n\nEach singer visited all n towns in clockwise order, starting with the town he lives in, and gave exactly one concert in each town. Additionally, while performing in each town, the i-th singer found inspiration and composed a new song that lasted a_i minutes. This song was added to his repertoire so that he could perform it in the rest of the cities.\n\nHence, for the i-th singer, the concert in the i-th town will last a_i minutes, in the (i + 1)-th town the concert will last 2 \u22c5 a_i minutes, ..., in the ((i + k) mod n + 1)-th town the duration of the concert will be (k + 2) \u22c5 a_i, ..., in the town ((i + n - 2) mod n + 1) \u2014 n \u22c5 a_i minutes.\n\nYou are given an array of b integer numbers, where b_i is the total duration of concerts in the i-th town. Reconstruct any correct sequence of positive integers a or say that it is impossible.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of two lines. The first line contains a single integer n (1 \u2264 n \u2264 4 \u22c5 10^4) \u2014 the number of cities. The second line contains n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 10^{9}) \u2014 the total duration of concerts in i-th city.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print the answer as follows:\n\nIf there is no suitable sequence a, print NO. Otherwise, on the first line print YES, on the next line print the sequence a_1, a_2, ..., a_n of n integers, where a_i (1 \u2264 a_i \u2264 10^{9}) is the initial duration of repertoire of the i-th singer. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n\n\nOutput\n\n\nYES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n\nNote\n\nLet's consider the 1-st test case of the example:\n\n  1. the 1-st singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 6 minutes, in the 3-rd \u2014 for 9 minutes; \n  2. the 2-nd singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 1 minute, in the 3-rd - for 2 minutes; \n  3. the 3-rd singer in the 1-st city will give a concert for 6 minutes, in the 2-nd \u2014 for 9 minutes, in the 3-rd \u2014 for 3 minutes. \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "n towns are arranged in a circle sequentially. The towns are numbered from 1 to n in clockwise order. In the i-th town, there lives a singer with a repertoire of a_i minutes for each i \u2208 [1, n].\n\nEach singer visited all n towns in clockwise order, starting with the town he lives in, and gave exactly one concert in each town. Additionally, while performing in each town, the i-th singer found inspiration. He composed a new song that lasted a_i minutes. This song was added to his repertoire so that he could perform it in the rest of the cities.\n\nHence, for the i-th singer, the concert in the i-th town will last a_i minutes, in the (i + 1)-th town the concert will last 2 \u22c5 a_i minutes, ..., in the ((i + k) mod n + 1)-th town the duration of the concert will be (k + 2) \u22c5 a_i, ..., in the town ((i + n - 2) mod n + 1) \u2014 n \u22c5 a_i minutes.\n\nYou are given an array of b integer numbers, where b_i is the total duration of concerts in the i-th town. Reconstruct any correct sequence of positive integers a or say that it is impossible.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of two lines. The first line contains a single integer n (1 \u2264 n \u2264 4 \u22c5 10^4) \u2014 the number of cities. The second line contains n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 10^{9}) \u2014 the total duration of concerts in i-th city.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print the answer as follows:\n\nIf there is no suitable sequence a, print NO. Otherwise, on the first line print YES, on the next line print the sequence a_1, a_2, ..., a_n of n integers, where a_i (1 \u2264 a_i \u2264 10^{9}) is the initial duration of repertoire of the i-th singer. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n\n\nOutput\n\n\nYES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n\nNote\n\nLet's consider the 1-st test case of the example:\n\n  1. the 1-st singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 6 minutes, in the 3-rd \u2014 for 9 minutes; \n  2. the 2-nd singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 1 minute, in the 3-rd - for 2 minutes; \n  3. the 3-rd singer in the 1-st city will give a concert for 6 minutes, in the 2-nd \u2014 for 9 minutes, in the 3-rd \u2014 for 3 minutes. \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "n towns are arranged in a circle sequentially. The towns are numbered from 1 to n in clockwise order. In the i-th town, there lives a singer with a repertoire of a_i minutes for each i \u2208 [1, n]. Each singer visited all n towns in clockwise order, starting with the town he lives in, and gave exactly one concert in each town; additionally, while performing in each town, the i-th singer found inspiration and composed a new song that lasted a_i minutes, which was added to his repertoire so that he could perform it in the rest of the cities.\n\nHence, for the i-th singer, the concert in the i-th town will last a_i minutes, in the (i + 1)-th town the concert will last 2 \u22c5 a_i minutes, ..., in the ((i + k) mod n + 1)-th town the duration of the concert will be (k + 2) \u22c5 a_i, ..., in the town ((i + n - 2) mod n + 1) \u2014 n \u22c5 a_i minutes.\n\nYou are given an array of b integer numbers, where b_i is the total duration of concerts in the i-th town. Reconstruct any correct sequence of positive integers a or say that it is impossible.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of two lines. The first line contains a single integer n (1 \u2264 n \u2264 4 \u22c5 10^4) \u2014 the number of cities. The second line contains n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 10^{9}) \u2014 the total duration of concerts in i-th city.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print the answer as follows:\n\nIf there is no suitable sequence a, print NO. Otherwise, on the first line print YES, on the next line print the sequence a_1, a_2, ..., a_n of n integers, where a_i (1 \u2264 a_i \u2264 10^{9}) is the initial duration of repertoire of the i-th singer. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n\n\nOutput\n\n\nYES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n\nNote\n\nLet's consider the 1-st test case of the example:\n\n  1. the 1-st singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 6 minutes, in the 3-rd \u2014 for 9 minutes; \n  2. the 2-nd singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 1 minute, in the 3-rd - for 2 minutes; \n  3. the 3-rd singer in the 1-st city will give a concert for 6 minutes, in the 2-nd \u2014 for 9 minutes, in the 3-rd \u2014 for 3 minutes. \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] == 1:\n                results.append(\"YES\")\n                results.append(\"1\")\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nif __name__ == \"__main__\":\n    solve()\n\nmain()", "completions": ["def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        # Calculate the total sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) / 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of a\n        total_a = total_b // (n * (n + 1) // 2)\n        \n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            a[i] = (total_a + diff) // n\n            \n            if (total_a + diff) % n != 0 or a[i] <= 0:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            # Edge case: If there's only one town, the answer is straightforward\n            results.append(\"YES\")\n            results.append(f\"{b[0]}\")\n            continue\n        \n        # Calculate the sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) / 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of a_i\n        total_a = total_b // (n * (n + 1) // 2)\n        \n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            # Calculate the difference between b[i] and b[i-1]\n            diff = b[i] - b[i - 1]\n            # Calculate a[i]\n            a[i] = (total_a + diff) // n\n            \n            # Check if a[i] is a positive integer\n            if a[i] <= 0 or (total_a + diff) % n != 0:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    # Print all results\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] % n == 0:\n                results.append(\"YES\")\n                results.append(str(b[0] // n))\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev = (i - 1 + n) % n\n            diff = b[i] - b[prev]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff + total_a) % n != 0 or (diff + total_a) <= 0:\n                possible = False\n                break\n            a[i] = (diff + total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] % n == 0:\n                results.append(\"YES\")\n                results.append(str(b[0] // n))\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        # Check if total_b is divisible by the sum of the first n natural numbers\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1] if i > 0 else b[i] - b[n - 1]\n            if (diff + total_a) % n != 0 or (diff + total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff + total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] % n == 0:\n                results.append(\"YES\")\n                results.append(str(b[0] // n))\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_sum = sum(b)\n        if total_sum % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a_sum = total_sum // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev_index = (i - 1 + n) % n\n            diff = b[i] - b[prev_index]\n            if (total_a_sum - diff) % n != 0 or (total_a_sum - diff) // n <= 0:\n                possible = False\n                break\n            a[i] = (total_a_sum - diff) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] % n == 0:\n                results.append(\"YES\")\n                results.append(str(b[0] // n))\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_sum = sum(b)\n        if total_sum % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a_sum = total_sum // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (total_a_sum - diff) % n != 0 or (total_a_sum - diff) // n <= 0:\n                possible = False\n                break\n            a[i] = (total_a_sum - diff) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] == 1:\n                results.append(\"YES\")\n                results.append(\"1\")\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nif __name__ == \"__main__\":\n    solve()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of towns and the total duration of concerts in each town.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Parsed data structure containing test cases\"\n    },\n    {\n      \"description\": \"For each test case, determine if a valid sequence of initial repertoire durations exists that satisfies the given total concert durations for each town.\",\n      \"input\": \"Parsed data structure for a single test case\",\n      \"output\": \"Boolean indicating if a valid sequence exists\"\n    },\n    {\n      \"description\": \"If a valid sequence exists, reconstruct one possible sequence of initial repertoire durations for the singers.\",\n      \"input\": \"Parsed data structure for a single test case\",\n      \"output\": \"Sequence of initial repertoire durations or indication of impossibility\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, initialize variables to store the number of towns and the total concert durations for each town.\",\n    \"Iterate over each test case and attempt to reconstruct a valid sequence of initial repertoire durations:\",\n    \"  a. For each town, calculate the possible initial repertoire duration for the singer based on the total concert durations.\",\n    \"  b. Check if the calculated sequence satisfies the conditions for all towns.\",\n    \"  c. If a valid sequence is found, store it; otherwise, mark the test case as impossible.\",\n    \"Output the results for each test case, indicating 'YES' and the sequence if possible, or 'NO' if not.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'repertoire': refers to the initial duration of songs each singer has before starting the concerts.\n    'concert duration': refers to the total time each singer performs in each town, which increases as they compose new songs.\n\n# [phrase showing quantity relationship]\n    '2 \u22c5 a_i': means the concert duration in the next town is twice the initial repertoire.\n    '(k + 2) \u22c5 a_i': means the concert duration increases by a factor of (k + 2) times the initial repertoire as the singer moves to the next town.\n    'n \u22c5 a_i': means the concert duration in the last town is n times the initial repertoire.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for parsing input and reconstructing the sequence should be implemented simultaneously for efficiency. Specifically, parsing the input and initializing variables can be done in one code block, followed by the logic to reconstruct the sequence.\n\n# [edge case]\n    Test case with n = 1 and b_1 = 1: \n    Expected output: YES, 1\n    Explanation: With only one town, the singer's initial repertoire matches the total concert duration.\n    \n    Test case with n = 2 and b_1 = 2, b_2 = 4:\n    Expected output: YES, 1 2\n    Explanation: The first singer performs for 1 minute in the first town and 2 minutes in the second town, while the second singer performs for 2 minutes in the first town and 4 minutes in the second town.\n    \n    Test case with n = 3 and b_1 = 3, b_2 = 6, b_3 = 9:\n    Expected output: YES, 1 2 3\n    Explanation: Each singer's initial repertoire matches the total concert duration divided by the number of towns.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the sequence is impossible.\n        if n == 1 and b[0] != 1:\n            print(\"NO\")\n        else:\n            # Implement logic to check if a valid sequence can be reconstructed\n            # If not, print \"NO\"\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] == 1:\n                results.append(\"YES\")\n                results.append(\"1\")\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nif __name__ == \"__main__\":\n    solve()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of towns.\",\n        \"Read the array b of n integers, which represents the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence of initial repertoire durations exists for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize an array a of n integers to store the initial repertoire durations.\",\n        \"Iterate over each town and calculate the possible initial repertoire duration for each singer.\",\n        \"Check if the calculated durations satisfy the conditions given in the problem statement.\",\n        \"If a valid sequence is found, store it; otherwise, mark the test case as impossible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a valid sequence was found, print 'YES' followed by the sequence of integers.\",\n        \"If no valid sequence was found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence of initial repertoire durations.\",\n    \"Output the results for each test case, indicating whether a valid sequence was found.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'circular arrangement'\n    Explanation: The towns are arranged in a circle, meaning the sequence wraps around after the last town back to the first.\n\n    'repertoire'\n    Explanation: The initial duration of songs each singer has before starting the concerts.\n\n    'concert duration'\n    Explanation: The duration of each concert increases as the singer moves from town to town, adding the duration of a newly composed song each time.\n\n# [phrase showing quantity relationship]\n    'exactly one concert'\n    Explanation: Each singer performs exactly once in each town, which means the number of concerts equals the number of towns.\n\n    '2 \u22c5 a_i, ..., n \u22c5 a_i'\n    Explanation: The concert duration in each subsequent town is a multiple of the initial repertoire, increasing by the factor of the town number in the sequence.\n\n# [degree adverb]\n    'any correct sequence'\n    Explanation: There can be multiple valid sequences of initial repertoire durations that satisfy the conditions.\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the calculation of the initial repertoire duration for each singer and the validation of the sequence can be done in a single loop for efficiency.\n\n# [edge case]\n    1. n = 1, b = [1] = YES, 1\n       Explanation: With only one town, the initial repertoire must equal the total concert duration.\n       \n    2. n = 3, b = [1, 2, 3] = NO\n       Explanation: The sequence of concert durations does not allow for a valid initial repertoire that satisfies the conditions.\n       \n    3. n = 2, b = [2, 4] = YES, 1 2\n       Explanation: The initial repertoire can be 1 and 2, leading to concert durations of 2 and 4, respectively.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Specifically, we need to ensure that the calculated initial repertoire durations are positive integers and that they satisfy the conditions for all towns.\n    - Implement a check to verify if the calculated sequence is valid before outputting 'YES' or 'NO'.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        # Calculate the total sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) / 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of a\n        total_a = total_b // (n * (n + 1) // 2)\n        \n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            a[i] = (total_a + diff) // n\n            \n            if (total_a + diff) % n != 0 or a[i] <= 0:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of towns and the total duration of concerts in each town.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of towns.\",\n        \"Read the array b of n integers, representing the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence of initial repertoire durations exists for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize an array a of size n to store the initial repertoire durations.\",\n        \"Iterate over each town and calculate the possible initial repertoire duration for each singer.\",\n        \"Check if the calculated sequence satisfies the conditions for all towns.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"If a valid sequence a is found, print 'YES' followed by the sequence.\",\n        \"If no valid sequence exists, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence of initial repertoire durations.\",\n    \"For each town, calculate the contribution of each singer to the total concert duration and verify the sequence.\",\n    \"Output 'YES' and the sequence if a valid sequence is found, otherwise output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'circular arrangement'\n    Explanation: The towns are arranged in a circle, meaning the sequence wraps around after reaching the last town.\n\n    'repertoire'\n    Explanation: The initial duration of songs each singer has before starting their tour.\n\n    'concert duration'\n    Explanation: The total time a singer performs in a town, which increases as they compose new songs in each town.\n\n# [phrase showing quantity relationship]\n    'exactly one concert'\n    Explanation: Each singer performs exactly once in each town, which means the number of concerts equals the number of towns.\n\n    'n \u22c5 a_i'\n    Explanation: The concert duration in the last town for a singer is n times their initial repertoire.\n\n# [degree adverb]\n    'total duration'\n    Explanation: Refers to the sum of all concert durations in a town, which must match the given b_i values.\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the calculation of the initial repertoire duration for each singer and the verification of the sequence can be done in a single loop for efficiency.\n\n# [edge case]\n    1. n = 1, b = [1] = YES, 1\n       Explanation: With only one town, the initial repertoire must be equal to the total concert duration.\n    2. n = 3, b = [1, 2, 3] = NO\n       Explanation: The sequence of concerts cannot be arranged to satisfy the given durations.\n    3. n = 2, b = [2, 2] = YES, 1 1\n       Explanation: Each singer can have an initial repertoire of 1, leading to concert durations of 2 in both towns.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Specifically, we need to ensure that the calculated sequence of initial repertoires results in the correct total concert durations for each town.\n    - This involves checking if the sum of calculated concert durations matches the given b_i values for each town.\n\n```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index +", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            # Edge case: If there's only one town, the answer is straightforward\n            results.append(\"YES\")\n            results.append(f\"{b[0]}\")\n            continue\n        \n        # Calculate the sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) / 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of a_i\n        total_a = total_b // (n * (n + 1) // 2)\n        \n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            # Calculate the difference between b[i] and b[i-1]\n            diff = b[i] - b[i - 1]\n            # Calculate a[i]\n            a[i] = (total_a + diff) // n\n            \n            # Check if a[i] is a positive integer\n            if a[i] <= 0 or (total_a + diff) % n != 0:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    # Print all results\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of towns.\",\n        \"Read the array b of n integers, where each b_i represents the total duration of concerts in the i-th town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence a exists for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize an array a of size n to store the initial duration of repertoire for each singer.\",\n        \"Iterate over each town and calculate the possible initial duration a_i for each singer based on the given b array.\",\n        \"Check if the calculated sequence a satisfies the conditions for all towns.\",\n        \"If a valid sequence a is found, store it; otherwise, mark the test case as impossible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a valid sequence a was found, print 'YES' followed by the sequence a.\",\n        \"If no valid sequence was found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence a that satisfies the conditions.\",\n    \"Check the validity of the sequence a for each town.\",\n    \"Output 'YES' and the sequence a if a valid sequence is found; otherwise, output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'repertoire': refers to the collection of songs a singer has, which increases as they perform in each town.\n    'concert duration': refers to the total time a singer performs in a town, which increases as they compose new songs.\n\n# [phrase showing quantity relationship]\n    '2 \u22c5 a_i': means the concert duration in the next town is twice the initial repertoire.\n    '(k + 2) \u22c5 a_i': means the concert duration increases by a factor of (k + 2) times the initial repertoire as the singer moves to the next town.\n    'n \u22c5 a_i': means the concert duration in the last town is n times the initial repertoire.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps to parse the input and determine if a valid sequence exists should be implemented simultaneously for efficiency. Specifically, parsing the input and initializing the array a should be done in one block, followed by the calculation and validation of the sequence a.\n\n# [edge case]\n    Test case with n = 1 and b = [1] = YES, 1\n    Explanation: With only one town, the singer's repertoire matches the concert duration directly.\n    \n    Test case with n = 2 and b = [2, 4] = YES, 1 2\n    Explanation: The first singer performs for 1 minute in the first town and 2 minutes in the second town. The second singer performs for 2 minutes in the first town and 4 minutes in the second town.\n    \n    Test case with n = 3 and b = [3, 6, 9] = YES, 1 2 3\n    Explanation: Each singer's repertoire increases by their initial value as they move to the next town, matching the concert durations.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the calculated sequence a satisfies the conditions for all towns, and handle cases where n = 1 separately.\n    ```python\n    if n == 1:\n        if b[0] % n == 0:\n            print(\"YES\")\n            print(b[0] // n)\n        else:\n            print(\"NO\")\n    else:\n        # Original logic to calculate sequence a\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] % n == 0:\n                results.append(\"YES\")\n                results.append(str(b[0] // n))\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] % n == 0:\n                results.append(\"YES\")\n                results.append(str(b[0] // n))\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of towns and the total duration of concerts in each town.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of towns.\",\n        \"Read the array b of n integers, representing the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence a exists for each test case that satisfies the given conditions.\",\n      \"steps\": [\n        \"For each test case, initialize an array a of size n to store the initial duration of repertoire for each singer.\",\n        \"Iterate over each town and calculate the possible values for a_i based on the total duration b_i.\",\n        \"Check if the calculated values for a_i are consistent and valid across all towns.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"If a valid sequence a is found, print 'YES' followed by the sequence a.\",\n        \"If no valid sequence exists, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence a that satisfies the conditions.\",\n    \"Check the consistency and validity of the reconstructed sequence a.\",\n    \"Output 'YES' and the sequence a if valid, otherwise output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'circle sequentially'\n    This means the towns are arranged in a circular manner, and the singers visit them in a loop, starting from their own town and moving clockwise.\n\n    'repertoire'\n    Refers to the collection of songs a singer has, which increases as they perform in each town.\n\n    'concert duration'\n    The time each singer performs in a town, which increases as they compose new songs during their tour.\n\n# [phrase showing quantity relationship]\n    '2 \u22c5 a_i': This indicates that the concert duration in the next town is twice the initial repertoire.\n    'k + 2 \u22c5 a_i': This shows the concert duration increases by a factor of the town index plus two times the initial repertoire.\n    'n \u22c5 a_i': This indicates the concert duration in the last town is n times the initial repertoire.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for parsing input and determining the sequence should be implemented simultaneously for efficiency. Specifically, parsing the input and initializing the array a can be done in one code block, followed by the logic to determine the sequence a.\n\n# [edge case]\n    Test case with n = 1 and b = [1] = YES, 1\n    Explanation: With only one town, the singer's repertoire matches the concert duration directly.\n    \n    Test case with n = 2 and b = [2, 2] = NO\n    Explanation: The concert durations do not allow for a consistent sequence a that satisfies the conditions.\n    \n    Test case with n = 3 and b = [3, 6, 9] = YES, 1 2 3\n    Explanation: Each singer's concert duration matches the expected increase in repertoire.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the calculated sequence a is consistent across all towns and satisfies the conditions for each test case.\n    ```python\n    def is_valid_sequence(n, b):\n        # Check if a valid sequence a can be constructed\n        a = [0] * n\n        for i in range(n):\n            if b[i] % n != 0:\n                return False, []\n            a[i] = b[i] // n\n        return True, a\n\n    def process_test_cases(test_cases):\n        results = []\n        for n, b in test_cases:\n            valid", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev = (i - 1 + n) % n\n            diff = b[i] - b[prev]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev = (i - 1 + n) % n\n            diff = b[i] - b[prev]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of towns and the total duration of concerts in each town.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Parsed data structure containing test cases\"\n    },\n    {\n      \"description\": \"For each test case, determine if a valid sequence of initial repertoire durations exists that satisfies the given total concert durations in each town.\",\n      \"input\": \"Number of towns and total concert durations for each town\",\n      \"output\": \"Boolean indicating if a valid sequence exists\"\n    },\n    {\n      \"description\": \"If a valid sequence exists, reconstruct one possible sequence of initial repertoire durations for the singers.\",\n      \"input\": \"Number of towns and total concert durations for each town\",\n      \"output\": \"A sequence of initial repertoire durations\"\n    },\n    {\n      \"description\": \"Format the output for each test case, indicating whether a valid sequence was found and, if so, providing the sequence.\",\n      \"input\": \"Boolean indicating validity and the sequence of initial repertoire durations\",\n      \"output\": \"Formatted output string for each test case\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, initialize variables to track the feasibility of constructing a valid sequence.\",\n    \"Iterate over each town to calculate the potential initial repertoire durations based on the total concert durations.\",\n    \"Check if the calculated sequence satisfies the conditions for all towns.\",\n    \"If a valid sequence is found, store the sequence; otherwise, mark the test case as impossible.\",\n    \"Format the results for each test case, indicating 'YES' and the sequence if possible, or 'NO' if not.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'circular arrangement'\n    Explanation: The towns are arranged in a circle, meaning the sequence wraps around, and the last town is followed by the first town.\n\n    'repertoire growth'\n    Explanation: Each singer's repertoire grows as they perform in each town, adding a new song of the same duration as their initial repertoire.\n\n# [phrase showing quantity relationship]\n    'exactly one concert'\n    Explanation: Each singer performs exactly one concert in each town, which means the number of concerts equals the number of towns.\n\n    '2 \u22c5 a_i, (k + 2) \u22c5 a_i, n \u22c5 a_i'\n    Explanation: These phrases describe how the concert duration increases in multiples of the initial repertoire as the singer moves from town to town.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the calculation of potential initial repertoire durations and checking their validity can be done in a single loop for efficiency.\n\n# [edge case]\n    1. Test case with n = 1 and b_1 = 1\n       Expected output: YES, 1\n       Explanation: With only one town, the initial repertoire must equal the total concert duration.\n\n    2. Test case with n = 3 and b = [3, 6, 9]\n       Expected output: YES, 1 2 3\n       Explanation: Each town's total duration is a multiple of the initial repertoire, allowing a valid sequence.\n\n    3. Test case with n = 2 and b = [5, 10]\n       Expected output: NO\n       Explanation: The sequence cannot be constructed as the durations do not allow for a consistent initial repertoire.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the calculated sequence satisfies the conditions for all towns, considering the circular nature of the problem.\n\n    Example code snippet:\n    ```python\n    def is_valid_sequence(n, b):\n        a = [0] * n\n        for i in range(n):\n            if b[i] % n != 0:\n                return False, []\n            a[i] = b[i] // n\n        return True, a\n\n    for t in range(test_cases):\n        n = ...\n        b = ...\n        valid, sequence = is_valid_sequence(n, b)\n        if valid:\n", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff + total_a) % n != 0 or (diff + total_a) <= 0:\n                possible = False\n                break\n            a[i] = (diff + total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff + total_a) % n != 0 or (diff + total_a) <= 0:\n                possible = False\n                break\n            a[i] = (diff + total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of towns and the total duration of concerts in each town.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of towns.\",\n        \"Read the array b of n integers, representing the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence a exists for each test case and reconstruct it if possible.\",\n      \"steps\": [\n        \"For each test case, initialize an array a of size n to store the initial duration of repertoire for each singer.\",\n        \"Iterate over each town and calculate the possible values for a_i based on the given b array.\",\n        \"Check if the calculated values for a_i satisfy the conditions for all towns.\",\n        \"If a valid sequence a is found, store it; otherwise, mark the test case as impossible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a valid sequence a was found, print 'YES' followed by the sequence a.\",\n        \"If no valid sequence was found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence a that satisfies the given conditions.\",\n    \"Check the feasibility of the sequence by ensuring the calculated values match the total concert durations in each town.\",\n    \"Output 'YES' and the sequence a if a valid sequence is found, otherwise output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'circular arrangement'\n    Explanation: The towns are arranged in a circle, meaning the sequence wraps around after reaching the last town.\n\n    'repertoire growth'\n    Explanation: Each singer's repertoire grows as they perform in each town, adding the duration of their initial repertoire to their total for subsequent performances.\n\n# [phrase showing quantity relationship]\n    'exactly one concert'\n    Explanation: Each singer performs exactly one concert in each town, which means the number of concerts equals the number of towns.\n\n    'n \u22c5 a_i minutes'\n    Explanation: The concert duration in the last town for a singer is n times their initial repertoire.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the subproblem \"Determine if a valid sequence a exists for each test case and reconstruct it if possible\" should be implemented simultaneously. Specifically, the calculation of possible values for a_i and checking if they satisfy the conditions should be done in a single loop over the towns.\n\n# [edge case]\n    Test case with n = 1 and b_1 = 1\n    Expected output: YES, 1\n    Explanation: With only one town, the initial repertoire must equal the total concert duration.\n\n    Test case with n = 2 and b_1 = b_2 = 2\n    Expected output: YES, 1 1\n    Explanation: Each singer performs for 1 minute in each town, satisfying the total duration.\n\n    Test case with n = 3 and b_1 = b_2 = b_3 = 3\n    Expected output: NO\n    Explanation: It's impossible for each singer to perform for 3 minutes in each town without exceeding the total duration.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the calculated sequence a satisfies the condition for all towns, and handle cases where n = 1 separately.\n    \n    ```python\n    if n == 1:\n        if b[0] % n == 0:\n            print(\"YES\")\n            print(b[0] // n)\n        else:\n            print(\"NO\")\n    else:\n        # Original logic for n > 1\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] % n == 0:\n                results.append(\"YES\")\n                results.append(str(b[0] // n))\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] % n == 0:\n                results.append(\"YES\")\n                results.append(str(b[0] // n))\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of towns.\",\n        \"Read the array b of n integers, which represents the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence a exists for each test case.\",\n      \"steps\": [\n        \"For each test case, check if the sequence a can be reconstructed from the array b.\",\n        \"Consider the mathematical relationship between the sequence a and the array b.\",\n        \"If a valid sequence a can be found, store it; otherwise, mark the test case as impossible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a valid sequence a was found, print 'YES' followed by the sequence a.\",\n        \"If no valid sequence a was found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize a list to store the results for each test case.\",\n    \"Iterate over each test case to parse the input and determine if a valid sequence a exists.\",\n    \"For each test case, apply the mathematical logic to reconstruct the sequence a or determine impossibility.\",\n    \"Store the result ('YES' with sequence a or 'NO') for each test case.\",\n    \"Print the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'circular arrangement'\n    Explanation: The towns are arranged in a circle, meaning the sequence wraps around after reaching the last town.\n\n    'repertoire'\n    Explanation: The initial duration of songs each singer has before starting the concerts.\n\n    'concert duration'\n    Explanation: The total time a singer performs in a town, which increases as they compose new songs in each town.\n\n# [phrase showing quantity relationship]\n    'exactly one concert'\n    Explanation: Each singer performs exactly once in each town, which implies a fixed number of performances per singer.\n\n    'k + 2'\n    Explanation: This indicates the multiplier for the concert duration as the singer moves to the next town. It starts from 1 and increases by 1 for each subsequent town.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan are sequential and do not require simultaneous execution. However, the logic to determine if a valid sequence `a` exists should be carefully implemented to ensure the mathematical relationship is correctly applied.\n\n# [edge case]\n    1. n = 1, b = [1] = YES, 1\n       Explanation: With only one town, the singer's repertoire must match the total concert duration.\n       \n    2. n = 2, b = [2, 2] = NO\n       Explanation: If both towns have the same total duration, it might be impossible to find distinct initial repertoires that satisfy the conditions.\n       \n    3. n = 3, b = [3, 3, 3] = YES, 1 1 1\n       Explanation: Each singer can start with a repertoire of 1, and the total duration matches the requirement.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Specifically, we need to ensure that the logic for reconstructing sequence `a` correctly handles cases where the sum of durations does not allow for a valid sequence.\n    - Implement checks for impossibility based on the mathematical constraints derived from the problem description.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        # Check if total_b is divisible by the sum of the first n natural numbers\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1] if i > 0 else b[i] - b[n - 1]\n            if (diff + total_a) % n != 0 or (diff + total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff + total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        # Check if total_b is divisible by the sum of the first n natural numbers\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1] if i > 0 else b[i] - b[n - 1]\n            if (diff + total_a) % n != 0 or (diff + total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff + total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of towns.\",\n        \"Read the array b of n integers, representing the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence a exists for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize an array a of size n to store the initial repertoire durations.\",\n        \"Iterate over each town and calculate the possible initial repertoire duration a_i for each singer.\",\n        \"Check if the calculated sequence a satisfies the conditions for the total concert durations given in b.\",\n        \"If a valid sequence a is found, store it; otherwise, mark the test case as impossible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a valid sequence a was found, print 'YES' followed by the sequence a.\",\n        \"If no valid sequence was found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence a that satisfies the given conditions.\",\n    \"For each town, calculate the initial repertoire duration for each singer and verify against the total concert durations.\",\n    \"Output 'YES' and the sequence a if a valid sequence is found; otherwise, output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'repertoire': refers to the collection of songs a singer has initially, which increases as they perform in each town.\n    'concert duration': refers to the total time a singer performs in a town, which increases as they compose new songs.\n\n# [phrase showing quantity relationship]\n    '2 \u22c5 a_i': means the concert duration in the next town is twice the initial repertoire duration.\n    '(k + 2) \u22c5 a_i': means the concert duration increases by a factor of (k + 2) times the initial repertoire duration as the singer moves to subsequent towns.\n    'n \u22c5 a_i': means the concert duration in the last town is n times the initial repertoire duration.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps to parse input and determine if a valid sequence exists should be implemented simultaneously for efficiency. Specifically, parsing the input and initializing the array a can be done in one block, followed by the calculation and verification steps in another block.\n\n# [edge case]\n    Test case with n = 1 and b = [1] = YES, 1\n    Explanation: With only one town, the singer's initial repertoire matches the total concert duration.\n    \n    Test case with n = 2 and b = [2, 4] = YES, 1 2\n    Explanation: The first singer performs for 1 minute in the first town and 2 minutes in the second town. The second singer performs for 2 minutes in the first town and 4 minutes in the second town.\n    \n    Test case with n = 3 and b = [3, 6, 9] = YES, 1 2 3\n    Explanation: Each singer's concert duration matches the pattern described, with the initial repertoire being 1, 2, and 3 respectively.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n = 1 or the sequence b does not allow a valid sequence a.\n    ```python\n    if n == 1:\n        if b[0] % n == 0:\n            print(\"YES\")\n            print(b[0] // n)\n        else:\n            print(\"NO\")\n    else:\n        # Implement logic to check if a valid sequence a can be reconstructed\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] % n == 0:\n                results.append(\"YES\")\n                results.append(str(b[0] // n))\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_sum = sum(b)\n        if total_sum % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a_sum = total_sum // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev_index = (i - 1 + n) % n\n            diff = b[i] - b[prev_index]\n            if (total_a_sum - diff) % n != 0 or (total_a_sum - diff) // n <= 0:\n                possible = False\n                break\n            a[i] = (total_a_sum - diff) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] % n == 0:\n                results.append(\"YES\")\n                results.append(str(b[0] // n))\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_sum = sum(b)\n        if total_sum % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a_sum = total_sum // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev_index = (i - 1 + n) % n\n            diff = b[i] - b[prev_index]\n            if (total_a_sum - diff) % n != 0 or (total_a_sum - diff) // n <= 0:\n                possible = False\n                break\n            a[i] = (total_a_sum - diff) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of towns.\",\n        \"Read the array b of n integers, which represents the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence of initial repertoire durations exists for each test case.\",\n      \"steps\": [\n        \"For each test case, attempt to reconstruct the sequence a of initial repertoire durations.\",\n        \"Check if the sequence a satisfies the condition that the total duration of concerts in each town matches the given array b.\",\n        \"If a valid sequence a is found, store it; otherwise, mark the test case as impossible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a valid sequence a was found, print 'YES' followed by the sequence a.\",\n        \"If no valid sequence was found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence of initial repertoire durations.\",\n    \"Check the validity of the reconstructed sequence against the given total durations.\",\n    \"Output 'YES' and the sequence if valid, or 'NO' if no valid sequence exists.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'repertoire': refers to the initial duration of songs each singer has before starting the concerts.\n    'concert duration': refers to the total time a singer performs in each town, which increases as they compose new songs.\n\n# [phrase showing quantity relationship]\n    '2 \u22c5 a_i': means the concert duration in the next town is twice the initial repertoire.\n    '(k + 2) \u22c5 a_i': means the concert duration increases by a factor of (k + 2) times the initial repertoire as the singer moves to the next town.\n    'n \u22c5 a_i': means the concert duration in the last town is n times the initial repertoire.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps to parse the input and determine the sequence should be implemented simultaneously for efficiency. Specifically, parsing the input and reconstructing the sequence can be done in a single loop for each test case.\n\n# [edge case]\n    Test case with n = 1 and b = [1] = YES, 1\n    Explanation: With only one town, the initial repertoire must match the total concert duration.\n    \n    Test case with n = 2 and b = [2, 4] = YES, 1 2\n    Explanation: The first singer performs for 1 and 2 minutes, and the second singer performs for 2 and 4 minutes.\n    \n    Test case with n = 3 and b = [3, 6, 9] = YES, 1 2 3\n    Explanation: Each singer's concert duration matches the pattern described, with increasing multiples of their initial repertoire.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the reconstructed sequence matches the total concert durations for each town, and handle cases where n = 1 separately.\n    ```\n    if n == 1:\n        if b[0] % n == 0:\n            print(\"YES\")\n            print(b[0] // n)\n        else:\n            print(\"NO\")\n    else:\n        # Implement logic to reconstruct sequence a\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] % n == 0:\n                results.append(\"YES\")\n                results.append(str(b[0] // n))\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_sum = sum(b)\n        if total_sum % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a_sum = total_sum // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (total_a_sum - diff) % n != 0 or (total_a_sum - diff) // n <= 0:\n                possible = False\n                break\n            a[i] = (total_a_sum - diff) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 99)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] % n == 0:\n                results.append(\"YES\")\n                results.append(str(b[0] // n))\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_sum = sum(b)\n        if total_sum % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a_sum = total_sum // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (total_a_sum - diff) % n != 0 or (total_a_sum - diff) // n <= 0:\n                possible = False\n                break\n            a[i] = (total_a_sum - diff) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of towns and the total duration of concerts in each town.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Parsed data structure containing test cases\"\n    },\n    {\n      \"description\": \"For each test case, determine if a valid sequence of initial repertoire durations exists that satisfies the given total concert durations for each town.\",\n      \"input\": \"Parsed data structure for a single test case\",\n      \"output\": \"Boolean indicating if a valid sequence exists\"\n    },\n    {\n      \"description\": \"If a valid sequence exists, reconstruct one possible sequence of initial repertoire durations for the singers.\",\n      \"input\": \"Parsed data structure for a single test case\",\n      \"output\": \"Sequence of initial repertoire durations or indication of impossibility\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, initialize variables to store the number of towns and the total concert durations for each town.\",\n    \"Iterate over each test case and attempt to reconstruct a valid sequence of initial repertoire durations:\",\n    \"  a. For each town, calculate the possible initial repertoire duration for the singer based on the total concert durations.\",\n    \"  b. Check if the calculated sequence satisfies the conditions for all towns.\",\n    \"  c. If a valid sequence is found, store it; otherwise, mark the test case as impossible.\",\n    \"Output the results for each test case, indicating 'YES' and the sequence if possible, or 'NO' if not.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'repertoire': refers to the initial duration of songs each singer has before starting the concerts.\n    'concert duration': refers to the total time each singer performs in each town, which increases as they compose new songs.\n\n# [phrase showing quantity relationship]\n    '2 \u22c5 a_i': means the concert duration in the next town is twice the initial repertoire.\n    '(k + 2) \u22c5 a_i': means the concert duration increases by a factor of (k + 2) times the initial repertoire as the singer moves to the next town.\n    'n \u22c5 a_i': means the concert duration in the last town is n times the initial repertoire.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for parsing input and reconstructing the sequence should be implemented simultaneously for efficiency. Specifically, parsing the input and initializing variables can be done in one code block, followed by the logic to reconstruct the sequence.\n\n# [edge case]\n    Test case with n = 1 and b_1 = 1: \n    Expected output: YES, 1\n    Explanation: With only one town, the singer's initial repertoire matches the total concert duration.\n    \n    Test case with n = 2 and b_1 = 2, b_2 = 4:\n    Expected output: YES, 1 2\n    Explanation: The first singer performs for 1 minute in the first town and 2 minutes in the second town, while the second singer performs for 2 minutes in the first town and 4 minutes in the second town.\n    \n    Test case with n = 3 and b_1 = 3, b_2 = 6, b_3 = 9:\n    Expected output: YES, 1 2 3\n    Explanation: Each singer's initial repertoire matches the total concert duration divided by the number of towns.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the sequence is impossible.\n        if n == 1 and b[0] != 1:\n            print(\"NO\")\n        else:\n            # Implement logic to check if a valid sequence can be reconstructed\n            # If not, print \"NO\"\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] == 1:\n                results.append(\"YES\")\n                results.append(\"1\")\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nif __name__ == \"__main__\":\n    solve()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, true, false, false, false, false, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 556, "prompt": "n towns are arranged in a circle sequentially. The towns are numbered from 1 to n in clockwise order. In the i-th town, there lives a singer with a repertoire of a_i minutes for each i \u2208 [1, n].\n\nEach singer visited all n towns in clockwise order, starting with the town he lives in, and gave exactly one concert in each town. Additionally, while performing in each town, the i-th singer found inspiration and composed a new song that lasted a_i minutes. This song was added to his repertoire so that he could perform it in the rest of the cities.\n\nHence, for the i-th singer, the concert in the i-th town will last a_i minutes, in the (i + 1)-th town the concert will last 2 \u22c5 a_i minutes, ..., in the ((i + k) mod n + 1)-th town the duration of the concert will be (k + 2) \u22c5 a_i, ..., in the town ((i + n - 2) mod n + 1) \u2014 n \u22c5 a_i minutes.\n\nYou are given an array of b integer numbers, where b_i is the total duration of concerts in the i-th town. Reconstruct any correct sequence of positive integers a or say that it is impossible.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of two lines. The first line contains a single integer n (1 \u2264 n \u2264 4 \u22c5 10^4) \u2014 the number of cities. The second line contains n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 10^{9}) \u2014 the total duration of concerts in i-th city.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print the answer as follows:\n\nIf there is no suitable sequence a, print NO. Otherwise, on the first line print YES, on the next line print the sequence a_1, a_2, ..., a_n of n integers, where a_i (1 \u2264 a_i \u2264 10^{9}) is the initial duration of repertoire of the i-th singer. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n\n\nOutput\n\n\nYES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n\nNote\n\nLet's consider the 1-st test case of the example:\n\n  1. the 1-st singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 6 minutes, in the 3-rd \u2014 for 9 minutes; \n  2. the 2-nd singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 1 minute, in the 3-rd - for 2 minutes; \n  3. the 3-rd singer in the 1-st city will give a concert for 6 minutes, in the 2-nd \u2014 for 9 minutes, in the 3-rd \u2014 for 3 minutes. ", "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of two lines. The first line contains a single integer n (1 \u2264 n \u2264 4 \u22c5 10^4) \u2014 the number of cities. The second line contains n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 10^{9}) \u2014 the total duration of concerts in i-th city.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print the answer as follows:\n\nIf there is no suitable sequence a, print NO. Otherwise, on the first line print YES, on the next line print the sequence a_1, a_2, ..., a_n of n integers, where a_i (1 \u2264 a_i \u2264 10^{9}) is the initial duration of repertoire of the i-th singer. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n\n\nOutput\n\n\nYES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n\nNote\n\nLet's consider the 1-st test case of the example:\n\n  1. the 1-st singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 6 minutes, in the 3-rd \u2014 for 9 minutes; \n  2. the 2-nd singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 1 minute, in the 3-rd - for 2 minutes; \n  3. the 3-rd singer in the 1-st city will give a concert for 6 minutes, in the 2-nd \u2014 for 9 minutes, in the 3-rd \u2014 for 3 minutes. ", "mutate_method": "expand_one2two", "save_node": false, "parent_index": 45}
