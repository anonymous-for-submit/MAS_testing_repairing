{"name": "1580_C. Train Maintenance", "description": "Kawasiro Nitori is excellent in engineering. Thus she has been appointed to help maintain trains.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment. In the beginning, there are no trains, at each of the following m days, one train will be added, or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance in each day.\n\nOn a day a train is removed, it is not counted as in maintenance.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.", "tags": ["brute force", "data structures", "implementation"], "difficulty": 9, "id": 1580, "sample_io": [{"input": "3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}], "test_list": [{"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n10 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "3 4\n10 15\n12 10\n2 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "3 4\n23 15\n14 10\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n2 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n2 19\n7 19\n2 9\n26 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n5\n4\n3\n5\n7\n8\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n21 15\n7 3\n19 7\n1 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n2\n2\n2\n1\n2\n3\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n5\n4\n3\n5\n7\n8\n"]}, {"input": "5 2\n1 1\n10000011 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n1 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "10 7\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n8 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n8\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n3 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 2\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n0\n"]}, {"input": "20 7\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n4 9\n5 10\n657453515 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n3 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n"]}, {"input": "3 2\n9 15\n12 9\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n2 9\n14 19\n7 19\n2 9\n21 15\n7 3\n19 7\n1 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n2\n2\n2\n1\n3\n4\n4\n4\n4\n5\n5\n4\n3\n4\n6\n8\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 9\n2 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 2\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n3 9\n49 15\n7 6\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n6\n5\n6\n7\n7\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n1 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n14 9\n14 19\n7 19\n2 9\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n4\n3\n4\n7\n8\n"]}, {"input": "3 4\n16 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 15\n15 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 15\n10 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "3 4\n10 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000011 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 000000000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "3 4\n9 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n9 15\n12 1\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 0\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n733475792 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n13 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n467159628 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 8\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000001 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1258790837 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n26 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 0\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000011 100000000\n998244353 1\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n9 15\n12 0\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n21 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n13 15\n14 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n369260158 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n16 16\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n26 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n16 6\n2 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n23 15\n14 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n2 1\n10000001 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n2 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n450441171 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000101 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 7\n15 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "3 4\n16 15\n10 17\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000011 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000011 000000000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n9 15\n12 9\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 -1\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 241782432\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n2 1\n1 5\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 801909796\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n5 15\n12 10\n2 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "5 4\n1 1\n10000000 100000001\n733475792 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 8\n12 18\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10001011 100000000\n998244353 1\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n2 1\n10000011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n1166046831 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n26 15\n10 17\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000011 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000011 000000000\n998244353 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1425917046 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 241782432\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 11\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "20 20\n1 4\n864803385 801909796\n17 4\n12 1\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "5 4\n1 1\n10000000 100000001\n733475792 1\n2 2\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "3 4\n16 8\n12 25\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 2\n10000011 100000000\n998244353 0\n2 2\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1011185365 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000001\n733475792 0\n2 2\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 2\n1 1\n", "output": ["0\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n211018821 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n211018821 0\n3 1\n2 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "5 4\n3 1\n10000011 101000000\n211018821 0\n3 1\n2 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n4 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "3 4\n14 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 1\n2 1\n1 3\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 15\n12 15\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 0\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n14 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000011 000000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 1\n9 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n"]}, {"input": "5 4\n1 1\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n9 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n10 18\n12 10\n2 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n733475792 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n22 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 0\n430995384 733598623\n2 9\n5 13\n433415385 169535970\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n9 6\n752625088 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1258790837 0\n3 0\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 173113793\n3 10\n16 6\n2 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n2 2\n10000001 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n9 6\n450441171 733598623\n2 9\n3 10\n433415385 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n16 21\n10 17\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n9 6\n12 9\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1683854825 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 241782432\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 38795044\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n2 1\n1 10\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 0\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "3 4\n16 12\n12 18\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n4 1\n10000011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n1908812372 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n2 1\n", "output": ["0\n"]}, {"input": "5 4\n3 1\n10010011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 2\n10000011 100000000\n998244353 0\n2 4\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 2\n1 2\n", "output": ["0\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n211018821 0\n4 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n3 1\n10000011 101000000\n211018821 0\n3 1\n2 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n4 29\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "3 4\n14 15\n12 13\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 1\n3 1\n1 3\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n2 1\n10000001 100000000\n998244353 0\n2 0\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n14 15\n10 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "3 1\n9 15\n12 9\n2 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n"]}, {"input": "5 4\n1 1\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 4\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 0\n430995384 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n9 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n2 2\n10000001 100000000\n1258790837 0\n5 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n5\n4\n3\n5\n7\n8\n"]}, {"input": "5 2\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n"]}, {"input": "3 4\n16 21\n10 17\n2 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1683854825 0\n3 1\n2 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n4 1\n1 10\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "5 1\n1 0\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n3 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "3 4\n16 12\n12 22\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000000 100000000\n1908812372 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000101 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n2 1\n", "output": ["0\n"]}, {"input": "5 1\n1 1\n10000101 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 2\n1 2\n", "output": ["0\n"]}, {"input": "3 1\n9 15\n12 9\n2 2\n1 3\n1 1\n1 1\n2 3\n", "output": ["0\n"]}, {"input": "5 4\n1 0\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 4\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n0 0\n430995384 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 2\n1 1\n10000000 100010000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n"]}, {"input": "10 7\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 1\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 9\n2 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "3 4\n1 12\n12 22\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000000 100000000\n1908812372 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n2 1\n10000101 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n2 1\n", "output": ["0\n"]}, {"input": "3 1\n9 15\n12 9\n2 4\n1 3\n1 1\n1 1\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n0 0\n140846265 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 9\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n8\n"]}, {"input": "5 2\n1 2\n10000000 100010000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n"]}, {"input": "10 7\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 1\n2 9\n1 1\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 13\n2 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n12 9\n2 4\n1 3\n1 1\n0 1\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n-1 0\n140846265 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 7\n3 10\n9 6\n529113291 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 1\n2 9\n1 1\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "3 1\n9 15\n12 9\n2 4\n1 3\n1 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 7\n3 10\n-1 0\n140846265 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n17 2\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n292159474 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n3 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n7\n"]}, {"input": "3 1\n9 15\n12 11\n2 4\n1 3\n1 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 2\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n12 11\n2 4\n1 3\n0 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 1\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n12 11\n4 4\n1 3\n0 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 1\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 6\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n16 11\n4 4\n1 3\n0 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 0\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 6\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 -1\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 6\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 2\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n0 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n2 1\n10000001 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}], "task_id": "codecontest/22", "repair_prompt": ["Kawasiro Nitori is excellent in engineering, thus she has been appointed to help maintain trains.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment. Initially, there are no trains, and at each of the following m days, one train will be added or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, and then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance each day.\n\nOn a day a train is removed, it is not counted as in maintenance. Make sure to account for all transitions between working and maintenance periods accurately in your calculations. Consider edge cases where trains might have overlapping maintenance periods or synchronized cycles.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Kawasiro Nitori is excellent in engineering. Consequently, she has been appointed to help maintain trains.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment. Initially, there are no trains, and at each of the following m days, one train will be added or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, and then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance each day.\n\nOn a day a train is removed, it is not counted as in maintenance. Make sure to account for all transitions between working and maintenance periods accurately in your calculations. Consider edge cases where trains might have overlapping maintenance periods or synchronized cycles.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Kawasiro Nitori is excellent in engineering, thus she has been appointed to help maintain trains. There are n models of trains, and Nitori's department will only have at most one train of each model at any moment, and initially there are no trains and at each of the following m days, one train will be added or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, and then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance each day. On a day a train is removed, it is not counted as in maintenance, and make sure to account for all transitions between working and maintenance periods accurately in your calculations. Consider edge cases where trains might have overlapping maintenance periods or synchronized cycles.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    # Read the working and maintenance periods for each train model\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_cycles.append((x_i, y_i))\n    \n    # Read the operations for each day\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize the state of each train model\n    train_states = [None] * n  # None means no train of this model is added\n    \n    # Result list to store the number of trains in maintenance each day\n    results = []\n    \n    # Process each day's operation\n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            train_states[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n        \n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Calculate the number of trains in maintenance\n        maintenance_count = 0\n        for state in train_states:\n            if state is not None:\n                added_day, x_i, y_i = state\n                total_cycle = x_i + y_i\n                days_since_added = day - added_day\n                \n                # Determine the current cycle position\n                cycle_position = days_since_added % total_cycle\n                \n                # Check if the train is in maintenance\n                if cycle_position >= x_i:\n                    maintenance_count += 1\n        \n        # Store the result for the current day\n        results.append(maintenance_count)\n    \n    # Output the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: None if not present, otherwise the day it was added\n    train_states = [None] * n\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_states[k] = day\n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Calculate the number of trains in maintenance\n        count_in_maintenance = 0\n        for model in range(n):\n            if train_states[model] is not None:\n                added_day = train_states[model]\n                x_i, y_i = train_cycles[model]\n                total_cycle = x_i + y_i\n                days_since_added = day - added_day\n                \n                # Determine if the train is in maintenance\n                if days_since_added >= x_i:\n                    cycle_position = days_since_added % total_cycle\n                    if cycle_position >= x_i:\n                        count_in_maintenance += 1\n        \n        maintenance_count[day] = count_in_maintenance\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    # Read the working and maintenance periods for each train model\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_cycles.append((x_i, y_i))\n    \n    # Read the operations for each day\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize the state of each train model\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            train_states[k] = (0, x_i, y_i)  # (current day in cycle, x_i, y_i)\n        \n        elif op == 2:  # Remove train of model k\n            if train_states[k] is not None:\n                current_day_in_cycle, x_i, y_i = train_states[k]\n                # If it was in maintenance, decrease the maintenance count\n                if current_day_in_cycle >= x_i:\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update the cycle for each active train\n        for i in range(n):\n            if train_states[i] is not None:\n                current_day_in_cycle, x_i, y_i = train_states[i]\n                if current_day_in_cycle < x_i + y_i - 1:\n                    current_day_in_cycle += 1\n                else:\n                    current_day_in_cycle = 0\n                \n                # Check if it is in maintenance\n                if current_day_in_cycle == x_i:\n                    maintenance_count += 1\n                elif current_day_in_cycle == x_i + y_i:\n                    maintenance_count -= 1\n                \n                train\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: (is_active, current_day_in_cycle)\n    train_states = [None] * n\n    maintenance_count = 0\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            train_states[k] = (True, 0)  # Start at day 0 of the cycle\n        elif op == 2:  # Remove train of model k\n            is_active, current_day_in_cycle = train_states[k]\n            if is_active and current_day_in_cycle >= train_cycles[k][0]:\n                maintenance_count -= 1\n            train_states[k] = None\n        \n        # Update maintenance count\n        current_maintenance_count = 0\n        for i in range(n):\n            if train_states[i] is not None:\n                is_active, current_day_in_cycle = train_states[i]\n                x_i, y_i = train_cycles[i]\n                \n                if current_day_in_cycle >= x_i:\n                    current_maintenance_count += 1\n                \n                # Update the cycle day\n                total_cycle = x_i + y_i\n                train_states[i] = (is_active, (current_day_in_cycle + 1) % total_cycle)\n        \n        results.append(current_maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_maintenance_days(n, m, train_cycles, operations):\n    train_states = [None] * n  # None means no train, otherwise store the cycle start day\n    maintenance_counts = []\n\n    for day in range(m):\n        op, k = operations[day]\n        k -= 1  # Convert to zero-based index\n\n        if op == 1:  # Add train\n            train_states[k] = day\n        elif op == 2:  # Remove train\n            train_states[k] = None\n\n        # Calculate number of trains in maintenance\n        maintenance_count = 0\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i = train_cycles[i]\n                cycle_length = x_i + y_i\n                days_since_added = day - train_states[i]\n                if days_since_added >= x_i and (days_since_added % cycle_length) < y_i:\n                    maintenance_count += 1\n\n        maintenance_counts.append(maintenance_count)\n\n    return maintenance_counts\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1])\n        operations.append((op, k))\n        index += 2\n\n    maintenance_counts = calculate_maintenance_days(n, m, train_cycles, operations)\n\n    for count in maintenance_counts:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_maintenance_days(n, m, train_cycles, operations):\n    # Initialize the state of each train model\n    train_state = [None] * n  # None means no train of that model is present\n    maintenance_count = [0] * m  # To store the number of trains in maintenance each day\n\n    # Iterate over each day's operations\n    for day in range(m):\n        op, k = operations[day]\n        k -= 1  # Convert to zero-based index\n\n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            train_state[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n\n        elif op == 2:  # Remove train of model k\n            train_state[k] = None  # Remove the train\n\n        # Calculate the number of trains in maintenance for the current day\n        maintenance_count[day] = 0\n        for i in range(n):\n            if train_state[i] is not None:\n                start_day, x_i, y_i = train_state[i]\n                cycle_length = x_i + y_i\n                days_since_added = day - start_day\n\n                # Determine if the train is in maintenance\n                if days_since_added >= x_i:\n                    cycle_position = days_since_added % cycle_length\n                    if cycle_position >= x_i:\n                        maintenance_count[day] += 1\n\n    return maintenance_count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    # Parse the input\n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1])\n        operations.append((op, k))\n        index += 2\n\n    # Calculate maintenance days\n    maintenance_days = calculate_maintenance_days(n, m, train_cycles, operations)\n\n    # Output the result\n    for count in maintenance_days:\n        print(count)\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        cycles.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking for each train model\n    train_states = {}\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            x_i, y_i = cycles[k]\n            train_states[k] = (day, x_i, y_i)  # (start_day, work_days, maintenance_days)\n        \n        elif op == 2:  # Remove train\n            if k in train_states:\n                del train_states[k]\n        \n        # Calculate maintenance count for the current day\n        count = 0\n        for start_day, x_i, y_i in train_states.values():\n            total_cycle = x_i + y_i\n            days_since_start = day - start_day\n            if days_since_start >= x_i:\n                # Check if the train is in maintenance\n                if (days_since_start - x_i) % total_cycle < y_i:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    # Read x_i and y_i for each train model\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    # Initialize train states\n    train_states = [None] * n  # None means no train of this model is present\n    \n    # Prepare to store results\n    results = []\n    \n    # Process each day's operation\n    for day in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        index += 2\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            train_states[k] = (0, x_i, y_i)  # (current_day_in_cycle, x_i, y_i)\n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Count trains in maintenance\n        maintenance_count = 0\n        for state in train_states:\n            if state is not None:\n                current_day_in_cycle, x_i, y_i = state\n                # Check if the train is in maintenance\n                if current_day_in_cycle >= x_i:\n                    maintenance_count += 1\n        \n        # Store the result for the current day\n        results.append(maintenance_count)\n        \n        # Update the cycle day for each train\n        for i in range(n):\n            if train_states[i] is not None:\n                current_day_in_cycle, x_i, y_i = train_states[i]\n                total_cycle_length = x_i + y_i\n                # Move to the next day in the cycle\n                train_states[i] = ((current_day_in_cycle + 1) % total_cycle_length, x_i, y_i)\n    \n    # Output the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: -1 means not present, otherwise it stores the current day in the cycle\n    train_state = [-1] * n\n    \n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_state[k] = 0  # Start at the beginning of the cycle\n        elif op == 2:  # Remove train\n            train_state[k] = -1\n        \n        # Update the cycle positions and count maintenance trains\n        current_maintenance_count = 0\n        for i in range(n):\n            if train_state[i] != -1:\n                x_i, y_i = work_maintenance[i]\n                cycle_length = x_i + y_i\n                if train_state[i] >= x_i:\n                    current_maintenance_count += 1\n                train_state[i] = (train_state[i] + 1) % cycle_length\n        \n        results.append(current_maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    # Read train model periods\n    train_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_periods.append((x_i, y_i))\n    \n    # Read operations\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize train states\n    train_states = {}\n    maintenance_count = [0] * m\n    \n    # Process each day\n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            x_i, y_i = train_periods[k]\n            train_states[k] = (day, x_i, y_i)  # Store the start day and periods\n        elif op == 2:  # Remove train\n            if k in train_states:\n                del train_states[k]\n        \n        # Calculate number of trains in maintenance\n        count_in_maintenance = 0\n        for start_day, x_i, y_i in train_states.values():\n            cycle_length = x_i + y_i\n            days_since_start = day - start_day\n            if days_since_start >= x_i:\n                # Check if the train is in maintenance\n                if (days_since_start - x_i) % cycle_length < y_i:\n                    count_in_maintenance += 1\n        \n        maintenance_count[day] = count_in_maintenance\n    \n    # Output the result for each day\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    # Read the working and maintenance periods for each train model\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_cycles.append((x_i, y_i))\n    \n    # Read the operations for each day\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize the state of each train model\n    train_states = [None] * n  # None means no train of this model is added\n    \n    # Result list to store the number of trains in maintenance each day\n    results = []\n    \n    # Process each day's operation\n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            train_states[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n        \n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Calculate the number of trains in maintenance\n        maintenance_count = 0\n        for state in train_states:\n            if state is not None:\n                added_day, x_i, y_i = state\n                total_cycle = x_i + y_i\n                days_since_added = day - added_day\n                \n                # Determine the current cycle position\n                cycle_position = days_since_added % total_cycle\n                \n                # Check if the train is in maintenance\n                if cycle_position >= x_i:\n                    maintenance_count += 1\n        \n        # Store the result for the current day\n        results.append(maintenance_count)\n    \n    # Output the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the working and maintenance periods for each train model, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the working (x_i) and maintenance (y_i) periods for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Track the state of each train model over the days, including whether it is currently added and its current cycle position (working or maintenance).\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the state of each train model (e.g., added or removed, current cycle position).\",\n        \"For each operation, update the state of the corresponding train model.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day based on the current state of all train models.\",\n      \"steps\": [\n        \"For each day, iterate over all train models to determine if they are in the maintenance period.\",\n        \"Count the number of trains in maintenance and store the result for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, output the calculated number of trains in maintenance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data about train models and daily operations.\",\n    \"Initialize a data structure to track the state of each train model.\",\n    \"Iterate over each day's operations, updating the state of the train models accordingly.\",\n    \"For each day, calculate the number of trains in maintenance based on their current states.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models'\n    Explanation: Refers to different types of trains, each with its own working and maintenance cycle.\n\n    'working and maintenance periods'\n    Explanation: Each train model has a specific number of days it works (x_i) and a specific number of days it is in maintenance (y_i).\n\n    'operations'\n    Explanation: Daily actions that either add or remove a train of a specific model.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model'\n    Explanation: There can be zero or one train of each model at any time, but not more than one.\n\n    'x_i days', 'y_i days'\n    Explanation: These specify the duration of the working and maintenance periods for each train model.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the subproblem \"Track the state of each train model over the days\" should be implemented simultaneously. Specifically, updating the state of the train model and determining its current cycle position (working or maintenance) should be done in one code block to ensure accurate tracking of each train's status.\n\n# [edge case]\n    1. Input: 1 1\n             1 1\n             1 1\n       Output: 0\n       Explanation: On the first day, a train is added and it starts working, so no train is in maintenance.\n\n    2. Input: 1 2\n             1 1\n             1 1\n             2 1\n       Output: 0\n               0\n       Explanation: On the first day, a train is added and it starts working. On the second day, the train is removed, so no train is in maintenance on either day.\n\n    3. Input: 2 3\n             1 1\n             1 1\n             1 1\n             1 2\n             2 1\n       Output: 0\n               0\n               0\n       Explanation: On the first day, a train of model 1 is added and starts working. On the second day, a train of model 2 is added and starts working. On the third day, the train of model 1 is removed, so no train is in maintenance on any day.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Specifically, we need", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    # Read the working and maintenance periods for each train model\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_cycles.append((x_i, y_i))\n    \n    # Read the operations for each day\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize the state of each train model\n    train_states = [None] * n  # None means no train of this model is added\n    \n    # Result list to store the number of trains in maintenance each day\n    results = []\n    \n    # Process each day's operation\n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            train_states[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n        \n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Calculate the number of trains in maintenance\n        maintenance_count = 0\n        for state in train_states:\n            if state is not None:\n                added_day, x_i, y_i = state\n                total_cycle = x_i + y_i\n                days_since_added = day - added_day\n                \n                # Determine the current cycle position\n                cycle_position = days_since_added % total_cycle\n                \n                # Check if the train is in maintenance\n                if cycle_position >= x_i:\n                    maintenance_count += 1\n        \n        # Store the result for the current day\n        results.append(maintenance_count)\n    \n    # Output the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the working and maintenance periods for each train model, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get x_i and y_i for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over m days, tracking their working and maintenance periods.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current state of each train model (whether it is added or removed).\",\n        \"For each day, update the state based on the operation (add or remove) and adjust the working and maintenance periods accordingly.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, iterate over the current state of all train models.\",\n        \"Determine if each train is in its maintenance period based on its cycle (x_i days working, y_i days maintenance).\",\n        \"Count the number of trains in maintenance and store the result for that day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each of the m days.\",\n      \"steps\": [\n        \"Print the calculated number of trains in maintenance for each day in sequence.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Initialize data structures to track train states and cycles.\",\n    \"Simulate the daily operations, updating train states and cycles.\",\n    \"Calculate and store the number of trains in maintenance for each day.\",\n    \"Output the results for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'maintenance': refers to the period when a train is not operational and is being serviced.\n    'working period': refers to the period when a train is operational and running.\n    'cycle': refers to the alternating periods of working and maintenance for each train model.\n\n# [phrase showing quantity relationship]\n    'at most one train': means that there can be zero or one train of each model at any time.\n    'x_i days': refers to the number of days a train works before going into maintenance.\n    'y_i days': refers to the number of days a train is in maintenance before returning to work.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to simulating the addition and removal of trains and calculating the number of trains in maintenance should be considered simultaneously. Specifically, updating the state of trains and checking their maintenance status should be done in the same loop for each day.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: On the first day, a train is added and it is in its working period, so no train is in maintenance.\n\n    Input: 1 2\n           1 1\n           1 1\n           2 1\n    Output: 0\n    Explanation: On the first day, a train is added and it is in its working period. On the second day, the train is removed, so no train is in maintenance.\n\n    Input: 2 3\n           1 1\n           1 1\n           1 1\n           1 2\n           2 1\n    Output: 0\n            0\n            0\n    Explanation: On the first day, a train of model 1 is added and is in its working period. On the second day, a train of model 2 is added and is in its working period. On the third day, the train of model 1 is removed, so no train is in maintenance.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where trains are added and removed on the same day or have synchronized cycles.\n    Code for handling the edge case:\n    ```python\n    def handle_edge_cases(train_states, x, y, op, k):\n        if op == 1: ", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: None if not present, otherwise the day it was added\n    train_states = [None] * n\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_states[k] = day\n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Calculate the number of trains in maintenance\n        count_in_maintenance = 0\n        for model in range(n):\n            if train_states[model] is not None:\n                added_day = train_states[model]\n                x_i, y_i = train_cycles[model]\n                total_cycle = x_i + y_i\n                days_since_added = day - added_day\n                \n                # Determine if the train is in maintenance\n                if days_since_added >= x_i:\n                    cycle_position = days_since_added % total_cycle\n                    if cycle_position >= x_i:\n                        count_in_maintenance += 1\n        \n        maintenance_count[day] = count_in_maintenance\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 107)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: None if not present, otherwise the day it was added\n    train_states = [None] * n\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_states[k] = day\n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Calculate the number of trains in maintenance\n        count_in_maintenance = 0\n        for model in range(n):\n            if train_states[model] is not None:\n                added_day = train_states[model]\n                x_i, y_i = train_cycles[model]\n                total_cycle = x_i + y_i\n                days_since_added = day - added_day\n                \n                # Determine if the train is in maintenance\n                if days_since_added >= x_i:\n                    cycle_position = days_since_added % total_cycle\n                    if cycle_position >= x_i:\n                        count_in_maintenance += 1\n        \n        maintenance_count[day] = count_in_maintenance\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), and the list of train operations.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the working and maintenance periods (x_i, y_i) for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Track the state of each train model over the m days.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current state (working or maintenance) and cycle position for each train model.\",\n        \"Update the state of the train model based on the operation (add or remove) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"Iterate over each day and update the cycle position for each active train model.\",\n        \"Check if the train model is in maintenance based on its cycle position.\",\n        \"Count the number of trains in maintenance and store the result for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each day.\",\n      \"steps\": [\n        \"Print the number of trains in maintenance for each of the m days.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Initialize data structures to track train states and cycles.\",\n    \"Iterate over each day to update train states and calculate maintenance counts.\",\n    \"Output the maintenance count for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'maintenance': refers to the period when a train is not operational and is being serviced.\n    'cycle': refers to the alternating periods of working and maintenance for each train model.\n\n# [phrase showing quantity relationship]\n    'at most one train': means that there can be zero or one train of each model at any time.\n    'x_i days', 'y_i days': specify the duration of working and maintenance periods for each train model.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the subproblem \"Track the state of each train model over the m days\" should be implemented simultaneously. Specifically, updating the state of the train model based on the operation (add or remove) and updating the cycle position should be handled together in the same code block for each day.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: On the first day, a train is added and it is in the working period, so no train is in maintenance.\n\n    Input: 1 2\n           1 1\n           1 1\n           2 1\n    Output: 0\n            0\n    Explanation: On the first day, a train is added and it is in the working period. On the second day, the train is removed, so no train is in maintenance.\n\n    Input: 2 3\n           1 1\n           1 1\n           1 1\n           1 2\n           2 1\n    Output: 0\n            0\n            0\n    Explanation: On the first day, a train of model 1 is added and it is in the working period. On the second day, a train of model 2 is added and it is also in the working period. On the third day, the train of model 1 is removed, so no train is in maintenance.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of updating the cycle position and checking the maintenance state will handle these cases correctly.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    # Read the working and maintenance periods for each train model\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_cycles.append((x_i, y_i))\n    \n    # Read the operations for each day\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize the state of each train model\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            train_states[k] = (0, x_i, y_i)  # (current day in cycle, x_i, y_i)\n        \n        elif op == 2:  # Remove train of model k\n            if train_states[k] is not None:\n                current_day_in_cycle, x_i, y_i = train_states[k]\n                # If it was in maintenance, decrease the maintenance count\n                if current_day_in_cycle >= x_i:\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update the cycle for each active train\n        for i in range(n):\n            if train_states[i] is not None:\n                current_day_in_cycle, x_i, y_i = train_states[i]\n                if current_day_in_cycle < x_i + y_i - 1:\n                    current_day_in_cycle += 1\n                else:\n                    current_day_in_cycle = 0\n                \n                # Check if it is in maintenance\n                if current_day_in_cycle == x_i:\n                    maintenance_count += 1\n                elif current_day_in_cycle == x_i + y_i:\n                    maintenance_count -= 1\n                \n                train", "report": "The compilation output of the preceding code is: main() takes 0 positional arguments but 1 was given"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    # Read the working and maintenance periods for each train model\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_cycles.append((x_i, y_i))\n    \n    # Read the operations for each day\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize the state of each train model\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            train_states[k] = (0, x_i, y_i)  # (current day in cycle, x_i, y_i)\n        \n        elif op == 2:  # Remove train of model k\n            if train_states[k] is not None:\n                current_day_in_cycle, x_i, y_i = train_states[k]\n                # If it was in maintenance, decrease the maintenance count\n                if current_day_in_cycle >= x_i:\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update the cycle for each active train\n        for i in range(n):\n            if train_states[i] is not None:\n                current_day_in_cycle, x_i, y_i = train_states[i]\n                if current_day_in_cycle < x_i + y_i - 1:\n                    current_day_in_cycle += 1\n                else:\n                    current_day_in_cycle = 0\n                \n                # Check if it is in maintenance\n                if current_day_in_cycle == x_i:\n                    maintenance_count += 1\n                elif current_day_in_cycle == x_i + y_i:\n                    maintenance_count -= 1\n                \n                train"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the working and maintenance periods for each train model, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the working (x_i) and maintenance (y_i) periods for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days and track their maintenance status.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current state of each train model (whether it is added and its current cycle position).\",\n        \"For each day, perform the operation specified (add or remove a train) and update the state of the trains accordingly.\",\n        \"Calculate the number of trains in maintenance for each day based on their current cycle position.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, after updating the train states, determine how many trains are in maintenance.\",\n        \"Store the result for each day and print it at the end.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data about train models and daily operations.\",\n    \"Initialize data structures to track the state of each train model.\",\n    \"Iterate over each day, updating the state of trains based on the operations (add or remove).\",\n    \"For each day, calculate the number of trains in maintenance and store the result.\",\n    \"Output the results for each day after processing all operations.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'maintenance'\n    Explanation: In the requirement, maintenance refers to the period when a train is not operational and is undergoing repairs or checks. The task is to calculate how many trains are in this state each day.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': This means that there can be zero or one train of each model at any given time.\n    'x_i days', 'y_i days': These phrases indicate the duration of working and maintenance periods for each train model. They are used to determine the cycle of operation and maintenance for each train.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for simulating the addition and removal of trains and tracking their maintenance status should be implemented simultaneously. Specifically, updating the state of trains and calculating the number of trains in maintenance should occur in the same loop for each day.\n\n# [edge case] \n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: Only one train is added and it is working on the first day, so no train is in maintenance.\n\n    Input: 2 2\n           1 1\n           1 1\n           1 1\n           1 2\n    Output: 0\n            0\n    Explanation: Both trains are added on separate days and are working, so no train is in maintenance.\n\n    Input: 2 3\n           1 1\n           1 1\n           1 1\n           2 1\n           1 1\n    Output: 0\n            0\n            0\n    Explanation: A train is added, removed, and then added again, all while working, so no train is in maintenance.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of updating train states and calculating maintenance status should naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: (is_active, current_day_in_cycle)\n    train_states = [None] * n\n    maintenance_count = 0\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            train_states[k] = (True, 0)  # Start at day 0 of the cycle\n        elif op == 2:  # Remove train of model k\n            is_active, current_day_in_cycle = train_states[k]\n            if is_active and current_day_in_cycle >= train_cycles[k][0]:\n                maintenance_count -= 1\n            train_states[k] = None\n        \n        # Update maintenance count\n        current_maintenance_count = 0\n        for i in range(n):\n            if train_states[i] is not None:\n                is_active, current_day_in_cycle = train_states[i]\n                x_i, y_i = train_cycles[i]\n                \n                if current_day_in_cycle >= x_i:\n                    current_maintenance_count += 1\n                \n                # Update the cycle day\n                total_cycle = x_i + y_i\n                train_states[i] = (is_active, (current_day_in_cycle + 1) % total_cycle)\n        \n        results.append(current_maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the working and maintenance periods for each train model, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get x_i and y_i for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over m days, keeping track of their working and maintenance cycles.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current state of each train model (whether it is added or removed).\",\n        \"For each day, update the state based on the operation (add or remove) and adjust the cycle of the train model accordingly.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, iterate over the current state of all train models.\",\n        \"Determine if each train model is in its maintenance period based on its cycle.\",\n        \"Count the number of trains in maintenance and store the result for that day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"Print the stored results for each day, one per line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Initialize data structures to track train states and cycles.\",\n    \"Simulate the daily operations, updating train states and cycles.\",\n    \"Calculate and store the number of trains in maintenance for each day.\",\n    \"Output the results for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'maintenance': refers to the period when a train is not operational and is being serviced. It is crucial to track these periods accurately to determine how many trains are in maintenance each day.\n\n    'cycle': refers to the alternating periods of working and maintenance for each train model. Understanding the cycle is essential for calculating maintenance days.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': indicates that there can be zero or one train of each model at any time, but not more than one.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to simulating the addition and removal of trains and calculating the number of trains in maintenance should be considered simultaneously. Specifically, updating the state of trains and checking their maintenance status should occur in the same loop for each day to ensure accurate tracking.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: On the first day, a train is added but it starts working immediately, so no train is in maintenance.\n\n    Input: 1 2\n           1 1\n           1 1\n           2 1\n    Output: 0\n            0\n    Explanation: On the first day, a train is added and starts working. On the second day, it is removed, so no train is in maintenance.\n\n    Input: 2 3\n           1 1\n           1 1\n           1 1\n           1 2\n           2 1\n    Output: 0\n            0\n            0\n    Explanation: On the first day, two trains are added and both start working. On the second day, they continue working. On the third day, one train is removed, but the other is still working.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where trains might have overlapping maintenance periods or synchronized cycles. This can be managed by ensuring the cycle calculation accounts for the exact day transitions between working and maintenance.\n\n    Example code snippet:\n    ```python\n    def calculate_maintenance_days(n, m, train_cycles, operations):\n        train_states = [None] * n  # None means no train, otherwise store the cycle start day\n        maintenance_counts = []\n\n        for day in range(m):\n            op,", "Round_0": {"code": "def calculate_maintenance_days(n, m, train_cycles, operations):\n    train_states = [None] * n  # None means no train, otherwise store the cycle start day\n    maintenance_counts = []\n\n    for day in range(m):\n        op, k = operations[day]\n        k -= 1  # Convert to zero-based index\n\n        if op == 1:  # Add train\n            train_states[k] = day\n        elif op == 2:  # Remove train\n            train_states[k] = None\n\n        # Calculate number of trains in maintenance\n        maintenance_count = 0\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i = train_cycles[i]\n                cycle_length = x_i + y_i\n                days_since_added = day - train_states[i]\n                if days_since_added >= x_i and (days_since_added % cycle_length) < y_i:\n                    maintenance_count += 1\n\n        maintenance_counts.append(maintenance_count)\n\n    return maintenance_counts\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1])\n        operations.append((op, k))\n        index += 2\n\n    maintenance_counts = calculate_maintenance_days(n, m, train_cycles, operations)\n\n    for count in maintenance_counts:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), and the cycles (x_i, y_i) for each train model.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get x_i and y_i for each train model.\"\n      ]\n    },\n    {\n      \"description\": \"Track the state of each train model over the m days based on operations (add or remove).\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current state of each train model (added or removed).\",\n        \"Iterate over the m operations, updating the state of the train models accordingly.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, check the state of each train model.\",\n        \"Determine if a train is in maintenance based on its cycle (x_i, y_i) and the current day.\",\n        \"Count the number of trains in maintenance and store the result for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"Print the stored results for each of the m days.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Initialize data structures to track train states and maintenance periods.\",\n    \"Iterate over each day's operations, updating train states and calculating maintenance counts.\",\n    \"Output the maintenance count for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'maintenance'\n    Explanation: In the context of the requirement, maintenance refers to the period when a train is not operational and is undergoing maintenance. The cycle of maintenance is defined by the number of days a train works and the number of days it is in maintenance.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': This means that there can be zero or one train of each model at any given time.\n    'x_i days': This indicates the number of days a train works before going into maintenance.\n    'y_i days': This indicates the number of days a train is in maintenance before it resumes working.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to tracking the state of each train model and calculating the number of trains in maintenance should be considered simultaneously. Specifically, when updating the state of train models, the calculation of maintenance should be integrated to ensure accurate tracking of train states and maintenance periods.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: On the first day, a train is added and it starts working immediately, so no train is in maintenance.\n\n    Input: 2 2\n           1 1\n           1 1\n           1 1\n           1 2\n    Output: 0\n            0\n    Explanation: On both days, trains are added and they start working immediately, so no train is in maintenance.\n\n    Input: 1 3\n           1 1\n           1 1\n           2 1\n           1 1\n    Output: 0\n            0\n            0\n    Explanation: On the first day, a train is added and starts working. On the second day, it is removed, and on the third day, it is added again and starts working immediately, so no train is in maintenance.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the logic correctly handles the transition between working and maintenance periods, especially when trains are added or removed. This can be done by maintaining a cycle counter for each train model and updating it based on the current day and operation.\n\nYES", "Round_0": {"code": "def calculate_maintenance_days(n, m, train_cycles, operations):\n    # Initialize the state of each train model\n    train_state = [None] * n  # None means no train of that model is present\n    maintenance_count = [0] * m  # To store the number of trains in maintenance each day\n\n    # Iterate over each day's operations\n    for day in range(m):\n        op, k = operations[day]\n        k -= 1  # Convert to zero-based index\n\n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            train_state[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n\n        elif op == 2:  # Remove train of model k\n            train_state[k] = None  # Remove the train\n\n        # Calculate the number of trains in maintenance for the current day\n        maintenance_count[day] = 0\n        for i in range(n):\n            if train_state[i] is not None:\n                start_day, x_i, y_i = train_state[i]\n                cycle_length = x_i + y_i\n                days_since_added = day - start_day\n\n                # Determine if the train is in maintenance\n                if days_since_added >= x_i:\n                    cycle_position = days_since_added % cycle_length\n                    if cycle_position >= x_i:\n                        maintenance_count[day] += 1\n\n    return maintenance_count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    # Parse the input\n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1])\n        operations.append((op, k))\n        index += 2\n\n    # Calculate maintenance days\n    maintenance_days = calculate_maintenance_days(n, m, train_cycles, operations)\n\n    # Output the result\n    for count in maintenance_days:\n        print(count)", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 98)"}, "Round_1": {"code": "def calculate_maintenance_days(n, m, train_cycles, operations):\n    # Initialize the state of each train model\n    train_state = [None] * n  # None means no train of that model is present\n    maintenance_count = [0] * m  # To store the number of trains in maintenance each day\n\n    # Iterate over each day's operations\n    for day in range(m):\n        op, k = operations[day]\n        k -= 1  # Convert to zero-based index\n\n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            train_state[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n\n        elif op == 2:  # Remove train of model k\n            train_state[k] = None  # Remove the train\n\n        # Calculate the number of trains in maintenance for the current day\n        maintenance_count[day] = 0\n        for i in range(n):\n            if train_state[i] is not None:\n                start_day, x_i, y_i = train_state[i]\n                cycle_length = x_i + y_i\n                days_since_added = day - start_day\n\n                # Determine if the train is in maintenance\n                if days_since_added >= x_i:\n                    cycle_position = days_since_added % cycle_length\n                    if cycle_position >= x_i:\n                        maintenance_count[day] += 1\n\n    return maintenance_count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    # Parse the input\n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1])\n        operations.append((op, k))\n        index += 2\n\n    # Calculate maintenance days\n    maintenance_days = calculate_maintenance_days(n, m, train_cycles, operations)\n\n    # Output the result\n    for count in maintenance_days:\n        print(count)"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), and the cycles (x_i, y_i) for each train model.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get x_i and y_i for each train model.\"\n      ]\n    },\n    {\n      \"description\": \"Track the state of each train model over the m days based on operations (add or remove).\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current state (working or maintenance) of each train model.\",\n        \"For each of the m operations, update the state of the train model based on whether it is added or removed.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, iterate over the train models to count how many are in maintenance.\",\n        \"Consider the transition between working and maintenance periods accurately.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"Print the count of trains in maintenance for each of the m days.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, m, and the cycles (x_i, y_i) for each train model.\",\n    \"Initialize a data structure to track the state of each train model.\",\n    \"Iterate over the m operations to update the state of the train models.\",\n    \"For each day, calculate the number of trains in maintenance by checking the state of each train model.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'maintenance'\n    Explanation: In the context of the requirement, maintenance refers to the period during which a train is not operational and is undergoing upkeep. The task is to calculate how many trains are in this state each day.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': This means that there can be zero or one train of each model at any given time.\n    'x_i days', 'y_i days': These phrases indicate the duration of working and maintenance periods for each train model. Implementation involves tracking these cycles for each train.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to updating the state of train models based on operations (add or remove) and calculating the number of trains in maintenance should be considered simultaneously. This involves checking the current state of each train model and updating it based on the operation for the day.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: Only one train is added and it starts working immediately, so no train is in maintenance.\n\n    Input: 2 2\n           1 1\n           1 1\n           1 1\n           1 2\n    Output: 0\n            0\n    Explanation: Both trains are added and start working immediately, so no train is in maintenance.\n\n    Input: 1 3\n           1 1\n           1 1\n           2 1\n           1 1\n    Output: 0\n            0\n            0\n    Explanation: The train is added, removed, and added again, but it starts working immediately each time, so no train is in maintenance.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling the edge case:\n    ```python\n    if op == 1:  # Train is added\n        # Initialize the train's cycle\n        train_cycles[k] = (0, x_i[k])  # (maintenance_days, working_days)\n    elif op == 2:  # Train is removed\n        if k in train_cycles:\n            del train_cycles[k]  # Remove the train from tracking\n    ```\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        cycles.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking for each train model\n    train_states = {}\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            x_i, y_i = cycles[k]\n            train_states[k] = (day, x_i, y_i)  # (start_day, work_days, maintenance_days)\n        \n        elif op == 2:  # Remove train\n            if k in train_states:\n                del train_states[k]\n        \n        # Calculate maintenance count for the current day\n        count = 0\n        for start_day, x_i, y_i in train_states.values():\n            total_cycle = x_i + y_i\n            days_since_start = day - start_day\n            if days_since_start >= x_i:\n                # Check if the train is in maintenance\n                if (days_since_start - x_i) % total_cycle < y_i:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), and the list of train operations.\",\n      \"details\": \"Read the first line to get n and m. Read the next n lines to get the x_i and y_i values for each train model. Read the next m lines to get the operations (op, k) for each day.\"\n    },\n    {\n      \"description\": \"Track the state of each train model over the days.\",\n      \"details\": \"Maintain a data structure to keep track of the current state (working or maintenance) and the cycle position for each train model that is added.\"\n    },\n    {\n      \"description\": \"Simulate the daily operations and update the train states accordingly.\",\n      \"details\": \"For each day, based on the operation (add or remove), update the state of the train model. If a train is added, initialize its cycle. If a train is removed, clear its state.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"details\": \"For each day, iterate over the train models and count how many are in the maintenance state.\"\n    },\n    {\n      \"description\": \"Output the result for each day.\",\n      \"details\": \"Print the number of trains in maintenance for each day as specified in the output format.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize data structures to store train model states and cycle information.\",\n    \"Parse the input to extract train model details and daily operations.\",\n    \"Iterate over each day and perform the specified operation (add or remove train).\",\n    \"Update the cycle state of each train model based on its x_i and y_i values.\",\n    \"Count the number of trains in maintenance for the current day.\",\n    \"Output the count for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models'\n    Explanation: Refers to different types of trains, each with its own working and maintenance cycle.\n\n    'maintenance'\n    Explanation: A period during which a train is not operational and is being serviced.\n\n    'cycle'\n    Explanation: The repeating sequence of working and maintenance days for each train model.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model'\n    Explanation: There can be zero or one train of each model at any time, but not more than one.\n\n    'x_i days', 'y_i days'\n    Explanation: x_i represents the number of days a train works before going into maintenance, and y_i represents the number of days it stays in maintenance.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to updating the train state and counting the number of trains in maintenance should be implemented simultaneously. Specifically:\n    - \"Simulate the daily operations and update the train states accordingly.\"\n    - \"Calculate the number of trains in maintenance for each day.\"\n    These can be done in a single loop that processes each day's operations and updates the state of the trains.\n\n# [edge case]\n    1. Input: 1 1\\n1 1\\n1 1\\n\n       Output: 0\n       Explanation: Only one train is added and it starts working, so no train is in maintenance.\n\n    2. Input: 1 2\\n1 1\\n1 1\\n2 1\\n\n       Output: 0\\n0\n       Explanation: A train is added and then removed the next day, so no train is in maintenance on either day.\n\n    3. Input: 2 3\\n1 1\\n1 1\\n1 1\\n1 2\\n2 1\\n\n       Output: 0\\n0\\n0\n       Explanation: Two trains are added, both start working, and one is removed, so no train is in maintenance.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of updating train states and counting maintenance trains should naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    # Read x_i and y_i for each train model\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    # Initialize train states\n    train_states = [None] * n  # None means no train of this model is present\n    \n    # Prepare to store results\n    results = []\n    \n    # Process each day's operation\n    for day in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        index += 2\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            train_states[k] = (0, x_i, y_i)  # (current_day_in_cycle, x_i, y_i)\n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Count trains in maintenance\n        maintenance_count = 0\n        for state in train_states:\n            if state is not None:\n                current_day_in_cycle, x_i, y_i = state\n                # Check if the train is in maintenance\n                if current_day_in_cycle >= x_i:\n                    maintenance_count += 1\n        \n        # Store the result for the current day\n        results.append(maintenance_count)\n        \n        # Update the cycle day for each train\n        for i in range(n):\n            if train_states[i] is not None:\n                current_day_in_cycle, x_i, y_i = train_states[i]\n                total_cycle_length = x_i + y_i\n                # Move to the next day in the cycle\n                train_states[i] = ((current_day_in_cycle + 1) % total_cycle_length, x_i, y_i)\n    \n    # Output the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get x_i and y_i for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over m days, keeping track of their work and maintenance cycles.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current state of each train model (whether it is added or removed, and its current cycle position).\",\n        \"For each day, perform the operation specified (add or remove a train of model k).\",\n        \"Update the cycle position of each train model that is currently added.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, iterate over all added train models and check their current cycle position.\",\n        \"Count the number of trains that are in the maintenance period.\",\n        \"Output the count for each day.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary information.\",\n    \"Initialize data structures to track train states and cycles.\",\n    \"Iterate over each day, updating train states and cycles based on operations.\",\n    \"Calculate and output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'maintenance': refers to the period when a train is not operational and is being serviced. It is crucial to track this period accurately for each train model.\n    'cycle': refers to the alternating periods of work and maintenance for each train model. Understanding the cycle helps in determining when a train is in maintenance.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': indicates that there can be zero or one train of each model at any time.\n    'x_i days', 'y_i days': specify the duration of work and maintenance periods for each train model. These durations are crucial for calculating the cycle of each train.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to updating the cycle position and counting maintenance trains should be considered simultaneously. Specifically, when updating the cycle position of each train model, you should also check if it is in the maintenance period and count it accordingly. This can be implemented in a single loop that iterates over the active train models each day.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: On the first day, a train is added but it is in the work period, so no train is in maintenance.\n\n    Input: 2 2\n           1 1\n           1 1\n           1 1\n           1 2\n    Output: 0\n            0\n    Explanation: Both trains are added on consecutive days, but both are in their work periods initially.\n\n    Input: 1 3\n           1 1\n           1 1\n           1 1\n           2 1\n    Output: 0\n            0\n            0\n    Explanation: A train is added and then removed, but it never enters the maintenance period.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where trains might be added or removed without entering the maintenance period. This can be handled by ensuring that the cycle position is updated correctly and checking the maintenance status immediately after any operation.\n    ```python\n    # Example code snippet for handling edge cases\n    if op == 1:  # Add train\n        train_state[k] = 0  # Start at the beginning of the cycle\n    elif op == 2:", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: -1 means not present, otherwise it stores the current day in the cycle\n    train_state = [-1] * n\n    maintenance_count = 0\n    \n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_state[k] = 0  # Start at the beginning of the cycle\n        elif op == 2:  # Remove train\n            if train_state[k] != -1:\n                # Check if it was in maintenance before removal\n                x_i, y_i = work_maintenance[k]\n                cycle_length = x_i + y_i\n                if train_state[k] >= x_i:\n                    maintenance_count -= 1\n            train_state[k] = -1\n        \n        # Update the cycle positions and count maintenance trains\n        current_maintenance_count = 0\n        for i in range(n):\n            if train_state[i] != -1:\n                x_i, y_i = work_maintenance[i]\n                cycle_length = x_i + y_i\n                train_state[i] = (train_state[i] + 1) % cycle_length\n                if train_state[i] >= x_i:\n                    current_maintenance_count += 1\n        \n        results.append(current_maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 105)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: -1 means not present, otherwise it stores the current day in the cycle\n    train_state = [-1] * n\n    \n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_state[k] = 0  # Start at the beginning of the cycle\n        elif op == 2:  # Remove train\n            train_state[k] = -1\n        \n        # Update the cycle positions and count maintenance trains\n        current_maintenance_count = 0\n        for i in range(n):\n            if train_state[i] != -1:\n                x_i, y_i = work_maintenance[i]\n                cycle_length = x_i + y_i\n                if train_state[i] >= x_i:\n                    current_maintenance_count += 1\n                train_state[i] = (train_state[i] + 1) % cycle_length\n        \n        results.append(current_maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the working and maintenance periods for each train model, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the working (x_i) and maintenance (y_i) periods for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days and track their maintenance status.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current state of each train model (whether it is added and its current cycle position).\",\n        \"For each day, perform the operation specified (add or remove a train) and update the state of the trains accordingly.\",\n        \"Calculate the number of trains in maintenance for each day based on their current cycle position.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, after updating the train states, determine how many trains are in maintenance.\",\n        \"Print the result for each day.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data about train models and daily operations.\",\n    \"Initialize data structures to track the state of each train model.\",\n    \"Iterate over each day, updating the state of trains based on the operations (add or remove).\",\n    \"For each day, calculate the number of trains in maintenance and store the result.\",\n    \"Output the stored results for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models', 'working period', 'maintenance period', 'add', 'remove'\n    Explanation: The requirement involves managing different train models, each with specific working and maintenance cycles. The operations include adding and removing trains, which affect their maintenance status.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': This means that there can be zero or one train of each model at any time.\n    'x_i days', 'y_i days': These specify the duration of working and maintenance periods for each train model.\n    Implementation: Use variables to track the cycle of each train model and update them based on the operations.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but within the simulation of train operations, the addition and removal of trains should be handled simultaneously with updating their maintenance status. This can be done using a loop that processes each day's operations and updates the state of the trains accordingly.\n\n# [edge case]\n    1. Input: 1 1\\n1 1\\n1 1\\n1 1\\nOutput: 0\n       Explanation: Only one train is added and it starts working, so no train is in maintenance.\n    2. Input: 1 2\\n1 1\\n1 1\\n2 1\\nOutput: 0\\n0\n       Explanation: A train is added and then removed the next day, so no train is in maintenance on either day.\n    3. Input: 2 3\\n1 1\\n1 1\\n1 1\\n1 2\\n2 1\\nOutput: 0\\n0\\n0\n       Explanation: Two trains are added on consecutive days, and one is removed, but none enter maintenance during the given days.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Ensure that the state of each train is updated correctly when added or removed.\n    - Implement logic to check the current cycle position of each train to determine if it is in maintenance.\n\n```python\n# Example code snippet for handling train states\ntrain_states = {}  # Dictionary to track train states\n\nfor day in range(m):\n    op, k = operations[day]\n    if op == 1:  # Add train\n        train_states[k] = 0  # Start at the beginning of the cycle\n    elif op", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    # Read train model periods\n    train_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_periods.append((x_i, y_i))\n    \n    # Read operations\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize train states\n    train_states = {}\n    maintenance_count = [0] * m\n    \n    # Process each day\n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            x_i, y_i = train_periods[k]\n            train_states[k] = (day, x_i, y_i)  # Store the start day and periods\n        elif op == 2:  # Remove train\n            if k in train_states:\n                del train_states[k]\n        \n        # Calculate number of trains in maintenance\n        count_in_maintenance = 0\n        for start_day, x_i, y_i in train_states.values():\n            cycle_length = x_i + y_i\n            days_since_start = day - start_day\n            if days_since_start >= x_i:\n                # Check if the train is in maintenance\n                if (days_since_start - x_i) % cycle_length < y_i:\n                    count_in_maintenance += 1\n        \n        maintenance_count[day] = count_in_maintenance\n    \n    # Output the result for each day\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the working and maintenance periods for each train model, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the working (x_i) and maintenance (y_i) periods for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Track the state of each train model over the days, including whether it is currently added and its current cycle position (working or maintenance).\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the state of each train model (e.g., added or removed, current cycle position).\",\n        \"For each operation, update the state of the corresponding train model.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day based on the current state of all train models.\",\n      \"steps\": [\n        \"For each day, iterate over all train models to determine if they are in the maintenance period.\",\n        \"Count the number of trains in maintenance and store the result for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, output the calculated number of trains in maintenance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data about train models and daily operations.\",\n    \"Initialize a data structure to track the state of each train model.\",\n    \"Iterate over each day's operations, updating the state of the train models accordingly.\",\n    \"For each day, calculate the number of trains in maintenance based on their current states.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models'\n    Explanation: Refers to different types of trains, each with its own working and maintenance cycle.\n\n    'working and maintenance periods'\n    Explanation: Each train model has a specific number of days it works (x_i) and a specific number of days it is in maintenance (y_i).\n\n    'operations'\n    Explanation: Daily actions that either add or remove a train of a specific model.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model'\n    Explanation: There can be zero or one train of each model at any time, but not more than one.\n\n    'x_i days', 'y_i days'\n    Explanation: These specify the duration of the working and maintenance periods for each train model.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the subproblem \"Track the state of each train model over the days\" should be implemented simultaneously. Specifically, updating the state of the train model and determining its current cycle position (working or maintenance) should be done in one code block to ensure accurate tracking of each train's status.\n\n# [edge case]\n    1. Input: 1 1\n             1 1\n             1 1\n       Output: 0\n       Explanation: On the first day, a train is added and it starts working, so no train is in maintenance.\n\n    2. Input: 1 2\n             1 1\n             1 1\n             2 1\n       Output: 0\n               0\n       Explanation: On the first day, a train is added and it starts working. On the second day, the train is removed, so no train is in maintenance on either day.\n\n    3. Input: 2 3\n             1 1\n             1 1\n             1 1\n             1 2\n             2 1\n       Output: 0\n               0\n               0\n       Explanation: On the first day, a train of model 1 is added and starts working. On the second day, a train of model 2 is added and starts working. On the third day, the train of model 1 is removed, so no train is in maintenance on any day.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Specifically, we need", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    # Read the working and maintenance periods for each train model\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_cycles.append((x_i, y_i))\n    \n    # Read the operations for each day\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize the state of each train model\n    train_states = [None] * n  # None means no train of this model is added\n    \n    # Result list to store the number of trains in maintenance each day\n    results = []\n    \n    # Process each day's operation\n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            train_states[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n        \n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Calculate the number of trains in maintenance\n        maintenance_count = 0\n        for state in train_states:\n            if state is not None:\n                added_day, x_i, y_i = state\n                total_cycle = x_i + y_i\n                days_since_added = day - added_day\n                \n                # Determine the current cycle position\n                cycle_position = days_since_added % total_cycle\n                \n                # Check if the train is in maintenance\n                if cycle_position >= x_i:\n                    maintenance_count += 1\n        \n        # Store the result for the current day\n        results.append(maintenance_count)\n    \n    # Output the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, true, true, true, true, false, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 393, "prompt": "Kawasiro Nitori is excellent in engineering, thus she has been appointed to help maintain trains.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment. Initially, there are no trains, and at each of the following m days, one train will be added or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, and then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance each day.\n\nOn a day a train is removed, it is not counted as in maintenance. Make sure to account for all transitions between working and maintenance periods accurately in your calculations. Consider edge cases where trains might have overlapping maintenance periods or synchronized cycles.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.", "examples": "\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 210}
