{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "repair_prompt": ["Chanek and Indiana require your assistance in creating an effective algorithm to manage multiple requests, simulating the treasure hunt process in real time.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Chanek and Indiana need your help in developing an efficient algorithm to handle numerous requests. These requests will simulate the treasure hunt process. The simulation needs to occur in real time.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Chanek and Indiana require your assistance in creating an effective algorithm to manage multiple requests, simulating the treasure hunt process in real time.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of rooms and queries\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read initial illusion rates\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read tunnel connections and build the tree\n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    # Function to find path using BFS\n    def find_path(start, end):\n        queue = deque([start])\n        parent = {start: None}\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        \n        return path[::-1]\n    \n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            illusion_rates[room] = new_rate\n            index += 3\n        elif query_type == 2:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            index += 3\n            \n            path = find_path(start, end)\n            energy_sum = 0\n            for i in range(len(path) - 1):\n                s = path[i]\n                t = path[i + 1]\n                energy_sum += max(abs(illusion_rates[s] + illusion_rates[t]), abs(illusion_rates[s] - illusion_rates[t]))\n            \n            results.append(energy_sum)\n    \n    # Output results for type 2 queries\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    \n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1]) - 1\n        v = int(data[index + 2]) - 1\n        queries.append((query_type, u, v))\n        index += 3\n    \n    def calculate_energy(a, b):\n        return max(abs(a + b), abs(a - b))\n    \n    def bfs_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    results = []\n    \n    for query_type, u, v in queries:\n        if query_type == 1:\n            # Update the illusion rate of room u\n            illusion_rates[u] = v\n        elif query_type == 2:\n            # Calculate the minimum energy required from room u to room v\n            path = bfs_path(u, v)\n            total_energy = 0\n            for i in range(len(path) - 1):\n                room1 = path[i]\n                room2 = path[i + 1]\n                total_energy += calculate_energy(illusion_rates[room1], illusion_rates[room2])\n            results.append(total_energy)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = []\n    for _ in range(n):\n        illusion_rates.append(int(data[index]))\n        index += 1\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        index += 1\n        t = int(data[index]) - 1\n        index += 1\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        x = int(data[index]) - 1\n        index += 1\n        y = int(data[index])\n        index += 1\n        queries.append((query_type, x, y))\n    \n    return n, q, illusion_rates, tree, queries\n\ndef update_illusion_rate(illusion_rates, room, new_rate):\n    illusion_rates[room] = new_rate\n\ndef calculate_energy(a_i, a_j):\n    return max(abs(a_i + a_j), abs(a_i - a_j))\n\ndef find_path(tree, start, end):\n    visited = [False] * len(tree)\n    parent = [-1] * len(tree)\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            break\n        for neighbor in tree[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                parent[neighbor] = current\n                queue.append(neighbor)\n    \n    path = []\n    while end != -1:\n        path.append(end)\n        end = parent[end]\n    path.reverse()\n    \n    return path\n\ndef process_queries(n, q, illusion_rates, tree, queries):\n    results = []\n    for query_type, x, y in queries:\n        if query_type == 1:\n            update_illusion_rate(illusion_rates, x, y)\n        elif query_type == 2:\n            path = find_path(tree, x, y - 1)\n            total_energy = 0\n            for i in range(len(path) - 1):\n                total_energy += calculate\nmain()", "def parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        index += 1\n        t = int(data[index]) - 1\n        index += 1\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index])\n        index += 1\n        queries.append((query_type, u, v))\n    \n    return n, q, illusion_rates, tree, queries\n\ndef bfs_path(tree, start, end):\n    queue = deque([start])\n    parent = {start: None}\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            break\n        for neighbor in tree[node]:\n            if neighbor not in parent:\n                parent[neighbor] = node\n                queue.append(neighbor)\n    \n    path = []\n    while end is not None:\n        path.append(end)\n        end = parent[end]\n    \n    return path[::-1]\n\ndef calculate_energy(illusion_rates, path):\n    energy = 0\n    for i in range(len(path) - 1):\n        u = path[i]\n        v = path[i + 1]\n        energy += max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n    return energy\n\ndef process_queries(n, q, illusion_rates, tree, queries):\n    results = []\n    for query_type, u, v in queries:\n        if query_type == 1:\n            illusion_rates[u] = v\n        elif query_type == 2:\n            path = bfs_path(tree, u, v - 1)\n            energy = calculate_energy(illusion_rates, path)\n            results.append(energy)\n    return results\n\ndef main():\n    n, q, illusion_rates, tree, queries = parse_input()\n    results =\nmain()", "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    \n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            queries.append((query_type, room, new_rate))\n            index += 3\n        else:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            queries.append((query_type, start, end))\n            index += 3\n    \n    def bfs_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    results = []\n    \n    for query in queries:\n        if query[0] == 1:\n            _, room, new_rate = query\n            illusion_rates[room] = new_rate\n        else:\n            _, start, end = query\n            path = bfs_path(start, end)\n            energy_sum = 0\n            for i in range(len(path) - 1):\n                s = path[i]\n                t = path[i + 1]\n                energy = max(abs(illusion_rates[s] + illusion_rates[t]), abs(illusion_rates[s] - illusion_rates[t]))\n                energy_sum += energy\n            results.append(energy_sum)\n    \n    for result in results:\n        print(result)\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef calculate_energy(a, path):\n    energy = 0\n    for i in range(len(path) - 1):\n        u, v = path[i], path[i + 1]\n        energy += max(abs(a[u] + a[v]), abs(a[u] - a[v]))\n    return energy\n\ndef bfs_path(tree, start, end):\n    queue = deque([start])\n    parent = {start: None}\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            break\n        for neighbor in tree[node]:\n            if neighbor not in parent:\n                parent[neighbor] = node\n                queue.append(neighbor)\n    \n    path = []\n    while end is not None:\n        path.append(end)\n        end = parent[end]\n    path.reverse()\n    return path\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            a[room] = new_rate\n            index += 3\n        elif query_type == 2:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            path = bfs_path(tree, start, end)\n            energy = calculate_energy(a, path)\n            results.append(energy)\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Build the tree\n    tree = collections.defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    # Preprocess to find parent and depth using BFS\n    parent = [-1] * n\n    depth = [0] * n\n    def bfs():\n        queue = collections.deque([0])\n        visited = [False] * n\n        visited[0] = True\n        while queue:\n            node = queue.popleft()\n            for neighbor in tree[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    parent[neighbor] = node\n                    depth[neighbor] = depth[node] + 1\n                    queue.append(neighbor)\n    \n    bfs()\n    \n    # Function to find LCA\n    def lca(u, v):\n        if depth[u] < depth[v]:\n            u, v = v, u\n        # Bring u and v to the same depth\n        while depth[u] > depth[v]:\n            u = parent[u]\n        while u != v:\n            u = parent[u]\n            v = parent[v]\n        return u\n    \n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            illusion_rates[room] = new_rate\n            index += 3\n        elif query_type == 2:\n            start = int(data[index + 1]) - 1\nmain()", "def parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        index += 1\n        t = int(data[index]) - 1\n        index += 1\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index])\n        index += 1\n        queries.append((query_type, u, v))\n    \n    return n, q, illusion_rates, tree, queries\n\ndef update_illusion_rate(illusion_rates, room, new_rate):\n    illusion_rates[room] = new_rate\n\ndef calculate_energy(illusion_rates, tree, start, end):\n    # BFS to find the path from start to end\n    queue = deque([(start, -1)])\n    parent = {start: None}\n    \n    while queue:\n        current, prev = queue.popleft()\n        parent[current] = prev\n        if current == end:\n            break\n        for neighbor in tree[current]:\n            if neighbor != prev:\n                queue.append((neighbor, current))\n    \n    # Calculate energy along the path\n    energy = 0\n    current = end\n    while parent[current] is not None:\n        prev = parent[current]\n        a = illusion_rates[current]\n        b = illusion_rates[prev]\n        energy += max(abs(a + b), abs(a - b))\n        current = prev\n    \n    return energy\n\ndef process_queries(n, q, illusion_rates, tree, queries):\n    results = []\n    for query_type, u, v in queries:\n        if query_type == 1:\n            update_illusion_rate(illusion_rates, u, v)\n        elif query_type == 2:\n            energy = calculate_energy(illusion_rates, tree, u, v - 1)\n            results.append(energy)\n    return results\n\ndef main():\n    n, q\nmain()", "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    \n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            queries.append((query_type, room, new_rate))\n            index += 3\n        else:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            queries.append((query_type, start, end))\n            index += 3\n    \n    def bfs_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    results = []\n    \n    for query in queries:\n        if query[0] == 1:\n            _, room, new_rate = query\n            illusion_rates[room] = new_rate\n        else:\n            _, start, end = query\n            path = bfs_path(start, end)\n            total_energy = 0\n            for i in range(len(path) - 1):\n                u = path[i]\n                v = path[i + 1]\n                energy = max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n                total_energy += energy\n            results.append(total_energy)\n    \n    for result in results:\n        print(result)\nmain()", "import sys\nimport collections\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Build the tree\n    tree = collections.defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            illusion_rates[room] = new_rate\n            index += 3\n        elif query_type == 2:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            index += 3\n            \n            # BFS to find the path from start to end\n            queue = collections.deque([(start, -1)])\n            parent = {start: None}\n            \n            while queue:\n                current, prev = queue.popleft()\n                if current == end:\n                    break\n                for neighbor in tree[current]:\n                    if neighbor != prev and neighbor not in parent:\n                        parent[neighbor] = current\n                        queue.append((neighbor, current))\n            \n            # Calculate the energy required for the path\n            total_energy = 0\n            current = end\n            while parent[current] is not None:\n                prev = parent[current]\n                a = illusion_rates[current]\n                b = illusion_rates[prev]\n                energy = max(abs(a + b), abs(a - b))\n                total_energy += energy\n                current = prev\n            \n            results.append(total_energy)\n    \n    # Output results for type 2 queries\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of rooms and queries\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read initial illusion rates\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read tunnel connections and build the tree\n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    # Function to find path using BFS\n    def find_path(start, end):\n        queue = deque([start])\n        parent = {start: None}\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        \n        return path[::-1]\n    \n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            illusion_rates[room] = new_rate\n            index += 3\n        elif query_type == 2:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            index += 3\n            \n            path = find_path(start, end)\n            energy_sum = 0\n            for i in range(len(path) - 1):\n                s = path[i]\n                t = path[i + 1]\n                energy_sum += max(abs(illusion_rates[s] + illusion_rates[t]), abs(illusion_rates[s] - illusion_rates[t]))\n            \n            results.append(energy_sum)\n    \n    # Output results for type 2 queries\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, tunnel connections, and queries.\",\n      \"details\": [\n        \"Read the first line to get integers n (number of rooms) and q (number of queries).\",\n        \"Read the second line to get the list of n integers representing the initial illusion rates of each room.\",\n        \"Read the next n-1 lines to get pairs of integers representing tunnel connections between rooms.\",\n        \"Read the next q lines to get the queries, which can be either type 1 (update illusion rate) or type 2 (calculate energy).\"\n      ]\n    },\n    {\n      \"description\": \"Represent the maze as a tree structure using the tunnel connections.\",\n      \"details\": [\n        \"Use the tunnel connections to build a tree data structure where each room is a node and each tunnel is an edge.\"\n      ]\n    },\n    {\n      \"description\": \"Implement query processing logic.\",\n      \"details\": [\n        \"For type 1 queries, update the illusion rate of the specified room.\",\n        \"For type 2 queries, calculate the minimum sum of energy needed to move from the start room to the end room using the current illusion rates.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the energy required for movement between rooms.\",\n      \"details\": [\n        \"For each movement from room s to room t, calculate the energy as max(|a_s + a_t|, |a_s - a_t|) where a_s and a_t are the illusion rates of rooms s and t respectively.\",\n        \"Sum the energy for all movements in the path from the start room to the end room.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Build a tree representation of the maze using the tunnel connections.\",\n    \"Process each query sequentially:\",\n    \"  - If the query is type 1, update the illusion rate of the specified room.\",\n    \"  - If the query is type 2, calculate the energy required to move from the start room to the end room and output the result.\",\n    \"For type 2 queries, traverse the tree to find the path between the specified rooms and calculate the energy required for each segment of the path.\",\n    \"Output the results for each type 2 query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a numerical value associated with each room, which affects the energy calculation when moving between rooms.\n\n    'tree structure'\n    Explanation: The maze is represented as a tree, meaning there are no cycles, and each room is connected in a hierarchical manner.\n\n# [phrase showing quantity relationship]\n    'max(|a_s + a_t|, |a_s - a_t|)'\n    Explanation: This phrase indicates that for each movement between rooms, the energy required is the maximum of the absolute sum or absolute difference of the illusion rates of the two rooms. In code, this can be implemented using the `max` function and `abs` function: `max(abs(a_s + a_t), abs(a_s - a_t))`.\n\n# [degree adverb]\n    'minimum sum'\n    Explanation: This refers to the total energy required for a path, which is the sum of the maximum energy values calculated for each segment of the path. The goal is to find the minimum sum of energy needed for the entire path.\n\n# [code logic]\n    The steps for processing type 2 queries should be implemented simultaneously:\n    \"Calculate the energy required to move from the start room to the end room and output the result.\"\n    This involves traversing the tree to find the path and calculating the energy for each segment in one code block.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so the energy required for movement is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 1\n           1 1 1\n           1 2\n           2 3\n           2 1 3\n    Expected Output: 2\n    Explanation: The path is 1 \u2192 2 \u2192 3, with energy calculations max(|1 + 1|, |1 - 1|) = 2 and max(|1 + 1|, |1 - 1|) = 2, totaling 2.\n\n    Input: 4 1\n           10 -10 10 -10\n           1 2\n           2 3\n           3 4\n           2 1 4\n   ", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of rooms and queries\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read initial illusion rates\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read tunnel connections and build the tree\n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    # Function to find path using BFS\n    def find_path(start, end):\n        queue = deque([start])\n        parent = {start: None}\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        \n        return path[::-1]\n    \n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            illusion_rates[room] = new_rate\n            index += 3\n        elif query_type == 2:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            index += 3\n            \n            path = find_path(start, end)\n            energy_sum = 0\n            for i in range(len(path) - 1):\n                s = path[i]\n                t = path[i + 1]\n                energy_sum += max(abs(illusion_rates[s] + illusion_rates[t]), abs(illusion_rates[s] - illusion_rates[t]))\n            \n            results.append(energy_sum)\n    \n    # Output results for type 2 queries\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the connections between rooms.\",\n      \"output\": \"Data structures to store rooms, queries, and connections.\"\n    },\n    {\n      \"description\": \"Construct a tree data structure from the room connections.\",\n      \"output\": \"A tree representation of the maze with rooms as nodes and tunnels as edges.\"\n    },\n    {\n      \"description\": \"Implement a function to calculate the energy required to move between two connected rooms based on their illusion rates.\",\n      \"output\": \"A function that takes two room indices and returns the energy required to move between them.\"\n    },\n    {\n      \"description\": \"Implement a function to handle type 1 queries, which update the illusion rate of a specific room.\",\n      \"output\": \"An updated data structure reflecting the new illusion rate for the specified room.\"\n    },\n    {\n      \"description\": \"Implement a function to handle type 2 queries, which calculate the minimum energy required to move from one room to another.\",\n      \"output\": \"The total energy required for the specified path, printed as output.\"\n    },\n    {\n      \"description\": \"Optimize the pathfinding and energy calculation to handle large input sizes efficiently.\",\n      \"output\": \"Efficient algorithms for pathfinding and energy calculation, possibly using techniques like depth-first search (DFS) or breadth-first search (BFS).\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the connections between rooms.\",\n    \"Construct a tree data structure to represent the maze using the room connections.\",\n    \"Define a function to calculate the energy required to move between two rooms based on their illusion rates.\",\n    \"Implement logic to process each query:\",\n    \"  - For type 1 queries, update the illusion rate of the specified room.\",\n    \"  - For type 2 queries, calculate the minimum energy required to move from the start room to the end room using the tree structure.\",\n    \"Optimize the pathfinding and energy calculation to ensure the program runs efficiently for the maximum input size.\",\n    \"Output the results for each type 2 query as specified.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is represented as a tree, which is a connected acyclic graph. Each room is a node, and each tunnel is an edge connecting two nodes.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy calculation when moving between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_i + a_j|, |a_i - a_j|), where a_i and a_j are the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_i + a_j|, |a_i - a_j|)': This phrase indicates that for each movement between two rooms, the energy required is the maximum of the absolute sum and the absolute difference of their illusion rates. In code, this can be implemented using the `max` function: `max(abs(a_i + a_j), abs(a_i - a_j))`.\n\n# [degree adverb]\n    'minimum': In the context of type 2 queries, it refers to finding the minimum sum of energy needed to move from one room to another. This involves calculating the energy for each segment of the path and summing them up.\n\n# [code logic]\n    The steps for handling type 2 queries should be implemented simultaneously:\n    - Calculate the energy required for each segment of the path.\n    - Sum the energies to get the total energy for the path.\n    This can be done in a single function that iterates over the path and accumulates the energy.\n\n# [edge case]\n    1. Input: 2 1\n       Illusion rates: 0 0\n       Connections: 1 2\n       Query: 2 1 2\n       Expected Output: 0\n       Explanation: Both rooms have an illusion rate of 0, so the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    2. Input: 3 1\n       Illusion rates: 1 1 1\n       Connections: 1 2, 2 3\n       Query: 2 1 3\n       Expected Output: 2\n       Explanation: The path is 1 -> 2 -> 3. Each segment requires max(|1 + 1|, |1 - 1|) = 2 energy, so total", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    \n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1]) - 1\n        v = int(data[index + 2]) - 1\n        queries.append((query_type, u, v))\n        index += 3\n    \n    def calculate_energy(a, b):\n        return max(abs(a + b), abs(a - b))\n    \n    def bfs_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    results = []\n    \n    for query_type, u, v in queries:\n        if query_type == 1:\n            # Update the illusion rate of room u\n            illusion_rates[u] = v\n        elif query_type == 2:\n            # Calculate the minimum energy required from room u to room v\n            path = bfs_path(u, v)\n            total_energy = 0\n            for i in range(len(path) - 1):\n                room1 = path[i]\n                room2 = path[i + 1]\n                total_energy += calculate_energy(illusion_rates[room1], illusion_rates[room2])\n            results.append(total_energy)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 157)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    \n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1]) - 1\n        v = int(data[index + 2]) - 1\n        queries.append((query_type, u, v))\n        index += 3\n    \n    def calculate_energy(a, b):\n        return max(abs(a + b), abs(a - b))\n    \n    def bfs_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    results = []\n    \n    for query_type, u, v in queries:\n        if query_type == 1:\n            # Update the illusion rate of room u\n            illusion_rates[u] = v\n        elif query_type == 2:\n            # Calculate the minimum energy required from room u to room v\n            path = bfs_path(u, v)\n            total_energy = 0\n            for i in range(len(path) - 1):\n                room1 = path[i]\n                room2 = path[i + 1]\n                total_energy += calculate_energy(illusion_rates[room1], illusion_rates[room2])\n            results.append(total_energy)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the connections between rooms.\",\n      \"output\": \"Data structures to store the number of rooms (n), number of queries (q), list of illusion rates, and adjacency list for the tree structure.\"\n    },\n    {\n      \"description\": \"Construct the tree structure from the given room connections.\",\n      \"output\": \"A tree representation using an adjacency list or similar data structure.\"\n    },\n    {\n      \"description\": \"Implement a function to handle type 1 queries, which update the illusion rate of a specific room.\",\n      \"output\": \"Updated list of illusion rates after processing each type 1 query.\"\n    },\n    {\n      \"description\": \"Implement a function to handle type 2 queries, which calculate the minimum energy required to move from one room to another.\",\n      \"output\": \"The minimum energy required for each type 2 query.\"\n    },\n    {\n      \"description\": \"Calculate the energy required to move between two connected rooms based on their illusion rates.\",\n      \"output\": \"Energy calculation using the formula max(|a_i + a_j|, |a_i - a_j|) for connected rooms i and j.\"\n    },\n    {\n      \"description\": \"Use a graph traversal algorithm (e.g., DFS or BFS) to find the path between two rooms for type 2 queries.\",\n      \"output\": \"The path between the specified rooms for each type 2 query.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and room connections.\",\n    \"Construct the tree structure using the room connections.\",\n    \"For each query, determine its type:\",\n    \"  - If it's a type 1 query, update the illusion rate of the specified room.\",\n    \"  - If it's a type 2 query, find the path between the specified rooms using a graph traversal algorithm.\",\n    \"    - Calculate the energy required for each segment of the path using the energy formula.\",\n    \"    - Sum the energies to get the total energy required for the path.\",\n    \"Output the result for each type 2 query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n    'illusion rate': This refers to the integer value associated with each room, which affects the energy calculation when moving between rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_i + a_j|, |a_i - a_j|)': This phrase indicates that for each movement between two rooms, the energy required is the maximum of the absolute sum or absolute difference of their illusion rates. In code, this can be implemented using the `max` function: `max(abs(a_i + a_j), abs(a_i - a_j))`.\n\n# [degree adverb]\n    'minimum': In the context of type 2 queries, it refers to the minimum sum of energy required to move from one room to another. This involves calculating the energy for each segment of the path and summing them up.\n\n# [code logic]\n    The steps related to handling type 2 queries should be considered simultaneously:\n    - \"Use a graph traversal algorithm (e.g., DFS or BFS) to find the path between two rooms for type 2 queries.\"\n    - \"Calculate the energy required for each segment of the path using the energy formula.\"\n    - \"Sum the energies to get the total energy required for the path.\"\n    These steps can be implemented in a single function that performs the traversal and energy calculation in one go.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 1\n           1 1 1\n           1 2\n           2 3\n           2 1 3\n    Output: 2\n    Explanation: The path is 1 \u2192 2 \u2192 3, with energy calculations max(|1 + 1|, |1 - 1|) = 2 and max(|1 + 1|, |1 - 1|) = 2, totaling 2.\n\n    Input: 4 1\n           10 -10 10 -10\n           1 2\n           2 3", "Round_0": {"code": "def parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = []\n    for _ in range(n):\n        illusion_rates.append(int(data[index]))\n        index += 1\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        index += 1\n        t = int(data[index]) - 1\n        index += 1\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        x = int(data[index]) - 1\n        index += 1\n        y = int(data[index])\n        index += 1\n        queries.append((query_type, x, y))\n    \n    return n, q, illusion_rates, tree, queries\n\ndef update_illusion_rate(illusion_rates, room, new_rate):\n    illusion_rates[room] = new_rate\n\ndef calculate_energy(a_i, a_j):\n    return max(abs(a_i + a_j), abs(a_i - a_j))\n\ndef find_path(tree, start, end):\n    visited = [False] * len(tree)\n    parent = [-1] * len(tree)\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            break\n        for neighbor in tree[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                parent[neighbor] = current\n                queue.append(neighbor)\n    \n    path = []\n    while end != -1:\n        path.append(end)\n        end = parent[end]\n    path.reverse()\n    \n    return path\n\ndef process_queries(n, q, illusion_rates, tree, queries):\n    results = []\n    for query_type, x, y in queries:\n        if query_type == 1:\n            update_illusion_rate(illusion_rates, x, y)\n        elif query_type == 2:\n            path = find_path(tree, x, y - 1)\n            total_energy = 0\n            for i in range(len(path) - 1):\n                total_energy += calculate", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 143)"}, "Round_1": {"code": "def parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = []\n    for _ in range(n):\n        illusion_rates.append(int(data[index]))\n        index += 1\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        index += 1\n        t = int(data[index]) - 1\n        index += 1\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        x = int(data[index]) - 1\n        index += 1\n        y = int(data[index])\n        index += 1\n        queries.append((query_type, x, y))\n    \n    return n, q, illusion_rates, tree, queries\n\ndef update_illusion_rate(illusion_rates, room, new_rate):\n    illusion_rates[room] = new_rate\n\ndef calculate_energy(a_i, a_j):\n    return max(abs(a_i + a_j), abs(a_i - a_j))\n\ndef find_path(tree, start, end):\n    visited = [False] * len(tree)\n    parent = [-1] * len(tree)\n    queue = deque([start])\n    visited[start] = True\n    \n    while queue:\n        current = queue.popleft()\n        if current == end:\n            break\n        for neighbor in tree[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                parent[neighbor] = current\n                queue.append(neighbor)\n    \n    path = []\n    while end != -1:\n        path.append(end)\n        end = parent[end]\n    path.reverse()\n    \n    return path\n\ndef process_queries(n, q, illusion_rates, tree, queries):\n    results = []\n    for query_type, x, y in queries:\n        if query_type == 1:\n            update_illusion_rate(illusion_rates, x, y)\n        elif query_type == 2:\n            path = find_path(tree, x, y - 1)\n            total_energy = 0\n            for i in range(len(path) - 1):\n                total_energy += calculate", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the connections between rooms.\",\n      \"details\": \"Read the input data and store the number of rooms (n), number of queries (q), the list of initial illusion rates for each room, and the list of connections (edges) between rooms.\"\n    },\n    {\n      \"description\": \"Construct a tree data structure to represent the maze of rooms and tunnels.\",\n      \"details\": \"Use the list of connections to build a tree where each node represents a room and edges represent tunnels.\"\n    },\n    {\n      \"description\": \"Implement a function to calculate the energy required to move between two rooms.\",\n      \"details\": \"For a given path between two rooms, calculate the energy using the formula max(|a_i + a_j|, |a_i - a_j|) for each pair of connected rooms along the path.\"\n    },\n    {\n      \"description\": \"Process the queries and update the illusion rates or calculate the energy as required.\",\n      \"details\": \"Iterate over each query. If it's a type 1 query, update the illusion rate of the specified room. If it's a type 2 query, calculate the total energy required to move between the specified rooms and store the result.\"\n    },\n    {\n      \"description\": \"Output the results for each type 2 query.\",\n      \"details\": \"For each type 2 query processed, output the calculated energy to standard output.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the connections between rooms.\",\n    \"Construct a tree data structure to represent the maze using the connections provided.\",\n    \"Implement a function to calculate the energy required to move between two rooms based on the illusion rates.\",\n    \"Iterate over each query: update illusion rates for type 1 queries and calculate energy for type 2 queries.\",\n    \"Output the calculated energy for each type 2 query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'real time'\n    Explanation: The algorithm needs to handle requests efficiently as they come in, without significant delay.\n\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are no cycles, and there is exactly one path between any two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_i + a_j|, |a_i - a_j|)'\n    Explanation: For each pair of connected rooms, the energy required is the maximum of the absolute sum or absolute difference of their illusion rates. This can be implemented in code using the `max` function: `max(abs(a_i + a_j), abs(a_i - a_j))`.\n\n# [degree adverb]\n    'minimum sum'\n    Explanation: For type 2 queries, the task is to find the minimum sum of energy required to move from one room to another. This involves calculating the energy for each segment of the path and summing them up.\n\n# [code logic]\n    The steps for parsing input and constructing the tree should be implemented simultaneously as they are closely related. The input parsing will directly feed into the tree construction.\n\n# [edge case]\n    1. Input with minimum values: n = 2, q = 1, a = [0, 0], connections = [(1, 2)], query = [(2, 1, 2)]\n       Expected output: 0\n       Explanation: With both rooms having an illusion rate of 0, the energy required is 0.\n\n    2. All rooms have the same illusion rate: n = 3, q = 1, a = [5, 5, 5], connections = [(1, 2), (2, 3)], query = [(2, 1, 3)]\n       Expected output: 0\n       Explanation: Since all rooms have the same illusion rate, the energy for each segment is 0.\n\n    3. Maximum illusion rate difference: n = 2, q = 1, a = [10^9, -10^9], connections = [(1, 2)], query = [(2, 1, 2)]\n       Expected output: 2 * 10^9\n       Explanation: The maximum energy is required due to the large difference in illusion rates.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating energy using the max function", "Round_0": {"code": "def parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        index += 1\n        t = int(data[index]) - 1\n        index += 1\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index])\n        index += 1\n        queries.append((query_type, u, v))\n    \n    return n, q, illusion_rates, tree, queries\n\ndef bfs_path(tree, start, end):\n    queue = deque([start])\n    parent = {start: None}\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            break\n        for neighbor in tree[node]:\n            if neighbor not in parent:\n                parent[neighbor] = node\n                queue.append(neighbor)\n    \n    path = []\n    while end is not None:\n        path.append(end)\n        end = parent[end]\n    \n    return path[::-1]\n\ndef calculate_energy(illusion_rates, path):\n    energy = 0\n    for i in range(len(path) - 1):\n        u = path[i]\n        v = path[i + 1]\n        energy += max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n    return energy\n\ndef process_queries(n, q, illusion_rates, tree, queries):\n    results = []\n    for query_type, u, v in queries:\n        if query_type == 1:\n            illusion_rates[u] = v\n        elif query_type == 2:\n            path = bfs_path(tree, u, v - 1)\n            energy = calculate_energy(illusion_rates, path)\n            results.append(energy)\n    return results\n\ndef main():\n    n, q, illusion_rates, tree, queries = parse_input()\n    results =", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 76)"}, "Round_1": {"code": "def parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        index += 1\n        t = int(data[index]) - 1\n        index += 1\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index])\n        index += 1\n        queries.append((query_type, u, v))\n    \n    return n, q, illusion_rates, tree, queries\n\ndef bfs_path(tree, start, end):\n    queue = deque([start])\n    parent = {start: None}\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            break\n        for neighbor in tree[node]:\n            if neighbor not in parent:\n                parent[neighbor] = node\n                queue.append(neighbor)\n    \n    path = []\n    while end is not None:\n        path.append(end)\n        end = parent[end]\n    \n    return path[::-1]\n\ndef calculate_energy(illusion_rates, path):\n    energy = 0\n    for i in range(len(path) - 1):\n        u = path[i]\n        v = path[i + 1]\n        energy += max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n    return energy\n\ndef process_queries(n, q, illusion_rates, tree, queries):\n    results = []\n    for query_type, u, v in queries:\n        if query_type == 1:\n            illusion_rates[u] = v\n        elif query_type == 2:\n            path = bfs_path(tree, u, v - 1)\n            energy = calculate_energy(illusion_rates, path)\n            results.append(energy)\n    return results\n\ndef main():\n    n, q, illusion_rates, tree, queries = parse_input()\n    results ="}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, tunnel connections, and queries.\",\n      \"details\": [\n        \"Read the first line to get integers n (number of rooms) and q (number of queries).\",\n        \"Read the second line to get the list of n integers representing the initial illusion rates of each room.\",\n        \"Read the next n-1 lines to get pairs of integers representing tunnel connections between rooms.\",\n        \"Read the next q lines to get the queries, which can be of two types: update or calculate energy.\"\n      ]\n    },\n    {\n      \"description\": \"Represent the maze as a tree structure using the tunnel connections.\",\n      \"details\": [\n        \"Use the tunnel connections to build a tree data structure where each room is a node and each tunnel is an edge.\"\n      ]\n    },\n    {\n      \"description\": \"Implement query processing logic.\",\n      \"details\": [\n        \"For type 1 queries, update the illusion rate of the specified room.\",\n        \"For type 2 queries, calculate the minimum sum of energy needed to move from the start room to the end room.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the energy required for movement between rooms.\",\n      \"details\": [\n        \"For each movement from room s to room t, calculate the energy using the formula: max(|a_s + a_t|, |a_s - a_t|).\",\n        \"Sum the energy values for the path from the start room to the end room.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for type 2 queries.\",\n      \"details\": [\n        \"For each type 2 query, output the calculated energy sum.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Construct the tree representation of the maze using the tunnel connections.\",\n    \"Iterate over each query and process it based on its type.\",\n    \"For type 1 queries, update the illusion rate of the specified room.\",\n    \"For type 2 queries, calculate the energy required to move from the start room to the end room using the tree structure.\",\n    \"Output the results for each type 2 query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: In the requirement, the maze is represented as a tree structure, where each room is a node and each tunnel is an edge. This implies that there are no cycles, and there is exactly one path between any two rooms.\n\n    'illusion rate'\n    Explanation: This is a value associated with each room, which affects the energy calculation when moving between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_s + a_t|, |a_s - a_t|), where a_s and a_t are the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_s + a_t|, |a_s - a_t|)': This indicates that for each movement between two rooms, the energy is the maximum of the absolute sum or absolute difference of their illusion rates. In code, this can be implemented using the `max` function with `abs`.\n\n# [degree adverb] \n    'minimum sum': This refers to the total energy required for a path, which is the sum of the maximum energy values calculated for each segment of the path. The goal is to compute this sum for the entire path.\n\n# [code logic]\n    The steps for parsing input, constructing the tree, and processing queries should be implemented sequentially. However, within the query processing, type 1 and type 2 queries are distinct and should be handled separately. The energy calculation for type 2 queries involves iterating over the path and summing the energy values, which can be done in a single loop.\n\n# [edge case] \n    1. Input with minimum values: n = 2, q = 1, with illusion rates [0, 0] and a single type 2 query from room 1 to room 2.\n       Expected output: 0\n       Explanation: The energy calculation max(|0 + 0|, |0 - 0|) results in 0.\n\n    2. All rooms have the same illusion rate: n = 3, q = 1, with illusion rates [5, 5, 5] and a type 2 query from room 1 to room 3.\n       Expected output: 10\n       Explanation: Each movement between rooms results in max(|5 + 5|, |5 - 5|) = 10, and there are two movements.\n\n    ", "Round_0": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    \n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            queries.append((query_type, room, new_rate))\n            index += 3\n        else:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            queries.append((query_type, start, end))\n            index += 3\n    \n    def bfs_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    results = []\n    \n    for query in queries:\n        if query[0] == 1:\n            _, room, new_rate = query\n            illusion_rates[room] = new_rate\n        else:\n            _, start, end = query\n            path = bfs_path(start, end)\n            energy_sum = 0\n            for i in range(len(path) - 1):\n                s = path[i]\n                t = path[i + 1]\n                energy = max(abs(illusion_rates[s] + illusion_rates[t]), abs(illusion_rates[s] - illusion_rates[t]))\n                energy_sum += energy\n            results.append(energy_sum)\n    \n    for result in results:\n        print(result)", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the connections between rooms.\",\n      \"details\": \"Read the input data and store the number of rooms (n), number of queries (q), the list of initial illusion rates for each room, and the list of connections (edges) between rooms.\"\n    },\n    {\n      \"description\": \"Construct a tree data structure to represent the maze of rooms and tunnels.\",\n      \"details\": \"Use the list of connections to build a tree structure where each node represents a room and edges represent tunnels.\"\n    },\n    {\n      \"description\": \"Implement a function to calculate the energy required to move between two rooms.\",\n      \"details\": \"For a given path between two rooms, calculate the energy required using the formula max(|a_i + a_j|, |a_i - a_j|) for each pair of consecutive rooms in the path.\"\n    },\n    {\n      \"description\": \"Implement a function to handle type 1 queries to update the illusion rate of a specific room.\",\n      \"details\": \"Update the illusion rate of the specified room in the data structure when a type 1 query is encountered.\"\n    },\n    {\n      \"description\": \"Implement a function to handle type 2 queries to calculate the minimum energy required for a given path.\",\n      \"details\": \"Use the energy calculation function to determine the total energy required for the path specified in the type 2 query.\"\n    },\n    {\n      \"description\": \"Output the results for each type 2 query.\",\n      \"details\": \"For each type 2 query, output the calculated energy to the standard output.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and connections between rooms.\",\n    \"Construct a tree data structure to represent the maze using the connections.\",\n    \"Define a function to calculate the energy required to move between two rooms based on their illusion rates.\",\n    \"Iterate over each query:\",\n    \"  - If the query is of type 1, update the illusion rate of the specified room.\",\n    \"  - If the query is of type 2, calculate the minimum energy required for the specified path and store the result.\",\n    \"Output the results for all type 2 queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A tree is a data structure consisting of nodes, where each node has zero or more child nodes, and one node is designated as the root. In this context, the rooms and tunnels form a tree structure.\n    'illusion rate': This refers to the integer value associated with each room, which affects the energy calculation when moving between rooms.\n\n# [phrase showing quantity relationship]\n    'minimum sum of energy': This means calculating the least amount of energy required to move from one room to another, considering the illusion rates.\n    Implementation: Use the formula max(|a_i + a_j|, |a_i - a_j|) for each pair of consecutive rooms in the path to calculate the energy.\n\n# [degree adverb]\n    'minimum': This indicates that the goal is to find the least amount of energy required for the path.\n    Implementation: Accumulate the energy calculated for each segment of the path and ensure it is the smallest possible sum.\n\n# [code logic]\n    The steps related to handling type 2 queries (calculating energy) should be implemented simultaneously within a loop that processes each query. This involves parsing the query, calculating the energy, and storing the result in one code block.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 2\n           1 1 1\n           1 2\n           2 3\n           2 1 3\n           1 2 2\n           2 1 3\n    Expected Output: 2\n                     3\n    Explanation: Initially, the energy from room 1 to 3 is calculated as 2. After updating room 2's illusion rate to 2, the energy becomes 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating energy using the formula max(|a_i + a_j|, |a_i - a_j|) will handle these cases correctly.\n\nNO", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef calculate_energy(a, path):\n    energy = 0\n    for i in range(len(path) - 1):\n        u, v = path[i], path[i + 1]\n        energy += max(abs(a[u] + a[v]), abs(a[u] - a[v]))\n    return energy\n\ndef bfs_path(tree, start, end):\n    queue = deque([start])\n    parent = {start: None}\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            break\n        for neighbor in tree[node]:\n            if neighbor not in parent:\n                parent[neighbor] = node\n                queue.append(neighbor)\n    \n    path = []\n    while end is not None:\n        path.append(end)\n        end = parent[end]\n    path.reverse()\n    return path\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            a[room] = new_rate\n            index += 3\n        elif query_type == 2:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            path = bfs_path(tree, start, end)\n            energy = calculate_energy(a, path)\n            results.append(energy)\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 150)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef calculate_energy(a, path):\n    energy = 0\n    for i in range(len(path) - 1):\n        u, v = path[i], path[i + 1]\n        energy += max(abs(a[u] + a[v]), abs(a[u] - a[v]))\n    return energy\n\ndef bfs_path(tree, start, end):\n    queue = deque([start])\n    parent = {start: None}\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            break\n        for neighbor in tree[node]:\n            if neighbor not in parent:\n                parent[neighbor] = node\n                queue.append(neighbor)\n    \n    path = []\n    while end is not None:\n        path.append(end)\n        end = parent[end]\n    path.reverse()\n    return path\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            a[room] = new_rate\n            index += 3\n        elif query_type == 2:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            path = bfs_path(tree, start, end)\n            energy = calculate_energy(a, path)\n            results.append(energy)\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, tunnel connections, and queries.\",\n      \"details\": [\n        \"Read the first line to get integers n (number of rooms) and q (number of queries).\",\n        \"Read the second line to get the list of n integers representing the initial illusion rates of each room.\",\n        \"Read the next n-1 lines to get pairs of integers representing tunnel connections between rooms.\",\n        \"Read the next q lines to get the queries, which can be of two types: update or calculate energy.\"\n      ]\n    },\n    {\n      \"description\": \"Represent the maze as a tree structure using the tunnel connections.\",\n      \"details\": [\n        \"Use the tunnel connections to build a tree data structure where each room is a node and each tunnel is an edge.\"\n      ]\n    },\n    {\n      \"description\": \"Implement query processing logic.\",\n      \"details\": [\n        \"For type 1 queries, update the illusion rate of the specified room.\",\n        \"For type 2 queries, calculate the minimum sum of energy needed to move from the start room to the end room.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the energy required for movement between rooms.\",\n      \"details\": [\n        \"For each movement from room s to room t, calculate the energy using the formula: max(|a_s + a_t|, |a_s - a_t|).\",\n        \"Sum the energy for all movements in the path from the start room to the end room.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for type 2 queries.\",\n      \"details\": [\n        \"For each type 2 query, output the calculated energy.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Construct the tree representation of the maze using the tunnel connections.\",\n    \"Iterate over each query and process it based on its type.\",\n    \"For type 1 queries, update the illusion rate of the specified room.\",\n    \"For type 2 queries, calculate the energy required to move from the start room to the end room using the tree structure.\",\n    \"Output the results for each type 2 query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree structure'\n    Explanation: The maze is represented as a tree, meaning there are no cycles, and each room is connected in a hierarchical manner. This structure is crucial for traversing paths between rooms efficiently.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy calculation when moving between rooms. The illusion rate can be positive or negative.\n\n# [phrase showing quantity relationship]\n    'minimum sum of energy'\n    Explanation: For type 2 queries, the task is to calculate the total energy required to move from one room to another, using the formula max(|a_s + a_t|, |a_s - a_t|) for each step. This involves summing the energy for all movements along the path.\n\n# [degree adverb]\n    'max'\n    Explanation: The energy calculation for moving between rooms uses the maximum value between two expressions: |a_s + a_t| and |a_s - a_t|. This ensures the energy cost accounts for the greatest possible illusion impact.\n\n# [code logic]\n    The steps for processing type 2 queries should be implemented simultaneously:\n    \"Calculate the energy required for movement between rooms\" and \"Output the results for type 2 queries\" should be integrated into a single loop that processes each query and immediately outputs the result.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so the energy required for movement is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 1\n           10 -10 10\n           1 2\n           2 3\n           2 1 3\n    Expected Output: 30\n    Explanation: The path is 1 \u2192 2 \u2192 3. Energy calculations are max(|10 + (-10)|, |10 - (-10)|) = 20 and max(|-10 + 10|, |-10 - 10|) = 10, totaling 30.\n\n    Input: 4 1\n           5 5 5 5\n           1 2\n           2 3\n           3 4\n           2 1 4\n    Expected Output: 30\n    Explanation", "Round_0": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Build the tree\n    tree = collections.defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    # Preprocess to find parent and depth using BFS\n    parent = [-1] * n\n    depth = [0] * n\n    def bfs():\n        queue = collections.deque([0])\n        visited = [False] * n\n        visited[0] = True\n        while queue:\n            node = queue.popleft()\n            for neighbor in tree[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    parent[neighbor] = node\n                    depth[neighbor] = depth[node] + 1\n                    queue.append(neighbor)\n    \n    bfs()\n    \n    # Function to find LCA\n    def lca(u, v):\n        if depth[u] < depth[v]:\n            u, v = v, u\n        # Bring u and v to the same depth\n        while depth[u] > depth[v]:\n            u = parent[u]\n        while u != v:\n            u = parent[u]\n            v = parent[v]\n        return u\n    \n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            illusion_rates[room] = new_rate\n            index += 3\n        elif query_type == 2:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            index += 3\n            \n            # Find LCA of start and end\n            ancestor = lca(start, end)\n            \n            # Calculate energy from start to ancestor\n            energy = 0\n            current = start\n            while current != ancestor:", "report": "The compilation output of the preceding code is: expected an indented block (<string>, line 73)"}, "Round_1": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Build the tree\n    tree = collections.defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    # Preprocess to find parent and depth using BFS\n    parent = [-1] * n\n    depth = [0] * n\n    def bfs():\n        queue = collections.deque([0])\n        visited = [False] * n\n        visited[0] = True\n        while queue:\n            node = queue.popleft()\n            for neighbor in tree[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    parent[neighbor] = node\n                    depth[neighbor] = depth[node] + 1\n                    queue.append(neighbor)\n    \n    bfs()\n    \n    # Function to find LCA\n    def lca(u, v):\n        if depth[u] < depth[v]:\n            u, v = v, u\n        # Bring u and v to the same depth\n        while depth[u] > depth[v]:\n            u = parent[u]\n        while u != v:\n            u = parent[u]\n            v = parent[v]\n        return u\n    \n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            illusion_rates[room] = new_rate\n            index += 3\n        elif query_type == 2:\n            start = int(data[index + 1]) - 1"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the connections between rooms.\",\n      \"output\": \"A data structure representing the tree of rooms and their initial illusion rates.\"\n    },\n    {\n      \"description\": \"Implement a function to update the illusion rate of a specific room based on a query.\",\n      \"output\": \"Updated data structure with the new illusion rate for the specified room.\"\n    },\n    {\n      \"description\": \"Implement a function to calculate the minimum energy required to move from one room to another based on the current illusion rates.\",\n      \"output\": \"The minimum energy required for the specified path.\"\n    },\n    {\n      \"description\": \"Process each query and determine whether it is an update or a calculation query, then execute the appropriate function.\",\n      \"output\": \"Results for each calculation query.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and the connections between rooms. Represent the maze as a tree data structure.\",\n    \"For each query, check if it is an update query or a calculation query.\",\n    \"If it is an update query, update the illusion rate of the specified room.\",\n    \"If it is a calculation query, determine the path between the specified rooms and calculate the minimum energy required using the current illusion rates.\",\n    \"Output the result for each calculation query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The rooms and tunnels form a tree structure, which means there are no cycles, and there is exactly one path between any two rooms.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy calculation when moving between rooms.\n\n    'query'\n    Explanation: There are two types of queries: one that updates the illusion rate of a room and another that calculates the energy required to move between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a + b|, |a - b|)'\n    Explanation: This phrase describes the energy calculation between two connected rooms. It means you take the maximum of the absolute value of the sum and the absolute value of the difference of the illusion rates of the two rooms.\n    Implementation: `energy = max(abs(a + b), abs(a - b))`\n\n# [degree adverb] \n    'minimum'\n    Explanation: For type 2 queries, the task is to find the minimum sum of energy needed to move from one room to another.\n    Implementation: This involves calculating the energy for each segment of the path and summing them up.\n\n# [code logic]\n    The steps for parsing input and representing the maze as a tree should be implemented simultaneously. This involves reading the input data and constructing the tree structure in one go.\n\n# [edge case] \n    1. Input: 2 1\n             0 0\n             1 2\n             2 1 2\n       Output: 0\n       Explanation: Both rooms have an illusion rate of 0, so the energy required is 0.\n\n    2. Input: 3 2\n             1 1 1\n             1 2\n             2 3\n             2 1 3\n             1 1 2\n       Output: 2\n       Explanation: Initially, the energy from room 1 to 3 is 2. After updating room 1's illusion rate to 2, the energy remains 2.\n\n    3. Input: 4 1\n             5 -5 5 -5\n             1 2\n             2 3\n             3 4\n             2 1 4\n       Output: 20\n       Explanation: The path 1 -> 2 -> 3 -> 4 requires 10 energy for each segment, totaling", "Round_0": {"code": "def parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        index += 1\n        t = int(data[index]) - 1\n        index += 1\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index])\n        index += 1\n        queries.append((query_type, u, v))\n    \n    return n, q, illusion_rates, tree, queries\n\ndef update_illusion_rate(illusion_rates, room, new_rate):\n    illusion_rates[room] = new_rate\n\ndef calculate_energy(illusion_rates, tree, start, end):\n    # BFS to find the path from start to end\n    queue = deque([(start, -1)])\n    parent = {start: None}\n    \n    while queue:\n        current, prev = queue.popleft()\n        parent[current] = prev\n        if current == end:\n            break\n        for neighbor in tree[current]:\n            if neighbor != prev:\n                queue.append((neighbor, current))\n    \n    # Calculate energy along the path\n    energy = 0\n    current = end\n    while parent[current] is not None:\n        prev = parent[current]\n        a = illusion_rates[current]\n        b = illusion_rates[prev]\n        energy += max(abs(a + b), abs(a - b))\n        current = prev\n    \n    return energy\n\ndef process_queries(n, q, illusion_rates, tree, queries):\n    results = []\n    for query_type, u, v in queries:\n        if query_type == 1:\n            update_illusion_rate(illusion_rates, u, v)\n        elif query_type == 2:\n            energy = calculate_energy(illusion_rates, tree, u, v - 1)\n            results.append(energy)\n    return results\n\ndef main():\n    n, q", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, tunnel connections, and queries.\",\n      \"details\": [\n        \"Read the first line to get integers n (number of rooms) and q (number of queries).\",\n        \"Read the second line to get the list of n integers representing the initial illusion rates of each room.\",\n        \"Read the next n-1 lines to get pairs of integers representing tunnel connections between rooms.\",\n        \"Read the next q lines to get the queries, which can be of two types: update or calculate energy.\"\n      ]\n    },\n    {\n      \"description\": \"Represent the maze as a tree structure using the tunnel connections.\",\n      \"details\": [\n        \"Use the tunnel connections to build a tree data structure where each room is a node and each tunnel is an edge.\"\n      ]\n    },\n    {\n      \"description\": \"Implement query handling logic.\",\n      \"details\": [\n        \"For type 1 queries, update the illusion rate of the specified room.\",\n        \"For type 2 queries, calculate the minimum sum of energy needed to move from the start room to the end room.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the energy required for movement between rooms.\",\n      \"details\": [\n        \"For each movement between two connected rooms, calculate the energy using the formula: max(|a_i + a_j|, |a_i - a_j|).\",\n        \"Sum the energy for all movements in the path from the start room to the end room.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for type 2 queries.\",\n      \"details\": [\n        \"For each type 2 query, output the calculated energy.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Construct the tree representation of the maze using the tunnel connections.\",\n    \"Iterate over each query and perform the required operations based on the query type.\",\n    \"For type 1 queries, update the illusion rate of the specified room.\",\n    \"For type 2 queries, calculate the energy required to move from the start room to the end room using the tree structure.\",\n    \"Output the calculated energy for each type 2 query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree structure'\n    Explanation: The maze is represented as a tree, which is a connected acyclic graph. Each room is a node, and each tunnel is an edge connecting two nodes.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy calculation when moving between rooms.\n\n    'query types'\n    Explanation: There are two types of queries: one to update the illusion rate of a room and another to calculate the energy required to move between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_i + a_j|, |a_i - a_j|)': This phrase indicates that for each movement between two connected rooms, the energy required is the maximum of the absolute sum or absolute difference of their illusion rates. In code, this can be implemented using the `max` function: `max(abs(a_i + a_j), abs(a_i - a_j))`.\n\n# [degree adverb]\n    'minimum sum': This refers to the total energy required for a path, which is the sum of the maximum energy values calculated for each segment of the path. The goal is to compute this sum for the entire path from the start room to the end room.\n\n# [code logic]\n    The steps for handling type 2 queries (calculating energy) should be implemented simultaneously:\n    - Calculate the energy for each segment of the path using the formula `max(|a_i + a_j|, |a_i - a_j|)`.\n    - Sum these energies to get the total energy for the path.\n    This can be done in a single loop that traverses the path and accumulates the energy.\n\n# [edge case]\n    1. Input: `2 1\\n0 0\\n1 2\\n2 1 2` = 0\n       Explanation: With only two rooms and both having an illusion rate of 0, the energy required is `max(|0 + 0|, |0 - 0|) = 0`.\n\n    2. Input: `3 1\\n10 -10 0\\n1 2\\n2 3\\n2 1 3` = 20\n       Explanation: The path from room 1 to room 3 goes through room 2. The energy calculations are `max(|10 + (-10)|, |10 - (-10)|) = 20` and `max(|-10 + 0|, |-10 -", "Round_0": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = defaultdict(list)\n    \n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            queries.append((query_type, room, new_rate))\n            index += 3\n        else:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            queries.append((query_type, start, end))\n            index += 3\n    \n    def bfs_path(start, end):\n        parent = {start: None}\n        queue = deque([start])\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    results = []\n    \n    for query in queries:\n        if query[0] == 1:\n            _, room, new_rate = query\n            illusion_rates[room] = new_rate\n        else:\n            _, start, end = query\n            path = bfs_path(start, end)\n            total_energy = 0\n            for i in range(len(path) - 1):\n                u = path[i]\n                v = path[i + 1]\n                energy = max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n                total_energy += energy\n            results.append(total_energy)\n    \n    for result in results:\n        print(result)", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"name\": \"Parse Input\",\n      \"description\": \"Read and parse the input to extract the number of rooms, number of queries, initial illusion rates, and the connections between rooms.\"\n    },\n    {\n      \"name\": \"Build Tree Structure\",\n      \"description\": \"Construct a tree data structure to represent the maze using the room connections provided.\"\n    },\n    {\n      \"name\": \"Process Queries\",\n      \"description\": \"Iterate through each query and perform the necessary operations based on the query type.\"\n    },\n    {\n      \"name\": \"Update Illusion Rate\",\n      \"description\": \"For type 1 queries, update the illusion rate of the specified room.\"\n    },\n    {\n      \"name\": \"Calculate Minimum Energy\",\n      \"description\": \"For type 2 queries, calculate the minimum energy required to move from the start room to the end room using the current illusion rates.\"\n    },\n    {\n      \"name\": \"Output Results\",\n      \"description\": \"Output the results for each type 2 query.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, and room connections.\",\n    \"Construct a tree data structure to represent the maze using the room connections.\",\n    \"Initialize a data structure to store the current illusion rates of each room.\",\n    \"Iterate through each query:\",\n    \"  - If the query is of type 1, update the illusion rate of the specified room.\",\n    \"  - If the query is of type 2, perform a traversal from the start room to the end room:\",\n    \"    - Calculate the energy required for each step using the formula max(|a + b|, |a - b|) where a and b are the illusion rates of the connected rooms.\",\n    \"    - Accumulate the total energy required for the path.\",\n    \"    - Store the result for this query.\",\n    \"Output the results for all type 2 queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'real time'\n    Explanation: The algorithm needs to handle queries efficiently as they are received, implying the need for optimized data structures and algorithms to ensure quick updates and calculations.\n\n    'tree'\n    Explanation: The maze is represented as a tree, which is a connected acyclic graph. This structure is important for understanding the connectivity and traversal between rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a + b|, |a - b|)'\n    Explanation: This phrase describes the calculation of energy required to move between two rooms. It means you take the maximum of the absolute value of the sum and the absolute value of the difference of the illusion rates of two connected rooms.\n    Implementation: In code, this can be implemented as `energy = max(abs(a + b), abs(a - b))`.\n\n# [degree adverb]\n    'minimum'\n    Explanation: For type 2 queries, the task is to calculate the minimum sum of energy needed for the path from the start room to the end room.\n    Implementation: This involves accumulating the energy calculated for each step along the path and ensuring the path chosen is optimal in terms of energy usage.\n\n# [code logic]\n    The steps \"Update Illusion Rate\" and \"Calculate Minimum Energy\" should be considered separately as they correspond to different types of queries. However, within the \"Calculate Minimum Energy\" step, the calculation of energy for each step and the accumulation of total energy should be implemented simultaneously in a loop that traverses the path.\n\n# [edge case]\n    1. Input: 2 1\n       0 0\n       1 2\n       2 1 2\n       Expected Output: 0\n       Explanation: With both rooms having an illusion rate of 0, the energy required for any movement is 0.\n\n    2. Input: 3 2\n       1 1 1\n       1 2\n       2 3\n       2 1 3\n       1 1 2\n       2 1 3\n       Expected Output: 2, 4\n       Explanation: Initially, moving from room 1 to 3 via room 2 requires 2 energy. After updating room 1's illusion rate to 2, the energy required becomes 4.\n\n    3. Input: 4 1\n       5 -5 5 -5\n       1 2\n      ", "Round_0": {"code": "import sys\nimport collections\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Build the tree\n    tree = collections.defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            illusion_rates[room] = new_rate\n            index += 3\n        elif query_type == 2:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            index += 3\n            \n            # BFS to find the path from start to end\n            queue = collections.deque([(start, -1)])\n            parent = {start: None}\n            \n            while queue:\n                current, prev = queue.popleft()\n                if current == end:\n                    break\n                for neighbor in tree[current]:\n                    if neighbor != prev and neighbor not in parent:\n                        parent[neighbor] = current\n                        queue.append((neighbor, current))\n            \n            # Calculate the energy required for the path\n            total_energy = 0\n            current = end\n            while parent[current] is not None:\n                prev = parent[current]\n                a = illusion_rates[current]\n                b = illusion_rates[prev]\n                energy = max(abs(a + b), abs(a - b))\n                total_energy += energy\n                current = prev\n            \n            results.append(total_energy)\n    \n    # Output results for type 2 queries\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 142)"}, "Round_1": {"code": "import sys\nimport collections\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Build the tree\n    tree = collections.defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            illusion_rates[room] = new_rate\n            index += 3\n        elif query_type == 2:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            index += 3\n            \n            # BFS to find the path from start to end\n            queue = collections.deque([(start, -1)])\n            parent = {start: None}\n            \n            while queue:\n                current, prev = queue.popleft()\n                if current == end:\n                    break\n                for neighbor in tree[current]:\n                    if neighbor != prev and neighbor not in parent:\n                        parent[neighbor] = current\n                        queue.append((neighbor, current))\n            \n            # Calculate the energy required for the path\n            total_energy = 0\n            current = end\n            while parent[current] is not None:\n                prev = parent[current]\n                a = illusion_rates[current]\n                b = illusion_rates[prev]\n                energy = max(abs(a + b), abs(a - b))\n                total_energy += energy\n                current = prev\n            \n            results.append(total_energy)\n    \n    # Output results for type 2 queries\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of rooms, number of queries, initial illusion rates, tunnel connections, and queries.\",\n      \"details\": [\n        \"Read the first line to get integers n (number of rooms) and q (number of queries).\",\n        \"Read the second line to get the list of n integers representing the initial illusion rates of each room.\",\n        \"Read the next n-1 lines to get pairs of integers representing tunnel connections between rooms.\",\n        \"Read the next q lines to get the queries, which can be either type 1 (update illusion rate) or type 2 (calculate energy).\"\n      ]\n    },\n    {\n      \"description\": \"Represent the maze as a tree structure using the tunnel connections.\",\n      \"details\": [\n        \"Use the tunnel connections to build a tree data structure where each room is a node and each tunnel is an edge.\"\n      ]\n    },\n    {\n      \"description\": \"Implement query processing logic.\",\n      \"details\": [\n        \"For type 1 queries, update the illusion rate of the specified room.\",\n        \"For type 2 queries, calculate the minimum sum of energy needed to move from the start room to the end room using the current illusion rates.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the energy required for movement between rooms.\",\n      \"details\": [\n        \"For each movement from room s to room t, calculate the energy as max(|a_s + a_t|, |a_s - a_t|) where a_s and a_t are the illusion rates of rooms s and t respectively.\",\n        \"Sum the energy for all movements in the path from the start room to the end room.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Build a tree representation of the maze using the tunnel connections.\",\n    \"Process each query sequentially:\",\n    \"  - If the query is type 1, update the illusion rate of the specified room.\",\n    \"  - If the query is type 2, calculate the energy required to move from the start room to the end room and output the result.\",\n    \"For type 2 queries, traverse the tree to find the path between the specified rooms and calculate the energy required for each segment of the path.\",\n    \"Output the results for each type 2 query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a numerical value associated with each room, which affects the energy calculation when moving between rooms.\n\n    'tree structure'\n    Explanation: The maze is represented as a tree, meaning there are no cycles, and each room is connected in a hierarchical manner.\n\n# [phrase showing quantity relationship]\n    'max(|a_s + a_t|, |a_s - a_t|)'\n    Explanation: This phrase indicates that for each movement between rooms, the energy required is the maximum of the absolute sum or absolute difference of the illusion rates of the two rooms. In code, this can be implemented using the `max` function and `abs` function: `max(abs(a_s + a_t), abs(a_s - a_t))`.\n\n# [degree adverb]\n    'minimum sum'\n    Explanation: This refers to the total energy required for a path, which is the sum of the maximum energy values calculated for each segment of the path. The goal is to find the minimum sum of energy needed for the entire path.\n\n# [code logic]\n    The steps for processing type 2 queries should be implemented simultaneously:\n    \"Calculate the energy required to move from the start room to the end room and output the result.\"\n    This involves traversing the tree to find the path and calculating the energy for each segment in one code block.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so the energy required for movement is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 1\n           1 1 1\n           1 2\n           2 3\n           2 1 3\n    Expected Output: 2\n    Explanation: The path is 1 \u2192 2 \u2192 3, with energy calculations max(|1 + 1|, |1 - 1|) = 2 and max(|1 + 1|, |1 - 1|) = 2, totaling 2.\n\n    Input: 4 1\n           10 -10 10 -10\n           1 2\n           2 3\n           3 4\n           2 1 4\n   ", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of rooms and queries\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read initial illusion rates\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read tunnel connections and build the tree\n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        tree[s].append(t)\n        tree[t].append(s)\n        index += 2\n    \n    # Function to find path using BFS\n    def find_path(start, end):\n        queue = deque([start])\n        parent = {start: None}\n        \n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        \n        return path[::-1]\n    \n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1]) - 1\n            new_rate = int(data[index + 2])\n            illusion_rates[room] = new_rate\n            index += 3\n        elif query_type == 2:\n            start = int(data[index + 1]) - 1\n            end = int(data[index + 2]) - 1\n            index += 3\n            \n            path = find_path(start, end)\n            energy_sum = 0\n            for i in range(len(path) - 1):\n                s = path[i]\n                t = path[i + 1]\n                energy_sum += max(abs(illusion_rates[s] + illusion_rates[t]), abs(illusion_rates[s] - illusion_rates[t]))\n            \n            results.append(energy_sum)\n    \n    # Output results for type 2 queries\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, false, true, false, true, false, true, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 624, "prompt": "Chanek and Indiana require your assistance in creating an effective algorithm to manage multiple requests, simulating the treasure hunt process in real time.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "condense_two2one", "save_node": true, "parent_index": 336}
