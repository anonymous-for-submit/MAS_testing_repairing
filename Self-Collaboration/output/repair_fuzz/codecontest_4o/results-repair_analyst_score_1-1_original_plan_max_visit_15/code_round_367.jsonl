{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "repair_prompt": ["CQXYM located a rectangle A with dimensions n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is either an obsidian block or empty. CQXYM can convert an obsidian block to an empty block or vice versa in a single operation.\n\nA rectangle M of dimensions a \u00d7 b is identified as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5, b must be at least 4. This means that b must be no less than 4.\n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type.\n\nIt is important to note that a rows and b columns are required, not b rows and a columns.\n\nAlso note that corners can be any type.\n\nCQXYM wants to determine the smallest number of operations required to transform at least one sub-rectangle into a portal. Analyze all potential sub-rectangles of A to obtain the best solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM located a rectangle A with dimensions n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is either an obsidian block or empty. CQXYM can convert an obsidian block to an empty block or vice versa in a single operation.\n\nA rectangle M of dimensions a \u00d7 b is identified as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5, b must be at least 4. This means that b must be no less than 4.\n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. These corner blocks do not have a prescribed type and can be either obsidian or empty blocks.\n\nIt is important to note that a rows and b columns are required, not b rows and a columns.\n\nAlso note that corners can be any type.\n\nCQXYM wants to determine the smallest number of operations required to transform at least one sub-rectangle into a portal. Analyze all potential sub-rectangles of A to obtain the best solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM located a rectangle A with dimensions n \u00d7 m. There are n rows and m columns of blocks; each block of the rectangle is either an obsidian block or empty, and CQXYM can convert an obsidian block to an empty block or vice versa in a single operation.\n\nA rectangle M of dimensions a \u00d7 b is identified as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5, b must be at least 4.\n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type.\n\nIt is important to note that a rows and b columns are required, not b rows and a columns.\n\nAlso note that corners can be any type.\n\nCQXYM wants to determine the smallest number of operations required to transform at least one sub-rectangle into a portal. Analyze all potential sub-rectangles of A to obtain the best solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check if it's a border block\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and y == 0) or (x == 0 and y == b - 1) or (x == a - 1 and y == 0) or (x == a - 1 and y == b - 1):\n                                        # Corner blocks can be any type\n                                        continue\n                                    else:\n                                        # Border blocks must be obsidian\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inner blocks must be empty\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n                        \n                        # Check the border conditions for obsidian blocks\n                        for x in range(1, a - 1):\n                            if grid[start_row + x][start_col] != '1':\n                                operations += 1\n                            if grid[start_row + x][start_col + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(1, b - 1):\n                            if grid[start_row][start_col + y] != '1':\n                                operations += 1\n                            if grid[start_row + a - 1][start_col + y] != '1':\n                                operations += 1\n                        \n                        # Count the number of operations needed for interior blocks\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[start_row + x][start_col + y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate operations needed for this sub-rectangle\n                        operations = 0\n                        valid = True\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check borders\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and (y == 0 or y == b - 1)) or (x == a - 1 and (y == 0 or y == b - 1)):\n                                        # Corners can be any type\n                                        continue\n                                    if current_block == '0':\n                                        operations += 1\n                                else:\n                                    # Interior must be empty\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update minimum operations if this sub-rectangle is valid\n                        if valid:\n                            min_operations = min(min_operations, operations)\n        \n        # Handle the case where no valid portal can be formed\n        if min_operations == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    for result in results:\n        print(result)\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n):\n            for j in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = 0\n                        \n                        # Check border conditions for obsidian blocks\n                        for x in range(i + 1, i + a - 1):\n                            if grid[x][j] != '1':\n                                operations += 1\n                            if grid[x][j + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(j + 1, j + b - 1):\n                            if grid[i][y] != '1':\n                                operations += 1\n                            if grid[i + a - 1][y] != '1':\n                                operations += 1\n                        \n                        # Count operations needed to convert interior blocks to empty blocks\n                        for x in range(i + 1, i + a - 1):\n                            for y in range(j + 1, j + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Update minimum operations for this test case\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        \n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible starting points (i, j) for the sub-rectangle\n        for i in range(n):\n            for j in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = 0\n                        \n                        # Check the border conditions for obsidian blocks\n                        for x in range(i, i + a):\n                            if x == i or x == i + a - 1:\n                                # Top and bottom borders\n                                for y in range(j + 1, j + b - 1):\n                                    if grid[x][y] != '1':\n                                        operations += 1\n                            else:\n                                # Left and right borders\n                                if grid[x][j] != '1':\n                                    operations += 1\n                                if grid[x][j + b - 1] != '1':\n                                    operations += 1\n                        \n                        # Check the inner blocks for empty blocks\n                        for x in range(i + 1, i + a - 1):\n                            for y in range(j + 1, j + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        valid = True\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check the border conditions\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and y == 0) or (x == 0 and y == b - 1) or (x == a - 1 and y == 0) or (x == a - 1 and y == b - 1):\n                                        # Corners can be any type\n                                        continue\n                                    else:\n                                        # Borders must be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inside must be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations if this sub-rectangle is valid\n                        if valid:\n                            min_operations = min(min_operations, operations)\n        \n        # If no valid portal was found, return -1\n        if min_operations == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed to make this sub-rectangle a portal\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check the border conditions\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and (y == 0 or y == b - 1)) or (x == a - 1 and (y == 0 or y == b - 1)):\n                                        # Corners can be any type\n                                        continue\n                                    else:\n                                        # Border should be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inner should be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of the sub-rectangle\n        for i in range(n):\n            for j in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the top and bottom borders\n                        for x in range(1, b - 1):\n                            if grid[i][j + x] != '1':  # Top border\n                                operations += 1\n                            if grid[i + a - 1][j + x] != '1':  # Bottom border\n                                operations += 1\n                        \n                        # Check the left and right borders\n                        for y in range(1, a - 1):\n                            if grid[i + y][j] != '1':  # Left border\n                                operations += 1\n                            if grid[i + y][j + b - 1] != '1':  # Right border\n                                operations += 1\n                        \n                        # Check the inner area\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate operations needed to transform this sub-rectangle into a portal\n                        operations = 0\n                        for i in range(a):\n                            for j in range(b):\n                                current_block = grid[start_row + i][start_col + j]\n                                if i == 0 or i == a - 1 or j == 0 or j == b - 1:\n                                    # Border blocks (except corners)\n                                    if (i == 0 and j == 0) or (i == 0 and j == b - 1) or (i == a - 1 and j == 0) or (i == a - 1 and j == b - 1):\n                                        # Corners can be any type, no operation needed\n                                        continue\n                                    if current_block == '0':\n                                        operations += 1\n                                else:\n                                    # Inner blocks\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update minimum operations for this test case\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):  # a must be at least 5\n            for j in range(m - 3):  # b must be at least 4\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = 0\n                        \n                        # Check border conditions\n                        for x in range(1, a - 1):\n                            if grid[i + x][j] != '1':\n                                operations += 1\n                            if grid[i + x][j + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(1, b - 1):\n                            if grid[i][j + y] != '1':\n                                operations += 1\n                            if grid[i + a - 1][j + y] != '1':\n                                operations += 1\n                        \n                        # Check inner conditions\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    operations += 1\n                        \n                        # Update minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        # Handle edge case where no sub-rectangle can be transformed into a portal\n        if min_operations == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check if it's a border block\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and y == 0) or (x == 0 and y == b - 1) or (x == a - 1 and y == 0) or (x == a - 1 and y == b - 1):\n                                        # Corner blocks can be any type\n                                        continue\n                                    else:\n                                        # Border blocks must be obsidian\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inner blocks must be empty\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"output\": \"A list of test cases, where each test case contains the dimensions (n, m) and the grid as a list of strings.\"\n    },\n    {\n      \"description\": \"For each test case, iterate over all possible sub-rectangles of dimensions at least 5x4 within the given grid.\",\n      \"output\": \"A list of all possible sub-rectangles for each test case.\"\n    },\n    {\n      \"description\": \"For each sub-rectangle, check if it can be transformed into a portal by counting the number of operations needed.\",\n      \"output\": \"The number of operations required to transform each sub-rectangle into a portal.\"\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required to transform at least one sub-rectangle into a portal for each test case.\",\n      \"output\": \"The minimum number of operations for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, generate all possible sub-rectangles of dimensions at least 5x4.\",\n    \"For each sub-rectangle, calculate the number of operations needed to convert it into a portal by checking the conditions for portal formation.\",\n    \"Track the minimum number of operations needed for each test case.\",\n    \"Output the minimum number of operations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle of dimensions a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5': The number of rows in the portal must be at least 5.\n    'b must be at least 4': The number of columns in the portal must be no less than 4.\n    Implementation: These conditions can be checked using simple comparison operations in code.\n\n# [degree adverb]\n    'smallest': Refers to the minimum number of operations required to transform a sub-rectangle into a portal.\n    Implementation: This can be achieved by iterating through all possible sub-rectangles and keeping track of the minimum operations needed.\n\n# [code logic]\n    The steps for generating sub-rectangles and calculating operations should be considered simultaneously.\n    Explanation: While iterating over possible sub-rectangles, the calculation of operations needed to transform them into a portal can be done in the same loop to optimize performance.\n\n# [edge case]\n    Edge Case 1: A grid where all blocks are obsidian.\n    Expected Output: The number of operations needed to convert the inner blocks to empty blocks while maintaining the portal structure.\n    Explanation: Since all blocks are obsidian, the inner blocks need to be converted to empty blocks, and the border blocks need to be checked for compliance with portal criteria.\n\n    Edge Case 2: A grid where all blocks are empty.\n    Expected Output: The number of operations needed to convert the border blocks to obsidian while maintaining the portal structure.\n    Explanation: Since all blocks are empty, the border blocks need to be converted to obsidian, and the inner blocks need to be checked for compliance with portal criteria.\n\n    Edge Case 3: A grid with dimensions exactly 5x4.\n    Expected Output: The number of operations needed to transform this specific grid into a portal.\n    Explanation: The grid is the smallest possible size for a portal, so the operations needed will depend on the initial configuration of blocks.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: Additional logic is required to specifically handle cases where the grid is uniform (all obsidian or all empty) and when the grid is at the minimum size for a portal.\n\nYES", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check if it's a border block\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and y == 0) or (x == 0 and y == b - 1) or (x == a - 1 and y == 0) or (x == a - 1 and y == b - 1):\n                                        # Corner blocks can be any type\n                                        continue\n                                    else:\n                                        # Border blocks must be obsidian\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inner blocks must be empty\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the dimensions n and m.\",\n        \"Read the n lines of m characters representing the grid configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of dimensions a \u00d7 b within the given rectangle A, where a \u2265 5 and b \u2265 4.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b that satisfy the constraints.\"\n      ]\n    },\n    {\n      \"description\": \"For each identified sub-rectangle, calculate the number of operations required to transform it into a portal.\",\n      \"steps\": [\n        \"Check the border conditions for obsidian blocks as per the portal criteria.\",\n        \"Count the number of operations needed to convert the interior blocks to empty blocks.\",\n        \"Consider the flexibility of corner blocks.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required across all sub-rectangles for each test case.\",\n      \"steps\": [\n        \"Track the minimum operations needed for each test case.\",\n        \"Store the result for each test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all test cases.\",\n      \"steps\": [\n        \"Print the minimum number of operations for each test case on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles of valid dimensions.\",\n    \"For each sub-rectangle, calculate the operations needed to transform it into a portal.\",\n    \"Track and store the minimum operations required for each test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n \u00d7 m'\n    Explanation: This refers to the main grid or matrix where the operations will be performed. It consists of n rows and m columns.\n\n    'portal'\n    Explanation: A sub-rectangle within the main rectangle that meets specific criteria, including having certain blocks as obsidian and others as empty.\n\n    'obsidian block' and 'empty block'\n    Explanation: These are the two types of blocks in the grid. An obsidian block is represented by '1', and an empty block is represented by '0'.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b must be at least 4'\n    Explanation: This specifies the minimum dimensions for the sub-rectangle to be considered a portal. In code, this can be implemented by ensuring that any sub-rectangle considered has dimensions a and b that meet these criteria.\n\n# [degree adverb]\n    'smallest number of operations'\n    Explanation: This refers to the goal of minimizing the number of changes needed to transform a sub-rectangle into a portal. In code, this can be implemented by keeping track of the minimum operations required across all possible sub-rectangles.\n\n# [code logic]\n    The steps in the plan are well-structured and do not require simultaneous implementation. Each step logically follows from the previous one, and they should be executed in sequence.\n\n# [edge case]\n    Edge Case 1: A grid where all blocks are already in the portal configuration.\n    Example: \n    ```\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    ```\n    Expected Output: 0\n    Explanation: No operations are needed as the grid is already a portal.\n\n    Edge Case 2: A grid where no sub-rectangle can be a portal without changing every block.\n    Example:\n    ```\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    ```\n    Expected Output: 12\n    Explanation: All blocks need to be changed to form a portal.\n\n    Edge Case 3: A grid with the minimum size that can form a portal.\n    Example:\n    ```\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n                        \n                        # Check the border conditions for obsidian blocks\n                        for x in range(1, a - 1):\n                            if grid[start_row + x][start_col] != '1':\n                                operations += 1\n                            if grid[start_row + x][start_col + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(1, b - 1):\n                            if grid[start_row][start_col + y] != '1':\n                                operations += 1\n                            if grid[start_row + a - 1][start_col + y] != '1':\n                                operations += 1\n                        \n                        # Count the number of operations needed for interior blocks\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[start_row + x][start_col + y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the dimensions n and m.\",\n        \"Read the n lines of m characters representing the grid configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of dimensions a \u00d7 b within the given rectangle A that can potentially be transformed into a portal.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b that satisfy the portal conditions (a \u2265 5, b \u2265 4).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of operations required to transform each identified sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each sub-rectangle, check the border conditions for obsidian blocks.\",\n        \"Count the number of operations needed to convert the interior blocks to empty blocks.\",\n        \"Consider the corners as flexible and do not count operations for them.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required for each test case.\",\n      \"steps\": [\n        \"For each test case, track the minimum number of operations across all possible sub-rectangles.\",\n        \"Store the result for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles that can be transformed into a portal.\",\n    \"For each sub-rectangle, calculate the number of operations required to meet the portal criteria.\",\n    \"Track and store the minimum number of operations needed for each test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle with specific dimensions and block configurations. It must have obsidian blocks on its borders and empty blocks inside, except for the corners which can be any type.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5': The number of rows in the portal must be at least 5.\n    'b must be at least 4': The number of columns in the portal must be no less than 4.\n    Implementation: These conditions can be checked using simple comparison operations in code.\n\n# [degree adverb]\n    'smallest': Refers to the minimum number of operations required to transform a sub-rectangle into a portal.\n    Implementation: This can be implemented by keeping track of the minimum number of operations needed across all sub-rectangles.\n\n# [code logic]\n    The steps in the plan related to identifying sub-rectangles and calculating operations should be considered simultaneously. Specifically, iterating over possible sub-rectangles and calculating operations can be done in a nested loop structure where each sub-rectangle is evaluated immediately for transformation.\n\n# [edge case]\n    Edge case 1: A rectangle with dimensions exactly 5x4 with all blocks already in portal configuration.\n    Expected output: 0\n    Explanation: No operations are needed as the rectangle already meets the portal criteria.\n\n    Edge case 2: A rectangle with dimensions larger than 5x4 but with no possible sub-rectangle that can be transformed into a portal.\n    Expected output: -1\n    Explanation: If no sub-rectangle can be transformed into a portal, the function should return a special value indicating impossibility.\n\n    Edge case 3: A rectangle with dimensions 5x4 where all blocks are empty.\n    Expected output: 12\n    Explanation: All border blocks need to be converted to obsidian, requiring 12 operations (3 for each side).\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where no sub-rectangle can be transformed into a portal.\n    Code for handling the edge case:\n    ```python\n    if min_operations == float('inf'):\n        return -1\n    ```\n\nYES", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate operations needed for this sub-rectangle\n                        operations = 0\n                        valid = True\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check borders\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and (y == 0 or y == b - 1)) or (x == a - 1 and (y == 0 or y == b - 1)):\n                                        # Corners can be any type\n                                        continue\n                                    if current_block == '0':\n                                        operations += 1\n                                else:\n                                    # Interior must be empty\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update minimum operations if this sub-rectangle is valid\n                        if valid:\n                            min_operations = min(min_operations, operations)\n        \n        # Handle the case where no valid portal can be formed\n        if min_operations == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    for result in results:\n        print(result)", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the dimensions n and m.\",\n        \"Read the n lines of m characters representing the grid configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all potential sub-rectangles of dimensions a \u00d7 b within the given rectangle A that can be transformed into a portal.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b that satisfy the portal conditions (a \u2265 5, b \u2265 4).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of operations required to transform a sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each potential sub-rectangle, check the border conditions for obsidian blocks.\",\n        \"Count the number of operations needed to convert the interior blocks to empty blocks.\",\n        \"Consider the corners as flexible and do not count operations for them.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required for each test case.\",\n      \"steps\": [\n        \"For each test case, track the minimum operations required across all potential sub-rectangles.\",\n        \"Store the result for each test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all test cases.\",\n      \"steps\": [\n        \"Print the minimum number of operations required for each test case on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles that can be transformed into a portal.\",\n    \"For each sub-rectangle, calculate the number of operations required to meet the portal conditions.\",\n    \"Track the minimum number of operations needed for each test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle of dimensions a \u00d7 b that meets specific criteria regarding the placement of obsidian and empty blocks.\n\n    'obsidian block' and 'empty block'\n    Explanation: These are the two types of blocks in the grid, represented by '1' and '0' respectively.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5': The number of rows in the portal must be at least 5.\n    'b must be at least 4': The number of columns in the portal must be at least 4.\n    'For all 1 < x < a': This means for all rows except the first and last.\n    'For all 1 < x < b': This means for all columns except the first and last.\n\n# [degree adverb] \n    'smallest': Refers to the minimum number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    The steps in the plan are well-structured and do not require simultaneous implementation. Each step logically follows from the previous one, ensuring a clear flow from input parsing to output generation.\n\n# [edge case] \n    1. A grid where all blocks are already in the portal configuration.\n       Explanation: The expected output is 0 operations since no changes are needed.\n    2. A grid where no sub-rectangle can be transformed into a portal due to insufficient dimensions.\n       Explanation: The expected output should be handled gracefully, potentially returning a large number or a specific indicator that transformation is impossible.\n    3. A grid with the minimum size of 5x4, where all blocks are the opposite of the portal configuration.\n       Explanation: The expected output is the maximum number of operations needed to transform the entire grid into a portal.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where no valid portal can be formed due to dimension constraints.\n    ```python\n    if n < 5 or m < 4:\n        print(\"Transformation impossible\")\n        continue\n    ```\n\nYES", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n):\n            for j in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = 0\n                        \n                        # Check border conditions for obsidian blocks\n                        for x in range(i + 1, i + a - 1):\n                            if grid[x][j] != '1':\n                                operations += 1\n                            if grid[x][j + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(j + 1, j + b - 1):\n                            if grid[i][y] != '1':\n                                operations += 1\n                            if grid[i + a - 1][y] != '1':\n                                operations += 1\n                        \n                        # Count operations needed to convert interior blocks to empty blocks\n                        for x in range(i + 1, i + a - 1):\n                            for y in range(j + 1, j + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Update minimum operations for this test case\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        \n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the dimensions n and m.\",\n        \"Read the n lines of m characters representing the grid configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of dimensions a \u00d7 b within the given rectangle A, where a \u2265 5 and b \u2265 4.\",\n      \"steps\": [\n        \"Iterate over all possible starting points (i, j) for the sub-rectangle.\",\n        \"For each starting point, iterate over all possible dimensions a and b that satisfy the constraints a \u2265 5 and b \u2265 4.\",\n        \"Ensure that the sub-rectangle fits within the bounds of the original rectangle A.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the number of operations required to transform each sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each sub-rectangle, check the border conditions for obsidian blocks as specified in the requirement.\",\n        \"Count the number of operations needed to convert the current configuration to meet the portal criteria.\",\n        \"Consider the flexibility of corner blocks which can be any type.\"\n      ]\n    },\n    {\n      \"description\": \"Find the minimum number of operations required across all sub-rectangles for each test case.\",\n      \"steps\": [\n        \"Track the minimum number of operations needed for each test case.\",\n        \"Compare the operation count for each sub-rectangle and update the minimum as necessary.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles of valid dimensions.\",\n    \"For each sub-rectangle, calculate the number of operations required to transform it into a portal.\",\n    \"Track and output the minimum number of operations required for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n \u00d7 m'\n    Explanation: This refers to the main grid or matrix that contains blocks, where 'n' is the number of rows and 'm' is the number of columns.\n\n    'portal'\n    Explanation: A sub-rectangle within the main rectangle that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5': The number of rows in the sub-rectangle must be at least 5.\n    'b must be at least 4': The number of columns in the sub-rectangle must be at least 4.\n    'For all 1 < x < a': This means for all rows except the first and last in the sub-rectangle.\n    'For all 1 < x < b': This means for all columns except the first and last in the sub-rectangle.\n\n# [degree adverb]\n    'smallest': Refers to finding the minimum number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    The steps in the plan are well-structured and do not require simultaneous implementation. Each step logically follows from the previous one, ensuring a clear progression from input parsing to finding the minimum operations.\n\n# [edge case]\n    1. A grid where all blocks are already in the portal configuration:\n       Input: \n       ```\n       1\n       5 4\n       1111\n       1001\n       1001\n       1001\n       1111\n       ```\n       Expected Output: 0\n       Explanation: No operations are needed as the grid is already a portal.\n\n    2. A grid with the minimum size that cannot form a portal:\n       Input:\n       ```\n       1\n       5 4\n       0000\n       0000\n       0000\n       0000\n       0000\n       ```\n       Expected Output: 12\n       Explanation: All blocks need to be converted to form a portal.\n\n    3. A grid with mixed blocks but no valid sub-rectangle:\n       Input:\n       ```\n       1\n       5 4\n       1010\n       0101\n       1010\n       0101\n       1010\n       ```\n       Expected Output: 12\n       Explanation: The pattern does not allow for a portal without significant changes.\n\n# [extra code", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible starting points (i, j) for the sub-rectangle\n        for i in range(n):\n            for j in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = 0\n                        \n                        # Check the border conditions for obsidian blocks\n                        for x in range(i, i + a):\n                            if x == i or x == i + a - 1:\n                                # Top and bottom borders\n                                for y in range(j + 1, j + b - 1):\n                                    if grid[x][y] != '1':\n                                        operations += 1\n                            else:\n                                # Left and right borders\n                                if grid[x][j] != '1':\n                                    operations += 1\n                                if grid[x][j + b - 1] != '1':\n                                    operations += 1\n                        \n                        # Check the inner blocks for empty blocks\n                        for x in range(i + 1, i + a - 1):\n                            for y in range(j + 1, j + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposition\": [\n    {\n      \"subproblem\": \"Identify all possible sub-rectangles of dimensions a \u00d7 b within the given rectangle A.\",\n      \"details\": \"Iterate over all possible top-left corners and dimensions a and b that satisfy the portal criteria.\"\n    },\n    {\n      \"subproblem\": \"Check if a sub-rectangle can be transformed into a portal.\",\n      \"details\": \"Verify the portal criteria for each sub-rectangle: dimensions, border obsidian blocks, and inner empty blocks.\"\n    },\n    {\n      \"subproblem\": \"Calculate the number of operations needed to transform a sub-rectangle into a portal.\",\n      \"details\": \"Count the number of blocks that need to be flipped to meet the portal criteria.\"\n    },\n    {\n      \"subproblem\": \"Determine the minimum number of operations across all sub-rectangles.\",\n      \"details\": \"Track the minimum operations required for any sub-rectangle to become a portal.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse the input data.\",\n      \"details\": \"Read the number of test cases, dimensions of each rectangle, and the block data.\"\n    },\n    {\n      \"step\": \"Iterate over each test case.\",\n      \"details\": \"For each test case, process the rectangle data to find potential portals.\"\n    },\n    {\n      \"step\": \"Generate all possible sub-rectangles of valid dimensions.\",\n      \"details\": \"For each rectangle, iterate over all possible top-left corners and dimensions a and b.\"\n    },\n    {\n      \"step\": \"Evaluate each sub-rectangle for portal criteria.\",\n      \"details\": \"Check if the sub-rectangle meets the portal criteria and calculate the operations needed.\"\n    },\n    {\n      \"step\": \"Track the minimum operations needed for each test case.\",\n      \"details\": \"Store the minimum operations required to transform any sub-rectangle into a portal.\"\n    },\n    {\n      \"step\": \"Output the results for all test cases.\",\n      \"details\": \"Print the minimum operations for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: In the requirement, a portal is defined as a sub-rectangle with specific dimensions and block arrangements. It must have obsidian blocks on its borders and empty blocks inside, except for the corners which can be any type.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5': means the number of rows in the portal must be at least 5.\n    'b must be at least 4': means the number of columns in the portal must be no less than 4.\n    'For all 1 < x < a': means for all rows except the first and last, certain conditions must be met.\n    'For all 1 < x < b': means for all columns except the first and last, certain conditions must be met.\n\n# [degree adverb]\n    'smallest': means we need to find the minimum number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    The steps \"Evaluate each sub-rectangle for portal criteria\" and \"Calculate the number of operations needed to transform a sub-rectangle into a portal\" should be implemented simultaneously. This can be done by checking the portal criteria and counting the necessary operations in the same loop.\n\n# [edge case]\n    Case 1: A rectangle with dimensions exactly 5x4 where all blocks are already in portal configuration.\n    Expected output: 0\n    Explanation: No operations are needed as the rectangle already meets the portal criteria.\n\n    Case 2: A rectangle with dimensions larger than 5x4 but no possible sub-rectangle can be transformed into a portal.\n    Expected output: -1 (or a large number indicating impossibility)\n    Explanation: If no sub-rectangle can meet the criteria, the output should reflect that transformation is impossible.\n\n    Case 3: A rectangle with dimensions 5x4 where all blocks are empty.\n    Expected output: 12\n    Explanation: All border blocks need to be converted to obsidian, requiring 12 operations.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where no sub-rectangle can be transformed into a portal.\n        if min_operations == float('inf'):\n            print(-1)\n        else:\n            print(min_operations)\n\nYES", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        valid = True\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check the border conditions\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and y == 0) or (x == 0 and y == b - 1) or (x == a - 1 and y == 0) or (x == a - 1 and y == b - 1):\n                                        # Corners can be any type\n                                        continue\n                                    else:\n                                        # Borders must be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inside must be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations if this sub-rectangle is valid\n                        if valid:\n                            min_operations = min(min_operations, operations)\n        \n        # If no valid portal was found, return -1\n        if min_operations == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 67)"}, "Round_1": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        valid = True\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check the border conditions\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and y == 0) or (x == 0 and y == b - 1) or (x == a - 1 and y == 0) or (x == a - 1 and y == b - 1):\n                                        # Corners can be any type\n                                        continue\n                                    else:\n                                        # Borders must be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inside must be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations if this sub-rectangle is valid\n                        if valid:\n                            min_operations = min(min_operations, operations)\n        \n        # If no valid portal was found, return -1\n        if min_operations == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid"}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Identify all possible sub-rectangles of dimensions a \u00d7 b within the given rectangle A.\",\n      \"details\": \"Iterate over all possible top-left corners and dimensions a and b that satisfy the portal criteria.\"\n    },\n    {\n      \"subproblem\": \"Check if a sub-rectangle is a portal.\",\n      \"details\": \"Verify the portal criteria for each sub-rectangle: dimensions, border obsidian blocks, and inner empty blocks.\"\n    },\n    {\n      \"subproblem\": \"Calculate the number of operations needed to transform a sub-rectangle into a portal.\",\n      \"details\": \"Count the number of blocks that need to be converted to meet the portal criteria.\"\n    },\n    {\n      \"subproblem\": \"Determine the minimum number of operations across all sub-rectangles.\",\n      \"details\": \"Track the minimum operations required for any sub-rectangle to become a portal.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse the input.\",\n      \"details\": \"Read the number of test cases, dimensions of each rectangle, and the block configuration.\"\n    },\n    {\n      \"step\": \"Iterate over each test case.\",\n      \"details\": \"For each test case, process the rectangle to find potential portals.\"\n    },\n    {\n      \"step\": \"Generate all possible sub-rectangles of valid dimensions.\",\n      \"details\": \"For each rectangle, iterate over all possible top-left corners and dimensions a and b.\"\n    },\n    {\n      \"step\": \"Evaluate each sub-rectangle for portal criteria.\",\n      \"details\": \"Check if the sub-rectangle meets the portal criteria and calculate the operations needed.\"\n    },\n    {\n      \"step\": \"Track the minimum operations required.\",\n      \"details\": \"Update the minimum operations count for each test case.\"\n    },\n    {\n      \"step\": \"Output the result for each test case.\",\n      \"details\": \"Print the minimum number of operations required for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: In the context of the requirement, a portal is a sub-rectangle of specific dimensions (a \u00d7 b) within the larger rectangle A that meets certain criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5': The number of rows in the portal must be at least 5.\n    'b must be at least 4': The number of columns in the portal must be at least 4.\n    'For all 1 < x < a': This means for every row index x that is greater than 1 and less than a.\n    'For all 1 < x < b': This means for every column index x that is greater than 1 and less than b.\n\n# [degree adverb]\n    'smallest': Refers to the minimum number of operations required to transform a sub-rectangle into a portal.\n    Implementation: This can be implemented by keeping track of the minimum number of operations needed across all possible sub-rectangles.\n\n# [code logic]\n    The steps \"Generate all possible sub-rectangles of valid dimensions\" and \"Evaluate each sub-rectangle for portal criteria\" should be implemented simultaneously. This can be done by iterating over all possible sub-rectangles and checking their validity in the same loop to optimize performance.\n\n# [edge case]\n    1. A rectangle with dimensions exactly 5x4 filled entirely with empty blocks (0s).\n       Expected output: The number of operations needed to convert the entire border to obsidian blocks (1s).\n       Explanation: Since the rectangle is the smallest possible portal, all border blocks need to be converted.\n       \n    2. A rectangle with dimensions 5x4 filled entirely with obsidian blocks (1s).\n       Expected output: The number of operations needed to convert the inner blocks to empty blocks (0s).\n       Explanation: Only the inner blocks need to be converted to meet the portal criteria.\n       \n    3. A rectangle with dimensions 6x5 where the border is already in the correct configuration, but the inner blocks are not.\n       Expected output: The number of operations needed to convert the inner blocks to empty blocks (0s).\n       Explanation: Only the inner blocks need to be converted, as the border already meets the criteria.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should include logic to specifically check and handle the", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed to make this sub-rectangle a portal\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check the border conditions\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and (y == 0 or y == b - 1)) or (x == a - 1 and (y == 0 or y == b - 1)):\n                                        # Corners can be any type\n                                        continue\n                                    else:\n                                        # Border should be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inner should be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the dimensions n and m.\",\n        \"Read the n lines of m characters representing the grid configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of dimensions a \u00d7 b within the given rectangle A, where a \u2265 5 and b \u2265 4.\",\n      \"steps\": [\n        \"Iterate over all possible starting points (i, j) for the sub-rectangle.\",\n        \"For each starting point, iterate over all possible dimensions a and b that satisfy the constraints a \u2265 5 and b \u2265 4.\",\n        \"Ensure that the sub-rectangle fits within the bounds of the original rectangle A.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the number of operations required to transform each sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each sub-rectangle, check the border conditions for obsidian blocks as specified in the requirement.\",\n        \"Count the number of operations needed to convert the current configuration into a portal configuration.\",\n        \"Consider the flexibility of corner blocks which can be any type.\"\n      ]\n    },\n    {\n      \"description\": \"Find the minimum number of operations required across all sub-rectangles for each test case.\",\n      \"steps\": [\n        \"Track the minimum number of operations needed for each test case.\",\n        \"Compare the operation count for each sub-rectangle and update the minimum as necessary.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles that meet the dimension constraints.\",\n    \"For each sub-rectangle, calculate the number of operations required to transform it into a portal.\",\n    \"Track and update the minimum number of operations needed for each test case.\",\n    \"Output the minimum number of operations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n \u00d7 m'\n    Explanation: This refers to the main grid or matrix where the operations will be performed. It consists of n rows and m columns.\n\n    'portal'\n    Explanation: A sub-rectangle within the main grid that meets specific criteria regarding its dimensions and block types.\n\n    'obsidian block' and 'empty block'\n    Explanation: These are the two types of blocks in the grid. An obsidian block is represented by '1', and an empty block is represented by '0'.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5': The number of rows in the portal must be at least 5.\n    'b must be at least 4': The number of columns in the portal must be no less than 4.\n    'For all 1 < x < a': This means for all rows except the first and last.\n    'For all 1 < x < b': This means for all columns except the first and last.\n\n# [degree adverb]\n    'smallest number of operations': This means we need to find the minimum number of changes required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    The steps in the plan are well-structured, but the following steps should be considered simultaneously:\n    - \"For each sub-rectangle, check the border conditions for obsidian blocks as specified in the requirement.\"\n    - \"Count the number of operations needed to convert the current configuration into a portal configuration.\"\n    These can be implemented in a single loop that checks the conditions and counts the operations needed.\n\n# [edge case]\n    Edge Case 1: A grid where all blocks are already in the portal configuration.\n    Example: \n    ```\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    ```\n    Expected Output: 0\n    Explanation: No operations are needed as the grid is already a portal.\n\n    Edge Case 2: A grid where no sub-rectangle can be transformed into a portal.\n    Example:\n    ```\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    ```\n    Expected Output: 16\n    Explanation: All blocks need to be changed to form a portal.\n\n    Edge Case 3: A grid with", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of the sub-rectangle\n        for i in range(n):\n            for j in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the top and bottom borders\n                        for x in range(1, b - 1):\n                            if grid[i][j + x] != '1':  # Top border\n                                operations += 1\n                            if grid[i + a - 1][j + x] != '1':  # Bottom border\n                                operations += 1\n                        \n                        # Check the left and right borders\n                        for y in range(1, a - 1):\n                            if grid[i + y][j] != '1':  # Left border\n                                operations += 1\n                            if grid[i + y][j + b - 1] != '1':  # Right border\n                                operations += 1\n                        \n                        # Check the inner area\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the block configuration for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read integers n and m representing the dimensions of the rectangle.\",\n        \"Read n lines of m characters each, representing the block configuration of the rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of dimensions a \u00d7 b within the given rectangle A.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles within the bounds of n \u00d7 m.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b that satisfy the portal criteria (a \u2265 5, b \u2265 4).\"\n      ]\n    },\n    {\n      \"description\": \"Check if a sub-rectangle can be transformed into a portal and calculate the number of operations required.\",\n      \"steps\": [\n        \"For each sub-rectangle, verify if it can be transformed into a portal by checking the block conditions.\",\n        \"Calculate the number of operations needed to convert the sub-rectangle into a portal by counting mismatches and required conversions.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required for each test case.\",\n      \"steps\": [\n        \"For each test case, track the minimum number of operations across all possible sub-rectangles.\",\n        \"Store the result for each test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all test cases.\",\n      \"steps\": [\n        \"Print the minimum number of operations required for each test case on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and block configurations.\",\n    \"Iterate over each test case to find all possible sub-rectangles that can be transformed into portals.\",\n    \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n    \"Track the minimum number of operations required for each test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle with specific dimensions and block configurations. It must have obsidian blocks on its borders and empty blocks inside, except for the corners which can be any type.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5': The number of rows in the portal must be at least 5.\n    'b must be at least 4': The number of columns in the portal must be no less than 4.\n    Implementation: Use loops to iterate over possible dimensions starting from these minimum values.\n\n# [degree adverb]\n    'smallest': Refers to the minimum number of operations required to transform a sub-rectangle into a portal.\n    Implementation: Track the minimum number of operations across all sub-rectangles and update it whenever a smaller number is found.\n\n# [code logic]\n    The steps in the plan related to checking sub-rectangles and calculating operations should be implemented simultaneously.\n    Explanation: For each sub-rectangle, check if it can be transformed into a portal and calculate the operations in one code block to optimize performance.\n\n# [edge case]\n    Edge case 1: A rectangle with dimensions exactly 5x4 with all blocks already in portal configuration.\n    Expected output: 0\n    Explanation: No operations are needed as the rectangle already meets the portal criteria.\n\n    Edge case 2: A rectangle with dimensions larger than 5x4 but with no possible sub-rectangle that can be transformed into a portal.\n    Expected output: -1 (or a large number indicating impossibility)\n    Explanation: If no sub-rectangle can be transformed, the output should reflect that no valid portal can be formed.\n\n    Edge case 3: A rectangle with dimensions 5x4 but with all blocks opposite to portal configuration (all empty inside, obsidian on borders).\n    Expected output: Maximum number of operations needed to transform all blocks.\n    Explanation: Every block needs to be flipped to meet the portal criteria.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: Implement checks for rectangles that already meet portal criteria or cannot be transformed into a portal.\n    Code for handling the edge case:\n    ```python\n    if a == 5 and b == 4 and all_blocks_meet_portal_criteria():\n        return 0\n    if no_possible_portal():\n        return -1\n    ```\n\nYES", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate operations needed to transform this sub-rectangle into a portal\n                        operations = 0\n                        for i in range(a):\n                            for j in range(b):\n                                current_block = grid[start_row + i][start_col + j]\n                                if i == 0 or i == a - 1 or j == 0 or j == b - 1:\n                                    # Border blocks (except corners)\n                                    if (i == 0 and j == 0) or (i == 0 and j == b - 1) or (i == a - 1 and j == 0) or (i == a - 1 and j == b - 1):\n                                        # Corners can be any type, no operation needed\n                                        continue\n                                    if current_block == '0':\n                                        operations += 1\n                                else:\n                                    # Inner blocks\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update minimum operations for this test case\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read integers n and m, the dimensions of the rectangle.\",\n        \"Read the next n lines, each containing m characters, to form the grid representation of the rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of dimensions a \u00d7 b within the given rectangle that can potentially be transformed into a portal.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b that satisfy a \u2265 5 and b \u2265 4.\",\n        \"Ensure that the sub-rectangle fits within the bounds of the original rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of operations required to transform each identified sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each sub-rectangle, check the border conditions for obsidian blocks as per the portal criteria.\",\n        \"Count the number of operations needed to convert blocks to meet the portal criteria.\",\n        \"Consider the flexibility of corner blocks which can be either type.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required across all sub-rectangles for each test case.\",\n      \"steps\": [\n        \"Track the minimum number of operations needed for each test case.\",\n        \"Compare the operation counts for all sub-rectangles and update the minimum as necessary.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the minimum number of operations required to transform at least one sub-rectangle into a portal.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles that meet the minimum dimension requirements.\",\n    \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n    \"Track and update the minimum number of operations required for each test case.\",\n    \"Output the minimum number of operations for each test case.\"\n  ]\n}\n\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle with specific obsidian and empty block arrangements. The portal has strict border conditions and flexible corner conditions.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5': The number of rows in the sub-rectangle must be at least 5.\n    'b must be at least 4': The number of columns in the sub-rectangle must be no less than 4.\n    Implementation: Use loops to iterate over possible sub-rectangle dimensions starting from these minimum values.\n\n# [degree adverb] \n    'smallest': Refers to the minimum number of operations required to transform a sub-rectangle into a portal.\n    Implementation: Track the minimum number of operations using a variable that updates whenever a smaller count is found.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they build upon each other. However, within the subproblem of calculating operations, checking border conditions and counting operations can be done in a single loop over the sub-rectangle.\n\n# [edge case] \n    Edge case 1: A rectangle with dimensions exactly 5x4 with all blocks already meeting portal criteria.\n    Expected output: 0\n    Explanation: No operations are needed as the rectangle already meets the portal criteria.\n\n    Edge case 2: A rectangle with dimensions larger than 5x4 but with no possible sub-rectangle meeting portal criteria.\n    Expected output: -1 (or a large number indicating impossibility)\n    Explanation: If no sub-rectangle can be transformed into a portal, the output should reflect that.\n\n    Edge case 3: A rectangle with dimensions 5x4 where all blocks are empty.\n    Expected output: 12\n    Explanation: All border blocks need to be converted to obsidian, requiring 12 operations.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where no sub-rectangle can be transformed into a portal.\n        if min_operations == float('inf'):\n            print(-1)\n        else:\n            print(min_operations)\n\nYES", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):  # a must be at least 5\n            for j in range(m - 3):  # b must be at least 4\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = 0\n                        \n                        # Check border conditions\n                        for x in range(1, a - 1):\n                            if grid[i + x][j] != '1':\n                                operations += 1\n                            if grid[i + x][j + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(1, b - 1):\n                            if grid[i][j + y] != '1':\n                                operations += 1\n                            if grid[i + a - 1][j + y] != '1':\n                                operations += 1\n                        \n                        # Check inner conditions\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    operations += 1\n                        \n                        # Update minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        # Handle edge case where no sub-rectangle can be transformed into a portal\n        if min_operations == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"output\": \"A list of test cases, where each test case contains the dimensions (n, m) and the grid as a list of strings.\"\n    },\n    {\n      \"description\": \"For each test case, iterate over all possible sub-rectangles of dimensions at least 5x4 within the given grid.\",\n      \"output\": \"A list of all possible sub-rectangles for each test case.\"\n    },\n    {\n      \"description\": \"For each sub-rectangle, check if it can be transformed into a portal by counting the number of operations needed.\",\n      \"output\": \"The number of operations required to transform each sub-rectangle into a portal.\"\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required to transform at least one sub-rectangle into a portal for each test case.\",\n      \"output\": \"The minimum number of operations for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, generate all possible sub-rectangles of dimensions at least 5x4.\",\n    \"For each sub-rectangle, calculate the number of operations needed to convert it into a portal by checking the conditions for portal formation.\",\n    \"Track the minimum number of operations needed for each test case.\",\n    \"Output the minimum number of operations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle of dimensions a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5': The number of rows in the portal must be at least 5.\n    'b must be at least 4': The number of columns in the portal must be no less than 4.\n    Implementation: These conditions can be checked using simple comparison operations in code.\n\n# [degree adverb]\n    'smallest': Refers to the minimum number of operations required to transform a sub-rectangle into a portal.\n    Implementation: This can be achieved by iterating through all possible sub-rectangles and keeping track of the minimum operations needed.\n\n# [code logic]\n    The steps for generating sub-rectangles and calculating operations should be considered simultaneously.\n    Explanation: While iterating over possible sub-rectangles, the calculation of operations needed to transform them into a portal can be done in the same loop to optimize performance.\n\n# [edge case]\n    Edge Case 1: A grid where all blocks are obsidian.\n    Expected Output: The number of operations needed to convert the inner blocks to empty blocks while maintaining the portal structure.\n    Explanation: Since all blocks are obsidian, the inner blocks need to be converted to empty blocks, and the border blocks need to be checked for compliance with portal criteria.\n\n    Edge Case 2: A grid where all blocks are empty.\n    Expected Output: The number of operations needed to convert the border blocks to obsidian while maintaining the portal structure.\n    Explanation: Since all blocks are empty, the border blocks need to be converted to obsidian, and the inner blocks need to be checked for compliance with portal criteria.\n\n    Edge Case 3: A grid with dimensions exactly 5x4.\n    Expected Output: The number of operations needed to transform this specific grid into a portal.\n    Explanation: The grid is the smallest possible size for a portal, so the operations needed will depend on the initial configuration of blocks.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: Additional logic is required to specifically handle cases where the grid is uniform (all obsidian or all empty) and when the grid is at the minimum size for a portal.\n\nYES", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check if it's a border block\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and y == 0) or (x == 0 and y == b - 1) or (x == a - 1 and y == 0) or (x == a - 1 and y == b - 1):\n                                        # Corner blocks can be any type\n                                        continue\n                                    else:\n                                        # Border blocks must be obsidian\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inner blocks must be empty\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, false, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 367, "prompt": "CQXYM located a rectangle A with dimensions n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is either an obsidian block or empty. CQXYM can convert an obsidian block to an empty block or vice versa in a single operation.\n\nA rectangle M of dimensions a \u00d7 b is identified as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5, b must be at least 4. This means that b must be no less than 4.\n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type.\n\nIt is important to note that a rows and b columns are required, not b rows and a columns.\n\nAlso note that corners can be any type.\n\nCQXYM wants to determine the smallest number of operations required to transform at least one sub-rectangle into a portal. Analyze all potential sub-rectangles of A to obtain the best solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 120}
