{"name": "1620_B. Triangles on a Rectangle", "description": "A rectangle with its opposite corners in (0, 0) and (w, h) and sides parallel to the axes is drawn on a plane.\n\nYou are given a list of lattice points such that each point lies on a side of a rectangle but not in its corner. Also, there are at least two points on every side of a rectangle.\n\nYour task is to choose three points in such a way that: \n\n  * exactly two of them belong to the same side of a rectangle; \n  * the area of a triangle formed by them is maximum possible. \n\n\n\nPrint the doubled area of this triangle. It can be shown that the doubled area of any triangle formed by lattice points is always an integer.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers w and h (3 \u2264 w, h \u2264 10^6) \u2014 the coordinates of the corner of a rectangle.\n\nThe next two lines contain the description of the points on two horizontal sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers x_1 < x_2 < ... < x_k (0 < x_i < w) \u2014 the x coordinates of the points in the ascending order. The y coordinate for the first line is 0 and for the second line is h.\n\nThe next two lines contain the description of the points on two vertical sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers y_1 < y_2 < ... < y_k (0 < y_i < h) \u2014 the y coordinates of the points in the ascending order. The x coordinate for the first line is 0 and for the second line is w.\n\nThe total number of points on all sides in all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase print a single integer \u2014 the doubled maximum area of a triangle formed by such three points that exactly two of them belong to the same side.\n\nExample\n\nInput\n\n\n3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n\n\nOutput\n\n\n25\n42\n35\n\nNote\n\nThe points in the first testcase of the example: \n\n  * (1, 0), (2, 0); \n  * (2, 8), (3, 8), (4, 8); \n  * (0, 1), (0, 4), (0, 6); \n  * (5, 4), (5, 5). \n\n\n\nThe largest triangle is formed by points (0, 1), (0, 6) and (5, 4) \u2014 its area is 25/2. Thus, the doubled area is 25. Two points that are on the same side are: (0, 1) and (0, 6).", "tags": ["geometry", "greedy", "math"], "difficulty": 8, "id": 1620, "sample_io": [{"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["25\n42\n35\n"]}], "test_list": [{"input": "1\n99 99\n2 1 2\n2 3 4\n2 5 6\n2 7 8\n", "output": ["99\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 4\n2 2 4\n", "output": ["25\n42\n44\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 13\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 4\n2 2 4\n", "output": ["25\n70\n44\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n14 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n42\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["36\n42\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 10\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["45\n42\n35\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n21 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n147\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 13\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n78\n77\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 7\n2 2 4\n", "output": ["36\n42\n66\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 10\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 12\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["45\n42\n55\n"]}, {"input": "3\n5 8\n3 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 11\n11 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n70\n77\n"]}, {"input": "3\n5 17\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 7\n2 2 4\n", "output": ["51\n42\n66\n"]}, {"input": "3\n5 8\n2 0 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["32\n42\n35\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["32\n42\n70\n"]}, {"input": "1\n99 164\n2 1 2\n2 3 4\n2 5 6\n2 7 8\n", "output": ["164\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 0 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["25\n49\n35\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 -1 3 7\n2 2 4\n", "output": ["25\n42\n88\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 2 4 6\n2 4 5\n10 7\n2 3 13\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 4\n2 2 4\n", "output": ["20\n70\n44\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n16 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["36\n42\n112\n"]}, {"input": "3\n6 8\n2 0 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 4\n", "output": ["30\n42\n35\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n21 5\n3 1 6 8\n3 3 6 8\n3 0 3 10\n2 2 4\n", "output": ["25\n42\n210\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 0 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 7\n2 2 4\n", "output": ["36\n49\n66\n"]}, {"input": "3\n5 8\n3 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 5 7\n2 2 4\n", "output": ["25\n42\n66\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 14\n3 1 3 0\n3 4 5 6\n14 5\n3 1 6 8\n3 4 6 5\n3 0 3 3\n2 2 4\n", "output": ["25\n91\n42\n"]}, {"input": "3\n5 8\n3 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 14\n3 1 3 4\n3 4 5 11\n11 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n91\n77\n"]}, {"input": "3\n5 8\n3 1 0\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 11\n18 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n70\n126\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n10 7\n2 0 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["32\n63\n35\n"]}, {"input": "3\n5 17\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 4\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n12 5\n3 1 7 8\n3 3 11 8\n3 1 3 7\n2 2 0\n", "output": ["51\n42\n72\n"]}, {"input": "3\n5 8\n2 1 4\n3 1 3 4\n3 1 4 6\n2 6 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n42\n70\n"]}, {"input": "1\n198 164\n2 1 2\n2 3 4\n2 5 6\n2 7 8\n", "output": ["198\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 0 9\n2 0 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["25\n63\n35\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 8\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 1\n11 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n48\n35\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 3 5 6\n25 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n75\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 8 5\n10 7\n2 3 9\n2 1 11\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n70\n35\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 7\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 1 10\n3 0 3 7\n2 2 4\n", "output": ["30\n42\n77\n"]}, {"input": "3\n6 8\n2 0 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 1\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 4\n", "output": ["30\n42\n33\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 13\n2 3 7\n2 1 10\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n117\n77\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 0 7\n3 1 3 4\n3 7 5 6\n22 5\n3 1 6 8\n3 3 11 8\n3 1 3 7\n2 2 4\n", "output": ["36\n49\n132\n"]}, {"input": "3\n9 8\n3 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 5 7\n2 2 4\n", "output": ["45\n42\n66\n"]}, {"input": "3\n9 8\n3 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 0 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 5 7\n2 2 4\n", "output": ["45\n63\n66\n"]}, {"input": "3\n5 8\n3 1 0\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 3\n2 1 7\n3 1 3 4\n3 4 5 11\n26 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n70\n182\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 10\n2 1 7\n3 0 3 4\n3 4 5 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 6 4\n2 2 4\n", "output": ["32\n49\n70\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 5 9\n2 1 7\n3 1 3 1\n3 4 5 5\n17 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n51\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 8 5\n10 7\n2 3 9\n2 1 11\n3 1 3 4\n3 8 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 7\n", "output": ["25\n70\n55\n"]}, {"input": "3\n4 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 13\n2 3 7\n2 1 10\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 4 4\n", "output": ["24\n117\n77\n"]}, {"input": "3\n5 1\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 10\n2 1 7\n3 0 3 4\n3 4 5 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 6 4\n2 2 4\n", "output": ["25\n49\n70\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 5 9\n2 1 7\n3 1 3 1\n3 4 5 5\n20 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n60\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 7\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 1 5 6\n11 5\n3 1 2 8\n3 2 1 10\n3 0 3 7\n2 2 4\n", "output": ["30\n50\n77\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 9\n3 1 3 2\n3 7 5 6\n21 5\n3 1 6 4\n3 3 6 8\n3 0 3 10\n2 2 3\n", "output": ["25\n56\n210\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 5 9\n2 1 13\n3 1 3 1\n3 4 5 5\n20 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n84\n60\n"]}, {"input": "3\n2 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 4\n10 7\n2 3 9\n2 1 9\n3 1 3 2\n3 7 5 6\n21 5\n3 1 6 4\n3 3 6 8\n3 0 3 10\n2 2 3\n", "output": ["24\n56\n210\n"]}, {"input": "1\n99 99\n2 1 2\n2 0 4\n2 5 6\n2 7 8\n", "output": ["396\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 7\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["40\n42\n77\n"]}, {"input": "3\n5 12\n2 1 3\n3 2 3 4\n3 1 4 6\n2 4 5\n20 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n60\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 16\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["75\n42\n35\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 13\n2 3 9\n2 1 13\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n156\n77\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 2 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n14 5\n3 1 6 8\n3 4 6 5\n3 0 3 3\n2 2 4\n", "output": ["24\n42\n42\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 9\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 7\n2 2 4\n", "output": ["36\n54\n66\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 10\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 12\n3 4 6 16\n3 1 3 4\n2 2 4\n", "output": ["45\n42\n60\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 6\n", "output": ["32\n42\n44\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 0 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 2\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["25\n49\n33\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 1 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 -1 3 7\n2 2 4\n", "output": ["25\n56\n88\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 11\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 2\n", "output": ["50\n42\n77\n"]}, {"input": "3\n5 12\n2 1 3\n3 2 3 4\n3 1 4 2\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 2 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["24\n42\n77\n"]}, {"input": "3\n5 24\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n21 5\n3 1 6 8\n3 3 6 8\n3 0 3 10\n2 2 4\n", "output": ["48\n42\n210\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 0 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 7\n2 2 4\n", "output": ["25\n49\n66\n"]}, {"input": "3\n5 8\n2 0 2\n3 2 3 4\n3 1 4 6\n2 4 7\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 7\n3 3 6 8\n3 0 3 3\n2 2 5\n", "output": ["25\n42\n33\n"]}, {"input": "3\n5 8\n2 1 5\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 14\n3 1 3 0\n3 4 5 6\n14 5\n3 1 6 8\n3 4 6 5\n3 0 3 3\n2 2 4\n", "output": ["32\n91\n42\n"]}, {"input": "3\n5 8\n2 1 4\n3 1 3 4\n3 0 4 6\n2 6 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["30\n42\n70\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 2 4 6\n2 4 5\n10 7\n2 3 13\n2 1 7\n2 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 4\n2 2 4\n", "output": ["24\n70\n44\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n18 7\n2 5 9\n2 1 7\n3 1 3 4\n3 4 5 5\n11 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n54\n35\n"]}, {"input": "3\n6 8\n2 0 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n21 1\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 4\n", "output": ["30\n42\n63\n"]}, {"input": "3\n9 8\n3 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 5 8\n2 2 4\n", "output": ["45\n42\n77\n"]}, {"input": "3\n10 8\n2 1 4\n3 1 3 4\n3 1 4 6\n2 6 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 2 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["50\n42\n70\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 0\n10 7\n2 0 9\n2 0 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 3\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["25\n63\n33\n"]}, {"input": "3\n5 12\n2 2 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 4 16\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 0 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n84\n77\n"]}, {"input": "3\n5 8\n2 1 7\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 5 9\n2 1 7\n3 1 3 1\n3 4 5 5\n11 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["48\n42\n35\n"]}, {"input": "3\n5 9\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 4 9\n2 1 7\n3 1 3 4\n3 3 5 6\n25 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["27\n42\n75\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 2\n3 7 5 6\n9 5\n3 1 6 8\n3 3 6 8\n3 0 3 10\n2 2 3\n", "output": ["25\n42\n90\n"]}, {"input": "3\n5 8\n3 1 0\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 3\n2 1 7\n3 1 3 4\n3 4 5 10\n26 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n60\n182\n"]}, {"input": "3\n5 1\n2 0 4\n3 1 3 4\n3 1 4 9\n2 4 2\n10 7\n2 3 10\n2 1 7\n3 0 3 4\n3 4 5 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 4 4\n2 4 4\n", "output": ["40\n49\n70\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 8\n2 4 5\n10 7\n2 5 9\n2 1 13\n3 1 3 1\n3 4 8 3\n20 5\n3 1 12 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["35\n84\n60\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 2 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 16\n3 3 6 8\n3 0 3 3\n2 2 4\n", "output": ["20\n42\n75\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 6\n3 1 4 6\n2 4 5\n0 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["32\n42\n77\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 12\n2 1 4\n", "output": ["36\n42\n121\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 12\n2 3 9\n2 1 7\n3 2 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n72\n35\n"]}, {"input": "3\n5 8\n3 1 2\n3 2 3 4\n3 2 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 11\n11 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 0 4\n", "output": ["20\n70\n77\n"]}, {"input": "3\n5 8\n2 1 0\n3 2 3 4\n3 1 4 6\n2 4 5\n10 13\n2 3 9\n2 1 7\n3 0 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n78\n35\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 0 10\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 7\n2 2 4\n", "output": ["25\n70\n66\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 8\n2 4 2\n10 7\n2 0 4\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["35\n42\n35\n"]}, {"input": "3\n5 17\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 4\n10 7\n2 3 15\n2 2 7\n3 1 3 4\n3 7 5 6\n12 5\n3 1 7 8\n3 3 11 8\n3 1 3 7\n2 2 0\n", "output": ["51\n84\n72\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 2 4 6\n2 4 5\n10 7\n2 3 13\n2 1 7\n2 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 -1 3 4\n2 2 4\n", "output": ["24\n70\n55\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 2 6\n2 4 5\n10 7\n2 4 9\n2 2 7\n3 1 3 4\n3 7 5 6\n11 5\n3 0 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n35\n77\n"]}, {"input": "3\n5 12\n2 2 2\n3 2 3 4\n3 1 4 10\n2 4 5\n10 7\n2 4 16\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 0 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["45\n84\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 5\n2 8 5\n10 7\n2 3 9\n2 1 11\n3 1 3 4\n3 8 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 4 4\n2 2 4\n", "output": ["20\n70\n35\n"]}, {"input": "3\n5 8\n3 1 2\n3 2 3 4\n3 1 4 6\n2 4 0\n1 7\n2 3 9\n2 1 14\n3 1 3 5\n3 4 5 11\n16 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n91\n112\n"]}, {"input": "3\n5 8\n3 1 0\n3 2 3 4\n3 1 4 6\n2 4 10\n10 7\n2 3 3\n2 1 7\n3 1 3 4\n3 4 5 11\n26 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["30\n70\n182\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 5 9\n2 2 7\n3 1 3 1\n3 4 5 5\n17 5\n3 1 6 8\n3 4 6 8\n3 1 3 3\n2 2 4\n", "output": ["25\n35\n35\n"]}, {"input": "3\n1 12\n2 1 6\n3 2 4 4\n3 1 4 7\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n16 8\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 1\n", "output": ["60\n42\n112\n"]}, {"input": "3\n3 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 9\n3 1 3 2\n3 7 5 6\n21 5\n3 1 6 4\n3 3 6 8\n3 0 3 20\n2 2 3\n", "output": ["24\n56\n420\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 0 4 6\n2 4 5\n10 7\n2 5 9\n2 1 13\n3 1 3 1\n3 4 5 5\n20 5\n3 2 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["30\n84\n60\n"]}, {"input": "3\n5 1\n2 0 4\n3 1 3 4\n3 1 4 9\n2 4 2\n10 7\n2 3 10\n2 1 7\n3 0 3 4\n3 4 5 6\n11 10\n3 0 6 8\n3 3 6 8\n3 2 4 4\n2 4 4\n", "output": ["40\n49\n80\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 16\n2 4 5\n10 7\n2 5 9\n2 1 13\n3 1 3 1\n3 4 8 3\n20 5\n3 1 12 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["75\n84\n60\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 16\n2 4 5\n10 7\n2 3 17\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 10 8\n3 1 3 4\n2 2 4\n", "output": ["75\n98\n35\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 18\n2 3 9\n2 1 7\n3 2 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n108\n35\n"]}, {"input": "3\n5 8\n2 1 2\n3 3 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 9\n3 1 3 4\n3 4 5 1\n11 5\n3 1 6 2\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n56\n33\n"]}, {"input": "3\n5 17\n2 0 4\n3 2 3 4\n3 1 4 6\n2 4 4\n10 7\n2 3 15\n2 2 7\n3 1 3 4\n3 7 5 6\n12 5\n3 1 7 8\n3 3 11 8\n3 1 3 7\n2 2 0\n", "output": ["68\n84\n72\n"]}, {"input": "3\n9 12\n2 1 2\n3 2 3 4\n3 1 2 6\n2 4 5\n10 7\n2 4 9\n2 2 7\n3 1 3 4\n3 7 5 6\n11 5\n3 0 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["45\n35\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 9\n2 8 5\n10 7\n2 3 3\n2 1 11\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 1 4\n2 2 4\n", "output": ["40\n70\n35\n"]}, {"input": "3\n5 8\n2 0 4\n3 2 3 4\n3 0 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 6 5 6\n11 6\n3 1 6 8\n3 3 6 8\n3 2 2 2\n2 2 4\n", "output": ["32\n42\n42\n"]}, {"input": "3\n5 8\n2 1 1\n3 1 3 4\n3 1 4 6\n2 4 0\n10 7\n2 0 9\n2 0 7\n3 1 3 4\n3 2 5 6\n11 5\n3 1 6 8\n3 3 7 8\n3 1 3 4\n2 2 7\n", "output": ["25\n63\n55\n"]}, {"input": "1\n53 164\n2 1 2\n2 0 4\n2 5 6\n2 9 8\n", "output": ["656\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 2 4 6\n2 4 5\n1 8\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n14 5\n3 1 6 8\n3 4 3 5\n3 0 3 3\n2 2 4\n", "output": ["24\n48\n42\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 0 6\n2 4 5\n18 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 12\n2 1 4\n", "output": ["36\n54\n121\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 18\n2 3 9\n2 1 7\n3 2 3 4\n3 4 5 6\n11 5\n3 2 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n108\n30\n"]}, {"input": "3\n5 8\n2 1 2\n3 3 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 9\n3 1 3 4\n3 4 5 1\n13 5\n3 1 6 2\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n56\n39\n"]}, {"input": "3\n5 17\n2 0 4\n3 2 3 4\n3 1 4 6\n2 4 4\n10 7\n2 3 28\n2 2 7\n3 1 3 4\n3 7 5 6\n12 5\n3 1 7 8\n3 3 11 8\n3 1 3 7\n2 2 0\n", "output": ["68\n175\n72\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 9\n2 8 5\n10 7\n2 3 3\n2 1 15\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 1 4\n2 2 4\n", "output": ["40\n98\n35\n"]}, {"input": "3\n5 8\n2 0 2\n3 0 3 4\n3 1 4 3\n2 4 7\n10 7\n2 3 4\n2 1 7\n3 1 0 4\n3 1 5 6\n11 5\n3 1 6 8\n3 3 2 8\n3 0 3 3\n2 2 5\n", "output": ["32\n50\n35\n"]}, {"input": "3\n1 12\n2 1 6\n3 2 4 4\n3 1 4 7\n2 4 5\n10 7\n2 3 1\n2 1 7\n3 1 3 4\n3 7 5 6\n16 8\n3 1 6 8\n3 3 11 8\n3 0 3 13\n2 2 1\n", "output": ["60\n42\n208\n"]}, {"input": "3\n5 1\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n19 7\n2 3 10\n2 1 7\n3 0 3 4\n3 4 6 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 4 7\n2 4 4\n", "output": ["25\n76\n70\n"]}, {"input": "3\n5 8\n2 1 4\n3 0 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 2 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 14\n3 4 6 1\n3 0 3 3\n2 2 4\n", "output": ["32\n42\n65\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 0\n3 1 4 6\n2 4 1\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n8 4\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 0 4\n", "output": ["25\n42\n32\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 0 6\n2 4 5\n18 7\n2 3 15\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 12\n2 1 4\n", "output": ["36\n84\n121\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 7\n3 4 5 6\n11 5\n3 1 6 0\n3 3 10 8\n3 2 5 4\n2 2 6\n", "output": ["32\n60\n44\n"]}, {"input": "3\n10 8\n2 1 2\n3 3 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 9\n3 1 3 4\n3 4 5 1\n13 5\n3 1 6 2\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["50\n56\n39\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 0 10\n3 0 3 8\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 5\n3 1 3 7\n2 2 4\n", "output": ["25\n80\n66\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 11\n2 8 5\n10 7\n2 3 3\n2 1 15\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 1 4\n2 2 4\n", "output": ["50\n98\n35\n"]}, {"input": "3\n5 1\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n19 7\n2 3 10\n2 1 7\n3 -1 3 4\n3 4 6 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 4 7\n2 4 4\n", "output": ["25\n95\n70\n"]}, {"input": "3\n5 1\n2 0 4\n3 1 3 4\n3 1 4 9\n2 4 2\n20 7\n2 3 10\n2 1 7\n3 0 3 4\n3 4 5 6\n11 10\n3 0 6 8\n3 3 6 8\n3 2 4 4\n2 4 1\n", "output": ["40\n80\n80\n"]}, {"input": "1\n53 202\n2 1 2\n2 0 4\n2 3 6\n2 9 8\n", "output": ["808\n"]}, {"input": "3\n5 4\n2 1 4\n3 0 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 2 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 14\n3 4 6 1\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n65\n"]}, {"input": "3\n5 13\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n4 18\n2 3 9\n2 1 7\n3 2 3 4\n3 4 5 6\n11 5\n3 2 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["39\n108\n30\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 7\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 1 4\n3 7 5 6\n16 6\n3 2 6 0\n3 3 11 8\n3 0 3 6\n2 2 1\n", "output": ["36\n42\n96\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 3\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 6 10\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 0 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 3\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 8\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n14 5\n3 1 6 8\n3 4 6 5\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n42\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 8\n3 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 0 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 5\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 2 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n21 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n147\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 0\n3 4 5 6\n14 5\n3 1 6 8\n3 4 6 5\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n42\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 7\n2 2 4\n", "output": ["36\n42\n66\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 10\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 12\n3 4 6 8\n3 1 3 4\n2 2 4\n", "output": ["45\n42\n55\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 8\n3 1 0\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 11\n11 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n70\n77\n"]}, {"input": "3\n5 17\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 7\n2 2 0\n", "output": ["51\n42\n66\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["32\n42\n35\n"]}, {"input": "3\n5 17\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 7 8\n3 3 11 8\n3 1 3 7\n2 2 0\n", "output": ["51\n42\n66\n"]}, {"input": "3\n5 17\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 4\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 7 8\n3 3 11 8\n3 1 3 7\n2 2 0\n", "output": ["51\n42\n66\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 6 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["32\n42\n70\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 4\n2 2 0\n", "output": ["25\n42\n44\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 2\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 0 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 4 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 1\n11 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 3\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 5\n11 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 3\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 2 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 3 5 6\n14 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n42\n"]}, {"input": "3\n5 8\n2 1 1\n3 2 3 4\n3 1 4 10\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["45\n42\n35\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 8 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 1 10\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 13\n2 3 7\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n78\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 10\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 0 4\n3 4 5 6\n11 5\n3 1 6 12\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["45\n42\n55\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 6\n3 2 3 4\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 8\n2 0 2\n3 2 3 4\n3 1 4 6\n2 4 7\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 5\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 2 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n2 1 3 4\n3 7 5 6\n21 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n147\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 6 7\n2 2 4\n", "output": ["36\n42\n66\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 8 10\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 12\n3 4 6 8\n3 1 3 4\n2 2 4\n", "output": ["45\n42\n55\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 3\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 8\n2 0 4\n3 2 3 4\n3 0 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["32\n42\n35\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 0 3 4\n3 4 5 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["32\n42\n70\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 0 6 8\n3 0 3 4\n2 2 0\n", "output": ["25\n42\n44\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 5\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 2\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 2 4 6\n2 4 5\n10 7\n2 3 13\n2 1 7\n2 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 4\n2 2 4\n", "output": ["20\n70\n44\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 4 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 0 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 12\n2 0 2\n3 2 3 4\n3 1 4 6\n2 4 3\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 5 9\n2 1 7\n3 1 3 4\n3 4 5 5\n11 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 7\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n16 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["36\n42\n112\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n21 5\n3 1 6 8\n3 3 6 8\n3 0 3 10\n2 2 3\n", "output": ["25\n42\n210\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n12 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 6\n3 2 3 4\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 8\n2 0 2\n3 2 3 4\n3 1 4 6\n2 4 7\n10 7\n2 3 9\n2 1 7\n3 1 0 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 5\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 0 6 8\n3 3 11 8\n3 1 6 7\n2 2 4\n", "output": ["36\n42\n66\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 0 4\n3 1 8 10\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 12\n3 4 6 8\n3 1 3 4\n2 2 4\n", "output": ["45\n42\n55\n"]}, {"input": "3\n5 8\n3 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 14\n3 1 3 5\n3 4 5 11\n11 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n91\n77\n"]}, {"input": "3\n5 8\n2 0 4\n3 2 3 4\n3 0 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 6 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["32\n42\n35\n"]}, {"input": "3\n5 8\n3 1 0\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 3\n2 1 7\n3 1 3 4\n3 4 5 11\n18 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n70\n126\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 0 2\n10 7\n2 0 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["32\n63\n35\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 0 3 4\n3 4 5 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 6 4\n2 2 4\n", "output": ["32\n42\n70\n"]}], "task_id": "codecontest/148", "repair_prompt": ["A rectangle with its opposing corners situated at (0, 0) and (w, h) and edges aligned with the axes is illustrated on a plane.\n\nYou are given a list of lattice points such that each point lies on a side of a rectangle but not in its corner. It is important to note that none of the listed points are located at the rectangle's corners. Also, there are at least two points on every side of a rectangle.\n\nYour task is to choose three points in such a way that: \n\n  * exactly two of them belong to the same side of a rectangle; \n  * the area of a triangle formed by them is maximum possible. \n\nPrint the doubled area of this triangle. It can be shown that the doubled area of any triangle formed by lattice points is always an integer. Consider using geometric properties to identify the optimal points that maximize the area efficiently.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers w and h (3 \u2264 w, h \u2264 10^6) \u2014 the coordinates of the corner of a rectangle.\n\nThe next two lines contain the description of the points on two horizontal sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers x_1 < x_2 < ... < x_k (0 < x_i < w) \u2014 the x coordinates of the points in the ascending order. The y coordinate for the first line is 0 and for the second line is h.\n\nThe next two lines contain the description of the points on two vertical sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers y_1 < y_2 < ... < y_k (0 < y_i < h) \u2014 the y coordinates of the points in the ascending order. The x coordinate for the first line is 0 and for the second line is w.\n\nThe total number of points on all sides in all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase print a single integer \u2014 the doubled maximum area of a triangle formed by such three points that exactly two of them belong to the same side.\n\nExample\n\nInput\n\n\n3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n\n\nOutput\n\n\n25\n42\n35\n\nNote\n\nThe points in the first testcase of the example: \n\n  * (1, 0), (2, 0); \n  * (2, 8), (3, 8), (4, 8); \n  * (0, 1), (0, 4), (0, 6); \n  * (5, 4), (5, 5). \n\n\n\nThe largest triangle is formed by points (0, 1), (0, 6) and (5, 4) \u2014 its area is 25/2. Thus, the doubled area is 25. Two points that are on the same side are: (0, 1) and (0, 6).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "A rectangle with its opposing corners situated at (0, 0) and (w, h) and edges aligned with the axes is illustrated on a plane.\n\nYou are given a list of lattice points such that each point lies on a side of a rectangle but not in its corner. It is important to note that none of the listed points are located at the rectangle's corners. Additionally, these points do not include the corners at all. Also, there are at least two points on every side of a rectangle.\n\nYour task is to choose three points in such a way that: \n\n  * exactly two of them belong to the same side of a rectangle; \n  * the area of a triangle formed by them is maximum possible. \n\nPrint the doubled area of this triangle. It can be shown that the doubled area of any triangle formed by lattice points is always an integer. Consider using geometric properties to identify the optimal points that maximize the area efficiently.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers w and h (3 \u2264 w, h \u2264 10^6) \u2014 the coordinates of the corner of a rectangle.\n\nThe next two lines contain the description of the points on two horizontal sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers x_1 < x_2 < ... < x_k (0 < x_i < w) \u2014 the x coordinates of the points in the ascending order. The y coordinate for the first line is 0 and for the second line is h.\n\nThe next two lines contain the description of the points on two vertical sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers y_1 < y_2 < ... < y_k (0 < y_i < h) \u2014 the y coordinates of the points in the ascending order. The x coordinate for the first line is 0 and for the second line is w.\n\nThe total number of points on all sides in all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase print a single integer \u2014 the doubled maximum area of a triangle formed by such three points that exactly two of them belong to the same side.\n\nExample\n\nInput\n\n\n3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n\n\nOutput\n\n\n25\n42\n35\n\nNote\n\nThe points in the first testcase of the example: \n\n  * (1, 0), (2, 0); \n  * (2, 8), (3, 8), (4, 8); \n  * (0, 1), (0, 4), (0, 6); \n  * (5, 4), (5, 5). \n\n\n\nThe largest triangle is formed by points (0, 1), (0, 6) and (5, 4) \u2014 its area is 25/2. Thus, the doubled area is 25. Two points that are on the same side are: (0, 1) and (0, 6).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "A rectangle with its opposing corners situated at (0, 0) and (w, h) and edges aligned with the axes is illustrated on a plane.\n\nYou are given a list of lattice points such that each point lies on a side of a rectangle but not in its corner, and there are at least two points on every side of a rectangle.\n\nYour task is to choose three points in such a way that: \n\n  * exactly two of them belong to the same side of a rectangle; \n  * the area of a triangle formed by them is maximum possible. \n\nPrint the doubled area of this triangle. It can be shown that the doubled area of any triangle formed by lattice points is always an integer. Consider using geometric properties to identify the optimal points that maximize the area efficiently.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers w and h (3 \u2264 w, h \u2264 10^6) \u2014 the coordinates of the corner of a rectangle.\n\nThe next two lines contain the description of the points on two horizontal sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers x_1 < x_2 < ... < x_k (0 < x_i < w) \u2014 the x coordinates of the points in the ascending order. The y coordinate for the first line is 0 and for the second line is h.\n\nThe next two lines contain the description of the points on two vertical sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers y_1 < y_2 < ... < y_k (0 < y_i < h) \u2014 the y coordinates of the points in the ascending order. The x coordinate for the first line is 0 and for the second line is w.\n\nThe total number of points on all sides in all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase print a single integer \u2014 the doubled maximum area of a triangle formed by such three points that exactly two of them belong to the same side.\n\nExample\n\nInput\n\n\n3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n\n\nOutput\n\n\n25\n42\n35\n\nNote\n\nThe points in the first testcase of the example: \n\n  * (1, 0), (2, 0); \n  * (2, 8), (3, 8), (4, 8); \n  * (0, 1), (0, 4), (0, 6); \n  * (5, 4), (5, 5). \n\n\n\nThe largest triangle is formed by points (0, 1), (0, 6) and (5, 4) \u2014 its area is 25/2. Thus, the doubled area is 25. Two points that are on the same side are: (0, 1) and (0, 6).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x1_min = int(data[index + 1])\n        x1_max = int(data[index + k1])\n        index += k1 + 1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x2_min = int(data[index + 1])\n        x2_max = int(data[index + k2])\n        index += k2 + 1\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y1_min = int(data[index + 1])\n        y1_max = int(data[index + k3])\n        index += k3 + 1\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y2_min = int(data[index + 1])\n        y2_max = int(data[index + k4])\n        index += k4 + 1\n        \n        # Calculate maximum doubled area for each side combination\n        max_area = 0\n        \n        # Bottom and Top sides\n        max_area = max(max_area, (x1_max - x1_min) * h)\n        max_area = max(max_area, (x2_max - x2_min) * h)\n        \n        # Left and Right sides\n        max_area = max(max_area, (y1_max - y1_min) * w)\n        max_area = max(max_area, (y2_max - y2_min) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x1_min = int(data[index + 1])\n        x1_max = int(data[index + k1])\n        index += k1 + 1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x2_min = int(data[index + 1])\n        x2_max = int(data[index + k2])\n        index += k2 + 1\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y1_min = int(data[index + 1])\n        y1_max = int(data[index + k3])\n        index += k3 + 1\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y2_min = int(data[index + 1])\n        y2_max = int(data[index + k4])\n        index += k4 + 1\n        \n        # Calculate maximum doubled area for each side\n        max_area = 0\n        \n        # Bottom side (y = 0) and top side (y = h)\n        max_area = max(max_area, (x1_max - x1_min) * h)\n        max_area = max(max_area, (x2_max - x2_min) * h)\n        \n        # Left side (x = 0) and right side (x = w)\n        max_area = max(max_area, (y1_max - y1_min) * w)\n        max_area = max(max_area, (y2_max - y2_min) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side\n        k1 = int(data[index])\n        x1 = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        # Read points on the top side\n        k2 = int(data[index])\n        x2 = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        # Read points on the left side\n        k3 = int(data[index])\n        y1 = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        # Read points on the right side\n        k4 = int(data[index])\n        y2 = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        # Calculate maximum doubled area for each side\n        max_area = 0\n        \n        # Bottom and Top sides\n        max_area = max(max_area, (x1[-1] - x1[0]) * h)\n        max_area = max(max_area, (x2[-1] - x2[0]) * h)\n        \n        # Left and Right sides\n        max_area = max(max_area, (y1[-1] - y1[0]) * w)\n        max_area = max(max_area, (y2[-1] - y2[0]) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def max_doubled_area(t, test_cases):\n    results = []\n    for case in test_cases:\n        w, h, x_bottom, x_top, y_left, y_right = case\n        \n        # Calculate maximum distance between two points on the same side\n        max_x_bottom = (x_bottom[-1] - x_bottom[0]) * h\n        max_x_top = (x_top[-1] - x_top[0]) * h\n        max_y_left = (y_left[-1] - y_left[0]) * w\n        max_y_right = (y_right[-1] - y_right[0]) * w\n        \n        # Find the maximum doubled area\n        max_area = max(max_x_bottom, max_x_top, max_y_left, max_y_right)\n        results.append(max_area)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        k_bottom = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k_bottom]))\n        index += 1 + k_bottom\n        \n        k_top = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k_top]))\n        index += 1 + k_top\n        \n        k_left = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k_left]))\n        index += 1 + k_left\n        \n        k_right = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k_right]))\n        index += 1 + k_right\n        \n        test_cases.append((w, h, x_bottom, x_top, y_left, y_right))\n    \n    results = max_doubled_area(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def max_doubled_area_of_triangle(test_cases):\n    results = []\n    for case in test_cases:\n        w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right = case\n        \n        # Calculate maximum base for horizontal sides\n        max_base_bottom = horizontal_bottom[-1] - horizontal_bottom[0]\n        max_base_top = horizontal_top[-1] - horizontal_top[0]\n        \n        # Calculate maximum base for vertical sides\n        max_base_left = vertical_left[-1] - vertical_left[0]\n        max_base_right = vertical_right[-1] - vertical_right[0]\n        \n        # Calculate maximum doubled area for each side\n        max_area_bottom = max_base_bottom * h\n        max_area_top = max_base_top * h\n        max_area_left = max_base_left * w\n        max_area_right = max_base_right * w\n        \n        # Find the maximum doubled area\n        max_doubled_area = max(max_area_bottom, max_area_top, max_area_left, max_area_right)\n        \n        results.append(max_doubled_area)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        k1 = int(data[index])\n        horizontal_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        k2 = int(data[index])\n        horizontal_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        k3 = int(data[index])\n        vertical_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        k4 = int(data[index])\n        vertical_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        test_cases.append((w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right))\n    \n    results = max_doubled_area_of_triangle(test_cases)\n    \n    for result in results:\n        print(result)\nmain()", "def max_doubled_area_of_triangle(test_cases):\n    results = []\n    \n    for case in test_cases:\n        w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right = case\n        \n        # Calculate maximum doubled area for horizontal sides\n        max_horizontal_area = max(\n            (horizontal_bottom[-1] - horizontal_bottom[0]) * h,\n            (horizontal_top[-1] - horizontal_top[0]) * h\n        )\n        \n        # Calculate maximum doubled area for vertical sides\n        max_vertical_area = max(\n            (vertical_left[-1] - vertical_left[0]) * w,\n            (vertical_right[-1] - vertical_right[0]) * w\n        )\n        \n        # Determine the maximum doubled area\n        max_area = max(max_horizontal_area, max_vertical_area)\n        results.append(max_area)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        k1 = int(data[index])\n        horizontal_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        k2 = int(data[index])\n        horizontal_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        k3 = int(data[index])\n        vertical_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        k4 = int(data[index])\n        vertical_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        test_cases.append((w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right))\n    \n    results = max_doubled_area_of_triangle(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def max_doubled_area(t, test_cases):\n    results = []\n    for case in test_cases:\n        w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right = case\n        \n        # Calculate maximum distance on each side\n        max_horizontal_bottom = horizontal_bottom[-1] - horizontal_bottom[0]\n        max_horizontal_top = horizontal_top[-1] - horizontal_top[0]\n        max_vertical_left = vertical_left[-1] - vertical_left[0]\n        max_vertical_right = vertical_right[-1] - vertical_right[0]\n        \n        # Calculate maximum doubled area for each pair of adjacent sides\n        max_area = 0\n        max_area = max(max_area, max_horizontal_bottom * h)\n        max_area = max(max_area, max_horizontal_top * h)\n        max_area = max(max_area, max_vertical_left * w)\n        max_area = max(max_area, max_vertical_right * w)\n        \n        results.append(max_area)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        k1 = int(data[index])\n        horizontal_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        k2 = int(data[index])\n        horizontal_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        k3 = int(data[index])\n        vertical_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        k4 = int(data[index])\n        vertical_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        test_cases.append((w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right))\n    \n    results = max_doubled_area(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x1_min = int(data[index + 1])\n        x1_max = int(data[index + k1])\n        index += k1 + 1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x2_min = int(data[index + 1])\n        x2_max = int(data[index + k2])\n        index += k2 + 1\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y1_min = int(data[index + 1])\n        y1_max = int(data[index + k3])\n        index += k3 + 1\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y2_min = int(data[index + 1])\n        y2_max = int(data[index + k4])\n        index += k4 + 1\n        \n        # Calculate maximum doubled area\n        max_area = 0\n        \n        # Horizontal sides\n        max_area = max(max_area, (x1_max - x1_min) * h)\n        max_area = max(max_area, (x2_max - x2_min) * h)\n        \n        # Vertical sides\n        max_area = max(max_area, (y1_max - y1_min) * w)\n        max_area = max(max_area, (y2_max - y2_min) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        # Calculate maximum doubled area for each pair of opposite sides\n        max_area = 0\n        \n        # Bottom and Top sides\n        if x_bottom:\n            max_area = max(max_area, (x_bottom[-1] - x_bottom[0]) * h)\n        if x_top:\n            max_area = max(max_area, (x_top[-1] - x_top[0]) * h)\n        \n        # Left and Right sides\n        if y_left:\n            max_area = max(max_area, (y_left[-1] - y_left[0]) * w)\n        if y_right:\n            max_area = max(max_area, (y_right[-1] - y_right[0]) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side\n        k1 = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        # Read points on the top side\n        k2 = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        # Read points on the left side\n        k3 = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        # Read points on the right side\n        k4 = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        # Calculate maximum base lengths\n        max_base_bottom = x_bottom[-1] - x_bottom[0]\n        max_base_top = x_top[-1] - x_top[0]\n        max_base_left = y_left[-1] - y_left[0]\n        max_base_right = y_right[-1] - y_right[0]\n        \n        # Calculate maximum doubled area\n        max_doubled_area = 0\n        max_doubled_area = max(max_doubled_area, max_base_bottom * h)\n        max_doubled_area = max(max_doubled_area, max_base_top * h)\n        max_doubled_area = max(max_doubled_area, max_base_left * w)\n        max_doubled_area = max(max_doubled_area, max_base_right * w)\n        \n        results.append(max_doubled_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x1_min = int(data[index + 1])\n        x1_max = int(data[index + k1])\n        index += k1 + 1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x2_min = int(data[index + 1])\n        x2_max = int(data[index + k2])\n        index += k2 + 1\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y1_min = int(data[index + 1])\n        y1_max = int(data[index + k3])\n        index += k3 + 1\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y2_min = int(data[index + 1])\n        y2_max = int(data[index + k4])\n        index += k4 + 1\n        \n        # Calculate maximum doubled area for each side combination\n        max_area = 0\n        \n        # Bottom and Top sides\n        max_area = max(max_area, (x1_max - x1_min) * h)\n        max_area = max(max_area, (x2_max - x2_min) * h)\n        \n        # Left and Right sides\n        max_area = max(max_area, (y1_max - y1_min) * w)\n        max_area = max(max_area, (y2_max - y2_min) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of the rectangle, and the list of lattice points on each side for each test case.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, identify the two points on the same side of the rectangle that are farthest apart.\",\n      \"output\": \"The maximum distance between two points on the same side for each side of the rectangle.\"\n    },\n    {\n      \"description\": \"Calculate the maximum possible area of a triangle formed by choosing two points from the same side and one point from an adjacent side.\",\n      \"output\": \"The maximum doubled area of the triangle for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format, including the number of test cases, rectangle dimensions, and lattice points on each side.\",\n    \"For each test case, iterate over each side of the rectangle and find the two points that are farthest apart. Calculate the distance between these points.\",\n    \"For each pair of sides (horizontal and vertical), calculate the potential maximum area of a triangle by using the farthest points on one side and a point on the adjacent side.\",\n    \"Compute the doubled area of the triangle using the formula for the area of a triangle given by lattice points.\",\n    \"Compare the areas obtained from different combinations of sides and select the maximum doubled area for each test case.\",\n    \"Output the maximum doubled area for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A four-sided polygon with opposite sides equal and parallel, and all angles are right angles.\n    'lattice points': Points with integer coordinates.\n    'maximum possible area': The largest area that can be achieved by forming a triangle with the given points.\n\n# [phrase showing quantity relationship]\n    'maximum possible': Refers to the largest area that can be achieved.\n    Implementation: Use geometric properties to calculate the area and compare to find the maximum.\n\n# [degree adverb]\n    'maximum': Refers to the largest area achievable.\n    Implementation: Compare calculated areas and select the largest.\n\n# [code logic]\n    Steps 2 and 3 should be considered simultaneously:\n    \"Identify the two points on the same side of the rectangle that are farthest apart\" and \"Calculate the maximum possible area of a triangle formed by choosing two points from the same side and one point from an adjacent side\" can be implemented in a single loop where you calculate the area while identifying the farthest points.\n\n# [edge case]\n    Case 1: When all points on one side are equidistant, e.g., w = 5, h = 5, points on one side are [1, 2, 3, 4].\n    Expected output: The maximum area will be determined by the farthest points on the opposite side.\n    Case 2: When the rectangle is a square, e.g., w = h = 5, points are evenly distributed.\n    Expected output: The maximum area will be determined by the farthest points on any side.\n    Case 3: When the number of points is minimal, e.g., w = 3, h = 3, points are [1, 2] on each side.\n    Expected output: The maximum area will be determined by the farthest points on adjacent sides.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of finding the maximum distance between points on the same side and calculating the area using adjacent sides will cover these cases.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x1_min = int(data[index + 1])\n        x1_max = int(data[index + k1])\n        index += k1 + 1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x2_min = int(data[index + 1])\n        x2_max = int(data[index + k2])\n        index += k2 + 1\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y1_min = int(data[index + 1])\n        y1_max = int(data[index + k3])\n        index += k3 + 1\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y2_min = int(data[index + 1])\n        y2_max = int(data[index + k4])\n        index += k4 + 1\n        \n        # Calculate maximum doubled area for each side combination\n        max_area = 0\n        \n        # Bottom and Top sides\n        max_area = max(max_area, (x1_max - x1_min) * h)\n        max_area = max(max_area, (x2_max - x2_min) * h)\n        \n        # Left and Right sides\n        max_area = max(max_area, (y1_max - y1_min) * w)\n        max_area = max(max_area, (y2_max - y2_min) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"decomposition\": [\n    {\n      \"subproblem\": \"Parse the input data\",\n      \"description\": \"Read the number of test cases and for each test case, read the dimensions of the rectangle and the list of lattice points on each side.\"\n    },\n    {\n      \"subproblem\": \"Identify potential triangles\",\n      \"description\": \"For each test case, identify sets of three points where two points are on the same side of the rectangle.\"\n    },\n    {\n      \"subproblem\": \"Calculate the area of triangles\",\n      \"description\": \"For each identified set of three points, calculate the area of the triangle formed by these points using geometric properties.\"\n    },\n    {\n      \"subproblem\": \"Determine the maximum area\",\n      \"description\": \"Compare the areas of all possible triangles for each test case and determine the maximum area.\"\n    },\n    {\n      \"subproblem\": \"Output the doubled maximum area\",\n      \"description\": \"For each test case, output the doubled maximum area of the triangle.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Input Parsing\",\n      \"description\": \"Read the number of test cases. For each test case, read the rectangle dimensions and the lattice points on each side.\"\n    },\n    {\n      \"step\": \"Triangle Formation\",\n      \"description\": \"For each test case, form triangles by selecting two points from the same side and one point from another side.\"\n    },\n    {\n      \"step\": \"Area Calculation\",\n      \"description\": \"Calculate the area of each triangle using the formula for the area of a triangle given its vertices.\"\n    },\n    {\n      \"step\": \"Max Area Determination\",\n      \"description\": \"Track the maximum area found for each test case.\"\n    },\n    {\n      \"step\": \"Output Result\",\n      \"description\": \"Print the doubled maximum area for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle with opposing corners': This refers to a rectangle defined by two corners at (0, 0) and (w, h), meaning the rectangle's sides are aligned with the axes.\n    'lattice points': These are points with integer coordinates that lie on the sides of the rectangle but not at the corners.\n    'doubled area of a triangle': The requirement is to output twice the area of the triangle formed by the selected points.\n\n# [phrase showing quantity relationship]\n    'at least two points on every side': This means each side of the rectangle has a minimum of two lattice points.\n    'maximum possible': This indicates the need to find the largest area possible for the triangle formed by the points.\n\n# [degree adverb]\n    'maximum': Refers to the largest possible area of the triangle that can be formed by the points.\n    Implementation: To find the maximum area, iterate through all possible triangles and keep track of the largest area found.\n\n# [code logic]\n    The steps \"Triangle Formation\" and \"Area Calculation\" should be considered simultaneously. For each set of points, form a triangle and immediately calculate its area to determine if it's the maximum.\n\n# [edge case]\n    Case 1: When all points on one side are very close to each other, e.g., (0, 1), (0, 2), and (5, 4).\n    Expected output: The area will be small, but the logic should still correctly identify the maximum possible area.\n    Case 2: When the rectangle is very large, e.g., w = 10^6, h = 10^6, with points spread out.\n    Expected output: The logic should handle large numbers and still find the maximum area efficiently.\n    Case 3: When points are evenly distributed on all sides, e.g., (0, 1), (0, 3), (5, 2).\n    Expected output: The logic should correctly calculate the area and identify the maximum.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through all possible triangles and calculating their areas will suffice.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x1_min = int(data[index + 1])\n        x1_max = int(data[index + k1])\n        index += k1 + 1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x2_min = int(data[index + 1])\n        x2_max = int(data[index + k2])\n        index += k2 + 1\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y1_min = int(data[index + 1])\n        y1_max = int(data[index + k3])\n        index += k3 + 1\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y2_min = int(data[index + 1])\n        y2_max = int(data[index + k4])\n        index += k4 + 1\n        \n        # Calculate maximum doubled area for each side\n        max_area = 0\n        \n        # Bottom side (y = 0) and top side (y = h)\n        max_area = max(max_area, (x1_max - x1_min) * h)\n        max_area = max(max_area, (x2_max - x2_min) * h)\n        \n        # Left side (x = 0) and right side (x = w)\n        max_area = max(max_area, (y1_max - y1_min) * w)\n        max_area = max(max_area, (y2_max - y2_min) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 83)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x1_min = int(data[index + 1])\n        x1_max = int(data[index + k1])\n        index += k1 + 1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x2_min = int(data[index + 1])\n        x2_max = int(data[index + k2])\n        index += k2 + 1\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y1_min = int(data[index + 1])\n        y1_max = int(data[index + k3])\n        index += k3 + 1\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y2_min = int(data[index + 1])\n        y2_max = int(data[index + k4])\n        index += k4 + 1\n        \n        # Calculate maximum doubled area for each side\n        max_area = 0\n        \n        # Bottom side (y = 0) and top side (y = h)\n        max_area = max(max_area, (x1_max - x1_min) * h)\n        max_area = max(max_area, (x2_max - x2_min) * h)\n        \n        # Left side (x = 0) and right side (x = w)\n        max_area = max(max_area, (y1_max - y1_min) * w)\n        max_area = max(max_area, (y2_max - y2_min) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"decomposition\": [\n    {\n      \"subproblem\": \"Parse the input data\",\n      \"description\": \"Read the number of test cases, dimensions of the rectangle, and the list of lattice points for each side of the rectangle.\"\n    },\n    {\n      \"subproblem\": \"Identify potential triangles\",\n      \"description\": \"For each test case, identify sets of three points where two points are on the same side of the rectangle.\"\n    },\n    {\n      \"subproblem\": \"Calculate triangle area\",\n      \"description\": \"For each identified set of points, calculate the area of the triangle formed by them using geometric properties.\"\n    },\n    {\n      \"subproblem\": \"Determine maximum area\",\n      \"description\": \"Compare the areas of all possible triangles for each test case and determine the maximum area.\"\n    },\n    {\n      \"subproblem\": \"Output the result\",\n      \"description\": \"Print the doubled maximum area for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Input Handling\",\n      \"description\": \"Read and parse the input data to extract the number of test cases, rectangle dimensions, and lattice points for each side.\"\n    },\n    {\n      \"step\": \"Triangle Formation\",\n      \"description\": \"For each test case, iterate through the points on each side to form triangles with two points on the same side and one point on another side.\"\n    },\n    {\n      \"step\": \"Area Calculation\",\n      \"description\": \"Use the formula for the area of a triangle given three points to calculate the area for each formed triangle.\"\n    },\n    {\n      \"step\": \"Max Area Determination\",\n      \"description\": \"Track the maximum area found for each test case and store the doubled value.\"\n    },\n    {\n      \"step\": \"Output Results\",\n      \"description\": \"Print the doubled maximum area for each test case as the final output.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'lattice points'\n    Explanation: Lattice points are points with integer coordinates. In this problem, they lie on the sides of a rectangle but not at the corners.\n\n    'doubled area of a triangle'\n    Explanation: The problem requires calculating the area of a triangle formed by three points and then doubling it. This is a common technique in computational geometry to avoid dealing with fractions.\n\n# [phrase showing quantity relationship]\n    'at least two points on every side'\n    Explanation: This means that each side of the rectangle will have a minimum of two points, ensuring that a triangle can always be formed.\n\n# [degree adverb]\n    'maximum possible'\n    Explanation: The task is to find the largest possible area of a triangle that can be formed under the given conditions.\n\n# [code logic]\n    The steps \"Triangle Formation\" and \"Area Calculation\" should be considered simultaneously. For each pair of points on the same side, calculate the area with a point from another side immediately to efficiently find the maximum area.\n\n# [edge case]\n    1. Test case with minimum dimensions and points:\n       Input: \n       ```\n       1\n       3 3\n       2 1 2\n       2 1 2\n       2 1 2\n       2 1 2\n       ```\n       Expected Output: 4\n       Explanation: The largest triangle is formed by points (1, 0), (2, 0), and (3, 1) with a doubled area of 4.\n\n    2. Test case with points only on one side:\n       Input:\n       ```\n       1\n       5 5\n       2 1 4\n       2 1 4\n       2 1 4\n       2 1 4\n       ```\n       Expected Output: 15\n       Explanation: The largest triangle is formed by points (1, 0), (4, 0), and (5, 4) with a doubled area of 15.\n\n    3. Test case with maximum possible points on one side:\n       Input:\n       ```\n       1\n       1000000 1000000\n       200000 1 2 ... 200000\n       2 1 999999\n       2 1 999999\n       2 1 999999\n       ```\n       Expected Output: ", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side\n        k1 = int(data[index])\n        x1 = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        # Read points on the top side\n        k2 = int(data[index])\n        x2 = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        # Read points on the left side\n        k3 = int(data[index])\n        y1 = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        # Read points on the right side\n        k4 = int(data[index])\n        y2 = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        # Calculate maximum doubled area for each side\n        max_area = 0\n        \n        # Bottom and Top sides\n        max_area = max(max_area, (x1[-1] - x1[0]) * h)\n        max_area = max(max_area, (x2[-1] - x2[0]) * h)\n        \n        # Left and Right sides\n        max_area = max(max_area, (y1[-1] - y1[0]) * w)\n        max_area = max(max_area, (y2[-1] - y2[0]) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of the rectangle, and the list of lattice points on each side for each test case.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, identify the two points on the same side of the rectangle that are farthest apart.\",\n      \"output\": \"The maximum distance between two points on the same side for each side of the rectangle.\"\n    },\n    {\n      \"description\": \"Calculate the maximum possible area of a triangle formed by choosing two points from the same side and one point from an adjacent side.\",\n      \"output\": \"The maximum doubled area of the triangle for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format for each test case.\",\n    \"For each test case, iterate over the four sides of the rectangle and find the two points on each side that are farthest apart.\",\n    \"Calculate the maximum possible doubled area of a triangle by considering combinations of two points from the same side and one point from an adjacent side.\",\n    \"Output the maximum doubled area for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A four-sided polygon with opposite sides equal and parallel, and all angles are right angles.\n    'lattice points': Points with integer coordinates.\n    'maximum possible area': The largest area that can be achieved by forming a triangle with the given points.\n\n# [phrase showing quantity relationship]\n    'maximum possible': Refers to the largest area that can be achieved by forming a triangle with the given points.\n    Implementation: Use geometric properties to calculate the area of triangles and find the maximum.\n\n# [degree adverb]\n    'maximum': Refers to the largest area that can be achieved by forming a triangle with the given points.\n    Implementation: Iterate through possible combinations of points and calculate the area, keeping track of the largest area found.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially. However, when calculating the maximum possible area, the logic for finding the two farthest points on the same side and combining them with a point from an adjacent side should be considered simultaneously to ensure the maximum area is calculated efficiently.\n\n# [edge case]\n    Edge Case 1: When all points on one side are very close to each other, the maximum area might be formed by points on another side.\n    Edge Case 2: When the rectangle is very large, the maximum area might be formed by points on the longer sides.\n    Edge Case 3: When the number of points is minimal (e.g., 2 points per side), the choice of points is limited, affecting the maximum area calculation.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through combinations of points and calculating the area will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def max_doubled_area(t, test_cases):\n    results = []\n    for case in test_cases:\n        w, h, x_bottom, x_top, y_left, y_right = case\n        \n        # Calculate maximum distance between two points on the same side\n        max_x_bottom = (x_bottom[-1] - x_bottom[0]) * h\n        max_x_top = (x_top[-1] - x_top[0]) * h\n        max_y_left = (y_left[-1] - y_left[0]) * w\n        max_y_right = (y_right[-1] - y_right[0]) * w\n        \n        # Find the maximum doubled area\n        max_area = max(max_x_bottom, max_x_top, max_y_left, max_y_right)\n        results.append(max_area)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        k_bottom = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k_bottom]))\n        index += 1 + k_bottom\n        \n        k_top = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k_top]))\n        index += 1 + k_top\n        \n        k_left = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k_left]))\n        index += 1 + k_left\n        \n        k_right = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k_right]))\n        index += 1 + k_right\n        \n        test_cases.append((w, h, x_bottom, x_top, y_left, y_right))\n    \n    results = max_doubled_area(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the rectangle dimensions and the list of lattice points on each side.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, identify the two points on the same side of the rectangle that are farthest apart. This will help in maximizing the base of the triangle.\",\n      \"output\": \"The maximum distance between two points on the same side for each side of the rectangle.\"\n    },\n    {\n      \"description\": \"Calculate the maximum possible area of a triangle by considering the farthest points on one side as the base and a point from the opposite side as the third vertex.\",\n      \"output\": \"The maximum doubled area of the triangle for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Parse the rectangle dimensions (w, h) and the list of lattice points on each side.\",\n    \"  b. For each side of the rectangle, find the two points that are farthest apart.\",\n    \"  c. Calculate the maximum possible doubled area of a triangle using the farthest points on one side as the base and a point from the opposite side as the third vertex.\",\n    \"  d. Compare the areas obtained from different sides and select the maximum doubled area.\",\n    \"Output the maximum doubled area for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle'\n    Explanation: A rectangle is a quadrilateral with opposite sides parallel and equal in length. In this problem, the rectangle is defined by its opposing corners at (0, 0) and (w, h).\n\n    'lattice points'\n    Explanation: Lattice points are points with integer coordinates. In this problem, they lie on the sides of the rectangle but not at the corners.\n\n    'doubled area of a triangle'\n    Explanation: The area of a triangle formed by lattice points is always an integer when doubled. The task is to find the maximum possible doubled area of such a triangle.\n\n# [phrase showing quantity relationship]\n    'at least two points on every side'\n    Explanation: This means that each side of the rectangle has a minimum of two lattice points, ensuring that a triangle can be formed.\n\n    'maximum possible'\n    Explanation: This indicates the need to find the largest possible value, in this case, the largest doubled area of a triangle.\n\n# [degree adverb]\n    'maximum'\n    Explanation: Refers to the largest possible doubled area of a triangle that can be formed by the given points.\n\n# [code logic]\n    The steps in the plan can be implemented in sequence, but step 2b and 2c can be considered together as they both involve calculating distances and areas. Specifically, finding the farthest points and calculating the area can be done in a single loop for efficiency.\n\n# [edge case]\n    1. Test case with minimum dimensions and points:\n       Input: 1 3 3 2 1 2 2 1 2 2 1 2 2 1 2\n       Expected Output: 4\n       Explanation: The smallest possible rectangle with minimum points on each side, forming a triangle with maximum doubled area of 4.\n\n    2. Test case with all points on one side:\n       Input: 1 5 5 5 1 2 3 4 5 2 1 2 2 1 2\n       Expected Output: 16\n       Explanation: All points on one side, forming a triangle with maximum doubled area of 16.\n\n    3. Test case with maximum dimensions:\n       Input: 1 1000000 1000000 2 1 999999 2 1 999999 2 1 999999 2 1 999999\n       Expected Output", "Round_0": {"code": "def max_doubled_area_of_triangle(test_cases):\n    results = []\n    for case in test_cases:\n        w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right = case\n        \n        # Calculate maximum base for horizontal sides\n        max_base_bottom = horizontal_bottom[-1] - horizontal_bottom[0]\n        max_base_top = horizontal_top[-1] - horizontal_top[0]\n        \n        # Calculate maximum base for vertical sides\n        max_base_left = vertical_left[-1] - vertical_left[0]\n        max_base_right = vertical_right[-1] - vertical_right[0]\n        \n        # Calculate maximum doubled area for each side\n        max_area_bottom = max_base_bottom * h\n        max_area_top = max_base_top * h\n        max_area_left = max_base_left * w\n        max_area_right = max_base_right * w\n        \n        # Find the maximum doubled area\n        max_doubled_area = max(max_area_bottom, max_area_top, max_area_left, max_area_right)\n        \n        results.append(max_doubled_area)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        k1 = int(data[index])\n        horizontal_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        k2 = int(data[index])\n        horizontal_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        k3 = int(data[index])\n        vertical_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        k4 = int(data[index])\n        vertical_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        test_cases.append((w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right))\n    \n    results = max_doubled_area_of_triangle(test_cases)\n    \n    for result in results:\n        print(result)", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposition\": [\n    {\n      \"subproblem\": \"Parse the input data\",\n      \"description\": \"Read the number of test cases, dimensions of the rectangle, and the list of lattice points for each side of the rectangle.\"\n    },\n    {\n      \"subproblem\": \"Identify potential triangles\",\n      \"description\": \"For each test case, identify sets of three points where two points are on the same side of the rectangle.\"\n    },\n    {\n      \"subproblem\": \"Calculate the area of triangles\",\n      \"description\": \"For each identified set of points, calculate the area of the triangle formed by them using geometric properties.\"\n    },\n    {\n      \"subproblem\": \"Determine the maximum area\",\n      \"description\": \"Compare the areas of all possible triangles for each test case and determine the maximum area.\"\n    },\n    {\n      \"subproblem\": \"Output the doubled maximum area\",\n      \"description\": \"For each test case, output the doubled maximum area of the triangle.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Initialize\",\n      \"description\": \"Set up data structures to store input data and results.\"\n    },\n    {\n      \"step\": \"Input Parsing\",\n      \"description\": \"Read and parse the input data to extract the number of test cases, rectangle dimensions, and lattice points for each side.\"\n    },\n    {\n      \"step\": \"Triangle Identification\",\n      \"description\": \"For each test case, iterate through the points on each side to identify valid sets of three points.\"\n    },\n    {\n      \"step\": \"Area Calculation\",\n      \"description\": \"For each valid set of points, calculate the area of the triangle using the formula for the area of a triangle given its vertices.\"\n    },\n    {\n      \"step\": \"Max Area Determination\",\n      \"description\": \"Track the maximum area found for each test case.\"\n    },\n    {\n      \"step\": \"Output Results\",\n      \"description\": \"Print the doubled maximum area for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'lattice points'\n    Explanation: Lattice points are points with integer coordinates. In this problem, they lie on the sides of a rectangle but not at the corners.\n\n    'doubled area of a triangle'\n    Explanation: The problem requires calculating the area of a triangle formed by three points and then doubling it. This is a common technique in computational geometry to avoid dealing with fractions.\n\n# [phrase showing quantity relationship]\n    'at least two points on every side'\n    Explanation: This means that each side of the rectangle has a minimum of two points, ensuring that a triangle can be formed with points from different sides.\n\n# [degree adverb] \n    'maximum possible'\n    Explanation: The task is to find the largest possible area of a triangle that can be formed under the given conditions.\n\n# [code logic]\n    The steps \"Triangle Identification\" and \"Area Calculation\" should be considered simultaneously. \n    Explanation: As you identify valid sets of three points, you can immediately calculate the area of the triangle they form. This can be done in a single loop or function to improve efficiency.\n\n# [edge case] \n    Edge Case 1: w = 3, h = 3, points on sides: [(1,0), (2,0)], [(1,3), (2,3)], [(0,1), (0,2)], [(3,1), (3,2)]\n    Expected Output: 9\n    Explanation: The largest triangle is formed by points (0,1), (0,2), and (3,1) with a doubled area of 9.\n\n    Edge Case 2: w = 4, h = 4, points on sides: [(1,0), (3,0)], [(1,4), (3,4)], [(0,1), (0,3)], [(4,1), (4,3)]\n    Expected Output: 16\n    Explanation: The largest triangle is formed by points (0,1), (0,3), and (4,1) with a doubled area of 16.\n\n    Edge Case 3: w = 5, h = 5, points on sides: [(1,0), (4,0)], [(1,5), (4,5)], [(0,1), (0,4)], [(5,1), (5,4)]\n    Expected Output: 25\n    Explanation: The largest triangle", "Round_0": {"code": "def max_doubled_area_of_triangle(test_cases):\n    results = []\n    \n    for case in test_cases:\n        w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right = case\n        \n        # Calculate maximum doubled area for horizontal sides\n        max_horizontal_area = max(\n            (horizontal_bottom[-1] - horizontal_bottom[0]) * h,\n            (horizontal_top[-1] - horizontal_top[0]) * h\n        )\n        \n        # Calculate maximum doubled area for vertical sides\n        max_vertical_area = max(\n            (vertical_left[-1] - vertical_left[0]) * w,\n            (vertical_right[-1] - vertical_right[0]) * w\n        )\n        \n        # Determine the maximum doubled area\n        max_area = max(max_horizontal_area, max_vertical_area)\n        results.append(max_area)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        k1 = int(data[index])\n        horizontal_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        k2 = int(data[index])\n        horizontal_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        k3 = int(data[index])\n        vertical_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        k4 = int(data[index])\n        vertical_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        test_cases.append((w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right))\n    \n    results = max_doubled_area_of_triangle(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of the rectangle, and the list of lattice points on each side for each test case.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, identify the two points on the same side of the rectangle that are farthest apart.\",\n      \"output\": \"The maximum distance between two points on the same side for each side of the rectangle.\"\n    },\n    {\n      \"description\": \"Calculate the maximum possible area of a triangle formed by choosing two points from the same side and one point from an adjacent side.\",\n      \"output\": \"The maximum doubled area of the triangle for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, iterate over the four sides of the rectangle.\",\n    \"For each side, calculate the maximum distance between the two farthest points.\",\n    \"For each pair of adjacent sides, calculate the area of the triangle formed by the two farthest points on one side and the farthest point on the adjacent side.\",\n    \"Determine the maximum area from all possible triangles for each test case.\",\n    \"Output the doubled maximum area for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle', 'lattice points', 'triangle', 'maximum area'\n    Explanation: \n    - 'rectangle': A four-sided polygon with opposing corners at (0, 0) and (w, h) and edges aligned with the axes.\n    - 'lattice points': Points with integer coordinates that lie on the sides of the rectangle but not at the corners.\n    - 'triangle': A polygon formed by three points.\n    - 'maximum area': The largest possible area that can be formed by a triangle using the given points.\n\n# [phrase showing quantity relationship]\n    'maximum possible': Refers to finding the largest area of a triangle that can be formed by the given points.\n    Implementation: Calculate the area of triangles formed by points and compare to find the maximum.\n\n# [degree adverb] \n    'maximum': Refers to the largest area achievable by a triangle formed by the points.\n    Implementation: Use comparison to determine the largest area among calculated triangle areas.\n\n# [code logic]\n    The steps to calculate the maximum distance between two points on the same side and the area of the triangle should be considered simultaneously for efficiency. This can be done by iterating over the sides and calculating both the maximum distance and potential triangle areas in one loop.\n\n# [edge case] \n    Edge cases are not explicitly given in the requirement, but we can infer:\n    - Case with minimum number of points on each side: \n      Input: 3 3\n             2 1 2\n             2 1 2\n             2 1 2\n             2 1 2\n      Expected output: 6\n      Explanation: The largest triangle is formed by points (1, 0), (2, 0), and (2, 3) with an area of 3, doubled area is 6.\n    - Case with points forming a straight line:\n      Input: 5 5\n             2 1 4\n             2 1 4\n             2 1 4\n             2 1 4\n      Expected output: 0\n      Explanation: All points are collinear, no triangle can be formed.\n    - Case with maximum number of points:\n      Input: 1000000 1000000\n             2 1 999999\n             2 1 999999\n             2 1 999999\n             2 1", "Round_0": {"code": "def max_doubled_area(t, test_cases):\n    results = []\n    for case in test_cases:\n        w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right = case\n        \n        # Calculate maximum distance on each side\n        max_horizontal_bottom = horizontal_bottom[-1] - horizontal_bottom[0]\n        max_horizontal_top = horizontal_top[-1] - horizontal_top[0]\n        max_vertical_left = vertical_left[-1] - vertical_left[0]\n        max_vertical_right = vertical_right[-1] - vertical_right[0]\n        \n        # Calculate maximum doubled area for each pair of adjacent sides\n        max_area = 0\n        max_area = max(max_area, max_horizontal_bottom * h)\n        max_area = max(max_area, max_horizontal_top * h)\n        max_area = max(max_area, max_vertical_left * w)\n        max_area = max(max_area, max_vertical_right * w)\n        \n        results.append(max_area)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        k1 = int(data[index])\n        horizontal_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        k2 = int(data[index])\n        horizontal_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        k3 = int(data[index])\n        vertical_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        k4 = int(data[index])\n        vertical_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        test_cases.append((w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right))\n    \n    results = max_doubled_area(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: list index out of range"}, "Round_1": {"code": "def max_doubled_area(t, test_cases):\n    results = []\n    for case in test_cases:\n        w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right = case\n        \n        # Calculate maximum distance on each side\n        max_horizontal_bottom = horizontal_bottom[-1] - horizontal_bottom[0]\n        max_horizontal_top = horizontal_top[-1] - horizontal_top[0]\n        max_vertical_left = vertical_left[-1] - vertical_left[0]\n        max_vertical_right = vertical_right[-1] - vertical_right[0]\n        \n        # Calculate maximum doubled area for each pair of adjacent sides\n        max_area = 0\n        max_area = max(max_area, max_horizontal_bottom * h)\n        max_area = max(max_area, max_horizontal_top * h)\n        max_area = max(max_area, max_vertical_left * w)\n        max_area = max(max_area, max_vertical_right * w)\n        \n        results.append(max_area)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        k1 = int(data[index])\n        horizontal_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        k2 = int(data[index])\n        horizontal_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        k3 = int(data[index])\n        vertical_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        k4 = int(data[index])\n        vertical_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        test_cases.append((w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right))\n    \n    results = max_doubled_area(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of the rectangle, and the list of lattice points for each side.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions w and h of the rectangle.\",\n        \"Read the number of points and their coordinates for each of the four sides of the rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Identify the two points on the same side that maximize the distance between them.\",\n      \"steps\": [\n        \"For each side, calculate the distance between the first and last point.\",\n        \"Store the maximum distance for each side.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum possible area of a triangle formed by choosing two points from the same side and one point from another side.\",\n      \"steps\": [\n        \"For horizontal sides, calculate the area using the formula: max_distance * h.\",\n        \"For vertical sides, calculate the area using the formula: max_distance * w.\",\n        \"Determine the maximum area from the calculated values.\"\n      ]\n    },\n    {\n      \"description\": \"Output the doubled maximum area for each test case.\",\n      \"steps\": [\n        \"Multiply the maximum area by 2.\",\n        \"Print the result for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, determine the maximum distance between two points on the same side for all four sides of the rectangle.\",\n    \"Calculate the maximum possible area of a triangle using the identified distances and rectangle dimensions.\",\n    \"Output the doubled maximum area for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'lattice points'\n    Explanation: Lattice points are points with integer coordinates. In this problem, they lie on the sides of a rectangle but not at the corners.\n\n    'doubled area'\n    Explanation: The problem requires calculating the area of a triangle and then doubling it. This is because the area of a triangle formed by lattice points is always an integer when doubled.\n\n# [phrase showing quantity relationship]\n    'at least two points on every side'\n    Explanation: This means that each side of the rectangle will have a minimum of two points, ensuring that a triangle can always be formed.\n\n    'maximum possible'\n    Explanation: The task is to find the configuration of points that results in the largest possible area for the triangle.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This refers to finding the largest possible area of a triangle that can be formed under the given conditions.\n\n# [code logic]\n    The steps in the plan are well-structured and do not require simultaneous execution. Each step logically follows from the previous one, ensuring clarity and correctness in the implementation.\n\n# [edge case]\n    1. Test case with minimum dimensions and points:\n       Input: \n       ```\n       1\n       3 3\n       2 1 2\n       2 1 2\n       2 1 2\n       2 1 2\n       ```\n       Expected Output: 6\n       Explanation: The maximum triangle is formed by points (1, 0), (2, 0), and (1, 3) with a doubled area of 6.\n\n    2. Test case with points only on one side:\n       Input:\n       ```\n       1\n       5 5\n       2 1 4\n       2 1 4\n       2 1 4\n       2 1 4\n       ```\n       Expected Output: 20\n       Explanation: The maximum triangle is formed by points (1, 0), (4, 0), and (1, 5) with a doubled area of 20.\n\n    3. Test case with maximum possible points:\n       Input:\n       ```\n       1\n       1000000 1000000\n       200000 1 2 ... 199999\n       200000 1 2 ... 199999\n       200000 1 2 ... ", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x1_min = int(data[index + 1])\n        x1_max = int(data[index + k1])\n        index += k1 + 1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x2_min = int(data[index + 1])\n        x2_max = int(data[index + k2])\n        index += k2 + 1\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y1_min = int(data[index + 1])\n        y1_max = int(data[index + k3])\n        index += k3 + 1\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y2_min = int(data[index + 1])\n        y2_max = int(data[index + k4])\n        index += k4 + 1\n        \n        # Calculate maximum doubled area\n        max_area = 0\n        \n        # Horizontal sides\n        max_area = max(max_area, (x1_max - x1_min) * h)\n        max_area = max(max_area, (x2_max - x2_min) * h)\n        \n        # Vertical sides\n        max_area = max(max_area, (y1_max - y1_min) * w)\n        max_area = max(max_area, (y2_max - y2_min) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of the rectangle, and the list of lattice points on each side for each test case.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, identify the two points on the same side that are farthest apart for each side of the rectangle.\",\n      \"output\": \"The maximum distance between two points on each side of the rectangle.\"\n    },\n    {\n      \"description\": \"Calculate the doubled area of the triangle formed by the two farthest points on one side and a point on the opposite side for each pair of sides.\",\n      \"output\": \"The doubled area of the triangle for each pair of sides.\"\n    },\n    {\n      \"description\": \"Determine the maximum doubled area of the triangle for each test case.\",\n      \"output\": \"The maximum doubled area of the triangle for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, iterate over each side of the rectangle and find the two points that are farthest apart.\",\n    \"For each pair of opposite sides, calculate the doubled area of the triangle formed by the two farthest points on one side and a point on the opposite side.\",\n    \"Compare the calculated areas for all pairs of sides and determine the maximum doubled area for each test case.\",\n    \"Output the maximum doubled area for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'lattice points'\n    Explanation: Lattice points are points with integer coordinates that lie on the sides of the rectangle.\n\n    'doubled area of a triangle'\n    Explanation: The requirement asks for the area of the triangle formed by the selected points, but it should be doubled. This is a common technique in computational geometry to avoid dealing with fractions.\n\n# [phrase showing quantity relationship]\n    'at least two points on every side'\n    Explanation: This means that each side of the rectangle will have a minimum of two points, ensuring that a triangle can always be formed.\n\n    'maximum possible'\n    Explanation: The task is to find the configuration of points that results in the largest possible area for the triangle.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This indicates that we need to find the largest possible area of the triangle that can be formed by the given points.\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the calculation of the maximum distance between points on each side and the calculation of the doubled area of the triangle can be considered simultaneously for optimization. Specifically, once the farthest points on a side are identified, the area calculation can be done immediately.\n\n# [edge case]\n    1. Test case with minimum dimensions and points:\n       Input: \n       ```\n       1\n       3 3\n       2 1 2\n       2 1 2\n       2 1 2\n       2 1 2\n       ```\n       Expected Output: 4\n       Explanation: The points (1,0), (2,0) and (1,3) form a triangle with doubled area 4.\n\n    2. Test case with points only on one side:\n       Input:\n       ```\n       1\n       5 5\n       2 1 4\n       2 1 4\n       2 1 4\n       2 1 4\n       ```\n       Expected Output: 15\n       Explanation: The points (1,0), (4,0) and (1,5) form a triangle with doubled area 15.\n\n    3. Test case with maximum possible points on a side:\n       Input:\n       ```\n       1\n       1000000 1000000\n       200000 1 2 ... 200000\n       200000 1 2", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        # Calculate maximum doubled area for each pair of opposite sides\n        max_area = 0\n        \n        # Bottom and Top sides\n        if x_bottom:\n            max_area = max(max_area, (x_bottom[-1] - x_bottom[0]) * h)\n        if x_top:\n            max_area = max(max_area, (x_top[-1] - x_top[0]) * h)\n        \n        # Left and Right sides\n        if y_left:\n            max_area = max(max_area, (y_left[-1] - y_left[0]) * w)\n        if y_right:\n            max_area = max(max_area, (y_right[-1] - y_right[0]) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of the rectangle, and the list of lattice points on each side for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions of the rectangle (w, h).\",\n        \"Read the number of points and their coordinates for each of the four sides of the rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Identify the two points on the same side that can form the largest base of a triangle.\",\n      \"steps\": [\n        \"For each side, calculate the potential base length using the first and last point on that side.\",\n        \"Store the maximum base length for each side.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum possible area of a triangle using the identified base and a point from another side.\",\n      \"steps\": [\n        \"For each side, use the maximum base length and calculate the area with a point from the opposite side.\",\n        \"Use the formula for the area of a triangle: (base * height) / 2.\",\n        \"Double the area to match the requirement of outputting the doubled area.\"\n      ]\n    },\n    {\n      \"description\": \"Output the doubled maximum area for each test case.\",\n      \"steps\": [\n        \"For each test case, determine the maximum doubled area from the calculated values.\",\n        \"Print the result for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize data structures to store input values and results.\",\n    \"Iterate over each test case to process the rectangle and points.\",\n    \"For each side of the rectangle, determine the maximum base length using the first and last points.\",\n    \"Calculate the maximum possible area of a triangle using the identified base and a point from another side.\",\n    \"Store the doubled area for each test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A four-sided polygon with opposite sides equal and parallel, and all angles are right angles.\n    'lattice points': Points with integer coordinates.\n    'maximum possible area': The largest area that can be formed by a triangle using the given points.\n\n# [phrase showing quantity relationship]\n    'maximum possible': Refers to the largest area that can be achieved by selecting points according to the given conditions.\n    Implementation: Calculate the area using the formula for a triangle and ensure it is the largest possible by comparing all combinations.\n\n# [degree adverb]\n    'maximum': Refers to the largest area achievable.\n    Implementation: Use a comparison to keep track of the largest area found during calculations.\n\n# [code logic]\n    The steps for calculating the maximum base length and the maximum area should be considered simultaneously for efficiency.\n    Implementation: Calculate the base length and area in a single loop over the sides to avoid redundant calculations.\n\n# [edge case]\n    Case 1: Minimum number of points on each side\n    Input: 3 3\n           2 1 2\n           2 1 2\n           2 1 2\n           2 1 2\n    Expected Output: 4\n    Explanation: The smallest rectangle with minimum points, the largest triangle is formed by points (0, 1), (0, 2), and (3, 2).\n\n    Case 2: All points are on one side\n    Input: 5 5\n           5 1 2 3 4 5\n           2 1 2\n           2 1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: No valid triangle can be formed as all points are on one side.\n\n    Case 3: Points forming a straight line\n    Input: 5 5\n           2 1 5\n           2 1 5\n           2 1 5\n           2 1 5\n    Expected Output: 0\n    Explanation: All points are collinear, no area can be formed.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where no valid triangle can be formed.\n    Implementation:\n    ```python\n    if len(points_on_side) < 2 or all_points_collinear(points_on_side):\n        return 0\n    ```\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side\n        k1 = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        # Read points on the top side\n        k2 = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        # Read points on the left side\n        k3 = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        # Read points on the right side\n        k4 = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        # Calculate maximum base lengths\n        max_base_bottom = x_bottom[-1] - x_bottom[0]\n        max_base_top = x_top[-1] - x_top[0]\n        max_base_left = y_left[-1] - y_left[0]\n        max_base_right = y_right[-1] - y_right[0]\n        \n        # Calculate maximum doubled area\n        max_doubled_area = 0\n        max_doubled_area = max(max_doubled_area, max_base_bottom * h)\n        max_doubled_area = max(max_doubled_area, max_base_top * h)\n        max_doubled_area = max(max_doubled_area, max_base_left * w)\n        max_doubled_area = max(max_doubled_area, max_base_right * w)\n        \n        results.append(max_doubled_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 139)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side\n        k1 = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        # Read points on the top side\n        k2 = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        # Read points on the left side\n        k3 = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        # Read points on the right side\n        k4 = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        # Calculate maximum base lengths\n        max_base_bottom = x_bottom[-1] - x_bottom[0]\n        max_base_top = x_top[-1] - x_top[0]\n        max_base_left = y_left[-1] - y_left[0]\n        max_base_right = y_right[-1] - y_right[0]\n        \n        # Calculate maximum doubled area\n        max_doubled_area = 0\n        max_doubled_area = max(max_doubled_area, max_base_bottom * h)\n        max_doubled_area = max(max_doubled_area, max_base_top * h)\n        max_doubled_area = max(max_doubled_area, max_base_left * w)\n        max_doubled_area = max(max_doubled_area, max_base_right * w)\n        \n        results.append(max_doubled_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of the rectangle, and the list of lattice points on each side for each test case.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, identify the two points on the same side of the rectangle that are farthest apart.\",\n      \"output\": \"The maximum distance between two points on the same side for each side of the rectangle.\"\n    },\n    {\n      \"description\": \"Calculate the maximum possible area of a triangle formed by choosing two points from the same side and one point from an adjacent side.\",\n      \"output\": \"The maximum doubled area of the triangle for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format, including the number of test cases, rectangle dimensions, and lattice points on each side.\",\n    \"For each test case, iterate over each side of the rectangle and find the two points that are farthest apart. Calculate the distance between these points.\",\n    \"For each pair of sides (horizontal and vertical), calculate the potential maximum area of a triangle by using the farthest points on one side and a point on the adjacent side.\",\n    \"Compute the doubled area of the triangle using the formula for the area of a triangle given by lattice points.\",\n    \"Compare the areas obtained from different combinations of sides and select the maximum doubled area for each test case.\",\n    \"Output the maximum doubled area for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A four-sided polygon with opposite sides equal and parallel, and all angles are right angles.\n    'lattice points': Points with integer coordinates.\n    'maximum possible area': The largest area that can be achieved by forming a triangle with the given points.\n\n# [phrase showing quantity relationship]\n    'maximum possible': Refers to the largest area that can be achieved.\n    Implementation: Use geometric properties to calculate the area and compare to find the maximum.\n\n# [degree adverb]\n    'maximum': Refers to the largest area achievable.\n    Implementation: Compare calculated areas and select the largest.\n\n# [code logic]\n    Steps 2 and 3 should be considered simultaneously:\n    \"Identify the two points on the same side of the rectangle that are farthest apart\" and \"Calculate the maximum possible area of a triangle formed by choosing two points from the same side and one point from an adjacent side\" can be implemented in a single loop where you calculate the area while identifying the farthest points.\n\n# [edge case]\n    Case 1: When all points on one side are equidistant, e.g., w = 5, h = 5, points on one side are [1, 2, 3, 4].\n    Expected output: The maximum area will be determined by the farthest points on the opposite side.\n    Case 2: When the rectangle is a square, e.g., w = h = 5, points are evenly distributed.\n    Expected output: The maximum area will be determined by the farthest points on any side.\n    Case 3: When the number of points is minimal, e.g., w = 3, h = 3, points are [1, 2] on each side.\n    Expected output: The maximum area will be determined by the farthest points on adjacent sides.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of finding the maximum distance between points on the same side and calculating the area using adjacent sides will cover these cases.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x1_min = int(data[index + 1])\n        x1_max = int(data[index + k1])\n        index += k1 + 1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x2_min = int(data[index + 1])\n        x2_max = int(data[index + k2])\n        index += k2 + 1\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y1_min = int(data[index + 1])\n        y1_max = int(data[index + k3])\n        index += k3 + 1\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y2_min = int(data[index + 1])\n        y2_max = int(data[index + k4])\n        index += k4 + 1\n        \n        # Calculate maximum doubled area for each side combination\n        max_area = 0\n        \n        # Bottom and Top sides\n        max_area = max(max_area, (x1_max - x1_min) * h)\n        max_area = max(max_area, (x2_max - x2_min) * h)\n        \n        # Left and Right sides\n        max_area = max(max_area, (y1_max - y1_min) * w)\n        max_area = max(max_area, (y2_max - y2_min) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 679, "prompt": "A rectangle with its opposing corners situated at (0, 0) and (w, h) and edges aligned with the axes is illustrated on a plane.\n\nYou are given a list of lattice points such that each point lies on a side of a rectangle but not in its corner. It is important to note that none of the listed points are located at the rectangle's corners. Also, there are at least two points on every side of a rectangle.\n\nYour task is to choose three points in such a way that: \n\n  * exactly two of them belong to the same side of a rectangle; \n  * the area of a triangle formed by them is maximum possible. \n\nPrint the doubled area of this triangle. It can be shown that the doubled area of any triangle formed by lattice points is always an integer. Consider using geometric properties to identify the optimal points that maximize the area efficiently.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers w and h (3 \u2264 w, h \u2264 10^6) \u2014 the coordinates of the corner of a rectangle.\n\nThe next two lines contain the description of the points on two horizontal sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers x_1 < x_2 < ... < x_k (0 < x_i < w) \u2014 the x coordinates of the points in the ascending order. The y coordinate for the first line is 0 and for the second line is h.\n\nThe next two lines contain the description of the points on two vertical sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers y_1 < y_2 < ... < y_k (0 < y_i < h) \u2014 the y coordinates of the points in the ascending order. The x coordinate for the first line is 0 and for the second line is w.\n\nThe total number of points on all sides in all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase print a single integer \u2014 the doubled maximum area of a triangle formed by such three points that exactly two of them belong to the same side.\n\nExample\n\nInput\n\n\n3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n\n\nOutput\n\n\n25\n42\n35\n\nNote\n\nThe points in the first testcase of the example: \n\n  * (1, 0), (2, 0); \n  * (2, 8), (3, 8), (4, 8); \n  * (0, 1), (0, 4), (0, 6); \n  * (5, 4), (5, 5). \n\n\n\nThe largest triangle is formed by points (0, 1), (0, 6) and (5, 4) \u2014 its area is 25/2. Thus, the doubled area is 25. Two points that are on the same side are: (0, 1) and (0, 6).", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers w and h (3 \u2264 w, h \u2264 10^6) \u2014 the coordinates of the corner of a rectangle.\n\nThe next two lines contain the description of the points on two horizontal sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers x_1 < x_2 < ... < x_k (0 < x_i < w) \u2014 the x coordinates of the points in the ascending order. The y coordinate for the first line is 0 and for the second line is h.\n\nThe next two lines contain the description of the points on two vertical sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers y_1 < y_2 < ... < y_k (0 < y_i < h) \u2014 the y coordinates of the points in the ascending order. The x coordinate for the first line is 0 and for the second line is w.\n\nThe total number of points on all sides in all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase print a single integer \u2014 the doubled maximum area of a triangle formed by such three points that exactly two of them belong to the same side.\n\nExample\n\nInput\n\n\n3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n\n\nOutput\n\n\n25\n42\n35\n\nNote\n\nThe points in the first testcase of the example: \n\n  * (1, 0), (2, 0); \n  * (2, 8), (3, 8), (4, 8); \n  * (0, 1), (0, 4), (0, 6); \n  * (5, 4), (5, 5). \n\n\n\nThe largest triangle is formed by points (0, 1), (0, 6) and (5, 4) \u2014 its area is 25/2. Thus, the doubled area is 25. Two points that are on the same side are: (0, 1) and (0, 6).", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 333}
