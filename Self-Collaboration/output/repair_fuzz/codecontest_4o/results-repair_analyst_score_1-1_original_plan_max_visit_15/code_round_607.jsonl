{"name": "1580_C. Train Maintenance", "description": "Kawasiro Nitori is excellent in engineering. Thus she has been appointed to help maintain trains.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment. In the beginning, there are no trains, at each of the following m days, one train will be added, or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance in each day.\n\nOn a day a train is removed, it is not counted as in maintenance.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.", "tags": ["brute force", "data structures", "implementation"], "difficulty": 9, "id": 1580, "sample_io": [{"input": "3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}], "test_list": [{"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n10 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "3 4\n10 15\n12 10\n2 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "3 4\n23 15\n14 10\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n2 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n2 19\n7 19\n2 9\n26 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n5\n4\n3\n5\n7\n8\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n21 15\n7 3\n19 7\n1 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n2\n2\n2\n1\n2\n3\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n5\n4\n3\n5\n7\n8\n"]}, {"input": "5 2\n1 1\n10000011 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n1 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "10 7\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n8 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n8\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n3 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 2\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n0\n"]}, {"input": "20 7\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n4 9\n5 10\n657453515 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n3 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n"]}, {"input": "3 2\n9 15\n12 9\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n2 9\n14 19\n7 19\n2 9\n21 15\n7 3\n19 7\n1 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n2\n2\n2\n1\n3\n4\n4\n4\n4\n5\n5\n4\n3\n4\n6\n8\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 9\n2 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 2\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n3 9\n49 15\n7 6\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n6\n5\n6\n7\n7\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n1 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n14 9\n14 19\n7 19\n2 9\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n4\n3\n4\n7\n8\n"]}, {"input": "3 4\n16 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 15\n15 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 15\n10 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "3 4\n10 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000011 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 000000000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "3 4\n9 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n9 15\n12 1\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 0\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n733475792 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n13 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n467159628 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 8\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000001 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1258790837 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n26 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 0\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000011 100000000\n998244353 1\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n9 15\n12 0\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n21 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n13 15\n14 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n369260158 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n16 16\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n26 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n16 6\n2 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n23 15\n14 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n2 1\n10000001 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n2 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n450441171 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000101 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 7\n15 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "3 4\n16 15\n10 17\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000011 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000011 000000000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n9 15\n12 9\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 -1\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 241782432\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n2 1\n1 5\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 801909796\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n5 15\n12 10\n2 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "5 4\n1 1\n10000000 100000001\n733475792 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 8\n12 18\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10001011 100000000\n998244353 1\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n2 1\n10000011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n1166046831 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n26 15\n10 17\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000011 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000011 000000000\n998244353 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1425917046 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 241782432\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 11\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "20 20\n1 4\n864803385 801909796\n17 4\n12 1\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "5 4\n1 1\n10000000 100000001\n733475792 1\n2 2\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "3 4\n16 8\n12 25\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 2\n10000011 100000000\n998244353 0\n2 2\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1011185365 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000001\n733475792 0\n2 2\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 2\n1 1\n", "output": ["0\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n211018821 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n211018821 0\n3 1\n2 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "5 4\n3 1\n10000011 101000000\n211018821 0\n3 1\n2 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n4 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "3 4\n14 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 1\n2 1\n1 3\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 15\n12 15\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 0\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n14 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000011 000000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 1\n9 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n"]}, {"input": "5 4\n1 1\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n9 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n10 18\n12 10\n2 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n733475792 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n22 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 0\n430995384 733598623\n2 9\n5 13\n433415385 169535970\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n9 6\n752625088 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1258790837 0\n3 0\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 173113793\n3 10\n16 6\n2 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n2 2\n10000001 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n9 6\n450441171 733598623\n2 9\n3 10\n433415385 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n16 21\n10 17\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n9 6\n12 9\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1683854825 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 241782432\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 38795044\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n2 1\n1 10\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 0\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "3 4\n16 12\n12 18\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n4 1\n10000011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n1908812372 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n2 1\n", "output": ["0\n"]}, {"input": "5 4\n3 1\n10010011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 2\n10000011 100000000\n998244353 0\n2 4\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 2\n1 2\n", "output": ["0\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n211018821 0\n4 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n3 1\n10000011 101000000\n211018821 0\n3 1\n2 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n4 29\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "3 4\n14 15\n12 13\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 1\n3 1\n1 3\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n2 1\n10000001 100000000\n998244353 0\n2 0\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n14 15\n10 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "3 1\n9 15\n12 9\n2 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n"]}, {"input": "5 4\n1 1\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 4\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 0\n430995384 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n9 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n2 2\n10000001 100000000\n1258790837 0\n5 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n5\n4\n3\n5\n7\n8\n"]}, {"input": "5 2\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n"]}, {"input": "3 4\n16 21\n10 17\n2 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1683854825 0\n3 1\n2 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n4 1\n1 10\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "5 1\n1 0\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n3 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "3 4\n16 12\n12 22\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000000 100000000\n1908812372 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000101 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n2 1\n", "output": ["0\n"]}, {"input": "5 1\n1 1\n10000101 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 2\n1 2\n", "output": ["0\n"]}, {"input": "3 1\n9 15\n12 9\n2 2\n1 3\n1 1\n1 1\n2 3\n", "output": ["0\n"]}, {"input": "5 4\n1 0\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 4\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n0 0\n430995384 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 2\n1 1\n10000000 100010000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n"]}, {"input": "10 7\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 1\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 9\n2 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "3 4\n1 12\n12 22\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000000 100000000\n1908812372 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n2 1\n10000101 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n2 1\n", "output": ["0\n"]}, {"input": "3 1\n9 15\n12 9\n2 4\n1 3\n1 1\n1 1\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n0 0\n140846265 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 9\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n8\n"]}, {"input": "5 2\n1 2\n10000000 100010000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n"]}, {"input": "10 7\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 1\n2 9\n1 1\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 13\n2 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n12 9\n2 4\n1 3\n1 1\n0 1\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n-1 0\n140846265 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 7\n3 10\n9 6\n529113291 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 1\n2 9\n1 1\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "3 1\n9 15\n12 9\n2 4\n1 3\n1 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 7\n3 10\n-1 0\n140846265 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n17 2\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n292159474 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n3 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n7\n"]}, {"input": "3 1\n9 15\n12 11\n2 4\n1 3\n1 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 2\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n12 11\n2 4\n1 3\n0 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 1\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n12 11\n4 4\n1 3\n0 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 1\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 6\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n16 11\n4 4\n1 3\n0 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 0\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 6\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 -1\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 6\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 2\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n0 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n2 1\n10000001 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}], "task_id": "codecontest/22", "repair_prompt": ["Kawasiro Nitori is skilled in engineering. Hence she has been selected to assist in train maintenance.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment. In the beginning, there are no trains, at each of the following m days, one train will be added, or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to simplify management, Nitori wants you to help her determine the number of trains in maintenance each day.\n\nOn a day a train is removed, it is not counted as in maintenance.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Kawasiro Nitori is skilled in engineering. Due to her expertise in this field, she has been selected to assist in train maintenance.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment. In the beginning, there are no trains, at each of the following m days, one train will be added, or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to simplify management, Nitori wants you to help her determine the number of trains in maintenance each day.\n\nOn a day a train is removed, it is not counted as in maintenance.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Kawasiro Nitori is skilled in engineering and hence she has been selected to assist in train maintenance.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment. Initially, there are no trains, and at each of the following m days, one train will be added or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to simplify management, Nitori wants you to help her determine the number of trains in maintenance each day.\n\nOn a day a train is removed, it is not counted as in maintenance.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance_cycles.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # To track the current status of each train model\n    train_status = [None] * n  # None means no train of this model is present\n    \n    # To store the number of trains in maintenance each day\n    maintenance_count = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_cycles[k]\n            train_status[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Count trains in maintenance\n        count = 0\n        for status in train_status:\n            if status is not None:\n                added_day, x_i, y_i = status\n                cycle_length = x_i + y_i\n                days_since_added = day - added_day\n                if days_since_added >= x_i:\n                    # Check if it's in the maintenance period\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        count += 1\n        \n        maintenance_count.append(count)\n    \n    for count in maintenance_count:\n        print(count)\n\n\nmain()", "completions": ["def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to zero-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: (days since added, is in maintenance)\n    train_state = [None] * n\n    maintenance_count = 0\n    \n    result = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            train_state[k] = (0, False)  # Start working\n        elif op == 2:  # Remove train of model k\n            if train_state[k] and train_state[k][1]:  # If it was in maintenance\n                maintenance_count -= 1\n            train_state[k] = None\n        \n        # Update train states\n        for i in range(n):\n            if train_state[i] is not None:\n                days, in_maintenance = train_state[i]\n                x_i, y_i = train_cycles[i]\n                \n                if in_maintenance:\n                    if days + 1 == y_i:\n                        train_state[i] = (0, False)  # Switch to working\n                        maintenance_count -= 1\n                    else:\n                        train_state[i] = (days + 1, True)\n                else:\n                    if days + 1 == x_i:\n                        train_state[i] = (0, True)  # Switch to maintenance\n                        maintenance_count += 1\n                    else:\n                        train_state[i] = (days + 1, False)\n        \n        result.append(maintenance_count)\n    \n    for count in result:\n        print(count)\n\ntrain_maintenance()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State of each train model\n    train_state = [None] * n  # None means no train, otherwise it stores the day it was added\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_state[k] = day\n        elif op == 2:  # Remove train\n            train_state[k] = None\n        \n        # Calculate the number of trains in maintenance\n        maintenance_count = 0\n        for i in range(n):\n            if train_state[i] is not None:\n                x_i, y_i = work_maintenance[i]\n                days_since_added = day - train_state[i]\n                cycle_length = x_i + y_i\n                if days_since_added >= x_i:\n                    # Check if it's in the maintenance period\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        maintenance_count += 1\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_cycles.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to zero-based index\n        index += 1\n        operations.append((op, k))\n    \n    active_trains = {}\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            active_trains[k] = (day, x_i, y_i)\n        \n        elif op == 2:  # Remove train of model k\n            if k in active_trains:\n                del active_trains[k]\n        \n        # Update maintenance count for the current day\n        for model, (start_day, x_i, y_i) in active_trains.items():\n            cycle_length = x_i + y_i\n            days_since_start = day - start_day\n            if days_since_start >= x_i and (days_since_start - x_i) % cycle_length < y_i:\n                maintenance_count[day] += 1\n    \n    for count in maintenance_count:\n        print(count)\n\ntrain_maintenance()\n\nmain()", "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_models = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_models.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        operations.append((op, k))\n    \n    # State of trains: 0 means not present, positive means days since added\n    train_state = [0] * (n + 1)\n    \n    result = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_state[k] = 1\n        elif op == 2:  # Remove train of model k\n            train_state[k] = 0\n        \n        maintenance_count = 0\n        \n        # Calculate maintenance count\n        for i in range(1, n + 1):\n            if train_state[i] > 0:\n                x_i, y_i = train_models[i-1]\n                if train_state[i] > x_i and (train_state[i] - x_i) % (x_i + y_i) < y_i:\n                    maintenance_count += 1\n                train_state[i] += 1\n        \n        result.append(maintenance_count)\n    \n    for res in result:\n        print(res)\n\ntrain_maintenance()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_periods.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking\n    train_states = {}\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        x_i, y_i = train_periods[k]\n        \n        if op == 1:  # Add train\n            # Calculate the initial state\n            train_states[k] = day + x_i  # Next maintenance day\n        elif op == 2:  # Remove train\n            if k in train_states:\n                del train_states[k]\n        \n        # Count trains in maintenance\n        count = 0\n        for model, next_maintenance_day in train_states.items():\n            if day >= next_maintenance_day:\n                # Calculate the cycle position\n                cycle_length = train_periods[model][0] + train_periods[model][1]\n                days_since_start = day - (next_maintenance_day - train_periods[model][0])\n                if days_since_start % cycle_length >= train_periods[model][0]:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_models = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_models.append((x_i, y_i))\n    \n    train_states = {}\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1\n        index += 1\n        \n        if op == 1:  # Add train\n            x_i, y_i = train_models[k]\n            train_states[k] = {'state': 'running', 'start_day': day, 'x_i': x_i, 'y_i': y_i}\n        elif op == 2:  # Remove train\n            if k in train_states:\n                del train_states[k]\n        \n        # Calculate maintenance count for the current day\n        for model, state_info in train_states.items():\n            x_i = state_info['x_i']\n            y_i = state_info['y_i']\n            start_day = state_info['start_day']\n            cycle_length = x_i + y_i\n            days_since_start = day - start_day\n            \n            if days_since_start >= x_i and (days_since_start - x_i) % cycle_length < y_i:\n                maintenance_count[day] += 1\n    \n    for count in maintenance_count:\n        print(count)\n\ntrain_maintenance()\n\nmain()", "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_periods.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking\n    train_states = [None] * n  # None means no train, otherwise store the start day\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_states[k] = day\n        elif op == 2:  # Remove train\n            train_states[k] = None\n        \n        # Calculate maintenance count\n        maintenance_count = 0\n        for model in range(n):\n            start_day = train_states[model]\n            if start_day is not None:\n                x_i, y_i = train_periods[model]\n                elapsed_days = day - start_day\n                cycle_length = x_i + y_i\n                if elapsed_days >= x_i and (elapsed_days % cycle_length) >= x_i:\n                    maintenance_count += 1\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\ntrain_maintenance()\n\nmain()", "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_specs = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_specs.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        operations.append((op, k))\n    \n    train_state = {}\n    maintenance_count = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        if op == 1:  # Add train\n            train_state[k] = 0  # Start working cycle\n        elif op == 2:  # Remove train\n            if k in train_state:\n                del train_state[k]  # Remove train from tracking\n        \n        # Calculate maintenance count\n        count = 0\n        for model in train_state:\n            x_i, y_i = train_specs[model - 1]\n            cycle_position = train_state[model]\n            if cycle_position >= x_i:\n                count += 1\n        \n        maintenance_count.append(count)\n        \n        # Update train states\n        for model in train_state:\n            x_i, y_i = train_specs[model - 1]\n            cycle_position = train_state[model]\n            cycle_length = x_i + y_i\n            train_state[model] = (cycle_position + 1) % cycle_length\n    \n    for count in maintenance_count:\n        print(count)\n\ntrain_maintenance()\n\nmain()", "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_periods = []\n    maintenance_periods = []\n    \n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_periods.append(x_i)\n        maintenance_periods.append(y_i)\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        operations.append((op, k))\n    \n    train_states = {i: {'added': False, 'days_left': 0, 'cycle': 'work'} for i in range(1, n+1)}\n    maintenance_count = 0\n    result = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_states[k]['added'] = True\n            train_states[k]['days_left'] = work_periods[k-1]\n            train_states[k]['cycle'] = 'work'\n        elif op == 2:  # Remove train\n            if train_states[k]['cycle'] == 'maintenance':\n                maintenance_count -= 1\n            train_states[k]['added'] = False\n        \n        # Update train states\n        for i in range(1, n+1):\n            if train_states[i]['added']:\n                train_states[i]['days_left'] -= 1\n                if train_states[i]['days_left'] == 0:\n                    if train_states[i]['cycle'] == 'work':\n                        train_states[i]['cycle'] = 'maintenance'\n                        train_states[i]['days_left'] = maintenance_periods[i-1]\n                        maintenance_count += 1\n                    elif train_states[i]['cycle'] == 'maintenance':\n                        train_states[i]['cycle'] = 'work'\n                        train_states[i]['days_left'] = work_periods[i-1]\n                        maintenance_count -= 1\n        \n        result.append(maintenance_count)\n    \n    for count in result:\n        print(count)\n\ntrain_maintenance()\n\nmain()", "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance_cycles.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # To track the current status of each train model\n    train_status = [None] * n  # None means no train of this model is present\n    \n    # To store the number of trains in maintenance each day\n    maintenance_count = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_cycles[k]\n            train_status[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Count trains in maintenance\n        count = 0\n        for status in train_status:\n            if status is not None:\n                added_day, x_i, y_i = status\n                cycle_length = x_i + y_i\n                days_since_added = day - added_day\n                if days_since_added >= x_i:\n                    # Check if it's in the maintenance period\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        count += 1\n        \n        maintenance_count.append(count)\n    \n    for count in maintenance_count:\n        print(count)\n\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get x_i and y_i for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over m days, keeping track of their maintenance status.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status of each train model (whether it is added and its current cycle position).\",\n        \"Iterate over each of the m days and perform the operation specified (add or remove a train).\",\n        \"For each train addition, start its cycle and update its status.\",\n        \"For each train removal, reset its status.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, check the status of all added trains to determine if they are in maintenance.\",\n        \"Count the number of trains in maintenance and store the result for that day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"Print the count of trains in maintenance for each of the m days.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Initialize data structures to track train statuses.\",\n    \"Simulate the daily operations of adding and removing trains.\",\n    \"Calculate the number of trains in maintenance for each day.\",\n    \"Output the results for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models'\n    Explanation: Refers to different types of trains, each with its own work and maintenance cycle.\n\n    'work for x_i days, then in maintenance for y_i days'\n    Explanation: Each train model has a cycle where it operates for a certain number of days and then goes into maintenance for another set of days.\n\n    'added or removed'\n    Explanation: Trains can be introduced into the system or taken out, affecting their maintenance status.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model'\n    Explanation: There can be no more than one train of each model at any time, meaning the operations are strictly controlled.\n\n    '1 \u2264 n,m \u2264 2 \u22c5 10^5'\n    Explanation: The constraints on the number of train models and days, indicating the potential size of the input.\n\n    '1 \u2264 x_i,y_i \u2264 10^9'\n    Explanation: The constraints on the work and maintenance periods, indicating the potential length of cycles.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan are well-structured and do not require simultaneous implementation. Each step logically follows the previous one, ensuring the correct simulation of train operations and maintenance tracking.\n\n# [edge case]\n    1. Input: 1 1\\n1 1\\n1 1\\n\n       Output: 0\n       Explanation: Only one train is added and it starts working, so no train is in maintenance.\n\n    2. Input: 1 2\\n1 1\\n1 1\\n2 1\\n\n       Output: 0\\n0\n       Explanation: A train is added and then removed the next day, so no train is in maintenance on either day.\n\n    3. Input: 2 3\\n1 1\\n1 1\\n1 1\\n1 2\\n2 1\\n\n       Output: 0\\n0\\n0\n       Explanation: Two trains are added on consecutive days, but both start working, so no train is in maintenance. The first train is removed on the third day.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating the train operations and checking their maintenance status should naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance_cycles.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # To track the current status of each train model\n    train_status = [None] * n  # None means no train of this model is present\n    \n    # To store the number of trains in maintenance each day\n    maintenance_count = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_cycles[k]\n            train_status[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Count trains in maintenance\n        count = 0\n        for status in train_status:\n            if status is not None:\n                added_day, x_i, y_i = status\n                cycle_length = x_i + y_i\n                days_since_added = day - added_day\n                if days_since_added >= x_i:\n                    # Check if it's in the maintenance period\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        count += 1\n        \n        maintenance_count.append(count)\n    \n    for count in maintenance_count:\n        print(count)\n\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 102)"}, "Round_1": {"code": "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance_cycles.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # To track the current status of each train model\n    train_status = [None] * n  # None means no train of this model is present\n    \n    # To store the number of trains in maintenance each day\n    maintenance_count = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_cycles[k]\n            train_status[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Count trains in maintenance\n        count = 0\n        for status in train_status:\n            if status is not None:\n                added_day, x_i, y_i = status\n                cycle_length = x_i + y_i\n                days_since_added = day - added_day\n                if days_since_added >= x_i:\n                    # Check if it's in the maintenance period\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        count += 1\n        \n        maintenance_count.append(count)\n    \n    for count in maintenance_count:\n        print(count)\n\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"input\": \"Raw input data\",\n      \"output\": \"Structured data containing n, m, train model periods, and daily operations\"\n    },\n    {\n      \"description\": \"Track the state of each train model, specifically whether it is currently added and its current cycle (working or maintenance).\",\n      \"input\": \"Structured data from the previous step\",\n      \"output\": \"A data structure that maintains the state of each train model\"\n    },\n    {\n      \"description\": \"Simulate each day's operations, updating the state of the trains and counting the number of trains in maintenance.\",\n      \"input\": \"Daily operations and current state of trains\",\n      \"output\": \"Number of trains in maintenance for each day\"\n    },\n    {\n      \"description\": \"Output the results for each day as specified in the requirement.\",\n      \"input\": \"Number of trains in maintenance for each day\",\n      \"output\": \"Formatted output for each day\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, m, train model periods, and daily operations.\",\n    \"Initialize a data structure to track the state of each train model, including whether it is added and its current cycle.\",\n    \"Iterate over each day's operations:\",\n    \"  - If a train is added, update its state to indicate it is working and track its cycle.\",\n    \"  - If a train is removed, update its state to indicate it is no longer present.\",\n    \"  - For each day, determine the number of trains in maintenance based on their current cycle and update the count.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models'\n    Refers to different types of trains, each with unique work and maintenance cycles.\n\n    'maintenance'\n    A period during which a train is not operational and is being serviced.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model'\n    Indicates that there can be zero or one train of each model at any time.\n\n    'x_i days', 'y_i days'\n    Specifies the duration of work and maintenance periods for each train model.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to updating the state of trains and counting the number of trains in maintenance should be considered simultaneously. Specifically:\n    - \"If a train is added, update its state to indicate it is working and track its cycle.\"\n    - \"For each day, determine the number of trains in maintenance based on their current cycle and update the count.\"\n    These can be implemented in a single loop that processes each day's operations and updates the state and count accordingly.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: Only one train is added and it is working, so no train is in maintenance.\n\n    Input: 2 2\n           1 1\n           1 1\n           1 1\n           1 2\n    Output: 0\n            0\n    Explanation: Both trains are added and working, so no train is in maintenance.\n\n    Input: 1 3\n           1 1\n           1 1\n           2 1\n           1 1\n    Output: 0\n            0\n            0\n    Explanation: The train is removed and then added again, but it is working, so no train is in maintenance.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the train is added and immediately removed or added again. This can be handled by ensuring the state of the train is correctly updated each day, considering its cycle.\n\nYES", "Round_0": {"code": "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to zero-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: (days since added, is in maintenance)\n    train_state = [None] * n\n    maintenance_count = 0\n    \n    result = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            train_state[k] = (0, False)  # Start working\n        elif op == 2:  # Remove train of model k\n            if train_state[k] and train_state[k][1]:  # If it was in maintenance\n                maintenance_count -= 1\n            train_state[k] = None\n        \n        # Update train states\n        for i in range(n):\n            if train_state[i] is not None:\n                days, in_maintenance = train_state[i]\n                x_i, y_i = train_cycles[i]\n                \n                if in_maintenance:\n                    if days + 1 == y_i:\n                        train_state[i] = (0, False)  # Switch to working\n                        maintenance_count -= 1\n                    else:\n                        train_state[i] = (days + 1, True)\n                else:\n                    if days + 1 == x_i:\n                        train_state[i] = (0, True)  # Switch to maintenance\n                        maintenance_count += 1\n                    else:\n                        train_state[i] = (days + 1, False)\n        \n        result.append(maintenance_count)\n    \n    for count in result:\n        print(count)\n\ntrain_maintenance()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 101)"}, "Round_1": {"code": "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to zero-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train model: (days since added, is in maintenance)\n    train_state = [None] * n\n    maintenance_count = 0\n    \n    result = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            train_state[k] = (0, False)  # Start working\n        elif op == 2:  # Remove train of model k\n            if train_state[k] and train_state[k][1]:  # If it was in maintenance\n                maintenance_count -= 1\n            train_state[k] = None\n        \n        # Update train states\n        for i in range(n):\n            if train_state[i] is not None:\n                days, in_maintenance = train_state[i]\n                x_i, y_i = train_cycles[i]\n                \n                if in_maintenance:\n                    if days + 1 == y_i:\n                        train_state[i] = (0, False)  # Switch to working\n                        maintenance_count -= 1\n                    else:\n                        train_state[i] = (days + 1, True)\n                else:\n                    if days + 1 == x_i:\n                        train_state[i] = (0, True)  # Switch to maintenance\n                        maintenance_count += 1\n                    else:\n                        train_state[i] = (days + 1, False)\n        \n        result.append(maintenance_count)\n    \n    for count in result:\n        print(count)\n\ntrain_maintenance()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"output\": \"A structured representation of the input data, including train models' work and maintenance periods and daily operations.\"\n    },\n    {\n      \"description\": \"Implement a data structure to track the state of each train model, specifically whether it is currently added and its current cycle (working or maintenance).\",\n      \"output\": \"A data structure that can efficiently update and query the state of each train model.\"\n    },\n    {\n      \"description\": \"Simulate each day's operations, updating the state of the trains based on the operation (add or remove) and the current day.\",\n      \"output\": \"An updated state of the train models after each day's operation.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day based on the current state of all train models.\",\n      \"output\": \"A list of integers representing the number of trains in maintenance for each day.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of train models, number of days, work and maintenance periods for each model, and daily operations.\",\n    \"Initialize a data structure to keep track of the state of each train model, including whether it is added and its current cycle.\",\n    \"Iterate over each day's operations:\",\n    \"  - If a train is added, update its state to reflect the start of its work cycle.\",\n    \"  - If a train is removed, update its state to reflect its removal.\",\n    \"  - For each train model, update its cycle state (working or maintenance) based on the current day.\",\n    \"Calculate the number of trains in maintenance for the current day and store the result.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models': Refers to different types of trains, each with unique work and maintenance cycles.\n    'work for x_i days': The period during which a train is operational.\n    'maintenance for y_i days': The period during which a train is not operational and undergoing maintenance.\n    Explanation: The requirement involves managing the operational and maintenance cycles of different train models over a series of days, with trains being added or removed.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': Indicates that there can be zero or one train of each model at any time.\n    'x_i days', 'y_i days': Specifies the duration of work and maintenance periods for each train model.\n    Explanation: These phrases define the constraints and durations for train operations and maintenance.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to updating the state of trains and calculating the number of trains in maintenance should be considered simultaneously. Specifically:\n    - \"If a train is added, update its state to reflect the start of its work cycle.\"\n    - \"For each train model, update its cycle state (working or maintenance) based on the current day.\"\n    These steps can be implemented in a single code block where the state of each train is updated based on the day's operation and the current cycle.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: Only one train model is added and it starts working immediately, so no train is in maintenance.\n\n    Input: 2 2\n           1 1\n           1 1\n           1 1\n           1 2\n    Output: 0\n            0\n    Explanation: Both trains are added and start working immediately, so no train is in maintenance.\n\n    Input: 1 3\n           1 1\n           1 1\n           2 1\n           1 1\n    Output: 0\n            0\n            0\n    Explanation: A train is added, removed, and added again, but it starts working immediately each time, so no train is in maintenance.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where trains are added and removed on the same day or have very short cycles.\n    Code for handling the edge case:\n", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State of each train model\n    train_state = [None] * n  # None means no train, otherwise it stores the day it was added\n    maintenance_count = 0\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_state[k] = day\n        elif op == 2:  # Remove train\n            train_state[k] = None\n        \n        # Calculate the number of trains in maintenance\n        maintenance_count = 0\n        for i in range(n):\n            if train_state[i] is not None:\n                x_i, y_i = work_maintenance[i]\n                days_since_added = day - train_state[i]\n                cycle_length = x_i + y_i\n                if days_since_added >= x_i:\n                    # Check if it's in the maintenance period\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        maintenance_count += 1\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 103)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State of each train model\n    train_state = [None] * n  # None means no train, otherwise it stores the day it was added\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_state[k] = day\n        elif op == 2:  # Remove train\n            train_state[k] = None\n        \n        # Calculate the number of trains in maintenance\n        maintenance_count = 0\n        for i in range(n):\n            if train_state[i] is not None:\n                x_i, y_i = work_maintenance[i]\n                days_since_added = day - train_state[i]\n                cycle_length = x_i + y_i\n                if days_since_added >= x_i:\n                    # Check if it's in the maintenance period\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        maintenance_count += 1\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), and the list of train model parameters (x_i, y_i) and operations (op, k).\",\n      \"steps\": [\n        \"Read the first line to get integers n and m.\",\n        \"Read the next n lines to get pairs of integers x_i and y_i for each train model.\",\n        \"Read the next m lines to get pairs of integers op and k for each day's operation.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains and track their maintenance status over m days.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of active trains and their maintenance cycles.\",\n        \"Iterate over each day's operation:\",\n        \"If op = 1, add the train of model k and start its cycle.\",\n        \"If op = 2, remove the train of model k and stop its cycle.\",\n        \"For each day, update the maintenance status of all active trains.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, count the number of trains currently in their maintenance period.\",\n        \"Ensure that trains removed on a given day are not counted as in maintenance.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"Print the count of trains in maintenance for each of the m days.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Initialize data structures to track train status and maintenance cycles.\",\n    \"Simulate the daily operations of adding and removing trains.\",\n    \"Update and track the maintenance status of trains each day.\",\n    \"Calculate and output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models'\n    Explanation: Refers to different types of trains, each with its own maintenance and operational cycle.\n\n    'maintenance cycle'\n    Explanation: The period during which a train is not operational and is undergoing maintenance. This cycle alternates with the operational period.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model'\n    Explanation: Indicates that there can be zero or one train of each model at any given time, but not more than one.\n\n    'x_i days', 'y_i days'\n    Explanation: 'x_i days' refers to the number of days a train is operational, and 'y_i days' refers to the number of days it is in maintenance. These are used to determine the train's cycle.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to simulating the addition and removal of trains and updating their maintenance status should be implemented simultaneously. Specifically:\n    - \"If op = 1, add the train of model k and start its cycle.\"\n    - \"If op = 2, remove the train of model k and stop its cycle.\"\n    - \"For each day, update the maintenance status of all active trains.\"\n    These steps can be handled in a single loop that processes each day's operation and updates the status of all trains accordingly.\n\n# [edge case]\n    1. Input: 1 1\\n1 1\\n1 1\\nOutput: 0\n       Explanation: Only one train is added and it is operational on the first day, so no train is in maintenance.\n\n    2. Input: 2 2\\n1 1\\n1 1\\n1 1\\n2 1\\nOutput: 0\\n0\n       Explanation: A train is added and then removed the next day, so no train is in maintenance on either day.\n\n    3. Input: 1 2\\n1 1\\n1 1\\n1 1\\n1 1\\nOutput: 0\\n1\n       Explanation: A train is added and is operational on the first day, then enters maintenance on the second day.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the maintenance status is updated correctly each day, and that trains removed on a given day are not counted as in maintenance. This can be handled by maintaining a data structure that", "Round_0": {"code": "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_cycles.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to zero-based index\n        index += 1\n        operations.append((op, k))\n    \n    active_trains = {}\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            active_trains[k] = (day, x_i, y_i)\n        \n        elif op == 2:  # Remove train of model k\n            if k in active_trains:\n                del active_trains[k]\n        \n        # Update maintenance count for the current day\n        for model, (start_day, x_i, y_i) in active_trains.items():\n            cycle_length = x_i + y_i\n            days_since_start = day - start_day\n            if days_since_start >= x_i and (days_since_start - x_i) % cycle_length < y_i:\n                maintenance_count[day] += 1\n    \n    for count in maintenance_count:\n        print(count)\n\ntrain_maintenance()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_cycles.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to zero-based index\n        index += 1\n        operations.append((op, k))\n    \n    active_trains = {}\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            active_trains[k] = (day, x_i, y_i)\n        \n        elif op == 2:  # Remove train of model k\n            if k in active_trains:\n                del active_trains[k]\n        \n        # Update maintenance count for the current day\n        for model, (start_day, x_i, y_i) in active_trains.items():\n            cycle_length = x_i + y_i\n            days_since_start = day - start_day\n            if days_since_start >= x_i and (days_since_start - x_i) % cycle_length < y_i:\n                maintenance_count[day] += 1\n    \n    for count in maintenance_count:\n        print(count)\n\ntrain_maintenance()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), and the list of train operations.\",\n      \"steps\": [\n        \"Read the first line to get integers n and m.\",\n        \"Read the next n lines to get pairs of integers (x_i, y_i) representing the work and maintenance periods for each train model.\",\n        \"Read the next m lines to get pairs of integers (op, k) representing the operations for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the train operations over m days to track the number of trains in maintenance each day.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current state of each train model (whether it is added or removed).\",\n        \"For each day, update the state of the train models based on the operation (add or remove).\",\n        \"Calculate the number of trains in maintenance for each day based on the current state and the maintenance schedule (x_i, y_i).\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, print the calculated number of trains in maintenance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, m, train model schedules, and daily operations.\",\n    \"Initialize a data structure to track the state of each train model.\",\n    \"Iterate over each day, updating the state of train models based on the operation (add or remove).\",\n    \"For each day, calculate the number of trains in maintenance using the current state and maintenance schedule.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models': Refers to different types of trains, each with its own schedule for working and maintenance.\n    'maintenance': The period during which a train is not operational and is being serviced.\n    Explanation: The requirement involves tracking the number of trains in maintenance each day based on their operational and maintenance schedules.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': Indicates that there can be zero or one train of each model at any time.\n    'x_i days': Refers to the number of days a train works before going into maintenance.\n    'y_i days': Refers to the number of days a train is in maintenance before it resumes working.\n    Explanation: These phrases define the operational cycle of each train model, which is crucial for determining maintenance status.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for updating the state of train models and calculating the number of trains in maintenance should be considered simultaneously.\n    Explanation: When a train is added or removed, its state changes, and this directly affects the calculation of trains in maintenance. These operations should be handled in a single code block to ensure accurate tracking.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: Only one train is added and it starts working immediately, so no train is in maintenance.\n\n    Input: 2 2\n           1 1\n           1 1\n           1 1\n           1 2\n    Output: 0\n            0\n    Explanation: Both trains are added and start working immediately, so no train is in maintenance.\n\n    Input: 2 3\n           1 1\n           1 1\n           1 1\n           2 1\n           1 2\n    Output: 0\n            0\n            0\n    Explanation: Train 1 is added and removed before it goes into maintenance, and train 2 is added and starts working immediately.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: The code should ensure that trains are not counted as in maintenance on the day they are removed. This requires checking the operation type and adjusting the maintenance count accordingly.\n\nYES", "Round_0": {"code": "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_models = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_models.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        operations.append((op, k))\n    \n    # State of trains: 0 means not present, positive means days since added\n    train_state = [0] * (n + 1)\n    maintenance_count = 0\n    \n    result = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_state[k] = 1\n        elif op == 2:  # Remove train of model k\n            if train_state[k] > train_models[k-1][0]:\n                maintenance_count -= 1\n            train_state[k] = 0\n        \n        # Update maintenance count\n        for i in range(1, n + 1):\n            if train_state[i] > 0:\n                x_i, y_i = train_models[i-1]\n                if train_state[i] > x_i and (train_state[i] - x_i) % (x_i + y_i) < y_i:\n                    maintenance_count += 1\n                train_state[i] += 1\n        \n        result.append(maintenance_count)\n    \n    for res in result:\n        print(res)\n\ntrain_maintenance()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_models = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_models.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        operations.append((op, k))\n    \n    # State of trains: 0 means not present, positive means days since added\n    train_state = [0] * (n + 1)\n    \n    result = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_state[k] = 1\n        elif op == 2:  # Remove train of model k\n            train_state[k] = 0\n        \n        maintenance_count = 0\n        \n        # Calculate maintenance count\n        for i in range(1, n + 1):\n            if train_state[i] > 0:\n                x_i, y_i = train_models[i-1]\n                if train_state[i] > x_i and (train_state[i] - x_i) % (x_i + y_i) < y_i:\n                    maintenance_count += 1\n                train_state[i] += 1\n        \n        result.append(maintenance_count)\n    \n    for res in result:\n        print(res)\n\ntrain_maintenance()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"output\": \"A structured data format containing n, m, a list of tuples for each train model's work and maintenance periods, and a list of operations for each day.\"\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days, keeping track of which trains are currently in operation and which are in maintenance.\",\n      \"output\": \"A data structure that maintains the state of each train model (whether it is in operation or maintenance) for each day.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day based on the current state of all train models.\",\n      \"output\": \"A list of integers where each integer represents the number of trains in maintenance for the corresponding day.\"\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day in the required format.\",\n      \"output\": \"Print the list of integers, each on a new line.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, m, the work and maintenance periods for each train model, and the operations for each day.\",\n    \"Initialize a data structure to keep track of the state of each train model (whether it is in operation or maintenance) and the current day.\",\n    \"Iterate over each day's operation:\",\n    \"  - If a train is added, calculate its initial state (working or maintenance) and update the data structure.\",\n    \"  - If a train is removed, update the data structure to reflect its removal.\",\n    \"  - For each day, determine the number of trains in maintenance based on the current state of all train models.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models': Refers to different types of trains, each with unique work and maintenance cycles.\n    'maintenance': A period when the train is not operational and undergoing maintenance.\n    Explanation: The requirement involves managing train models with specific work and maintenance cycles, and determining how many trains are in maintenance each day.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': Indicates that there can be zero or one train of each model at any time.\n    'x_i days', 'y_i days': Specifies the duration of work and maintenance periods for each train model.\n    Explanation: The requirement specifies the duration of work and maintenance cycles for each train model, which affects the calculation of trains in maintenance.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to adding and removing trains should be considered simultaneously:\n    \"If a train is added, calculate its initial state (working or maintenance) and update the data structure.\"\n    \"If a train is removed, update the data structure to reflect its removal.\"\n    These steps can be implemented using an if-else statement to handle the addition and removal of trains.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: Only one train is added and it starts working, so no train is in maintenance.\n\n    Input: 2 2\n           1 1\n           1 1\n           1 1\n           1 2\n    Output: 0\n            0\n    Explanation: Two trains are added, both start working, so no train is in maintenance.\n\n    Input: 1 2\n           1 1\n           1 1\n           2 1\n    Output: 0\n            0\n    Explanation: A train is added and then removed, so no train is in maintenance.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling the edge case:\n    ```python\n    def handle_edge_cases(n, m, train_periods, operations):\n        maintenance_count = [0] * m\n        train_states = {}\n        \n        for day in range(m):\n            op, k = operations[day]\n            if op == 1:  # Add train\n                train_states[k] = 'working'\n            elif", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_periods.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking\n    train_states = {}\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        x_i, y_i = train_periods[k]\n        \n        if op == 1:  # Add train\n            # Calculate the initial state\n            train_states[k] = day + x_i  # Next maintenance day\n        elif op == 2:  # Remove train\n            if k in train_states:\n                del train_states[k]\n        \n        # Count trains in maintenance\n        count = 0\n        for model, next_maintenance_day in train_states.items():\n            if day >= next_maintenance_day:\n                # Calculate the cycle position\n                cycle_length = train_periods[model][0] + train_periods[model][1]\n                days_since_start = day - (next_maintenance_day - train_periods[model][0])\n                if days_since_start % cycle_length >= train_periods[model][0]:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 103)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_periods.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking\n    train_states = {}\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        x_i, y_i = train_periods[k]\n        \n        if op == 1:  # Add train\n            # Calculate the initial state\n            train_states[k] = day + x_i  # Next maintenance day\n        elif op == 2:  # Remove train\n            if k in train_states:\n                del train_states[k]\n        \n        # Count trains in maintenance\n        count = 0\n        for model, next_maintenance_day in train_states.items():\n            if day >= next_maintenance_day:\n                # Calculate the cycle position\n                cycle_length = train_periods[model][0] + train_periods[model][1]\n                days_since_start = day - (next_maintenance_day - train_periods[model][0])\n                if days_since_start % cycle_length >= train_periods[model][0]:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), and the list of train operation days (x_i, y_i) for each model.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get x_i and y_i for each train model.\"\n      ]\n    },\n    {\n      \"description\": \"Track the state of each train model over the m days based on operations (add or remove).\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current state of each train model (running or maintenance).\",\n        \"Iterate over the m operations, updating the state of the train model based on whether it is added or removed.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, check the state of all train models.\",\n        \"Count the number of trains that are in maintenance and store the result for that day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each of the m days.\",\n      \"steps\": [\n        \"Print the stored results for each day.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, m, and the list of (x_i, y_i) for each train model.\",\n    \"Initialize a data structure to track the state of each train model.\",\n    \"Iterate over the m operations, updating the state of the train models.\",\n    \"For each day, calculate the number of trains in maintenance.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train maintenance'\n    Explanation: This refers to the period when a train is not operational and is undergoing maintenance. The requirement is to track how many trains are in this state each day.\n\n    'model'\n    Explanation: Each train has a specific model, and the department can have at most one train of each model at any time.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model'\n    Explanation: This means that for each model, there can be zero or one train present in the department at any given time.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to updating the state of train models based on operations (add or remove) should be implemented simultaneously. Specifically, when iterating over the m operations, the state of the train model should be updated in one code block to ensure accurate tracking of train states.\n\n# [edge case] \n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: Only one train is added and it is running, not in maintenance.\n\n    Input: 2 2\n           1 1\n           1 1\n           1 1\n           2 1\n    Output: 0\n            0\n    Explanation: The train is added and then removed, so it is never in maintenance.\n\n    Input: 3 3\n           1 1\n           1 1\n           1 1\n           1 1\n           1 2\n           2 1\n    Output: 0\n            0\n            0\n    Explanation: The train of model 1 is added, then model 2 is added, and model 1 is removed. No train is in maintenance.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the logic correctly handles the transition between running and maintenance states, and accurately tracks when a train is removed.\n\n    ```python\n    # Example code snippet for handling edge cases\n    def update_train_state(train_states, model, operation, x_i, y_i, current_day):\n        if operation == 1:  # Add train\n            train_states[model] = {'state': 'running', 'start_day': current_day, 'x_i': x", "Round_0": {"code": "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_models = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_models.append((x_i, y_i))\n    \n    train_states = {}\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1\n        index += 1\n        \n        if op == 1:  # Add train\n            x_i, y_i = train_models[k]\n            train_states[k] = {'state': 'running', 'start_day': day, 'x_i': x_i, 'y_i': y_i}\n        elif op == 2:  # Remove train\n            if k in train_states:\n                del train_states[k]\n        \n        # Calculate maintenance count for the current day\n        for model, state_info in train_states.items():\n            x_i = state_info['x_i']\n            y_i = state_info['y_i']\n            start_day = state_info['start_day']\n            cycle_length = x_i + y_i\n            days_since_start = day - start_day\n            \n            if days_since_start >= x_i and (days_since_start - x_i) % cycle_length < y_i:\n                maintenance_count[day] += 1\n    \n    for count in maintenance_count:\n        print(count)\n\ntrain_maintenance()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_models = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_models.append((x_i, y_i))\n    \n    train_states = {}\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1\n        index += 1\n        \n        if op == 1:  # Add train\n            x_i, y_i = train_models[k]\n            train_states[k] = {'state': 'running', 'start_day': day, 'x_i': x_i, 'y_i': y_i}\n        elif op == 2:  # Remove train\n            if k in train_states:\n                del train_states[k]\n        \n        # Calculate maintenance count for the current day\n        for model, state_info in train_states.items():\n            x_i = state_info['x_i']\n            y_i = state_info['y_i']\n            start_day = state_info['start_day']\n            cycle_length = x_i + y_i\n            days_since_start = day - start_day\n            \n            if days_since_start >= x_i and (days_since_start - x_i) % cycle_length < y_i:\n                maintenance_count[day] += 1\n    \n    for count in maintenance_count:\n        print(count)\n\ntrain_maintenance()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the working and maintenance periods for each train model, and the operations for each day.\",\n      \"output\": \"A structured representation of the input data, including train models' working and maintenance periods and daily operations.\"\n    },\n    {\n      \"description\": \"Track the state of each train model, specifically whether it is currently added or removed, and if added, whether it is in the working or maintenance phase.\",\n      \"output\": \"A data structure that maintains the current state of each train model.\"\n    },\n    {\n      \"description\": \"Simulate each day's operations, updating the state of the trains based on the operation (add or remove) and the current phase (working or maintenance).\",\n      \"output\": \"An updated state of the trains after each day's operation.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day based on the current state of the trains.\",\n      \"output\": \"A list of integers representing the number of trains in maintenance for each day.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of train models, number of days, working and maintenance periods for each train model, and the operations for each day.\",\n    \"Initialize a data structure to track the state of each train model, including whether it is added or removed and its current phase.\",\n    \"Iterate over each day's operations:\",\n    \"  - If a train is added, update its state to indicate it is in the working phase and track the start day.\",\n    \"  - If a train is removed, update its state to indicate it is no longer present.\",\n    \"  - For each train currently added, determine if it is in the working or maintenance phase based on the elapsed days since it was added.\",\n    \"  - Count the number of trains in the maintenance phase for the current day.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models', 'working and maintenance periods', 'operations'\n    Explanation: The requirement involves managing different train models, each with specific working and maintenance periods. Operations include adding or removing trains, and the task is to track how many trains are in maintenance each day.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': This means there can be zero or one train of each model at any time.\n    'x_i days', 'y_i days': These represent the working and maintenance periods for each train model, respectively.\n    '1 \u2264 n,m \u2264 2 \u22c5 10^5', '1 \u2264 x_i,y_i \u2264 10^9': These are constraints on the number of models, days, and the duration of working and maintenance periods.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to updating the state of trains and counting the number of trains in maintenance should be implemented simultaneously. Specifically:\n    - \"If a train is added, update its state to indicate it is in the working phase and track the start day.\"\n    - \"For each train currently added, determine if it is in the working or maintenance phase based on the elapsed days since it was added.\"\n    - \"Count the number of trains in the maintenance phase for the current day.\"\n    These steps can be combined in a loop that processes each day's operations and updates the state and count accordingly.\n\n# [edge case]\n    1. Input: 1 1\\n1 1\\n1 1\\n\n       Output: 0\n       Explanation: Only one train is added and it is in the working phase on the first day, so no trains are in maintenance.\n    2. Input: 1 2\\n1 1\\n1 1\\n2 1\\n\n       Output: 0\\n0\n       Explanation: A train is added on the first day and removed on the second day. It never enters maintenance.\n    3. Input: 2 3\\n1 1\\n1 1\\n1 1\\n1 2\\n2 1\\n\n       Output: 0\\n0\\n0\n       Explanation: Two trains are added on consecutive days, but both are in the working phase on their respective days.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of tracking the state of each train", "Round_0": {"code": "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_periods.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking\n    train_states = [None] * n  # None means no train, otherwise store the start day\n    maintenance_count = 0\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_states[k] = day\n        elif op == 2:  # Remove train\n            train_states[k] = None\n        \n        # Calculate maintenance count\n        maintenance_count = 0\n        for model in range(n):\n            start_day = train_states[model]\n            if start_day is not None:\n                x_i, y_i = train_periods[model]\n                elapsed_days = day - start_day\n                cycle_length = x_i + y_i\n                if elapsed_days >= x_i and (elapsed_days % cycle_length) >= x_i:\n                    maintenance_count += 1\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\ntrain_maintenance()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_periods.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking\n    train_states = [None] * n  # None means no train, otherwise store the start day\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_states[k] = day\n        elif op == 2:  # Remove train\n            train_states[k] = None\n        \n        # Calculate maintenance count\n        maintenance_count = 0\n        for model in range(n):\n            start_day = train_states[model]\n            if start_day is not None:\n                x_i, y_i = train_periods[model]\n                elapsed_days = day - start_day\n                cycle_length = x_i + y_i\n                if elapsed_days >= x_i and (elapsed_days % cycle_length) >= x_i:\n                    maintenance_count += 1\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\ntrain_maintenance()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), and the list of train model specifications (x_i, y_i).\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the list of tuples (x_i, y_i) for each train model.\"\n      ]\n    },\n    {\n      \"description\": \"Track the state of each train model over the m days based on operations (add or remove).\",\n      \"steps\": [\n        \"Initialize a dictionary to keep track of the current state of each train model (added or removed).\",\n        \"Iterate over the m operations, updating the state of the train models accordingly.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, check the state of each train model.\",\n        \"Determine if a train is in maintenance based on its cycle (x_i days working, y_i days maintenance).\",\n        \"Count the number of trains in maintenance and store the result for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"Print the count of trains in maintenance for each of the m days.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, m, and the list of train model specifications (x_i, y_i).\",\n    \"Initialize a data structure to track the state of each train model.\",\n    \"Iterate over the m operations to update the state of train models.\",\n    \"For each day, calculate the number of trains in maintenance based on their cycles.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train model': Refers to the different types of trains, each with its own working and maintenance cycle.\n    'maintenance cycle': The period during which a train is not operational and is undergoing maintenance.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': Indicates that there can be zero or one train of each model at any time.\n    'x_i days', 'y_i days': Specifies the duration of working and maintenance periods for each train model.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for tracking the state of each train model and calculating the number of trains in maintenance should be considered simultaneously. Specifically, updating the state of train models and checking their maintenance status can be done in a single loop over the operations.\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: Only one train is added and it starts working immediately, so no train is in maintenance.\n\n    Input: 2 2\n           1 1\n           1 1\n           1 1\n           1 2\n    Output: 0\n            0\n    Explanation: Both trains are added and start working immediately, so no train is in maintenance.\n\n    Input: 1 3\n           1 1\n           1 1\n           1 1\n           2 1\n    Output: 0\n            0\n            0\n    Explanation: The train is added, works, and then is removed before entering maintenance.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where trains are added and removed before entering maintenance.\n    ```python\n    # Initialize a dictionary to track the current state and cycle of each train model\n    train_state = {}\n    maintenance_count = []\n\n    for day in range(m):\n        op, k = operations[day]\n        if op == 1:  # Add train\n            train_state[k] = 0  # Start working cycle\n        elif op == 2:  # Remove train\n            if k in train_state:\n                del train_state[k]  # Remove train from tracking\n\n        # Calculate maintenance count\n        count = 0\n        for model in train_state:\n            cycle_position = train_state[model]\n            if cycle_position >=", "Round_0": {"code": "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_specs = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_specs.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        operations.append((op, k))\n    \n    train_state = {}\n    maintenance_count = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        if op == 1:  # Add train\n            train_state[k] = 0  # Start working cycle\n        elif op == 2:  # Remove train\n            if k in train_state:\n                del train_state[k]  # Remove train from tracking\n        \n        # Calculate maintenance count\n        count = 0\n        for model in train_state:\n            x_i, y_i = train_specs[model - 1]\n            cycle_position = train_state[model]\n            if cycle_position >= x_i:\n                count += 1\n        \n        maintenance_count.append(count)\n        \n        # Update train states\n        for model in train_state:\n            x_i, y_i = train_specs[model - 1]\n            cycle_position = train_state[model]\n            cycle_length = x_i + y_i\n            train_state[model] = (cycle_position + 1) % cycle_length\n    \n    for count in maintenance_count:\n        print(count)\n\ntrain_maintenance()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 96)"}, "Round_1": {"code": "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_specs = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_specs.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        operations.append((op, k))\n    \n    train_state = {}\n    maintenance_count = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        if op == 1:  # Add train\n            train_state[k] = 0  # Start working cycle\n        elif op == 2:  # Remove train\n            if k in train_state:\n                del train_state[k]  # Remove train from tracking\n        \n        # Calculate maintenance count\n        count = 0\n        for model in train_state:\n            x_i, y_i = train_specs[model - 1]\n            cycle_position = train_state[model]\n            if cycle_position >= x_i:\n                count += 1\n        \n        maintenance_count.append(count)\n        \n        # Update train states\n        for model in train_state:\n            x_i, y_i = train_specs[model - 1]\n            cycle_position = train_state[model]\n            cycle_length = x_i + y_i\n            train_state[model] = (cycle_position + 1) % cycle_length\n    \n    for count in maintenance_count:\n        print(count)\n\ntrain_maintenance()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"output\": \"A structured representation of the input data, including train models' work and maintenance periods and daily operations.\"\n    },\n    {\n      \"description\": \"Track the state of each train model over the days, including whether it is currently added, in work, or in maintenance.\",\n      \"output\": \"A data structure that maintains the current state of each train model.\"\n    },\n    {\n      \"description\": \"Simulate each day's operations, updating the state of the trains and counting the number of trains in maintenance.\",\n      \"output\": \"A list of integers representing the number of trains in maintenance for each day.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse Input\",\n      \"details\": \"Read the input values and store them in appropriate data structures. This includes the number of train models, number of days, work and maintenance periods for each model, and the list of operations for each day.\"\n    },\n    {\n      \"step\": \"Initialize State\",\n      \"details\": \"Create a data structure to track the state of each train model, including whether it is added, and if so, its current cycle (work or maintenance) and the remaining days in that cycle.\"\n    },\n    {\n      \"step\": \"Process Daily Operations\",\n      \"details\": \"Iterate over each day's operations. For each operation, update the state of the relevant train model. If a train is added, set its initial state to working. If a train is removed, clear its state. Update the cycle states for all trains and count how many are in maintenance.\"\n    },\n    {\n      \"step\": \"Output Results\",\n      \"details\": \"For each day, output the number of trains that are in maintenance based on the updated states.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models': Refers to different types of trains, each with unique work and maintenance cycles.\n    'work for x_i days': The period during which a train is operational.\n    'maintenance for y_i days': The period during which a train is not operational and undergoing maintenance.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model': Indicates that there can be zero or one train of each model at any time.\n    'works for x_i days': Specifies the duration a train is operational.\n    'maintenance for y_i days': Specifies the duration a train is in maintenance.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Initialize State\" and \"Process Daily Operations\" should be considered simultaneously. When a train is added, its state should be initialized and immediately processed to determine its current cycle (work or maintenance).\n\n# [edge case]\n    Input: 1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: On the first day, a train is added and is in work mode, so no train is in maintenance.\n\n    Input: 1 2\n           1 1\n           1 1\n           2 1\n    Output: 0\n    Explanation: On the first day, a train is added and is in work mode. On the second day, the train is removed, so no train is in maintenance.\n\n    Input: 2 3\n           1 1\n           1 1\n           1 1\n           1 2\n           2 1\n    Output: 0\n            0\n            0\n    Explanation: On the first day, a train of model 1 is added and is in work mode. On the second day, a train of model 2 is added and is in work mode. On the third day, the train of model 1 is removed, so no train is in maintenance.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    ```python\n    # Initialize a dictionary to track the state of each train model\n    train_states = {i: {'added': False, 'days_left': 0, 'cycle': 'work'} for i in range(1, n+1)}\n\n    # Function to update train states\n    def update_train_states", "Round_0": {"code": "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_periods = []\n    maintenance_periods = []\n    \n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_periods.append(x_i)\n        maintenance_periods.append(y_i)\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        operations.append((op, k))\n    \n    train_states = {i: {'added': False, 'days_left': 0, 'cycle': 'work'} for i in range(1, n+1)}\n    maintenance_count = 0\n    result = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_states[k]['added'] = True\n            train_states[k]['days_left'] = work_periods[k-1]\n            train_states[k]['cycle'] = 'work'\n        elif op == 2:  # Remove train\n            if train_states[k]['cycle'] == 'maintenance':\n                maintenance_count -= 1\n            train_states[k]['added'] = False\n        \n        # Update train states\n        for i in range(1, n+1):\n            if train_states[i]['added']:\n                train_states[i]['days_left'] -= 1\n                if train_states[i]['days_left'] == 0:\n                    if train_states[i]['cycle'] == 'work':\n                        train_states[i]['cycle'] = 'maintenance'\n                        train_states[i]['days_left'] = maintenance_periods[i-1]\n                        maintenance_count += 1\n                    elif train_states[i]['cycle'] == 'maintenance':\n                        train_states[i]['cycle'] = 'work'\n                        train_states[i]['days_left'] = work_periods[i-1]\n                        maintenance_count -= 1\n        \n        result.append(maintenance_count)\n    \n    for count in result:\n        print(count)\n\ntrain_maintenance()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_periods = []\n    maintenance_periods = []\n    \n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_periods.append(x_i)\n        maintenance_periods.append(y_i)\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        operations.append((op, k))\n    \n    train_states = {i: {'added': False, 'days_left': 0, 'cycle': 'work'} for i in range(1, n+1)}\n    maintenance_count = 0\n    result = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_states[k]['added'] = True\n            train_states[k]['days_left'] = work_periods[k-1]\n            train_states[k]['cycle'] = 'work'\n        elif op == 2:  # Remove train\n            if train_states[k]['cycle'] == 'maintenance':\n                maintenance_count -= 1\n            train_states[k]['added'] = False\n        \n        # Update train states\n        for i in range(1, n+1):\n            if train_states[i]['added']:\n                train_states[i]['days_left'] -= 1\n                if train_states[i]['days_left'] == 0:\n                    if train_states[i]['cycle'] == 'work':\n                        train_states[i]['cycle'] = 'maintenance'\n                        train_states[i]['days_left'] = maintenance_periods[i-1]\n                        maintenance_count += 1\n                    elif train_states[i]['cycle'] == 'maintenance':\n                        train_states[i]['cycle'] = 'work'\n                        train_states[i]['days_left'] = work_periods[i-1]\n                        maintenance_count -= 1\n        \n        result.append(maintenance_count)\n    \n    for count in result:\n        print(count)\n\ntrain_maintenance()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get x_i and y_i for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over m days, keeping track of their maintenance status.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status of each train model (whether it is added and its current cycle position).\",\n        \"Iterate over each of the m days and perform the operation specified (add or remove a train).\",\n        \"For each train addition, start its cycle and update its status.\",\n        \"For each train removal, reset its status.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, check the status of all added trains to determine if they are in maintenance.\",\n        \"Count the number of trains in maintenance and store the result for that day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"Print the count of trains in maintenance for each of the m days.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Initialize data structures to track train statuses.\",\n    \"Simulate the daily operations of adding and removing trains.\",\n    \"Calculate the number of trains in maintenance for each day.\",\n    \"Output the results for each day.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'train models'\n    Explanation: Refers to different types of trains, each with its own work and maintenance cycle.\n\n    'work for x_i days, then in maintenance for y_i days'\n    Explanation: Each train model has a cycle where it operates for a certain number of days and then goes into maintenance for another set of days.\n\n    'added or removed'\n    Explanation: Trains can be introduced into the system or taken out, affecting their maintenance status.\n\n# [phrase showing quantity relationship]\n    'at most one train of each model'\n    Explanation: There can be no more than one train of each model at any time, meaning the operations are strictly controlled.\n\n    '1 \u2264 n,m \u2264 2 \u22c5 10^5'\n    Explanation: The constraints on the number of train models and days, indicating the potential size of the input.\n\n    '1 \u2264 x_i,y_i \u2264 10^9'\n    Explanation: The constraints on the work and maintenance periods, indicating the potential length of cycles.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan are well-structured and do not require simultaneous implementation. Each step logically follows the previous one, ensuring the correct simulation of train operations and maintenance tracking.\n\n# [edge case]\n    1. Input: 1 1\\n1 1\\n1 1\\n\n       Output: 0\n       Explanation: Only one train is added and it starts working, so no train is in maintenance.\n\n    2. Input: 1 2\\n1 1\\n1 1\\n2 1\\n\n       Output: 0\\n0\n       Explanation: A train is added and then removed the next day, so no train is in maintenance on either day.\n\n    3. Input: 2 3\\n1 1\\n1 1\\n1 1\\n1 2\\n2 1\\n\n       Output: 0\\n0\\n0\n       Explanation: Two trains are added on consecutive days, but both start working, so no train is in maintenance. The first train is removed on the third day.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating the train operations and checking their maintenance status should naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance_cycles.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # To track the current status of each train model\n    train_status = [None] * n  # None means no train of this model is present\n    \n    # To store the number of trains in maintenance each day\n    maintenance_count = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_cycles[k]\n            train_status[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Count trains in maintenance\n        count = 0\n        for status in train_status:\n            if status is not None:\n                added_day, x_i, y_i = status\n                cycle_length = x_i + y_i\n                days_since_added = day - added_day\n                if days_since_added >= x_i:\n                    # Check if it's in the maintenance period\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        count += 1\n        \n        maintenance_count.append(count)\n    \n    for count in maintenance_count:\n        print(count)\n\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 102)"}, "Round_1": {"code": "def train_maintenance():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance_cycles.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # To track the current status of each train model\n    train_status = [None] * n  # None means no train of this model is present\n    \n    # To store the number of trains in maintenance each day\n    maintenance_count = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_cycles[k]\n            train_status[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Count trains in maintenance\n        count = 0\n        for status in train_status:\n            if status is not None:\n                added_day, x_i, y_i = status\n                cycle_length = x_i + y_i\n                days_since_added = day - added_day\n                if days_since_added >= x_i:\n                    # Check if it's in the maintenance period\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        count += 1\n        \n        maintenance_count.append(count)\n    \n    for count in maintenance_count:\n        print(count)\n\n"}}], "scores": [], "pass_results": [true, false, true, true, false, true, false, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 607, "prompt": "Kawasiro Nitori is skilled in engineering. Hence she has been selected to assist in train maintenance.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment. In the beginning, there are no trains, at each of the following m days, one train will be added, or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to simplify management, Nitori wants you to help her determine the number of trains in maintenance each day.\n\nOn a day a train is removed, it is not counted as in maintenance.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.", "examples": "\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.", "mutate_method": "rephrase_one", "save_node": true, "parent_index": 11}
