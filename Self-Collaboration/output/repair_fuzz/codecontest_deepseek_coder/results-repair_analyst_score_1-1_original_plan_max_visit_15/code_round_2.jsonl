{"name": "1575_M. Managing Telephone Poles", "description": "Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "tags": ["data structures", "geometry"], "difficulty": 20, "id": 1575, "sample_io": [{"input": "2 2\n101\n000\n000\n", "output": ["18\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n00100\n00010\n", "output": ["36\n"]}], "test_list": [{"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["182\n"]}, {"input": "0 0\n1\n", "output": ["0\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["181\n"]}, {"input": "2 2\n101\n010\n000\n", "output": ["8\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n00100\n00110\n", "output": ["33\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["183\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n10100\n00110\n", "output": ["25\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["187\n"]}, {"input": "5 4\n10010\n00000\n00000\n00001\n10100\n00110\n", "output": ["38\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001011000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["188\n"]}, {"input": "5 4\n10010\n00000\n00000\n01001\n10100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n10010\n00100\n00000\n01001\n10100\n00110\n", "output": ["24\n"]}, {"input": "5 4\n00010\n00101\n00000\n01001\n10100\n00110\n", "output": ["31\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10110\n00111\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00101\n00100\n01001\n10110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01000\n10101\n00100\n01001\n10110\n00111\n", "output": ["18\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n10110\n00111\n", "output": ["16\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n10110\n01111\n", "output": ["15\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n00110\n01111\n", "output": ["17\n"]}, {"input": "0 4\n10010\n00000\n01000\n00001\n00100\n00010\n", "output": ["3\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["152\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["149\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["163\n"]}, {"input": "5 4\n10010\n00001\n00000\n00001\n10100\n00110\n", "output": ["36\n"]}, {"input": "5 9\n0000110000\n0001001000\n0001000000\n0001011000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["193\n"]}, {"input": "5 4\n00010\n00100\n00000\n01001\n10110\n00110\n", "output": ["32\n"]}, {"input": "5 4\n00010\n00101\n00000\n01001\n10100\n01110\n", "output": ["30\n"]}, {"input": "5 4\n00000\n00101\n00000\n01001\n10100\n00010\n", "output": ["35\n"]}, {"input": "5 4\n01000\n00101\n00000\n00001\n10100\n00111\n", "output": ["29\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n11110\n00111\n", "output": ["22\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["148\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["146\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["164\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n10100\n00010\n", "output": ["40\n"]}, {"input": "5 4\n01100\n11101\n00100\n01001\n00110\n00111\n", "output": ["20\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["158\n"]}, {"input": "9 9\n0000110010\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["109\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["147\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["173\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n01110\n", "output": ["27\n"]}, {"input": "4 4\n00010\n00101\n00000\n01011\n10100\n01110\n", "output": ["26\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n10101\n00010\n", "output": ["39\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["157\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["106\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["171\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["107\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["129\n"]}, {"input": "2 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["101\n"]}, {"input": "4 4\n01100\n11111\n00100\n01101\n00100\n01111\n", "output": ["14\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["103\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["128\n"]}, {"input": "3 4\n01100\n11111\n00100\n01101\n00100\n01111\n", "output": ["9\n"]}, {"input": "9 9\n0100100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001000011\n0011111110\n", "output": ["133\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["90\n"]}, {"input": "2 9\n0000110000\n0001001100\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001001\n0011111110\n", "output": ["74\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["89\n"]}, {"input": "1 4\n01001\n00101\n00100\n00001\n10100\n10100\n", "output": ["7\n"]}, {"input": "9 9\n0000110011\n0001011000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["88\n"]}, {"input": "9 9\n0000110011\n0001011010\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["84\n"]}, {"input": "4 4\n10010\n10100\n01011\n00010\n00101\n10111\n", "output": ["19\n"]}, {"input": "3 4\n01100\n11101\n00100\n01101\n10110\n01110\n", "output": ["10\n"]}, {"input": "9 9\n0000110011\n0001011010\n1001000000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["85\n"]}, {"input": "1 4\n01100\n11101\n00100\n00101\n11110\n01110\n", "output": ["4\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["184\n"]}, {"input": "2 2\n101\n000\n010\n", "output": ["6\n"]}, {"input": "9 9\n0001110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["177\n"]}, {"input": "2 2\n101\n000\n110\n", "output": ["5\n"]}, {"input": "5 4\n10000\n00000\n00000\n00001\n10100\n00110\n", "output": ["67\n"]}, {"input": "5 4\n00000\n00100\n00000\n01001\n10100\n00010\n", "output": ["43\n"]}, {"input": "0 4\n10110\n00000\n01000\n00001\n00100\n00010\n", "output": ["2\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111101110\n", "output": ["153\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1001111000\n0001000000\n0001001000\n0110100110\n1000000001\n1001001011\n0111111110\n", "output": ["145\n"]}, {"input": "5 4\n00010\n00100\n00000\n00001\n10110\n00110\n", "output": ["37\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["180\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000000\n1001001001\n0111111110\n", "output": ["159\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00010\n", "output": ["52\n"]}, {"input": "9 9\n0000100000\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["137\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n0101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["175\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n1001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["99\n"]}, {"input": "5 4\n01000\n00111\n10100\n01101\n11111\n00111\n", "output": ["13\n"]}, {"input": "9 9\n0100100001\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["113\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110100110\n1000000011\n1001001011\n0110111110\n", "output": ["124\n"]}, {"input": "9 9\n0100010000\n0001001000\n0001001000\n1101111100\n0001000001\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["98\n"]}, {"input": "9 9\n1100010000\n0001001000\n0001001100\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["97\n"]}, {"input": "2 9\n0000110000\n0001000100\n0001000000\n0001110000\n1101000000\n0001001000\n0110001110\n1000000001\n1001001001\n0011111110\n", "output": ["78\n"]}, {"input": "9 9\n0000110011\n0001111000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["87\n"]}, {"input": "9 9\n0001110000\n0001001000\n0001001000\n1001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["144\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n0001000000\n0001001000\n0110000010\n1000000001\n1001001011\n0011111110\n", "output": ["190\n"]}, {"input": "5 4\n10000\n00000\n00000\n00001\n10101\n00110\n", "output": ["66\n"]}, {"input": "9 9\n0000110000\n0001011000\n0001000000\n0001011000\n0001000010\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["162\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["136\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1101111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["115\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0101111000\n1001000100\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["139\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n0001110000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["121\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00011\n", "output": ["51\n"]}, {"input": "4 9\n0000100000\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["111\n"]}, {"input": "5 4\n11010\n00000\n00000\n00001\n10100\n00111\n", "output": ["34\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001001\n0011111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0110111110\n", "output": ["86\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0100100110\n1000000011\n1001001011\n0110111110\n", "output": ["126\n"]}, {"input": "9 9\n1100010000\n1001001000\n0001001100\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["96\n"]}, {"input": "9 9\n0000110011\n1001111000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["79\n"]}, {"input": "9 9\n0000110000\n0001011000\n0001000000\n0001011000\n0001010010\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["161\n"]}, {"input": "9 9\n0000110000\n0001001000\n1001001000\n0000111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["143\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["135\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1100111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["116\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0101111000\n1001000100\n0011001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["138\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n0001110000\n1000000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["123\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00111\n", "output": ["48\n"]}, {"input": "4 9\n0000100000\n0101001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["73\n"]}, {"input": "3 4\n10010\n11101\n01000\n00011\n00100\n00110\n", "output": ["12\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001100\n0001111000\n1001001001\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["76\n"]}, {"input": "2 4\n00010\n10100\n01001\n00011\n00100\n10111\n", "output": ["11\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["127\n"]}, {"input": "2 9\n0000110000\n0001001100\n0011000000\n0001110010\n1101000000\n0001001000\n0110000110\n1000000001\n1001000001\n0011111110\n", "output": ["57\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001000\n0110000110\n0000010001\n1001000011\n0111111111\n", "output": ["77\n"]}, {"input": "9 9\n0000110011\n1001111000\n1001000000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["80\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001111000\n0001000000\n0101001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["142\n"]}, {"input": "5 4\n10001\n00000\n00000\n00001\n10101\n10110\n", "output": ["42\n"]}, {"input": "0 4\n11110\n01000\n01000\n00001\n00110\n00010\n", "output": ["1\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["131\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1100111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111100\n", "output": ["117\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n1001110000\n1000000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["118\n"]}, {"input": "9 9\n0000110000\n0001001100\n0001000000\n0001110100\n0101000100\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["125\n"]}, {"input": "9 9\n0000110011\n0101001000\n1001001001\n0001111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0110111110\n", "output": ["82\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111101\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["110\n"]}, {"input": "2 9\n0000010000\n0001001100\n0001000000\n0001110000\n1101000000\n0001101000\n0110001110\n1000000000\n1001001001\n0011111110\n", "output": ["75\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001111000\n0001000000\n0101001000\n0110001110\n1000000001\n1001001001\n0111111110\n", "output": ["140\n"]}, {"input": "9 9\n0000010010\n0001000001\n0001001100\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["132\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001100\n1101111101\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["105\n"]}, {"input": "9 9\n1100010000\n1001001000\n0101001100\n1101111000\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111010\n", "output": ["102\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001011000\n0001000000\n0101001000\n0110001110\n1000000001\n1001001001\n0111111110\n", "output": ["141\n"]}, {"input": "7 9\n0000110000\n0001000000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000111\n0000000001\n1001001011\n0111111110\n", "output": ["189\n"]}, {"input": "2 9\n0000110000\n0000001100\n0011000000\n1001110010\n1101000000\n0001001000\n0110000110\n1000000011\n1001000001\n0011111110\n", "output": ["60\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001100\n0110000111\n0010010001\n1001000011\n0111111111\n", "output": ["72\n"]}, {"input": "9 9\n0000110000\n0001011001\n0101000000\n0001011000\n0101010010\n0101001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["83\n"]}, {"input": "5 4\n10000\n00001\n00000\n00001\n01110\n00111\n", "output": ["41\n"]}, {"input": "9 9\n0000010010\n0001000001\n0001001100\n0001111000\n0001011000\n0001001000\n0110000110\n1000010001\n1101101011\n0111111110\n", "output": ["130\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001000100\n0001111010\n0001001000\n0001001000\n0011000110\n1100000000\n1001000001\n1111111110\n", "output": ["155\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001100\n1101111101\n0001000000\n0001001000\n0100100110\n1000100011\n1001001001\n0110101110\n", "output": ["104\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001100\n0110000111\n1010010001\n1001000011\n0111111111\n", "output": ["71\n"]}, {"input": "7 9\n0000100000\n0001000000\n0001000000\n0001111000\n1001000000\n0001001001\n0110000111\n0000000001\n1001001011\n0111111110\n", "output": ["195\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001000100\n0011111010\n0001001000\n0001001000\n0011000110\n1100000000\n1001000001\n1111111110\n", "output": ["134\n"]}, {"input": "5 4\n00010\n00100\n00000\n01001\n10100\n00110\n", "output": ["33\n"]}, {"input": "5 4\n00000\n00101\n00000\n01001\n10100\n00110\n", "output": ["33\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10100\n00110\n", "output": ["25\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10100\n00111\n", "output": ["24\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["183\n"]}, {"input": "5 4\n10010\n00000\n01000\n00011\n00100\n00110\n", "output": ["31\n"]}, {"input": "5 4\n11010\n00000\n01000\n00001\n10100\n00110\n", "output": ["24\n"]}, {"input": "5 4\n11010\n00100\n00000\n01001\n10100\n00110\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00101\n00100\n01000\n10110\n00111\n", "output": ["23\n"]}, {"input": "5 4\n01000\n10101\n00100\n01101\n10110\n00111\n", "output": ["17\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n00110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01100\n10101\n00100\n01000\n10110\n01111\n", "output": ["17\n"]}, {"input": "4 4\n01100\n10101\n00100\n01001\n00110\n01111\n", "output": ["16\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["181\n"]}, {"input": "5 4\n10010\n00100\n01000\n00011\n00100\n00110\n", "output": ["29\n"]}, {"input": "5 4\n11010\n00000\n01000\n00001\n10100\n00111\n", "output": ["23\n"]}, {"input": "5 4\n10011\n00001\n00000\n00001\n10100\n00110\n", "output": ["35\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n00010\n00101\n00000\n01011\n10100\n01110\n", "output": ["28\n"]}, {"input": "5 4\n01000\n00101\n00000\n00001\n10100\n00110\n", "output": ["30\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n11111\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01000\n00101\n00100\n01010\n10110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01100\n10101\n00100\n01000\n10111\n01111\n", "output": ["15\n"]}, {"input": "4 4\n01100\n10101\n00100\n01001\n00100\n01111\n", "output": ["17\n"]}, {"input": "5 4\n10010\n10100\n01000\n00011\n00100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n01000\n00101\n00100\n00001\n10100\n00110\n", "output": ["27\n"]}, {"input": "5 4\n01000\n00101\n10000\n01001\n11111\n00111\n", "output": ["18\n"]}, {"input": "5 4\n01000\n00101\n00100\n01011\n10110\n00111\n", "output": ["20\n"]}, {"input": "4 4\n01100\n10101\n00100\n01101\n00100\n01111\n", "output": ["16\n"]}, {"input": "5 4\n10010\n10100\n01001\n00011\n00100\n00110\n", "output": ["26\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["148\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n01111\n", "output": ["26\n"]}, {"input": "5 4\n00000\n00101\n00100\n00001\n10101\n00010\n", "output": ["36\n"]}, {"input": "5 4\n01000\n00101\n00100\n00001\n10100\n00100\n", "output": ["31\n"]}, {"input": "5 4\n01000\n00101\n10000\n01101\n11111\n00111\n", "output": ["17\n"]}, {"input": "5 4\n01000\n00101\n00100\n00011\n10110\n00111\n", "output": ["24\n"]}, {"input": "4 4\n01100\n11101\n00100\n01101\n00100\n01111\n", "output": ["15\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["158\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n00110\n", "output": ["20\n"]}, {"input": "5 4\n11010\n00100\n00000\n00011\n10100\n01111\n", "output": ["24\n"]}, {"input": "5 4\n00000\n00101\n00100\n00001\n10101\n00011\n", "output": ["35\n"]}, {"input": "3 4\n01000\n00101\n00100\n00001\n10100\n00100\n", "output": ["25\n"]}, {"input": "5 4\n01000\n00101\n10100\n01101\n11111\n00111\n", "output": ["15\n"]}, {"input": "9 9\n0100100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["129\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n00111\n", "output": ["20\n"]}, {"input": "2 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001001\n0011111110\n", "output": ["101\n"]}, {"input": "5 4\n11010\n00110\n00000\n00011\n10100\n01111\n", "output": ["22\n"]}, {"input": "5 4\n00000\n00101\n00100\n10001\n10101\n00011\n", "output": ["30\n"]}, {"input": "3 4\n01001\n00101\n00100\n00001\n10100\n00100\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00100\n10100\n01101\n11111\n00111\n", "output": ["23\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n10111\n", "output": ["20\n"]}, {"input": "9 9\n0100010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["109\n"]}, {"input": "5 4\n11000\n00110\n00000\n00011\n10100\n01111\n", "output": ["24\n"]}, {"input": "5 4\n00000\n00111\n00100\n10001\n10101\n00011\n", "output": ["28\n"]}, {"input": "3 4\n01001\n00101\n00100\n00001\n10100\n10100\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00100\n10100\n01101\n01111\n00111\n", "output": ["25\n"]}, {"input": "3 4\n01100\n11111\n00100\n01101\n10100\n01111\n", "output": ["9\n"]}, {"input": "4 4\n10010\n10100\n01001\n00010\n00100\n10111\n", "output": ["22\n"]}, {"input": "9 9\n1100010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["107\n"]}, {"input": "2 9\n0000110000\n0001001100\n0001000000\n0001110000\n1101000000\n0001001000\n0110001110\n1000000001\n1001001001\n0011111110\n", "output": ["74\n"]}], "task_id": "codecontest/12", "prompt": "Mr. Chanek's city is depicted as a plane. He wants to build a housing complex in the city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the squared Euclidean distance between the two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo improve the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "repair_prompt": ["Mr. Chanek's city is depicted as a plane. He wants to build a housing complex in the city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the squared Euclidean distance between the two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo improve the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nWrite a main() function and use input() function to read input from stdin", " Mr. Chanek's city is depicted as a plane. He wants to build a housing complex in the city. There are some telephone poles on the plane, which is represented by a grid of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1. For each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). The squared Euclidean distance between the two points (x_1, y_1) and (x\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nWrite a main() function and use input() function to read input from stdin", " Mr. Chanek's city is depicted as a plane. He wants to build a housing complex in the city. There are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1. For each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). To improve the building plan, the project supervisor asks you the sum of all S(x,\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nWrite a main() function and use input() function to read input from stdin"], "completion": "def main():\n    # Read the grid size\n    n, m = map(int, input().split())\n    \n    # Initialize the grid\n    grid = []\n    \n    # Read the grid input and store it in a 2D array\n    for _ in range(n + 1):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    # Function to calculate the squared Euclidean distance\n    def calculate_squared_distance(x, y, grid):\n        min_distance_squared = float('inf')\n        for i in range(n + 1):\n            for j in range(m + 1):\n                if grid[i][j] == 1:\n                    distance_squared = (x - i) ** 2 + (y - j) ** 2\n                    if distance_squared < min_distance_squared:\n                        min_distance_squared = distance_squared\n        return min_distance_squared\n    \n    # Calculate the sum of squared distances\n    total_sum = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            total_sum += calculate_squared_distance(x, y, grid)\n    \n    # Output the total sum of squared distances\n    print(total_sum)\nmain()", "completions": ["def main():\n    # Read the grid size\n    n, m = map(int, input().split())\n    \n    # Read the grid\n    grid = []\n    for _ in range(n + 1):\n        grid.append(list(map(int, input())))\n    \n    # Initialize the sum of squared distances\n    sum_squared_distances = 0\n    \n    # Iterate over each cell in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            # Calculate the squared Euclidean distance to the nearest telephone pole\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            # Accumulate the sum of squared distances\n            sum_squared_distances += min_distance_squared\n    \n    # Output the final sum\n    print(sum_squared_distances)\nmain()", "def main():\n    # Read the grid size (n and m)\n    n, m = map(int, input().split())\n    \n    # Read the grid representing the positions of telephone poles\n    grid = []\n    for _ in range(n + 1):\n        grid.append(list(map(int, input())))\n    \n    # Initialize the sum of all S(x, y)\n    total_sum = 0\n    \n    # Calculate the squared Euclidean distance for each point in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            total_sum += min_distance_squared\n    \n    # Output the sum of all S(x, y)\n    print(total_sum)\nmain()", "def main():\n    # Read the grid size (n and m)\n    n, m = map(int, input().split())\n    \n    # Read the grid representing the positions of telephone poles\n    grid = []\n    for _ in range(n + 1):\n        grid.append(list(map(int, input())))\n    \n    # Initialize the sum of all S(x, y)\n    total_sum = 0\n    \n    # Calculate the squared Euclidean distance for each point in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                # If the point is a pole, S(x, y) is 0\n                total_sum += 0\n            else:\n                # Find the nearest pole\n                min_distance_squared = float('inf')\n                for i in range(n + 1):\n                    for j in range(m + 1):\n                        if grid[i][j] == 1:\n                            distance_squared = (x - i) ** 2 + (y - j) ** 2\n                            if distance_squared < min_distance_squared:\n                                min_distance_squared = distance_squared\n                total_sum += min_distance_squared\n    \n    # Output the sum of all S(x, y)\n    print(total_sum)\nmain()", "def main():\n    # Read the first line to get the grid size (n, m)\n    n, m = map(int, input().split())\n    \n    # Initialize the grid with zeros\n    grid = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    # Read the subsequent lines to populate the grid\n    for i in range(n + 1):\n        row = input()\n        for j, value in enumerate(row):\n            grid[i][j] = int(value)\n    \n    # Initialize a sum variable to accumulate the total S(x, y) values\n    total_sum = 0\n    \n    # Iterate over each point in the grid to calculate S(x, y) for each point\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                S_xy = 0\n            else:\n                min_distance_squared = float('inf')\n                for i in range(n + 1):\n                    for j in range(m + 1):\n                        if grid[i][j] == 1:\n                            distance_squared = (x - i) ** 2 + (y - j) ** 2\n                            if distance_squared < min_distance_squared:\n                                min_distance_squared = distance_squared\n                S_xy = min_distance_squared\n            total_sum += S_xy\n    \n    # Output the total sum\n    print(total_sum)\nmain()", "def main():\n    # Read the size of the grid\n    n, m = map(int, input().split())\n    \n    # Read the grid\n    grid = []\n    for _ in range(n + 1):\n        grid.append(list(map(int, input())))\n    \n    # Initialize the sum of squares of Euclidean distances\n    sum_of_squares = 0\n    \n    # Iterate over each point in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            # Calculate the minimum Euclidean distance squared to any telephone pole\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            # Accumulate the sum of squares of Euclidean distances\n            sum_of_squares += min_distance_squared\n    \n    # Output the final sum\n    print(sum_of_squares)\nmain()", "def main():\n    # Read the grid size (n, m)\n    n, m = map(int, input().split())\n    \n    # Read the grid representation of telephone poles\n    grid = []\n    for _ in range(n + 1):\n        grid.append(list(map(int, input().split())))\n    \n    # Initialize the sum of squared distances\n    total_sum = 0\n    \n    # Calculate the squared Euclidean distance for each point in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                min_distance_squared = 0\n            else:\n                min_distance_squared = float('inf')\n                # Find the nearest telephone pole\n                for i in range(n + 1):\n                    for j in range(m + 1):\n                        if grid[i][j] == 1:\n                            distance_squared = (x - i) ** 2 + (y - j) ** 2\n                            if distance_squared < min_distance_squared:\n                                min_distance_squared = distance_squared\n            # Add the squared distance to the total sum\n            total_sum += min_distance_squared\n    \n    # Output the final sum\n    print(total_sum)\nmain()", "def main():\n    # Read the first line to get the grid size (n, m)\n    n, m = map(int, input().split())\n    \n    # Initialize the grid with zeros\n    grid = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    # Read the subsequent lines to populate the grid\n    for i in range(n + 1):\n        row = input()\n        for j, value in enumerate(row):\n            grid[i][j] = int(value)\n    \n    # Initialize a sum variable to accumulate the total sum of S(x, y)\n    total_sum = 0\n    \n    # Iterate over each point (x, y) in the grid to calculate S(x, y) for each point\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                S_xy = 0\n            else:\n                min_distance_squared = float('inf')\n                for i in range(n + 1):\n                    for j in range(m + 1):\n                        if grid[i][j] == 1:\n                            distance_squared = (x - i) ** 2 + (y - j) ** 2\n                            if distance_squared < min_distance_squared:\n                                min_distance_squared = distance_squared\n                S_xy = min_distance_squared\n            total_sum += S_xy\n    \n    # Output the total sum\n    print(total_sum)\nmain()", "def main():\n    # Read the grid size (n and m)\n    n, m = map(int, input().split())\n    \n    # Read the grid\n    grid = []\n    for _ in range(n + 1):\n        grid.append(list(map(int, input())))\n    \n    # Initialize the sum of all S(x, y)\n    total_sum = 0\n    \n    # Iterate over each point (x, y) in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            # Find the nearest telephone pole\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            # Add the squared distance to the total sum\n            total_sum += min_distance_squared\n    \n    # Output the final sum\n    print(total_sum)\nmain()", "def main():\n    # Read the size of the grid\n    n, m = map(int, input().split())\n    \n    # Initialize the grid to store the positions of telephone poles\n    grid = []\n    \n    # Read the grid input and store it in a 2D array\n    for _ in range(n + 1):\n        row = list(map(int, input().strip()))\n        grid.append(row)\n    \n    # Initialize the sum of squared distances\n    total_sum = 0\n    \n    # Iterate through each cell in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            \n            # Find the nearest telephone pole for the current cell\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            \n            # Add the squared distance to the total sum\n            total_sum += min_distance_squared\n    \n    # Output the total sum of squared distances\n    print(total_sum)\nmain()", "def main():\n    # Read the grid size\n    n, m = map(int, input().split())\n    \n    # Initialize the grid\n    grid = []\n    \n    # Read the grid input and store it in a 2D array\n    for _ in range(n + 1):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    # Function to calculate the squared Euclidean distance\n    def calculate_squared_distance(x, y, grid):\n        min_distance_squared = float('inf')\n        for i in range(n + 1):\n            for j in range(m + 1):\n                if grid[i][j] == 1:\n                    distance_squared = (x - i) ** 2 + (y - j) ** 2\n                    if distance_squared < min_distance_squared:\n                        min_distance_squared = distance_squared\n        return min_distance_squared\n    \n    # Calculate the sum of squared distances\n    total_sum = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            total_sum += calculate_squared_distance(x, y, grid)\n    \n    # Output the total sum of squared distances\n    print(total_sum)\nmain()"], "session_history": {"plan": " ```json\n{\n  \"plan\": {\n    \"subproblems\": [\n      \"Read the input values for the grid size and the grid itself.\",\n      \"Determine the nearest telephone pole for each cell in the grid.\",\n      \"Calculate the squared Euclidean distance for each cell to its nearest pole.\",\n      \"Sum the squared distances for all cells in the grid.\",\n      \"Output the total sum of squared distances.\"\n    ],\n    \"high_level_steps\": [\n      \"Initialize the grid size variables.\",\n      \"Read the grid input and store it in a 2D array.\",\n      \"Iterate through each cell in the grid to find the nearest telephone pole.\",\n      \"Calculate the squared Euclidean distance for each cell to its nearest pole.\",\n      \"Sum the squared distances for all cells and output the result.\",\n      \"Handle edge cases such as empty grid or no poles.\"\n    ]\n  }\n}\n```\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem, where the distance is the square root of the sum of the squares of the differences in the coordinates.\n    'squared Euclidean distance': The square of the Euclidean distance, which is used for simplification in certain calculations.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps should be implemented sequentially as each cell's nearest pole must", "Round_0": {"code": "def main():\n    # Read the grid size\n    n, m = map(int, input().split())\n    \n    # Initialize the grid\n    grid = []\n    \n    # Read the grid input\n    for _ in range(n + 1):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    # Function to calculate the squared Euclidean distance\n    def calculate_squared_distance(x, y, grid):\n        min_distance_squared = float('inf')\n        for i in range(n + 1):\n            for j in range(m + 1):\n                if grid[i][j] == 1:\n                    distance_squared = (x - i) ** 2 + (y - j) ** 2\n                    if distance_squared < min_distance_squared:\n                        min_distance_squared = distance_squared\n        return min_distance_squared\n    \n    # Calculate the sum of squared distances\n    total_sum = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            total_sum += calculate_squared_distance(x, y, grid)\n    \n    # Output the total sum of squared distances\n    print(total_sum)", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 106)"}, "Round_1": {"code": "def main():\n    # Read the grid size\n    n, m = map(int, input().split())\n    \n    # Initialize the grid\n    grid = []\n    \n    # Read the grid input and store it in a 2D array\n    for _ in range(n + 1):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    # Function to calculate the squared Euclidean distance\n    def calculate_squared_distance(x, y, grid):\n        min_distance_squared = float('inf')\n        for i in range(n + 1):\n            for j in range(m + 1):\n                if grid[i][j] == 1:\n                    distance_squared = (x - i) ** 2 + (y - j) ** 2\n                    if distance_squared < min_distance_squared:\n                        min_distance_squared = distance_squared\n        return min_distance_squared\n    \n    # Calculate the sum of squared distances\n    total_sum = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            total_sum += calculate_squared_distance(x, y, grid)\n    \n    # Output the total sum of squared distances\n    print(total_sum)"}}, "session_historys": [{"plan": " ```json\n{\n  \"plan\": {\n    \"subproblems\": [\n      {\n        \"description\": \"Read the input grid size and the grid itself.\",\n        \"details\": \"The program should first read the dimensions of the grid (n and m) and then read the grid itself line by line.\"\n      },\n      {\n        \"description\": \"Calculate the squared Euclidean distance for each cell in the grid to the nearest telephone pole.\",\n        \"details\": \"For each cell, iterate through all telephone poles to find the one with the minimum squared Euclidean distance.\"\n      },\n      {\n        \"description\": \"Sum the squared distances for all cells in the grid.\",\n        \"details\": \"After calculating the squared distances for all cells, sum them up to get the final result.\"\n      }\n    ],\n    \"high_level_plan\": [\n      {\n        \"step\": \"Read the input.\",\n        \"details\": \"Read the grid size and the grid itself from standard input.\"\n      },\n      {\n        \"step\": \"Initialize a variable to store the sum of squared distances.\",\n        \"details\": \"This will be used to accumulate the sum of all S(x, y) values.\"\n      },\n      {\n        \"step\": \"Iterate over each cell in the grid.\",\n        \"details\": \"For each cell, calculate the squared Euclidean distance to the nearest telephone pole.\"\n      },\n      {\n        \"step\": \"Accumulate the sum of squared distances.\",\n        \"details\": \"Add the calculated squared distance to the sum variable.\"\n      },\n      {\n        \"step\": \"Output the final sum.\",\n        \"details\": \"Print the accumulated sum to standard output.\"\n      }\n    ]\n  }\n}\n```\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane is the length of the line segment connecting them. The Euclidean distance between two points (x1, y1) and (x2, y2) is given by the formula \u221a((x2 - x1)^2 + (y2 - y1)^2).\n\n    'Squared Euclidean distance': When we are only interested in comparing distances and not the actual distance values, we can use the squared Euclidean distance. This is the Euclidean distance squared, which is (x2 - x1)^2 + (y", "Round_0": {"code": "def main():\n    # Read the grid size\n    n, m = map(int, input().split())\n    \n    # Read the grid\n    grid = []\n    for _ in range(n + 1):\n        grid.append(list(map(int, input())))\n    \n    # Initialize the sum of squared distances\n    sum_squared_distances = 0\n    \n    # Iterate over each cell in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            # Calculate the squared Euclidean distance to the nearest telephone pole\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            # Accumulate the sum of squared distances\n            sum_squared_distances += min_distance_squared\n    \n    # Output the final sum\n    print(sum_squared_distances)", "report": "The compilation output of the preceding code is: failed with AssertionError. "}, "Round_1": {"code": "def main():\n    # Read the grid size\n    n, m = map(int, input().split())\n    \n    # Read the grid\n    grid = []\n    for _ in range(n + 1):\n        grid.append(list(map(int, input())))\n    \n    # Initialize the sum of squared distances\n    sum_squared_distances = 0\n    \n    # Iterate over each cell in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            # Calculate the squared Euclidean distance to the nearest telephone pole\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            # Accumulate the sum of squared distances\n            sum_squared_distances += min_distance_squared\n    \n    # Output the final sum\n    print(sum_squared_distances)"}}, {"plan": " ```json\n{\n  \"plan\": {\n    \"subproblems\": [\n      {\n        \"description\": \"Read the input grid size and the grid itself from standard input.\",\n        \"steps\": [\n          \"Read the first line to get the grid size (n and m).\",\n          \"Read the subsequent lines to populate the grid.\"\n        ]\n      },\n      {\n        \"description\": \"Calculate the squared Euclidean distance from each point in the grid to the nearest telephone pole.\",\n        \"steps\": [\n          \"Iterate over each point (x, y) in the grid.\",\n          \"For each point, find the nearest telephone pole by checking all poles in the grid.\",\n          \"Calculate the squared Euclidean distance between the point and the nearest pole.\",\n          \"Store the result in a new grid S.\"\n        ]\n      },\n      {\n        \"description\": \"Sum the values in the S grid to get the final result.\",\n        \"steps\": [\n          \"Iterate over the S grid and sum all values to get the final result.\"\n        ]\n      }\n    ],\n    \"high_level_plan\": [\n      \"Initialize the grid size and read the grid from standard input.\",\n      \"Initialize a new grid S to store the squared Euclidean distances.\",\n      \"Calculate the squared Euclidean distance for each point in the grid.\",\n      \"Sum the values in the S grid to get the final result and output it.\"\n    ]\n  }\n}\n```\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem, where the distance is the square root of the sum of the squares of the differences in the coordinates.\n    Explanation: In this problem, we need to calculate the squared Euclidean distance between each point in the grid and the nearest telephone pole. The squared distance is used because it simplifies the calculation and comparison without needing to take the square root.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n", "Round_0": {"code": "def main():\n    # Read the grid size (n and m)\n    n, m = map(int, input().split())\n    \n    # Read the grid representing the positions of telephone poles\n    grid = []\n    for _ in range(n + 1):\n        grid.append(list(map(int, input())))\n    \n    # Initialize the sum of all S(x, y)\n    total_sum = 0\n    \n    # Calculate the squared Euclidean distance for each point in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            total_sum += min_distance_squared\n    \n    # Output the sum of all S(x, y)\n    print(total_sum)", "report": "The compilation output of the preceding code is: failed with AssertionError. "}, "Round_1": {"code": "def main():\n    # Read the grid size (n and m)\n    n, m = map(int, input().split())\n    \n    # Read the grid representing the positions of telephone poles\n    grid = []\n    for _ in range(n + 1):\n        grid.append(list(map(int, input())))\n    \n    # Initialize the sum of all S(x, y)\n    total_sum = 0\n    \n    # Calculate the squared Euclidean distance for each point in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            total_sum += min_distance_squared\n    \n    # Output the sum of all S(x, y)\n    print(total_sum)"}}, {"plan": " ```json\n{\n  \"plan\": {\n    \"subproblems\": [\n      {\n        \"description\": \"Read the input grid size and the grid itself from standard input.\",\n        \"steps\": [\n          \"Read the first line to get the grid size (n and m).\",\n          \"Read the subsequent lines to construct the grid.\"\n        ]\n      },\n      {\n        \"description\": \"Calculate the squared Euclidean distance from each point in the grid to the nearest telephone pole.\",\n        \"steps\": [\n          \"Iterate over each point (x, y) in the grid.\",\n          \"For each point, find the nearest telephone pole by checking all poles in the grid.\",\n          \"Calculate the squared Euclidean distance between the point and the nearest pole.\",\n          \"Store the result in a new grid S.\"\n        ]\n      },\n      {\n        \"description\": \"Sum the values in the S grid to get the final result.\",\n        \"steps\": [\n          \"Iterate over the S grid and sum all the values to get the final result.\"\n        ]\n      }\n    ],\n    \"high_level_plan\": [\n      \"Initialize the grid size and read the grid from standard input.\",\n      \"Initialize a new grid S to store the squared Euclidean distances.\",\n      \"Calculate the squared Euclidean distance for each point in the grid.\",\n      \"Sum the values in the S grid to get the final result and output it.\"\n    ]\n  }\n}\n```\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem, where the distance is the square root of the sum of the squares of the differences in the coordinates.\n    Explanation: In this problem, we need to calculate the squared Euclidean distance between each point in the grid and the nearest telephone pole. The squared distance is used because it simplifies the calculation and comparison without needing to take the square root.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n", "Round_0": {"code": "def main():\n    # Read the grid size (n and m)\n    n, m = map(int, input().split())\n    \n    # Read the grid representing the positions of telephone poles\n    grid = []\n    for _ in range(n + 1):\n        grid.append(list(map(int, input())))\n    \n    # Initialize the sum of all S(x, y)\n    total_sum = 0\n    \n    # Calculate the squared Euclidean distance for each point in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                # If the point is a pole, S(x, y) is 0\n                total_sum += 0\n            else:\n                # Find the nearest pole\n                min_distance_squared = float('inf')\n                for i in range(n + 1):\n                    for j in range(m + 1):\n                        if grid[i][j] == 1:\n                            distance_squared = (x - i) ** 2 + (y - j) ** 2\n                            if distance_squared < min_distance_squared:\n                                min_distance_squared = distance_squared\n                total_sum += min_distance_squared\n    \n    # Output the sum of all S(x, y)\n    print(total_sum)", "report": "The compilation output of the preceding code is: failed with AssertionError. "}, "Round_1": {"code": "def main():\n    # Read the grid size (n and m)\n    n, m = map(int, input().split())\n    \n    # Read the grid representing the positions of telephone poles\n    grid = []\n    for _ in range(n + 1):\n        grid.append(list(map(int, input())))\n    \n    # Initialize the sum of all S(x, y)\n    total_sum = 0\n    \n    # Calculate the squared Euclidean distance for each point in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                # If the point is a pole, S(x, y) is 0\n                total_sum += 0\n            else:\n                # Find the nearest pole\n                min_distance_squared = float('inf')\n                for i in range(n + 1):\n                    for j in range(m + 1):\n                        if grid[i][j] == 1:\n                            distance_squared = (x - i) ** 2 + (y - j) ** 2\n                            if distance_squared < min_distance_squared:\n                                min_distance_squared = distance_squared\n                total_sum += min_distance_squared\n    \n    # Output the sum of all S(x, y)\n    print(total_sum)"}}, {"plan": " ```json\n{\n  \"plan\": {\n    \"subproblems\": [\n      {\n        \"description\": \"Read the input grid size and the grid itself from standard input.\",\n        \"steps\": [\n          \"Read the first line to get the grid size (n, m).\",\n          \"Read the subsequent lines to populate the grid.\"\n        ]\n      },\n      {\n        \"description\": \"Calculate the Euclidean distance squared (S(x, y)) for each point in the grid to the nearest telephone pole.\",\n        \"steps\": [\n          \"Iterate over each point (x, y) in the grid.\",\n          \"For each point, find the nearest telephone pole by checking all points with a pole (a_{x, y} = 1).\",\n          \"Calculate the Euclidean distance squared between the point and the nearest pole.\"\n        ]\n      },\n      {\n        \"description\": \"Sum the values of S(x, y) for all points in the grid.\",\n        \"steps\": [\n          \"Initialize a sum variable.\",\n          \"Iterate over each point (x, y) in the grid and add the value of S(x, y) to the sum.\"\n        ]\n      },\n      {\n        \"description\": \"Output the total sum of S(x, y) for all points in the grid.\",\n        \"steps\": [\n          \"Print the sum to standard output.\"\n        ]\n      }\n    ],\n    \"high_level_plan\": [\n      \"Read the input grid size and the grid.\",\n      \"Initialize a sum variable to accumulate the total S(x, y) values.\",\n      \"Iterate over each point in the grid to calculate S(x, y) for each point.\",\n      \"Sum the calculated S(x, y) values.\",\n      \"Output the total sum.\"\n    ]\n  }\n}\n```\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance squared': The distance between two points in a plane is calculated using the formula sqrt((x2-x1)^2 + (y2-y1)^2). In this case, we are interested in the square of this distance for simplicity.\n    Explanation: The Euclidean distance squared is used to measure the proximity of a point to the nearest telephone pole. This is important for determining the suitability of a location for the housing complex.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree", "Round_0": {"code": "def main():\n    # Read the first line to get the grid size (n, m)\n    n, m = map(int, input().split())\n    \n    # Initialize the grid with zeros\n    grid = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    # Read the subsequent lines to populate the grid\n    for i in range(n + 1):\n        row = input()\n        for j, value in enumerate(row):\n            grid[i][j] = int(value)\n    \n    # Initialize a sum variable to accumulate the total S(x, y) values\n    total_sum = 0\n    \n    # Iterate over each point in the grid to calculate S(x, y) for each point\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                S_xy = 0\n            else:\n                min_distance_squared = float('inf')\n                for i in range(n + 1):\n                    for j in range(m + 1):\n                        if grid[i][j] == 1:\n                            distance_squared = (x - i) ** 2 + (y - j) ** 2\n                            if distance_squared < min_distance_squared:\n                                min_distance_squared = distance_squared\n                S_xy = min_distance_squared\n            total_sum += S_xy\n    \n    # Output the total sum\n    print(total_sum)", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 107)"}, "Round_1": {"code": "def main():\n    # Read the first line to get the grid size (n, m)\n    n, m = map(int, input().split())\n    \n    # Initialize the grid with zeros\n    grid = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    # Read the subsequent lines to populate the grid\n    for i in range(n + 1):\n        row = input()\n        for j, value in enumerate(row):\n            grid[i][j] = int(value)\n    \n    # Initialize a sum variable to accumulate the total S(x, y) values\n    total_sum = 0\n    \n    # Iterate over each point in the grid to calculate S(x, y) for each point\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                S_xy = 0\n            else:\n                min_distance_squared = float('inf')\n                for i in range(n + 1):\n                    for j in range(m + 1):\n                        if grid[i][j] == 1:\n                            distance_squared = (x - i) ** 2 + (y - j) ** 2\n                            if distance_squared < min_distance_squared:\n                                min_distance_squared = distance_squared\n                S_xy = min_distance_squared\n            total_sum += S_xy\n    \n    # Output the total sum\n    print(total_sum)"}}, {"plan": " ```json\n{\n  \"plan\": {\n    \"subproblems\": [\n      \"Read the input values for the grid size and the grid itself.\",\n      \"Identify the positions of all telephone poles in the grid.\",\n      \"Calculate the Euclidean distance from each grid point to the nearest telephone pole.\",\n      \"Compute the square of the Euclidean distance for each point.\",\n      \"Sum the squares of the Euclidean distances for all points in the grid.\",\n      \"Output the final sum.\"\n    ],\n    \"high_level_plan\": [\n      \"Initialize the grid and read the input values.\",\n      \"Locate all telephone poles and store their coordinates.\",\n      \"Iterate over each point in the grid.\",\n      \"For each point, calculate the minimum Euclidean distance to any telephone pole.\",\n      \"Square the minimum distance and accumulate the sum.\",\n      \"Print the accumulated sum as the output.\"\n    ]\n  }\n}\n```\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem, where the distance is the square root of the sum of the squares of the differences in the coordinates.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially. Each point in the grid needs to calculate its distance to the nearest telephone pole, and then the sum of these distances should be computed.\n\n# [edge case]", "Round_0": {"code": "def main():\n    # Read the size of the grid\n    n, m = map(int, input().split())\n    \n    # Read the grid\n    grid = []\n    for _ in range(n + 1):\n        grid.append(list(map(int, input())))\n    \n    # Initialize the sum of squares of Euclidean distances\n    sum_of_squares = 0\n    \n    # Iterate over each point in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            # Calculate the minimum Euclidean distance squared to any telephone pole\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            # Accumulate the sum of squares of Euclidean distances\n            sum_of_squares += min_distance_squared\n    \n    # Output the final sum\n    print(sum_of_squares)", "report": "The compilation output of the preceding code is: failed with AssertionError. "}, "Round_1": {"code": "def main():\n    # Read the size of the grid\n    n, m = map(int, input().split())\n    \n    # Read the grid\n    grid = []\n    for _ in range(n + 1):\n        grid.append(list(map(int, input())))\n    \n    # Initialize the sum of squares of Euclidean distances\n    sum_of_squares = 0\n    \n    # Iterate over each point in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            # Calculate the minimum Euclidean distance squared to any telephone pole\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            # Accumulate the sum of squares of Euclidean distances\n            sum_of_squares += min_distance_squared\n    \n    # Output the final sum\n    print(sum_of_squares)", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": " ```json\n{\n  \"plan\": {\n    \"subproblems\": [\n      {\n        \"description\": \"Read the input grid size and the grid representation of telephone poles.\",\n        \"steps\": [\n          \"Read the first line to get the grid size (n, m).\",\n          \"Read the subsequent lines to construct the grid of telephone poles.\"\n        ]\n      },\n      {\n        \"description\": \"Calculate the squared Euclidean distance for each point in the grid to the nearest telephone pole.\",\n        \"steps\": [\n          \"Iterate over each point (x, y) in the grid.\",\n          \"For each point, find the nearest telephone pole by checking all points with a telephone pole (a_{i, j} = 1).\",\n          \"Calculate the squared Euclidean distance between the point and the nearest telephone pole.\",\n          \"Store the squared distance for each point.\"\n        ]\n      },\n      {\n        \"description\": \"Sum the squared distances for all points in the grid to get the final result.\",\n        \"steps\": [\n          \"Initialize a sum variable to accumulate the total squared distances.\",\n          \"Iterate over all points (x, y) in the grid and add their squared distances to the sum.\",\n          \"Output the final sum.\"\n        ]\n      }\n    ],\n    \"high_level_plan\": [\n      \"Read the input grid size and the grid representation of telephone poles.\",\n      \"Calculate the squared Euclidean distance for each point in the grid to the nearest telephone pole.\",\n      \"Sum the squared distances for all points in the grid to get the final result.\",\n      \"Output the final sum.\"\n    ]\n  }\n}\n```\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem, where the distance is the square root of the sum of the squares of the differences in the coordinates. In this case, we are calculating the squared Euclidean distance, which is the square of the Euclidean distance.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially. Each point in the grid needs to find the nearest telephone pole and", "Round_0": {"code": "def main():\n    # Read the grid size (n, m)\n    n, m = map(int, input().split())\n    \n    # Read the grid representation of telephone poles\n    grid = []\n    for _ in range(n + 1):\n        grid.append(list(map(int, input().split())))\n    \n    # Initialize the sum of squared distances\n    total_sum = 0\n    \n    # Calculate the squared Euclidean distance for each point in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            # Find the nearest telephone pole\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            # Add the squared distance to the total sum\n            total_sum += min_distance_squared\n    \n    # Output the final sum\n    print(total_sum)", "report": "The compilation output of the preceding code is: list index out of range"}, "Round_1": {"code": "def main():\n    # Read the grid size (n, m)\n    n, m = map(int, input().split())\n    \n    # Read the grid representation of telephone poles\n    grid = []\n    for _ in range(n + 1):\n        grid.append(list(map(int, input().split())))\n    \n    # Initialize the sum of squared distances\n    total_sum = 0\n    \n    # Calculate the squared Euclidean distance for each point in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                min_distance_squared = 0\n            else:\n                min_distance_squared = float('inf')\n                # Find the nearest telephone pole\n                for i in range(n + 1):\n                    for j in range(m + 1):\n                        if grid[i][j] == 1:\n                            distance_squared = (x - i) ** 2 + (y - j) ** 2\n                            if distance_squared < min_distance_squared:\n                                min_distance_squared = distance_squared\n            # Add the squared distance to the total sum\n            total_sum += min_distance_squared\n    \n    # Output the final sum\n    print(total_sum)"}}, {"plan": " ```json\n{\n  \"plan\": {\n    \"subproblems\": [\n      {\n        \"description\": \"Read the input grid size and the grid itself from standard input.\",\n        \"steps\": [\n          \"Read the first line to get the grid size (n, m).\",\n          \"Read the subsequent lines to populate the grid.\"\n        ]\n      },\n      {\n        \"description\": \"Calculate the Euclidean distance squared (S(x, y)) for each point in the grid to the nearest telephone pole.\",\n        \"steps\": [\n          \"Iterate over each point (x, y) in the grid.\",\n          \"For each point, find the nearest telephone pole by checking all points with a pole (a_{x, y} = 1).\",\n          \"Calculate the Euclidean distance squared between the point and the nearest pole.\"\n        ]\n      },\n      {\n        \"description\": \"Sum the values of S(x, y) for all points in the grid.\",\n        \"steps\": [\n          \"Initialize a sum variable to accumulate the total sum of S(x, y).\",\n          \"Iterate over each point (x, y) in the grid and add the value of S(x, y) to the sum.\"\n        ]\n      },\n      {\n        \"description\": \"Output the total sum of S(x, y) to standard output.\",\n        \"steps\": [\n          \"Print the accumulated sum.\"\n        ]\n      }\n    ],\n    \"high_level_plan\": [\n      \"Read the input grid size and the grid.\",\n      \"Initialize a sum variable.\",\n      \"Iterate over each point in the grid to calculate S(x, y) for each point.\",\n      \"Sum the values of S(x, y) for all points.\",\n      \"Output the total sum.\"\n    ]\n  }\n}\n```\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance squared': The distance between two points in a plane is calculated using the formula sqrt((x2-x1)^2 + (y2-y1)^2). In this case, we are interested in the square of this distance for simplicity.\n    Explanation: The square of the Euclidean distance is used because it allows for easier comparison and computation, especially in grid-based systems where distances are typically measured in integer units.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n", "Round_0": {"code": "def main():\n    # Read the first line to get the grid size (n, m)\n    n, m = map(int, input().split())\n    \n    # Initialize the grid with zeros\n    grid = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    # Read the subsequent lines to populate the grid\n    for i in range(n + 1):\n        row = input()\n        for j, value in enumerate(row):\n            grid[i][j] = int(value)\n    \n    # Initialize a sum variable to accumulate the total sum of S(x, y)\n    total_sum = 0\n    \n    # Iterate over each point (x, y) in the grid to calculate S(x, y) for each point\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                S_xy = 0\n            else:\n                min_distance_squared = float('inf')\n                for i in range(n + 1):\n                    for j in range(m + 1):\n                        if grid[i][j] == 1:\n                            distance_squared = (x - i) ** 2 + (y - j) ** 2\n                            if distance_squared < min_distance_squared:\n                                min_distance_squared = distance_squared\n                S_xy = min_distance_squared\n            total_sum += S_xy\n    \n    # Output the total sum\n    print(total_sum)", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def main():\n    # Read the first line to get the grid size (n, m)\n    n, m = map(int, input().split())\n    \n    # Initialize the grid with zeros\n    grid = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    # Read the subsequent lines to populate the grid\n    for i in range(n + 1):\n        row = input()\n        for j, value in enumerate(row):\n            grid[i][j] = int(value)\n    \n    # Initialize a sum variable to accumulate the total sum of S(x, y)\n    total_sum = 0\n    \n    # Iterate over each point (x, y) in the grid to calculate S(x, y) for each point\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                S_xy = 0\n            else:\n                min_distance_squared = float('inf')\n                for i in range(n + 1):\n                    for j in range(m + 1):\n                        if grid[i][j] == 1:\n                            distance_squared = (x - i) ** 2 + (y - j) ** 2\n                            if distance_squared < min_distance_squared:\n                                min_distance_squared = distance_squared\n                S_xy = min_distance_squared\n            total_sum += S_xy\n    \n    # Output the total sum\n    print(total_sum)"}}, {"plan": " ```json\n{\n  \"plan\": {\n    \"subproblems\": [\n      {\n        \"description\": \"Read the input grid size and the grid itself from standard input.\",\n        \"steps\": [\n          \"Read the first line to get the grid size (n and m).\",\n          \"Read the subsequent lines to populate the grid.\"\n        ]\n      },\n      {\n        \"description\": \"Calculate the squared Euclidean distance from each point in the grid to the nearest telephone pole.\",\n        \"steps\": [\n          \"Iterate over each point (x, y) in the grid.\",\n          \"For each point, find the nearest telephone pole by checking all other poles.\",\n          \"Calculate the squared Euclidean distance and store it.\"\n        ]\n      },\n      {\n        \"description\": \"Sum the squared distances for all points in the grid.\",\n        \"steps\": [\n          \"Initialize a sum variable.\",\n          \"Iterate over all points (x, y) in the grid and add their squared distances to the sum.\",\n          \"Output the final sum.\"\n        ]\n      }\n    ],\n    \"high_level_plan\": [\n      \"Read the input grid size and the grid.\",\n      \"For each point in the grid, calculate the squared Euclidean distance to the nearest telephone pole.\",\n      \"Sum all the squared distances and output the result.\"\n    ]\n  }\n}\n```\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem.\n    Explanation: In this problem, we need to calculate the squared Euclidean distance from each point in the grid to the nearest telephone pole. The squared distance is used because it simplifies the calculation and comparison without the need for square roots.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously.\n    \"Iterate over", "Round_0": {"code": "def main():\n    # Read the grid size (n and m)\n    n, m = map(int, input().split())\n    \n    # Read the grid\n    grid = []\n    for _ in range(n + 1):\n        grid.append(list(map(int, input())))\n    \n    # Initialize the sum of all S(x, y)\n    total_sum = 0\n    \n    # Iterate over each point (x, y) in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            # Find the nearest telephone pole\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            # Add the squared distance to the total sum\n            total_sum += min_distance_squared\n    \n    # Output the final sum\n    print(total_sum)", "report": "The compilation output of the preceding code is: failed with AssertionError. "}, "Round_1": {"code": "def main():\n    # Read the grid size (n and m)\n    n, m = map(int, input().split())\n    \n    # Read the grid\n    grid = []\n    for _ in range(n + 1):\n        grid.append(list(map(int, input())))\n    \n    # Initialize the sum of all S(x, y)\n    total_sum = 0\n    \n    # Iterate over each point (x, y) in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            # Find the nearest telephone pole\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            # Add the squared distance to the total sum\n            total_sum += min_distance_squared\n    \n    # Output the final sum\n    print(total_sum)", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": " ```json\n{\n  \"plan\": {\n    \"subproblems\": [\n      \"Read the input values for the grid size and the grid itself.\",\n      \"Determine the nearest telephone pole for each cell in the grid.\",\n      \"Calculate the squared Euclidean distance for each cell to its nearest pole.\",\n      \"Sum the squared distances for all cells in the grid.\",\n      \"Output the total sum of squared distances.\"\n    ],\n    \"high_level_steps\": [\n      \"Initialize the grid size variables.\",\n      \"Read the grid input and store it in a 2D array.\",\n      \"Iterate through each cell in the grid to find the nearest telephone pole.\",\n      \"Calculate the squared Euclidean distance for each cell to its nearest pole.\",\n      \"Sum the squared distances for all cells and output the result.\",\n      \"Handle edge cases such as empty grid or no poles.\"\n    ]\n  }\n}\n```\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane is the length of the line segment connecting them. The squared Euclidean distance is the square of this length.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps should be implemented sequentially as each cell's nearest pole must be determined before moving to the next cell.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    1", "Round_0": {"code": "def main():\n    # Read the size of the grid\n    n, m = map(int, input().split())\n    \n    # Initialize the grid to store the positions of telephone poles\n    grid = []\n    \n    # Read the grid input\n    for _ in range(n + 1):\n        row = list(map(int, input().strip()))\n        grid.append(row)\n    \n    # Initialize the sum of squared distances\n    total_sum = 0\n    \n    # Iterate through each cell in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            \n            # Find the nearest telephone pole for the current cell\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            \n            # Add the squared distance to the total sum\n            total_sum += min_distance_squared\n    \n    # Output the total sum of squared distances\n    print(total_sum)", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 108)"}, "Round_1": {"code": "def main():\n    # Read the size of the grid\n    n, m = map(int, input().split())\n    \n    # Initialize the grid to store the positions of telephone poles\n    grid = []\n    \n    # Read the grid input and store it in a 2D array\n    for _ in range(n + 1):\n        row = list(map(int, input().strip()))\n        grid.append(row)\n    \n    # Initialize the sum of squared distances\n    total_sum = 0\n    \n    # Iterate through each cell in the grid\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            \n            # Find the nearest telephone pole for the current cell\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            \n            # Add the squared distance to the total sum\n            total_sum += min_distance_squared\n    \n    # Output the total sum of squared distances\n    print(total_sum)"}}, {"plan": " ```json\n{\n  \"plan\": {\n    \"subproblems\": [\n      \"Read the input values for the grid size and the grid itself.\",\n      \"Determine the nearest telephone pole for each cell in the grid.\",\n      \"Calculate the squared Euclidean distance for each cell to its nearest pole.\",\n      \"Sum the squared distances for all cells in the grid.\",\n      \"Output the total sum of squared distances.\"\n    ],\n    \"high_level_steps\": [\n      \"Initialize the grid size variables.\",\n      \"Read the grid input and store it in a 2D array.\",\n      \"Iterate through each cell in the grid to find the nearest telephone pole.\",\n      \"Calculate the squared Euclidean distance for each cell to its nearest pole.\",\n      \"Sum the squared distances for all cells and output the result.\",\n      \"Handle edge cases such as empty grid or no poles.\"\n    ]\n  }\n}\n```\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem, where the distance is the square root of the sum of the squares of the differences in the coordinates.\n    'squared Euclidean distance': The square of the Euclidean distance, which is used for simplification in certain calculations.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps should be implemented sequentially as each cell's nearest pole must", "Round_0": {"code": "def main():\n    # Read the grid size\n    n, m = map(int, input().split())\n    \n    # Initialize the grid\n    grid = []\n    \n    # Read the grid input\n    for _ in range(n + 1):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    # Function to calculate the squared Euclidean distance\n    def calculate_squared_distance(x, y, grid):\n        min_distance_squared = float('inf')\n        for i in range(n + 1):\n            for j in range(m + 1):\n                if grid[i][j] == 1:\n                    distance_squared = (x - i) ** 2 + (y - j) ** 2\n                    if distance_squared < min_distance_squared:\n                        min_distance_squared = distance_squared\n        return min_distance_squared\n    \n    # Calculate the sum of squared distances\n    total_sum = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            total_sum += calculate_squared_distance(x, y, grid)\n    \n    # Output the total sum of squared distances\n    print(total_sum)", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 106)"}, "Round_1": {"code": "def main():\n    # Read the grid size\n    n, m = map(int, input().split())\n    \n    # Initialize the grid\n    grid = []\n    \n    # Read the grid input and store it in a 2D array\n    for _ in range(n + 1):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    # Function to calculate the squared Euclidean distance\n    def calculate_squared_distance(x, y, grid):\n        min_distance_squared = float('inf')\n        for i in range(n + 1):\n            for j in range(m + 1):\n                if grid[i][j] == 1:\n                    distance_squared = (x - i) ** 2 + (y - j) ** 2\n                    if distance_squared < min_distance_squared:\n                        min_distance_squared = distance_squared\n        return min_distance_squared\n    \n    # Calculate the sum of squared distances\n    total_sum = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            total_sum += calculate_squared_distance(x, y, grid)\n    \n    # Output the total sum of squared distances\n    print(total_sum)"}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 2, "examples": "\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "mutate_method": "rephrase_one", "save_node": true, "parent_index": 2}
