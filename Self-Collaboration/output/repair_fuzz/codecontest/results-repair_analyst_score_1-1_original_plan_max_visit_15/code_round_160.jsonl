{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "repair_prompt": ["Monocarp is the coach of the Berland State University programming teams and decided to create a set of problems for a training session for his teams. Monocarp has n problems that none of his students have seen yet, where the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n); all problems are different, meaning there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset, and the problems should satisfy at least one of two conditions (possibly, both): * the topics of all three selected problems are different; * the difficulties of all three selected problems are different. Your task is to calculate the number of methods to choose three problems for the problemset. Make sure to consider edge cases where the number of problems n might be small. Think about scenarios where the constraints on topic and difficulty do not allow forming a valid problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp decided to select exactly 3 problems from n problems for the problemset, all problems should satisfy at least one of two conditions: the topics of all three selected problems are different, or the difficulties of all three selected problems are different. Calculate the number of methods to choose three problems for the problemset, considering scenarios where constraints on topic and difficulty do not allow forming a valid problemset, especially when the number of problems n is small.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp, the coach of Berland State University programming teams, wants to create a set of problems for training sessions, where the i-th problem has a topic a_i and a difficulty b_i, selecting 3 problems that meet specific conditions. Calculate the number of methods to choose three problems for the problem set, even with small values of n that could result in scenarios where forming a valid problem set is not possible.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "from itertools import combinations\n\ndef count_valid_combinations(n, problems):\n    topics = set()\n    difficulties = set()\n    valid_combinations = 0\n    \n    for i in range(n):\n        topics.add(problems[i][0])\n        difficulties.add(problems[i][1])\n    \n    if n < 3 or (len(topics) >= 3 and len(difficulties) >= 3):\n        return 0\n    \n    for comb in combinations(problems, 3):\n        comb_topics = set()\n        comb_difficulties = set()\n        \n        for problem in comb:\n            comb_topics.add(problem[0])\n            comb_difficulties.add(problem[1])\n        \n        if len(comb_topics) == 3 or len(comb_difficulties) == 3:\n            valid_combinations += 1\n    \n    return valid_combinations\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    result = count_valid_combinations(n, problems)\n    print(result)\n\nmain()", "completions": ["from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Initialize a counter for valid sets of problems\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        \n        # Check if the combination meets the requirements\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        # If the combination meets the requirements, increment the counter\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n\nmain()", "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Initialize a counter for valid sets of problems\n    count = 0\n    \n    # Generate all possible combinations of 3 problems\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        \n        # Check if the combination meets the requirements\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        # If the combination meets the requirements, increment the counter\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n\nmain()", "from itertools import combinations\n\ndef count_valid_combinations(problems):\n    topics = set()\n    difficulties = set()\n    valid_combinations = 0\n    \n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    \n    if len(topics) >= 3 or len(difficulties) >= 3:\n        return len(list(combinations(problems, 3)))\n    \n    return valid_combinations\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    result = count_valid_combinations(problems)\n    print(result)\n\nmain()", "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Initialize a counter for valid sets of problems\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        \n        # Check if the combination meets the requirements\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        # If the combination meets the requirements, increment the counter\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n\nmain()", "from itertools import combinations\n\ndef count_valid_combinations(n, problems):\n    topics = set()\n    difficulties = set()\n    valid_combinations = 0\n    \n    for i in range(n):\n        topics.add(problems[i][0])\n        difficulties.add(problems[i][1])\n    \n    if n < 3 or len(topics) < 3 or len(difficulties) < 3:\n        return 0\n    \n    for comb in combinations(problems, 3):\n        comb_topics = set()\n        comb_difficulties = set()\n        \n        for problem in comb:\n            comb_topics.add(problem[0])\n            comb_difficulties.add(problem[1])\n        \n        if len(comb_topics) == 3 or len(comb_difficulties) == 3:\n            valid_combinations += 1\n    \n    return valid_combinations\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    result = count_valid_combinations(n, problems)\n    print(result)\n\nmain()", "from collections import defaultdict\n\ndef calculate_ways_to_select_problems(testcases):\n    def count_pairs(arr):\n        freq = defaultdict(int)\n        for a, b in arr:\n            freq[(a, b)] += 1\n        return sum(v * (v - 1) // 2 for v in freq.values())\n\n    results = []\n    for problems in testcases:\n        topics = defaultdict(list)\n        difficulties = defaultdict(list)\n        for i, (a, b) in enumerate(problems):\n            topics[a].append(i)\n            difficulties[b].append(i)\n\n        valid_topics = sum(len(v) >= 3 for v in topics.values())\n        valid_difficulties = sum(len(v) >= 3 for v in difficulties.values())\n        valid_both = sum(len(set(topics[a]) & set(difficulties[b])) >= 3 for a, b in problems)\n\n        total_ways = count_pairs(problems) - valid_topics - valid_difficulties + valid_both\n        results.append(total_ways)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        testcases.append(problems)\n\n    results = calculate_ways_to_select_problems(testcases)\n    for res in results:\n        print(res)\n\nmain()", "from collections import defaultdict\n\ndef calculate_ways_to_select_problems(t, testcases):\n    def count_unique_topics_difficulties(problems):\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        for topic, difficulty in problems:\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n        return topics, difficulties\n\n    def calculate_combinations(n):\n        return n * (n - 1) * (n - 2) // 6\n\n    results = []\n    for _ in range(t):\n        n = testcases[_][0]\n        problems = testcases[_][1:]\n        topics, difficulties = count_unique_topics_difficulties(problems)\n\n        unique_topics = sum(1 for topic in topics if topics[topic] >= 1)\n        unique_difficulties = sum(1 for difficulty in difficulties if difficulties[difficulty] >= 1)\n\n        if unique_topics >= 3 or unique_difficulties >= 3:\n            results.append(calculate_combinations(n))\n        else:\n            valid_sets = 0\n            for i in range(n):\n                for j in range(i + 1, n):\n                    for k in range(j + 1, n):\n                        if problems[i][0] != problems[j][0] and problems[j][0] != problems[k][0] and problems[i][0] != problems[k][0]:\n                            valid_sets += 1\n                        elif problems[i][1] != problems[j][1] and problems[j][1] != problems[k][1] and problems[i][1] != problems[k][1]:\n                            valid_sets += 1\n            results.append(valid_sets)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        testcases.append((n, problems))\n\n    results = calculate_ways_to_select_problems(t, testcases)\n\n    for result in results:\n        print(result)\n\nmain()", "def calculate_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        min_selection = min(n, 3)\n        max_selection = min(3, len(topics), len(difficulties))\n        \n        ways = max(0, n - 2) * max(0, n - 1) * max(0, n) // 6\n        \n        for i in range(1, min_selection + 1):\n            ways -= max(0, n - i - 1) * max(0, n - i) // 2\n        \n        for i in range(1, max_selection + 1):\n            ways += max(0, n - i - 1) * max(0, n - i) // 2\n        \n        print(ways)\n\ncalculate_ways_to_select_problems()\n\nmain()", "def calculate_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = {}\n        difficulties = {}\n        \n        for i in range(n):\n            a, b = map(int, input().split())\n            topics[a] = topics.get(a, 0) + 1\n            difficulties[b] = difficulties.get(b, 0) + 1\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        same_topic = sum(val * (val - 1) * (val - 2) // 6 for val in topics.values())\n        same_difficulty = sum(val * (val - 1) * (val - 2) // 6 for val in difficulties.values())\n        \n        same_topic_difficulty = 0\n        for val in topics.values():\n            same_topic_difficulty += val * (val - 1) // 2 * (n - val)\n        \n        result = total_ways - same_topic - same_difficulty + same_topic_difficulty\n        print(result)\n\ncalculate_ways_to_select_problems()\n\nmain()", "from itertools import combinations\n\ndef count_valid_combinations(n, problems):\n    topics = set()\n    difficulties = set()\n    valid_combinations = 0\n    \n    for i in range(n):\n        topics.add(problems[i][0])\n        difficulties.add(problems[i][1])\n    \n    if n < 3 or (len(topics) >= 3 and len(difficulties) >= 3):\n        return 0\n    \n    for comb in combinations(problems, 3):\n        comb_topics = set()\n        comb_difficulties = set()\n        \n        for problem in comb:\n            comb_topics.add(problem[0])\n            comb_difficulties.add(problem[1])\n        \n        if len(comb_topics) == 3 or len(comb_difficulties) == 3:\n            valid_combinations += 1\n    \n    return valid_combinations\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    result = count_valid_combinations(n, problems)\n    print(result)\n\nmain()"], "session_history": {"plan": "{\n  \"subproblems\": [\n    \"Identify all possible combinations of 3 problems from the given list\",\n    \"Check if the topics of the selected problems are different\",\n    \"Check if the difficulties of the selected problems are different\",\n    \"Count the number of valid combinations that satisfy either of the conditions\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases (t)\",\n    \"Step 2\": \"For each testcase, read the number of problems (n)\",\n    \"Step 3\": \"Read the topic and difficulty of each problem\",\n    \"Step 4\": \"Generate all possible combinations of 3 problems\",\n    \"Step 5\": \"Check if the topics of the selected problems are different\",\n    \"Step 6\": \"Check if the difficulties of the selected problems are different\",\n    \"Step 7\": \"Count the number of valid combinations that satisfy either of the conditions\",\n    \"Step 8\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is to choose exactly 3 problems from a given list of problems, ensuring that they satisfy certain conditions related to topics and difficulties.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve different checks and calculations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, all problems have the same topic and difficulty, so there is only one way to select 3 problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    0\n    Explanation: When all problems have unique topics and difficulties, it is not possible to select 3 problems that satisfy the conditions.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: In this case, all combinations of 3 problems satisfy the conditions, resulting in 10 valid ways to select problems.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "from itertools import combinations\n\ndef count_valid_combinations(n, problems):\n    topics = set()\n    difficulties = set()\n    valid_combinations = 0\n    \n    for i in range(n):\n        topics.add(problems[i][0])\n        difficulties.add(problems[i][1])\n    \n    if n < 3 or (len(topics) >= 3 and len(difficulties) >= 3):\n        return 0\n    \n    for comb in combinations(problems, 3):\n        comb_topics = set()\n        comb_difficulties = set()\n        \n        for problem in comb:\n            comb_topics.add(problem[0])\n            comb_difficulties.add(problem[1])\n        \n        if len(comb_topics) == 3 or len(comb_difficulties) == 3:\n            valid_combinations += 1\n    \n    return valid_combinations\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    result = count_valid_combinations(n, problems)\n    print(result)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "from itertools import combinations\n\ndef count_valid_combinations(n, problems):\n    topics = set()\n    difficulties = set()\n    valid_combinations = 0\n    \n    for i in range(n):\n        topics.add(problems[i][0])\n        difficulties.add(problems[i][1])\n    \n    if n < 3 or (len(topics) >= 3 and len(difficulties) >= 3):\n        return 0\n    \n    for comb in combinations(problems, 3):\n        comb_topics = set()\n        comb_difficulties = set()\n        \n        for problem in comb:\n            comb_topics.add(problem[0])\n            comb_difficulties.add(problem[1])\n        \n        if len(comb_topics) == 3 or len(comb_difficulties) == 3:\n            valid_combinations += 1\n    \n    return valid_combinations\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    result = count_valid_combinations(n, problems)\n    print(result)\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, calculate the number of ways to select three training problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases from input\",\n    \"Step 2\": \"For each testcase, read the number of problems and their details\",\n    \"Step 3\": \"Calculate the number of ways to select three training problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topic', 'difficulty'\n    Explanation: The core concepts in the requirement are the topics and difficulties of the problems that need to be considered when selecting the training problems.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve different calculations for each testcase.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: With only 3 problems and each having unique topics and difficulties, there is only one way to select three training problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All problems have unique topics and difficulties, so there are 4 ways to select three training problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: All problems have unique topics and difficulties, so there are 10 ways to select three training problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to calculate the number of ways to select three training problems can handle all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Initialize a counter for valid sets of problems\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        \n        # Check if the combination meets the requirements\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        # If the combination meets the requirements, increment the counter\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 39)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Initialize a counter for valid sets of problems\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        \n        # Check if the combination meets the requirements\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        # If the combination meets the requirements, increment the counter\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, calculate the number of ways to select three training problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases from input\",\n    \"Step 2\": \"For each testcase, read the number of problems and their details\",\n    \"Step 3\": \"Calculate the number of ways to select three training problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topic', 'difficulty'\n    Explanation: The core concepts in the requirement are the topics and difficulties of the problems that need to be considered when selecting the training problems.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, calculating the number of ways, and outputting the result.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: With only 3 problems and each having different topics and difficulties, there is only one way to select three training problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All problems have different topics and difficulties, so there are 4 ways to select three training problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: All problems have different topics and difficulties, so there are 10 ways to select three training problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to calculate the number of ways to select three training problems already considers scenarios where forming a valid problem set is not possible.\n\nNO", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Initialize a counter for valid sets of problems\n    count = 0\n    \n    # Generate all possible combinations of 3 problems\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        \n        # Check if the combination meets the requirements\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        # If the combination meets the requirements, increment the counter\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 39)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Initialize a counter for valid sets of problems\n    count = 0\n    \n    # Generate all possible combinations of 3 problems\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        \n        # Check if the combination meets the requirements\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        # If the combination meets the requirements, increment the counter\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify all possible combinations of 3 problems from the given list\",\n    \"Check if the topics of the selected problems are different\",\n    \"Check if the difficulties of the selected problems are different\",\n    \"Count the number of valid combinations that satisfy either of the conditions\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases (t)\",\n    \"Step 2\": \"For each testcase, read the number of problems (n)\",\n    \"Step 3\": \"Read the topic and difficulty of each problem\",\n    \"Step 4\": \"Generate all possible combinations of 3 problems\",\n    \"Step 5\": \"Check if the topics of the selected problems are different\",\n    \"Step 6\": \"Check if the difficulties of the selected problems are different\",\n    \"Step 7\": \"Count the number of valid combinations that satisfy either of the conditions\",\n    \"Step 8\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is to choose exactly 3 problems from a given list of problems, ensuring they meet specific criteria regarding topics and difficulties.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve different checks and calculations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    0\n    Explanation: In this case, all problems have the same topic and difficulty, making it impossible to select 3 problems that meet the given conditions.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: Each problem has a unique topic and difficulty, allowing for 4 valid combinations of 3 problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: All problems have different topics and difficulties, providing 10 valid combinations of 3 problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of checking for unique topics and difficulties will naturally handle these scenarios.", "Round_0": {"code": "from itertools import combinations\n\ndef count_valid_combinations(problems):\n    topics = set()\n    difficulties = set()\n    valid_combinations = 0\n    \n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    \n    if len(topics) >= 3 or len(difficulties) >= 3:\n        return len(list(combinations(problems, 3)))\n    \n    return valid_combinations\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    result = count_valid_combinations(problems)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 39)"}, "Round_1": {"code": "from itertools import combinations\n\ndef count_valid_combinations(problems):\n    topics = set()\n    difficulties = set()\n    valid_combinations = 0\n    \n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    \n    if len(topics) >= 3 or len(difficulties) >= 3:\n        return len(list(combinations(problems, 3)))\n    \n    return valid_combinations\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    result = count_valid_combinations(problems)\n    print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, calculate the number of ways to select three training problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases from input\",\n    \"Step 2\": \"For each testcase, read the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Calculate the number of ways to select three training problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topic': Refers to the subject or category of the problem.\n    'difficulty': Indicates the level of complexity or challenge of the problem.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented sequentially as they involve different aspects of processing the input and calculating the output.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: With only 3 problems and unique topics and difficulties, there is only one way to select three training problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: In this case, all 4 problems have different topics and difficulties, so there are 4 ways to select three training problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: With 5 unique problems, there are 10 ways to select three training problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic for selecting three problems can handle scenarios where forming a valid problem set is not possible.", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Initialize a counter for valid sets of problems\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        \n        # Check if the combination meets the requirements\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        # If the combination meets the requirements, increment the counter\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 39)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Initialize a counter for valid sets of problems\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        \n        # Check if the combination meets the requirements\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        # If the combination meets the requirements, increment the counter\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify all possible combinations of 3 problems from the given list\",\n    \"Check if the topics of the selected problems are different\",\n    \"Check if the difficulties of the selected problems are different\",\n    \"Count the number of valid combinations that satisfy either of the conditions\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases (t)\",\n    \"Step 2\": \"For each testcase, read the number of problems (n)\",\n    \"Step 3\": \"Read the topic and difficulty of each problem\",\n    \"Step 4\": \"Generate all possible combinations of 3 problems\",\n    \"Step 5\": \"Check if the topics of the selected problems are different\",\n    \"Step 6\": \"Check if the difficulties of the selected problems are different\",\n    \"Step 7\": \"Count the number of valid combinations that satisfy either of the conditions\",\n    \"Step 8\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is to choose exactly 3 problems from a given list of problems, ensuring that they satisfy certain conditions related to topics and difficulties.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they involve different checks and calculations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, all problems have the same topic and difficulty, making it impossible to select 3 problems that satisfy the conditions.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    0\n    Explanation: Here, all problems have unique topics and difficulties, but there are only 4 problems, which is not enough to select 3 problems that satisfy the conditions.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: In this case, all problems have unique topics and difficulties, allowing for 10 valid combinations of 3 problems.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "from itertools import combinations\n\ndef count_valid_combinations(n, problems):\n    topics = set()\n    difficulties = set()\n    valid_combinations = 0\n    \n    for i in range(n):\n        topics.add(problems[i][0])\n        difficulties.add(problems[i][1])\n    \n    if n < 3 or len(topics) < 3 or len(difficulties) < 3:\n        return 0\n    \n    for comb in combinations(problems, 3):\n        comb_topics = set()\n        comb_difficulties = set()\n        \n        for problem in comb:\n            comb_topics.add(problem[0])\n            comb_difficulties.add(problem[1])\n        \n        if len(comb_topics) == 3 or len(comb_difficulties) == 3:\n            valid_combinations += 1\n    \n    return valid_combinations\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    result = count_valid_combinations(n, problems)\n    print(result)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "from itertools import combinations\n\ndef count_valid_combinations(n, problems):\n    topics = set()\n    difficulties = set()\n    valid_combinations = 0\n    \n    for i in range(n):\n        topics.add(problems[i][0])\n        difficulties.add(problems[i][1])\n    \n    if n < 3 or len(topics) < 3 or len(difficulties) < 3:\n        return 0\n    \n    for comb in combinations(problems, 3):\n        comb_topics = set()\n        comb_difficulties = set()\n        \n        for problem in comb:\n            comb_topics.add(problem[0])\n            comb_difficulties.add(problem[1])\n        \n        if len(comb_topics) == 3 or len(comb_difficulties) == 3:\n            valid_combinations += 1\n    \n    return valid_combinations\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    result = count_valid_combinations(n, problems)\n    print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, calculate the number of ways to select three training problems that meet the requirements\",\n    \"Handle edge cases where the constraints on topic and difficulty do not allow forming a valid problemset\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Calculate the number of ways to select three training problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\",\n    \"Step 5\": \"Handle edge cases where a valid problemset cannot be formed\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties', 'selecting problems'\n    Explanation: The core concept involves selecting three problems that meet certain conditions based on their topics and difficulties.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, calculating ways to select problems, and handling edge cases.\n\n# [edge case] \n    Testcase 1:\n    4\n    2 4\n    3 4\n    2 1\n    1 3\n    Output\n    3\n    Explanation: The valid sets are (1, 2, 4), (1, 3, 4), (2, 3, 4).\n    \n    Testcase 2:\n    5\n    1 5\n    2 4\n    3 3\n    4 2\n    5 1\n    Output\n    10\n    Explanation: There are 10 ways to select three problems that meet the requirements.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling edge cases)", "Round_0": {"code": "from collections import defaultdict\n\ndef calculate_ways_to_select_problems(testcases):\n    def count_pairs(arr):\n        freq = defaultdict(int)\n        for a, b in arr:\n            freq[(a, b)] += 1\n        return sum(v * (v - 1) // 2 for v in freq.values())\n\n    results = []\n    for problems in testcases:\n        topics = defaultdict(list)\n        difficulties = defaultdict(list)\n        for i, (a, b) in enumerate(problems):\n            topics[a].append(i)\n            difficulties[b].append(i)\n\n        valid_topics = sum(len(v) >= 3 for v in topics.values())\n        valid_difficulties = sum(len(v) >= 3 for v in difficulties.values())\n        valid_both = sum(len(set(topics[a]) & set(difficulties[b])) >= 3 for a, b in problems)\n\n        total_ways = count_pairs(problems) - valid_topics - valid_difficulties + valid_both\n        results.append(total_ways)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        testcases.append(problems)\n\n    results = calculate_ways_to_select_problems(testcases)\n    for res in results:\n        print(res)\n", "report": "The compilation output of the preceding code is: closing parenthesis ')' does not match opening parenthesis '[' (<string>, line 40)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef calculate_ways_to_select_problems(testcases):\n    def count_pairs(arr):\n        freq = defaultdict(int)\n        for a, b in arr:\n            freq[(a, b)] += 1\n        return sum(v * (v - 1) // 2 for v in freq.values())\n\n    results = []\n    for problems in testcases:\n        topics = defaultdict(list)\n        difficulties = defaultdict(list)\n        for i, (a, b) in enumerate(problems):\n            topics[a].append(i)\n            difficulties[b].append(i)\n\n        valid_topics = sum(len(v) >= 3 for v in topics.values())\n        valid_difficulties = sum(len(v) >= 3 for v in difficulties.values())\n        valid_both = sum(len(set(topics[a]) & set(difficulties[b])) >= 3 for a, b in problems)\n\n        total_ways = count_pairs(problems) - valid_topics - valid_difficulties + valid_both\n        results.append(total_ways)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        testcases.append(problems)\n\n    results = calculate_ways_to_select_problems(testcases)\n    for res in results:\n        print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, calculate the number of ways to select three training problems that meet the requirements\",\n    \"Handle edge cases where the constraints on topic and difficulty do not allow forming a valid problemset\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Calculate the number of ways to select three training problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\",\n    \"Step 5\": \"Handle edge cases where a valid problemset cannot be formed\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties', 'selecting problems'\n    Explanation: The core concept involves selecting 3 problems based on different topics or difficulties.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    There are no steps that should be implemented simultaneously. Each step should be executed sequentially as outlined in the plan.\n\n# [edge case] \n    Testcase 1:\n    4\n    2 4\n    3 4\n    2 1\n    1 3\n    Output\n    3\n    Explanation: The valid sets are (1, 2, 4), (1, 3, 4), (2, 3, 4).\n    \n    Testcase 2:\n    5\n    1 5\n    2 4\n    3 3\n    4 2\n    5 1\n    Output\n    10\n    Explanation: All combinations of 3 problems can be selected.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling edge cases where a valid problemset cannot be formed)", "Round_0": {"code": "from collections import defaultdict\n\ndef calculate_ways_to_select_problems(t, testcases):\n    def count_unique_topics_difficulties(problems):\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        for topic, difficulty in problems:\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n        return topics, difficulties\n\n    def calculate_combinations(n):\n        return n * (n - 1) * (n - 2) // 6\n\n    results = []\n    for _ in range(t):\n        n = testcases[_][0]\n        problems = testcases[_][1:]\n        topics, difficulties = count_unique_topics_difficulties(problems)\n\n        unique_topics = sum(1 for topic in topics if topics[topic] >= 1)\n        unique_difficulties = sum(1 for difficulty in difficulties if difficulties[difficulty] >= 1)\n\n        if unique_topics >= 3 or unique_difficulties >= 3:\n            results.append(calculate_combinations(n))\n        else:\n            valid_sets = 0\n            for i in range(n):\n                for j in range(i + 1, n):\n                    for k in range(j + 1, n):\n                        if problems[i][0] != problems[j][0] and problems[j][0] != problems[k][0] and problems[i][0] != problems[k][0]:\n                            valid_sets += 1\n                        elif problems[i][1] != problems[j][1] and problems[j][1] != problems[k][1] and problems[i][1] != problems[k][1]:\n                            valid_sets += 1\n            results.append(valid_sets)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        testcases.append((n, problems))\n\n    results = calculate_ways_to_select_problems(t, testcases)\n\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: closing parenthesis ')' does not match opening parenthesis '[' (<string>, line 53)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef calculate_ways_to_select_problems(t, testcases):\n    def count_unique_topics_difficulties(problems):\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        for topic, difficulty in problems:\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n        return topics, difficulties\n\n    def calculate_combinations(n):\n        return n * (n - 1) * (n - 2) // 6\n\n    results = []\n    for _ in range(t):\n        n = testcases[_][0]\n        problems = testcases[_][1:]\n        topics, difficulties = count_unique_topics_difficulties(problems)\n\n        unique_topics = sum(1 for topic in topics if topics[topic] >= 1)\n        unique_difficulties = sum(1 for difficulty in difficulties if difficulties[difficulty] >= 1)\n\n        if unique_topics >= 3 or unique_difficulties >= 3:\n            results.append(calculate_combinations(n))\n        else:\n            valid_sets = 0\n            for i in range(n):\n                for j in range(i + 1, n):\n                    for k in range(j + 1, n):\n                        if problems[i][0] != problems[j][0] and problems[j][0] != problems[k][0] and problems[i][0] != problems[k][0]:\n                            valid_sets += 1\n                        elif problems[i][1] != problems[j][1] and problems[j][1] != problems[k][1] and problems[i][1] != problems[k][1]:\n                            valid_sets += 1\n            results.append(valid_sets)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        testcases.append((n, problems))\n\n    results = calculate_ways_to_select_problems(t, testcases)\n\n    for result in results:\n        print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, calculate the number of ways to select three training problems that meet the requirements\",\n    \"Handle edge cases where the constraints on topic and difficulty do not allow forming a valid problemset\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Calculate the number of ways to select three training problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\",\n    \"Step 5\": \"Handle edge cases where a valid problemset cannot be formed\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties', 'selecting problems'\n    Explanation: The core concept involves selecting 3 problems that satisfy certain conditions based on their topics and difficulties.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, calculating ways to select problems, and handling edge cases.\n\n# [edge case] \n    Testcase 1:\n    Input:\n    4\n    2 4\n    3 4\n    2 1\n    1 3\n    Output:\n    3\n    Explanation: Three possible sets of problems can be selected: (1, 2, 4), (1, 3, 4), (2, 3, 4).\n\n    Testcase 2:\n    Input:\n    5\n    1 5\n    2 4\n    3 3\n    4 2\n    5 1\n    Output:\n    10\n    Explanation: There are 10 ways to select 3 problems satisfying the conditions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling edge cases)", "Round_0": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        min_selection = min(n, 3)\n        max_selection = min(3, len(topics), len(difficulties))\n        \n        ways = max(0, n - 2) * max(0, n - 1) * max(0, n) // 6\n        \n        for i in range(1, min_selection + 1):\n            ways -= max(0, n - i - 1) * max(0, n - i) // 2\n        \n        for i in range(1, max_selection + 1):\n            ways += max(0, n - i - 1) * max(0, n - i) // 2\n        \n        print(ways)\n\ncalculate_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        min_selection = min(n, 3)\n        max_selection = min(3, len(topics), len(difficulties))\n        \n        ways = max(0, n - 2) * max(0, n - 1) * max(0, n) // 6\n        \n        for i in range(1, min_selection + 1):\n            ways -= max(0, n - i - 1) * max(0, n - i) // 2\n        \n        for i in range(1, max_selection + 1):\n            ways += max(0, n - i - 1) * max(0, n - i) // 2\n        \n        print(ways)\n\ncalculate_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, calculate the number of ways to select three training problems that meet the requirements\",\n    \"Handle edge cases where the constraints on topic and difficulty do not allow forming a valid problemset\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Calculate the number of ways to select three training problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\",\n    \"Step 5\": \"Handle edge cases where a valid problemset cannot be formed\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties', 'selecting problems'\n    Explanation: The core concept involves selecting 3 problems that satisfy certain conditions based on their topics and difficulties.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, calculating ways to select problems, and handling edge cases.\n\n# [edge case] \n    Testcase 1:\n    4\n    2 4\n    3 4\n    2 1\n    1 3\n    Output: 3\n    Explanation: Three possible sets of problems can be selected: (1, 2, 4), (1, 3, 4), (2, 3, 4).\n\n    Testcase 2:\n    5\n    1 5\n    2 4\n    3 3\n    4 2\n    5 1\n    Output: 10\n    Explanation: There are 10 ways to select 3 problems that meet the requirements.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling edge cases) \n\nNO", "Round_0": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = {}\n        difficulties = {}\n        \n        for i in range(n):\n            a, b = map(int, input().split())\n            topics[a] = topics.get(a, 0) + 1\n            difficulties[b] = difficulties.get(b, 0) + 1\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        same_topic = sum(val * (val - 1) * (val - 2) // 6 for val in topics.values())\n        same_difficulty = sum(val * (val - 1) * (val - 2) // 6 for val in difficulties.values())\n        \n        same_topic_difficulty = 0\n        for val in topics.values():\n            same_topic_difficulty += val * (val - 1) // 2 * (n - val)\n        \n        result = total_ways - same_topic - same_difficulty + same_topic_difficulty\n        print(result)\n\ncalculate_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 33)"}, "Round_1": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = {}\n        difficulties = {}\n        \n        for i in range(n):\n            a, b = map(int, input().split())\n            topics[a] = topics.get(a, 0) + 1\n            difficulties[b] = difficulties.get(b, 0) + 1\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        same_topic = sum(val * (val - 1) * (val - 2) // 6 for val in topics.values())\n        same_difficulty = sum(val * (val - 1) * (val - 2) // 6 for val in difficulties.values())\n        \n        same_topic_difficulty = 0\n        for val in topics.values():\n            same_topic_difficulty += val * (val - 1) // 2 * (n - val)\n        \n        result = total_ways - same_topic - same_difficulty + same_topic_difficulty\n        print(result)\n\ncalculate_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify all possible combinations of 3 problems from the given list\",\n    \"Check if the topics of the selected problems are different\",\n    \"Check if the difficulties of the selected problems are different\",\n    \"Count the number of valid combinations that satisfy either of the conditions\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases (t)\",\n    \"Step 2\": \"For each testcase, read the number of problems (n)\",\n    \"Step 3\": \"Read the topic and difficulty of each problem\",\n    \"Step 4\": \"Generate all possible combinations of 3 problems\",\n    \"Step 5\": \"Check if the topics of the selected problems are different\",\n    \"Step 6\": \"Check if the difficulties of the selected problems are different\",\n    \"Step 7\": \"Count the number of valid combinations that satisfy either of the conditions\",\n    \"Step 8\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is to choose exactly 3 problems from a given list of problems, ensuring that they satisfy certain conditions related to topics and difficulties.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve different checks and calculations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, all problems have the same topic and difficulty, so there is only one way to select 3 problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    0\n    Explanation: When all problems have unique topics and difficulties, it is not possible to select 3 problems that satisfy the conditions.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: In this case, all combinations of 3 problems satisfy the conditions, resulting in 10 valid ways to select problems.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "from itertools import combinations\n\ndef count_valid_combinations(n, problems):\n    topics = set()\n    difficulties = set()\n    valid_combinations = 0\n    \n    for i in range(n):\n        topics.add(problems[i][0])\n        difficulties.add(problems[i][1])\n    \n    if n < 3 or (len(topics) >= 3 and len(difficulties) >= 3):\n        return 0\n    \n    for comb in combinations(problems, 3):\n        comb_topics = set()\n        comb_difficulties = set()\n        \n        for problem in comb:\n            comb_topics.add(problem[0])\n            comb_difficulties.add(problem[1])\n        \n        if len(comb_topics) == 3 or len(comb_difficulties) == 3:\n            valid_combinations += 1\n    \n    return valid_combinations\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    result = count_valid_combinations(n, problems)\n    print(result)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "from itertools import combinations\n\ndef count_valid_combinations(n, problems):\n    topics = set()\n    difficulties = set()\n    valid_combinations = 0\n    \n    for i in range(n):\n        topics.add(problems[i][0])\n        difficulties.add(problems[i][1])\n    \n    if n < 3 or (len(topics) >= 3 and len(difficulties) >= 3):\n        return 0\n    \n    for comb in combinations(problems, 3):\n        comb_topics = set()\n        comb_difficulties = set()\n        \n        for problem in comb:\n            comb_topics.add(problem[0])\n            comb_difficulties.add(problem[1])\n        \n        if len(comb_topics) == 3 or len(comb_difficulties) == 3:\n            valid_combinations += 1\n    \n    return valid_combinations\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    result = count_valid_combinations(n, problems)\n    print(result)\n"}}], "scores": [], "pass_results": [false, false, true, false, false, true, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 160, "prompt": "Monocarp is the coach of the Berland State University programming teams and decided to create a set of problems for a training session for his teams. Monocarp has n problems that none of his students have seen yet, where the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n); all problems are different, meaning there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset, and the problems should satisfy at least one of two conditions (possibly, both): * the topics of all three selected problems are different; * the difficulties of all three selected problems are different. Your task is to calculate the number of methods to choose three problems for the problemset. Make sure to consider edge cases where the number of problems n might be small. Think about scenarios where the constraints on topic and difficulty do not allow forming a valid problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 108}
