{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "repair_prompt": ["Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet. Each of these problems is defined by its topic and difficulty: the i-th problem has a topic a_i (an integer from 1 to n). Furthermore, it has a difficulty b_i (an integer from 1 to n), with all problems being different, meaning there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp decided to select exactly 3 problems from n problems for the problemset, ensuring that the topics and difficulties of the selected problems are all different. Your task is to determine the number of ways to select three problems for the problemset while satisfying these conditions.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp has n problems that none of his students have seen yet, defined by topic and difficulty. He decided to select exactly 3 problems that satisfy specific conditions - determine the number of ways to do so.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a set to store unique topics and difficulties\n    topics_difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        topic, difficulty = map(int, input().split())\n        topics_difficulties.add((topic, difficulty))\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    for comb in combinations(topics_difficulties, 3):\n        # Check if the topics and difficulties are all different\n        if len(set([topic for topic, _ in comb])) == 3 and len(set([difficulty for _, difficulty in comb])) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n\nmain()", "completions": ["def calculate_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            topic, difficulty = map(int, input().split())\n            problems.append((topic, difficulty))\n        \n        ways = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if problems[i][0] == problems[j][0] or problems[i][0] == problems[k][0] or problems[j][0] == problems[k][0]:\n                        ways += 1\n                    elif problems[i][1] == problems[j][1] or problems[i][1] == problems[k][1] or problems[j][1] == problems[k][1]:\n                        ways += 1\n        \n        print(ways)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    calculate_ways_to_select_problems(testcases)\n\nmain()", "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a set to store unique topics and difficulties\n    topics = set()\n    difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        topics.add(a)\n        difficulties.add(b)\n    \n    # Calculate the number of ways to select 3 problems with different topics and difficulties\n    num_ways = len(list(combinations(range(1, n+1), 3)))\n    \n    print(num_ways)\n\nmain()", "from itertools import combinations\n\n# Function to determine the number of ways to select three problems that meet the requirements\ndef select_problems(testcases):\n    results = []\n    \n    for problems in testcases:\n        topics = set()\n        difficulties = set()\n        \n        for problem in problems:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        if len(topics) >= 3 or len(difficulties) >= 3:\n            results.append(len(list(combinations(problems, 3)))\n        else:\n            valid_combinations = 0\n            for comb in combinations(problems, 3):\n                if len(set([topic for topic, _ in comb])) == 3 or len(set([diff for _, diff in comb])) == 3:\n                    valid_combinations += 1\n            results.append(valid_combinations)\n    \n    return results\n\n# Parse the input to extract the number of testcases and the details of each testcase\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    testcases.append(problems)\n\n# Determine the number of ways to select three problems for each testcase\nresults = select_problems(testcases)\n\n# Output the result for each testcase\nfor result in results:\n    print(result)\n\nmain()", "def count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if (problems[i][0] == problems[j][0] == problems[k][0]) or (problems[i][1] == problems[j][1] == problems[k][1]):\n                        count += 1\n        \n        print(count)\n\ncount_ways_to_select_problems()\n\nmain()", "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a set to store unique topics and difficulties\n    topics_difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        topic, difficulty = map(int, input().split())\n        topics_difficulties.add((topic, difficulty))\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    for comb in combinations(topics_difficulties, 3):\n        # Check if the selected problems have different topics and difficulties\n        if len(set([topic for topic, _ in comb])) == 3 and len(set([difficulty for _, difficulty in comb])) == 3:\n            count += 1\n    \n    # Output the total number of valid combinations for each testcase\n    print(count)\n\nmain()", "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize a list to store the topics and difficulties of each problem\n    problems = []\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Initialize a counter for the number of ways to select three training problems\n    count = 0\n    \n    # Generate all possible combinations of 3 problems\n    problem_combinations = combinations(problems, 3)\n    \n    # Check each combination if it meets the requirements\n    for comb in problem_combinations:\n        topics = set()\n        difficulties = set()\n        for prob in comb:\n            topics.add(prob[0])\n            difficulties.add(prob[1])\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n\nmain()", "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize a list to store the topics and difficulties of each problem\n    problems = []\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Generate all possible combinations of 3 problems\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        \n        # Check if the topics or difficulties of the selected problems are different\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n\nmain()", "from itertools import combinations\n\ndef check_topics_diff(topics, difficulties):\n    return len(set(topics)) == 3 or len(set(difficulties)) == 3\n\ndef count_ways_to_select_problems(n, problems):\n    total_ways = 0\n    for comb in combinations(problems, 3):\n        topics = [topic for topic, _ in comb]\n        difficulties = [diff for _, diff in comb]\n        if check_topics_diff(topics, difficulties):\n            total_ways += 1\n    return total_ways\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    ways = count_ways_to_select_problems(n, problems)\n    print(ways)\n\nmain()", "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize a set to store unique topics and difficulties\n    topics = set()\n    difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        topics.add(a)\n        difficulties.add(b)\n    \n    # Calculate the number of ways to select 3 problems\n    num_ways = 0\n    if n >= 3:\n        num_ways += len(list(combinations(range(1, n+1), 3)))\n    \n    # Output the result\n    print(num_ways)\n\nmain()", "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a set to store unique topics and difficulties\n    topics_difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        topic, difficulty = map(int, input().split())\n        topics_difficulties.add((topic, difficulty))\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    for comb in combinations(topics_difficulties, 3):\n        # Check if the topics and difficulties are all different\n        if len(set([topic for topic, _ in comb])) == 3 and len(set([difficulty for _, difficulty in comb])) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n\nmain()"], "session_history": {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of testcases and the details of each testcase\",\n      \"For each testcase, determine the number of ways to select three problems that meet the given conditions\"\n    ],\n    \"major_steps\": [\n      \"Read the number of testcases from input\",\n      \"For each testcase, read the number of problems and their topics/difficulties\",\n      \"Create a data structure to store the topics and difficulties of each problem\",\n      \"Iterate through all possible combinations of 3 problems and check if they meet the conditions\",\n      \"Count the number of valid combinations and output the result\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is to select exactly 3 problems from a given set of problems, ensuring that the topics and difficulties of the selected problems are all different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The major steps should be implemented step by step as they involve different tasks such as parsing input, determining valid combinations, and counting the number of valid combinations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: Since all problems have different topics and difficulties, there is only one way to select 3 problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: All problems have different topics and difficulties, so there are 10 ways to select 3 problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to iterate through all possible combinations and check for valid selections should cover all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a set to store unique topics and difficulties\n    topics_difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        topic, difficulty = map(int, input().split())\n        topics_difficulties.add((topic, difficulty))\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    for comb in combinations(topics_difficulties, 3):\n        # Check if the topics and difficulties are all different\n        if len(set([topic for topic, _ in comb])) == 3 and len(set([difficulty for _, difficulty in comb])) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 36)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a set to store unique topics and difficulties\n    topics_difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        topic, difficulty = map(int, input().split())\n        topics_difficulties.add((topic, difficulty))\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    for comb in combinations(topics_difficulties, 3):\n        # Check if the topics and difficulties are all different\n        if len(set([topic for topic, _ in comb])) == 3 and len(set([difficulty for _, difficulty in comb])) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three training problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases from input\",\n    \"Step 2\": \"For each testcase, read the number of problems and their details\",\n    \"Step 3\": \"Implement a function to calculate the number of ways to select three training problems\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problems selection'\n    Explanation: The core concept is to select exactly 3 problems that satisfy specific conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve different aspects of parsing input, calculating, and outputting results.\n\n# [edge case] \n    Edge Case 1:\n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    0\n    Explanation: Since all problems have different topics and difficulties, there are no ways to select 3 problems that meet the requirements.\n\n    Edge Case 2:\n    Input:\n    1\n    3\n    1 1\n    1 2\n    1 3\n    Output:\n    1\n    Explanation: Only one way to select 3 problems with the same topic but different difficulties.\n\n    Edge Case 3:\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "def calculate_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            topic, difficulty = map(int, input().split())\n            problems.append((topic, difficulty))\n        \n        ways = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if problems[i][0] == problems[j][0] or problems[i][0] == problems[k][0] or problems[j][0] == problems[k][0]:\n                        ways += 1\n                    elif problems[i][1] == problems[j][1] or problems[i][1] == problems[k][1] or problems[j][1] == problems[k][1]:\n                        ways += 1\n        \n        print(ways)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    calculate_ways_to_select_problems(testcases)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 63)"}, "Round_1": {"code": "def calculate_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            topic, difficulty = map(int, input().split())\n            problems.append((topic, difficulty))\n        \n        ways = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if problems[i][0] == problems[j][0] or problems[i][0] == problems[k][0] or problems[j][0] == problems[k][0]:\n                        ways += 1\n                    elif problems[i][1] == problems[j][1] or problems[i][1] == problems[k][1] or problems[j][1] == problems[k][1]:\n                        ways += 1\n        \n        print(ways)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    calculate_ways_to_select_problems(testcases)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of testcases and the details of each testcase\",\n      \"For each testcase, determine the number of ways to select three problems that meet the given conditions\"\n    ],\n    \"major_steps\": [\n      \"Read the number of testcases from input\",\n      \"For each testcase, read the number of problems and their topics and difficulties\",\n      \"Create a data structure to store the topics and difficulties of each problem\",\n      \"Iterate through all possible combinations of three problems\",\n      \"Check if the selected problems have different topics and difficulties\",\n      \"Count the number of valid combinations\",\n      \"Output the total number of valid combinations for each testcase\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is to select exactly 3 problems from a given set of problems, ensuring that the topics and difficulties of the selected problems are all different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The major steps should be implemented step by step as they are distinct actions required to solve the problem.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: There is only one way to select 3 problems with different topics and difficulties.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All combinations of 3 problems have different topics and difficulties.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: There are 10 ways to select 3 problems with different topics and difficulties.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a set to store unique topics and difficulties\n    topics = set()\n    difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        topics.add(a)\n        difficulties.add(b)\n    \n    # Calculate the number of ways to select 3 problems with different topics and difficulties\n    num_ways = len(list(combinations(range(1, n+1), 3)))\n    \n    print(num_ways)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 31)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a set to store unique topics and difficulties\n    topics = set()\n    difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        topics.add(a)\n        difficulties.add(b)\n    \n    # Calculate the number of ways to select 3 problems with different topics and difficulties\n    num_ways = len(list(combinations(range(1, n+1), 3)))\n    \n    print(num_ways)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Iterate through all possible combinations of 3 problems and check if they meet the requirements\",\n    \"Step 4\": \"Count the number of valid combinations\",\n    \"Step 5\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problems selection'\n    Explanation: The core concept is to select 3 problems that meet certain requirements from a given set of problems.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, determining valid combinations, and outputting the result.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, there is only one way to select 3 problems as all topics and difficulties are different.\n\n    Input:\n    2\n    3\n    1 1\n    2 2\n    3 3\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    10\n    Explanation: In the first case, there is only one way to select 3 problems. In the second case, there are 10 ways to select 3 problems satisfying the conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic for selecting 3 problems can handle all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Function to determine the number of ways to select three problems that meet the requirements\ndef select_problems(testcases):\n    results = []\n    \n    for problems in testcases:\n        topics = set()\n        difficulties = set()\n        \n        for problem in problems:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        if len(topics) >= 3 or len(difficulties) >= 3:\n            results.append(len(list(combinations(problems, 3)))\n        else:\n            valid_combinations = 0\n            for comb in combinations(problems, 3):\n                if len(set([topic for topic, _ in comb])) == 3 or len(set([diff for _, diff in comb])) == 3:\n                    valid_combinations += 1\n            results.append(valid_combinations)\n    \n    return results\n\n# Parse the input to extract the number of testcases and the details of each testcase\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    testcases.append(problems)\n\n# Determine the number of ways to select three problems for each testcase\nresults = select_problems(testcases)\n\n# Output the result for each testcase\nfor result in results:\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 17)"}, "Round_1": {"code": "from itertools import combinations\n\n# Function to determine the number of ways to select three problems that meet the requirements\ndef select_problems(testcases):\n    results = []\n    \n    for problems in testcases:\n        topics = set()\n        difficulties = set()\n        \n        for problem in problems:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        if len(topics) >= 3 or len(difficulties) >= 3:\n            results.append(len(list(combinations(problems, 3)))\n        else:\n            valid_combinations = 0\n            for comb in combinations(problems, 3):\n                if len(set([topic for topic, _ in comb])) == 3 or len(set([diff for _, diff in comb])) == 3:\n                    valid_combinations += 1\n            results.append(valid_combinations)\n    \n    return results\n\n# Parse the input to extract the number of testcases and the details of each testcase\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    testcases.append(problems)\n\n# Determine the number of ways to select three problems for each testcase\nresults = select_problems(testcases)\n\n# Output the result for each testcase\nfor result in results:\n    print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three training problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases from input\",\n    \"Step 2\": \"For each testcase, read the number of problems and their details\",\n    \"Step 3\": \"Implement a function to calculate the number of ways to select three training problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problems selection'\n    Explanation: The core concept is to select exactly 3 problems that satisfy specific conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve different aspects of processing the input and calculating the output.\n\n# [edge case] \n    Edge Case 1:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    0\n    Explanation: Since there are only 3 problems and we need to select 3, there is only one way to select them all.\n    \n    Edge Case 2:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    0\n    Explanation: Similar to Edge Case 1, there is only one way to select all 3 problems.\n    \n    Edge Case 3:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: With 4 problems, there are 4 ways to select 3 problems: (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4).\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge cases)\n\nNO", "Round_0": {"code": "def count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if (problems[i][0] == problems[j][0] == problems[k][0]) or (problems[i][1] == problems[j][1] == problems[k][1]):\n                        count += 1\n        \n        print(count)\n\ncount_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if (problems[i][0] == problems[j][0] == problems[k][0]) or (problems[i][1] == problems[j][1] == problems[k][1]):\n                        count += 1\n        \n        print(count)\n\ncount_ways_to_select_problems()\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of testcases and the details of each testcase\",\n      \"For each testcase, determine the number of ways to select three problems that meet the given conditions\"\n    ],\n    \"major_steps\": [\n      \"Read the number of testcases from input\",\n      \"For each testcase, read the number of problems and their topics/difficulties\",\n      \"Create a data structure to store the topics and difficulties of each problem\",\n      \"Iterate through all possible combinations of 3 problems\",\n      \"Check if the selected problems have different topics and difficulties\",\n      \"Count the number of valid combinations\",\n      \"Output the total number of valid combinations for each testcase\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is to select exactly 3 problems from a given set of problems, ensuring that the topics and difficulties of the selected problems are all different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All major steps should be implemented step by step as they involve different aspects of parsing input and processing data.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, there is only one way to select 3 problems with different topics and difficulties.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All 4 problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: All 5 problems have different topics and difficulties, so there are 10 ways to select 3 problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to iterate through all possible combinations and check for different topics and difficulties will cover all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a set to store unique topics and difficulties\n    topics_difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        topic, difficulty = map(int, input().split())\n        topics_difficulties.add((topic, difficulty))\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    for comb in combinations(topics_difficulties, 3):\n        # Check if the selected problems have different topics and difficulties\n        if len(set([topic for topic, _ in comb])) == 3 and len(set([difficulty for _, difficulty in comb])) == 3:\n            count += 1\n    \n    # Output the total number of valid combinations for each testcase\n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 36)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a set to store unique topics and difficulties\n    topics_difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        topic, difficulty = map(int, input().split())\n        topics_difficulties.add((topic, difficulty))\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    for comb in combinations(topics_difficulties, 3):\n        # Check if the selected problems have different topics and difficulties\n        if len(set([topic for topic, _ in comb])) == 3 and len(set([difficulty for _, difficulty in comb])) == 3:\n            count += 1\n    \n    # Output the total number of valid combinations for each testcase\n    print(count)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three training problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases from input\",\n    \"Step 2\": \"For each testcase, read the number of problems and their details\",\n    \"Step 3\": \"Implement a function to calculate the number of ways to select three training problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problems selection'\n    Explanation: The core concept is to select exactly 3 problems that satisfy specific conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve different aspects of processing the input and calculating the output.\n\n# [edge case] \n    Edge Case 1:\n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: There is only one way to select 3 problems when all problems have different topics and difficulties.\n\n    Edge Case 2:\n    Input:\n    1\n    3\n    1 1\n    1 2\n    1 3\n    Output:\n    0\n    Explanation: It is not possible to select 3 problems with the same topic or difficulty.\n\n    Edge Case 3:\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge cases)\n\nNO", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize a list to store the topics and difficulties of each problem\n    problems = []\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Initialize a counter for the number of ways to select three training problems\n    count = 0\n    \n    # Generate all possible combinations of 3 problems\n    problem_combinations = combinations(problems, 3)\n    \n    # Check each combination if it meets the requirements\n    for comb in problem_combinations:\n        topics = set()\n        difficulties = set()\n        for prob in comb:\n            topics.add(prob[0])\n            difficulties.add(prob[1])\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 43)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize a list to store the topics and difficulties of each problem\n    problems = []\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Initialize a counter for the number of ways to select three training problems\n    count = 0\n    \n    # Generate all possible combinations of 3 problems\n    problem_combinations = combinations(problems, 3)\n    \n    # Check each combination if it meets the requirements\n    for comb in problem_combinations:\n        topics = set()\n        difficulties = set()\n        for prob in comb:\n            topics.add(prob[0])\n            difficulties.add(prob[1])\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases\",\n    \"Step 2\": \"For each testcase, read the number of problems and their topics/difficulties\",\n    \"Step 3\": \"Iterate through all possible combinations of 3 problems and check if they meet the requirements\",\n    \"Step 4\": \"Count the number of valid combinations\",\n    \"Step 5\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problems selection'\n    Explanation: The core concept is to select 3 problems that meet the given requirements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: Since all problems have different topics and difficulties, there is only one way to select 3 problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n    Input:\n    1\n    4\n    1 1\n    1 2\n    2 1\n    2 2\n    Output:\n    0\n    Explanation: None of the combinations satisfy the requirements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to check for valid combinations covers all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize a list to store the topics and difficulties of each problem\n    problems = []\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Generate all possible combinations of 3 problems\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        \n        # Check if the topics or difficulties of the selected problems are different\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 39)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize a list to store the topics and difficulties of each problem\n    problems = []\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Generate all possible combinations of 3 problems\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        \n        # Check if the topics or difficulties of the selected problems are different\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three problems that meet the requirements\",\n    \"Implement a function to check if the topics of three selected problems are different\",\n    \"Implement a function to check if the difficulties of three selected problems are different\",\n    \"Count the total number of ways to select three problems that meet either of the requirements\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"step_2\": \"For each testcase, iterate through all possible combinations of three problems\",\n    \"step_3\": \"Check if the topics of the three selected problems are different\",\n    \"step_4\": \"Check if the difficulties of the three selected problems are different\",\n    \"step_5\": \"Increment the count if either of the conditions is met\",\n    \"step_6\": \"Output the total number of ways for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties'\n    Explanation: The problems are defined by their topics and difficulties. Monocarp needs to select 3 problems that meet certain conditions based on these attributes.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve different subproblems and conditions to check.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, there is only one way to select 3 problems with different topics or difficulties.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All 4 problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: All 5 problems have different topics and difficulties, so there are 10 ways to select 3 problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to select 3 problems based on different topics or difficulties covers all scenarios.", "Round_0": {"code": "from itertools import combinations\n\ndef check_topics_diff(topics, difficulties):\n    return len(set(topics)) == 3 or len(set(difficulties)) == 3\n\ndef count_ways_to_select_problems(n, problems):\n    total_ways = 0\n    for comb in combinations(problems, 3):\n        topics = [topic for topic, _ in comb]\n        difficulties = [diff for _, diff in comb]\n        if check_topics_diff(topics, difficulties):\n            total_ways += 1\n    return total_ways\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    ways = count_ways_to_select_problems(n, problems)\n    print(ways)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 27)"}, "Round_1": {"code": "from itertools import combinations\n\ndef check_topics_diff(topics, difficulties):\n    return len(set(topics)) == 3 or len(set(difficulties)) == 3\n\ndef count_ways_to_select_problems(n, problems):\n    total_ways = 0\n    for comb in combinations(problems, 3):\n        topics = [topic for topic, _ in comb]\n        difficulties = [diff for _, diff in comb]\n        if check_topics_diff(topics, difficulties):\n            total_ways += 1\n    return total_ways\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    ways = count_ways_to_select_problems(n, problems)\n    print(ways)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases\",\n    \"Step 2\": \"For each testcase, read the number of problems and their topics/difficulties\",\n    \"Step 3\": \"Iterate through all possible combinations of 3 problems and check if they meet the requirements\",\n    \"Step 4\": \"Count the number of valid combinations\",\n    \"Step 5\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problems selection'\n    Explanation: The core concept is to select 3 problems that meet certain requirements from a given set of problems.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve parsing input, determining valid combinations, and outputting the result.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, there is only one way to select 3 problems with different topics or difficulties.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All combinations of 3 problems can be selected as they all have different topics and difficulties.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: There are 10 ways to select 3 problems with different topics or difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to determine valid combinations covers all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize a set to store unique topics and difficulties\n    topics = set()\n    difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        topics.add(a)\n        difficulties.add(b)\n    \n    # Calculate the number of ways to select 3 problems\n    num_ways = 0\n    if n >= 3:\n        num_ways += len(list(combinations(range(1, n+1), 3)))\n    \n    # Output the result\n    print(num_ways)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 34)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize a set to store unique topics and difficulties\n    topics = set()\n    difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        topics.add(a)\n        difficulties.add(b)\n    \n    # Calculate the number of ways to select 3 problems\n    num_ways = 0\n    if n >= 3:\n        num_ways += len(list(combinations(range(1, n+1), 3)))\n    \n    # Output the result\n    print(num_ways)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of testcases and the details of each testcase\",\n      \"For each testcase, determine the number of ways to select three problems that meet the given conditions\"\n    ],\n    \"major_steps\": [\n      \"Read the number of testcases from input\",\n      \"For each testcase, read the number of problems and their topics/difficulties\",\n      \"Create a data structure to store the topics and difficulties of each problem\",\n      \"Iterate through all possible combinations of 3 problems and check if they meet the conditions\",\n      \"Count the number of valid combinations and output the result\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is to select exactly 3 problems from a given set of problems, ensuring that the topics and difficulties of the selected problems are all different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The major steps should be implemented step by step as they involve different tasks such as parsing input, determining valid combinations, and counting the number of valid combinations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: Since all problems have different topics and difficulties, there is only one way to select 3 problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: All problems have different topics and difficulties, so there are 10 ways to select 3 problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to iterate through all possible combinations and check for valid selections should cover all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a set to store unique topics and difficulties\n    topics_difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        topic, difficulty = map(int, input().split())\n        topics_difficulties.add((topic, difficulty))\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    for comb in combinations(topics_difficulties, 3):\n        # Check if the topics and difficulties are all different\n        if len(set([topic for topic, _ in comb])) == 3 and len(set([difficulty for _, difficulty in comb])) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 36)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a set to store unique topics and difficulties\n    topics_difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        topic, difficulty = map(int, input().split())\n        topics_difficulties.add((topic, difficulty))\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    for comb in combinations(topics_difficulties, 3):\n        # Check if the topics and difficulties are all different\n        if len(set([topic for topic, _ in comb])) == 3 and len(set([difficulty for _, difficulty in comb])) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n"}}], "scores": [], "pass_results": [false, false, false, true, true, false, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 189, "prompt": "Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet. Each of these problems is defined by its topic and difficulty: the i-th problem has a topic a_i (an integer from 1 to n). Furthermore, it has a difficulty b_i (an integer from 1 to n), with all problems being different, meaning there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "expand_one2two", "save_node": true, "parent_index": 121}
