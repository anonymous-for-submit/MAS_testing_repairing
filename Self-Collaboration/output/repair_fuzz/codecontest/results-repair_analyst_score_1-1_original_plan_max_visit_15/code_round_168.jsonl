{"name": "1607_F. Robot on the Board 2", "description": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nEach cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. \n\n  * If the robot moves beyond the edge of the board, it falls and breaks. \n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). \n\n\n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDetermine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "tags": ["brute force", "dfs and similar", "dp", "graphs", "implementation"], "difficulty": 12, "id": 1607, "sample_io": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n"]}], "test_list": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nUDUR\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRDRR\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 7\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDUD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 1 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 9\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nUUDR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n4 3 10\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDULD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 4\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nUDDL\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 4 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n1 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n1 2 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 13\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nUDLD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRDUU\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n1 1 5\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n2 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDRUU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n3 1 7\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 2\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n2 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n1 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 4\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nURLL\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 1 8\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n3 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}], "task_id": "codecontest/103", "repair_prompt": ["The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right. The robot is able to move from the current cell to one of the four cells adjacent by side. Each cell has one of the symbols 'L', 'R', 'D' or 'U' indicating the direction to move (left, right, down or up, respectively). The robot can start its movement in any cell. Then it moves to the adjacent square in the direction indicated on the current square in one move. * If the robot moves beyond the edge of the board, it falls and breaks. * If the robot appears in the cell it already visited before, it breaks. It stops and doesn't move anymore. Robot can choose any cell as the starting cell, and its goal is to make the maximum number of steps before it breaks or stops. Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written. It does not matter whether to another square or beyond the edge of the board.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The robot can start its movement in any cell, allowing for flexibility in its initial position. It then moves to the adjacent square in the direction indicated, aiming to make the maximum number of steps before breaking or stopping. Determine the optimal starting square for the robot to execute as many commands as possible successfully, regardless of the outcome.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns) where each cell has a symbol indicating the direction to move, such as 'L', 'R', 'D', or 'U'. The goal is to make the maximum number of steps before it breaks or stops by choosing the right starting cell.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def get_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = 0\n            visited = set()\n            curr_r, curr_c = r, c\n            \n            while (curr_r, curr_c) not in visited:\n                visited.add((curr_r, curr_c))\n                move = board[curr_r][curr_c]\n                \n                if move == 'L':\n                    curr_c -= 1\n                elif move == 'R':\n                    curr_c += 1\n                elif move == 'U':\n                    curr_r -= 1\n                elif move == 'D':\n                    curr_r += 1\n                \n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r + 1, c + 1)\n    \n    return start_cell, max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    start_cell, max_moves = get_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n\nmain()", "completions": ["def get_max_moves(board):\n    n = len(board)\n    m = len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            visited = set()\n            x, y = i, j\n            moves = 0\n\n            while (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n\n                if x < 0 or x >= n or y < 0 or y >= m:\n                    break\n\n                moves += 1\n\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Read the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n\nmain()", "def find_optimal_starting_square(test_cases):\n    for _ in range(test_cases):\n        input()  # Read the blank line\n        n, m = map(int, input().split())\n        board = [input() for _ in range(n)]\n        \n        max_moves = 0\n        start_row, start_col = 1, 1\n        \n        for i in range(n):\n            for j in range(m):\n                moves = 0\n                row, col = i, j\n                \n                while 0 <= row < n and 0 <= col < m:\n                    if board[row][col] == 'L':\n                        col -= 1\n                    elif board[row][col] == 'R':\n                        col += 1\n                    elif board[row][col] == 'U':\n                        row -= 1\n                    elif board[row][col] == 'D':\n                        row += 1\n                    moves += 1\n                \n                if moves > max_moves:\n                    max_moves = moves\n                    start_row, start_col = i + 1, j + 1\n        \n        print(start_row, start_col, max_moves)\n\n# Read the number of test cases\ntest_cases = int(input())\nfind_optimal_starting_square(test_cases)\n\nmain()", "def get_starting_cell(board):\n    n = len(board)\n    m = len(board[0])\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            moves = 0\n            visited = set()\n            x, y = i, j\n            \n            while (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell, max_moves\n\nt = int(input())\ninput_data = []\nfor _ in range(t):\n    input()\n    n, m = map(int, input().split())\n    input_data.append([list(input().strip()) for _ in range(n)])\n\nfor board in input_data:\n    start_cell, max_moves = get_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n\nmain()", "def get_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = 0\n            visited = set()\n            curr_r, curr_c = r, c\n            \n            while (curr_r, curr_c) not in visited:\n                visited.add((curr_r, curr_c))\n                move = board[curr_r][curr_c]\n                \n                if move == 'L':\n                    curr_c -= 1\n                elif move == 'R':\n                    curr_c += 1\n                elif move == 'U':\n                    curr_r -= 1\n                elif move == 'D':\n                    curr_r += 1\n                \n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r + 1, c + 1)\n    \n    return start_cell, max_moves\n\nt = int(input())\ninput_data = []\nfor _ in range(t):\n    input()\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    input_data.append((n, m, board))\n\nfor n, m, board in input_data:\n    start_cell, max_moves = get_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n\nmain()", "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = set()\n            moves = 0\n            x, y = i, j\n            \n            while 0 <= x < n and 0 <= y < m and (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Read the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n\nmain()", "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = set()\n            moves = 0\n            x, y = i, j\n            \n            while 0 <= x < n and 0 <= y < m and (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # read the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n\nmain()", "def find_optimal_starting_square(test_cases):\n    for _ in range(test_cases):\n        input()  # Read the blank line\n        n, m = map(int, input().split())\n        board = [input() for _ in range(n)]\n        \n        max_moves = 0\n        start_row, start_col = 1, 1\n        \n        for i in range(n):\n            for j in range(m):\n                moves = 0\n                row, col = i, j\n                \n                while 0 <= row < n and 0 <= col < m:\n                    if board[row][col] == 'L':\n                        col -= 1\n                    elif board[row][col] == 'R':\n                        col += 1\n                    elif board[row][col] == 'U':\n                        row -= 1\n                    elif board[row][col] == 'D':\n                        row += 1\n                    \n                    moves += 1\n                \n                if moves > max_moves:\n                    max_moves = moves\n                    start_row, start_col = i + 1, j + 1\n        \n        print(start_row, start_col, max_moves)\n\n# Read the number of test cases\ntest_cases = int(input())\nfind_optimal_starting_square(test_cases)\n\nmain()", "def find_optimal_starting_square(test_cases):\n    for _ in range(test_cases):\n        input()  # Read the blank line\n        n, m = map(int, input().split())\n        board = [input() for _ in range(n)]\n        \n        max_moves = 0\n        start_row, start_col = 1, 1\n        \n        for i in range(n):\n            for j in range(m):\n                directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n                moves = 0\n                row, col = i, j\n                \n                while 0 <= row < n and 0 <= col < m:\n                    moves += 1\n                    dr, dc = directions[board[row][col]]\n                    row += dr\n                    col += dc\n                \n                if moves > max_moves:\n                    max_moves = moves\n                    start_row, start_col = i + 1, j + 1\n        \n        print(start_row, start_col, max_moves)\n\n# Read the number of test cases\ntest_cases = int(input())\nfind_optimal_starting_square(test_cases)\n\nmain()", "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = set()\n            moves = 0\n            x, y = i, j\n            \n            while 0 <= x < n and 0 <= y < m and (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput_data = []\nfor _ in range(t):\n    input()\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    input_data.append((n, m, board))\n\nfor data in input_data:\n    result = calculate_moves(data[2])\n    print(f\"{result[0]} {result[1]} {result[2]}\")\n\nmain()", "def get_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = 0\n            visited = set()\n            curr_r, curr_c = r, c\n            \n            while (curr_r, curr_c) not in visited:\n                visited.add((curr_r, curr_c))\n                move = board[curr_r][curr_c]\n                \n                if move == 'L':\n                    curr_c -= 1\n                elif move == 'R':\n                    curr_c += 1\n                elif move == 'U':\n                    curr_r -= 1\n                elif move == 'D':\n                    curr_r += 1\n                \n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r + 1, c + 1)\n    \n    return start_cell, max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    start_cell, max_moves = get_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n\nmain()"], "session_history": {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board configurations\",\n      \"For each test case, determine the starting cell and the maximum number of moves the robot can make\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, read the board configuration and determine the starting cell and maximum number of moves\",\n      \"Output the starting cell and maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'direction to move'\n    Explanation: The core concept is the symbols 'L', 'R', 'D', or 'U' indicating the direction the robot can move on the board.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve reading input, processing each test case, and outputting the results.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make 1 move in the right direction.\n    \n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation: The robot starts at cell (1, 1) and can make 3 moves by following the directions 'RRL'.\n    \n    Test Case 3:\n    Input:\n    4 4\n    DDLU\n    RDDU\n    UUUU\n    RDLD\n    Output:\n    1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves by following the directions 'DDLU'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should be sufficient to handle the given requirements.", "Round_0": {"code": "def get_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = 0\n            visited = set()\n            curr_r, curr_c = r, c\n            \n            while (curr_r, curr_c) not in visited:\n                visited.add((curr_r, curr_c))\n                move = board[curr_r][curr_c]\n                \n                if move == 'L':\n                    curr_c -= 1\n                elif move == 'R':\n                    curr_c += 1\n                elif move == 'U':\n                    curr_r -= 1\n                elif move == 'D':\n                    curr_r += 1\n                \n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r + 1, c + 1)\n    \n    return start_cell, max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    start_cell, max_moves = get_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 46)"}, "Round_1": {"code": "def get_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = 0\n            visited = set()\n            curr_r, curr_c = r, c\n            \n            while (curr_r, curr_c) not in visited:\n                visited.add((curr_r, curr_c))\n                move = board[curr_r][curr_c]\n                \n                if move == 'L':\n                    curr_c -= 1\n                elif move == 'R':\n                    curr_c += 1\n                elif move == 'U':\n                    curr_r -= 1\n                elif move == 'D':\n                    curr_r += 1\n                \n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r + 1, c + 1)\n    \n    return start_cell, max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    start_cell, max_moves = get_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n"}}, "session_historys": [{"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board configurations\",\n      \"For each test case, determine the starting cell for the robot to maximize the number of moves\",\n      \"Implement a function to calculate the maximum number of moves for a given starting cell\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the board configuration and determine the starting cell\",\n      \"Implement a function to calculate the maximum number of moves for a given starting cell\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The core concept involves the movement of a robot on a checkered rectangular board based on symbols 'L', 'R', 'D', 'U' indicating directions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': indicates the highest number of steps the robot can take before breaking or stopping.\n\n# [code logic]\n    The steps do not need to be implemented simultaneously. Each step should be followed sequentially as mentioned in the plan.\n\n# [edge case] \n    Test Case 1:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make one move to the right.\n    \n    Test Case 2:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation: The robot starts at cell (1, 1) and can make three moves to the right.\n    \n    Test Case 3:\n    2 2\n    DL\n    RU\n    Output:\n    1 1 4\n    Explanation: The robot starts at cell (1, 1) and can make four moves in different directions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Check if the robot moves beyond the edge of the board.\n        - Check if the robot revisits a cell it has already visited.\n        - Implement logic to handle multiple possible starting cells for maximum moves.\n        (additional code for handling edge cases) \n\nNO", "Round_0": {"code": "def get_max_moves(board):\n    n = len(board)\n    m = len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            visited = set()\n            x, y = i, j\n            moves = 0\n\n            while (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n\n                if x < 0 or x >= n or y < 0 or y >= m:\n                    break\n\n                moves += 1\n\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Read the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_max_moves(board):\n    n = len(board)\n    m = len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            visited = set()\n            x, y = i, j\n            moves = 0\n\n            while (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n\n                if x < 0 or x >= n or y < 0 or y >= m:\n                    break\n\n                moves += 1\n\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Read the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board configurations\",\n      \"For each test case, determine the optimal starting square for the robot to execute as many commands as possible successfully\",\n      \"Output the starting square coordinates and the maximum number of moves for each test case\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the input to extract the board configuration\",\n      \"Implement a function to determine the optimal starting square for the robot\",\n      \"Output the starting square coordinates and the maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'adjacent square': Refers to the square that is directly next to the current square in the specified direction.\n    'maximum number of steps': Indicates the highest number of steps the robot can take before stopping or breaking.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest or greatest number of steps the robot can take.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve different subproblems and major steps.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation:\n    The robot starts at cell (1, 1) and can only make 1 move to the right.\n    \n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation:\n    The robot starts at cell (1, 1) and can make 3 moves to the right before stopping.\n    \n    Test Case 3:\n    Input:\n    4 4\n    DDLU\n    RUUD\n    URUD\n    ULLR\n    Output:\n    4 3 12\n    Explanation:\n    The robot starts at cell (4, 3) and can make 12 moves in various directions before stopping.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "def find_optimal_starting_square(test_cases):\n    for _ in range(test_cases):\n        input()  # Read the blank line\n        n, m = map(int, input().split())\n        board = [input() for _ in range(n)]\n        \n        max_moves = 0\n        start_row, start_col = 1, 1\n        \n        for i in range(n):\n            for j in range(m):\n                moves = 0\n                row, col = i, j\n                \n                while 0 <= row < n and 0 <= col < m:\n                    if board[row][col] == 'L':\n                        col -= 1\n                    elif board[row][col] == 'R':\n                        col += 1\n                    elif board[row][col] == 'U':\n                        row -= 1\n                    elif board[row][col] == 'D':\n                        row += 1\n                    moves += 1\n                \n                if moves > max_moves:\n                    max_moves = moves\n                    start_row, start_col = i + 1, j + 1\n        \n        print(start_row, start_col, max_moves)\n\n# Read the number of test cases\ntest_cases = int(input())\nfind_optimal_starting_square(test_cases)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 50)"}, "Round_1": {"code": "def find_optimal_starting_square(test_cases):\n    for _ in range(test_cases):\n        input()  # Read the blank line\n        n, m = map(int, input().split())\n        board = [input() for _ in range(n)]\n        \n        max_moves = 0\n        start_row, start_col = 1, 1\n        \n        for i in range(n):\n            for j in range(m):\n                moves = 0\n                row, col = i, j\n                \n                while 0 <= row < n and 0 <= col < m:\n                    if board[row][col] == 'L':\n                        col -= 1\n                    elif board[row][col] == 'R':\n                        col += 1\n                    elif board[row][col] == 'U':\n                        row -= 1\n                    elif board[row][col] == 'D':\n                        row += 1\n                    moves += 1\n                \n                if moves > max_moves:\n                    max_moves = moves\n                    start_row, start_col = i + 1, j + 1\n        \n        print(start_row, start_col, max_moves)\n\n# Read the number of test cases\ntest_cases = int(input())\nfind_optimal_starting_square(test_cases)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board configurations\",\n      \"For each test case, determine the starting cell and the maximum number of moves the robot can make\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, read the board configuration and determine the starting cell and maximum number of moves\",\n      \"Output the starting cell and maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'direction to move'\n    Explanation: The core concept is the symbols 'L', 'R', 'D', or 'U' indicating the direction the robot can move on the board.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve reading input, processing each test case, and outputting the results.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make 1 move in the right direction.\n    \n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation: The robot starts at cell (1, 1) and can make 3 moves by following the directions 'RRL'.\n    \n    Test Case 3:\n    Input:\n    4 4\n    DDLU\n    RDDU\n    UUUU\n    RDLD\n    Output:\n    1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves to reach cell (1, 4) following the directions 'DDLU'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should be sufficient to handle the given requirements.", "Round_0": {"code": "def get_starting_cell(board):\n    n = len(board)\n    m = len(board[0])\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            moves = 0\n            visited = set()\n            x, y = i, j\n            \n            while (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell, max_moves\n\nt = int(input())\ninput_data = []\nfor _ in range(t):\n    input_data.append([list(input().strip()) for _ in range(int(input().split()[0]))])\n\nfor board in input_data:\n    start_cell, max_moves = get_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_starting_cell(board):\n    n = len(board)\n    m = len(board[0])\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            moves = 0\n            visited = set()\n            x, y = i, j\n            \n            while (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell, max_moves\n\nt = int(input())\ninput_data = []\nfor _ in range(t):\n    input()\n    n, m = map(int, input().split())\n    input_data.append([list(input().strip()) for _ in range(n)])\n\nfor board in input_data:\n    start_cell, max_moves = get_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board configurations\",\n      \"For each test case, determine the starting cell and the maximum number of moves the robot can make\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, read the board configuration and determine the starting cell and maximum number of moves\",\n      \"Output the starting cell and maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'checkered rectangular board': Refers to a board with rows and columns where each cell has a direction symbol.\n    'maximum number of steps': Refers to the goal of the robot to move the most steps before stopping.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve reading input, processing each test case, and outputting results.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make 1 move in the right direction.\n    \n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation: The robot starts at cell (1, 1) and can make 3 moves by following the directions RRL.\n\n    Test Case 3:\n    Input:\n    4 4\n    DDLU\n    RDDU\n    UUUU\n    RDLD\n    Output:\n    1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves to reach cell (1, 4).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should be able to handle all test cases effectively.", "Round_0": {"code": "def get_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = 0\n            visited = set()\n            curr_r, curr_c = r, c\n            \n            while (curr_r, curr_c) not in visited:\n                visited.add((curr_r, curr_c))\n                move = board[curr_r][curr_c]\n                \n                if move == 'L':\n                    curr_c -= 1\n                elif move == 'R':\n                    curr_c += 1\n                elif move == 'U':\n                    curr_r -= 1\n                elif move == 'D':\n                    curr_r += 1\n                \n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r + 1, c + 1)\n    \n    return start_cell, max_moves\n\nt = int(input())\ninput_data = []\nfor _ in range(t):\n    input()\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    input_data.append((n, m, board))\n\nfor n, m, board in input_data:\n    start_cell, max_moves = get_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = 0\n            visited = set()\n            curr_r, curr_c = r, c\n            \n            while (curr_r, curr_c) not in visited:\n                visited.add((curr_r, curr_c))\n                move = board[curr_r][curr_c]\n                \n                if move == 'L':\n                    curr_c -= 1\n                elif move == 'R':\n                    curr_c += 1\n                elif move == 'U':\n                    curr_r -= 1\n                elif move == 'D':\n                    curr_r += 1\n                \n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r + 1, c + 1)\n    \n    return start_cell, max_moves\n\nt = int(input())\ninput_data = []\nfor _ in range(t):\n    input()\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    input_data.append((n, m, board))\n\nfor n, m, board in input_data:\n    start_cell, max_moves = get_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the board configurations\",\n    \"For each test case, determine the starting cell for the robot to maximize the number of moves\",\n    \"Implement a function to calculate the maximum number of moves for a given starting cell\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the board configurations\",\n    \"For each test case, iterate through each cell on the board and calculate the maximum number of moves for that cell\",\n    \"Store the maximum number of moves and the corresponding starting cell\",\n    \"Output the starting cell with the maximum number of moves for each test case\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'checkered rectangular board': A board with rows and columns where a robot can move in four directions indicated by symbols.\n    Explanation: The core concept involves navigating a robot on a board with specific symbols indicating movement directions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum number of steps': Indicates the highest number of moves the robot can make before breaking.\n    Explanation: The robot needs to start from a cell that allows it to make the most moves without breaking.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve parsing input, determining starting cell, and calculating maximum moves.\n\n# [edge case] \n    Edge Case 1:\n    1 1\n    R\n    Output: 1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make 1 move to the right.\n    \n    Edge Case 2:\n    1 3\n    RRL\n    Output: 1 1 3\n    Explanation: The robot starts at cell (1, 1) and can make 3 moves to the right.\n    \n    Edge Case 3:\n    4 4\n    DDLU\n    RUUD\n    URUD\n    ULLR\n    Output: 4 3 12\n    Explanation: The robot starts at cell (4, 3) and can make 12 moves before breaking.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n\nNO", "Round_0": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = set()\n            moves = 0\n            x, y = i, j\n            \n            while 0 <= x < n and 0 <= y < m and (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Read the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = set()\n            moves = 0\n            x, y = i, j\n            \n            while 0 <= x < n and 0 <= y < m and (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Read the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the board configurations\",\n    \"For each test case, determine the starting cell for the robot to maximize the number of moves\",\n    \"Implement a function to calculate the maximum number of moves for a given starting cell\"\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases\",\n    \"For each test case, parse the board configuration and create a matrix representation\",\n    \"Iterate through each cell in the matrix and calculate the maximum number of moves for that cell\",\n    \"Track the maximum number of moves and the corresponding starting cell\",\n    \"Output the starting cell with the maximum number of moves for each test case\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configurations'\n    Explanation: The requirement involves parsing the input board configurations to determine the starting cell for the robot to maximize the number of moves.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the need to find the starting cell that allows the robot to make the maximum number of moves.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve parsing input, creating matrix representation, iterating through cells, calculating moves, and tracking the maximum moves.\n\n# [edge case] \n    Edge Case 1:\n    Input:\n    1\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: In this case, the robot can only move to the right from the starting cell (1, 1) for a single move.\n    \n    Edge Case 2:\n    Input:\n    2\n    2 2\n    UD\n    RU\n    2 2\n    DL\n    RU\n    Output:\n    1 1 2\n    1 1 3\n    Explanation: In the first case, the robot can move up and then right from the starting cell (1, 1) for a total of 2 moves. In the second case, the robot can move down and then left from the starting cell (1, 1) for a total of 3 moves.\n    \n    Edge Case 3:\n    Input:\n    3\n    3 3\n    RRR\n    UUU\n    LLL\n    3 3\n    UUU\n    RRR\n    LLL\n    3 3\n    DDD\n    RRR\n    UUU\n    Output:\n    1 1 3\n    1 1 3\n    1 1 3\n    Explanation: In all three cases, the robot can only move in a loop within the same row or column, resulting in a maximum of 3 moves.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to find the starting cell with the maximum number of moves can handle different scenarios effectively.", "Round_0": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = set()\n            moves = 0\n            x, y = i, j\n            \n            while 0 <= x < n and 0 <= y < m and (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # read the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = set()\n            moves = 0\n            x, y = i, j\n            \n            while 0 <= x < n and 0 <= y < m and (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # read the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board descriptions\",\n      \"For each test case, determine the optimal starting square for the robot to execute as many commands as possible successfully\",\n      \"Output the starting square coordinates and the maximum number of moves for each test case\"\n    ],\n    \"high-level steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the board description to extract the height, width, and board layout\",\n      \"Implement a function to determine the optimal starting square for the robot based on the board layout\",\n      \"Output the starting square coordinates and the maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'adjacent square': Refers to the square that is directly next to the current square in the specified direction.\n    'maximum number of steps': Indicates the highest number of steps the robot can take before stopping or breaking.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'optimal': Indicates the best or most favorable starting square for the robot to maximize the number of successful commands.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve different subproblems and high-level steps.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make 1 move in the right direction.\n    \n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation: The robot starts at cell (1, 1) and can make 3 moves to the right before stopping.\n    \n    Test Case 3:\n    Input:\n    4 4\n    DDLU\n    RUUD\n    URUD\n    ULLR\n    Output:\n    4 3 12\n    Explanation: The robot starts at cell (4, 3) and can make 12 moves in various directions before stopping.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "def find_optimal_starting_square(test_cases):\n    for _ in range(test_cases):\n        input()  # Read the blank line\n        n, m = map(int, input().split())\n        board = [input() for _ in range(n)]\n        \n        max_moves = 0\n        start_row, start_col = 1, 1\n        \n        for i in range(n):\n            for j in range(m):\n                moves = 0\n                row, col = i, j\n                \n                while 0 <= row < n and 0 <= col < m:\n                    if board[row][col] == 'L':\n                        col -= 1\n                    elif board[row][col] == 'R':\n                        col += 1\n                    elif board[row][col] == 'U':\n                        row -= 1\n                    elif board[row][col] == 'D':\n                        row += 1\n                    \n                    moves += 1\n                \n                if moves > max_moves:\n                    max_moves = moves\n                    start_row, start_col = i + 1, j + 1\n        \n        print(start_row, start_col, max_moves)\n\n# Read the number of test cases\ntest_cases = int(input())\nfind_optimal_starting_square(test_cases)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_optimal_starting_square(test_cases):\n    for _ in range(test_cases):\n        input()  # Read the blank line\n        n, m = map(int, input().split())\n        board = [input() for _ in range(n)]\n        \n        max_moves = 0\n        start_row, start_col = 1, 1\n        \n        for i in range(n):\n            for j in range(m):\n                moves = 0\n                row, col = i, j\n                \n                while 0 <= row < n and 0 <= col < m:\n                    if board[row][col] == 'L':\n                        col -= 1\n                    elif board[row][col] == 'R':\n                        col += 1\n                    elif board[row][col] == 'U':\n                        row -= 1\n                    elif board[row][col] == 'D':\n                        row += 1\n                    \n                    moves += 1\n                \n                if moves > max_moves:\n                    max_moves = moves\n                    start_row, start_col = i + 1, j + 1\n        \n        print(start_row, start_col, max_moves)\n\n# Read the number of test cases\ntest_cases = int(input())\nfind_optimal_starting_square(test_cases)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board descriptions\",\n      \"For each test case, determine the optimal starting square for the robot to execute as many commands as possible successfully\",\n      \"Output the starting square coordinates and the maximum number of moves for each test case\"\n    ],\n    \"high-level steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the input to extract the board description\",\n      \"Implement a function to determine the optimal starting square for the robot\",\n      \"Output the starting square coordinates and the maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'adjacent square': Refers to the square that is directly next to the current square in the specified direction.\n    'maximum number of steps': Refers to the highest number of steps the robot can take before stopping or breaking.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest or greatest value.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve different subproblems and high-level steps.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation:\n    The robot starts at cell (1, 1) and can only make 1 move in the right direction.\n    \n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation:\n    The robot starts at cell (1, 1) and can make 3 moves to the right before stopping.\n    \n    Test Case 3:\n    Input:\n    4 4\n    DDLU\n    RUUD\n    URUD\n    ULLR\n    Output:\n    4 3 12\n    Explanation:\n    The robot starts at cell (4, 3) and can make 12 moves in various directions before stopping.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "def find_optimal_starting_square(test_cases):\n    for _ in range(test_cases):\n        input()  # Read the blank line\n        n, m = map(int, input().split())\n        board = [input() for _ in range(n)]\n        \n        max_moves = 0\n        start_row, start_col = 1, 1\n        \n        for i in range(n):\n            for j in range(m):\n                directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n                moves = 0\n                row, col = i, j\n                \n                while 0 <= row < n and 0 <= col < m:\n                    moves += 1\n                    dr, dc = directions[board[row][col]]\n                    row += dr\n                    col += dc\n                \n                if moves > max_moves:\n                    max_moves = moves\n                    start_row, start_col = i + 1, j + 1\n        \n        print(start_row, start_col, max_moves)\n\n# Read the number of test cases\ntest_cases = int(input())\nfind_optimal_starting_square(test_cases)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_optimal_starting_square(test_cases):\n    for _ in range(test_cases):\n        input()  # Read the blank line\n        n, m = map(int, input().split())\n        board = [input() for _ in range(n)]\n        \n        max_moves = 0\n        start_row, start_col = 1, 1\n        \n        for i in range(n):\n            for j in range(m):\n                directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n                moves = 0\n                row, col = i, j\n                \n                while 0 <= row < n and 0 <= col < m:\n                    moves += 1\n                    dr, dc = directions[board[row][col]]\n                    row += dr\n                    col += dc\n                \n                if moves > max_moves:\n                    max_moves = moves\n                    start_row, start_col = i + 1, j + 1\n        \n        print(start_row, start_col, max_moves)\n\n# Read the number of test cases\ntest_cases = int(input())\nfind_optimal_starting_square(test_cases)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the board configurations\",\n    \"For each test case, determine the starting cell for the robot to maximize the number of moves\",\n    \"Implement a function to calculate the maximum number of moves for a given starting cell\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the board configurations\",\n    \"For each test case, iterate through each cell on the board and calculate the maximum number of moves for that cell\",\n    \"Track the maximum number of moves and the corresponding starting cell\",\n    \"Output the starting cell with the maximum number of moves for each test case\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The core concept is about the movement of a robot on a checkered rectangular board following specific directions and conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    Edge Case 1:\n    1 1\n    R\n    Output: 1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make one move to the right.\n    \n    Edge Case 2:\n    4 4\n    DDLU\n    RDDU\n    UUUU\n    RDLD\n    Output: 1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves before breaking.\n\n    Edge Case 3:\n    2 2\n    UD\n    RU\n    Output: 1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves before breaking.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should be sufficient to handle the edge cases.", "Round_0": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = set()\n            moves = 0\n            x, y = i, j\n            \n            while 0 <= x < n and 0 <= y < m and (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput_data = []\nfor _ in range(t):\n    input()\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    input_data.append((n, m, board))\n\nfor data in input_data:\n    result = calculate_moves(data[2])\n    print(f\"{result[0]} {result[1]} {result[2]}\")\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = set()\n            moves = 0\n            x, y = i, j\n            \n            while 0 <= x < n and 0 <= y < m and (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput_data = []\nfor _ in range(t):\n    input()\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    input_data.append((n, m, board))\n\nfor data in input_data:\n    result = calculate_moves(data[2])\n    print(f\"{result[0]} {result[1]} {result[2]}\")\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board configurations\",\n      \"For each test case, determine the starting cell and the maximum number of moves the robot can make\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, read the board configuration and determine the starting cell and maximum number of moves\",\n      \"Output the starting cell and maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'direction to move'\n    Explanation: The core concept is the symbols 'L', 'R', 'D', or 'U' indicating the direction the robot can move on the board.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve reading input, processing each test case, and outputting the results.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make 1 move in the right direction.\n    \n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation: The robot starts at cell (1, 1) and can make 3 moves by following the directions 'RRL'.\n    \n    Test Case 3:\n    Input:\n    4 4\n    DDLU\n    RDDU\n    UUUU\n    RDLD\n    Output:\n    1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves by following the directions 'DDLU'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should be sufficient to handle the given requirements.", "Round_0": {"code": "def get_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = 0\n            visited = set()\n            curr_r, curr_c = r, c\n            \n            while (curr_r, curr_c) not in visited:\n                visited.add((curr_r, curr_c))\n                move = board[curr_r][curr_c]\n                \n                if move == 'L':\n                    curr_c -= 1\n                elif move == 'R':\n                    curr_c += 1\n                elif move == 'U':\n                    curr_r -= 1\n                elif move == 'D':\n                    curr_r += 1\n                \n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r + 1, c + 1)\n    \n    return start_cell, max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    start_cell, max_moves = get_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 46)"}, "Round_1": {"code": "def get_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = 0\n            visited = set()\n            curr_r, curr_c = r, c\n            \n            while (curr_r, curr_c) not in visited:\n                visited.add((curr_r, curr_c))\n                move = board[curr_r][curr_c]\n                \n                if move == 'L':\n                    curr_c -= 1\n                elif move == 'R':\n                    curr_c += 1\n                elif move == 'U':\n                    curr_r -= 1\n                elif move == 'D':\n                    curr_r += 1\n                \n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r + 1, c + 1)\n    \n    return start_cell, max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    start_cell, max_moves = get_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n"}}], "scores": [], "pass_results": [false, true, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 168, "prompt": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right. The robot is able to move from the current cell to one of the four cells adjacent by side. Each cell has one of the symbols 'L', 'R', 'D' or 'U' indicating the direction to move (left, right, down or up, respectively). The robot can start its movement in any cell. Then it moves to the adjacent square in the direction indicated on the current square in one move. * If the robot moves beyond the edge of the board, it falls and breaks. * If the robot appears in the cell it already visited before, it breaks. It stops and doesn't move anymore. Robot can choose any cell as the starting cell, and its goal is to make the maximum number of steps before it breaks or stops. Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written. It does not matter whether to another square or beyond the edge of the board.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "mutate_method": "expand_one2two", "save_node": true, "parent_index": 116}
