{"name": "1607_E. Robot on the Board 1", "description": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nThe sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).\n\nDetermine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "tags": ["implementation"], "difficulty": 11, "id": 1607, "sample_io": [{"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}], "test_list": [{"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n5 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n1 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 1\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 4\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n1 1\n3 4\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n2 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 1\n2 1\n4 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRUDLLLDU\n", "output": ["1 2\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n2 2\nLUUDRLDLRLUU\n", "output": ["1 1\n1 2\n2 1\n2 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 1\nUULDRR\n4 2\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 1\n1 1\n4 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 1\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nLRDRUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 2\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n17 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 1\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 1\n3 1\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n4 4\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n5 2\nL\n3 3\nRRDLUU\n6 3\nLUUURRDLLLDU\n", "output": ["1 1\n1 2\n2 1\n4 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n4 4\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 4\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 1\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n4 3\nRRDLUU\n3 4\nDUULRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n2 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 2\nUULRRD\n6 2\nUULULDRRDULL\n", "output": ["1 1\n1 2\n3 2\n4 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n13 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n9 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n22 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n8 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n6 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n1 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRDRLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n5 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n4 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUT\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n6 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRDRLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n4 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n6 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDURDURL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n10 3\nRRDLUU\n6 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 2\nLUUDRLDLRLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n7 3\nRRDLUU\n8 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n8 3\nLUUDRRDLLLUT\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n5 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n3 3\nRRDUUL\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n6 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n3 3\nUULDRR\n11 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n7 3\nRRDLUU\n8 2\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n3 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nDRRLUU\n6 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n12 3\nRRDLUU\n8 2\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n2 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n5 2\nL\n3 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n10 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n4 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nLUULRRDLDLUU\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n2 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n5 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n2 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n10 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n6 3\nRRDLUU\n9 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRRDLUU\n8 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n2 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nUULDRR\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n4 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRDRLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nLUULRRDDLLUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nUULDRR\n4 2\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n6 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 4\nLUUDRRLLLDUU\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDURDURL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n1 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n2 2\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n5 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n8 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nDRRLUU\n6 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n5 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n12 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nUULDRR\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDTUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n5 3\nUUULLDRRDULL\n", "output": ["1 1\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 1\nL\n10 2\nL\n2 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 2\nUULDRR\n10 3\nLUULRRDDLLUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n23 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDTUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n13 2\nL\n2 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n6 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n9 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n15 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLRUURDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n4 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDUUL\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n4 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n11 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUV\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n5 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n12 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nUULRDR\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}], "task_id": "codecontest/102", "repair_prompt": ["The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns), where rows are numbered from 1 to n from top to bottom, and columns \u2014 from 1 to m from left to right. The robot is able to move from the current cell to one of the four cells adjacent by side. The sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U'. Each symbol triggers the movement to left, right, down or up, respectively. The robot can start its movement in any cell, and executes the commands starting from the first one, strictly in the order in which they are listed in s; if the robot moves beyond the edge of the board, it falls and breaks, so a command that causes the robot to break is not considered successfully executed. The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge; if the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column). Determine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The robot can start its movement in any cell, and executes the commands starting from the first one, strictly in the order in which they are listed in s; if the robot moves beyond the edge of the board, it falls and breaks, so a command that causes the robot to break is not considered successfully executed. The robot's task is to execute as many commands as possible without falling off the board.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The robot can start its movement in any cell and executes the commands starting from the first one; determine the cell from which the robot should start to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def determine_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            current_commands = 0\n            x, y = i, j\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = determine_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n\nmain()", "completions": ["def find_starting_cell(n, m, s):\n    max_commands = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            commands = 0\n\n            for command in s:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n\n                commands += 1\n\n            if commands > max_commands:\n                max_commands = commands\n                start_cell = (i, j)\n\n    return start_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input().strip()\n    result = find_starting_cell(n, m, s)\n    results.append(result)\n\nfor result in results:\n    print(result[0], result[1])\n\nmain()", "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            curr_commands = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                curr_commands += 1\n            \n            if curr_commands > max_commands:\n                max_commands = curr_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n\nmain()", "def find_starting_cell(n, m, s):\n    max_commands = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            commands_executed = 0\n            x, y = i, j\n\n            for command in s:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                commands_executed += 1\n\n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                start_cell = (i, j)\n\n    return start_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input().strip()\n    start_cell = find_starting_cell(n, m, s)\n    results.append(start_cell)\n\nfor result in results:\n    print(result[0], result[1])\n\nmain()", "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            x, y = i, j\n            curr_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                curr_commands += 1\n            \n            if curr_commands > max_commands:\n                max_commands = curr_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n\nmain()", "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            curr_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                curr_commands += 1\n            \n            if curr_commands > max_commands:\n                max_commands = curr_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n\nmain()", "def execute_commands(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            current_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = execute_commands(n, m, commands)\n    results.append(result)\n\nfor result in results:\n    print(result[0], result[1])\n\nmain()", "def determine_starting_cell(test_cases):\n    for i in range(test_cases):\n        n, m = map(int, input().split())\n        commands = input()\n\n        max_commands = 0\n        start_cell = (1, 1)\n\n        for r in range(1, n + 1):\n            for c in range(1, m + 1):\n                current_commands = 0\n                current_r, current_c = r, c\n\n                for command in commands:\n                    if command == 'L':\n                        current_c -= 1\n                    elif command == 'R':\n                        current_c += 1\n                    elif command == 'U':\n                        current_r -= 1\n                    elif command == 'D':\n                        current_r += 1\n\n                    if 1 <= current_r <= n and 1 <= current_c <= m:\n                        current_commands += 1\n\n                if current_commands > max_commands:\n                    max_commands = current_commands\n                    start_cell = (r, c)\n\n        print(start_cell[0], start_cell[1])\n\n# Read the number of test cases\ntest_cases = int(input())\n\n# Call the function to determine the starting cell for each test case\ndetermine_starting_cell(test_cases)\n\nmain()", "def execute_commands(n, m, commands):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def count_successful_commands(start_x, start_y):\n        x, y = start_x, start_y\n        count = 0\n        for command in commands:\n            dx, dy = directions[command]\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y):\n                x, y = new_x, new_y\n                count += 1\n            else:\n                break\n        return count\n\n    max_commands = 0\n    best_start = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            commands_count = count_successful_commands(i, j)\n            if commands_count > max_commands:\n                max_commands = commands_count\n                best_start = (i + 1, j + 1)\n\n    return best_start\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = execute_commands(n, m, commands)\n    results.append(result)\n\nfor res in results:\n    print(res[0], res[1])\n\nmain()", "def determine_starting_cell(test_cases):\n    for i in range(test_cases):\n        n, m = map(int, input().split())\n        commands = input()\n\n        max_commands = 0\n        start_cell = (1, 1)\n\n        for row in range(1, n + 1):\n            for col in range(1, m + 1):\n                current_commands = 0\n                r, c = row, col\n\n                for command in commands:\n                    if command == 'L':\n                        c -= 1\n                    elif command == 'R':\n                        c += 1\n                    elif command == 'U':\n                        r -= 1\n                    elif command == 'D':\n                        r += 1\n\n                    if 1 <= r <= n and 1 <= c <= m:\n                        current_commands += 1\n\n                if current_commands > max_commands:\n                    max_commands = current_commands\n                    start_cell = (row, col)\n\n        print(start_cell[0], start_cell[1])\n\n# Read the number of test cases\ntest_cases = int(input())\n\n# Call the function to determine the starting cell for each test case\ndetermine_starting_cell(test_cases)\n\nmain()", "def determine_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            current_commands = 0\n            x, y = i, j\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = determine_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n\nmain()"], "session_history": {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and their descriptions\",\n      \"For each test case, extract the field dimensions and the sequence of commands\",\n      \"Determine the cell from which the robot should start moving to perform as many commands as possible\"\n    ],\n    \"major_steps\": [\n      \"Read the input from standard input\",\n      \"Parse the input to extract the number of test cases\",\n      \"For each test case, extract the field dimensions and the sequence of commands\",\n      \"Implement a function to determine the cell from which the robot should start moving to perform as many commands as possible\",\n      \"Print the output to standard output in the specified format\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sequence of commands'\n    Explanation: The robot needs to execute a sequence of commands 'L', 'R', 'D', 'U' in the given field to determine the starting cell for maximum command execution.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented step by step as they are sequential and dependent on each other.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    L\n    Output:\n    1 1\n    Explanation: With only one cell and one command 'L', the robot should start from cell (1, 1) to execute the command.\n    \n    Test Case 2:\n    Input:\n    1 2\n    L\n    Output:\n    1 2\n    Explanation: With one row and two columns, the robot should start from cell (1, 2) to execute the command 'L'.\n    \n    Test Case 3:\n    Input:\n    3 3\n    RRDLUU\n    Output:\n    2 1\n    Explanation: The robot should start from cell (2, 1) to execute the sequence of commands 'RRDLUU'.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to determine the starting cell for maximum command execution can handle all scenarios.", "Round_0": {"code": "def determine_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            current_commands = 0\n            x, y = i, j\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = determine_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 44)"}, "Round_1": {"code": "def determine_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            current_commands = 0\n            x, y = i, j\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = determine_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the descriptions of each test case\",\n    \"For each test case, extract the height, width, and sequence of commands\",\n    \"Determine the starting cell that will allow the robot to execute the most commands without falling off the board\"\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases\",\n    \"For each test case, read the height, width, and sequence of commands\",\n    \"Iterate through each cell on the board and simulate the robot's movement based on the commands\",\n    \"Track the number of successful commands executed from each starting cell\",\n    \"Output the coordinates of the cell that allows the robot to execute the most commands\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'movement': refers to the actions the robot can take based on the commands provided.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve reading input, parsing data, simulating robot movement, tracking successful commands, and outputting the result.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    L\n    Output:\n    1 1\n    Explanation:\n    The robot can only move left in a 1x1 grid, so it should start at cell (1, 1) to execute the command 'L'.\n\n    Test Case 2:\n    Input:\n    1 2\n    L\n    Output:\n    1 2\n    Explanation:\n    The robot can only move left in a 1x2 grid, so it should start at cell (1, 2) to execute the command 'L'.\n\n    Test Case 3:\n    Input:\n    3 3\n    RRDLUU\n    Output:\n    2 1\n    Explanation:\n    The robot can execute the most commands starting from cell (2, 1) in a 3x3 grid by following the sequence 'RRDLUU'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should be sufficient to handle the given requirements.", "Round_0": {"code": "def find_starting_cell(n, m, s):\n    max_commands = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            commands = 0\n\n            for command in s:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n\n                commands += 1\n\n            if commands > max_commands:\n                max_commands = commands\n                start_cell = (i, j)\n\n    return start_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input().strip()\n    result = find_starting_cell(n, m, s)\n    results.append(result)\n\nfor result in results:\n    print(result[0], result[1])\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 48)"}, "Round_1": {"code": "def find_starting_cell(n, m, s):\n    max_commands = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            commands = 0\n\n            for command in s:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n\n                commands += 1\n\n            if commands > max_commands:\n                max_commands = commands\n                start_cell = (i, j)\n\n    return start_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input().strip()\n    result = find_starting_cell(n, m, s)\n    results.append(result)\n\nfor result in results:\n    print(result[0], result[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the descriptions of each test case\",\n    \"For each test case, extract the height, width, and sequence of commands\",\n    \"Determine the starting cell that will allow the robot to execute the most commands without falling off the board\"\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases\",\n    \"For each test case, read the height, width, and sequence of commands\",\n    \"Iterate through each cell on the board and simulate the robot's movement based on the commands\",\n    \"Track the number of successful commands executed from each starting cell\",\n    \"Output the coordinates of the cell that allows the robot to execute the most commands\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'movement': refers to the actions the robot can take based on the commands provided.\n    'successful execution': indicates the ability of the robot to complete a command without falling off the board.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve parsing input, extracting information, simulating movements, tracking successful commands, and outputting the coordinates.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    L\n    Output:\n    1 1\n    Explanation:\n    The robot starts at cell (1, 1) and executes the command 'L', which is within the board limits.\n    \n    Test Case 2:\n    Input:\n    1 2\n    L\n    Output:\n    1 2\n    Explanation:\n    The robot starts at cell (1, 2) and executes the command 'L', which is within the board limits.\n\n    Test Case 3:\n    Input:\n    3 3\n    RRDLUU\n    Output:\n    2 1\n    Explanation:\n    The robot can start at cell (2, 1) to execute the most commands without falling off the board.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover the scenarios effectively.", "Round_0": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            curr_commands = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                curr_commands += 1\n            \n            if curr_commands > max_commands:\n                max_commands = curr_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            curr_commands = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                curr_commands += 1\n            \n            if curr_commands > max_commands:\n                max_commands = curr_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and their descriptions\",\n    \"For each test case, extract the height, width, and sequence of commands\",\n    \"Determine the starting cell that allows the robot to execute the most commands without falling off the board\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and their descriptions\",\n    \"For each test case, extract the height, width, and sequence of commands\",\n    \"Create a function to simulate the robot's movement based on the commands\",\n    \"Iterate through all cells to find the starting cell that maximizes the number of successfully executed commands\",\n    \"Output the coordinates of the optimal starting cell for each test case\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'movement': refers to the actions the robot takes based on the commands provided.\n    'falling off the board': indicates that if the robot moves beyond the board's boundaries, it fails.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they are sequential in nature.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    L\n    Output:\n    1 1\n    Explanation:\n    The robot starts at cell (1, 1) and executes the command 'L', which is within the board boundaries.\n    \n    Test Case 2:\n    Input:\n    1 2\n    L\n    Output:\n    1 2\n    Explanation:\n    The robot starts at cell (1, 2) and executes the command 'L', which is within the board boundaries.\n\n    Test Case 3:\n    Input:\n    3 3\n    RRDLUU\n    Output:\n    2 1\n    Explanation:\n    The robot starts at cell (2, 1) and executes the commands 'RRDLUU', maximizing the number of successful commands without falling off the board.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "def find_starting_cell(n, m, s):\n    max_commands = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            commands_executed = 0\n            x, y = i, j\n\n            for command in s:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                commands_executed += 1\n\n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                start_cell = (i, j)\n\n    return start_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input().strip()\n    start_cell = find_starting_cell(n, m, s)\n    results.append(start_cell)\n\nfor result in results:\n    print(result[0], result[1])\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 47)"}, "Round_1": {"code": "def find_starting_cell(n, m, s):\n    max_commands = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            commands_executed = 0\n            x, y = i, j\n\n            for command in s:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                commands_executed += 1\n\n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                start_cell = (i, j)\n\n    return start_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input().strip()\n    start_cell = find_starting_cell(n, m, s)\n    results.append(start_cell)\n\nfor result in results:\n    print(result[0], result[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"For each test case, determine the starting cell that allows the robot to execute the maximum number of commands without falling off the board\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the necessary information for each test case\",\n    \"Create a function to determine the maximum number of commands that can be executed starting from a given cell\",\n    \"Iterate through all cells on the board to find the cell that allows the robot to execute the maximum number of commands\",\n    \"Output the coordinates of the cell that maximizes the number of executed commands for each test case\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'checkered rectangular board': The board on which the robot moves is a grid with rows and columns.\n    'sequence of commands': The robot follows a sequence of commands denoted by 'L', 'R', 'D', 'U' for left, right, down, and up movements respectively.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they involve parsing input, determining starting cell, and iterating through cells.\n\n# [edge case] \n    Test Case 1:\n    1 1\n    L\n    Output: 1 1\n    Explanation: With only one cell, the robot can only start from that cell.\n    \n    Test Case 2:\n    1 2\n    L\n    Output: 1 2\n    Explanation: The robot can start from the second cell to execute the command.\n    \n    Test Case 3:\n    3 3\n    RRDLUU\n    Output: 2 1\n    Explanation: Starting from cell (2, 1) allows the robot to execute the maximum number of commands without falling off.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should cover all scenarios.", "Round_0": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            x, y = i, j\n            curr_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                curr_commands += 1\n            \n            if curr_commands > max_commands:\n                max_commands = curr_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            x, y = i, j\n            curr_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                curr_commands += 1\n            \n            if curr_commands > max_commands:\n                max_commands = curr_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"For each test case, determine the starting cell that allows the robot to execute the maximum number of commands without falling off the board\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the necessary information for each test case\",\n    \"Create a function to determine the maximum number of commands that can be executed starting from a given cell\",\n    \"Iterate through all cells on the board to find the cell that allows the robot to execute the maximum number of commands\",\n    \"Output the coordinates of the cell that maximizes the number of executed commands for each test case\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'movement': The core concept is about the movement of the robot on a checkered rectangular board based on the given commands.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'as many as possible': The degree adverb here implies that the robot should aim to execute the maximum number of commands without falling off the board.\n\n# [code logic]\n    All steps should be implemented step by step as there are no steps that need to be executed simultaneously.\n\n# [edge case] \n    Test Case 1:\n    1 1\n    L\n    Output:\n    1 1\n    Explanation: The robot is already at the only cell on the board, so it can execute the command successfully.\n    \n    Test Case 2:\n    1 2\n    L\n    Output:\n    1 2\n    Explanation: The robot can start at the second cell to execute the command successfully.\n    \n    Test Case 3:\n    3 3\n    RRDLUU\n    Output:\n    2 1\n    Explanation: Starting from cell (2, 1) allows the robot to execute all commands successfully.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should cover all scenarios.", "Round_0": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            curr_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                curr_commands += 1\n            \n            if curr_commands > max_commands:\n                max_commands = curr_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            curr_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                curr_commands += 1\n            \n            if curr_commands > max_commands:\n                max_commands = curr_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Determine the maximum number of commands that can be executed starting from each cell on the board\",\n    \"Identify the cell from which the robot should start moving to perform as many commands as possible\"\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases\",\n    \"For each test case:\",\n    \"   Read the board dimensions and command sequence\",\n    \"   Initialize a 2D array to store the maximum number of commands that can be executed starting from each cell\",\n    \"   Iterate through each cell on the board and calculate the maximum number of commands that can be executed starting from that cell\",\n    \"   Identify the cell with the maximum number of commands that can be executed\",\n    \"   Print the coordinates of the identified cell\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'movement': The core concept is about the movement of a robot on a checkered rectangular board based on a sequence of commands.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    Edge Case 1:\n    1 1\n    L\n    Expected Output: 1 1\n    Explanation: With only one cell and a left command, the robot should start from the same cell.\n    \n    Edge Case 2:\n    3 3\n    RRDLUU\n    Expected Output: 2 1\n    Explanation: Starting from cell (2, 1) allows the robot to execute all commands successfully.\n    \n    Edge Case 3:\n    4 3\n    LUURRDDLLLUU\n    Expected Output: 3 2\n    Explanation: Starting from cell (3, 2) allows the robot to execute the maximum number of commands successfully.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "def execute_commands(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            current_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = execute_commands(n, m, commands)\n    results.append(result)\n\nfor result in results:\n    print(result[0], result[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def execute_commands(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            current_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = execute_commands(n, m, commands)\n    results.append(result)\n\nfor result in results:\n    print(result[0], result[1])\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and their descriptions\",\n      \"For each test case, extract the field dimensions and the sequence of commands\",\n      \"Determine the cell from which the robot should start moving to perform as many commands as possible\"\n    ],\n    \"major_steps\": [\n      \"Read the input from standard input\",\n      \"Parse the input to extract the number of test cases\",\n      \"For each test case, extract the field dimensions and the sequence of commands\",\n      \"Implement a function to determine the cell from which the robot should start moving to perform as many commands as possible\",\n      \"Print the output to standard output in the specified format\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sequence of commands'\n    Explanation: The robot needs to execute a sequence of commands consisting of 'L', 'R', 'D', and 'U' to move on the field.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    L\n    Output:\n    1 1\n    Explanation: The robot can only start at cell (1, 1) and execute the single command 'L'.\n    \n    Test Case 2:\n    Input:\n    1 2\n    L\n    Output:\n    1 2\n    Explanation: The robot can start at cell (1, 2) and execute the single command 'L'.\n    \n    Test Case 3:\n    Input:\n    3 3\n    RRDLUU\n    Output:\n    2 1\n    Explanation: The robot can start at cell (2, 1) to execute the commands 'RRDLUU' and cover the most commands.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should cover all scenarios.", "Round_0": {"code": "def determine_starting_cell(test_cases):\n    for i in range(test_cases):\n        n, m = map(int, input().split())\n        commands = input()\n\n        max_commands = 0\n        start_cell = (1, 1)\n\n        for r in range(1, n + 1):\n            for c in range(1, m + 1):\n                current_commands = 0\n                current_r, current_c = r, c\n\n                for command in commands:\n                    if command == 'L':\n                        current_c -= 1\n                    elif command == 'R':\n                        current_c += 1\n                    elif command == 'U':\n                        current_r -= 1\n                    elif command == 'D':\n                        current_r += 1\n\n                    if 1 <= current_r <= n and 1 <= current_c <= m:\n                        current_commands += 1\n\n                if current_commands > max_commands:\n                    max_commands = current_commands\n                    start_cell = (r, c)\n\n        print(start_cell[0], start_cell[1])\n\n# Read the number of test cases\ntest_cases = int(input())\n\n# Call the function to determine the starting cell for each test case\ndetermine_starting_cell(test_cases)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def determine_starting_cell(test_cases):\n    for i in range(test_cases):\n        n, m = map(int, input().split())\n        commands = input()\n\n        max_commands = 0\n        start_cell = (1, 1)\n\n        for r in range(1, n + 1):\n            for c in range(1, m + 1):\n                current_commands = 0\n                current_r, current_c = r, c\n\n                for command in commands:\n                    if command == 'L':\n                        current_c -= 1\n                    elif command == 'R':\n                        current_c += 1\n                    elif command == 'U':\n                        current_r -= 1\n                    elif command == 'D':\n                        current_r += 1\n\n                    if 1 <= current_r <= n and 1 <= current_c <= m:\n                        current_commands += 1\n\n                if current_commands > max_commands:\n                    max_commands = current_commands\n                    start_cell = (r, c)\n\n        print(start_cell[0], start_cell[1])\n\n# Read the number of test cases\ntest_cases = int(input())\n\n# Call the function to determine the starting cell for each test case\ndetermine_starting_cell(test_cases)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Determine the maximum number of commands that can be executed starting from each cell on the board\",\n    \"Identify the cell from which the robot should start moving to perform as many commands as possible\"\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases\",\n    \"For each test case:\",\n    \"   Read the board dimensions and command sequence\",\n    \"   Initialize a 2D array to store the maximum number of commands that can be executed starting from each cell\",\n    \"   Iterate through each cell on the board and calculate the maximum number of commands that can be executed starting from that cell\",\n    \"   Identify the cell with the maximum number of commands that can be executed\",\n    \"   Print the coordinates of the identified cell\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'movement': The core concept is about the movement of a robot on a checkered rectangular board based on a sequence of commands.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    Edge Case 1:\n    1 1\n    L\n    Expected Output: 1 1\n    Explanation: With only one cell and one command to move left, the robot should start at the initial cell itself.\n\n    Edge Case 2:\n    3 3\n    RRDLUU\n    Expected Output: 2 1\n    Explanation: Starting from cell (2, 1) allows the robot to execute all commands successfully without falling off the board.\n\n    Edge Case 3:\n    4 3\n    LUURRDDLLLUU\n    Expected Output: 3 2\n    Explanation: Starting from cell (3, 2) allows the robot to execute the maximum number of commands successfully.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge cases)\n\nYES", "Round_0": {"code": "def execute_commands(n, m, commands):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def count_successful_commands(start_x, start_y):\n        x, y = start_x, start_y\n        count = 0\n        for command in commands:\n            dx, dy = directions[command]\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y):\n                x, y = new_x, new_y\n                count += 1\n            else:\n                break\n        return count\n\n    max_commands = 0\n    best_start = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            commands_count = count_successful_commands(i, j)\n            if commands_count > max_commands:\n                max_commands = commands_count\n                best_start = (i + 1, j + 1)\n\n    return best_start\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = execute_commands(n, m, commands)\n    results.append(result)\n\nfor res in results:\n    print(res[0], res[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def execute_commands(n, m, commands):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def count_successful_commands(start_x, start_y):\n        x, y = start_x, start_y\n        count = 0\n        for command in commands:\n            dx, dy = directions[command]\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y):\n                x, y = new_x, new_y\n                count += 1\n            else:\n                break\n        return count\n\n    max_commands = 0\n    best_start = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            commands_count = count_successful_commands(i, j)\n            if commands_count > max_commands:\n                max_commands = commands_count\n                best_start = (i + 1, j + 1)\n\n    return best_start\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = execute_commands(n, m, commands)\n    results.append(result)\n\nfor res in results:\n    print(res[0], res[1])\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and their descriptions\",\n      \"For each test case, extract the height, width, and sequence of commands\",\n      \"Determine the cell from which the robot should start moving to perform as many commands as possible\"\n    ],\n    \"major_steps\": [\n      \"Read the input from standard input\",\n      \"Parse the input to extract the number of test cases\",\n      \"For each test case, extract the height, width, and sequence of commands\",\n      \"Implement a function to determine the cell from which the robot should start moving\",\n      \"Print the output to standard output\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sequence of commands'\n    Explanation: The robot needs to execute a sequence of commands consisting of 'L', 'R', 'D', and 'U' to move on the field.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    L\n    Output:\n    1 1\n    Explanation: The robot can only start at cell (1, 1) and execute the single command 'L'.\n    \n    Test Case 2:\n    Input:\n    1 2\n    L\n    Output:\n    1 2\n    Explanation: The robot can start at cell (1, 2) and execute the single command 'L'.\n    \n    Test Case 3:\n    Input:\n    3 3\n    RRDLUU\n    Output:\n    2 1\n    Explanation: The robot can start at cell (2, 1) to execute the commands 'RRDLUU' and cover the most commands.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should cover all scenarios.", "Round_0": {"code": "def determine_starting_cell(test_cases):\n    for i in range(test_cases):\n        n, m = map(int, input().split())\n        commands = input()\n\n        max_commands = 0\n        start_cell = (1, 1)\n\n        for row in range(1, n + 1):\n            for col in range(1, m + 1):\n                current_commands = 0\n                r, c = row, col\n\n                for command in commands:\n                    if command == 'L':\n                        c -= 1\n                    elif command == 'R':\n                        c += 1\n                    elif command == 'U':\n                        r -= 1\n                    elif command == 'D':\n                        r += 1\n\n                    if 1 <= r <= n and 1 <= c <= m:\n                        current_commands += 1\n\n                if current_commands > max_commands:\n                    max_commands = current_commands\n                    start_cell = (row, col)\n\n        print(start_cell[0], start_cell[1])\n\n# Read the number of test cases\ntest_cases = int(input())\n\n# Call the function to determine the starting cell for each test case\ndetermine_starting_cell(test_cases)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def determine_starting_cell(test_cases):\n    for i in range(test_cases):\n        n, m = map(int, input().split())\n        commands = input()\n\n        max_commands = 0\n        start_cell = (1, 1)\n\n        for row in range(1, n + 1):\n            for col in range(1, m + 1):\n                current_commands = 0\n                r, c = row, col\n\n                for command in commands:\n                    if command == 'L':\n                        c -= 1\n                    elif command == 'R':\n                        c += 1\n                    elif command == 'U':\n                        r -= 1\n                    elif command == 'D':\n                        r += 1\n\n                    if 1 <= r <= n and 1 <= c <= m:\n                        current_commands += 1\n\n                if current_commands > max_commands:\n                    max_commands = current_commands\n                    start_cell = (row, col)\n\n        print(start_cell[0], start_cell[1])\n\n# Read the number of test cases\ntest_cases = int(input())\n\n# Call the function to determine the starting cell for each test case\ndetermine_starting_cell(test_cases)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and their descriptions\",\n      \"For each test case, extract the field dimensions and the sequence of commands\",\n      \"Determine the cell from which the robot should start moving to perform as many commands as possible\"\n    ],\n    \"major_steps\": [\n      \"Read the input from standard input\",\n      \"Parse the input to extract the number of test cases\",\n      \"For each test case, extract the field dimensions and the sequence of commands\",\n      \"Implement a function to determine the cell from which the robot should start moving to perform as many commands as possible\",\n      \"Print the output to standard output in the specified format\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sequence of commands'\n    Explanation: The robot needs to execute a sequence of commands 'L', 'R', 'D', 'U' in the given field to determine the starting cell for maximum command execution.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented step by step as they are sequential and dependent on each other.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    L\n    Output:\n    1 1\n    Explanation: With only one cell and one command 'L', the robot should start from cell (1, 1) to execute the command.\n    \n    Test Case 2:\n    Input:\n    1 2\n    L\n    Output:\n    1 2\n    Explanation: With one row and two columns, the robot should start from cell (1, 2) to execute the command 'L'.\n    \n    Test Case 3:\n    Input:\n    3 3\n    RRDLUU\n    Output:\n    2 1\n    Explanation: The robot should start from cell (2, 1) to execute the sequence of commands 'RRDLUU'.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to determine the starting cell for maximum command execution can handle all scenarios.", "Round_0": {"code": "def determine_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            current_commands = 0\n            x, y = i, j\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = determine_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 44)"}, "Round_1": {"code": "def determine_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            current_commands = 0\n            x, y = i, j\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = determine_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n"}}], "scores": [], "pass_results": [true, true, true, false, true, true, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 131, "prompt": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns), where rows are numbered from 1 to n from top to bottom, and columns \u2014 from 1 to m from left to right. The robot is able to move from the current cell to one of the four cells adjacent by side. The sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U'. Each symbol triggers the movement to left, right, down or up, respectively. The robot can start its movement in any cell, and executes the commands starting from the first one, strictly in the order in which they are listed in s; if the robot moves beyond the edge of the board, it falls and breaks, so a command that causes the robot to break is not considered successfully executed. The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge; if the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column). Determine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 44}
