{"name": "1607_E. Robot on the Board 1", "description": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nThe sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).\n\nDetermine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "tags": ["implementation"], "difficulty": 11, "id": 1607, "sample_io": [{"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}], "test_list": [{"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n5 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n1 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 1\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 4\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n1 1\n3 4\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n2 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 1\n2 1\n4 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRUDLLLDU\n", "output": ["1 2\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n2 2\nLUUDRLDLRLUU\n", "output": ["1 1\n1 2\n2 1\n2 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 1\nUULDRR\n4 2\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 1\n1 1\n4 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 1\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nLRDRUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 2\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n17 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 1\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 1\n3 1\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n4 4\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n5 2\nL\n3 3\nRRDLUU\n6 3\nLUUURRDLLLDU\n", "output": ["1 1\n1 2\n2 1\n4 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n4 4\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 4\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 1\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n4 3\nRRDLUU\n3 4\nDUULRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n2 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 2\nUULRRD\n6 2\nUULULDRRDULL\n", "output": ["1 1\n1 2\n3 2\n4 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n13 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n9 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n22 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n8 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n6 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n1 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRDRLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n5 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n4 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUT\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n6 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRDRLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n4 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n6 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDURDURL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n10 3\nRRDLUU\n6 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 2\nLUUDRLDLRLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n7 3\nRRDLUU\n8 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n8 3\nLUUDRRDLLLUT\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n5 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n3 3\nRRDUUL\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n6 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n3 3\nUULDRR\n11 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n7 3\nRRDLUU\n8 2\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n3 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nDRRLUU\n6 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n12 3\nRRDLUU\n8 2\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n2 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n5 2\nL\n3 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n10 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n4 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nLUULRRDLDLUU\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n2 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n5 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n2 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n10 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n6 3\nRRDLUU\n9 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRRDLUU\n8 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n2 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nUULDRR\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n4 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRDRLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nLUULRRDDLLUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nUULDRR\n4 2\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n6 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 4\nLUUDRRLLLDUU\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDURDURL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n1 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n2 2\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n5 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n8 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nDRRLUU\n6 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n5 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n12 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nUULDRR\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDTUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n5 3\nUUULLDRRDULL\n", "output": ["1 1\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 1\nL\n10 2\nL\n2 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 2\nUULDRR\n10 3\nLUULRRDDLLUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n23 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDTUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n13 2\nL\n2 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n6 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n9 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n15 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLRUURDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n4 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDUUL\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n4 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n11 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUV\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n5 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n12 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nUULRDR\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}], "task_id": "codecontest/102", "repair_prompt": ["The robot is positioned on a checkered rectangular board with dimensions n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot has the ability to move from the current cell to one of the four adjacent cells by side.\n\nThe sequence of commands s executed by the robot is provided. Each command is represented by one of the symbols 'L', 'R', 'D' or 'U', and causes movement to left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot begins its journey from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).\n\nFind out the cell the robot should start its journey from in order to carry out the maximum possible commands.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The robot can move from the current cell to one of the four adjacent cells by side. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\nThe robot is positioned on a checkered rectangular board with dimensions n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot has the ability to move from the current cell to one of the four adjacent cells by side. \n\nThe sequence of commands s executed by the robot is provided. Each command is represented by one of the symbols 'L', 'R', 'D' or 'U', and causes movement to left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed. \n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. \n\n<image> The robot begins its journey from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).\n\nFind out the cell the robot should start its journey from in order to carry out the maximum possible commands.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The robot is positioned on a checkered rectangular board with dimensions n \u00d7 m (n rows, m columns), and has the ability to move by side to one of the four adjacent cells. The robot's task is to execute as many commands as possible without falling off the board, finding the optimal starting cell for the journey.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the dimensions of the board and the sequence of commands\n    n, m = map(int, input().split())\n    commands = input()\n\n    # Initialize variables to keep track of the maximum number of commands and the starting cell\n    max_commands = 0\n    start_cell = (1, 1)\n\n    # Iterate through each cell to find the starting cell that allows the robot to execute the maximum number of commands\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                # Check if the robot falls off the board\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            # Update the maximum number of commands and the starting cell if a better solution is found\n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    # Output the starting cell coordinates for the current test case\n    print(start_cell[0], start_cell[1])\n\nmain()", "completions": ["t = int(input())\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n\n    max_commands = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    print(start_cell[0], start_cell[1])\n\nmain()", "# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the dimensions of the board and the sequence of commands\n    n, m = map(int, input().split())\n    commands = input()\n\n    # Initialize variables to track the maximum successful commands and the starting cell\n    max_commands = 0\n    start_cell = (1, 1)\n\n    # Iterate through each cell on the board to find the starting cell\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n\n            # Simulate the robot's movement based on the sequence of commands\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n\n                # Check if the robot falls off the board\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n\n                count += 1\n\n            # Update the maximum successful commands and starting cell if applicable\n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n\n    # Output the coordinates of the identified cell for each test case\n    print(start_cell[0], start_cell[1])\n\nmain()", "t = int(input())\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n\n    max_commands = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    print(start_cell[0], start_cell[1])\n\nmain()", "t = int(input())\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n\n    max_commands = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    print(start_cell[0], start_cell[1])\n\nmain()", "t = int(input())\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n\n    max_commands = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    print(start_cell[0], start_cell[1])\n\nmain()", "def find_optimal_starting_cell(n, m, commands):\n    max_commands = 0\n    optimal_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            curr_i, curr_j = i, j\n            commands_executed = 0\n            \n            for command in commands:\n                if command == 'L':\n                    curr_j -= 1\n                elif command == 'R':\n                    curr_j += 1\n                elif command == 'U':\n                    curr_i -= 1\n                elif command == 'D':\n                    curr_i += 1\n                \n                if curr_i < 1 or curr_i > n or curr_j < 1 or curr_j > m:\n                    break\n                \n                commands_executed += 1\n            \n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                optimal_cell = (i, j)\n    \n    return optimal_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    optimal_cell = find_optimal_starting_cell(n, m, commands)\n    print(optimal_cell[0], optimal_cell[1])\n\nmain()", "# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the dimensions of the board and the sequence of commands\n    n, m = map(int, input().split())\n    commands = input()\n\n    # Initialize variables to track the maximum successful commands and the starting cell\n    max_commands = 0\n    start_cell = (1, 1)\n\n    # Iterate through each cell on the board to find the starting cell\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                # Check if the robot falls off the board\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            # Update the maximum successful commands and starting cell if applicable\n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    # Output the coordinates of the identified cell for each test case\n    print(start_cell[0], start_cell[1])\n\nmain()", "def find_optimal_starting_cell(n, m, commands):\n    x, y = 1, 1\n    max_commands = 0\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            curr_x, curr_y = i, j\n            commands_executed = 0\n            \n            for command in commands:\n                if command == 'L':\n                    curr_y -= 1\n                elif command == 'R':\n                    curr_y += 1\n                elif command == 'U':\n                    curr_x -= 1\n                elif command == 'D':\n                    curr_x += 1\n                \n                if curr_x < 1 or curr_x > n or curr_y < 1 or curr_y > m:\n                    break\n                \n                commands_executed += 1\n            \n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                x, y = i, j\n    \n    return x, y\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    optimal_starting_cell = find_optimal_starting_cell(n, m, commands)\n    print(optimal_starting_cell[0], optimal_starting_cell[1])\n\nmain()", "def find_optimal_starting_cell(n, m, commands):\n    max_commands = 0\n    optimal_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            curr_i, curr_j = i, j\n            commands_executed = 0\n            \n            for command in commands:\n                if command == 'L':\n                    curr_j -= 1\n                elif command == 'R':\n                    curr_j += 1\n                elif command == 'D':\n                    curr_i += 1\n                elif command == 'U':\n                    curr_i -= 1\n                \n                if curr_i < 1 or curr_i > n or curr_j < 1 or curr_j > m:\n                    break\n                \n                commands_executed += 1\n            \n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                optimal_cell = (i, j)\n    \n    return optimal_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    optimal_cell = find_optimal_starting_cell(n, m, commands)\n    print(optimal_cell[0], optimal_cell[1])\n\nmain()", "# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the dimensions of the board and the sequence of commands\n    n, m = map(int, input().split())\n    commands = input()\n\n    # Initialize variables to keep track of the maximum number of commands and the starting cell\n    max_commands = 0\n    start_cell = (1, 1)\n\n    # Iterate through each cell to find the starting cell that allows the robot to execute the maximum number of commands\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                # Check if the robot falls off the board\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            # Update the maximum number of commands and the starting cell if a better solution is found\n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    # Output the starting cell coordinates for the current test case\n    print(start_cell[0], start_cell[1])\n\nmain()"], "session_history": {"plan": "{\n  \"subproblems\": [\n    \"Identify the dimensions of the board and the sequence of commands for each test case\",\n    \"Determine the starting cell that allows the robot to execute the maximum number of commands without falling off the board\"\n  ],\n  \"high-level plan\": {\n    \"Step 1\": \"Parse the input to extract the dimensions of the board and the sequence of commands for each test case\",\n    \"Step 2\": \"Iterate through each test case and calculate the maximum number of commands the robot can execute without falling off the board\",\n    \"Step 3\": \"Output the starting cell coordinates that allow the robot to perform the maximum number of commands for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'dimensions of the board and the sequence of commands'\n    Explanation: The core concept involves understanding the size of the board (n x m) and the sequence of commands the robot needs to execute.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    Test Case 1:\n    1 1\n    L\n    Output: 1 1\n    Explanation: With a 1x1 board and a single command 'L', the robot can only start from the initial cell.\n    \n    Test Case 2:\n    1 2\n    L\n    Output: 1 2\n    Explanation: With a 1x2 board and a single command 'L', the robot can start from either cell to execute the command.\n    \n    Test Case 3:\n    3 3\n    RRDLUU\n    Output: 2 1\n    Explanation: Starting from cell (2, 1) allows the robot to execute all commands successfully.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the dimensions of the board and the sequence of commands\n    n, m = map(int, input().split())\n    commands = input()\n\n    # Initialize variables to keep track of the maximum number of commands and the starting cell\n    max_commands = 0\n    start_cell = (1, 1)\n\n    # Iterate through each cell to find the starting cell that allows the robot to execute the maximum number of commands\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                # Check if the robot falls off the board\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            # Update the maximum number of commands and the starting cell if a better solution is found\n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    # Output the starting cell coordinates for the current test case\n    print(start_cell[0], start_cell[1])\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 48)"}, "Round_1": {"code": "# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the dimensions of the board and the sequence of commands\n    n, m = map(int, input().split())\n    commands = input()\n\n    # Initialize variables to keep track of the maximum number of commands and the starting cell\n    max_commands = 0\n    start_cell = (1, 1)\n\n    # Iterate through each cell to find the starting cell that allows the robot to execute the maximum number of commands\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                # Check if the robot falls off the board\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            # Update the maximum number of commands and the starting cell if a better solution is found\n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    # Output the starting cell coordinates for the current test case\n    print(start_cell[0], start_cell[1])\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Identify the dimensions of the board and the sequence of commands for each test case\",\n    \"Determine the maximum number of commands the robot can execute without falling off the board\",\n    \"Find the cell from which the robot should start its journey to perform the maximum possible commands\"\n  ],\n  \"high-level plan\": {\n    \"Step 1\": \"Parse the input to extract the dimensions of the board and the sequence of commands for each test case\",\n    \"Step 2\": \"Iterate through each test case and simulate the robot's movement based on the sequence of commands\",\n    \"Step 3\": \"Track the number of successful commands executed by the robot without falling off the board\",\n    \"Step 4\": \"Identify the cell from which the robot should start its journey to maximize the number of successful commands\",\n    \"Step 5\": \"Output the coordinates of the identified cell for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The core concept involves simulating the movement of a robot on a rectangular board based on a sequence of commands.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    Test Case 1:\n    1 1\n    L\n    Output: 1 1\n    Explanation: With only one cell on the board, the robot can only start from that cell to execute the command.\n    \n    Test Case 2:\n    1 2\n    L\n    Output: 1 2\n    Explanation: The robot can start from the only available cell to execute the command.\n    \n    Test Case 3:\n    3 3\n    RRDLUU\n    Output: 2 1\n    Explanation: Starting from cell (2, 1) allows the robot to execute the maximum number of commands without falling off the board.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the dimensions of the board and the sequence of commands\n    n, m = map(int, input().split())\n    commands = input()\n\n    # Initialize variables to track the maximum successful commands and the starting cell\n    max_commands = 0\n    start_cell = (1, 1)\n\n    # Iterate through each cell on the board to find the starting cell\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                # Check if the robot falls off the board\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            # Update the maximum successful commands and starting cell if needed\n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    # Output the coordinates of the identified cell for each test case\n    print(start_cell[0], start_cell[1])\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 46)"}, "Round_1": {"code": "t = int(input())\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n\n    max_commands = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    print(start_cell[0], start_cell[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify the dimensions of the board and the sequence of commands for each test case\",\n    \"Determine the maximum number of commands the robot can execute without falling off the board\",\n    \"Find the cell from which the robot should start its journey to perform the maximum possible commands\"\n  ],\n  \"high-level plan\": {\n    \"Step 1\": \"Parse the input to extract the dimensions of the board and the sequence of commands for each test case\",\n    \"Step 2\": \"Iterate through each test case and simulate the robot's movement based on the sequence of commands\",\n    \"Step 3\": \"Track the number of successful commands executed by the robot without falling off the board\",\n    \"Step 4\": \"Identify the cell from which the robot should start its journey to maximize the number of successful commands\",\n    \"Step 5\": \"Output the coordinates of the identified cell for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The core concept involves simulating the movement of a robot on a rectangular board based on a sequence of commands.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve parsing input, simulating robot movement, tracking successful commands, identifying the starting cell, and outputting the coordinates.\n\n# [edge case] \n    Test Case 1:\n    1 1\n    L\n    Output:\n    1 1\n    Explanation: With only one cell on the board, the robot can only start from that cell to perform the command.\n    \n    Test Case 2:\n    1 2\n    L\n    Output:\n    1 2\n    Explanation: The robot can start from the only available cell to execute the command.\n    \n    Test Case 3:\n    3 3\n    RRDLUU\n    Output:\n    2 1\n    Explanation: Starting from cell (2, 1) allows the robot to execute the maximum number of commands without falling off the board.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the dimensions of the board and the sequence of commands\n    n, m = map(int, input().split())\n    commands = input()\n\n    # Initialize variables to track the maximum successful commands and the starting cell\n    max_commands = 0\n    start_cell = (1, 1)\n\n    # Iterate through each cell on the board to find the starting cell\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n\n            # Simulate the robot's movement based on the sequence of commands\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n\n                # Check if the robot falls off the board\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n\n                count += 1\n\n            # Update the maximum successful commands and starting cell if applicable\n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n\n    # Output the coordinates of the identified cell for each test case\n    print(start_cell[0], start_cell[1])\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 50)"}, "Round_1": {"code": "# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the dimensions of the board and the sequence of commands\n    n, m = map(int, input().split())\n    commands = input()\n\n    # Initialize variables to track the maximum successful commands and the starting cell\n    max_commands = 0\n    start_cell = (1, 1)\n\n    # Iterate through each cell on the board to find the starting cell\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n\n            # Simulate the robot's movement based on the sequence of commands\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n\n                # Check if the robot falls off the board\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n\n                count += 1\n\n            # Update the maximum successful commands and starting cell if applicable\n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n\n    # Output the coordinates of the identified cell for each test case\n    print(start_cell[0], start_cell[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify the dimensions of the board and the sequence of commands for each test case\",\n    \"Determine the starting cell that allows the robot to execute the maximum number of commands without falling off the board\"\n  ],\n  \"high-level plan\": {\n    \"Step 1\": \"Parse the input to extract the dimensions of the board and the sequence of commands for each test case\",\n    \"Step 2\": \"Iterate through each test case and calculate the maximum number of commands the robot can execute without falling off the board\",\n    \"Step 3\": \"Output the starting cell coordinates that allow the robot to perform the maximum number of commands for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'dimensions of the board': Refers to the number of rows and columns in the checkered rectangular board.\n    'sequence of commands': Refers to the movements the robot can make ('L' for left, 'R' for right, 'D' for down, 'U' for up).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they are sequential in nature.\n\n# [edge case] \n    Test Case 1:\n    1 1\n    L\n    Output: 1 1\n    Explanation: With only one cell on the board and a single command to move left, the robot should start from the initial cell itself to execute the command.\n    \n    Test Case 2:\n    1 2\n    L\n    Output: 1 2\n    Explanation: With a board of 1 row and 2 columns, the robot should start from the second cell to execute the command 'L'.\n    \n    Test Case 3:\n    3 3\n    RRDLUU\n    Output: 2 1\n    Explanation: Starting from cell (2, 1) allows the robot to execute all commands successfully without falling off the board.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should be sufficient to handle the scenarios. \n\nNO", "Round_0": {"code": "# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the dimensions of the board and the sequence of commands\n    n, m = map(int, input().split())\n    commands = input()\n\n    # Initialize variables to keep track of the maximum number of commands and the starting cell\n    max_commands = 0\n    start_cell = (1, 1)\n\n    # Iterate through each cell to find the starting cell that allows the robot to execute the maximum number of commands\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                # Check if the robot falls off the board\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            # Update the maximum number of commands and the starting cell if a better solution is found\n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    # Output the starting cell coordinates for the current test case\n    print(start_cell[0], start_cell[1])\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 48)"}, "Round_1": {"code": "t = int(input())\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n\n    max_commands = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    print(start_cell[0], start_cell[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify the dimensions of the board and the sequence of commands for each test case\",\n    \"Determine the starting cell that allows the robot to execute the maximum number of commands without falling off the board\"\n  ],\n  \"high-level plan\": {\n    \"Step 1\": \"Parse the input to extract the dimensions of the board and the sequence of commands for each test case\",\n    \"Step 2\": \"Iterate through each test case and calculate the maximum number of commands the robot can execute without falling off the board\",\n    \"Step 3\": \"Output the starting cell coordinates that allow the robot to perform the maximum number of commands for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'dimensions of the board and the sequence of commands'\n    Explanation: The core concept involves understanding the size of the board (n x m) and the sequence of commands the robot needs to execute.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they are described in the plan.\n\n# [edge case] \n    Test Case 1:\n    1 1\n    L\n    Output: 1 1\n    Explanation: With a board of size 1x1 and a single command 'L', the robot can only start from the initial cell.\n    \n    Test Case 2:\n    1 2\n    L\n    Output: 1 2\n    Explanation: With a board of size 1x2 and a single command 'L', the robot can start from either cell to execute the command.\n    \n    Test Case 3:\n    3 3\n    RRDLUU\n    Output: 2 1\n    Explanation: Starting from cell (2, 1) allows the robot to execute all commands successfully.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic should be able to handle all scenarios.", "Round_0": {"code": "# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the dimensions of the board and the sequence of commands\n    n, m = map(int, input().split())\n    commands = input()\n\n    # Initialize variables to keep track of the maximum number of commands and the starting cell\n    max_commands = 0\n    start_cell = (1, 1)\n\n    # Iterate through each cell to find the starting cell that allows the robot to execute the maximum number of commands\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                # Check if the robot falls off the board\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            # Update the maximum number of commands and the starting cell if a better solution is found\n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    # Output the starting cell coordinates for the current test case\n    print(start_cell[0], start_cell[1])\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 48)"}, "Round_1": {"code": "t = int(input())\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n\n    max_commands = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    print(start_cell[0], start_cell[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify the dimensions of the board and the sequence of commands for each test case\",\n    \"Determine the starting cell that allows the robot to execute the maximum number of commands without falling off the board\"\n  ],\n  \"high-level plan\": {\n    \"Step 1\": \"Parse the input to extract the dimensions of the board and the sequence of commands for each test case\",\n    \"Step 2\": \"Iterate through each test case and calculate the maximum number of commands the robot can execute without falling off the board\",\n    \"Step 3\": \"Output the starting cell coordinates that allow the robot to perform the maximum possible commands for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'dimensions of the board and the sequence of commands'\n    Explanation: The core concept involves understanding the size of the board (n x m) and the sequence of commands the robot needs to execute.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    Test Case 1:\n    1 1\n    L\n    Output: 1 1\n    Explanation: With a board of size 1x1 and a single command 'L', the robot can only start from the initial cell.\n    \n    Test Case 2:\n    1 2\n    L\n    Output: 1 2\n    Explanation: With a board of size 1x2 and a single command 'L', the robot can start from either cell to execute the command.\n    \n    Test Case 3:\n    3 3\n    RRDLUU\n    Output: 2 1\n    Explanation: Starting from cell (2, 1) allows the robot to execute all commands successfully.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic should be able to handle all scenarios effectively. \n\nNO", "Round_0": {"code": "# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the dimensions of the board and the sequence of commands\n    n, m = map(int, input().split())\n    commands = input()\n\n    # Initialize variables to keep track of the maximum number of commands and the starting cell\n    max_commands = 0\n    start_cell = (1, 1)\n\n    # Iterate through each cell to find the starting cell that allows the robot to execute the maximum number of commands\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                # Check if the robot falls off the board\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            # Update the maximum number of commands and the starting cell if a better solution is found\n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    # Output the starting cell coordinates for the current test case\n    print(start_cell[0], start_cell[1])\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 48)"}, "Round_1": {"code": "t = int(input())\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n\n    max_commands = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    print(start_cell[0], start_cell[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the descriptions of each test case\",\n    \"For each test case, extract the dimensions of the board and the sequence of commands\",\n    \"Find the optimal starting cell for the robot to execute as many commands as possible without falling off the board\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of test cases and the descriptions of each test case\",\n    \"Step 2\": \"For each test case, extract the dimensions of the board and the sequence of commands\",\n    \"Step 3\": \"Implement a function to find the optimal starting cell for the robot based on the given dimensions and sequence of commands\",\n    \"Step 4\": \"Output the coordinates of the optimal starting cell for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'dimensions': Refers to the height and width of the rectangular board where the robot is located.\n    'sequence of commands': Refers to the string consisting of 'L', 'R', 'D', 'U' representing left, right, down, and up movements respectively.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    L\n    Output:\n    1 1\n    Explanation:\n    The robot is already at the only cell on the board, so it should start from there.\n    \n    Test Case 2:\n    Input:\n    1 2\n    L\n    Output:\n    1 2\n    Explanation:\n    The robot can start from either cell as it only has one command to execute.\n\n    Test Case 3:\n    Input:\n    3 3\n    RRDLUU\n    Output:\n    2 1\n    Explanation:\n    The robot can start from cell (2, 1) to execute the maximum number of commands without falling off the board.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to find the optimal starting cell can handle all scenarios.", "Round_0": {"code": "def find_optimal_starting_cell(n, m, commands):\n    max_commands = 0\n    optimal_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            curr_i, curr_j = i, j\n            commands_executed = 0\n            \n            for command in commands:\n                if command == 'L':\n                    curr_j -= 1\n                elif command == 'R':\n                    curr_j += 1\n                elif command == 'U':\n                    curr_i -= 1\n                elif command == 'D':\n                    curr_i += 1\n                \n                if curr_i < 1 or curr_i > n or curr_j < 1 or curr_j > m:\n                    break\n                \n                commands_executed += 1\n            \n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                optimal_cell = (i, j)\n    \n    return optimal_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    optimal_cell = find_optimal_starting_cell(n, m, commands)\n    print(optimal_cell[0], optimal_cell[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_optimal_starting_cell(n, m, commands):\n    max_commands = 0\n    optimal_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            curr_i, curr_j = i, j\n            commands_executed = 0\n            \n            for command in commands:\n                if command == 'L':\n                    curr_j -= 1\n                elif command == 'R':\n                    curr_j += 1\n                elif command == 'U':\n                    curr_i -= 1\n                elif command == 'D':\n                    curr_i += 1\n                \n                if curr_i < 1 or curr_i > n or curr_j < 1 or curr_j > m:\n                    break\n                \n                commands_executed += 1\n            \n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                optimal_cell = (i, j)\n    \n    return optimal_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    optimal_cell = find_optimal_starting_cell(n, m, commands)\n    print(optimal_cell[0], optimal_cell[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify the dimensions of the board and the sequence of commands for each test case\",\n    \"Determine the maximum number of commands the robot can execute without falling off the board\",\n    \"Find the cell from which the robot should start its journey to perform the maximum possible commands\"\n  ],\n  \"high-level plan\": {\n    \"Step 1\": \"Parse the input to extract the dimensions of the board and the sequence of commands for each test case\",\n    \"Step 2\": \"Iterate through each test case and simulate the robot's movement based on the sequence of commands\",\n    \"Step 3\": \"Track the number of successful commands executed by the robot without falling off the board\",\n    \"Step 4\": \"Identify the cell from which the robot should start its journey to maximize the number of successful commands\",\n    \"Step 5\": \"Output the coordinates of the identified cell for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The core concept involves simulating the movement of a robot on a rectangular board based on a sequence of commands.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    Test Case 1:\n    1 1\n    L\n    Output:\n    1 1\n    Explanation: The robot starts at the only cell and can only execute one command.\n    \n    Test Case 2:\n    1 2\n    L\n    Output:\n    1 2\n    Explanation: The robot starts at the only cell and can only execute one command.\n    \n    Test Case 3:\n    3 3\n    RRDLUU\n    Output:\n    2 1\n    Explanation: The robot can start at cell (2, 1) to perform the maximum possible commands.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should be sufficient to handle the scenarios.", "Round_0": {"code": "# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the dimensions of the board and the sequence of commands\n    n, m = map(int, input().split())\n    commands = input()\n\n    # Initialize variables to track the maximum successful commands and the starting cell\n    max_commands = 0\n    start_cell = (1, 1)\n\n    # Iterate through each cell on the board to find the starting cell\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                # Check if the robot falls off the board\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            # Update the maximum successful commands and starting cell if applicable\n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    # Output the coordinates of the identified cell for each test case\n    print(start_cell[0], start_cell[1])\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 48)"}, "Round_1": {"code": "# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the dimensions of the board and the sequence of commands\n    n, m = map(int, input().split())\n    commands = input()\n\n    # Initialize variables to track the maximum successful commands and the starting cell\n    max_commands = 0\n    start_cell = (1, 1)\n\n    # Iterate through each cell on the board to find the starting cell\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                # Check if the robot falls off the board\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            # Update the maximum successful commands and starting cell if applicable\n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    # Output the coordinates of the identified cell for each test case\n    print(start_cell[0], start_cell[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the descriptions of each test case\",\n    \"For each test case, extract the dimensions of the board and the sequence of commands\",\n    \"Find the optimal starting cell for the robot to execute as many commands as possible without falling off the board\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of test cases and the descriptions of each test case\",\n    \"Step 2\": \"For each test case, extract the dimensions of the board and the sequence of commands\",\n    \"Step 3\": \"Implement a function to find the optimal starting cell for the robot based on the given dimensions and sequence of commands\",\n    \"Step 4\": \"Print the coordinates of the optimal starting cell for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'dimensions': Refers to the height and width of the rectangular board where the robot is located.\n    'sequence of commands': Refers to the string consisting of 'L', 'R', 'D', 'U' representing left, right, down, and up movements respectively.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    Test Case 1:\n    1 1\n    L\n    Output: 1 1\n    Explanation: With only one cell on the board, the robot starts at that cell.\n    \n    Test Case 2:\n    1 2\n    L\n    Output: 1 2\n    Explanation: The robot starts at the second cell to perform the left movement.\n    \n    Test Case 3:\n    3 3\n    RRDLUU\n    Output: 2 1\n    Explanation: The robot can start at cell (2, 1) to execute the sequence of commands.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should cover all scenarios. \n\nNO", "Round_0": {"code": "def find_optimal_starting_cell(n, m, commands):\n    x, y = 1, 1\n    max_commands = 0\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            curr_x, curr_y = i, j\n            commands_executed = 0\n            \n            for command in commands:\n                if command == 'L':\n                    curr_y -= 1\n                elif command == 'R':\n                    curr_y += 1\n                elif command == 'U':\n                    curr_x -= 1\n                elif command == 'D':\n                    curr_x += 1\n                \n                if curr_x < 1 or curr_x > n or curr_y < 1 or curr_y > m:\n                    break\n                \n                commands_executed += 1\n            \n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                x, y = i, j\n    \n    return x, y\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    optimal_starting_cell = find_optimal_starting_cell(n, m, commands)\n    print(optimal_starting_cell[0], optimal_starting_cell[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_optimal_starting_cell(n, m, commands):\n    x, y = 1, 1\n    max_commands = 0\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            curr_x, curr_y = i, j\n            commands_executed = 0\n            \n            for command in commands:\n                if command == 'L':\n                    curr_y -= 1\n                elif command == 'R':\n                    curr_y += 1\n                elif command == 'U':\n                    curr_x -= 1\n                elif command == 'D':\n                    curr_x += 1\n                \n                if curr_x < 1 or curr_x > n or curr_y < 1 or curr_y > m:\n                    break\n                \n                commands_executed += 1\n            \n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                x, y = i, j\n    \n    return x, y\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    optimal_starting_cell = find_optimal_starting_cell(n, m, commands)\n    print(optimal_starting_cell[0], optimal_starting_cell[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the descriptions of each test case\",\n    \"For each test case, extract the dimensions of the board and the sequence of commands\",\n    \"Find the optimal starting cell for the robot to execute as many commands as possible\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of test cases and the descriptions of each test case\",\n    \"Step 2\": \"For each test case, extract the dimensions of the board and the sequence of commands\",\n    \"Step 3\": \"Create a function to find the optimal starting cell for the robot based on the given dimensions and sequence of commands\",\n    \"Step 4\": \"Iterate through each test case and call the function to find the optimal starting cell\",\n    \"Step 5\": \"Print the coordinates of the optimal starting cell for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'dimensions': Refers to the height and width of the rectangular board where the robot is located.\n    'sequence of commands': Refers to the string consisting of 'L', 'R', 'D', 'U' representing left, right, down, and up movements respectively.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they involve different subproblems and tasks.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    L\n    Output:\n    1 1\n    Explanation:\n    The robot is already at the only cell, so it should start from there.\n\n    Test Case 2:\n    Input:\n    1 2\n    L\n    Output:\n    1 2\n    Explanation:\n    The robot can start from either cell as it only has one command to execute.\n\n    Test Case 3:\n    Input:\n    3 3\n    RRDLUU\n    Output:\n    2 1\n    Explanation:\n    The robot can start from cell (2, 1) to execute the maximum number of commands.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should cover all scenarios.", "Round_0": {"code": "def find_optimal_starting_cell(n, m, commands):\n    max_commands = 0\n    optimal_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            curr_i, curr_j = i, j\n            commands_executed = 0\n            \n            for command in commands:\n                if command == 'L':\n                    curr_j -= 1\n                elif command == 'R':\n                    curr_j += 1\n                elif command == 'D':\n                    curr_i += 1\n                elif command == 'U':\n                    curr_i -= 1\n                \n                if curr_i < 1 or curr_i > n or curr_j < 1 or curr_j > m:\n                    break\n                \n                commands_executed += 1\n            \n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                optimal_cell = (i, j)\n    \n    return optimal_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    optimal_cell = find_optimal_starting_cell(n, m, commands)\n    print(optimal_cell[0], optimal_cell[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_optimal_starting_cell(n, m, commands):\n    max_commands = 0\n    optimal_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            curr_i, curr_j = i, j\n            commands_executed = 0\n            \n            for command in commands:\n                if command == 'L':\n                    curr_j -= 1\n                elif command == 'R':\n                    curr_j += 1\n                elif command == 'D':\n                    curr_i += 1\n                elif command == 'U':\n                    curr_i -= 1\n                \n                if curr_i < 1 or curr_i > n or curr_j < 1 or curr_j > m:\n                    break\n                \n                commands_executed += 1\n            \n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                optimal_cell = (i, j)\n    \n    return optimal_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    optimal_cell = find_optimal_starting_cell(n, m, commands)\n    print(optimal_cell[0], optimal_cell[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify the dimensions of the board and the sequence of commands for each test case\",\n    \"Determine the starting cell that allows the robot to execute the maximum number of commands without falling off the board\"\n  ],\n  \"high-level plan\": {\n    \"Step 1\": \"Parse the input to extract the dimensions of the board and the sequence of commands for each test case\",\n    \"Step 2\": \"Iterate through each test case and calculate the maximum number of commands the robot can execute without falling off the board\",\n    \"Step 3\": \"Output the starting cell coordinates that allow the robot to perform the maximum number of commands for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'dimensions of the board and the sequence of commands'\n    Explanation: The core concept involves understanding the size of the board (n x m) and the sequence of commands the robot needs to execute.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    Test Case 1:\n    1 1\n    L\n    Output: 1 1\n    Explanation: With a 1x1 board and a single command 'L', the robot can only start from the initial cell.\n    \n    Test Case 2:\n    1 2\n    L\n    Output: 1 2\n    Explanation: With a 1x2 board and a single command 'L', the robot can start from either cell to execute the command.\n    \n    Test Case 3:\n    3 3\n    RRDLUU\n    Output: 2 1\n    Explanation: Starting from cell (2, 1) allows the robot to execute all commands successfully.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the dimensions of the board and the sequence of commands\n    n, m = map(int, input().split())\n    commands = input()\n\n    # Initialize variables to keep track of the maximum number of commands and the starting cell\n    max_commands = 0\n    start_cell = (1, 1)\n\n    # Iterate through each cell to find the starting cell that allows the robot to execute the maximum number of commands\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                # Check if the robot falls off the board\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            # Update the maximum number of commands and the starting cell if a better solution is found\n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    # Output the starting cell coordinates for the current test case\n    print(start_cell[0], start_cell[1])\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 48)"}, "Round_1": {"code": "# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the dimensions of the board and the sequence of commands\n    n, m = map(int, input().split())\n    commands = input()\n\n    # Initialize variables to keep track of the maximum number of commands and the starting cell\n    max_commands = 0\n    start_cell = (1, 1)\n\n    # Iterate through each cell to find the starting cell that allows the robot to execute the maximum number of commands\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            count = 0\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                # Check if the robot falls off the board\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                count += 1\n            \n            # Update the maximum number of commands and the starting cell if a better solution is found\n            if count > max_commands:\n                max_commands = count\n                start_cell = (i, j)\n    \n    # Output the starting cell coordinates for the current test case\n    print(start_cell[0], start_cell[1])\n"}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 11, "prompt": "The robot is positioned on a checkered rectangular board with dimensions n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot has the ability to move from the current cell to one of the four adjacent cells by side.\n\nThe sequence of commands s executed by the robot is provided. Each command is represented by one of the symbols 'L', 'R', 'D' or 'U', and causes movement to left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot begins its journey from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).\n\nFind out the cell the robot should start its journey from in order to carry out the maximum possible commands.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 11}
