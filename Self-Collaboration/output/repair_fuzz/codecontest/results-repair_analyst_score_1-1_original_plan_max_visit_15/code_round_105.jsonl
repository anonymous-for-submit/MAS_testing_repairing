{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "repair_prompt": ["Monocarp is the coach of the Berland State University programming teams. He decided to create a set of problems for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset. Make sure to consider edge cases where the number of problems n might be small.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp decided to select exactly 3 problems from n problems for the problemset, ensuring that either the topics of all three selected problems are different or the difficulties of all three selected problems are different. Determine the number of ways to select three problems for the problemset, taking into account scenarios where n, the number of problems, is small.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp is the coach of the Berland State University programming teams and decided to create a set of problems for a training session for his teams, where he has n problems that none of his students have seen yet, each with a unique topic and difficulty. Monocarp has decided to select exactly 3 problems from n problems for the problemset, and your task is to determine the number of ways to select three problems that satisfy at least one of two conditions.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "from itertools import combinations\n\n# Function to count the number of ways to select three problems that meet the conditions\ndef count_ways_to_select_problems(testcases):\n    for problems in testcases:\n        n = problems[0]\n        problem_list = problems[1:]\n        valid_combinations = 0\n        \n        # Generate all possible combinations of selecting 3 problems\n        all_combinations = list(combinations(problem_list, 3))\n        \n        # Filter out combinations that do not satisfy at least one of the conditions\n        for comb in all_combinations:\n            topics = set()\n            difficulties = set()\n            for problem in comb:\n                topics.add(problem[0])\n                difficulties.add(problem[1])\n            if len(topics) == 3 or len(difficulties) == 3:\n                valid_combinations += 1\n        \n        # Output the result for each testcase\n        print(valid_combinations)\n\n# Parse the input to extract the number of testcases and the details of each testcase\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    testcases.append([n] + problems)\n\n# Call the function to count the number of ways to select three problems\ncount_ways_to_select_problems(testcases)\n\nmain()", "completions": ["from itertools import combinations\n\n# Function to count the number of ways to select three problems that meet the conditions\ndef count_ways_to_select_problems(n, problems):\n    topics = set()\n    difficulties = set()\n    for topic, difficulty in problems:\n        topics.add(topic)\n        difficulties.add(difficulty)\n    \n    if n < 3:\n        return 0\n    \n    valid_combinations = 0\n    for comb in combinations(problems, 3):\n        comb_topics = set()\n        comb_difficulties = set()\n        for problem in comb:\n            comb_topics.add(problem[0])\n            comb_difficulties.add(problem[1])\n        \n        if len(comb_topics) == 3 or len(comb_difficulties) == 3:\n            valid_combinations += 1\n    \n    return valid_combinations\n\n# Main function to read input and output results\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        result = count_ways_to_select_problems(n, problems)\n        print(result)\n\nmain()", "def count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        num_topics = len(topics)\n        num_difficulties = len(difficulties)\n        \n        if n <= 3:\n            print(1)\n        else:\n            print(n*(n-1)*(n-2)//6 if num_topics == n or num_difficulties == n else n*(n-1)*(n-2)//2)\n\ncount_ways_to_select_problems()\n\nmain()", "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Generate all possible combinations of 3 problems\n    all_combinations = list(combinations(problems, 3))\n    \n    # Count the number of valid combinations\n    valid_combinations = 0\n    for comb in all_combinations:\n        topics = set()\n        difficulties = set()\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        if len(topics) == 3 or len(difficulties) == 3:\n            valid_combinations += 1\n    \n    # Output the result for each testcase\n    print(valid_combinations)\n\nmain()", "from itertools import combinations\n\n# Function to check if a set of 3 problems meet the requirements\ndef meets_requirements(problems):\n    topics = set()\n    difficulties = set()\n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Main function to calculate the number of ways to select 3 problems\ndef calculate_ways(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        valid_combinations = 0\n        for combination in combinations(problems, 3):\n            if meets_requirements(combination):\n                valid_combinations += 1\n        print(valid_combinations)\n\n# Input reading and function call\nif __name__ == \"__main__\":\n    testcases = int(input())\n    calculate_ways(testcases)\n\nmain()", "from itertools import combinations\n\n# Parse the input to extract the number of testcases\nt = int(input())\n\n# For each testcase\nfor _ in range(t):\n    # Parse the input to extract the number of problems\n    n = int(input())\n    \n    # Create a list of tuples containing the topic and difficulty of each problem\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Initialize count of ways to select 3 problems\n    count = 0\n    \n    # Iterate through the list of problems and count the number of ways to select three problems that meet the requirements\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the number of ways for each testcase\n    print(count)\n\nmain()", "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Generate all possible combinations of selecting 3 problems\n    all_combinations = list(combinations(problems, 3))\n    \n    # Count the number of valid combinations that satisfy at least one condition\n    valid_combinations = 0\n    for comb in all_combinations:\n        topics = set()\n        difficulties = set()\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        if len(topics) == 3 or len(difficulties) == 3:\n            valid_combinations += 1\n    \n    # Output the result for the current testcase\n    print(valid_combinations)\n\nmain()", "from collections import defaultdict\n\ndef count_ways_to_select_problems(t, testcases):\n    def count_valid_sets(problems):\n        topics_count = defaultdict(int)\n        difficulties_count = defaultdict(int)\n        for topic, difficulty in problems:\n            topics_count[topic] += 1\n            difficulties_count[difficulty] += 1\n        \n        total_valid_sets = 0\n        for topic, difficulty in problems:\n            total_valid_sets += (topics_count[topic] - 1) * (difficulties_count[difficulty] - 1)\n        \n        return total_valid_sets // 2\n    \n    results = []\n    for i in range(0, len(testcases), 2):\n        n = int(testcases[i])\n        problems = [tuple(map(int, testcases[i+1+j].split())) for j in range(n)]\n        ways = count_valid_sets(problems)\n        results.append(ways)\n    \n    return results\n\n# Input\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    testcases.append(input())\n    for _ in range(int(testcases[-1])):\n        testcases.append(input())\n\n# Output\nresults = count_ways_to_select_problems(t, testcases)\nfor result in results:\n    print(result)\n\nmain()", "from itertools import combinations\n\n# Function to check if a combination of problems meets the requirements\ndef meets_requirements(combination):\n    topics = set()\n    difficulties = set()\n    for problem in combination:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Main function to calculate the number of ways to select 3 problems\ndef select_problems():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        valid_combinations = 0\n        for combination in combinations(problems, 3):\n            if meets_requirements(combination):\n                valid_combinations += 1\n        \n        print(valid_combinations)\n\n# Run the main function\nselect_problems()\n\nmain()", "from itertools import combinations\n\ndef count_ways_to_select_problems(t, testcases):\n    def check_conditions(problems):\n        topics = set()\n        difficulties = set()\n        for problem in problems:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        return len(topics) == 3 or len(difficulties) == 3\n\n    results = []\n    for _ in range(t):\n        n = testcases[_][0]\n        problems = testcases[_][1:]\n        valid_combinations = 0\n        for combination in combinations(problems, 3):\n            if check_conditions(combination):\n                valid_combinations += 1\n        results.append(valid_combinations)\n    \n    return results\n\n# Input\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    testcases.append((n, problems))\n\n# Output\nresults = count_ways_to_select_problems(t, testcases)\nfor result in results:\n    print(result)\n\nmain()", "from itertools import combinations\n\n# Function to count the number of ways to select three problems that meet the conditions\ndef count_ways_to_select_problems(testcases):\n    for problems in testcases:\n        n = problems[0]\n        problem_list = problems[1:]\n        valid_combinations = 0\n        \n        # Generate all possible combinations of selecting 3 problems\n        all_combinations = list(combinations(problem_list, 3))\n        \n        # Filter out combinations that do not satisfy at least one of the conditions\n        for comb in all_combinations:\n            topics = set()\n            difficulties = set()\n            for problem in comb:\n                topics.add(problem[0])\n                difficulties.add(problem[1])\n            if len(topics) == 3 or len(difficulties) == 3:\n                valid_combinations += 1\n        \n        # Output the result for each testcase\n        print(valid_combinations)\n\n# Parse the input to extract the number of testcases and the details of each testcase\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    testcases.append([n] + problems)\n\n# Call the function to count the number of ways to select three problems\ncount_ways_to_select_problems(testcases)\n\nmain()"], "session_history": {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, extract the number of problems and their topics and difficulties\",\n    \"Identify all possible combinations of selecting 3 problems that satisfy at least one of the conditions\",\n    \"Count the number of valid combinations\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"step_2\": \"For each testcase, extract the number of problems and their topics and difficulties\",\n    \"step_3\": \"Generate all possible combinations of selecting 3 problems\",\n    \"step_4\": \"Filter out combinations that do not satisfy at least one of the conditions\",\n    \"step_5\": \"Count the number of valid combinations\",\n    \"step_6\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting 3 problems': Refers to the process of choosing 3 problems from a given set of problems.\n    'satisfy at least one of two conditions': Indicates that the selected 3 problems should meet at least one of the specified conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve different subproblems and operations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: There is only one way to select 3 problems, which is to choose all of them.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All possible combinations of selecting 3 problems are valid in this case.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: There are 10 ways to select 3 problems that meet the conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic for selecting 3 problems can handle different scenarios effectively.", "Round_0": {"code": "from itertools import combinations\n\n# Function to count the number of ways to select three problems that meet the conditions\ndef count_ways_to_select_problems(testcases):\n    for problems in testcases:\n        n = problems[0]\n        problem_list = problems[1:]\n        valid_combinations = 0\n        \n        # Generate all possible combinations of selecting 3 problems\n        all_combinations = list(combinations(problem_list, 3))\n        \n        # Filter out combinations that do not satisfy at least one of the conditions\n        for comb in all_combinations:\n            topics = set()\n            difficulties = set()\n            for problem in comb:\n                topics.add(problem[0])\n                difficulties.add(problem[1])\n            if len(topics) == 3 or len(difficulties) == 3:\n                valid_combinations += 1\n        \n        # Output the result for each testcase\n        print(valid_combinations)\n\n# Parse the input to extract the number of testcases and the details of each testcase\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    testcases.append([n] + problems)\n\n# Call the function to count the number of ways to select three problems\ncount_ways_to_select_problems(testcases)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 45)"}, "Round_1": {"code": "from itertools import combinations\n\n# Function to count the number of ways to select three problems that meet the conditions\ndef count_ways_to_select_problems(testcases):\n    for problems in testcases:\n        n = problems[0]\n        problem_list = problems[1:]\n        valid_combinations = 0\n        \n        # Generate all possible combinations of selecting 3 problems\n        all_combinations = list(combinations(problem_list, 3))\n        \n        # Filter out combinations that do not satisfy at least one of the conditions\n        for comb in all_combinations:\n            topics = set()\n            difficulties = set()\n            for problem in comb:\n                topics.add(problem[0])\n                difficulties.add(problem[1])\n            if len(topics) == 3 or len(difficulties) == 3:\n                valid_combinations += 1\n        \n        # Output the result for each testcase\n        print(valid_combinations)\n\n# Parse the input to extract the number of testcases and the details of each testcase\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    testcases.append([n] + problems)\n\n# Call the function to count the number of ways to select three problems\ncount_ways_to_select_problems(testcases)\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the details of each test case\",\n    \"For each test case, determine the number of ways to select three problems that meet the given conditions\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of test cases\",\n    \"Step 2\": \"For each test case, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"For each test case, iterate through all possible combinations of three problems\",\n    \"Step 4\": \"Check if the selected three problems meet the conditions specified in the requirement\",\n    \"Step 5\": \"Count the number of valid combinations and output the result\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties'\n    Explanation: The core concepts in the requirement are the topics and difficulties of the problems. Each problem has a unique topic and difficulty.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, iterating through combinations, checking conditions, and counting valid combinations.\n\n# [edge case] \n    1. 2\n       1 1\n       2 2\n    Output: 0\n    Explanation: With only 2 problems, it's not possible to select 3 problems that meet the conditions.\n    \n    2. 3\n       1 1\n       2 2\n       3 3\n    Output: 1\n    Explanation: Only one valid set of problems can be selected where topics and difficulties are different for all three problems.\n    \n    3. 4\n       1 1\n       2 2\n       3 3\n       4 4\n    Output: 4\n    Explanation: All possible combinations of 3 problems can be selected in this case.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "from itertools import combinations\n\n# Function to count the number of ways to select three problems that meet the conditions\ndef count_ways_to_select_problems(n, problems):\n    topics = set()\n    difficulties = set()\n    for topic, difficulty in problems:\n        topics.add(topic)\n        difficulties.add(difficulty)\n    \n    if n < 3:\n        return 0\n    \n    valid_combinations = 0\n    for comb in combinations(problems, 3):\n        comb_topics = set()\n        comb_difficulties = set()\n        for problem in comb:\n            comb_topics.add(problem[0])\n            comb_difficulties.add(problem[1])\n        \n        if len(comb_topics) == 3 or len(comb_difficulties) == 3:\n            valid_combinations += 1\n    \n    return valid_combinations\n\n# Main function to read input and output results\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        result = count_ways_to_select_problems(n, problems)\n        print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 47)"}, "Round_1": {"code": "from itertools import combinations\n\n# Function to count the number of ways to select three problems that meet the conditions\ndef count_ways_to_select_problems(n, problems):\n    topics = set()\n    difficulties = set()\n    for topic, difficulty in problems:\n        topics.add(topic)\n        difficulties.add(difficulty)\n    \n    if n < 3:\n        return 0\n    \n    valid_combinations = 0\n    for comb in combinations(problems, 3):\n        comb_topics = set()\n        comb_difficulties = set()\n        for problem in comb:\n            comb_topics.add(problem[0])\n            comb_difficulties.add(problem[1])\n        \n        if len(comb_topics) == 3 or len(comb_difficulties) == 3:\n            valid_combinations += 1\n    \n    return valid_combinations\n\n# Main function to read input and output results\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        result = count_ways_to_select_problems(n, problems)\n        print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the number of problems for each testcase\",\n    \"Read the topic and difficulty of each problem for each testcase\",\n    \"Determine the number of ways to select three problems that meet the given conditions\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases and the number of problems for each testcase\",\n    \"Step 2\": \"For each testcase, read the topic and difficulty of each problem\",\n    \"Step 3\": \"Implement a function to determine the number of ways to select three problems that meet the given conditions\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties'\n    Explanation: The core concepts in the requirement are the topics and difficulties of the problems. Monocarp needs to select 3 problems based on these attributes.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    There are no steps that should be implemented simultaneously. All steps should be implemented sequentially as per the plan.\n\n# [edge case] \n    n = 3\n    Output: 1\n    Explanation: When there are only 3 problems, there is only 1 way to select 3 problems.\n\n    n = 4\n    Output: 3\n    Explanation: When there are 4 problems, there are 3 ways to select 3 problems: (1, 2, 3), (1, 2, 4), (1, 3, 4).\n\n    n = 5\n    Output: 10\n    Explanation: When there are 5 problems, there are 10 ways to select 3 problems satisfying the conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to determine the number of ways to select 3 problems can handle small values of n effectively.", "Round_0": {"code": "def count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        num_topics = len(topics)\n        num_difficulties = len(difficulties)\n        \n        if n <= 3:\n            print(1)\n        else:\n            print(n*(n-1)*(n-2)//6 if num_topics == n or num_difficulties == n else n*(n-1)*(n-2)//2)\n\ncount_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 29)"}, "Round_1": {"code": "def count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        num_topics = len(topics)\n        num_difficulties = len(difficulties)\n        \n        if n <= 3:\n            print(1)\n        else:\n            print(n*(n-1)*(n-2)//6 if num_topics == n or num_difficulties == n else n*(n-1)*(n-2)//2)\n\ncount_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, extract the number of problems and their topics and difficulties\",\n    \"Identify all possible combinations of 3 problems that satisfy at least one of the conditions\",\n    \"Count the number of valid combinations\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases from input\",\n    \"Step 2\": \"For each testcase, read the number of problems and their details\",\n    \"Step 3\": \"Generate all possible combinations of 3 problems\",\n    \"Step 4\": \"Check each combination if it satisfies at least one of the conditions\",\n    \"Step 5\": \"Count the number of valid combinations\",\n    \"Step 6\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique topic and difficulty': Each problem has a distinct topic and difficulty level.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve different aspects of processing the input and generating combinations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: Since all problems have unique topics and difficulties, there is only one way to select 3 problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All problems have unique topics and difficulties, so all combinations of 3 problems are valid.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: All combinations of 3 problems are valid as they all have unique topics and difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to generate combinations and check validity covers all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Generate all possible combinations of 3 problems\n    all_combinations = list(combinations(problems, 3))\n    \n    # Count the number of valid combinations\n    valid_combinations = 0\n    for comb in all_combinations:\n        topics = set()\n        difficulties = set()\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        if len(topics) == 3 or len(difficulties) == 3:\n            valid_combinations += 1\n    \n    # Output the result for each testcase\n    print(valid_combinations)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 36)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Generate all possible combinations of 3 problems\n    all_combinations = list(combinations(problems, 3))\n    \n    # Count the number of valid combinations\n    valid_combinations = 0\n    for comb in all_combinations:\n        topics = set()\n        difficulties = set()\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        if len(topics) == 3 or len(difficulties) == 3:\n            valid_combinations += 1\n    \n    # Output the result for each testcase\n    print(valid_combinations)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the number of problems for each testcase\",\n    \"For each testcase, create a list of tuples containing the topic and difficulty of each problem\",\n    \"Iterate through all possible combinations of 3 problems and check if they meet the requirements\",\n    \"Count the number of valid combinations\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and create a list of tuples containing the topic and difficulty of each problem\",\n    \"Step 3\": \"Iterate through all possible combinations of 3 problems and check if they meet the requirements\",\n    \"Step 4\": \"Count the number of valid combinations and output the result\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics or difficulties'\n    Explanation: The core concept is to select 3 problems where either all topics are different or all difficulties are different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented step by step as they involve different subproblems and conditions.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, there is only one way to select 3 problems as all topics and difficulties are different.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: In this case, all combinations of 3 problems have different topics or difficulties, so there are 4 ways to select 3 problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: In this case, all combinations of 3 problems have different topics or difficulties, so there are 10 ways to select 3 problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of checking different topics or difficulties covers all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Function to check if a set of 3 problems meet the requirements\ndef meets_requirements(problems):\n    topics = set()\n    difficulties = set()\n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Main function to calculate the number of ways to select 3 problems\ndef calculate_ways(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        valid_combinations = 0\n        for combination in combinations(problems, 3):\n            if meets_requirements(combination):\n                valid_combinations += 1\n        print(valid_combinations)\n\n# Input reading and function call\nif __name__ == \"__main__\":\n    testcases = int(input())\n    calculate_ways(testcases)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 33)"}, "Round_1": {"code": "from itertools import combinations\n\n# Function to check if a set of 3 problems meet the requirements\ndef meets_requirements(problems):\n    topics = set()\n    difficulties = set()\n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Main function to calculate the number of ways to select 3 problems\ndef calculate_ways(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        valid_combinations = 0\n        for combination in combinations(problems, 3):\n            if meets_requirements(combination):\n                valid_combinations += 1\n        print(valid_combinations)\n\n# Input reading and function call\nif __name__ == \"__main__\":\n    testcases = int(input())\n    calculate_ways(testcases)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the number of problems for each testcase\",\n    \"For each testcase, create a list of tuples containing the topic and difficulty of each problem\",\n    \"Determine the number of ways to select three problems that meet the requirements\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and create a list of tuples containing the topic and difficulty of each problem\",\n    \"Step 3\": \"Iterate through the list of problems and count the number of ways to select three problems that meet the requirements\",\n    \"Step 4\": \"Output the number of ways for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics or difficulties'\n    Explanation: Monocarp needs to select 3 problems where either all three have different topics or all three have different difficulties.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, there is only one way to select 3 problems with different topics or difficulties.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All 4 problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: All 5 problems have different topics and difficulties, so there are 10 ways to select 3 problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to count the number of ways to select 3 problems already covers all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Parse the input to extract the number of testcases\nt = int(input())\n\n# For each testcase\nfor _ in range(t):\n    # Parse the input to extract the number of problems\n    n = int(input())\n    \n    # Create a list of tuples containing the topic and difficulty of each problem\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Initialize count of ways to select 3 problems\n    count = 0\n    \n    # Iterate through the list of problems and count the number of ways to select three problems that meet the requirements\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the number of ways for each testcase\n    print(count)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "from itertools import combinations\n\n# Parse the input to extract the number of testcases\nt = int(input())\n\n# For each testcase\nfor _ in range(t):\n    # Parse the input to extract the number of problems\n    n = int(input())\n    \n    # Create a list of tuples containing the topic and difficulty of each problem\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Initialize count of ways to select 3 problems\n    count = 0\n    \n    # Iterate through the list of problems and count the number of ways to select three problems that meet the requirements\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the number of ways for each testcase\n    print(count)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, extract the number of problems and their topics and difficulties\",\n    \"Identify all possible combinations of selecting 3 problems that satisfy at least one of the conditions\",\n    \"Count the number of valid combinations\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases from input\",\n    \"Step 2\": \"For each testcase, read the number of problems and their details\",\n    \"Step 3\": \"Generate all possible combinations of selecting 3 problems\",\n    \"Step 4\": \"Check each combination if it satisfies at least one of the conditions\",\n    \"Step 5\": \"Count the number of valid combinations\",\n    \"Step 6\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique topic and difficulty': Each problem has a distinct topic and difficulty level.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve different aspects of processing the input and generating combinations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: There is only one way to select 3 problems with unique topics and difficulties.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All 4 problems have unique topics and difficulties, so there are 4 ways to select 3 problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: All 5 problems have unique topics and difficulties, so there are 10 ways to select 3 problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic for generating combinations and checking conditions covers all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Generate all possible combinations of selecting 3 problems\n    all_combinations = list(combinations(problems, 3))\n    \n    # Count the number of valid combinations that satisfy at least one condition\n    valid_combinations = 0\n    for comb in all_combinations:\n        topics = set()\n        difficulties = set()\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        if len(topics) == 3 or len(difficulties) == 3:\n            valid_combinations += 1\n    \n    # Output the result for the current testcase\n    print(valid_combinations)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Generate all possible combinations of selecting 3 problems\n    all_combinations = list(combinations(problems, 3))\n    \n    # Count the number of valid combinations that satisfy at least one condition\n    valid_combinations = 0\n    for comb in all_combinations:\n        topics = set()\n        difficulties = set()\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        if len(topics) == 3 or len(difficulties) == 3:\n            valid_combinations += 1\n    \n    # Output the result for the current testcase\n    print(valid_combinations)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the details of each test case\",\n    \"For each test case, determine the number of ways to select three problems that meet the given conditions\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of test cases\",\n    \"Step 2\": \"For each test case, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Create a function to determine the number of ways to select three problems that meet the conditions\",\n    \"Step 4\": \"Implement the logic to check for the conditions and count the number of valid sets of problems\",\n    \"Step 5\": \"Output the result for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties'\n    Explanation: The core concepts in the requirement are the topics and difficulties of the problems. Each problem has a unique topic and difficulty.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    There are no steps that should be implemented simultaneously. Each step should be followed sequentially as outlined in the plan.\n\n# [edge case] \n    Test Case 1:\n    4\n    2 4\n    3 4\n    2 1\n    1 3\n    Output\n    3\n    Explanation: The valid sets of problems are (1, 2, 4), (1, 3, 4), and (2, 3, 4).\n    \n    Test Case 2:\n    5\n    1 5\n    2 4\n    3 3\n    4 2\n    5 1\n    Output\n    10\n    Explanation: There are 10 valid sets of problems that can be selected.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to determine the number of ways to select three problems already considers all possible combinations.", "Round_0": {"code": "from collections import defaultdict\n\ndef count_ways_to_select_problems(t, testcases):\n    def count_valid_sets(problems):\n        topics_count = defaultdict(int)\n        difficulties_count = defaultdict(int)\n        for topic, difficulty in problems:\n            topics_count[topic] += 1\n            difficulties_count[difficulty] += 1\n        \n        total_valid_sets = 0\n        for topic, difficulty in problems:\n            total_valid_sets += (topics_count[topic] - 1) * (difficulties_count[difficulty] - 1)\n        \n        return total_valid_sets // 2\n    \n    results = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        ways = count_valid_sets(problems)\n        results.append(ways)\n    \n    return results\n\n# Input\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    testcases.append(input())\n\n# Output\nresults = count_ways_to_select_problems(t, testcases)\nfor result in results:\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 42)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef count_ways_to_select_problems(t, testcases):\n    def count_valid_sets(problems):\n        topics_count = defaultdict(int)\n        difficulties_count = defaultdict(int)\n        for topic, difficulty in problems:\n            topics_count[topic] += 1\n            difficulties_count[difficulty] += 1\n        \n        total_valid_sets = 0\n        for topic, difficulty in problems:\n            total_valid_sets += (topics_count[topic] - 1) * (difficulties_count[difficulty] - 1)\n        \n        return total_valid_sets // 2\n    \n    results = []\n    for i in range(0, len(testcases), 2):\n        n = int(testcases[i])\n        problems = [tuple(map(int, testcases[i+1+j].split())) for j in range(n)]\n        ways = count_valid_sets(problems)\n        results.append(ways)\n    \n    return results\n\n# Input\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    testcases.append(input())\n    for _ in range(int(testcases[-1])):\n        testcases.append(input())\n\n# Output\nresults = count_ways_to_select_problems(t, testcases)\nfor result in results:\n    print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the number of problems for each testcase\",\n    \"For each testcase, create a list of tuples containing the topic and difficulty of each problem\",\n    \"Iterate through all possible combinations of 3 problems and check if they meet the requirements\",\n    \"Count the number of valid combinations\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Iterate through all possible combinations of 3 problems\",\n    \"Step 4\": \"Check if the combination meets the requirements (different topics or difficulties)\",\n    \"Step 5\": \"Count the number of valid combinations\",\n    \"Step 6\": \"Output the total number of valid combinations for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is to select exactly 3 problems from a given set, ensuring that either the topics of all three selected problems are different or the difficulties of all three selected problems are different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, creating combinations, checking requirements, and counting valid combinations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, all problems have different topics and difficulties, so there is only one way to select 3 problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All problems have different topics and difficulties, so there are four ways to select 3 problems.\n\n    Input:\n    1\n    4\n    1 1\n    1 2\n    2 1\n    2 2\n    Output:\n    0\n    Explanation: In this case, it's not possible to select 3 problems with different topics or difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to check for different topics or difficulties will cover all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Function to check if a combination of problems meets the requirements\ndef meets_requirements(combination):\n    topics = set()\n    difficulties = set()\n    for problem in combination:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Main function to calculate the number of ways to select 3 problems\ndef select_problems():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        valid_combinations = 0\n        for combination in combinations(problems, 3):\n            if meets_requirements(combination):\n                valid_combinations += 1\n        \n        print(valid_combinations)\n\n# Run the main function\nselect_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 37)"}, "Round_1": {"code": "from itertools import combinations\n\n# Function to check if a combination of problems meets the requirements\ndef meets_requirements(combination):\n    topics = set()\n    difficulties = set()\n    for problem in combination:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Main function to calculate the number of ways to select 3 problems\ndef select_problems():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        valid_combinations = 0\n        for combination in combinations(problems, 3):\n            if meets_requirements(combination):\n                valid_combinations += 1\n        \n        print(valid_combinations)\n\n# Run the main function\nselect_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the details of each test case\",\n    \"For each test case, determine the number of ways to select three problems that meet the given conditions\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of test cases\",\n    \"Step 2\": \"For each test case, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"For each test case, iterate through all possible combinations of three problems\",\n    \"Step 4\": \"Check if the selected three problems meet the conditions specified in the requirement\",\n    \"Step 5\": \"Count the number of valid combinations and output the result\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties'\n    Explanation: The core concepts in the requirement are the topics and difficulties of the problems. Each problem has a unique topic and difficulty.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, iterating through combinations, checking conditions, and counting valid combinations.\n\n# [edge case] \n    Case 1:\n    1\n    3\n    1 1\n    1 2\n    1 3\n    Expected Output:\n    0\n    Explanation: With only 3 problems and all having the same topic, it's impossible to select 3 problems with different topics or difficulties.\n\n    Case 2:\n    1\n    3\n    1 1\n    2 1\n    3 1\n    Expected Output:\n    0\n    Explanation: With only 3 problems and all having the same difficulty, it's impossible to select 3 problems with different topics or difficulties.\n\n    Case 3:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Expected Output:\n    1\n    Explanation: With 3 problems having different topics and difficulties, there is only one way to select 3 problems that meet the conditions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 3:\n            return 1\n        (other code)\n\nNO", "Round_0": {"code": "from itertools import combinations\n\ndef count_ways_to_select_problems(t, testcases):\n    def check_conditions(problems):\n        topics = set()\n        difficulties = set()\n        for problem in problems:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        return len(topics) == 3 or len(difficulties) == 3\n\n    results = []\n    for _ in range(t):\n        n = testcases[_][0]\n        problems = testcases[_][1:]\n        valid_combinations = 0\n        for combination in combinations(problems, 3):\n            if check_conditions(combination):\n                valid_combinations += 1\n        results.append(valid_combinations)\n    \n    return results\n\n# Input\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    testcases.append((n, problems))\n\n# Output\nresults = count_ways_to_select_problems(t, testcases)\nfor result in results:\n    print(result)\n", "report": "The compilation output of the preceding code is: closing parenthesis ')' does not match opening parenthesis '[' (<string>, line 42)"}, "Round_1": {"code": "from itertools import combinations\n\ndef count_ways_to_select_problems(t, testcases):\n    def check_conditions(problems):\n        topics = set()\n        difficulties = set()\n        for problem in problems:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        return len(topics) == 3 or len(difficulties) == 3\n\n    results = []\n    for _ in range(t):\n        n = testcases[_][0]\n        problems = testcases[_][1:]\n        valid_combinations = 0\n        for combination in combinations(problems, 3):\n            if check_conditions(combination):\n                valid_combinations += 1\n        results.append(valid_combinations)\n    \n    return results\n\n# Input\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    testcases.append((n, problems))\n\n# Output\nresults = count_ways_to_select_problems(t, testcases)\nfor result in results:\n    print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, extract the number of problems and their topics and difficulties\",\n    \"Identify all possible combinations of selecting 3 problems that satisfy at least one of the conditions\",\n    \"Count the number of valid combinations\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"step_2\": \"For each testcase, extract the number of problems and their topics and difficulties\",\n    \"step_3\": \"Generate all possible combinations of selecting 3 problems\",\n    \"step_4\": \"Filter out combinations that do not satisfy at least one of the conditions\",\n    \"step_5\": \"Count the number of valid combinations\",\n    \"step_6\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting 3 problems': Refers to the process of choosing 3 problems from a given set of problems.\n    'satisfy at least one of two conditions': Indicates that the selected 3 problems should meet at least one of the specified conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve different subproblems and operations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: There is only one way to select 3 problems, which is to choose all of them.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All possible combinations of selecting 3 problems are valid in this case.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: There are 10 ways to select 3 problems that meet the conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic for selecting 3 problems can handle different scenarios effectively.", "Round_0": {"code": "from itertools import combinations\n\n# Function to count the number of ways to select three problems that meet the conditions\ndef count_ways_to_select_problems(testcases):\n    for problems in testcases:\n        n = problems[0]\n        problem_list = problems[1:]\n        valid_combinations = 0\n        \n        # Generate all possible combinations of selecting 3 problems\n        all_combinations = list(combinations(problem_list, 3))\n        \n        # Filter out combinations that do not satisfy at least one of the conditions\n        for comb in all_combinations:\n            topics = set()\n            difficulties = set()\n            for problem in comb:\n                topics.add(problem[0])\n                difficulties.add(problem[1])\n            if len(topics) == 3 or len(difficulties) == 3:\n                valid_combinations += 1\n        \n        # Output the result for each testcase\n        print(valid_combinations)\n\n# Parse the input to extract the number of testcases and the details of each testcase\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    testcases.append([n] + problems)\n\n# Call the function to count the number of ways to select three problems\ncount_ways_to_select_problems(testcases)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 45)"}, "Round_1": {"code": "from itertools import combinations\n\n# Function to count the number of ways to select three problems that meet the conditions\ndef count_ways_to_select_problems(testcases):\n    for problems in testcases:\n        n = problems[0]\n        problem_list = problems[1:]\n        valid_combinations = 0\n        \n        # Generate all possible combinations of selecting 3 problems\n        all_combinations = list(combinations(problem_list, 3))\n        \n        # Filter out combinations that do not satisfy at least one of the conditions\n        for comb in all_combinations:\n            topics = set()\n            difficulties = set()\n            for problem in comb:\n                topics.add(problem[0])\n                difficulties.add(problem[1])\n            if len(topics) == 3 or len(difficulties) == 3:\n                valid_combinations += 1\n        \n        # Output the result for each testcase\n        print(valid_combinations)\n\n# Parse the input to extract the number of testcases and the details of each testcase\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    testcases.append([n] + problems)\n\n# Call the function to count the number of ways to select three problems\ncount_ways_to_select_problems(testcases)\n"}}], "scores": [], "pass_results": [false, true, true, false, true, true, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 105, "prompt": "Monocarp is the coach of the Berland State University programming teams. He decided to create a set of problems for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset. Make sure to consider edge cases where the number of problems n might be small.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 82}
