{"task_id": "HumanEval/87", "prompt": "def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which resembles a matrix, however, unlike matrices, each row can have a different count of columns. Provided lst, and integer x, identify integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", "entry_point": "get_row", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "test": ["def check(get_row):\n\tassert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "def check(get_row):\n\tassert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "def check(get_row):\n\tassert get_row([], 5) == []", "def check(get_row):\n\tassert get_row([[2]], 5) == []", "def check(get_row):\n\tassert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "def check(get_row):\n\tassert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[2]], 3) == []", "def check(get_row):\n\tassert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "def check(get_row):\n\tassert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "def check(get_row):\n\tassert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "def check(get_row):\n\tassert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "def check(get_row):\n\tassert get_row([], 6) == []", "def check(get_row):\n\tassert get_row([], 1) == []", "def check(get_row):\n\tassert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "def check(get_row):\n\tassert get_row([[2]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "def check(get_row):\n\tassert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "def check(get_row):\n\tassert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "def check(get_row):\n\tassert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "def check(get_row):\n\tassert get_row([[5]], 6) == []", "def check(get_row):\n\tassert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "def check(get_row):\n\tassert get_row([[4]], 4) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[4]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 3) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "def check(get_row):\n\tassert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "def check(get_row):\n\tassert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "def check(get_row):\n\tassert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "def check(get_row):\n\tassert get_row([], 2) == []", "def check(get_row):\n\tassert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "def check(get_row):\n\tassert get_row([[1]], 3) == []", "def check(get_row):\n\tassert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "def check(get_row):\n\tassert get_row([[2]], 7) == []", "def check(get_row):\n\tassert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "def check(get_row):\n\tassert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "def check(get_row):\n\tassert get_row([[1]], 2) == []", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "def check(get_row):\n\tassert get_row([], 4) == []", "def check(get_row):\n\tassert get_row([[1]], 6) == []", "def check(get_row):\n\tassert get_row([[6]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "def check(get_row):\n\tassert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "def check(get_row):\n\tassert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "def check(get_row):\n\tassert get_row([[5]], 7) == []", "def check(get_row):\n\tassert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "def check(get_row):\n\tassert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "def check(get_row):\n\tassert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "def check(get_row):\n\tassert get_row([], 3) == []", "def check(get_row):\n\tassert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "def check(get_row):\n\tassert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "def check(get_row):\n\tassert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "def check(get_row):\n\tassert get_row([[1]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "def check(get_row):\n\tassert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[6]], 5) == []", "def check(get_row):\n\tassert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "def check(get_row):\n\tassert get_row([[6]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 6) == []", "def check(get_row):\n\tassert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "test_case_list": ["assert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "assert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "assert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "assert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "assert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "assert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "assert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "assert get_row([], 5) == []", "assert get_row([[2]], 5) == []", "assert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "assert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "assert get_row([[2]], 3) == []", "assert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "assert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "assert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "assert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "assert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "assert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "assert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "assert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "assert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "assert get_row([], 6) == []", "assert get_row([], 1) == []", "assert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "assert get_row([[2]], 4) == []", "assert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "assert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "assert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "assert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "assert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "assert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "assert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "assert get_row([[5]], 6) == []", "assert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "assert get_row([[4]], 4) == [(0, 0)]", "assert get_row([[4]], 3) == []", "assert get_row([[3]], 3) == [(0, 0)]", "assert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "assert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "assert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "assert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "assert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "assert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "assert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "assert get_row([], 2) == []", "assert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "assert get_row([[1]], 3) == []", "assert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "assert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "assert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "assert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "assert get_row([[2]], 7) == []", "assert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "assert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "assert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "assert get_row([[1]], 2) == []", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "assert get_row([], 4) == []", "assert get_row([[1]], 6) == []", "assert get_row([[6]], 4) == []", "assert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "assert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "assert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "assert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "assert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "assert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "assert get_row([[5]], 7) == []", "assert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "assert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "assert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "assert get_row([], 3) == []", "assert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "assert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "assert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "assert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "assert get_row([[1]], 4) == []", "assert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "assert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "assert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "assert get_row([[6]], 5) == []", "assert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "assert get_row([[6]], 3) == []", "assert get_row([[3]], 6) == []", "assert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "assert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "nl": "\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    ", "func": "def get_row(lst, x):", "examples": "Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    ", "completion": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists, which resembles a matrix, however, unlike matrices, each row can have a different count of columns. Provided lst, and integer x, identify integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\n    Examples:\n        get_row([\n          [1,2,3,4,5,6],\n          [1,2,3,4,1,6],\n          [1,2,3,4,5,1]\n        ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n        get_row([], 1) == []\n        get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    # Validate the input\n    if not isinstance(lst, list) or not all(isinstance(row, list) for row in lst) or not isinstance(x, int):\n        raise ValueError(\"Invalid input: lst must be a list of lists and x must be an integer.\")\n\n    # Initialize an empty list to store the coordinates of x\n    coordinates = []\n\n    # Loop through each row in lst using an index to track the row number\n    for row_index, row in enumerate(lst):\n        # Within each row, loop through each element using an index to track the column number\n        for col_index, element in enumerate(row):\n            # If an element equals x, append the tuple (row_index, column_index) to the coordinates list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates list by row index in ascending order\n    # For each group of tuples with the same row index, sort them by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "completions": ["def get_row(lst, x):\n    # Initialize an empty list to store the coordinates of occurrences of x\n    coordinates = []\n\n    # Loop through each row of the nested list using an index to track the row number\n    for row_index, row in enumerate(lst):\n        # Within each row, loop through each element using an index to track the column number\n        for col_index, element in enumerate(row):\n            # If an element matches x, append the tuple (row_index, column_index) to the coordinates list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates list by row index in ascending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists, which resembles a matrix, however, unlike matrices, each row can have a different count of columns. Provided lst, and integer x, identify integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\n    Examples:\n        get_row([\n          [1,2,3,4,5,6],\n          [1,2,3,4,1,6],\n          [1,2,3,4,5,1]\n        ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n        get_row([], 1) == []\n        get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    \n    # Step 1: Input Validation\n    if not isinstance(lst, list) or not all(isinstance(row, list) for row in lst) or not isinstance(x, int):\n        raise ValueError(\"Invalid input: 'lst' must be a list of lists and 'x' must be an integer.\")\n    \n    # Step 2: Initialize an empty list to store the coordinates of 'x'\n    coordinates = []\n    \n    # Step 3: Loop through each row in 'lst' using an index to track the row number\n    for row_index, row in enumerate(lst):\n        # Step 4: Within each row, loop through each element using an index to track the column number\n        for column_index, element in enumerate(row):\n            # Step 5: If an element equals 'x', append the tuple (row_index, column_index) to the coordinates list\n            if element == x:\n                coordinates.append((row_index, column_index))\n    \n    # Step 6: Sort the list of coordinates by row index in ascending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    # Step 8: Return the sorted list of coordinates\n    return coordinates\n", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists, which resembles a matrix, however, unlike matrices, each row can have a different count of columns. Provided lst, and integer x, identify integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\n    Examples:\n        get_row([\n          [1,2,3,4,5,6],\n          [1,2,3,4,1,6],\n          [1,2,3,4,5,1]\n        ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n        get_row([], 1) == []\n        get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n\n    # Iterate through each row with its index\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row with its index\n        for col_index, value in enumerate(row):\n            # If the element matches x, record the coordinate\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort coordinates by row index in ascending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists, which resembles a matrix, however, unlike matrices, each row can have a different count of columns. Provided lst, and integer x, identify integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\n    Examples:\n        get_row([\n          [1,2,3,4,5,6],\n          [1,2,3,4,1,6],\n          [1,2,3,4,5,1]\n        ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n        get_row([], 1) == []\n        get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    # Initialize an empty list to store the coordinates of occurrences of x\n    coordinates = []\n\n    # Loop through each row of the list using an index to track the row number\n    for row_index, row in enumerate(lst):\n        # Within each row, loop through each element using an index to track the column number\n        for col_index, value in enumerate(row):\n            # If an element matches x, append the tuple (row_index, column_index) to the coordinates list\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates list by row index in ascending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists, which resembles a matrix, however, unlike matrices, each row can have a different count of columns. Provided lst, and integer x, identify integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\n    Examples:\n        get_row([\n          [1,2,3,4,5,6],\n          [1,2,3,4,1,6],\n          [1,2,3,4,5,1]\n        ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n        get_row([], 1) == []\n        get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n\n    # Iterate over each row in the nested list\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row\n        for col_index, value in enumerate(row):\n            # If the element matches x, record the coordinate\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates by row index in ascending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n", "def get_row(lst, x):\n    # Initialize an empty list to store the coordinates of occurrences of x\n    coordinates = []\n\n    # Loop through each row of the nested list using an index to track the row number\n    for row_index, row in enumerate(lst):\n        # Within each row, loop through each element using an index to track the column number\n        for column_index, element in enumerate(row):\n            # If an element matches x, append the tuple (row_index, column_index) to the coordinates list\n            if element == x:\n                coordinates.append((row_index, column_index))\n\n    # Sort the coordinates list by row index in ascending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists, which resembles a matrix, however, unlike matrices, each row can have a different count of columns. Provided lst, and integer x, identify integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\n    Examples:\n        get_row([\n          [1,2,3,4,5,6],\n          [1,2,3,4,1,6],\n          [1,2,3,4,5,1]\n        ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n        get_row([], 1) == []\n        get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    # Step 1: Validate the input to ensure it is a nested list and an integer.\n    if not isinstance(lst, list) or not isinstance(x, int):\n        raise ValueError(\"Invalid input: lst must be a list of lists and x must be an integer.\")\n\n    # Step 2: Initialize an empty list to store the coordinates of occurrences of x.\n    coordinates = []\n\n    # Step 3: Loop through each row of the nested list using an index to track the row number.\n    for row_index, row in enumerate(lst):\n        if not isinstance(row, list):\n            raise ValueError(\"Invalid input: each element of lst must be a list.\")\n\n        # Step 4: Within each row, loop through each element using an index to track the column number.\n        for col_index, value in enumerate(row):\n            # Step 5: If an element matches x, append the tuple (row_index, column_index) to the coordinates list.\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Step 6: Sort the list of coordinates by row index in ascending order.\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Step 8: Return the sorted list of coordinates.\n    return coordinates", "def get_row(lst, x):\n    # Initialize an empty list to store the coordinates of occurrences of x\n    coordinates = []\n\n    # Loop through each row of the nested list using an index to keep track of the row number\n    for row_index, row in enumerate(lst):\n        # Within each row, loop through each element using an index to keep track of the column number\n        for col_index, element in enumerate(row):\n            # If the element matches x, append the tuple (row_index, column_index) to the list of coordinates\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of tuples by the first element (row index) in ascending order\n    # For tuples with the same row index, sort them by the second element (column index) in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "def get_row(lst, x):\n    # Initialize an empty list to store the coordinates of occurrences of x\n    coordinates = []\n\n    # Iterate over each row in the nested list using an index to track the row number\n    for row_index, row in enumerate(lst):\n        # Within each row, iterate over each element using an index to track the column number\n        for col_index, element in enumerate(row):\n            # If an element matches x, append the tuple (row_index, column_index) to the list of coordinates\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates by row index in ascending order\n    # For coordinates with the same row index, sort them by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists, which resembles a matrix, however, unlike matrices, each row can have a different count of columns. Provided lst, and integer x, identify integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\n    Examples:\n        get_row([\n          [1,2,3,4,5,6],\n          [1,2,3,4,1,6],\n          [1,2,3,4,5,1]\n        ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n        get_row([], 1) == []\n        get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    # Validate the input\n    if not isinstance(lst, list) or not all(isinstance(row, list) for row in lst) or not isinstance(x, int):\n        raise ValueError(\"Invalid input: lst must be a list of lists and x must be an integer.\")\n\n    # Initialize an empty list to store the coordinates of x\n    coordinates = []\n\n    # Loop through each row in lst using an index to track the row number\n    for row_index, row in enumerate(lst):\n        # Within each row, loop through each element using an index to track the column number\n        for col_index, element in enumerate(row):\n            # If an element equals x, append the tuple (row_index, column_index) to the coordinates list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates list by row index in ascending order\n    # For each group of tuples with the same row index, sort them by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n"], "session_history": {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    \"1. Validate the input to ensure it is a list of lists and an integer.\",\n    \"2. Iterate through each row of the list to find occurrences of the integer x.\",\n    \"3. For each occurrence of x, record its coordinates as a tuple (row_index, column_index).\",\n    \"4. Collect all tuples in a list.\",\n    \"5. Sort the list of tuples by row index in ascending order.\",\n    \"6. For tuples with the same row index, sort them by column index in descending order.\"\n  ],\n  \"high_level_plan\": [\n    \"Step 1: Define the function get_row(lst, x) with parameters lst (list of lists) and x (integer).\",\n    \"Step 2: Validate the input to ensure lst is a list of lists and x is an integer.\",\n    \"Step 3: Initialize an empty list to store the coordinates of x.\",\n    \"Step 4: Loop through each row in lst using an index to track the row number.\",\n    \"Step 5: Within each row, loop through each element using an index to track the column number.\",\n    \"Step 6: If an element equals x, append the tuple (row_index, column_index) to the coordinates list.\",\n    \"Step 7: Sort the coordinates list by row index in ascending order.\",\n    \"Step 8: For each group of tuples with the same row index, sort them by column index in descending order.\",\n    \"Step 9: Return the sorted list of coordinates.\"\n  ]\n}\n```", "Round_0": {"code": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists, which resembles a matrix, however, unlike matrices, each row can have a different count of columns. Provided lst, and integer x, identify integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\n    Examples:\n        get_row([\n          [1,2,3,4,5,6],\n          [1,2,3,4,1,6],\n          [1,2,3,4,5,1]\n        ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n        get_row([], 1) == []\n        get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    # Validate the input\n    if not isinstance(lst, list) or not all(isinstance(row, list) for row in lst) or not isinstance(x, int):\n        raise ValueError(\"Invalid input: lst must be a list of lists and x must be an integer.\")\n\n    # Initialize an empty list to store the coordinates of x\n    coordinates = []\n\n    # Loop through each row in lst using an index to track the row number\n    for row_index, row in enumerate(lst):\n        # Within each row, loop through each element using an index to track the column number\n        for col_index, element in enumerate(row):\n            # If an element equals x, append the tuple (row_index, column_index) to the coordinates list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates list by row index in ascending order\n    # For each group of tuples with the same row index, sort them by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Iterate through each row of the nested list to find occurrences of the integer x.\",\n      \"details\": \"For each row, check each element to see if it matches the integer x.\"\n    },\n    {\n      \"description\": \"Record the coordinates of each occurrence of x.\",\n      \"details\": \"For each match found, store the coordinates as a tuple (row_index, column_index).\"\n    },\n    {\n      \"description\": \"Sort the list of coordinates by row index in ascending order.\",\n      \"details\": \"Ensure that the list of tuples is ordered by the first element of each tuple (row index).\"\n    },\n    {\n      \"description\": \"Sort the coordinates within each row by column index in descending order.\",\n      \"details\": \"For tuples with the same row index, sort them by the second element (column index) in descending order.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize an empty list to store the coordinates of occurrences of x.\",\n    \"Loop through each row of the nested list using an index to track the row number.\",\n    \"Within each row, loop through each element using an index to track the column number.\",\n    \"If an element matches x, append the tuple (row_index, column_index) to the coordinates list.\",\n    \"Sort the coordinates list by row index in ascending order.\",\n    \"For each group of coordinates with the same row index, sort them by column index in descending order.\",\n    \"Return the sorted list of coordinates.\"\n  ]\n}\n```", "Round_0": {"code": "def get_row(lst, x):\n    # Initialize an empty list to store the coordinates of occurrences of x\n    coordinates = []\n\n    # Loop through each row of the nested list using an index to track the row number\n    for row_index, row in enumerate(lst):\n        # Within each row, loop through each element using an index to track the column number\n        for col_index, element in enumerate(row):\n            # If an element matches x, append the tuple (row_index, column_index) to the coordinates list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates list by row index in ascending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    \"1. Validate the input to ensure 'lst' is a list of lists and 'x' is an integer.\",\n    \"2. Iterate through each row of the list to find occurrences of the integer 'x'.\",\n    \"3. For each occurrence of 'x', record its coordinates as a tuple (row_index, column_index).\",\n    \"4. Sort the list of tuples first by row index in ascending order.\",\n    \"5. Within each row, sort the tuples by column index in descending order.\"\n  ],\n  \"high_level_plan\": [\n    \"Step 1: Input Validation - Check if 'lst' is a list of lists and 'x' is an integer. If not, handle the error appropriately.\",\n    \"Step 2: Initialize an empty list to store the coordinates of 'x'.\",\n    \"Step 3: Loop through each row in 'lst' using an index to track the row number.\",\n    \"Step 4: Within each row, loop through each element using an index to track the column number.\",\n    \"Step 5: If an element equals 'x', append the tuple (row_index, column_index) to the coordinates list.\",\n    \"Step 6: Sort the list of coordinates by row index in ascending order.\",\n    \"Step 7: For each row, sort the coordinates by column index in descending order.\",\n    \"Step 8: Return the sorted list of coordinates.\"\n  ]\n}\n```", "Round_0": {"code": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists, which resembles a matrix, however, unlike matrices, each row can have a different count of columns. Provided lst, and integer x, identify integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\n    Examples:\n        get_row([\n          [1,2,3,4,5,6],\n          [1,2,3,4,1,6],\n          [1,2,3,4,5,1]\n        ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n        get_row([], 1) == []\n        get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    \n    # Step 1: Input Validation\n    if not isinstance(lst, list) or not all(isinstance(row, list) for row in lst) or not isinstance(x, int):\n        raise ValueError(\"Invalid input: 'lst' must be a list of lists and 'x' must be an integer.\")\n    \n    # Step 2: Initialize an empty list to store the coordinates of 'x'\n    coordinates = []\n    \n    # Step 3: Loop through each row in 'lst' using an index to track the row number\n    for row_index, row in enumerate(lst):\n        # Step 4: Within each row, loop through each element using an index to track the column number\n        for column_index, element in enumerate(row):\n            # Step 5: If an element equals 'x', append the tuple (row_index, column_index) to the coordinates list\n            if element == x:\n                coordinates.append((row_index, column_index))\n    \n    # Step 6: Sort the list of coordinates by row index in ascending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    # Step 8: Return the sorted list of coordinates\n    return coordinates\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Iterate through each row of the nested list to find occurrences of the integer x.\",\n      \"details\": \"For each row, check each element to see if it matches the integer x.\"\n    },\n    {\n      \"description\": \"Record the coordinates of each occurrence of x.\",\n      \"details\": \"Store the coordinates as tuples (row_index, column_index) in a list.\"\n    },\n    {\n      \"description\": \"Sort the list of coordinates by row index in ascending order.\",\n      \"details\": \"Use a sorting function to order the tuples primarily by the first element (row index).\"\n    },\n    {\n      \"description\": \"Sort the coordinates within each row by column index in descending order.\",\n      \"details\": \"For each group of tuples with the same row index, sort them by the second element (column index) in descending order.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize an empty list to store the coordinates of occurrences of x.\",\n    \"Loop through each row of the nested list with an index to track the row number.\",\n    \"Within each row, loop through each element with an index to track the column number.\",\n    \"If an element matches x, append the tuple (row_index, column_index) to the list of coordinates.\",\n    \"Sort the list of coordinates by row index in ascending order.\",\n    \"For each group of coordinates with the same row index, sort them by column index in descending order.\",\n    \"Return the sorted list of coordinates.\"\n  ]\n}\n```", "Round_0": {"code": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists, which resembles a matrix, however, unlike matrices, each row can have a different count of columns. Provided lst, and integer x, identify integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\n    Examples:\n        get_row([\n          [1,2,3,4,5,6],\n          [1,2,3,4,1,6],\n          [1,2,3,4,5,1]\n        ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n        get_row([], 1) == []\n        get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n\n    # Iterate through each row with its index\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row with its index\n        for col_index, value in enumerate(row):\n            # If the element matches x, record the coordinate\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort coordinates by row index in ascending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    \"1. Parse the input to ensure it is a list of lists and an integer.\",\n    \"2. Iterate through each row of the list to find occurrences of the integer x.\",\n    \"3. For each occurrence of x, record the coordinates (row, column) as a tuple.\",\n    \"4. Sort the list of tuples first by row in ascending order.\",\n    \"5. Within each row, sort the tuples by column in descending order.\"\n  ],\n  \"high_level_plan\": [\n    \"1. Validate the input to ensure it matches the expected format: a list of lists and an integer.\",\n    \"2. Initialize an empty list to store the coordinates of occurrences of x.\",\n    \"3. Loop through each row of the list using an index to track the row number.\",\n    \"4. Within each row, loop through each element using an index to track the column number.\",\n    \"5. If an element matches x, append the tuple (row_index, column_index) to the coordinates list.\",\n    \"6. Sort the coordinates list by row index in ascending order.\",\n    \"7. For each row, sort the coordinates by column index in descending order.\",\n    \"8. Return the sorted list of coordinates.\"\n  ]\n}\n```", "Round_0": {"code": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists, which resembles a matrix, however, unlike matrices, each row can have a different count of columns. Provided lst, and integer x, identify integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\n    Examples:\n        get_row([\n          [1,2,3,4,5,6],\n          [1,2,3,4,1,6],\n          [1,2,3,4,5,1]\n        ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n        get_row([], 1) == []\n        get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    # Initialize an empty list to store the coordinates of occurrences of x\n    coordinates = []\n\n    # Loop through each row of the list using an index to track the row number\n    for row_index, row in enumerate(lst):\n        # Within each row, loop through each element using an index to track the column number\n        for col_index, value in enumerate(row):\n            # If an element matches x, append the tuple (row_index, column_index) to the coordinates list\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates list by row index in ascending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"analysis\": {\n    \"description\": \"The function get_row(lst, x) takes a nested list and an integer x, and returns a list of tuples representing the coordinates of occurrences of x in the list. The coordinates are sorted by rows in ascending order and by columns in descending order within each row.\",\n    \"subproblems\": [\n      \"Identify occurrences of integer x in each row of the nested list.\",\n      \"Record the coordinates (row, column) of each occurrence.\",\n      \"Sort the list of coordinates by row in ascending order.\",\n      \"Sort the coordinates within each row by column in descending order.\"\n    ]\n  },\n  \"high_level_plan\": {\n    \"steps\": [\n      \"Initialize an empty list to store the coordinates.\",\n      \"Iterate over each row in the nested list using an index to track the row number.\",\n      \"For each row, iterate over the elements using an index to track the column number.\",\n      \"If an element matches the integer x, append the tuple (row_index, column_index) to the coordinates list.\",\n      \"Sort the coordinates list by row index in ascending order.\",\n      \"For each row in the sorted list, sort the coordinates by column index in descending order.\",\n      \"Return the sorted list of coordinates.\"\n    ]\n  }\n}\n```", "Round_0": {"code": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists, which resembles a matrix, however, unlike matrices, each row can have a different count of columns. Provided lst, and integer x, identify integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\n    Examples:\n        get_row([\n          [1,2,3,4,5,6],\n          [1,2,3,4,1,6],\n          [1,2,3,4,5,1]\n        ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n        get_row([], 1) == []\n        get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n\n    # Iterate over each row in the nested list\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row\n        for col_index, value in enumerate(row):\n            # If the element matches x, record the coordinate\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates by row index in ascending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Iterate through each row of the nested list to find occurrences of the integer x.\",\n      \"details\": \"For each row, check each element to see if it matches the integer x.\"\n    },\n    {\n      \"description\": \"Record the coordinates of each occurrence of x.\",\n      \"details\": \"For each match found, store the coordinates as a tuple (row_index, column_index).\"\n    },\n    {\n      \"description\": \"Sort the list of coordinates by row index in ascending order.\",\n      \"details\": \"Ensure that the list of tuples is ordered by the first element of each tuple (row index).\"\n    },\n    {\n      \"description\": \"Sort the coordinates within each row by column index in descending order.\",\n      \"details\": \"For tuples with the same row index, sort them by the second element (column index) in descending order.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize an empty list to store the coordinates of occurrences of x.\",\n    \"Loop through each row of the nested list using an index to track the row number.\",\n    \"Within each row, loop through each element using an index to track the column number.\",\n    \"If an element matches x, append the tuple (row_index, column_index) to the coordinates list.\",\n    \"Sort the coordinates list by row index in ascending order.\",\n    \"For each group of coordinates with the same row index, sort them by column index in descending order.\",\n    \"Return the sorted list of coordinates.\"\n  ]\n}\n```", "Round_0": {"code": "def get_row(lst, x):\n    # Initialize an empty list to store the coordinates of occurrences of x\n    coordinates = []\n\n    # Loop through each row of the nested list using an index to track the row number\n    for row_index, row in enumerate(lst):\n        # Within each row, loop through each element using an index to track the column number\n        for column_index, element in enumerate(row):\n            # If an element matches x, append the tuple (row_index, column_index) to the coordinates list\n            if element == x:\n                coordinates.append((row_index, column_index))\n\n    # Sort the coordinates list by row index in ascending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposition\": [\n    \"Parse the input to ensure it is a list of lists and an integer.\",\n    \"Iterate through each row of the list to find occurrences of the integer x.\",\n    \"For each occurrence of x, record the coordinates (row, column) as a tuple.\",\n    \"Sort the list of tuples by row index in ascending order.\",\n    \"Within each row, sort the tuples by column index in descending order.\"\n  ],\n  \"high_level_plan\": [\n    \"Step 1: Validate the input to ensure it is a nested list and an integer.\",\n    \"Step 2: Initialize an empty list to store the coordinates of occurrences of x.\",\n    \"Step 3: Loop through each row of the nested list using an index to track the row number.\",\n    \"Step 4: Within each row, loop through each element using an index to track the column number.\",\n    \"Step 5: If an element matches x, append the tuple (row_index, column_index) to the coordinates list.\",\n    \"Step 6: Sort the list of coordinates by row index in ascending order.\",\n    \"Step 7: For each row, sort the coordinates by column index in descending order.\",\n    \"Step 8: Return the sorted list of coordinates.\"\n  ]\n}\n```", "Round_0": {"code": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists, which resembles a matrix, however, unlike matrices, each row can have a different count of columns. Provided lst, and integer x, identify integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\n    Examples:\n        get_row([\n          [1,2,3,4,5,6],\n          [1,2,3,4,1,6],\n          [1,2,3,4,5,1]\n        ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n        get_row([], 1) == []\n        get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    # Step 1: Validate the input to ensure it is a nested list and an integer.\n    if not isinstance(lst, list) or not isinstance(x, int):\n        raise ValueError(\"Invalid input: lst must be a list of lists and x must be an integer.\")\n\n    # Step 2: Initialize an empty list to store the coordinates of occurrences of x.\n    coordinates = []\n\n    # Step 3: Loop through each row of the nested list using an index to track the row number.\n    for row_index, row in enumerate(lst):\n        if not isinstance(row, list):\n            raise ValueError(\"Invalid input: each element of lst must be a list.\")\n\n        # Step 4: Within each row, loop through each element using an index to track the column number.\n        for col_index, value in enumerate(row):\n            # Step 5: If an element matches x, append the tuple (row_index, column_index) to the coordinates list.\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Step 6: Sort the list of coordinates by row index in ascending order.\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Step 8: Return the sorted list of coordinates.\n    return coordinates", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Iterate through each row of the nested list to identify the presence of the integer x.\",\n      \"goal\": \"Identify all occurrences of the integer x in the nested list.\"\n    },\n    {\n      \"description\": \"For each occurrence of x, record the coordinates (row, column) of x.\",\n      \"goal\": \"Store the coordinates of each occurrence of x in a list of tuples.\"\n    },\n    {\n      \"description\": \"Sort the list of tuples by row index in ascending order.\",\n      \"goal\": \"Ensure that the coordinates are ordered by rows first.\"\n    },\n    {\n      \"description\": \"Within each row, sort the coordinates by column index in descending order.\",\n      \"goal\": \"Ensure that within each row, the coordinates are ordered by columns in descending order.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize an empty list to store the coordinates of occurrences of x.\",\n    \"Loop through each row of the nested list using an index to keep track of the row number.\",\n    \"Within each row, loop through each element using an index to keep track of the column number.\",\n    \"If the element matches x, append the tuple (row_index, column_index) to the list of coordinates.\",\n    \"After collecting all coordinates, sort the list of tuples by the first element (row index) in ascending order.\",\n    \"For tuples with the same row index, sort them by the second element (column index) in descending order.\",\n    \"Return the sorted list of coordinates.\"\n  ]\n}\n```", "Round_0": {"code": "def get_row(lst, x):\n    # Initialize an empty list to store the coordinates of occurrences of x\n    coordinates = []\n\n    # Loop through each row of the nested list using an index to keep track of the row number\n    for row_index, row in enumerate(lst):\n        # Within each row, loop through each element using an index to keep track of the column number\n        for col_index, element in enumerate(row):\n            # If the element matches x, append the tuple (row_index, column_index) to the list of coordinates\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of tuples by the first element (row index) in ascending order\n    # For tuples with the same row index, sort them by the second element (column index) in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Identify all occurrences of the integer x in the nested list.\",\n      \"description\": \"Traverse each row of the nested list and check each element to see if it matches the integer x. Record the coordinates (row, column) of each match.\"\n    },\n    {\n      \"subproblem\": \"Sort the coordinates by row in ascending order.\",\n      \"description\": \"Once all coordinates are identified, sort them primarily by the row index in ascending order.\"\n    },\n    {\n      \"subproblem\": \"Sort the coordinates within each row by column in descending order.\",\n      \"description\": \"For coordinates that share the same row index, sort them by the column index in descending order.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Initialize an empty list to store the coordinates of occurrences of x.\"\n    },\n    {\n      \"step\": \"Iterate over each row in the nested list using an index to track the row number.\"\n    },\n    {\n      \"step\": \"Within each row, iterate over each element using an index to track the column number.\"\n    },\n    {\n      \"step\": \"If an element matches x, append the tuple (row_index, column_index) to the list of coordinates.\"\n    },\n    {\n      \"step\": \"Sort the list of coordinates by row index in ascending order.\"\n    },\n    {\n      \"step\": \"For coordinates with the same row index, sort them by column index in descending order.\"\n    },\n    {\n      \"step\": \"Return the sorted list of coordinates.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "def get_row(lst, x):\n    # Initialize an empty list to store the coordinates of occurrences of x\n    coordinates = []\n\n    # Iterate over each row in the nested list using an index to track the row number\n    for row_index, row in enumerate(lst):\n        # Within each row, iterate over each element using an index to track the column number\n        for col_index, element in enumerate(row):\n            # If an element matches x, append the tuple (row_index, column_index) to the list of coordinates\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates by row index in ascending order\n    # For coordinates with the same row index, sort them by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    \"1. Validate the input to ensure it is a list of lists and an integer.\",\n    \"2. Iterate through each row of the list to find occurrences of the integer x.\",\n    \"3. For each occurrence of x, record its coordinates as a tuple (row_index, column_index).\",\n    \"4. Collect all tuples in a list.\",\n    \"5. Sort the list of tuples by row index in ascending order.\",\n    \"6. For tuples with the same row index, sort them by column index in descending order.\"\n  ],\n  \"high_level_plan\": [\n    \"Step 1: Define the function get_row(lst, x) with parameters lst (list of lists) and x (integer).\",\n    \"Step 2: Validate the input to ensure lst is a list of lists and x is an integer.\",\n    \"Step 3: Initialize an empty list to store the coordinates of x.\",\n    \"Step 4: Loop through each row in lst using an index to track the row number.\",\n    \"Step 5: Within each row, loop through each element using an index to track the column number.\",\n    \"Step 6: If an element equals x, append the tuple (row_index, column_index) to the coordinates list.\",\n    \"Step 7: Sort the coordinates list by row index in ascending order.\",\n    \"Step 8: For each group of tuples with the same row index, sort them by column index in descending order.\",\n    \"Step 9: Return the sorted list of coordinates.\"\n  ]\n}\n```", "Round_0": {"code": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists, which resembles a matrix, however, unlike matrices, each row can have a different count of columns. Provided lst, and integer x, identify integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\n    Examples:\n        get_row([\n          [1,2,3,4,5,6],\n          [1,2,3,4,1,6],\n          [1,2,3,4,5,1]\n        ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n        get_row([], 1) == []\n        get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    # Validate the input\n    if not isinstance(lst, list) or not all(isinstance(row, list) for row in lst) or not isinstance(x, int):\n        raise ValueError(\"Invalid input: lst must be a list of lists and x must be an integer.\")\n\n    # Initialize an empty list to store the coordinates of x\n    coordinates = []\n\n    # Loop through each row in lst using an index to track the row number\n    for row_index, row in enumerate(lst):\n        # Within each row, loop through each element using an index to track the column number\n        for col_index, element in enumerate(row):\n            # If an element equals x, append the tuple (row_index, column_index) to the coordinates list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates list by row index in ascending order\n    # For each group of tuples with the same row index, sort them by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [87, 87, 87, 87, 87, 87, 87, 87, 87, 87], "passed": true, "pass": true, "pass_num": 10, "round": 76, "mutate_method": "rephrase_one", "save_node": false, "parent_index": 76}
