{"name": "1579_F. Array Stabilization (AND version)", "description": "You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\n\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "tags": ["brute force", "graphs", "math", "number theory", "shortest paths"], "difficulty": 12, "id": 1579, "sample_io": [{"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}], "test_list": [{"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n1\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n2\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["1\n0\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n2\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 4\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n-1\n-1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 0 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n2\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n2\n2\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n0\n", "output": ["0\n1\n1\n2\n0\n"]}, {"input": "5\n2 1\n1 0\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["0\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 0 0 0\n1 1\n1\n", "output": ["1\n-1\n1\n0\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n2\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["0\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 2\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n4\n0\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 0 0 0\n1 1\n1\n", "output": ["-1\n-1\n1\n0\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n2\n3\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["-1\n1\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 0 0\n5 3\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n0\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 4\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n-1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n-1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 5\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n-1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["0\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 4\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n-1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n0 0 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n0\n2\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 3\n1 0 0 0 0\n4 4\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n1\n-1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 5\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n-1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 1\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["1\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n1\n3\n0\n"]}, {"input": "5\n2 2\n1 0\n3 3\n0 1 0\n5 5\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["-1\n-1\n-1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n1\n", "output": ["1\n0\n2\n3\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n0\n", "output": ["1\n0\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n0\n", "output": ["0\n0\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n2\n1\n1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 1 0 1\n1 1\n1\n", "output": ["-1\n1\n1\n3\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 1\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 0\n5 2\n1 0 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n0\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 1 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n3\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 1 1\n5 4\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 1\n1 1 0 0 0\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n2\n2\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n1 1 0\n5 4\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n2\n2\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n0\n", "output": ["0\n1\n2\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n1\n", "output": ["1\n1\n2\n3\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["-1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n1 1 0 0\n1 1\n0\n", "output": ["0\n-1\n2\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 0 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n1\n1\n-1\n"]}, {"input": "5\n2 2\n1 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 1\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 0 0\n5 1\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 1\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n3\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 3\n0 1 0\n5 4\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n3\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 5\n0 0 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n0\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n-1\n-1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 2\n1 1 1\n5 4\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 1\n1 0 1 0 0\n4 2\n0 1 0 1\n1 1\n1\n", "output": ["0\n1\n1\n-1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 1\n5 3\n0 0 1 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["0\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 0 0\n5 3\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["0\n0\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["0\n2\n2\n2\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n-1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n2\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["0\n2\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n0\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 0 0 1\n1 1\n1\n", "output": ["-1\n1\n3\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n4\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n3\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 0 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n0\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n1 1 1 0\n1 1\n0\n", "output": ["-1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 4\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 1\n0 0 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 1\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 0 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n1 1 1 0\n1 1\n0\n", "output": ["1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 1 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 0 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n2\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 0 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 0 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 0 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}], "task_id": "codecontest/18", "repair_prompt": ["You have an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] consisting solely of ones and zeroes. Note that in this problem, unlike the others, the array indexes are numbered from zero. They are not numbered from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. Initially, a new array a^{\u2192 d} is constructed as a cyclic shift of the array a to the right by d positions. The elements of this shifted array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, shifted_a):\n        return [x & y for x, y in zip(a, shifted_a)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            shifted_a = cyclic_shift(a, d)\n            a = logical_and(a, shifted_a)\n            steps += 1\n\n            if a == test_cases[i][2]:  # Array remains the same after a step\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "completions": ["def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, shifted_a):\n        return [ai & sai for ai, sai in zip(a, shifted_a)]\n\n    def check_zeros(a):\n        return all(val == 0 for val in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            shifted_a = cyclic_shift(a, d)\n            a = logical_and(a, shifted_a)\n            steps += 1\n\n            if a == test_cases[i][2]:  # Array remains the same after a step\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        a = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == cyclic_shift(a, d):\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        a = test_cases[i][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == test_cases[i][1]:  # Array did not change\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, shifted_a):\n        return [ai & shifted_ai for ai, shifted_ai in zip(a, shifted_a)]\n\n    def check_zeros(a):\n        return all(val == 0 for val in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        a = test_cases[i][1]\n\n        steps = 0\n        while not check_zeros(a):\n            shifted_a = cyclic_shift(a, d)\n            a = logical_and(a, shifted_a)\n            steps += 1\n\n            if a == test_cases[i][1]:  # Array remains the same after a full cycle\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, shifted_a):\n        return [ai & shifted_ai for ai, shifted_ai in zip(a, shifted_a)]\n\n    def check_zeros(a):\n        return all(ai == 0 for ai in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            shifted_a = cyclic_shift(a, d)\n            a = logical_and(a, shifted_a)\n            steps += 1\n\n            if a == test_cases[i][2]:  # Array remains the same after one full cycle\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        a = test_cases[i][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == cyclic_shift(a, d):\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, shifted_a):\n        return [ai & shifted_ai for ai, shifted_ai in zip(a, shifted_a)]\n\n    def check_zeros(a):\n        return all(val == 0 for val in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            shifted_a = cyclic_shift(a, d)\n            a = logical_and(a, shifted_a)\n            steps += 1\n\n            if a == test_cases[i][2]:  # Array remains the same after one full cycle\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        a = test_cases[i][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == cyclic_shift(a, d):\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(elem == 0 for elem in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n        steps = 0\n\n        while not check_zeros(arr):\n            shifted_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, shifted_arr)\n            steps += 1\n\n            if arr == shifted_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, shifted_a):\n        return [x & y for x, y in zip(a, shifted_a)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            shifted_a = cyclic_shift(a, d)\n            a = logical_and(a, shifted_a)\n            steps += 1\n\n            if a == test_cases[i][2]:  # Array remains the same after a step\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()"], "session_history": {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Implement the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case, read the array size, cyclic shift offset, and elements of the array\",\n      \"Perform the cyclic shift operation on the array\",\n      \"Perform the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros\",\n      \"Repeat the above steps until the array contains only zeros or determine it will never contain only zeros\",\n      \"Output the number of steps taken or -1 if the array will never contain only zeros\"\n    ]\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, shifted_a):\n        return [x & y for x, y in zip(a, shifted_a)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            shifted_a = cyclic_shift(a, d)\n            a = logical_and(a, shifted_a)\n            steps += 1\n\n            if a == test_cases[i][2]:  # Array remains the same after a step\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 48)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, shifted_a):\n        return [x & y for x, y in zip(a, shifted_a)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            shifted_a = cyclic_shift(a, d)\n            a = logical_and(a, shifted_a)\n            steps += 1\n\n            if a == test_cases[i][2]:  # Array remains the same after a step\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, "session_historys": [{"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Implement the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case, read the array size, cyclic shift offset, and elements of the array\",\n      \"Perform the cyclic shift operation on the array\",\n      \"Perform the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros\",\n      \"Repeat the above steps until the array contains only zeros or determine it will never contain only zeros\",\n      \"Output the number of steps taken or -1 if the array will never contain only zeros\"\n    ]\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, shifted_a):\n        return [ai & sai for ai, sai in zip(a, shifted_a)]\n\n    def check_zeros(a):\n        return all(val == 0 for val in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            shifted_a = cyclic_shift(a, d)\n            a = logical_and(a, shifted_a)\n            steps += 1\n\n            if a == test_cases[i][2]:  # Array remains the same after a step\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 49)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, shifted_a):\n        return [ai & sai for ai, sai in zip(a, shifted_a)]\n\n    def check_zeros(a):\n        return all(val == 0 for val in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            shifted_a = cyclic_shift(a, d)\n            a = logical_and(a, shifted_a)\n            steps += 1\n\n            if a == test_cases[i][2]:  # Array remains the same after a step\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Perform the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken to reach an array with only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case, read the array size and cyclic shift offset\",\n      \"Read the elements of the array\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Perform the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken to reach an array with only zeros\",\n      \"Output the number of steps or -1 if the array never contains only zeros\"\n    ]\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        a = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == cyclic_shift(a, d):\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        a = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == cyclic_shift(a, d):\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Implement the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case, read the array size, cyclic shift offset, and elements of the array\",\n      \"Perform the cyclic shift operation on the array\",\n      \"Perform the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros\",\n      \"Repeat the above steps until the array contains only zeros or determine it will never contain only zeros\",\n      \"Output the number of steps taken or -1 if the array will never contain only zeros\"\n    ]\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        a = test_cases[i][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == test_cases[i][1]:  # Array did not change\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 49)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        a = test_cases[i][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == test_cases[i][1]:  # Array did not change\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Implement the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case, read the array size, cyclic shift offset, and elements of the array\",\n      \"Perform the cyclic shift operation on the array\",\n      \"Perform the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros\",\n      \"Repeat the above steps until the array contains only zeros or determine it will never contain only zeros\",\n      \"Output the number of steps taken or -1 if the array will never contain only zeros\"\n    ]\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, shifted_a):\n        return [ai & shifted_ai for ai, shifted_ai in zip(a, shifted_a)]\n\n    def check_zeros(a):\n        return all(val == 0 for val in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        a = test_cases[i][1]\n\n        steps = 0\n        while not check_zeros(a):\n            shifted_a = cyclic_shift(a, d)\n            a = logical_and(a, shifted_a)\n            steps += 1\n\n            if a == test_cases[i][1]:  # Array remains the same after a full cycle\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 49)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, shifted_a):\n        return [ai & shifted_ai for ai, shifted_ai in zip(a, shifted_a)]\n\n    def check_zeros(a):\n        return all(val == 0 for val in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        a = test_cases[i][1]\n\n        steps = 0\n        while not check_zeros(a):\n            shifted_a = cyclic_shift(a, d)\n            a = logical_and(a, shifted_a)\n            steps += 1\n\n            if a == test_cases[i][1]:  # Array remains the same after a full cycle\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Implement the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case, read the array size, cyclic shift offset, and elements of the array\",\n      \"Perform the cyclic shift operation on the array\",\n      \"Perform the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros\",\n      \"Repeat the above steps until the array contains only zeros or determine it will never contain only zeros\",\n      \"Output the number of steps taken or -1 if the array will never contain only zeros\"\n    ]\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, shifted_a):\n        return [ai & shifted_ai for ai, shifted_ai in zip(a, shifted_a)]\n\n    def check_zeros(a):\n        return all(ai == 0 for ai in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            shifted_a = cyclic_shift(a, d)\n            a = logical_and(a, shifted_a)\n            steps += 1\n\n            if a == test_cases[i][2]:  # Array remains the same after one full cycle\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, shifted_a):\n        return [ai & shifted_ai for ai, shifted_ai in zip(a, shifted_a)]\n\n    def check_zeros(a):\n        return all(ai == 0 for ai in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            shifted_a = cyclic_shift(a, d)\n            a = logical_and(a, shifted_a)\n            steps += 1\n\n            if a == test_cases[i][2]:  # Array remains the same after one full cycle\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Implement the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case, read the array size, cyclic shift offset, and elements of the array\",\n      \"Perform the cyclic shift operation on the array\",\n      \"Perform the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros\",\n      \"Repeat the above steps until the array contains only zeros or determine it will never contain only zeros\",\n      \"Output the number of steps taken or -1 if the array will never contain only zeros\"\n    ]\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        a = test_cases[i][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == cyclic_shift(a, d):\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        a = test_cases[i][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == cyclic_shift(a, d):\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Implement the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case, read the array size, cyclic shift offset, and elements of the array\",\n      \"Perform the cyclic shift operation on the array\",\n      \"Perform the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros\",\n      \"Repeat the above steps until the array contains only zeros or determine it will never contain only zeros\",\n      \"Output the number of steps taken or -1 if the array will never contain only zeros\"\n    ]\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, shifted_a):\n        return [ai & shifted_ai for ai, shifted_ai in zip(a, shifted_a)]\n\n    def check_zeros(a):\n        return all(val == 0 for val in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            shifted_a = cyclic_shift(a, d)\n            a = logical_and(a, shifted_a)\n            steps += 1\n\n            if a == test_cases[i][2]:  # Array remains the same after one full cycle\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, shifted_a):\n        return [ai & shifted_ai for ai, shifted_ai in zip(a, shifted_a)]\n\n    def check_zeros(a):\n        return all(val == 0 for val in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            shifted_a = cyclic_shift(a, d)\n            a = logical_and(a, shifted_a)\n            steps += 1\n\n            if a == test_cases[i][2]:  # Array remains the same after one full cycle\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Implement the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case, read the array size, cyclic shift offset, and elements of the array\",\n      \"Perform the cyclic shift operation on the array\",\n      \"Perform the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros\",\n      \"Repeat the above steps until the array contains only zeros or determine it will never contain only zeros\",\n      \"Output the number of steps taken or -1 if the array will never contain only zeros\"\n    ]\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        a = test_cases[i][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == cyclic_shift(a, d):\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        a = test_cases[i][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == cyclic_shift(a, d):\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Perform the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken to reach an array with only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case, read the array size, cyclic shift offset, and array elements\",\n      \"Initialize a counter to keep track of the number of steps taken\",\n      \"Repeat the following steps until the array contains only zeros or the process does not change the array anymore:\",\n      \"Perform the cyclic shift operation on the array\",\n      \"Perform the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros\",\n      \"Increment the step counter\",\n      \"Print the number of steps taken or -1 if the array still contains ones\"\n    ]\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(elem == 0 for elem in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n        steps = 0\n\n        while not check_zeros(arr):\n            shifted_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, shifted_arr)\n            steps += 1\n\n            if arr == shifted_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(elem == 0 for elem in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n        steps = 0\n\n        while not check_zeros(arr):\n            shifted_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, shifted_arr)\n            steps += 1\n\n            if arr == shifted_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Implement the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case, read the array size, cyclic shift offset, and elements of the array\",\n      \"Perform the cyclic shift operation on the array\",\n      \"Perform the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros\",\n      \"Repeat the above steps until the array contains only zeros or determine it will never contain only zeros\",\n      \"Output the number of steps taken or -1 if the array will never contain only zeros\"\n    ]\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, shifted_a):\n        return [x & y for x, y in zip(a, shifted_a)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            shifted_a = cyclic_shift(a, d)\n            a = logical_and(a, shifted_a)\n            steps += 1\n\n            if a == test_cases[i][2]:  # Array remains the same after a step\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 48)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, shifted_a):\n        return [x & y for x, y in zip(a, shifted_a)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            shifted_a = cyclic_shift(a, d)\n            a = logical_and(a, shifted_a)\n            steps += 1\n\n            if a == test_cases[i][2]:  # Array remains the same after a step\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}], "scores": [], "pass_results": [true, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 98, "prompt": "You have an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] consisting solely of ones and zeroes. Note that in this problem, unlike the others, the array indexes are numbered from zero. They are not numbered from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. Initially, a new array a^{\u2192 d} is constructed as a cyclic shift of the array a to the right by d positions. The elements of this shifted array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 34}
