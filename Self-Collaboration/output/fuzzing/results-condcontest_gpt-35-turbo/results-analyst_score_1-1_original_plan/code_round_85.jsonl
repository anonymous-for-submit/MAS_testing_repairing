{"name": "1607_E. Robot on the Board 1", "description": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nThe sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).\n\nDetermine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "tags": ["implementation"], "difficulty": 11, "id": 1607, "sample_io": [{"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}], "test_list": [{"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n5 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n1 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 1\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 4\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n1 1\n3 4\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n2 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 1\n2 1\n4 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRUDLLLDU\n", "output": ["1 2\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n2 2\nLUUDRLDLRLUU\n", "output": ["1 1\n1 2\n2 1\n2 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 1\nUULDRR\n4 2\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 1\n1 1\n4 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 1\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nLRDRUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 2\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n17 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 1\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 1\n3 1\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n4 4\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n5 2\nL\n3 3\nRRDLUU\n6 3\nLUUURRDLLLDU\n", "output": ["1 1\n1 2\n2 1\n4 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n4 4\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 4\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 1\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n4 3\nRRDLUU\n3 4\nDUULRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n2 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 2\nUULRRD\n6 2\nUULULDRRDULL\n", "output": ["1 1\n1 2\n3 2\n4 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n13 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n9 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n22 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n8 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n6 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n1 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRDRLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n5 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n4 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUT\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n6 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRDRLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n4 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n6 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDURDURL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n10 3\nRRDLUU\n6 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 2\nLUUDRLDLRLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n7 3\nRRDLUU\n8 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n8 3\nLUUDRRDLLLUT\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n5 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n3 3\nRRDUUL\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n6 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n3 3\nUULDRR\n11 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n7 3\nRRDLUU\n8 2\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n3 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nDRRLUU\n6 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n12 3\nRRDLUU\n8 2\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n2 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n5 2\nL\n3 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n10 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n4 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nLUULRRDLDLUU\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n2 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n5 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n2 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n10 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n6 3\nRRDLUU\n9 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRRDLUU\n8 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n2 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nUULDRR\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n4 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRDRLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nLUULRRDDLLUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nUULDRR\n4 2\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n6 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 4\nLUUDRRLLLDUU\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDURDURL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n1 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n2 2\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n5 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n8 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nDRRLUU\n6 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n5 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n12 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nUULDRR\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDTUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n5 3\nUUULLDRRDULL\n", "output": ["1 1\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 1\nL\n10 2\nL\n2 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 2\nUULDRR\n10 3\nLUULRRDDLLUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n23 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDTUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n13 2\nL\n2 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n6 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n9 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n15 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLRUURDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n4 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDUUL\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n4 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n11 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUV\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n5 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n12 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nUULRDR\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}], "task_id": "codecontest/102", "repair_prompt": ["The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns), with rows numbered from 1 to n from top to bottom and columns numbered from 1 to m from left to right. The robot is able to move from the current cell to one of the four cells adjacent by side, executing the sequence of commands s given, with each command denoted by 'L', 'R', 'D' or 'U' for moving left, right, down or up, respectively. The robot can start its movement in any cell, executing the commands from the first one in s strictly in order, but falls and breaks if it moves beyond the board's edge, rendering a command causing it to break unsuccessfully executed. The robot's task is to execute as many commands as possible without falling off the board; for example, on board 3 \u00d7 3, if starting a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, it performs one command before the next forces it over the edge. If starting from cell (2, 1), all commands succeed, stopping the robot in cell (1, 2). The robot starts from cell (2, 1), moves right, right, down, left, up, and up, ending in cell (1, 2). Determine the cell from which the robot should start its movement to execute the most commands; the goal is finding a starting cell that maximizes successful moves, considering edge cases like a very small board or commands moving in a single direction. Pay special attention to scenarios where the sequence of commands may form a loop. Ensure to consider the performance implications for large values of n and m. Consider optimizing your solution to handle cases efficiently where the length of the command sequence s is significantly large compared to the board dimensions.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def find_starting_cell(t, test_cases):\n    def execute_commands(n, m, commands):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n        \n        def is_valid_move(x, y):\n            return 0 <= x < n and 0 <= y < m\n        \n        def count_successful_moves(start_x, start_y):\n            visited = set()\n            x, y = start_x, start_y\n            count = 0\n            \n            while is_valid_move(x, y) and (x, y) not in visited:\n                visited.add((x, y))\n                count += 1\n                dx, dy = directions[commands[count % len(commands)]]\n                x, y = x + dx, y + dy\n                \n            return count\n        \n        max_successful_moves = 0\n        best_starting_cell = (1, 1)\n        \n        for i in range(n):\n            for j in range(m):\n                successful_moves = count_successful_moves(i, j)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    best_starting_cell = (i+1, j+1)\n        \n        return best_starting_cell\n    \n    results = []\n    \n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        result = execute_commands(n, m, commands)\n        results.append(result)\n    \n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nresults = find_starting_cell(t, test_cases)\nfor result in results:\n    print(result[0], result[1])\n\nmain()", "completions": ["def calculate_max_commands(n, m, commands):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def execute_commands(start_x, start_y):\n        x, y = start_x, start_y\n        count = 0\n        visited = set()\n        \n        while is_valid_move(x, y) and (x, y) not in visited:\n            visited.add((x, y))\n            count += 1\n            dx, dy = directions[commands[count % len(commands)]]\n            x, y = x + dx, y + dy\n        \n        return count\n    \n    max_commands = 0\n    best_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            commands_executed = execute_commands(i, j)\n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                best_cell = (i+1, j+1)\n    \n    return best_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = calculate_max_commands(n, m, commands)\n    results.append(result)\n\nfor res in results:\n    print(res[0], res[1])\n\nmain()", "def max_commands(n, m, s):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def count_commands(x, y):\n        visited = set()\n        count = 0\n        while is_valid_move(x, y) and (x, y) not in visited:\n            visited.add((x, y))\n            dx, dy = directions[s[count % len(s)]]\n            x, y = x + dx, y + dy\n            count += 1\n        return count\n\n    max_count = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            count = count_commands(i, j)\n            if count > max_count:\n                max_count = count\n                start_cell = (i, j)\n\n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input().strip()\n    result = max_commands(n, m, s)\n    print(result[0], result[1])\n\nmain()", "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    optimal_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            current_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                optimal_cell = (i, j)\n    \n    return optimal_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    optimal_cell = find_starting_cell(n, m, commands)\n    print(optimal_cell[0], optimal_cell[1])\n\nmain()", "def execute_commands(n, m, commands):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def count_successful_moves(start_x, start_y):\n        successful_moves = 0\n        visited = set()\n        x, y = start_x, start_y\n        \n        while is_valid_move(x, y) and (x, y) not in visited:\n            visited.add((x, y))\n            successful_moves += 1\n            dx, dy = directions[commands[successful_moves % len(commands)]]\n            x, y = x + dx, y + dy\n        \n        return successful_moves\n    \n    max_successful_moves = 0\n    best_starting_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            successful_moves = count_successful_moves(i, j)\n            if successful_moves > max_successful_moves:\n                max_successful_moves = successful_moves\n                best_starting_cell = (i+1, j+1)\n    \n    return best_starting_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = execute_commands(n, m, commands)\n    results.append(result)\n\nfor res in results:\n    print(res[0], res[1])\n\nmain()", "def max_commands(n, m, s):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def count_commands(start_x, start_y):\n        visited = set()\n        x, y = start_x, start_y\n        count = 0\n        \n        while is_valid_move(x, y) and (x, y) not in visited:\n            visited.add((x, y))\n            count += 1\n            dx, dy = directions[s[count % len(s)]]\n            x, y = x + dx, y + dy\n        \n        return count\n    \n    max_count = 0\n    max_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            count = count_commands(i, j)\n            if count > max_count:\n                max_count = count\n                max_cell = (i+1, j+1)\n    \n    return max_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input().strip()\n    result = max_commands(n, m, s)\n    results.append(result)\n\nfor res in results:\n    print(res[0], res[1])\n\nmain()", "def execute_commands(n, m, commands):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def count_commands(x, y):\n        visited = [[False for _ in range(m)] for _ in range(n)]\n        count = 0\n        while is_valid_move(x, y) and not visited[x][y]:\n            visited[x][y] = True\n            dx, dy = directions[commands[count % len(commands)]]\n            x, y = x + dx, y + dy\n            count += 1\n        return count\n    \n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            commands_count = count_commands(i, j)\n            if commands_count > max_commands:\n                max_commands = commands_count\n                start_cell = (i+1, j+1)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    start_cell = execute_commands(n, m, commands)\n    print(start_cell[0], start_cell[1])\n\nmain()", "def find_starting_cell(t, test_cases):\n    def simulate_movement(n, m, commands):\n        directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n        \n        def is_valid_move(x, y):\n            return 0 <= x < n and 0 <= y < m\n        \n        def execute_commands(start_x, start_y):\n            x, y = start_x, start_y\n            successful_commands = 0\n            visited = set()\n            \n            for command in commands:\n                dx, dy = directions[command]\n                new_x, new_y = x + dx, y + dy\n                \n                if is_valid_move(new_x, new_y) and (new_x, new_y) not in visited:\n                    x, y = new_x, new_y\n                    successful_commands += 1\n                    visited.add((x, y))\n                else:\n                    break\n            \n            return successful_commands\n        \n        max_successful_commands = 0\n        best_starting_cell = (1, 1)\n        \n        for i in range(n):\n            for j in range(m):\n                successful_commands = execute_commands(i, j)\n                if successful_commands > max_successful_commands:\n                    max_successful_commands = successful_commands\n                    best_starting_cell = (i+1, j+1)\n        \n        return best_starting_cell\n    \n    results = []\n    \n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        result = simulate_movement(n, m, commands)\n        results.append(result)\n    \n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nresults = find_starting_cell(t, test_cases)\nfor result in results:\n    print(result[0], result[1])\n\nmain()", "def calculate_max_commands(n, m, commands):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def execute_commands(start_x, start_y):\n        x, y = start_x, start_y\n        count = 0\n        visited = set()\n        \n        while is_valid_move(x, y) and (x, y) not in visited:\n            visited.add((x, y))\n            count += 1\n            dx, dy = directions[commands[count % len(commands)]]\n            x, y = x + dx, y + dy\n        \n        return count\n    \n    max_commands = 0\n    best_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            commands_executed = execute_commands(i, j)\n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                best_cell = (i+1, j+1)\n    \n    return best_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = calculate_max_commands(n, m, commands)\n    results.append(result)\n\nfor res in results:\n    print(res[0], res[1])\n\nmain()", "def max_commands(n, m, s):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def count_commands(start_x, start_y):\n        visited = set()\n        x, y = start_x, start_y\n        count = 0\n        while is_valid_move(x, y) and (x, y) not in visited:\n            visited.add((x, y))\n            count += 1\n            dx, dy = directions[s[count % len(s)]]\n            x, y = x + dx, y + dy\n        return count\n\n    max_count = 0\n    max_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            count = count_commands(i, j)\n            if count > max_count:\n                max_count = count\n                max_cell = (i + 1, j + 1)\n\n    return max_cell\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input().strip()\n    result = max_commands(n, m, s)\n    results.append(result)\n\nfor res in results:\n    print(res[0], res[1])\n\nmain()", "def find_starting_cell(t, test_cases):\n    def execute_commands(n, m, commands):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n        \n        def is_valid_move(x, y):\n            return 0 <= x < n and 0 <= y < m\n        \n        def count_successful_moves(start_x, start_y):\n            visited = set()\n            x, y = start_x, start_y\n            count = 0\n            \n            while is_valid_move(x, y) and (x, y) not in visited:\n                visited.add((x, y))\n                count += 1\n                dx, dy = directions[commands[count % len(commands)]]\n                x, y = x + dx, y + dy\n                \n            return count\n        \n        max_successful_moves = 0\n        best_starting_cell = (1, 1)\n        \n        for i in range(n):\n            for j in range(m):\n                successful_moves = count_successful_moves(i, j)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    best_starting_cell = (i+1, j+1)\n        \n        return best_starting_cell\n    \n    results = []\n    \n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        result = execute_commands(n, m, commands)\n        results.append(result)\n    \n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nresults = find_starting_cell(t, test_cases)\nfor result in results:\n    print(result[0], result[1])\n\nmain()"], "session_history": {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Determine the maximum number of commands that can be executed starting from each cell on the board\",\n    \"Identify the cell from which the robot should start moving to perform as many commands as possible\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"step_2\": \"For each test case, create a matrix representing the board with dimensions n x m\",\n    \"step_3\": \"Iterate through each cell on the board and simulate the robot's movement based on the command sequence\",\n    \"step_4\": \"Track the number of successful commands executed from each cell\",\n    \"step_5\": \"Identify the cell with the maximum number of successful commands executed\",\n    \"step_6\": \"Output the coordinates of the identified cell\"\n  }\n}", "Round_0": {"code": "def find_starting_cell(t, test_cases):\n    def execute_commands(n, m, commands):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n        \n        def is_valid_move(x, y):\n            return 0 <= x < n and 0 <= y < m\n        \n        def count_successful_moves(start_x, start_y):\n            visited = set()\n            x, y = start_x, start_y\n            count = 0\n            \n            while is_valid_move(x, y) and (x, y) not in visited:\n                visited.add((x, y))\n                count += 1\n                dx, dy = directions[commands[count % len(commands)]]\n                x, y = x + dx, y + dy\n                \n            return count\n        \n        max_successful_moves = 0\n        best_starting_cell = (1, 1)\n        \n        for i in range(n):\n            for j in range(m):\n                successful_moves = count_successful_moves(i, j)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    best_starting_cell = (i+1, j+1)\n        \n        return best_starting_cell\n    \n    results = []\n    \n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        result = execute_commands(n, m, commands)\n        results.append(result)\n    \n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nresults = find_starting_cell(t, test_cases)\nfor result in results:\n    print(result[0], result[1])\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 60)"}, "Round_1": {"code": "def find_starting_cell(t, test_cases):\n    def execute_commands(n, m, commands):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n        \n        def is_valid_move(x, y):\n            return 0 <= x < n and 0 <= y < m\n        \n        def count_successful_moves(start_x, start_y):\n            visited = set()\n            x, y = start_x, start_y\n            count = 0\n            \n            while is_valid_move(x, y) and (x, y) not in visited:\n                visited.add((x, y))\n                count += 1\n                dx, dy = directions[commands[count % len(commands)]]\n                x, y = x + dx, y + dy\n                \n            return count\n        \n        max_successful_moves = 0\n        best_starting_cell = (1, 1)\n        \n        for i in range(n):\n            for j in range(m):\n                successful_moves = count_successful_moves(i, j)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    best_starting_cell = (i+1, j+1)\n        \n        return best_starting_cell\n    \n    results = []\n    \n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        result = execute_commands(n, m, commands)\n        results.append(result)\n    \n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nresults = find_starting_cell(t, test_cases)\nfor result in results:\n    print(result[0], result[1])\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Determine the maximum number of commands that can be executed starting from each cell on the board\",\n    \"Identify the cell from which the robot should start moving to perform as many commands as possible\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"step_2\": \"Create a function to calculate the maximum number of commands that can be executed starting from a given cell\",\n    \"step_3\": \"Iterate through all cells on the board and calculate the maximum number of commands that can be executed from each cell\",\n    \"step_4\": \"Identify the cell with the highest number of commands and output its coordinates\"\n  }\n}", "Round_0": {"code": "def calculate_max_commands(n, m, commands):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def execute_commands(start_x, start_y):\n        x, y = start_x, start_y\n        count = 0\n        visited = set()\n        \n        while is_valid_move(x, y) and (x, y) not in visited:\n            visited.add((x, y))\n            count += 1\n            dx, dy = directions[commands[count % len(commands)]]\n            x, y = x + dx, y + dy\n        \n        return count\n    \n    max_commands = 0\n    best_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            commands_executed = execute_commands(i, j)\n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                best_cell = (i+1, j+1)\n    \n    return best_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = calculate_max_commands(n, m, commands)\n    results.append(result)\n\nfor res in results:\n    print(res[0], res[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def calculate_max_commands(n, m, commands):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def execute_commands(start_x, start_y):\n        x, y = start_x, start_y\n        count = 0\n        visited = set()\n        \n        while is_valid_move(x, y) and (x, y) not in visited:\n            visited.add((x, y))\n            count += 1\n            dx, dy = directions[commands[count % len(commands)]]\n            x, y = x + dx, y + dy\n        \n        return count\n    \n    max_commands = 0\n    best_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            commands_executed = execute_commands(i, j)\n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                best_cell = (i+1, j+1)\n    \n    return best_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = calculate_max_commands(n, m, commands)\n    results.append(result)\n\nfor res in results:\n    print(res[0], res[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Determine the maximum number of commands that can be executed starting from each cell on the board\",\n    \"Identify the cell from which the robot should start moving to perform as many commands as possible\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"step_2\": \"Create a function to calculate the maximum number of commands that can be executed starting from a given cell\",\n    \"step_3\": \"Iterate through all cells on the board and calculate the maximum number of commands that can be executed from each cell\",\n    \"step_4\": \"Identify the cell with the highest number of commands and output its coordinates\"\n  }\n}", "Round_0": {"code": "def max_commands(n, m, s):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def count_commands(x, y):\n        visited = set()\n        count = 0\n        while is_valid_move(x, y) and (x, y) not in visited:\n            visited.add((x, y))\n            dx, dy = directions[s[count % len(s)]]\n            x, y = x + dx, y + dy\n            count += 1\n        return count\n\n    max_count = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            count = count_commands(i, j)\n            if count > max_count:\n                max_count = count\n                start_cell = (i, j)\n\n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input().strip()\n    result = max_commands(n, m, s)\n    print(result[0], result[1])\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 41)"}, "Round_1": {"code": "def max_commands(n, m, s):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def count_commands(x, y):\n        visited = set()\n        count = 0\n        while is_valid_move(x, y) and (x, y) not in visited:\n            visited.add((x, y))\n            dx, dy = directions[s[count % len(s)]]\n            x, y = x + dx, y + dy\n            count += 1\n        return count\n\n    max_count = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            count = count_commands(i, j)\n            if count > max_count:\n                max_count = count\n                start_cell = (i, j)\n\n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input().strip()\n    result = max_commands(n, m, s)\n    print(result[0], result[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify the maximum number of commands the robot can execute without falling off the board\",\n    \"Determine the starting cell that maximizes successful moves\",\n    \"Consider edge cases like a very small board or commands moving in a single direction\",\n    \"Optimize the solution to handle large values of n and m efficiently\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of test cases\",\n    \"Step 2\": \"For each test case, extract the board dimensions and command sequence\",\n    \"Step 3\": \"Implement a function to simulate the robot's movement on the board based on the command sequence\",\n    \"Step 4\": \"Iterate through all cells on the board to find the starting cell that maximizes successful moves\",\n    \"Step 5\": \"Output the coordinates of the optimal starting cell for each test case\"\n  }\n}", "Round_0": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    optimal_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            current_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                optimal_cell = (i, j)\n    \n    return optimal_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    optimal_cell = find_starting_cell(n, m, commands)\n    print(optimal_cell[0], optimal_cell[1])\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 44)"}, "Round_1": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    optimal_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            current_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                optimal_cell = (i, j)\n    \n    return optimal_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    optimal_cell = find_starting_cell(n, m, commands)\n    print(optimal_cell[0], optimal_cell[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Determine the maximum number of commands that can be executed starting from each cell on the board\",\n    \"Identify the cell from which the robot should start moving to perform as many commands as possible\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"step_2\": \"For each test case, create a matrix representing the board with dimensions n x m\",\n    \"step_3\": \"Iterate through each cell on the board and simulate the robot's movement based on the command sequence\",\n    \"step_4\": \"Track the number of successful commands executed from each cell\",\n    \"step_5\": \"Identify the cell with the maximum number of successful commands executed\",\n    \"step_6\": \"Output the coordinates of the identified cell\"\n  }\n}", "Round_0": {"code": "def execute_commands(n, m, commands):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def count_successful_moves(start_x, start_y):\n        successful_moves = 0\n        visited = set()\n        x, y = start_x, start_y\n        \n        while is_valid_move(x, y) and (x, y) not in visited:\n            visited.add((x, y))\n            successful_moves += 1\n            dx, dy = directions[commands[successful_moves % len(commands)]]\n            x, y = x + dx, y + dy\n        \n        return successful_moves\n    \n    max_successful_moves = 0\n    best_starting_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            successful_moves = count_successful_moves(i, j)\n            if successful_moves > max_successful_moves:\n                max_successful_moves = successful_moves\n                best_starting_cell = (i+1, j+1)\n    \n    return best_starting_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = execute_commands(n, m, commands)\n    results.append(result)\n\nfor res in results:\n    print(res[0], res[1])\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 49)"}, "Round_1": {"code": "def execute_commands(n, m, commands):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def count_successful_moves(start_x, start_y):\n        successful_moves = 0\n        visited = set()\n        x, y = start_x, start_y\n        \n        while is_valid_move(x, y) and (x, y) not in visited:\n            visited.add((x, y))\n            successful_moves += 1\n            dx, dy = directions[commands[successful_moves % len(commands)]]\n            x, y = x + dx, y + dy\n        \n        return successful_moves\n    \n    max_successful_moves = 0\n    best_starting_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            successful_moves = count_successful_moves(i, j)\n            if successful_moves > max_successful_moves:\n                max_successful_moves = successful_moves\n                best_starting_cell = (i+1, j+1)\n    \n    return best_starting_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = execute_commands(n, m, commands)\n    results.append(result)\n\nfor res in results:\n    print(res[0], res[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Determine the maximum number of commands that can be executed starting from each cell on the board\",\n    \"Identify the cell from which the robot should start moving to perform as many commands as possible\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the necessary information for each test case\",\n    \"Create a function to calculate the maximum number of commands that can be executed starting from a given cell\",\n    \"Iterate through all cells on the board to find the cell with the maximum number of commands that can be executed\",\n    \"Output the coordinates of the identified cell for each test case\"\n  ]\n}", "Round_0": {"code": "def max_commands(n, m, s):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def count_commands(start_x, start_y):\n        visited = set()\n        x, y = start_x, start_y\n        count = 0\n        \n        while is_valid_move(x, y) and (x, y) not in visited:\n            visited.add((x, y))\n            count += 1\n            dx, dy = directions[s[count % len(s)]]\n            x, y = x + dx, y + dy\n        \n        return count\n    \n    max_count = 0\n    max_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            count = count_commands(i, j)\n            if count > max_count:\n                max_count = count\n                max_cell = (i+1, j+1)\n    \n    return max_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input().strip()\n    result = max_commands(n, m, s)\n    results.append(result)\n\nfor res in results:\n    print(res[0], res[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def max_commands(n, m, s):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def count_commands(start_x, start_y):\n        visited = set()\n        x, y = start_x, start_y\n        count = 0\n        \n        while is_valid_move(x, y) and (x, y) not in visited:\n            visited.add((x, y))\n            count += 1\n            dx, dy = directions[s[count % len(s)]]\n            x, y = x + dx, y + dy\n        \n        return count\n    \n    max_count = 0\n    max_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            count = count_commands(i, j)\n            if count > max_count:\n                max_count = count\n                max_cell = (i+1, j+1)\n    \n    return max_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input().strip()\n    result = max_commands(n, m, s)\n    results.append(result)\n\nfor res in results:\n    print(res[0], res[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Determine the maximum number of commands that can be executed starting from each cell on the board\",\n    \"Identify the cell from which the robot should start moving to perform as many commands as possible\"\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases\",\n    \"For each test case:\",\n    \"   Read the board dimensions and command sequence\",\n    \"   Initialize a 2D array to store the maximum number of commands that can be executed starting from each cell\",\n    \"   Iterate through each cell on the board and calculate the maximum number of commands that can be executed starting from that cell\",\n    \"   Identify the cell with the maximum number of commands and output its coordinates\"\n  ]\n}", "Round_0": {"code": "def execute_commands(n, m, commands):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def count_commands(x, y):\n        visited = [[False for _ in range(m)] for _ in range(n)]\n        count = 0\n        while is_valid_move(x, y) and not visited[x][y]:\n            visited[x][y] = True\n            dx, dy = directions[commands[count % len(commands)]]\n            x, y = x + dx, y + dy\n            count += 1\n        return count\n    \n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            commands_count = count_commands(i, j)\n            if commands_count > max_commands:\n                max_commands = commands_count\n                start_cell = (i+1, j+1)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    start_cell = execute_commands(n, m, commands)\n    print(start_cell[0], start_cell[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def execute_commands(n, m, commands):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def count_commands(x, y):\n        visited = [[False for _ in range(m)] for _ in range(n)]\n        count = 0\n        while is_valid_move(x, y) and not visited[x][y]:\n            visited[x][y] = True\n            dx, dy = directions[commands[count % len(commands)]]\n            x, y = x + dx, y + dy\n            count += 1\n        return count\n    \n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            commands_count = count_commands(i, j)\n            if commands_count > max_commands:\n                max_commands = commands_count\n                start_cell = (i+1, j+1)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    start_cell = execute_commands(n, m, commands)\n    print(start_cell[0], start_cell[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Determine the maximum number of commands that can be executed starting from each cell on the board\",\n    \"Identify the cell from which the robot should start moving to perform as many commands as possible\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Step 2\": \"For each test case, create a matrix representing the board with dimensions n x m\",\n    \"Step 3\": \"Iterate through each cell on the board and simulate the robot's movement based on the command sequence\",\n    \"Step 4\": \"Track the number of successful commands executed from each cell\",\n    \"Step 5\": \"Identify the cell with the maximum number of successful commands executed\",\n    \"Step 6\": \"Output the coordinates of the identified cell\"\n  }\n}", "Round_0": {"code": "def find_starting_cell(t, test_cases):\n    def simulate_movement(n, m, commands):\n        directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n        \n        def is_valid_move(x, y):\n            return 0 <= x < n and 0 <= y < m\n        \n        def execute_commands(start_x, start_y):\n            x, y = start_x, start_y\n            successful_commands = 0\n            visited = set()\n            \n            for command in commands:\n                dx, dy = directions[command]\n                new_x, new_y = x + dx, y + dy\n                \n                if is_valid_move(new_x, new_y) and (new_x, new_y) not in visited:\n                    x, y = new_x, new_y\n                    successful_commands += 1\n                    visited.add((x, y))\n                else:\n                    break\n            \n            return successful_commands\n        \n        max_successful_commands = 0\n        best_starting_cell = (1, 1)\n        \n        for i in range(n):\n            for j in range(m):\n                successful_commands = execute_commands(i, j)\n                if successful_commands > max_successful_commands:\n                    max_successful_commands = successful_commands\n                    best_starting_cell = (i+1, j+1)\n        \n        return best_starting_cell\n    \n    results = []\n    \n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        result = simulate_movement(n, m, commands)\n        results.append(result)\n    \n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nresults = find_starting_cell(t, test_cases)\nfor result in results:\n    print(result[0], result[1])\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 65)"}, "Round_1": {"code": "def find_starting_cell(t, test_cases):\n    def simulate_movement(n, m, commands):\n        directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n        \n        def is_valid_move(x, y):\n            return 0 <= x < n and 0 <= y < m\n        \n        def execute_commands(start_x, start_y):\n            x, y = start_x, start_y\n            successful_commands = 0\n            visited = set()\n            \n            for command in commands:\n                dx, dy = directions[command]\n                new_x, new_y = x + dx, y + dy\n                \n                if is_valid_move(new_x, new_y) and (new_x, new_y) not in visited:\n                    x, y = new_x, new_y\n                    successful_commands += 1\n                    visited.add((x, y))\n                else:\n                    break\n            \n            return successful_commands\n        \n        max_successful_commands = 0\n        best_starting_cell = (1, 1)\n        \n        for i in range(n):\n            for j in range(m):\n                successful_commands = execute_commands(i, j)\n                if successful_commands > max_successful_commands:\n                    max_successful_commands = successful_commands\n                    best_starting_cell = (i+1, j+1)\n        \n        return best_starting_cell\n    \n    results = []\n    \n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        result = simulate_movement(n, m, commands)\n        results.append(result)\n    \n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nresults = find_starting_cell(t, test_cases)\nfor result in results:\n    print(result[0], result[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Determine the maximum number of commands that can be executed starting from each cell on the board\",\n    \"Identify the cell from which the robot should start moving to perform as many commands as possible\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"step_2\": \"Create a function to calculate the maximum number of commands that can be executed starting from a given cell\",\n    \"step_3\": \"Iterate through all cells on the board and calculate the maximum number of commands that can be executed from each cell\",\n    \"step_4\": \"Identify the cell with the highest number of commands and output its coordinates\"\n  }\n}", "Round_0": {"code": "def calculate_max_commands(n, m, commands):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def execute_commands(start_x, start_y):\n        x, y = start_x, start_y\n        count = 0\n        visited = set()\n        \n        while is_valid_move(x, y) and (x, y) not in visited:\n            visited.add((x, y))\n            count += 1\n            dx, dy = directions[commands[count % len(commands)]]\n            x, y = x + dx, y + dy\n        \n        return count\n    \n    max_commands = 0\n    best_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            commands_executed = execute_commands(i, j)\n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                best_cell = (i+1, j+1)\n    \n    return best_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = calculate_max_commands(n, m, commands)\n    results.append(result)\n\nfor res in results:\n    print(res[0], res[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def calculate_max_commands(n, m, commands):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def execute_commands(start_x, start_y):\n        x, y = start_x, start_y\n        count = 0\n        visited = set()\n        \n        while is_valid_move(x, y) and (x, y) not in visited:\n            visited.add((x, y))\n            count += 1\n            dx, dy = directions[commands[count % len(commands)]]\n            x, y = x + dx, y + dy\n        \n        return count\n    \n    max_commands = 0\n    best_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            commands_executed = execute_commands(i, j)\n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                best_cell = (i+1, j+1)\n    \n    return best_cell\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = calculate_max_commands(n, m, commands)\n    results.append(result)\n\nfor res in results:\n    print(res[0], res[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Determine the maximum number of commands that can be executed starting from each cell on the board\",\n    \"Identify the cell from which the robot should start moving to perform as many commands as possible\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"step_2\": \"Create a function to calculate the maximum number of commands that can be executed starting from a given cell\",\n    \"step_3\": \"Iterate through all cells on the board and calculate the maximum number of commands that can be executed from each cell\",\n    \"step_4\": \"Identify the cell with the highest number of commands and output its coordinates\"\n  }\n}", "Round_0": {"code": "def max_commands(n, m, s):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def count_commands(start_x, start_y):\n        visited = set()\n        x, y = start_x, start_y\n        count = 0\n        while is_valid_move(x, y) and (x, y) not in visited:\n            visited.add((x, y))\n            count += 1\n            dx, dy = directions[s[count % len(s)]]\n            x, y = x + dx, y + dy\n        return count\n\n    max_count = 0\n    max_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            count = count_commands(i, j)\n            if count > max_count:\n                max_count = count\n                max_cell = (i + 1, j + 1)\n\n    return max_cell\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input().strip()\n    result = max_commands(n, m, s)\n    results.append(result)\n\nfor res in results:\n    print(res[0], res[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def max_commands(n, m, s):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def count_commands(start_x, start_y):\n        visited = set()\n        x, y = start_x, start_y\n        count = 0\n        while is_valid_move(x, y) and (x, y) not in visited:\n            visited.add((x, y))\n            count += 1\n            dx, dy = directions[s[count % len(s)]]\n            x, y = x + dx, y + dy\n        return count\n\n    max_count = 0\n    max_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            count = count_commands(i, j)\n            if count > max_count:\n                max_count = count\n                max_cell = (i + 1, j + 1)\n\n    return max_cell\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input().strip()\n    result = max_commands(n, m, s)\n    results.append(result)\n\nfor res in results:\n    print(res[0], res[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Determine the maximum number of commands that can be executed starting from each cell on the board\",\n    \"Identify the cell from which the robot should start moving to perform as many commands as possible\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"step_2\": \"For each test case, create a matrix representing the board with dimensions n x m\",\n    \"step_3\": \"Iterate through each cell on the board and simulate the robot's movement based on the command sequence\",\n    \"step_4\": \"Track the number of successful commands executed from each cell\",\n    \"step_5\": \"Identify the cell with the maximum number of successful commands executed\",\n    \"step_6\": \"Output the coordinates of the identified cell\"\n  }\n}", "Round_0": {"code": "def find_starting_cell(t, test_cases):\n    def execute_commands(n, m, commands):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n        \n        def is_valid_move(x, y):\n            return 0 <= x < n and 0 <= y < m\n        \n        def count_successful_moves(start_x, start_y):\n            visited = set()\n            x, y = start_x, start_y\n            count = 0\n            \n            while is_valid_move(x, y) and (x, y) not in visited:\n                visited.add((x, y))\n                count += 1\n                dx, dy = directions[commands[count % len(commands)]]\n                x, y = x + dx, y + dy\n                \n            return count\n        \n        max_successful_moves = 0\n        best_starting_cell = (1, 1)\n        \n        for i in range(n):\n            for j in range(m):\n                successful_moves = count_successful_moves(i, j)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    best_starting_cell = (i+1, j+1)\n        \n        return best_starting_cell\n    \n    results = []\n    \n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        result = execute_commands(n, m, commands)\n        results.append(result)\n    \n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nresults = find_starting_cell(t, test_cases)\nfor result in results:\n    print(result[0], result[1])\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 60)"}, "Round_1": {"code": "def find_starting_cell(t, test_cases):\n    def execute_commands(n, m, commands):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n        \n        def is_valid_move(x, y):\n            return 0 <= x < n and 0 <= y < m\n        \n        def count_successful_moves(start_x, start_y):\n            visited = set()\n            x, y = start_x, start_y\n            count = 0\n            \n            while is_valid_move(x, y) and (x, y) not in visited:\n                visited.add((x, y))\n                count += 1\n                dx, dy = directions[commands[count % len(commands)]]\n                x, y = x + dx, y + dy\n                \n            return count\n        \n        max_successful_moves = 0\n        best_starting_cell = (1, 1)\n        \n        for i in range(n):\n            for j in range(m):\n                successful_moves = count_successful_moves(i, j)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    best_starting_cell = (i+1, j+1)\n        \n        return best_starting_cell\n    \n    results = []\n    \n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        result = execute_commands(n, m, commands)\n        results.append(result)\n    \n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nresults = find_starting_cell(t, test_cases)\nfor result in results:\n    print(result[0], result[1])\n"}}], "scores": [], "pass_results": [false, false, false, false, false, false, true, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 85, "prompt": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns), with rows numbered from 1 to n from top to bottom and columns numbered from 1 to m from left to right. The robot is able to move from the current cell to one of the four cells adjacent by side, executing the sequence of commands s given, with each command denoted by 'L', 'R', 'D' or 'U' for moving left, right, down or up, respectively. The robot can start its movement in any cell, executing the commands from the first one in s strictly in order, but falls and breaks if it moves beyond the board's edge, rendering a command causing it to break unsuccessfully executed. The robot's task is to execute as many commands as possible without falling off the board; for example, on board 3 \u00d7 3, if starting a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, it performs one command before the next forces it over the edge. If starting from cell (2, 1), all commands succeed, stopping the robot in cell (1, 2). The robot starts from cell (2, 1), moves right, right, down, left, up, and up, ending in cell (1, 2). Determine the cell from which the robot should start its movement to execute the most commands; the goal is finding a starting cell that maximizes successful moves, considering edge cases like a very small board or commands moving in a single direction. Pay special attention to scenarios where the sequence of commands may form a loop. Ensure to consider the performance implications for large values of n and m. Consider optimizing your solution to handle cases efficiently where the length of the command sequence s is significantly large compared to the board dimensions.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "mutate_method": "add_1_sentence_at_end", "save_node": true, "parent_index": 51}
