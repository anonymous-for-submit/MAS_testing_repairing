{"name": "1579_F. Array Stabilization (AND version)", "description": "You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\n\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "tags": ["brute force", "graphs", "math", "number theory", "shortest paths"], "difficulty": 12, "id": 1579, "sample_io": [{"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}], "test_list": [{"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n1\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n2\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["1\n0\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n2\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 4\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n-1\n-1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 0 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n2\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n2\n2\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n0\n", "output": ["0\n1\n1\n2\n0\n"]}, {"input": "5\n2 1\n1 0\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["0\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 0 0 0\n1 1\n1\n", "output": ["1\n-1\n1\n0\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n2\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["0\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 2\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n4\n0\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 0 0 0\n1 1\n1\n", "output": ["-1\n-1\n1\n0\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n2\n3\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["-1\n1\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 0 0\n5 3\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n0\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 4\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n-1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n-1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 5\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n-1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["0\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 4\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n-1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n0 0 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n0\n2\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 3\n1 0 0 0 0\n4 4\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n1\n-1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 5\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n-1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 1\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["1\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n1\n3\n0\n"]}, {"input": "5\n2 2\n1 0\n3 3\n0 1 0\n5 5\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["-1\n-1\n-1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n1\n", "output": ["1\n0\n2\n3\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n0\n", "output": ["1\n0\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n0\n", "output": ["0\n0\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n2\n1\n1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 1 0 1\n1 1\n1\n", "output": ["-1\n1\n1\n3\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 1\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 0\n5 2\n1 0 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n0\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 1 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n3\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 1 1\n5 4\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 1\n1 1 0 0 0\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n2\n2\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n1 1 0\n5 4\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n2\n2\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n0\n", "output": ["0\n1\n2\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n1\n", "output": ["1\n1\n2\n3\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["-1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n1 1 0 0\n1 1\n0\n", "output": ["0\n-1\n2\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 0 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n1\n1\n-1\n"]}, {"input": "5\n2 2\n1 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 1\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 0 0\n5 1\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 1\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n3\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 3\n0 1 0\n5 4\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n3\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 5\n0 0 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n0\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n-1\n-1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 2\n1 1 1\n5 4\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 1\n1 0 1 0 0\n4 2\n0 1 0 1\n1 1\n1\n", "output": ["0\n1\n1\n-1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 1\n5 3\n0 0 1 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["0\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 0 0\n5 3\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["0\n0\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["0\n2\n2\n2\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n-1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n2\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["0\n2\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n0\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 0 0 1\n1 1\n1\n", "output": ["-1\n1\n3\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n4\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n3\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 0 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n0\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n1 1 1 0\n1 1\n0\n", "output": ["-1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 4\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 1\n0 0 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 1\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 0 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n1 1 1 0\n1 1\n0\n", "output": ["1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 1 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 0 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n2\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 0 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 0 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 0 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}], "task_id": "codecontest/18", "repair_prompt": ["You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only, and in this problem, unlike the others, the array indexes are numbered from zero instead of one. In one step, the array a is replaced by another array of length n according to the following rules: 1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells, where the elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n, meaning that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$.  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. For example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1]. The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        return arr[-d:] + arr[:-d]\n\n    def logical_and(arr1, arr2):\n        return [a & b for a, b in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "completions": ["def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        return arr[-d:] + arr[:-d]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    def process_test_case(n, d, arr):\n        steps = 0\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n            if arr == new_arr:\n                return -1\n        return steps\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        result = process_test_case(n, d, arr)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d), arr)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    def process_test_case(n, d, elements):\n        steps = 0\n        while not check_zeros(elements):\n            new_elements = logical_and(elements, cyclic_shift(elements, d))\n            steps += 1\n            if new_elements == elements:\n                return -1\n            elements = new_elements\n        return steps\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        elements = test_cases[i][1]\n        result = process_test_case(n, d, elements)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    elements = list(map(int, input().split()))\n    test_cases.append((n, d, elements))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor result in results:\n    print(result)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        arr = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d), arr)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        arr = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(arr):\n            arr_shifted = cyclic_shift(arr, d)\n            arr = logical_and(arr, arr_shifted)\n            steps += 1\n\n            if arr == arr_shifted:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d), arr)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        array = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(array):\n            shifted_array = cyclic_shift(array, d)\n            array = logical_and(array, shifted_array)\n            steps += 1\n\n            if array == shifted_array:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    array = list(map(int, input().split()))\n    test_cases.append((n, d, array))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    def process_test_case(n, d, elements):\n        steps = 0\n        while not check_zeros(elements):\n            new_arr = cyclic_shift(elements, d)\n            elements = logical_and(elements, new_arr)\n            steps += 1\n            if elements == new_arr:\n                return -1\n        return steps\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        elements = test_cases[i][1]\n        result = process_test_case(n, d, elements)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    elements = list(map(int, input().split()))\n    test_cases.append((n, d, elements))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_all_zeros(arr):\n        return all(elem == 0 for elem in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n\n        steps = 0\n        while not check_all_zeros(arr):\n            shifted_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, shifted_arr)\n            steps += 1\n\n            if arr == shifted_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d), arr)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(elem == 0 for elem in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_all_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n        steps = 0\n\n        while not check_all_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        return arr[-d:] + arr[:-d]\n\n    def logical_and(arr1, arr2):\n        return [a & b for a, b in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()"], "session_history": {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the array information for each test case\",\n      \"For each test case, implement the cyclic shift operation and logical 'AND' operation on the array elements\",\n      \"Repeat the operations until the array contains only zeros or determine if it will never contain only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases from input\",\n      \"Iterate over each test case and read the array size, cyclic shift offset, and array elements\",\n      \"Implement the cyclic shift operation on the array elements\",\n      \"Implement the logical 'AND' operation on the array elements\",\n      \"Repeat the operations until the array contains only zeros or determine if it will never contain only zeros\",\n      \"Output the number of steps taken for each test case\"\n    ]\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        return arr[-d:] + arr[:-d]\n\n    def logical_and(arr1, arr2):\n        return [a & b for a, b in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 49)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        return arr[-d:] + arr[:-d]\n\n    def logical_and(arr1, arr2):\n        return [a & b for a, b in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array information for each test case\",\n    \"Implement the cyclic shift operation on the array\",\n    \"Implement the logical 'AND' operation on each element of the array\",\n    \"Check if the array contains only zeros after each step\",\n    \"Count the number of steps taken to reach an array with only zeros or determine if it is not possible\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases and the array information for each test case\",\n    \"step_2\": \"For each test case, perform the cyclic shift operation on the array\",\n    \"step_3\": \"Perform the logical 'AND' operation on each element of the array\",\n    \"step_4\": \"Check if the array contains only zeros after each step\",\n    \"step_5\": \"Count the number of steps taken to reach an array with only zeros or determine if it is not possible\",\n    \"step_6\": \"Output the number of steps for each test case\"\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        return arr[-d:] + arr[:-d]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    def process_test_case(n, d, arr):\n        steps = 0\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n            if arr == new_arr:\n                return -1\n        return steps\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        result = process_test_case(n, d, arr)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d), arr)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 48)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        return arr[-d:] + arr[:-d]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    def process_test_case(n, d, arr):\n        steps = 0\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n            if arr == new_arr:\n                return -1\n        return steps\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        result = process_test_case(n, d, arr)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d), arr)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n    \"Implement the cyclic shift operation on the array\",\n    \"Implement the logical 'AND' operation on each element of the array\",\n    \"Check if the array contains only zeros after each step\",\n    \"Count the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases and test case descriptions\",\n    \"step_2\": \"For each test case, perform the following steps:\",\n    \"substeps\": [\n      \"Perform cyclic shift operation on the array based on the given offset\",\n      \"Perform logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros\",\n      \"Repeat the above steps until the array contains only zeros or determine it will never contain only zeros\",\n      \"Count the number of steps taken\"\n    ]\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    def process_test_case(n, d, elements):\n        steps = 0\n        while not check_zeros(elements):\n            new_elements = logical_and(elements, cyclic_shift(elements, d))\n            steps += 1\n            if new_elements == elements:\n                return -1\n            elements = new_elements\n        return steps\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        elements = test_cases[i][1]\n        result = process_test_case(n, d, elements)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    elements = list(map(int, input().split()))\n    test_cases.append((n, d, elements))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor result in results:\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 52)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    def process_test_case(n, d, elements):\n        steps = 0\n        while not check_zeros(elements):\n            new_elements = logical_and(elements, cyclic_shift(elements, d))\n            steps += 1\n            if new_elements == elements:\n                return -1\n            elements = new_elements\n        return steps\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        elements = test_cases[i][1]\n        result = process_test_case(n, d, elements)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    elements = list(map(int, input().split()))\n    test_cases.append((n, d, elements))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor result in results:\n    print(result)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Perform the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken to reach an array with only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case, read the array size, cyclic shift offset, and array elements\",\n      \"Initialize a counter to keep track of the number of steps taken\",\n      \"Repeat the following steps until the array contains only zeros or the process does not change the array anymore:\",\n      \"Perform the cyclic shift operation on the array\",\n      \"Perform the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros\",\n      \"Increment the step counter\",\n      \"Print the number of steps taken or -1 if the array still contains ones\"\n    ]\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        arr = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d), arr)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 50)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        arr = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d), arr)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n    \"Implement the cyclic shift operation on the array\",\n    \"Implement the logical 'AND' operation on each element of the array\",\n    \"Repeat the cyclic shift and 'AND' operations until the array contains only zeros or determine if it will never contain only zeros\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases and test case details\",\n    \"step_2\": \"For each test case, perform the cyclic shift operation on the array\",\n    \"step_3\": \"Perform the logical 'AND' operation on each element of the array\",\n    \"step_4\": \"Repeat steps 2 and 3 until the array contains only zeros or determine if it will never contain only zeros\",\n    \"step_5\": \"Output the number of steps taken for each test case or -1 if the array will never contain only zeros\"\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        arr = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(arr):\n            arr_shifted = cyclic_shift(arr, d)\n            arr = logical_and(arr, arr_shifted)\n            steps += 1\n\n            if arr == arr_shifted:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d), arr)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 49)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        arr = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(arr):\n            arr_shifted = cyclic_shift(arr, d)\n            arr = logical_and(arr, arr_shifted)\n            steps += 1\n\n            if arr == arr_shifted:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d), arr)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input data for each test case\",\n    \"Implement the cyclic shift operation on the array\",\n    \"Perform the logical 'AND' operation on each element of the array\",\n    \"Check if the array contains only zeros after each step\",\n    \"Count the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input data for the number of test cases\",\n    \"step_2\": \"For each test case, parse the array size, cyclic shift offset, and elements of the array\",\n    \"step_3\": \"Implement the cyclic shift operation on the array by shifting the elements to the right by the specified offset\",\n    \"step_4\": \"Perform the logical 'AND' operation on each element of the array with the corresponding element from the shifted array\",\n    \"step_5\": \"Check if the array contains only zeros after each step\",\n    \"step_6\": \"Repeat steps 3-5 until the array contains only zeros or determine if it will never contain only zeros\",\n    \"step_7\": \"Count the number of steps taken before the array contains only zeros or output -1 if it will never contain only zeros\"\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        array = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(array):\n            shifted_array = cyclic_shift(array, d)\n            array = logical_and(array, shifted_array)\n            steps += 1\n\n            if array == shifted_array:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    array = list(map(int, input().split()))\n    test_cases.append((n, d, array))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 48)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        array = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(array):\n            shifted_array = cyclic_shift(array, d)\n            array = logical_and(array, shifted_array)\n            steps += 1\n\n            if array == shifted_array:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    array = list(map(int, input().split()))\n    test_cases.append((n, d, array))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n    \"Implement the cyclic shift operation on the array\",\n    \"Implement the logical 'AND' operation on each element of the array\",\n    \"Check if the array contains only zeros after each step\",\n    \"Count the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases and test case details\",\n    \"step_2\": \"For each test case, perform the following steps:\",\n    \"substeps\": [\n      \"Perform cyclic shift operation on the array based on the given offset\",\n      \"Perform logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros\",\n      \"Repeat the above steps until the array contains only zeros or determine it will never contain only zeros\",\n      \"Count the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\"\n    ]\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    def process_test_case(n, d, elements):\n        steps = 0\n        while not check_zeros(elements):\n            new_arr = cyclic_shift(elements, d)\n            elements = logical_and(elements, new_arr)\n            steps += 1\n            if elements == new_arr:\n                return -1\n        return steps\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        elements = test_cases[i][1]\n        result = process_test_case(n, d, elements)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    elements = list(map(int, input().split()))\n    test_cases.append((n, d, elements))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 45)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    def process_test_case(n, d, elements):\n        steps = 0\n        while not check_zeros(elements):\n            new_arr = cyclic_shift(elements, d)\n            elements = logical_and(elements, new_arr)\n            steps += 1\n            if elements == new_arr:\n                return -1\n        return steps\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        elements = test_cases[i][1]\n        result = process_test_case(n, d, elements)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    elements = list(map(int, input().split()))\n    test_cases.append((n, d, elements))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the array information for each test case\",\n      \"Implement the logic to cyclically shift the array to the right by d cells\",\n      \"Implement the logic to perform element-wise logical 'AND' operation between the original array and the shifted array\",\n      \"Repeat the shifting and 'AND' operation until the array stops changing or all elements become zeros\",\n      \"Count the number of steps taken to reach the final array state\"\n    ],\n    \"high-level_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case, read the array size, cyclic shift offset, and array elements\",\n      \"Initialize a counter to keep track of the number of steps taken\",\n      \"Repeat the following steps until the array stops changing or all elements become zeros:\",\n      \"  - Perform cyclic shift of the array to the right by d cells\",\n      \"  - Perform element-wise logical 'AND' operation between the original array and the shifted array\",\n      \"  - Check if the array has changed or all elements are zeros, if yes, increment the step counter and continue, if no, break the loop\",\n      \"Print the number of steps taken for each test case\"\n    ]\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_all_zeros(arr):\n        return all(elem == 0 for elem in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n\n        steps = 0\n        while not check_all_zeros(arr):\n            shifted_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, shifted_arr)\n            steps += 1\n\n            if arr == shifted_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d), arr)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 46)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_all_zeros(arr):\n        return all(elem == 0 for elem in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n\n        steps = 0\n        while not check_all_zeros(arr):\n            shifted_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, shifted_arr)\n            steps += 1\n\n            if arr == shifted_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d), arr)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Perform the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken to reach an array with only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case, read the array size, cyclic shift offset, and array elements\",\n      \"Initialize a counter to keep track of the number of steps taken\",\n      \"Repeat the following steps until the array contains only zeros or the process does not change the array anymore:\",\n      \"Perform the cyclic shift operation on the array\",\n      \"Perform the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros\",\n      \"Increment the step counter\",\n      \"Print the number of steps taken or -1 if the array still contains elements other than zeros\"\n    ]\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(elem == 0 for elem in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 50)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(elem == 0 for elem in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Implement the logical 'AND' operation on each element of the array\",\n      \"Repeat the cyclic shift and 'AND' operations until the array stops changing or all elements become zeros\",\n      \"Count the number of steps taken to reach the final array state\"\n    ],\n    \"high-level_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case, read the array size, cyclic shift offset, and elements of the array\",\n      \"Perform cyclic shift operation on the array based on the given offset\",\n      \"Perform logical 'AND' operation on each element of the array\",\n      \"Repeat the cyclic shift and 'AND' operations until the array stops changing or all elements become zeros\",\n      \"Count the number of steps taken to reach the final array state\",\n      \"Output the number of steps or -1 if the array never contains only zeros\"\n    ]\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_all_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n        steps = 0\n\n        while not check_all_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 50)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_all_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n        steps = 0\n\n        while not check_all_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the array information for each test case\",\n      \"For each test case, implement the cyclic shift operation and logical 'AND' operation on the array elements\",\n      \"Repeat the operations until the array contains only zeros or determine if it will never contain only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases from input\",\n      \"Iterate over each test case and read the array size, cyclic shift offset, and array elements\",\n      \"Implement the cyclic shift operation on the array elements\",\n      \"Implement the logical 'AND' operation on the array elements\",\n      \"Repeat the operations until the array contains only zeros or determine if it will never contain only zeros\",\n      \"Output the number of steps taken for each test case\"\n    ]\n  }\n}", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        return arr[-d:] + arr[:-d]\n\n    def logical_and(arr1, arr2):\n        return [a & b for a, b in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 49)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        return arr[-d:] + arr[:-d]\n\n    def logical_and(arr1, arr2):\n        return [a & b for a, b in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}], "scores": [], "pass_results": [false, true, false, false, false, false, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 78, "prompt": "You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only, and in this problem, unlike the others, the array indexes are numbered from zero instead of one. In one step, the array a is replaced by another array of length n according to the following rules: 1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells, where the elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n, meaning that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$.  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. For example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1]. The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 34}
