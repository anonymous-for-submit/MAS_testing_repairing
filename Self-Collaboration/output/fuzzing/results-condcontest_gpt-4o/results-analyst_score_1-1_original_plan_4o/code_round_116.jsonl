{"name": "1586_H. Omkar and Tours", "description": "Omkar is hosting tours of his country, Omkarland! There are n cities in Omkarland, and, rather curiously, there are exactly n-1 bidirectional roads connecting the cities to each other. It is guaranteed that you can reach any city from any other city through the road network.\n\nEvery city has an enjoyment value e. Each road has a capacity c, denoting the maximum number of vehicles that can be on it, and an associated toll t. However, the toll system in Omkarland has an interesting quirk: if a vehicle travels on multiple roads on a single journey, they pay only the highest toll of any single road on which they traveled. (In other words, they pay max t over all the roads on which they traveled.) If a vehicle traverses no roads, they pay 0 toll.\n\nOmkar has decided to host q tour groups. Each tour group consists of v vehicles starting at city x. (Keep in mind that a tour group with v vehicles can travel only on roads with capacity \u2265 v.) Being the tour organizer, Omkar wants his groups to have as much fun as they possibly can, but also must reimburse his groups for the tolls that they have to pay. Thus, for each tour group, Omkar wants to know two things: first, what is the enjoyment value of the city y with maximum enjoyment value that the tour group can reach from their starting city, and second, how much per vehicle will Omkar have to pay to reimburse the entire group for their trip from x to y? (This trip from x to y will always be on the shortest path from x to y.)\n\nIn the case that there are multiple reachable cities with the maximum enjoyment value, Omkar will let his tour group choose which one they want to go to. Therefore, to prepare for all possible scenarios, he wants to know the amount of money per vehicle that he needs to guarantee that he can reimburse the group regardless of which city they choose.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 2 \u22c5 10^5, 1 \u2264 q \u2264 2 \u22c5 10^5), representing the number of cities and the number of groups, respectively.\n\nThe next line contains n integers e_1, e_2, \u2026, e_n (1 \u2264 e_i \u2264 10^9), where e_i represents the enjoyment value for city i.\n\nThe next n-1 lines each contain four integers a, b, c, and t (1 \u2264 a,b \u2264 n, 1 \u2264 c \u2264 10^9, 1 \u2264 t \u2264 10^9), representing an road between city a and city b with capacity c and toll t.\n\nThe next q lines each contain two integers v and x (1 \u2264 v \u2264 10^9, 1 \u2264 x \u2264 n), representing the number of vehicles in the tour group and the starting city, respectively.\n\nOutput\n\nOutput q lines. The i-th line should contain two integers: the highest possible enjoyment value of a city reachable by the i-th tour group, and the amount of money per vehicle Omkar needs to guarantee that he can reimburse the i-th tour group.\n\nExamples\n\nInput\n\n\n5 3\n2 2 3 3 3\n1 2 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n\n\nOutput\n\n\n3 8\n3 0\n3 2\n\n\nInput\n\n\n5 5\n1 2 3 4 5\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n\n\nOutput\n\n\n1 0\n2 1\n3 1\n4 1\n5 1\n\n\nInput\n\n\n5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\nOutput\n\n\n2 8\n2 8\n2 3\n2 1\n1 0\n\nNote\n\nA map of the first sample is shown below. For the nodes, unbolded numbers represent indices and bolded numbers represent enjoyment values. For the edges, unbolded numbers represent capacities and bolded numbers represent tolls.\n\n<image>\n\nFor the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.\n\nFor the second query, a tour group of size 9 starting at city 5 can reach only city 5. Thus, the largest reachable enjoyment value is still 3, and Omkar will pay 0 per vehicle.\n\nFor the third query, a tour group of size 6 starting at city 2 can reach cities 2 and 4. The largest reachable enjoyment value is again 3. If the tour group chooses to go to city 4, Omkar will have to pay 2 per vehicle, which is the maximum.\n\nA map of the second sample is shown below:\n\n<image>\n\nFor the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.\n\nFor the second query, a tour group of size 4 starting at city 1 can reach cities 1 and 2. Thus, their maximum enjoyment value is 2 and Omkar will pay 1 per vehicle.\n\nFor the third query, a tour group of size 3 starting at city 1 can reach cities 1, 2, and 3. Thus, their maximum enjoyment value is 3 and Omkar will pay 1 per vehicle.\n\nFor the fourth query, a tour group of size 2 starting at city 1 can reach cities 1, 2, 3 and 4. Thus, their maximum enjoyment value is 4 and Omkar will pay 1 per vehicle.\n\nFor the fifth query, a tour group of size 1 starting at city 1 can reach cities 1, 2, 3, 4, and 5. Thus, their maximum enjoyment value is 5 and Omkar will pay 1 per vehicle.", "tags": ["data structures", "dsu", "sortings", "trees"], "difficulty": 14, "id": 1586, "sample_io": [{"input": "5 5\n1 2 3 4 5\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n3 1\n4 1\n5 1\n"]}, {"input": "5 3\n2 2 3 3 3\n1 2 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n", "output": ["2 8\n2 8\n2 3\n2 1\n1 0\n"]}], "test_list": [{"input": "2 6\n1 2\n1 2 2 1\n1 1\n2 1\n3 1\n1 2\n2 2\n3 2\n", "output": ["2 1\n2 1\n1 0\n2 0\n2 0\n2 0\n"]}, {"input": "2 2\n7 3\n1 2 4 9\n10 1\n5 2\n", "output": ["7 0\n3 0\n"]}, {"input": "8 64\n1 1 1 1 1 1 1 1\n6 1 31 60\n1 3 3 8\n1 2 4 27\n4 1 41 27\n7 1 6 39\n1 5 28 46\n1 8 8 55\n55 6\n24 1\n28 1\n46 4\n15 6\n52 4\n58 4\n19 1\n55 8\n59 8\n18 2\n18 7\n26 1\n41 3\n48 4\n41 7\n46 6\n42 8\n44 4\n56 4\n13 1\n46 6\n1 2\n34 5\n47 6\n18 5\n35 8\n26 6\n57 7\n35 2\n27 3\n26 2\n39 2\n11 5\n23 1\n1 2\n54 3\n47 5\n48 2\n13 8\n40 6\n7 6\n38 2\n35 5\n6 6\n19 3\n10 6\n64 1\n2 3\n31 2\n1 6\n59 7\n47 3\n38 7\n18 4\n6 6\n27 7\n13 5\n63 8\n10 8\n11 4\n30 6\n2 2\n34 5\n", "output": ["1 0\n1 60\n1 60\n1 0\n1 60\n1 0\n1 0\n1 60\n1 0\n1 0\n1 0\n1 0\n1 60\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 60\n1 0\n1 60\n1 0\n1 0\n1 60\n1 0\n1 60\n1 0\n1 0\n1 0\n1 0\n1 0\n1 60\n1 60\n1 60\n1 0\n1 0\n1 0\n1 0\n1 0\n1 60\n1 0\n1 0\n1 60\n1 0\n1 60\n1 0\n1 60\n1 0\n1 60\n1 0\n1 0\n1 0\n1 60\n1 60\n1 0\n1 60\n1 0\n1 0\n1 60\n1 60\n1 60\n1 0\n"]}, {"input": "2 2\n7 0\n1 2 4 9\n10 1\n5 2\n", "output": ["7 0\n0 0\n"]}, {"input": "5 5\n1 2 3 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n4 1\n5 1\n"]}, {"input": "5 3\n2 2 3 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "2 2\n4 0\n1 2 4 9\n10 1\n5 2\n", "output": ["4 0\n0 0\n"]}, {"input": "5 5\n1 2 3 3 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n3 1\n5 1\n"]}, {"input": "5 5\n1 2 3 3 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 1\n5 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 3\n"]}, {"input": "5 5\n1 2 6 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n6 1\n6 1\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 4 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 8\n3 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 3\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n3 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 6\n1 2\n1 2 2 1\n1 2\n2 1\n3 1\n1 2\n2 2\n3 2\n", "output": ["2 0\n2 1\n1 0\n2 0\n2 0\n2 0\n"]}, {"input": "2 2\n7 2\n1 2 4 9\n10 1\n5 2\n", "output": ["7 0\n2 0\n"]}, {"input": "5 5\n1 2 3 4 0\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n3 1\n4 1\n4 1\n"]}, {"input": "5 3\n2 2 3 3 3\n1 2 4 13\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n", "output": ["3 13\n3 0\n3 2\n"]}, {"input": "5 5\n1 2 2 2 2\n1 2 2 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n", "output": ["2 5\n2 3\n2 3\n2 1\n1 0\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n5 1\n5 1\n"]}, {"input": "2 2\n4 0\n1 2 4 3\n10 2\n5 2\n", "output": ["0 0\n0 0\n"]}, {"input": "5 5\n1 2 3 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 0 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 1\n3 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 0 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n3 0\n3 2\n"]}, {"input": "5 5\n1 0 6 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 0\n6 1\n6 1\n"]}, {"input": "5 5\n1 2 3 4 0\n1 2 4 1\n1 3 3 1\n1 4 1 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n3 1\n3 1\n4 1\n"]}, {"input": "5 5\n1 2 2 2 2\n1 2 2 8\n1 3 6 3\n1 4 4 5\n1 5 2 1\n4 1\n5 1\n6 1\n7 1\n8 1\n", "output": ["2 5\n2 3\n2 3\n1 0\n1 0\n"]}, {"input": "2 2\n7 1\n1 2 4 9\n10 1\n7 2\n", "output": ["7 0\n1 0\n"]}, {"input": "5 5\n1 0 9 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 0\n9 1\n9 1\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 7\n1 3 1 8\n2 4 8 4\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 8\n3 0\n5 4\n"]}, {"input": "5 3\n4 1 0 5 3\n1 2 4 7\n1 3 1 11\n2 4 8 4\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n3 0\n5 4\n"]}, {"input": "5 3\n4 4 0 5 2\n1 2 4 7\n1 3 1 11\n1 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n4 0\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n2 1\n4 1\n5 1\n"]}, {"input": "2 2\n8 1\n1 2 4 3\n10 2\n5 2\n", "output": ["1 0\n1 0\n"]}, {"input": "5 3\n9 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["9 11\n2 0\n5 3\n"]}, {"input": "2 2\n7 2\n1 2 4 4\n10 1\n4 2\n", "output": ["7 0\n7 4\n"]}, {"input": "5 5\n1 2 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n2 1\n4 1\n6 1\n"]}, {"input": "5 3\n4 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 3\n7 5\n6 2\n", "output": ["4 8\n3 0\n4 7\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 1\n4 1\n6 1\n"]}, {"input": "5 3\n9 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 2 3\n4 5 2 1\n1 3\n7 5\n6 2\n", "output": ["9 11\n2 0\n2 0\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n5 1\n8 1\n5 1\n2 2\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 1\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n5 1\n8 1\n5 1\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "2 2\n11 3\n1 2 4 9\n10 1\n5 2\n", "output": ["11 0\n3 0\n"]}, {"input": "5 5\n1 2 3 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n3 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n2 1\n5 1\n"]}, {"input": "2 1\n4 0\n1 2 4 9\n10 1\n5 2\n", "output": ["4 0\n"]}, {"input": "5 3\n2 2 3 3 0\n1 2 4 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n0 0\n3 2\n"]}, {"input": "5 5\n1 2 3 3 5\n1 2 4 1\n1 3 2 2\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 2\n5 1\n"]}, {"input": "5 5\n1 2 6 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n8 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n6 1\n6 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 3\n", "output": ["3 8\n3 0\n0 0\n"]}, {"input": "5 3\n4 2 0 5 3\n1 2 4 7\n1 3 1 6\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 7\n3 0\n5 3\n"]}, {"input": "5 2\n4 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n"]}, {"input": "2 2\n5 2\n1 2 4 9\n10 1\n5 2\n", "output": ["5 0\n2 0\n"]}, {"input": "5 5\n1 2 3 4 0\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n3 1\n4 1\n4 1\n"]}, {"input": "5 3\n2 2 3 3 3\n1 2 4 13\n1 3 2 8\n2 4 3 2\n2 5 1 1\n1 3\n9 5\n6 2\n", "output": ["3 13\n3 0\n2 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 7\n1 3 1 5\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 7\n3 0\n3 2\n"]}, {"input": "5 5\n1 0 3 4 0\n1 2 4 1\n1 3 3 1\n1 4 1 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n3 1\n3 1\n4 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 7 7\n1 3 0 8\n2 4 2 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n3 0\n2 7\n"]}, {"input": "5 3\n4 1 0 5 6\n1 2 4 7\n1 3 1 11\n2 4 8 4\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["6 11\n6 0\n5 4\n"]}, {"input": "2 2\n8 2\n1 2 4 4\n10 1\n5 2\n", "output": ["8 0\n2 0\n"]}, {"input": "5 5\n1 2 5 4 6\n1 2 4 2\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n2 2\n4 1\n6 2\n"]}, {"input": "5 2\n9 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n6 2\n", "output": ["9 11\n2 0\n"]}, {"input": "5 3\n4 0 0 3 3\n1 2 6 7\n1 3 0 8\n2 4 8 2\n3 5 1 1\n1 3\n4 5\n6 2\n", "output": ["3 1\n3 0\n4 7\n"]}, {"input": "5 3\n4 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 2\n4 5\n4 2\n", "output": ["4 7\n3 0\n4 7\n"]}, {"input": "5 5\n1 2 3 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 2\n4 1\n3 1\n3 1\n1 1\n", "output": ["2 0\n2 1\n2 1\n2 1\n5 1\n"]}, {"input": "5 5\n1 2 3 3 5\n1 2 4 1\n1 3 2 2\n1 4 2 1\n2 5 1 1\n4 1\n4 2\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 0\n2 1\n3 2\n5 1\n"]}, {"input": "5 3\n4 2 0 5 3\n1 2 4 4\n1 3 1 6\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 6\n3 0\n5 3\n"]}, {"input": "2 2\n8 2\n1 2 8 4\n10 1\n5 2\n", "output": ["8 0\n8 4\n"]}, {"input": "5 5\n1 2 5 4 6\n1 2 1 2\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 1\n6 2\n"]}, {"input": "5 2\n9 2 0 5 2\n1 2 4 7\n1 3 1 3\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n6 2\n", "output": ["9 3\n2 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 9\n1 3 1 5\n2 4 8 2\n2 5 1 1\n1 3\n3 5\n6 2\n", "output": ["3 9\n3 0\n3 2\n"]}, {"input": "5 3\n4 4 0 5 2\n1 2 4 7\n1 3 1 11\n1 4 8 1\n2 5 1 1\n1 3\n14 5\n8 1\n", "output": ["5 11\n2 0\n5 1\n"]}, {"input": "2 1\n8 2\n1 2 8 4\n10 1\n5 2\n", "output": ["8 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 6 7\n1 3 1 9\n2 4 8 2\n3 5 1 0\n1 3\n7 5\n6 3\n", "output": ["3 9\n3 0\n0 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 12\n1 3 1 5\n2 4 8 2\n2 5 1 1\n1 3\n3 5\n6 2\n", "output": ["3 12\n3 0\n3 2\n"]}, {"input": "5 3\n4 4 0 5 4\n1 2 4 7\n1 3 1 11\n1 4 8 1\n2 5 1 1\n1 3\n14 5\n8 1\n", "output": ["5 11\n4 0\n5 1\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 6 7\n1 3 1 9\n2 4 8 2\n3 5 1 0\n2 3\n7 5\n6 3\n", "output": ["0 0\n3 0\n0 0\n"]}, {"input": "5 3\n10 0 0 5 2\n1 2 6 6\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["10 11\n2 0\n5 3\n"]}, {"input": "5 3\n2 0 0 3 2\n1 2 6 7\n1 3 1 9\n2 4 8 2\n3 5 1 0\n2 3\n7 5\n6 3\n", "output": ["0 0\n2 0\n0 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 12\n1 3 1 5\n2 4 8 3\n4 5 1 1\n1 3\n3 5\n6 2\n", "output": ["3 12\n3 0\n3 3\n"]}, {"input": "5 3\n4 9 0 5 4\n1 2 4 7\n1 3 1 11\n1 4 8 1\n2 5 1 1\n1 3\n14 5\n8 1\n", "output": ["9 11\n4 0\n5 1\n"]}, {"input": "5 3\n4 9 0 5 4\n1 2 4 14\n1 3 1 11\n1 4 8 1\n2 5 1 1\n1 3\n14 5\n8 1\n", "output": ["9 14\n4 0\n5 1\n"]}, {"input": "2 2\n7 3\n1 2 4 9\n10 2\n5 2\n", "output": ["3 0\n3 0\n"]}, {"input": "8 64\n1 1 1 1 1 1 1 1\n6 1 31 60\n1 3 3 8\n1 2 4 27\n4 1 41 27\n7 1 6 39\n1 5 28 46\n1 8 8 55\n55 6\n24 1\n28 1\n46 4\n15 6\n52 4\n58 4\n19 1\n55 8\n59 8\n18 2\n18 7\n26 1\n41 3\n48 4\n41 7\n46 6\n42 8\n44 4\n56 4\n13 1\n46 6\n1 2\n34 5\n47 6\n18 5\n35 8\n26 6\n57 7\n35 2\n27 3\n26 2\n39 2\n11 5\n23 1\n1 2\n54 3\n47 5\n48 2\n13 8\n40 6\n7 6\n38 2\n35 5\n6 6\n19 3\n10 6\n64 1\n2 3\n41 2\n1 6\n59 7\n47 3\n38 7\n18 4\n6 6\n27 7\n13 5\n63 8\n10 8\n11 4\n30 6\n2 2\n34 5\n", "output": ["1 0\n1 60\n1 60\n1 0\n1 60\n1 0\n1 0\n1 60\n1 0\n1 0\n1 0\n1 0\n1 60\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 60\n1 0\n1 60\n1 0\n1 0\n1 60\n1 0\n1 60\n1 0\n1 0\n1 0\n1 0\n1 0\n1 60\n1 60\n1 60\n1 0\n1 0\n1 0\n1 0\n1 0\n1 60\n1 0\n1 0\n1 60\n1 0\n1 60\n1 0\n1 60\n1 0\n1 60\n1 0\n1 0\n1 0\n1 60\n1 60\n1 0\n1 60\n1 0\n1 0\n1 60\n1 60\n1 60\n1 0\n"]}, {"input": "5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 2 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n", "output": ["2 8\n2 8\n2 3\n2 1\n1 0\n"]}, {"input": "5 5\n2 2 3 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 0\n2 1\n2 1\n4 1\n5 1\n"]}, {"input": "5 3\n4 2 0 5 3\n1 2 4 7\n1 3 0 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["0 0\n3 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 5\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n5 0\n5 3\n"]}, {"input": "2 2\n7 2\n1 2 4 9\n10 2\n5 2\n", "output": ["2 0\n2 0\n"]}, {"input": "5 5\n1 2 3 4 0\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 2\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 0\n3 1\n4 1\n4 1\n"]}, {"input": "5 3\n4 1 0 5 3\n1 2 4 7\n1 3 1 14\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 14\n3 0\n5 3\n"]}, {"input": "5 3\n7 4 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["7 11\n2 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n13 2\n", "output": ["5 11\n2 0\n2 0\n"]}, {"input": "2 6\n1 2\n1 2 2 1\n1 2\n2 1\n3 2\n1 2\n2 2\n2 2\n", "output": ["2 0\n2 1\n2 0\n2 0\n2 0\n2 0\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 7\n1 3 1 8\n2 4 8 4\n2 5 1 1\n1 4\n7 5\n8 2\n", "output": ["5 0\n3 0\n5 4\n"]}, {"input": "5 3\n4 1 0 5 4\n1 2 4 7\n1 3 1 11\n2 4 8 4\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n4 0\n5 4\n"]}, {"input": "5 3\n5 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 4\n", "output": ["5 11\n2 0\n5 0\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 1 1\n1 4 2 1\n2 5 1 2\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n2 1\n4 1\n5 2\n"]}, {"input": "2 2\n8 1\n1 2 4 3\n10 2\n2 2\n", "output": ["1 0\n8 3\n"]}, {"input": "5 3\n4 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 3\n4 5\n6 1\n", "output": ["4 8\n3 0\n4 0\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n5 1\n8 1\n5 1\n2 4\n2 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n4 1\n"]}, {"input": "5 5\n1 1 5 2 6\n1 2 4 1\n1 3 1 1\n1 4 2 0\n3 5 1 1\n10 1\n8 1\n5 2\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n2 0\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 5 1\n2 3 1 1\n1 4 2 0\n3 5 1 1\n10 1\n8 1\n5 2\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 1\n4 0\n6 1\n"]}, {"input": "2 2\n9 3\n1 2 4 9\n10 1\n5 2\n", "output": ["9 0\n3 0\n"]}, {"input": "2 2\n5 4\n1 2 4 9\n10 1\n5 2\n", "output": ["5 0\n4 0\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 7\n1 3 1 8\n3 4 15 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 3\n3 0\n2 0\n"]}, {"input": "5 3\n2 2 0 5 1\n1 2 1 7\n1 3 1 8\n2 4 8 4\n2 5 1 0\n1 3\n7 5\n8 2\n", "output": ["5 8\n1 0\n5 4\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n9 1\n8 1\n3 1\n4 1\n1 1\n", "output": ["1 0\n1 0\n1 1\n1 1\n6 1\n"]}, {"input": "5 5\n1 2 3 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 2\n4 1\n3 1\n3 2\n1 1\n", "output": ["2 0\n2 1\n2 1\n2 0\n5 1\n"]}, {"input": "5 3\n2 2 0 3 5\n1 2 7 7\n1 3 0 8\n2 4 2 2\n2 5 0 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n5 0\n2 7\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 9\n1 3 1 5\n2 4 8 2\n2 5 1 1\n1 3\n1 5\n6 2\n", "output": ["3 9\n3 2\n3 2\n"]}, {"input": "5 3\n5 4 0 5 2\n1 2 6 6\n1 3 1 11\n2 4 8 6\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 6\n"]}, {"input": "5 3\n2 2 3 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "2 2\n4 0\n1 2 4 3\n10 1\n5 2\n", "output": ["4 0\n0 0\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "5 5\n1 2 3 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 1\n5 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["3 8\n3 0\n3 3\n"]}, {"input": "5 3\n4 2 0 5 3\n1 2 4 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 8\n3 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 2\n7 0\n1 2 4 9\n10 1\n7 2\n", "output": ["7 0\n0 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 8\n3 0\n5 3\n"]}, {"input": "5 3\n4 1 0 5 3\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n3 0\n5 3\n"]}, {"input": "5 3\n4 4 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 6\n1 2\n1 2 2 1\n1 2\n2 1\n3 1\n1 2\n2 2\n2 2\n", "output": ["2 0\n2 1\n1 0\n2 0\n2 0\n2 0\n"]}, {"input": "2 2\n7 2\n1 2 4 5\n10 1\n5 2\n", "output": ["7 0\n2 0\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n4 1\n5 1\n"]}, {"input": "2 2\n8 0\n1 2 4 3\n10 2\n5 2\n", "output": ["0 0\n0 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 7 7\n1 3 0 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n3 0\n3 2\n"]}, {"input": "5 3\n5 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 2\n7 2\n1 2 4 4\n10 1\n5 2\n", "output": ["7 0\n2 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "2 2\n8 1\n1 2 4 0\n10 2\n5 2\n", "output": ["1 0\n1 0\n"]}, {"input": "5 3\n9 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n6 2\n", "output": ["9 11\n2 0\n5 3\n"]}, {"input": "2 2\n8 1\n1 2 4 0\n9 2\n5 2\n", "output": ["1 0\n1 0\n"]}, {"input": "5 3\n4 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 3\n4 5\n6 2\n", "output": ["4 8\n3 0\n4 7\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 1\n4 1\n6 1\n"]}, {"input": "5 3\n4 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 3\n4 5\n4 2\n", "output": ["4 8\n3 0\n4 7\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n5 1\n8 1\n3 1\n2 2\n1 1\n", "output": ["1 0\n1 0\n1 1\n4 1\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n10 1\n8 1\n5 1\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 0\n3 5 1 1\n10 1\n8 1\n5 1\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 0\n3 5 1 1\n10 1\n8 1\n5 2\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n2 3 1 1\n1 4 2 0\n3 5 1 1\n10 1\n8 1\n5 2\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "5 5\n1 2 3 1 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 1\n5 1\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 7\n1 3 1 8\n2 4 15 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 8\n3 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 2\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 2\n7 1\n1 2 4 5\n10 1\n5 2\n", "output": ["7 0\n1 0\n"]}, {"input": "5 5\n1 2 2 2 2\n1 2 2 8\n1 3 6 3\n1 4 4 5\n1 5 2 1\n4 1\n5 1\n6 1\n8 1\n8 1\n", "output": ["2 5\n2 3\n2 3\n1 0\n1 0\n"]}, {"input": "2 2\n7 1\n1 2 4 9\n12 1\n7 2\n", "output": ["7 0\n1 0\n"]}, {"input": "2 2\n8 0\n1 2 4 4\n10 2\n5 2\n", "output": ["0 0\n0 0\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 7\n1 3 1 8\n2 4 8 4\n2 5 1 0\n1 3\n7 5\n8 2\n", "output": ["5 8\n3 0\n5 4\n"]}, {"input": "5 3\n4 4 0 5 2\n1 2 4 7\n1 3 1 11\n1 4 8 3\n2 5 1 1\n1 3\n14 5\n8 2\n", "output": ["5 11\n2 0\n4 0\n"]}, {"input": "5 3\n5 2 0 5 2\n1 2 4 6\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 3\n7 5\n6 3\n", "output": ["3 8\n3 0\n0 0\n"]}, {"input": "5 3\n9 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 4 3\n4 5 2 1\n1 3\n7 5\n6 2\n", "output": ["9 11\n2 0\n2 0\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n9 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 1\n4 1\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n5 1\n5 1\n5 1\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n10 1\n5 1\n5 1\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "2 1\n4 0\n1 2 4 13\n10 1\n5 2\n", "output": ["4 0\n"]}, {"input": "5 5\n1 2 6 -1 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n8 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n6 1\n6 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 12 3\n2 5 1 1\n1 3\n7 5\n8 3\n", "output": ["3 8\n3 0\n0 0\n"]}, {"input": "5 5\n1 2 3 4 0\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 2\n", "output": ["2 1\n2 1\n3 1\n4 1\n4 1\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 7\n1 3 1 5\n2 4 8 2\n2 5 1 1\n1 3\n3 5\n6 2\n", "output": ["3 7\n3 0\n3 2\n"]}, {"input": "5 5\n1 2 2 2 2\n1 2 2 8\n1 3 6 3\n1 4 4 5\n1 5 4 1\n4 1\n5 1\n6 1\n8 1\n8 1\n", "output": ["2 5\n2 3\n2 3\n1 0\n1 0\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 7 7\n1 3 0 8\n2 4 2 2\n2 5 0 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n3 0\n2 7\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 11\n1 3 1 8\n2 4 8 4\n2 5 1 0\n1 3\n7 5\n8 2\n", "output": ["5 11\n3 0\n5 4\n"]}, {"input": "5 3\n4 4 0 5 2\n1 2 4 7\n1 3 1 11\n1 4 8 3\n2 5 1 1\n1 3\n14 5\n8 1\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "5 3\n5 4 0 5 2\n1 2 4 6\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 0\n1 3\n7 5\n6 3\n", "output": ["3 8\n3 0\n0 0\n"]}, {"input": "5 5\n1 2 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n9 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n2 1\n4 1\n6 1\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 2\n4 1\n3 1\n3 1\n1 1\n", "output": ["2 0\n2 1\n2 1\n2 1\n5 1\n"]}, {"input": "2 1\n4 -1\n1 2 4 13\n10 1\n5 2\n", "output": ["4 0\n"]}, {"input": "5 5\n1 2 3 3 5\n1 2 4 1\n1 3 2 2\n1 4 1 1\n2 5 1 1\n4 1\n4 2\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 0\n2 1\n3 2\n5 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 7 7\n1 3 0 8\n1 4 2 2\n2 5 0 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n3 0\n2 7\n"]}, {"input": "5 3\n5 4 0 5 2\n1 2 6 6\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 1\n4 -1\n1 2 4 13\n10 1\n2 2\n", "output": ["4 0\n"]}, {"input": "5 3\n5 0 0 5 2\n1 2 6 6\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 1\n4 -1\n1 2 4 13\n10 1\n2 3\n", "output": ["4 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 12\n1 3 1 5\n2 4 8 2\n4 5 1 1\n1 3\n3 5\n6 2\n", "output": ["3 12\n3 0\n3 2\n"]}, {"input": "5 3\n4 5 0 5 4\n1 2 4 7\n1 3 1 11\n1 4 8 1\n2 5 1 1\n1 3\n14 5\n8 1\n", "output": ["5 11\n4 0\n5 1\n"]}, {"input": "2 1\n4 -1\n1 2 4 13\n16 1\n2 3\n", "output": ["4 0\n"]}, {"input": "5 3\n2 0 0 6 2\n1 2 6 7\n1 3 1 9\n2 4 8 2\n3 5 1 0\n2 3\n7 5\n6 3\n", "output": ["0 0\n2 0\n0 0\n"]}, {"input": "2 1\n4 -1\n1 2 4 13\n16 1\n0 3\n", "output": ["4 0\n"]}, {"input": "5 3\n2 0 0 6 2\n1 2 6 7\n1 3 1 9\n2 4 8 2\n1 5 1 0\n2 3\n7 5\n6 3\n", "output": ["0 0\n2 0\n0 0\n"]}, {"input": "5 3\n2 2 3 3 3\n1 4 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "2 2\n7 0\n1 2 4 9\n5 1\n5 2\n", "output": ["7 0\n0 0\n"]}, {"input": "5 3\n2 2 3 3 3\n1 2 4 4\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "2 2\n4 0\n1 2 4 6\n10 1\n5 2\n", "output": ["4 0\n0 0\n"]}, {"input": "5 5\n1 2 3 3 5\n1 2 4 1\n1 3 2 1\n2 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 1\n5 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 2\n2 5 1 2\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "5 5\n1 2 3 0 5\n1 2 4 1\n1 3 2 1\n1 4 3 1\n2 5 0 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 1\n3 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 7 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["3 8\n3 0\n3 3\n"]}, {"input": "5 3\n5 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "5 5\n1 0 2 2 2\n1 2 2 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n", "output": ["2 5\n2 3\n2 3\n2 1\n1 0\n"]}, {"input": "2 2\n7 0\n1 2 4 9\n5 1\n7 2\n", "output": ["7 0\n0 0\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 0 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n4 1\n5 1\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 3 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 0 11\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n3 0\n3 2\n"]}, {"input": "5 5\n1 0 6 0 5\n1 2 4 0\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 0\n6 1\n6 1\n"]}, {"input": "2 2\n7 1\n1 2 4 9\n10 2\n7 2\n", "output": ["1 0\n1 0\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 2\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 0\n2 1\n2 1\n4 1\n5 1\n"]}, {"input": "5 5\n1 0 9 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n6 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 0\n9 1\n9 1\n"]}, {"input": "5 3\n4 4 0 5 2\n1 2 6 7\n1 3 1 11\n1 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n4 0\n"]}], "task_id": "codecontest/43", "repair_prompt": ["Omkar is hosting tours of his country, Omkarland! There are n cities in Omkarland, and, rather curiously, there are exactly n-1 bidirectional roads connecting the cities to each other. It is guaranteed that you can reach any city from any other city through the road network.\n\nEvery city has an enjoyment value e. Each road has a capacity c, and the capacity denotes the maximum number of vehicles that can be on it. Additionally, it has an associated toll t. However, the toll system in Omkarland has an interesting quirk: if a vehicle travels on multiple roads on a single journey, they pay only the highest toll of any single road on which they traveled. In other words, they pay max t over all the roads on which they traveled. If a vehicle traverses no roads, they pay 0 toll.\n\nOmkar has decided to host q tour groups. Each tour group consists of v vehicles starting at city x. (Keep in mind that a tour group with v vehicles can travel only on roads with capacity \u2265 v.) Being the tour organizer, Omkar wants his groups to have as much fun as they possibly can, but also must reimburse his groups for the tolls that they have to pay. Thus, for each tour group, Omkar wants to know two things: first, what is the enjoyment value of the city y with maximum enjoyment value that the tour group can reach from their starting city, and second, how much per vehicle will Omkar have to pay to reimburse the entire group for their trip from x to y? (This trip from x to y will always be on the shortest path from x to y.)\n\nIn the case that there are multiple reachable cities with the maximum enjoyment value, Omkar will let his tour group choose which one they want to go to. Therefore, to prepare for all possible scenarios, he wants to know the amount of money per vehicle. That way, he can guarantee that he can reimburse the group regardless of which city they choose. Omkar is looking forward to seeing the smiles on the faces of the tourists as they enjoy all that Omkarland has to offer!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 2 \u22c5 10^5, 1 \u2264 q \u2264 2 \u22c5 10^5), representing the number of cities and the number of groups, respectively.\n\nThe next line contains n integers e_1, e_2, \u2026, e_n (1 \u2264 e_i \u2264 10^9), where e_i represents the enjoyment value for city i.\n\nThe next n-1 lines each contain four integers a, b, c, and t (1 \u2264 a,b \u2264 n, 1 \u2264 c \u2264 10^9, 1 \u2264 t \u2264 10^9), representing an road between city a and city b with capacity c and toll t.\n\nThe next q lines each contain two integers v and x (1 \u2264 v \u2264 10^9, 1 \u2264 x \u2264 n), representing the number of vehicles in the tour group and the starting city, respectively.\n\nOutput\n\nOutput q lines. The i-th line should contain two integers: the highest possible enjoyment value of a city reachable by the i-th tour group, and the amount of money per vehicle Omkar needs to guarantee that he can reimburse the i-th tour group.\n\nExamples\n\nInput\n\n\n5 3\n2 2 3 3 3\n1 2 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n\n\nOutput\n\n\n3 8\n3 0\n3 2\n\n\nInput\n\n\n5 5\n1 2 3 4 5\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n\n\nOutput\n\n\n1 0\n2 1\n3 1\n4 1\n5 1\n\n\nInput\n\n\n5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\nOutput\n\n\n2 8\n2 8\n2 3\n2 1\n1 0\n\nNote\n\nA map of the first sample is shown below. For the nodes, unbolded numbers represent indices and bolded numbers represent enjoyment values. For the edges, unbolded numbers represent capacities and bolded numbers represent tolls.\n\n<image>\n\nFor the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.\n\nFor the second query, a tour group of size 9 starting at city 5 can reach only city 5. Thus, the largest reachable enjoyment value is still 3, and Omkar will pay 0 per vehicle.\n\nFor the third query, a tour group of size 6 starting at city 2 can reach cities 2 and 4. The largest reachable enjoyment value is again 3. If the tour group chooses to go to city 4, Omkar will have to pay 2 per vehicle, which is the maximum.\n\nA map of the second sample is shown below:\n\n<image>\n\nFor the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.\n\nFor the second query, a tour group of size 4 starting at city 1 can reach cities 1 and 2. Thus, their maximum enjoyment value is 2 and Omkar will pay 1 per vehicle.\n\nFor the third query, a tour group of size 3 starting at city 1 can reach cities 1, 2, and 3. Thus, their maximum enjoyment value is 3 and Omkar will pay 1 per vehicle.\n\nFor the fourth query, a tour group of size 2 starting at city 1 can reach cities 1, 2, 3 and 4. Thus, their maximum enjoyment value is 4 and Omkar will pay 1 per vehicle.\n\nFor the fifth query, a tour group of size 1 starting at city 1 can reach cities 1, 2, 3, 4, and 5. Thus, their maximum enjoyment value is 5 and Omkar will pay 1 per vehicle.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start_city in queries:\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            visited[current_city] = True\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    max_enjoyment = max(max_enjoyment, enjoyment_values[neighbor])\n                    max_toll = max(max_toll, toll)\n                    queue.append((neighbor, max(max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    roads = []\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        roads.append((a, b, c, t))\n        index += 4\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        queries.append((v, x))\n        index += 2\n    \n    return n, q, enjoyment_values, roads, queries\n\ndef build_graph(n, roads):\n    graph = defaultdict(list)\n    for a, b, c, t in roads:\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    return graph\n\ndef bfs_max_enjoyment_and_toll(graph, enjoyment_values, start_city, vehicle_count):\n    max_enjoyment = enjoyment_values[start_city]\n    max_toll = 0\n    visited = set()\n    queue = deque([(start_city, 0)])\n    \n    while queue:\n        current_city, current_toll = queue.popleft()\n        visited.add(current_city)\n        \n        max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n        max_toll = max(max_toll, current_toll)\n        \n        for neighbor, capacity, toll in graph[current_city]:\n            if neighbor not in visited and capacity >= vehicle_count:\n                queue.append((neighbor, max(current_toll, toll)))\n    \n    return max_enjoyment, max_toll\n\ndef main():\n    n, q, enjoyment_values, roads, queries = parse_input()\n    graph = build_graph(n, roads)\n    \n    results = []\n    for vehicle_count, start_city in queries:\n        max_enjoyment, max_toll = bfs_max_enjoyment_and_toll(graph, enjoyment_values, start_city, vehicle_count)\n        results.append((max_enjoyment, max_toll\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    def bfs(start, vehicle_count):\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= vehicle_count:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        return max_enjoyment, max_toll\n    \n    results = []\n    for vehicle_count, start_city in queries:\n        max_enjoyment, max_toll = bfs(start_city, vehicle_count)\n        results.append((max_enjoyment, max_toll))\n    \n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Parse number of cities and queries\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Parse enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Parse roads\n    roads = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        roads[a].append((b, c, t))\n        roads[b].append((a, c, t))\n    \n    # Parse queries\n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    # Process each query\n    results = []\n    for v, start_city in queries:\n        # BFS to find reachable cities\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in roads[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of cities and number of groups\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read roads\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    # Read tour groups\n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        tour_groups.append((v, x))\n    \n    # Process each tour group\n    results = []\n    for v, start_city in tour_groups:\n        # BFS to find reachable cities and max enjoyment value\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_max_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nimport heapq\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    def dijkstra(start, vehicle_count):\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        visited = [False] * n\n        pq = [(0, start, enjoyment_values[start])]\n        \n        while pq:\n            toll, city, enjoyment = heapq.heappop(pq)\n            if visited[city]:\n                continue\n            visited[city] = True\n            max_enjoyment = max(max_enjoyment, enjoyment)\n            max_toll = max(max_toll, toll)\n            \n            for neighbor, capacity, road_toll in graph[city]:\n                if not visited[neighbor] and capacity >= vehicle_count:\n                    heapq.heappush(pq, (max(toll, road_toll), neighbor, enjoyment_values[neighbor]))\n        \n        return max_enjoyment, max_toll\n    \n    results = []\n    for vehicle_count, start_city in queries:\n        max_enjoyment, max_toll = dijkstra(start_city, vehicle_count)\n        results.append(f\"{max_enjoyment} {max_toll}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            visited[current] = True\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and capacity >= v:\n                    new_max_toll = max(current_max_toll, toll)\n                    queue.append((neighbor, new_max_toll))\n                    max_enjoyment = max(max_enjoyment, enjoyment_values[neighbor])\n                    max_toll = max(max_toll, new_max_toll)\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    new_max_toll = max(current_max_toll, toll)\n                    queue.append((neighbor, new_max_toll))\n                    \n                    if enjoyment_values[neighbor] > max_enjoyment:\n                        max_enjoyment = enjoyment_values[neighbor]\n                        max_toll = new_max_toll\n                    elif enjoyment_values[neighbor] == max_enjoyment:\n                        max_toll = max(max_toll, new_max_toll)\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start_city in queries:\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            visited[current_city] = True\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    max_enjoyment = max(max_enjoyment, enjoyment_values[neighbor])\n                    max_toll = max(max_toll, toll)\n                    queue.append((neighbor, max(max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of queries, enjoyment values, road connections, and tour group details.\",\n      \"output\": \"Structured data for cities, roads, and tour groups.\"\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads using adjacency lists or another suitable data structure.\",\n      \"output\": \"Graph data structure representing cities and roads with capacities and tolls.\"\n    },\n    {\n      \"description\": \"Implement a function to find all reachable cities from a given starting city for a tour group, considering the road capacity constraints.\",\n      \"output\": \"List of reachable cities for each tour group.\"\n    },\n    {\n      \"description\": \"Determine the maximum enjoyment value among the reachable cities for each tour group.\",\n      \"output\": \"Maximum enjoyment value for each tour group.\"\n    },\n    {\n      \"description\": \"Calculate the maximum toll that needs to be reimbursed for each tour group based on the roads traversed to reach the city with maximum enjoyment.\",\n      \"output\": \"Maximum toll per vehicle for each tour group.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of cities, number of queries, enjoyment values, road connections, and tour group details.\",\n    \"Construct a graph representation of the cities and roads using adjacency lists or another suitable data structure.\",\n    \"For each tour group, perform a graph traversal (e.g., BFS or DFS) from the starting city to find all reachable cities, considering the road capacity constraints.\",\n    \"For each tour group, determine the maximum enjoyment value among the reachable cities.\",\n    \"For each tour group, calculate the maximum toll that needs to be reimbursed based on the roads traversed to reach the city with maximum enjoyment.\",\n    \"Output the maximum enjoyment value and the maximum toll per vehicle for each tour group.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start_city in queries:\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            visited[current_city] = True\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    max_enjoyment = max(max_enjoyment, enjoyment_values[neighbor])\n                    max_toll = max(max_toll, toll)\n                    queue.append((neighbor, max(max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 143)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start_city in queries:\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            visited[current_city] = True\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    max_enjoyment = max(max_enjoyment, enjoyment_values[neighbor])\n                    max_toll = max(max_toll, toll)\n                    queue.append((neighbor, max(max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"name\": \"Parse Input\",\n      \"description\": \"Read and parse the input data to extract the number of cities, number of queries, enjoyment values, road connections, and tour group details.\"\n    },\n    {\n      \"name\": \"Build Graph\",\n      \"description\": \"Construct a graph representation of the cities and roads using adjacency lists, where each node represents a city and each edge represents a road with its capacity and toll.\"\n    },\n    {\n      \"name\": \"Filter Roads by Capacity\",\n      \"description\": \"For each query, filter the roads in the graph to only include those with a capacity greater than or equal to the number of vehicles in the tour group.\"\n    },\n    {\n      \"name\": \"Find Reachable Cities\",\n      \"description\": \"For each query, perform a graph traversal (e.g., BFS or DFS) from the starting city to find all reachable cities using the filtered roads.\"\n    },\n    {\n      \"name\": \"Determine Maximum Enjoyment\",\n      \"description\": \"For each query, among the reachable cities, determine the city with the maximum enjoyment value.\"\n    },\n    {\n      \"name\": \"Calculate Maximum Toll\",\n      \"description\": \"For each query, calculate the maximum toll encountered on the path to the city with the maximum enjoyment value.\"\n    },\n    {\n      \"name\": \"Output Results\",\n      \"description\": \"For each query, output the maximum enjoyment value and the maximum toll per vehicle.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of cities, number of queries, enjoyment values, road connections, and tour group details.\",\n    \"Construct a graph using adjacency lists to represent the cities and roads.\",\n    \"For each query, filter the roads based on the capacity requirement of the tour group.\",\n    \"Perform a graph traversal from the starting city to find all reachable cities using the filtered roads.\",\n    \"Identify the city with the maximum enjoyment value among the reachable cities.\",\n    \"Calculate the maximum toll encountered on the path to the city with the maximum enjoyment value.\",\n    \"Output the maximum enjoyment value and the maximum toll per vehicle for each query.\"\n  ]\n}\n```", "Round_0": {"code": "def parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    roads = []\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        roads.append((a, b, c, t))\n        index += 4\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        queries.append((v, x))\n        index += 2\n    \n    return n, q, enjoyment_values, roads, queries\n\ndef build_graph(n, roads):\n    graph = defaultdict(list)\n    for a, b, c, t in roads:\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    return graph\n\ndef bfs_max_enjoyment_and_toll(graph, enjoyment_values, start_city, vehicle_count):\n    max_enjoyment = enjoyment_values[start_city]\n    max_toll = 0\n    visited = set()\n    queue = deque([(start_city, 0)])\n    \n    while queue:\n        current_city, current_toll = queue.popleft()\n        visited.add(current_city)\n        \n        max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n        max_toll = max(max_toll, current_toll)\n        \n        for neighbor, capacity, toll in graph[current_city]:\n            if neighbor not in visited and capacity >= vehicle_count:\n                queue.append((neighbor, max(current_toll, toll)))\n    \n    return max_enjoyment, max_toll\n\ndef main():\n    n, q, enjoyment_values, roads, queries = parse_input()\n    graph = build_graph(n, roads)\n    \n    results = []\n    for vehicle_count, start_city in queries:\n        max_enjoyment, max_toll = bfs_max_enjoyment_and_toll(graph, enjoyment_values, start_city, vehicle_count)\n        results.append((max_enjoyment, max_toll", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 65)"}, "Round_1": {"code": "def parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    roads = []\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        roads.append((a, b, c, t))\n        index += 4\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        queries.append((v, x))\n        index += 2\n    \n    return n, q, enjoyment_values, roads, queries\n\ndef build_graph(n, roads):\n    graph = defaultdict(list)\n    for a, b, c, t in roads:\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    return graph\n\ndef bfs_max_enjoyment_and_toll(graph, enjoyment_values, start_city, vehicle_count):\n    max_enjoyment = enjoyment_values[start_city]\n    max_toll = 0\n    visited = set()\n    queue = deque([(start_city, 0)])\n    \n    while queue:\n        current_city, current_toll = queue.popleft()\n        visited.add(current_city)\n        \n        max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n        max_toll = max(max_toll, current_toll)\n        \n        for neighbor, capacity, toll in graph[current_city]:\n            if neighbor not in visited and capacity >= vehicle_count:\n                queue.append((neighbor, max(current_toll, toll)))\n    \n    return max_enjoyment, max_toll\n\ndef main():\n    n, q, enjoyment_values, roads, queries = parse_input()\n    graph = build_graph(n, roads)\n    \n    results = []\n    for vehicle_count, start_city in queries:\n        max_enjoyment, max_toll = bfs_max_enjoyment_and_toll(graph, enjoyment_values, start_city, vehicle_count)\n        results.append((max_enjoyment, max_toll"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of queries, enjoyment values, road connections, and tour group details.\",\n      \"output\": \"Structured data containing cities, roads, and queries.\"\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads using adjacency lists or another suitable data structure.\",\n      \"output\": \"Graph data structure representing the cities and roads.\"\n    },\n    {\n      \"description\": \"Implement a function to find all reachable cities from a given starting city for a tour group, considering the road capacity constraints.\",\n      \"output\": \"List of reachable cities for each query.\"\n    },\n    {\n      \"description\": \"Determine the maximum enjoyment value among the reachable cities for each tour group.\",\n      \"output\": \"Maximum enjoyment value for each query.\"\n    },\n    {\n      \"description\": \"Calculate the maximum toll that needs to be reimbursed for the journey to the city with the maximum enjoyment value.\",\n      \"output\": \"Maximum toll per vehicle for each query.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of cities, number of queries, enjoyment values, road connections, and tour group details.\",\n    \"Construct a graph representation of the cities and roads using adjacency lists.\",\n    \"For each query, perform a graph traversal (e.g., BFS or DFS) starting from the given city, considering only roads with sufficient capacity for the tour group.\",\n    \"During the traversal, track the maximum enjoyment value of the cities that can be reached.\",\n    \"For each reachable city, calculate the maximum toll encountered on the path from the starting city.\",\n    \"Output the maximum enjoyment value and the maximum toll per vehicle for each query.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    def bfs(start, vehicle_count):\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= vehicle_count:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        return max_enjoyment, max_toll\n    \n    results = []\n    for vehicle_count, start_city in queries:\n        max_enjoyment, max_toll = bfs(start_city, vehicle_count)\n        results.append((max_enjoyment, max_toll))\n    \n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"name\": \"Parse Input\",\n      \"description\": \"Read and parse the input data to extract the number of cities, number of queries, enjoyment values, road connections, and tour group details.\"\n    },\n    {\n      \"name\": \"Build Graph\",\n      \"description\": \"Construct a graph representation of the cities and roads using adjacency lists, where each node represents a city and each edge represents a road with its capacity and toll.\"\n    },\n    {\n      \"name\": \"Filter Roads by Capacity\",\n      \"description\": \"For each query, filter the roads in the graph to only include those with a capacity greater than or equal to the number of vehicles in the tour group.\"\n    },\n    {\n      \"name\": \"Find Reachable Cities\",\n      \"description\": \"Using a graph traversal algorithm (e.g., BFS or DFS), find all cities that are reachable from the starting city for each query, considering only roads that meet the capacity requirement.\"\n    },\n    {\n      \"name\": \"Determine Maximum Enjoyment\",\n      \"description\": \"For each query, determine the maximum enjoyment value among the reachable cities.\"\n    },\n    {\n      \"name\": \"Calculate Maximum Toll\",\n      \"description\": \"For each query, calculate the maximum toll that would be paid by a tour group traveling from the starting city to any reachable city with the maximum enjoyment value.\"\n    },\n    {\n      \"name\": \"Output Results\",\n      \"description\": \"For each query, output the maximum enjoyment value and the maximum toll per vehicle.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of cities, number of queries, enjoyment values, road connections, and tour group details.\",\n    \"Construct a graph using adjacency lists to represent the cities and roads.\",\n    \"For each query, filter the graph to only include roads with sufficient capacity for the tour group.\",\n    \"Perform a graph traversal from the starting city to find all reachable cities.\",\n    \"Determine the maximum enjoyment value among the reachable cities.\",\n    \"Calculate the maximum toll that would be paid for traveling to any city with the maximum enjoyment value.\",\n    \"Output the results for each query, including the maximum enjoyment value and the maximum toll per vehicle.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 113)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of queries, enjoyment values, road connections, and tour group details.\",\n      \"output\": \"Structured data for cities, roads, and queries.\"\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads using adjacency lists or another suitable data structure.\",\n      \"output\": \"Graph data structure representing cities and roads with capacities and tolls.\"\n    },\n    {\n      \"description\": \"Implement a function to find all reachable cities from a given starting city for a tour group, considering the road capacity constraints.\",\n      \"output\": \"List of reachable cities for each query.\"\n    },\n    {\n      \"description\": \"Determine the city with the maximum enjoyment value from the list of reachable cities for each query.\",\n      \"output\": \"Maximum enjoyment value for each query.\"\n    },\n    {\n      \"description\": \"Calculate the maximum toll that needs to be reimbursed for the journey to the city with the maximum enjoyment value.\",\n      \"output\": \"Maximum toll per vehicle for each query.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of cities, number of queries, enjoyment values, road connections, and tour group details.\",\n    \"Construct a graph representation of the cities and roads using adjacency lists or another suitable data structure.\",\n    \"For each query, perform a graph traversal (e.g., BFS or DFS) starting from the given city, considering only roads with sufficient capacity for the tour group.\",\n    \"Collect all reachable cities and determine the city with the maximum enjoyment value.\",\n    \"For the path to the city with the maximum enjoyment value, calculate the maximum toll that needs to be reimbursed.\",\n    \"Output the maximum enjoyment value and the maximum toll per vehicle for each query.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Parse number of cities and queries\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Parse enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Parse roads\n    roads = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        roads[a].append((b, c, t))\n        roads[b].append((a, c, t))\n    \n    # Parse queries\n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    # Process each query\n    results = []\n    for v, start_city in queries:\n        # BFS to find reachable cities\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in roads[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 146)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Parse number of cities and queries\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Parse enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Parse roads\n    roads = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        roads[a].append((b, c, t))\n        roads[b].append((a, c, t))\n    \n    # Parse queries\n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    # Process each query\n    results = []\n    for v, start_city in queries:\n        # BFS to find reachable cities\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in roads[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input data to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\",\n      \"steps\": [\n        \"Read the first line to get the number of cities (n) and number of groups (q).\",\n        \"Read the second line to get the enjoyment values for each city.\",\n        \"Read the next n-1 lines to get the road connections, capacities, and tolls.\",\n        \"Read the next q lines to get the tour group details (number of vehicles and starting city).\"\n      ]\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads.\",\n      \"steps\": [\n        \"Create a graph data structure where nodes represent cities and edges represent roads.\",\n        \"Store the capacity and toll information for each road in the graph.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum enjoyment value reachable for each tour group.\",\n      \"steps\": [\n        \"For each tour group, perform a graph traversal starting from the given city.\",\n        \"Consider only roads with capacity greater than or equal to the number of vehicles in the tour group.\",\n        \"Track the maximum enjoyment value encountered during the traversal.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum toll per vehicle for each tour group.\",\n      \"steps\": [\n        \"During the graph traversal, keep track of the maximum toll encountered on the path to each reachable city.\",\n        \"For each city with the maximum enjoyment value, determine the maximum toll encountered on the path.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each tour group.\",\n      \"steps\": [\n        \"For each tour group, output the maximum enjoyment value and the maximum toll per vehicle.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information.\",\n    \"Construct a graph representation of the cities and roads.\",\n    \"For each tour group, perform a graph traversal to find reachable cities with maximum enjoyment value.\",\n    \"Calculate the maximum toll per vehicle for the path to each city with maximum enjoyment value.\",\n    \"Output the results for each tour group.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of cities and number of groups\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read roads\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    # Read tour groups\n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        tour_groups.append((v, x))\n    \n    # Process each tour group\n    results = []\n    for v, start_city in tour_groups:\n        # BFS to find reachable cities and max enjoyment value\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_max_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\",\n      \"steps\": [\n        \"Read the first line to get n (number of cities) and q (number of tour groups).\",\n        \"Read the second line to get the enjoyment values for each city.\",\n        \"Read the next n-1 lines to get the road connections, capacities, and tolls.\",\n        \"Read the next q lines to get the number of vehicles and starting city for each tour group.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads.\",\n      \"steps\": [\n        \"Create a graph data structure where nodes represent cities and edges represent roads.\",\n        \"Store the capacity and toll information for each road in the graph.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum enjoyment value reachable for each tour group.\",\n      \"steps\": [\n        \"For each tour group, perform a graph traversal starting from the given city.\",\n        \"Consider only roads with capacity greater than or equal to the number of vehicles in the tour group.\",\n        \"Track the maximum enjoyment value encountered during the traversal.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum toll per vehicle for the shortest path to the city with maximum enjoyment value.\",\n      \"steps\": [\n        \"For each tour group, find the shortest path to each city with maximum enjoyment value.\",\n        \"Determine the maximum toll encountered on the shortest path.\",\n        \"Output the maximum enjoyment value and the maximum toll per vehicle.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract cities, roads, and tour group information.\",\n    \"Construct a graph representation of the cities and roads.\",\n    \"For each tour group, perform a graph traversal to find reachable cities with maximum enjoyment value.\",\n    \"For each reachable city with maximum enjoyment value, calculate the maximum toll per vehicle for the shortest path.\",\n    \"Output the results for each tour group.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nimport heapq\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    def dijkstra(start, vehicle_count):\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        visited = [False] * n\n        pq = [(0, start, enjoyment_values[start])]\n        \n        while pq:\n            toll, city, enjoyment = heapq.heappop(pq)\n            if visited[city]:\n                continue\n            visited[city] = True\n            max_enjoyment = max(max_enjoyment, enjoyment)\n            max_toll = max(max_toll, toll)\n            \n            for neighbor, capacity, road_toll in graph[city]:\n                if not visited[neighbor] and capacity >= vehicle_count:\n                    heapq.heappush(pq, (max(toll, road_toll), neighbor, enjoyment_values[neighbor]))\n        \n        return max_enjoyment, max_toll\n    \n    results = []\n    for vehicle_count, start_city in queries:\n        max_enjoyment, max_toll = dijkstra(start_city, vehicle_count)\n        results.append(f\"{max_enjoyment} {max_toll}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of queries, enjoyment values, roads, and tour group queries.\",\n      \"details\": \"Read and store the input data in appropriate data structures for further processing.\"\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads.\",\n      \"details\": \"Use an adjacency list to represent the cities and roads, storing capacity and toll information for each road.\"\n    },\n    {\n      \"description\": \"Implement a function to find all reachable cities from a given starting city with a given number of vehicles.\",\n      \"details\": \"Use a graph traversal algorithm (e.g., BFS or DFS) to explore the graph, considering only roads with sufficient capacity.\"\n    },\n    {\n      \"description\": \"Determine the maximum enjoyment value among the reachable cities.\",\n      \"details\": \"While traversing the graph, keep track of the maximum enjoyment value encountered.\"\n    },\n    {\n      \"description\": \"Calculate the maximum toll for the path to each reachable city.\",\n      \"details\": \"During the graph traversal, track the maximum toll encountered on the path to each city.\"\n    },\n    {\n      \"description\": \"Process each query to find the maximum enjoyment value and the corresponding toll reimbursement.\",\n      \"details\": \"For each query, use the graph traversal results to determine the maximum enjoyment value and the maximum toll for the path.\"\n    },\n    {\n      \"description\": \"Output the results for each query.\",\n      \"details\": \"Format the results as specified and print them for each query.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract cities, roads, and queries.\",\n    \"Construct a graph using an adjacency list to represent the cities and roads.\",\n    \"For each query, perform a graph traversal from the starting city, considering only roads with sufficient capacity.\",\n    \"During traversal, track the maximum enjoyment value and the maximum toll encountered.\",\n    \"For each query, output the maximum enjoyment value and the maximum toll as the reimbursement cost.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            visited[current] = True\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and capacity >= v:\n                    new_max_toll = max(current_max_toll, toll)\n                    queue.append((neighbor, new_max_toll))\n                    max_enjoyment = max(max_enjoyment, enjoyment_values[neighbor])\n                    max_toll = max(max_toll, new_max_toll)\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"name\": \"Parse Input\",\n      \"description\": \"Read and parse the input data to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\"\n    },\n    {\n      \"name\": \"Build Graph\",\n      \"description\": \"Construct a graph representation of the cities and roads using adjacency lists, where each node represents a city and each edge represents a road with its capacity and toll.\"\n    },\n    {\n      \"name\": \"Filter Roads by Capacity\",\n      \"description\": \"For each query, filter the roads in the graph to only include those with a capacity greater than or equal to the number of vehicles in the tour group.\"\n    },\n    {\n      \"name\": \"Find Reachable Cities\",\n      \"description\": \"Using a graph traversal algorithm (e.g., BFS or DFS), find all cities that are reachable from the starting city for each tour group, considering only roads that meet the capacity requirement.\"\n    },\n    {\n      \"name\": \"Determine Maximum Enjoyment\",\n      \"description\": \"For each tour group, determine the maximum enjoyment value among the reachable cities.\"\n    },\n    {\n      \"name\": \"Calculate Maximum Toll\",\n      \"description\": \"For each tour group, calculate the maximum toll that would be paid per vehicle for the journey to the city with the maximum enjoyment value.\"\n    },\n    {\n      \"name\": \"Output Results\",\n      \"description\": \"For each query, output the maximum enjoyment value and the maximum toll per vehicle.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\",\n    \"Construct a graph using adjacency lists to represent the cities and roads.\",\n    \"For each tour group query, filter the roads to only include those with sufficient capacity for the number of vehicles in the group.\",\n    \"Perform a graph traversal from the starting city to find all reachable cities for the tour group.\",\n    \"Determine the maximum enjoyment value among the reachable cities.\",\n    \"Calculate the maximum toll per vehicle for the journey to the city with the maximum enjoyment value.\",\n    \"Output the results for each query, including the maximum enjoyment value and the maximum toll per vehicle.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of queries, enjoyment values, road connections, and tour group details.\",\n      \"output\": \"Structured data for cities, roads, and queries.\"\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads using adjacency lists or another suitable data structure.\",\n      \"output\": \"Graph data structure representing cities and roads with capacities and tolls.\"\n    },\n    {\n      \"description\": \"Implement a function to find all reachable cities from a given starting city for a tour group, considering the road capacity constraints.\",\n      \"output\": \"List of reachable cities for each query.\"\n    },\n    {\n      \"description\": \"Determine the city with the maximum enjoyment value from the list of reachable cities for each query.\",\n      \"output\": \"Maximum enjoyment value for each query.\"\n    },\n    {\n      \"description\": \"Calculate the maximum toll that needs to be reimbursed for the journey to the city with the maximum enjoyment value.\",\n      \"output\": \"Maximum toll per vehicle for each query.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of cities, number of queries, enjoyment values, road connections, and tour group details.\",\n    \"Construct a graph representation of the cities and roads using adjacency lists or another suitable data structure.\",\n    \"For each query, perform a graph traversal (e.g., BFS or DFS) starting from the given city, considering only roads with sufficient capacity for the tour group.\",\n    \"Collect all reachable cities and determine the city with the maximum enjoyment value.\",\n    \"For the path to the city with the maximum enjoyment value, calculate the maximum toll that needs to be reimbursed.\",\n    \"Output the maximum enjoyment value and the maximum toll per vehicle for each query.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    new_max_toll = max(current_max_toll, toll)\n                    queue.append((neighbor, new_max_toll))\n                    \n                    if enjoyment_values[neighbor] > max_enjoyment:\n                        max_enjoyment = enjoyment_values[neighbor]\n                        max_toll = new_max_toll\n                    elif enjoyment_values[neighbor] == max_enjoyment:\n                        max_toll = max(max_toll, new_max_toll)\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of queries, enjoyment values, road connections, and tour group details.\",\n      \"output\": \"Structured data for cities, roads, and tour groups.\"\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads using adjacency lists or another suitable data structure.\",\n      \"output\": \"Graph data structure representing cities and roads with capacities and tolls.\"\n    },\n    {\n      \"description\": \"Implement a function to find all reachable cities from a given starting city for a tour group, considering the road capacity constraints.\",\n      \"output\": \"List of reachable cities for each tour group.\"\n    },\n    {\n      \"description\": \"Determine the maximum enjoyment value among the reachable cities for each tour group.\",\n      \"output\": \"Maximum enjoyment value for each tour group.\"\n    },\n    {\n      \"description\": \"Calculate the maximum toll that needs to be reimbursed for each tour group based on the roads traversed to reach the city with maximum enjoyment.\",\n      \"output\": \"Maximum toll per vehicle for each tour group.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of cities, number of queries, enjoyment values, road connections, and tour group details.\",\n    \"Construct a graph representation of the cities and roads using adjacency lists or another suitable data structure.\",\n    \"For each tour group, perform a graph traversal (e.g., BFS or DFS) from the starting city to find all reachable cities, considering the road capacity constraints.\",\n    \"For each tour group, determine the maximum enjoyment value among the reachable cities.\",\n    \"For each tour group, calculate the maximum toll that needs to be reimbursed based on the roads traversed to reach the city with maximum enjoyment.\",\n    \"Output the maximum enjoyment value and the maximum toll per vehicle for each tour group.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start_city in queries:\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            visited[current_city] = True\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    max_enjoyment = max(max_enjoyment, enjoyment_values[neighbor])\n                    max_toll = max(max_toll, toll)\n                    queue.append((neighbor, max(max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 143)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start_city in queries:\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            visited[current_city] = True\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    max_enjoyment = max(max_enjoyment, enjoyment_values[neighbor])\n                    max_toll = max(max_toll, toll)\n                    queue.append((neighbor, max(max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 116, "prompt": "Omkar is hosting tours of his country, Omkarland! There are n cities in Omkarland, and, rather curiously, there are exactly n-1 bidirectional roads connecting the cities to each other. It is guaranteed that you can reach any city from any other city through the road network.\n\nEvery city has an enjoyment value e. Each road has a capacity c, and the capacity denotes the maximum number of vehicles that can be on it. Additionally, it has an associated toll t. However, the toll system in Omkarland has an interesting quirk: if a vehicle travels on multiple roads on a single journey, they pay only the highest toll of any single road on which they traveled. In other words, they pay max t over all the roads on which they traveled. If a vehicle traverses no roads, they pay 0 toll.\n\nOmkar has decided to host q tour groups. Each tour group consists of v vehicles starting at city x. (Keep in mind that a tour group with v vehicles can travel only on roads with capacity \u2265 v.) Being the tour organizer, Omkar wants his groups to have as much fun as they possibly can, but also must reimburse his groups for the tolls that they have to pay. Thus, for each tour group, Omkar wants to know two things: first, what is the enjoyment value of the city y with maximum enjoyment value that the tour group can reach from their starting city, and second, how much per vehicle will Omkar have to pay to reimburse the entire group for their trip from x to y? (This trip from x to y will always be on the shortest path from x to y.)\n\nIn the case that there are multiple reachable cities with the maximum enjoyment value, Omkar will let his tour group choose which one they want to go to. Therefore, to prepare for all possible scenarios, he wants to know the amount of money per vehicle. That way, he can guarantee that he can reimburse the group regardless of which city they choose. Omkar is looking forward to seeing the smiles on the faces of the tourists as they enjoy all that Omkarland has to offer!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 2 \u22c5 10^5, 1 \u2264 q \u2264 2 \u22c5 10^5), representing the number of cities and the number of groups, respectively.\n\nThe next line contains n integers e_1, e_2, \u2026, e_n (1 \u2264 e_i \u2264 10^9), where e_i represents the enjoyment value for city i.\n\nThe next n-1 lines each contain four integers a, b, c, and t (1 \u2264 a,b \u2264 n, 1 \u2264 c \u2264 10^9, 1 \u2264 t \u2264 10^9), representing an road between city a and city b with capacity c and toll t.\n\nThe next q lines each contain two integers v and x (1 \u2264 v \u2264 10^9, 1 \u2264 x \u2264 n), representing the number of vehicles in the tour group and the starting city, respectively.\n\nOutput\n\nOutput q lines. The i-th line should contain two integers: the highest possible enjoyment value of a city reachable by the i-th tour group, and the amount of money per vehicle Omkar needs to guarantee that he can reimburse the i-th tour group.\n\nExamples\n\nInput\n\n\n5 3\n2 2 3 3 3\n1 2 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n\n\nOutput\n\n\n3 8\n3 0\n3 2\n\n\nInput\n\n\n5 5\n1 2 3 4 5\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n\n\nOutput\n\n\n1 0\n2 1\n3 1\n4 1\n5 1\n\n\nInput\n\n\n5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\nOutput\n\n\n2 8\n2 8\n2 3\n2 1\n1 0\n\nNote\n\nA map of the first sample is shown below. For the nodes, unbolded numbers represent indices and bolded numbers represent enjoyment values. For the edges, unbolded numbers represent capacities and bolded numbers represent tolls.\n\n<image>\n\nFor the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.\n\nFor the second query, a tour group of size 9 starting at city 5 can reach only city 5. Thus, the largest reachable enjoyment value is still 3, and Omkar will pay 0 per vehicle.\n\nFor the third query, a tour group of size 6 starting at city 2 can reach cities 2 and 4. The largest reachable enjoyment value is again 3. If the tour group chooses to go to city 4, Omkar will have to pay 2 per vehicle, which is the maximum.\n\nA map of the second sample is shown below:\n\n<image>\n\nFor the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.\n\nFor the second query, a tour group of size 4 starting at city 1 can reach cities 1 and 2. Thus, their maximum enjoyment value is 2 and Omkar will pay 1 per vehicle.\n\nFor the third query, a tour group of size 3 starting at city 1 can reach cities 1, 2, and 3. Thus, their maximum enjoyment value is 3 and Omkar will pay 1 per vehicle.\n\nFor the fourth query, a tour group of size 2 starting at city 1 can reach cities 1, 2, 3 and 4. Thus, their maximum enjoyment value is 4 and Omkar will pay 1 per vehicle.\n\nFor the fifth query, a tour group of size 1 starting at city 1 can reach cities 1, 2, 3, 4, and 5. Thus, their maximum enjoyment value is 5 and Omkar will pay 1 per vehicle.", "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 2 \u22c5 10^5, 1 \u2264 q \u2264 2 \u22c5 10^5), representing the number of cities and the number of groups, respectively.\n\nThe next line contains n integers e_1, e_2, \u2026, e_n (1 \u2264 e_i \u2264 10^9), where e_i represents the enjoyment value for city i.\n\nThe next n-1 lines each contain four integers a, b, c, and t (1 \u2264 a,b \u2264 n, 1 \u2264 c \u2264 10^9, 1 \u2264 t \u2264 10^9), representing an road between city a and city b with capacity c and toll t.\n\nThe next q lines each contain two integers v and x (1 \u2264 v \u2264 10^9, 1 \u2264 x \u2264 n), representing the number of vehicles in the tour group and the starting city, respectively.\n\nOutput\n\nOutput q lines. The i-th line should contain two integers: the highest possible enjoyment value of a city reachable by the i-th tour group, and the amount of money per vehicle Omkar needs to guarantee that he can reimburse the i-th tour group.\n\nExamples\n\nInput\n\n\n5 3\n2 2 3 3 3\n1 2 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n\n\nOutput\n\n\n3 8\n3 0\n3 2\n\n\nInput\n\n\n5 5\n1 2 3 4 5\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n\n\nOutput\n\n\n1 0\n2 1\n3 1\n4 1\n5 1\n\n\nInput\n\n\n5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\nOutput\n\n\n2 8\n2 8\n2 3\n2 1\n1 0\n\nNote\n\nA map of the first sample is shown below. For the nodes, unbolded numbers represent indices and bolded numbers represent enjoyment values. For the edges, unbolded numbers represent capacities and bolded numbers represent tolls.\n\n<image>\n\nFor the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.\n\nFor the second query, a tour group of size 9 starting at city 5 can reach only city 5. Thus, the largest reachable enjoyment value is still 3, and Omkar will pay 0 per vehicle.\n\nFor the third query, a tour group of size 6 starting at city 2 can reach cities 2 and 4. The largest reachable enjoyment value is again 3. If the tour group chooses to go to city 4, Omkar will have to pay 2 per vehicle, which is the maximum.\n\nA map of the second sample is shown below:\n\n<image>\n\nFor the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.\n\nFor the second query, a tour group of size 4 starting at city 1 can reach cities 1 and 2. Thus, their maximum enjoyment value is 2 and Omkar will pay 1 per vehicle.\n\nFor the third query, a tour group of size 3 starting at city 1 can reach cities 1, 2, and 3. Thus, their maximum enjoyment value is 3 and Omkar will pay 1 per vehicle.\n\nFor the fourth query, a tour group of size 2 starting at city 1 can reach cities 1, 2, 3 and 4. Thus, their maximum enjoyment value is 4 and Omkar will pay 1 per vehicle.\n\nFor the fifth query, a tour group of size 1 starting at city 1 can reach cities 1, 2, 3, 4, and 5. Thus, their maximum enjoyment value is 5 and Omkar will pay 1 per vehicle.", "mutate_method": "add_1_sentence_at_end", "save_node": true, "parent_index": 92}
