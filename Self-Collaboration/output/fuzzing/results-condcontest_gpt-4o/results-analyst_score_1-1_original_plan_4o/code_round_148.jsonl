{"name": "1591_C. Minimize Distance", "description": "A total of n depots are located on a number line. Depot i lies at the point x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots. You and the n bags are initially at the origin 0. You can carry up to k bags at a time. You must collect the required number of goods from the origin, deliver them to the respective depots, and then return to the origin to collect your next batch of goods.\n\nCalculate the minimum distance you need to cover to deliver all the bags of goods to the depots. You do not have to return to the origin after you have delivered all the bags.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "tags": ["greedy", "math"], "difficulty": 9, "id": 1591, "sample_io": [{"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n7\n3000000000\n"]}], "test_list": [{"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n7\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n23\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["30\n41\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n43\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n43\n25\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n0 1 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["21\n40\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n46\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n50\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n40\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n40\n10\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n41\n7\n3000010100\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["13\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 4 4\n5 3\n2 2 5 3 3\n4 2\n0000000000 1000000000 1000000000 1000000000\n", "output": ["25\n39\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n9\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n23\n1000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n41\n10\n3000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n41\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n43\n27\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n44\n7\n3000000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n23\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n9\n3001000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -15 5 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n44\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 6 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n46\n8\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 3 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n50\n12\n3000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["13\n41\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n51\n7\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -15 6 2 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n44\n11\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000010000\n", "output": ["27\n41\n23\n1000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n41\n13\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n41\n9\n3000100000\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-14 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 7\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n45\n27\n3000010000\n"]}, {"input": "4\n5 1\n0 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n44\n9\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 3 3 6 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["30\n46\n9\n3001000000\n"]}, {"input": "4\n5 1\n1 0 3 4 5\n9 3\n-9 -18 -1 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["21\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["25\n46\n10\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n44\n8\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n50\n8\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 8 3 9 3\n5 3\n1 2 6 3 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n42\n10\n7000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 0 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["13\n37\n7\n3000000000\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 0 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000001000 1000000000 1000000000 1000010000\n", "output": ["13\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n37\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n45\n13\n3000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 8 3 12 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n49\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n57\n27\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 7\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000001000 1000000000 1000010000\n", "output": ["23\n45\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010000000 1000000000\n", "output": ["27\n46\n7\n3010000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 0\n5 1\n2 4 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n27\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 6 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["30\n46\n7\n3001000000\n"]}, {"input": "4\n5 1\n2 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["27\n46\n10\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1010000000\n", "output": ["16\n44\n8\n3010000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n44\n8\n3000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 -1 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["13\n39\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 6 5 9 1 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n53\n7\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 7 0\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["19\n37\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000010 1000000000\n", "output": ["29\n44\n11\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 5\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000010000 1001010000\n", "output": ["25\n41\n9\n3001010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 4\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n43\n13\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n41\n9\n7000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 8 3 12 4\n5 1\n2 0 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n49\n21\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n57\n27\n1000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010010000 1000000000\n", "output": ["27\n46\n7\n3010010000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n46\n7\n3001000000\n"]}, {"input": "4\n5 1\n2 2 3 4 5\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["27\n53\n10\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1010100000\n", "output": ["16\n44\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["11\n44\n8\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n53\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 7 0\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 4 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["19\n37\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1010000000 1000000010 1000000000\n", "output": ["29\n44\n11\n3010000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 2 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n39\n9\n7000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 1 3 12 4\n5 1\n2 0 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n47\n21\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-14 -18 -13 6 2 8 3 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n42\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 8 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n46\n10\n3001000000\n"]}, {"input": "4\n5 1\n2 2 3 4 5\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 0 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["27\n53\n8\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n2 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["11\n44\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 7 3 9 3\n5 3\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n42\n11\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-14 -18 -13 6 2 8 6 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n57\n27\n1010010000\n"]}, {"input": "4\n5 1\n2 2 3 4 7\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 0 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["29\n53\n8\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 0 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1001000000 1000000000 1010100000\n", "output": ["16\n42\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 4\n2 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["11\n44\n6\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 7 3 9 3\n5 2\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n42\n17\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 6\n-14 -18 -13 6 2 8 6 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n34\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n135\n27\n1010010000\n"]}, {"input": "4\n5 1\n2 2 3 5 7\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 0 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["31\n53\n8\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 8 1\n9 3\n-9 -18 -6 6 5 8 3 0 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1001000000 1000000000 1010100000\n", "output": ["20\n42\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -10 -6 6 6 7 3 9 3\n5 2\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n40\n17\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 10\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000010100\n", "output": ["30\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 6\n-14 -18 -13 6 2 8 6 11 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n40\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 10\n9 5\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000010100\n", "output": ["30\n40\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -6 -15 10 5 8 4 0 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["27\n43\n13\n3000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["23\n135\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -6 -15 10 5 8 4 0 4\n5 3\n2 7 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000110000\n", "output": ["27\n43\n13\n1000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["23\n135\n31\n1010010000\n"]}, {"input": "4\n5 1\n0 0 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["19\n135\n31\n1010010000\n"]}, {"input": "4\n5 1\n0 0 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 4 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["19\n115\n31\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 3 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n41\n7\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 7\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n0000000000 1000000000 1000000000 1000000000\n", "output": ["27\n41\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 1\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["18\n41\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 4 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 2 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["27\n41\n7\n3000010000\n"]}, {"input": "4\n5 1\n1 0 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["21\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 4 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n29\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 1\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n43\n25\n7000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n1 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n43\n23\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 12 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n48\n25\n3000010000\n"]}, {"input": "4\n5 1\n0 1 3 4 3\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["18\n40\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 0 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 9 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n48\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["18\n50\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 0\n9 3\n-9 -12 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["14\n40\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 2 6 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["30\n41\n7\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 4 4\n5 3\n2 2 5 6 3\n4 2\n0000000000 1000000000 1000000000 1000000000\n", "output": ["25\n39\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -23 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n49\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 4\n-5 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n42\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 16 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["38\n41\n10\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-14 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000001 1000000000\n", "output": ["25\n44\n9\n3000000001\n"]}, {"input": "4\n5 1\n0 3 3 4 5\n9 3\n-9 -18 -15 6 5 3 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n40\n9\n3000000000\n"]}, {"input": "4\n5 1\n-1 2 3 4 5\n9 3\n-5 -10 -15 9 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n47\n25\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 2 10 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n28\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 0\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["18\n46\n9\n3001000000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -1 6 6 8 3 7 4\n5 5\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n5\n3000000000\n"]}, {"input": "4\n5 1\n1 2 1 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["21\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 0 3 4 1\n9 3\n-9 -18 -15 5 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["14\n44\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 3 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n49\n7\n3000010100\n"]}, {"input": "4\n5 2\n2 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000001000 1000000000 1000000000 1000010000\n", "output": ["15\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n2 2 3 7 5\n9 3\n-5 -10 -15 6 2 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["31\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 0 3 4 9\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n44\n11\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 0000000000 1000110000\n", "output": ["30\n41\n13\n1000110000\n"]}, {"input": "4\n5 1\n1 2 3 2 2\n9 3\n-14 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["17\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 7\n5 1\n2 3 3 0 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n45\n19\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n4 2 3 5 3\n4 3\n1000000000 1000001000 1000000000 1000010000\n", "output": ["23\n43\n29\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 6\n1 2 5 0 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n5\n3000000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 14 8 3 7 0\n5 1\n2 2 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n50\n23\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 0 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["25\n42\n10\n3000000001\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 0 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000001000 1000000000 1001000000 1000010000\n", "output": ["13\n39\n8\n3001000000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -9 6 2 8 3 0 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n32\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 5\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n44\n5\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 2\n-5 -10 -15 6 5 8 3 7 5\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000010000 1000010000\n", "output": ["25\n63\n9\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1001000000 1000000000 1000110000\n", "output": ["30\n45\n13\n3001000000\n"]}, {"input": "4\n5 1\n1 2 6 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000100000 1000000000 1000000000\n", "output": ["30\n41\n9\n3000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 4 8 3 12 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n47\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1010010000\n", "output": ["25\n57\n27\n3010010000\n"]}, {"input": "4\n5 1\n1 3 3 8 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010000000 1000000000\n", "output": ["32\n46\n7\n3010000000\n"]}, {"input": "4\n5 1\n0 2 3 6 5\n9 3\n-5 -10 -12 6 7 8 3 7 0\n5 1\n2 4 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["26\n40\n27\n3000010000\n"]}, {"input": "4\n5 2\n1 2 4 4 5\n9 3\n-5 -10 -15 6 -1 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["15\n39\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 7 0\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 2 3 8 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["19\n37\n12\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 2\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000010 1000000000\n", "output": ["29\n44\n15\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 6\n9 3\n-5 -10 -15 6 5 8 3 7 5\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000010000 1001010000\n", "output": ["26\n41\n9\n3001010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 4\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1010110000\n", "output": ["30\n43\n13\n3010110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 8\n5 3\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n43\n9\n7000100000\n"]}, {"input": "4\n5 1\n1 2 3 7 2\n9 3\n-14 -18 -13 6 5 8 3 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000100000 1000000000 1000000000 1000010000\n", "output": ["25\n57\n27\n1000100000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 1 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010010000 1000000000\n", "output": ["27\n44\n7\n3010010000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 5 3 2\n4 4\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n46\n7\n1001000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -6 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1010100000\n", "output": ["16\n35\n8\n3010100000\n"]}, {"input": "4\n5 2\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["7\n44\n8\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 2\n-5 -10 -25 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n73\n8\n3000010100\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -18 -15 6 5 1 3 12 4\n5 1\n2 0 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n50\n21\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 6\n4 5\n1000000000 1000000000 1000000010 1000010000\n", "output": ["25\n57\n32\n1000010000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -26 6 6 8 3 7 4\n5 3\n1 1 8 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n54\n10\n3001000000\n"]}, {"input": "4\n5 1\n2 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1001000000 1000000000 1010100000\n", "output": ["18\n44\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -14 -6 6 6 7 3 9 3\n5 3\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n44\n11\n7000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["13\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 2 1 8 3 7 4\n5 4\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n37\n9\n7000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 1 3 12 4\n5 1\n1 0 3 5 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n47\n19\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 6\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n57\n32\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000100001 1000000000 1000000000 1000010100\n", "output": ["25\n48\n8\n3000100001\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 1\n-7 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n139\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 0 3 4 1\n9 3\n-9 -10 -6 6 6 7 3 9 3\n5 2\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["14\n40\n17\n7000000010\n"]}, {"input": "4\n5 1\n0 2 3 4 10\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000010100\n", "output": ["28\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 4\n-5 -6 -15 10 5 8 4 0 0\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n35\n13\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 0\n9 6\n-14 -18 -13 6 2 8 6 11 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n40\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 1\n-5 -10 -20 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["25\n140\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 4 10\n9 5\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000000100\n", "output": ["30\n40\n8\n3000000100\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 1\n-2 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["23\n129\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -6 -15 10 5 8 4 0 4\n5 3\n2 7 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000111000\n", "output": ["27\n43\n13\n1000111000\n"]}, {"input": "4\n5 2\n0 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["11\n135\n31\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -4 -15 10 3 8 4 0 4\n5 3\n2 7 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000110000\n", "output": ["27\n41\n13\n1000110000\n"]}, {"input": "4\n5 1\n0 0 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 4 7\n5 1\n4 3 3 5 1\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["19\n115\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 5 4\n5 3\n2 2 5 3 3\n4 2\n1000001000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n9\n3000001000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 3 8 0 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["20\n41\n10\n3000010000\n"]}], "task_id": "codecontest/47", "repair_prompt": ["A total of n depots are located on a number line. Depot i lies at the point x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots. You and the n bags are initially at the origin 0. You can carry up to k bags at a time. You must collect the required number of goods from the origin, deliver them to the respective depots, and then return to the origin to collect your next batch of goods.\n\nCalculate the minimum distance you need to cover to deliver all the bags of goods to the depots. You do not have to return to the origin after you have delivered all the bags. Assume the depots can be located at any point on the number line, including negative coordinates.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = []\n        negative = []\n        \n        # Separate depots into positive and negative\n        for x in depots:\n            if x > 0:\n                positive.append(x)\n            elif x < 0:\n                negative.append(-x)  # Store negative as positive for easier handling\n        \n        # Sort the lists\n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive depots\n        for i in range(0, len(positive), k):\n            total_distance += 2 * positive[i]\n        \n        # Calculate distance for negative depots\n        for i in range(0, len(negative), k):\n            total_distance += 2 * negative[i]\n        \n        # Subtract the farthest point as we don't need to return to origin\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive = []\n        negative = []\n        \n        # Separate positions into positive and negative\n        for x in positions:\n            if x > 0:\n                positive.append(x)\n            elif x < 0:\n                negative.append(-x)  # Store negative positions as positive for easier handling\n        \n        # Sort both lists in descending order\n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        # Function to calculate distance for a list of positions\n        def calculate_distance(coords):\n            distance = 0\n            for i in range(0, len(coords), k):\n                distance += 2 * coords[i]  # Round trip to the farthest point in the batch\n            return distance\n        \n        # Calculate total distance\n        total_distance = calculate_distance(positive) + calculate_distance(negative)\n        \n        # Subtract the farthest point since we don't need to return to origin after last delivery\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = sorted([x for x in depots if x > 0], reverse=True)\n        negative = sorted([x for x in depots if x < 0])\n        \n        def calculate_distance(coords):\n            distance = 0\n            for i in range(0, len(coords), k):\n                distance += 2 * abs(coords[i])\n            return distance\n        \n        positive_distance = calculate_distance(positive)\n        negative_distance = calculate_distance(negative)\n        \n        # The last trip does not require returning to the origin\n        if positive and negative:\n            total_distance = positive_distance + negative_distance - max(abs(positive[0]), abs(negative[0]))\n        elif positive:\n            total_distance = positive_distance - abs(positive[0])\n        elif negative:\n            total_distance = negative_distance - abs(negative[0])\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = sorted([x for x in positions if x > 0], reverse=True)\n        negative_positions = sorted([x for x in positions if x < 0])\n        \n        total_distance = 0\n        \n        # Calculate distance for positive positions\n        for i in range(0, len(positive_positions), k):\n            total_distance += 2 * positive_positions[i]\n        \n        # Calculate distance for negative positions\n        for i in range(0, len(negative_positions), k):\n            total_distance += 2 * abs(negative_positions[i])\n        \n        # Subtract the distance of the farthest depot (either positive or negative)\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], abs(negative_positions[0]))\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= abs(negative_positions[0])\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = sorted([x for x in depots if x > 0], reverse=True)\n        negative = sorted([-x for x in depots if x < 0], reverse=True)\n        \n        def calculate_distance(coords):\n            distance = 0\n            for i in range(0, len(coords), k):\n                distance += 2 * coords[i]\n            return distance\n        \n        total_distance = calculate_distance(positive) + calculate_distance(negative)\n        \n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = sorted([x for x in positions if x > 0], reverse=True)\n        negative_positions = sorted([-x for x in positions if x < 0], reverse=True)\n        \n        def calculate_distance(positions):\n            distance = 0\n            for i in range(0, len(positions), k):\n                distance += 2 * positions[i]\n            return distance\n        \n        positive_distance = calculate_distance(positive_positions)\n        negative_distance = calculate_distance(negative_positions)\n        \n        # Subtract the farthest trip as we don't need to return to origin after last delivery\n        if positive_positions and negative_positions:\n            min_distance = positive_distance + negative_distance - max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            min_distance = positive_distance - positive_positions[0]\n        elif negative_positions:\n            min_distance = negative_distance - negative_positions[0]\n        else:\n            min_distance = 0\n        \n        results.append(min_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = [x for x in positions if x > 0]\n        negative_positions = [-x for x in positions if x < 0]\n        \n        positive_positions.sort(reverse=True)\n        negative_positions.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive positions\n        for i in range(0, len(positive_positions), k):\n            total_distance += 2 * positive_positions[i]\n        \n        # Calculate distance for negative positions\n        for i in range(0, len(negative_positions), k):\n            total_distance += 2 * negative_positions[i]\n        \n        # Subtract the last trip back to origin\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= negative_positions[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        \n        positions = list(map(int, data[index:index + n]))\n        index += n\n        \n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = [x for x in positions if x > 0]\n        negative_positions = [-x for x in positions if x < 0]\n        \n        positive_positions.sort(reverse=True)\n        negative_positions.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive positions\n        for i in range(0, len(positive_positions), k):\n            total_distance += 2 * positive_positions[i]\n        \n        # Calculate distance for negative positions\n        for i in range(0, len(negative_positions), k):\n            total_distance += 2 * negative_positions[i]\n        \n        # Subtract the farthest trip since we don't return to origin after last delivery\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= negative_positions[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        \n        positions = list(map(int, data[index:index + n]))\n        index += n\n        \n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = [x for x in positions if x > 0]\n        negative_positions = [-x for x in positions if x < 0]\n        \n        positive_positions.sort(reverse=True)\n        negative_positions.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive positions\n        for i in range(0, len(positive_positions), k):\n            total_distance += 2 * positive_positions[i]\n        \n        # Calculate distance for negative positions\n        for i in range(0, len(negative_positions), k):\n            total_distance += 2 * negative_positions[i]\n        \n        # Subtract the farthest distance as we don't need to return to origin\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= negative_positions[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = [x for x in positions if x > 0]\n        negative_positions = [-x for x in positions if x < 0]\n        \n        positive_positions.sort(reverse=True)\n        negative_positions.sort(reverse=True)\n        \n        def calculate_distance(positions, k):\n            distance = 0\n            for i in range(0, len(positions), k):\n                distance += 2 * positions[i]\n            if positions:\n                distance -= positions[0]  # Don't return to origin after last delivery\n            return distance\n        \n        total_distance = calculate_distance(positive_positions, k) + calculate_distance(negative_positions, k)\n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = []\n        negative = []\n        \n        # Separate depots into positive and negative\n        for x in depots:\n            if x > 0:\n                positive.append(x)\n            elif x < 0:\n                negative.append(-x)  # Store negative as positive for easier handling\n        \n        # Sort the lists\n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive depots\n        for i in range(0, len(positive), k):\n            total_distance += 2 * positive[i]\n        \n        # Calculate distance for negative depots\n        for i in range(0, len(negative), k):\n            total_distance += 2 * negative[i]\n        \n        # Subtract the farthest point as we don't need to return to origin\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the integers n and k.\",\n        \"Read the list of depot positions, x, which contains n integers.\"\n      ]\n    },\n    {\n      \"description\": \"Separate the depot positions into positive and negative coordinates.\",\n      \"steps\": [\n        \"Iterate through the list of depot positions.\",\n        \"Create two separate lists: one for positive coordinates and one for negative coordinates.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots for each test case.\",\n      \"steps\": [\n        \"Sort the positive coordinates in descending order and the negative coordinates in ascending order.\",\n        \"For each group of k depots, calculate the distance to deliver goods and return to the origin.\",\n        \"For the last trip, do not return to the origin after delivering the goods.\",\n        \"Sum the distances for all trips to get the total minimum distance.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum distance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, separate the depot positions into positive and negative coordinates.\",\n    \"Sort the positive and negative coordinates appropriately.\",\n    \"Calculate the minimum distance required to deliver all goods for each test case.\",\n    \"Output the minimum distance for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = []\n        negative = []\n        \n        # Separate depots into positive and negative\n        for x in depots:\n            if x > 0:\n                positive.append(x)\n            elif x < 0:\n                negative.append(-x)  # Store negative as positive for easier handling\n        \n        # Sort the lists\n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive depots\n        for i in range(0, len(positive), k):\n            total_distance += 2 * positive[i]\n        \n        # Calculate distance for negative depots\n        for i in range(0, len(negative), k):\n            total_distance += 2 * negative[i]\n        \n        # Subtract the farthest point as we don't need to return to origin\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of depots, the maximum number of bags that can be carried at once, and the positions of the depots.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the integers n and k.\",\n        \"Read the list of depot positions.\"\n      ]\n    },\n    {\n      \"description\": \"Separate the depot positions into positive and negative coordinates for each test case.\",\n      \"steps\": [\n        \"Iterate through the list of depot positions.\",\n        \"Separate the positions into two lists: one for positive coordinates and one for negative coordinates.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance required to deliver all bags for each test case.\",\n      \"steps\": [\n        \"Sort the positive and negative coordinate lists in descending order of absolute values.\",\n        \"For each list, calculate the total distance by grouping the coordinates into batches of size k.\",\n        \"For each batch, calculate the round trip distance to the farthest point in the batch, except for the last trip where you do not return to the origin.\",\n        \"Sum the distances for both positive and negative coordinates.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum distance for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum distance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, separate the depot positions into positive and negative coordinates.\",\n    \"Sort the coordinates by absolute value in descending order.\",\n    \"Calculate the minimum distance by grouping coordinates into batches of size k and summing the round trip distances.\",\n    \"Output the minimum distance for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive = []\n        negative = []\n        \n        # Separate positions into positive and negative\n        for x in positions:\n            if x > 0:\n                positive.append(x)\n            elif x < 0:\n                negative.append(-x)  # Store negative positions as positive for easier handling\n        \n        # Sort both lists in descending order\n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        # Function to calculate distance for a list of positions\n        def calculate_distance(coords):\n            distance = 0\n            for i in range(0, len(coords), k):\n                distance += 2 * coords[i]  # Round trip to the farthest point in the batch\n            return distance\n        \n        # Calculate total distance\n        total_distance = calculate_distance(positive) + calculate_distance(negative)\n        \n        # Subtract the farthest point since we don't need to return to origin after last delivery\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 85)"}, "Round_1": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive = []\n        negative = []\n        \n        # Separate positions into positive and negative\n        for x in positions:\n            if x > 0:\n                positive.append(x)\n            elif x < 0:\n                negative.append(-x)  # Store negative positions as positive for easier handling\n        \n        # Sort both lists in descending order\n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        # Function to calculate distance for a list of positions\n        def calculate_distance(coords):\n            distance = 0\n            for i in range(0, len(coords), k):\n                distance += 2 * coords[i]  # Round trip to the farthest point in the batch\n            return distance\n        \n        # Calculate total distance\n        total_distance = calculate_distance(positive) + calculate_distance(negative)\n        \n        # Subtract the farthest point since we don't need to return to origin after last delivery\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"decomposition\": [\n    {\n      \"subproblem\": \"Parse the input data\",\n      \"description\": \"Read the number of test cases, and for each test case, read the values of n, k, and the list of depot positions.\"\n    },\n    {\n      \"subproblem\": \"Separate depot positions into positive and negative coordinates\",\n      \"description\": \"Divide the list of depot positions into two separate lists: one for positive coordinates and one for negative coordinates.\"\n    },\n    {\n      \"subproblem\": \"Calculate the minimum distance for positive coordinates\",\n      \"description\": \"Sort the positive coordinates in descending order and calculate the minimum distance by grouping them into batches of size k, considering the farthest point in each batch.\"\n    },\n    {\n      \"subproblem\": \"Calculate the minimum distance for negative coordinates\",\n      \"description\": \"Sort the negative coordinates in ascending order and calculate the minimum distance by grouping them into batches of size k, considering the farthest point in each batch.\"\n    },\n    {\n      \"subproblem\": \"Combine distances from positive and negative coordinates\",\n      \"description\": \"Sum the distances calculated for positive and negative coordinates to get the total minimum distance for each test case.\"\n    },\n    {\n      \"subproblem\": \"Output the results\",\n      \"description\": \"Print the minimum distance for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data.\",\n    \"For each test case, separate depot positions into positive and negative lists.\",\n    \"Sort the positive coordinates in descending order and calculate the minimum distance by processing in batches of size k.\",\n    \"Sort the negative coordinates in ascending order and calculate the minimum distance by processing in batches of size k.\",\n    \"Sum the distances from positive and negative coordinates to get the total minimum distance for each test case.\",\n    \"Output the minimum distance for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = sorted([x for x in depots if x > 0], reverse=True)\n        negative = sorted([x for x in depots if x < 0])\n        \n        def calculate_distance(coords):\n            distance = 0\n            for i in range(0, len(coords), k):\n                distance += 2 * abs(coords[i])\n            return distance\n        \n        positive_distance = calculate_distance(positive)\n        negative_distance = calculate_distance(negative)\n        \n        # The last trip does not require returning to the origin\n        if positive and negative:\n            total_distance = positive_distance + negative_distance - max(abs(positive[0]), abs(negative[0]))\n        elif positive:\n            total_distance = positive_distance - abs(positive[0])\n        elif negative:\n            total_distance = negative_distance - abs(negative[0])\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the integers n and k.\",\n        \"Read the list of depot positions, x, which contains n integers.\"\n      ]\n    },\n    {\n      \"description\": \"Separate the depot positions into positive and negative coordinates.\",\n      \"steps\": [\n        \"Iterate through the list of depot positions.\",\n        \"Create two separate lists: one for positive positions and one for negative positions.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots with positive coordinates.\",\n      \"steps\": [\n        \"Sort the list of positive positions in descending order.\",\n        \"Group the positions into batches of size k.\",\n        \"For each batch, calculate the distance to the farthest depot in the batch and back to the origin.\",\n        \"Sum the distances for all batches.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots with negative coordinates.\",\n      \"steps\": [\n        \"Sort the list of negative positions in ascending order (more negative to less negative).\",\n        \"Group the positions into batches of size k.\",\n        \"For each batch, calculate the distance to the farthest depot in the batch and back to the origin.\",\n        \"Sum the distances for all batches.\"\n      ]\n    },\n    {\n      \"description\": \"Combine the results from positive and negative coordinates to get the total minimum distance.\",\n      \"steps\": [\n        \"Sum the total distances calculated for positive and negative coordinates.\",\n        \"Subtract the distance of the farthest depot (either positive or negative) from the total, as the final trip does not require returning to the origin.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum distance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, separate depot positions into positive and negative coordinates.\",\n    \"Calculate the minimum distance for positive coordinates by batching and summing distances.\",\n    \"Calculate the minimum distance for negative coordinates by batching and summing distances.\",\n    \"Combine the results from", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = sorted([x for x in positions if x > 0], reverse=True)\n        negative_positions = sorted([x for x in positions if x < 0])\n        \n        total_distance = 0\n        \n        # Calculate distance for positive positions\n        for i in range(0, len(positive_positions), k):\n            total_distance += 2 * positive_positions[i]\n        \n        # Calculate distance for negative positions\n        for i in range(0, len(negative_positions), k):\n            total_distance += 2 * abs(negative_positions[i])\n        \n        # Subtract the distance of the farthest depot (either positive or negative)\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], abs(negative_positions[0]))\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= abs(negative_positions[0])\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the integers n and k.\",\n        \"Read the list of depot positions, x, which contains n integers.\"\n      ]\n    },\n    {\n      \"description\": \"Separate the depot positions into positive and negative coordinates.\",\n      \"steps\": [\n        \"Iterate through the list of depot positions.\",\n        \"Create two separate lists: one for positive coordinates and one for negative coordinates.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots located at positive coordinates.\",\n      \"steps\": [\n        \"Sort the list of positive coordinates in descending order.\",\n        \"Group the coordinates into batches of size k.\",\n        \"For each batch, calculate the distance to the farthest depot in the batch and back to the origin.\",\n        \"Sum the distances for all batches.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots located at negative coordinates.\",\n      \"steps\": [\n        \"Sort the list of negative coordinates in ascending order (more negative first).\",\n        \"Group the coordinates into batches of size k.\",\n        \"For each batch, calculate the distance to the farthest depot in the batch and back to the origin.\",\n        \"Sum the distances for all batches.\"\n      ]\n    },\n    {\n      \"description\": \"Combine the results from positive and negative coordinates to get the total minimum distance.\",\n      \"steps\": [\n        \"Sum the total distances calculated for positive and negative coordinates.\",\n        \"Subtract the distance of the farthest depot (either positive or negative) from the total, as the final trip does not require returning to the origin.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum distance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, separate depot positions into positive and negative coordinates.\",\n    \"Calculate the minimum distance for positive coordinates by batching and summing round-trip distances.\",\n    \"Calculate the minimum distance for negative coordinates similarly.\",\n    \"Combine the distances from positive and negative", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = sorted([x for x in depots if x > 0], reverse=True)\n        negative = sorted([-x for x in depots if x < 0], reverse=True)\n        \n        def calculate_distance(coords):\n            distance = 0\n            for i in range(0, len(coords), k):\n                distance += 2 * coords[i]\n            return distance\n        \n        total_distance = calculate_distance(positive) + calculate_distance(negative)\n        \n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the values of n, k, and the list of depot positions.\",\n      \"steps\": [\n        \"Read the number of test cases t.\",\n        \"For each test case, read the integers n and k.\",\n        \"Read the list of depot positions x_i.\"\n      ]\n    },\n    {\n      \"description\": \"Separate depot positions into positive and negative coordinates for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate through the list of depot positions.\",\n        \"Separate the positions into two lists: one for positive coordinates and one for negative coordinates.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots for each test case.\",\n      \"steps\": [\n        \"For each test case, sort the positive and negative lists in descending order of absolute values.\",\n        \"Calculate the distance for delivering goods to depots with positive coordinates.\",\n        \"Calculate the distance for delivering goods to depots with negative coordinates.\",\n        \"Sum the distances from both positive and negative deliveries.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the delivery sequence to minimize the total travel distance.\",\n      \"steps\": [\n        \"For each test case, determine the optimal delivery sequence by grouping depot positions into batches of size k.\",\n        \"For each batch, calculate the round-trip distance to the farthest depot in the batch.\",\n        \"Sum the round-trip distances for all batches, excluding the final return to the origin after the last delivery.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum distance for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum distance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and depot positions.\",\n    \"Separate depot positions into positive and negative lists.\",\n    \"Sort depot positions by absolute value in descending order.\",\n    \"Calculate the minimum delivery distance for positive and negative depots separately.\",\n    \"Optimize delivery sequence by batching depot positions and calculating round-trip distances.\",\n    \"Output the minimum distance for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = sorted([x for x in positions if x > 0], reverse=True)\n        negative_positions = sorted([-x for x in positions if x < 0], reverse=True)\n        \n        def calculate_distance(positions):\n            distance = 0\n            for i in range(0, len(positions), k):\n                distance += 2 * positions[i]\n            return distance\n        \n        positive_distance = calculate_distance(positive_positions)\n        negative_distance = calculate_distance(negative_positions)\n        \n        # Subtract the farthest trip as we don't need to return to origin after last delivery\n        if positive_positions and negative_positions:\n            min_distance = positive_distance + negative_distance - max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            min_distance = positive_distance - positive_positions[0]\n        elif negative_positions:\n            min_distance = negative_distance - negative_positions[0]\n        else:\n            min_distance = 0\n        \n        results.append(min_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the integers n and k.\",\n        \"Read the list of depot positions, x, which contains n integers.\"\n      ]\n    },\n    {\n      \"description\": \"Separate depot positions into positive and negative coordinates.\",\n      \"steps\": [\n        \"Iterate through the list of depot positions.\",\n        \"Create two separate lists: one for positive positions and one for negative positions.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots.\",\n      \"steps\": [\n        \"For each list (positive and negative), sort the positions in descending order of their absolute values.\",\n        \"Group the positions into batches of size k.\",\n        \"For each batch, calculate the distance to the farthest depot in the batch and back to the origin, except for the last batch where you don't return to the origin.\",\n        \"Sum the distances for all batches.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum distance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, separate depot positions into positive and negative coordinates.\",\n    \"For each set of positions (positive and negative), calculate the minimum distance required to deliver the goods.\",\n    \"Sum the distances from both positive and negative sides to get the total minimum distance for each test case.\",\n    \"Output the total minimum distance for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = [x for x in positions if x > 0]\n        negative_positions = [-x for x in positions if x < 0]\n        \n        positive_positions.sort(reverse=True)\n        negative_positions.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive positions\n        for i in range(0, len(positive_positions), k):\n            total_distance += 2 * positive_positions[i]\n        \n        # Calculate distance for negative positions\n        for i in range(0, len(negative_positions), k):\n            total_distance += 2 * negative_positions[i]\n        \n        # Subtract the last trip back to origin\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= negative_positions[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        \n        positions = list(map(int, data[index:index + n]))\n        index += n\n        \n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the integers n and k.\",\n        \"Read the list of depot positions, x, which contains n integers.\"\n      ]\n    },\n    {\n      \"description\": \"Separate the depot positions into positive and negative coordinates.\",\n      \"steps\": [\n        \"Iterate through the list of depot positions.\",\n        \"Create two separate lists: one for positive positions and one for negative positions.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots for each test case.\",\n      \"steps\": [\n        \"For each list of positions (positive and negative), sort the positions in descending order of their absolute values.\",\n        \"For each sorted list, group the positions into batches of size k.\",\n        \"For each batch, calculate the distance to the farthest depot in the batch and back to the origin, except for the last batch where you do not return to the origin.\",\n        \"Sum the distances for all batches to get the total minimum distance for the test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum distance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, separate the depot positions into positive and negative coordinates.\",\n    \"For each set of positions (positive and negative), sort them by absolute value in descending order.\",\n    \"Group the sorted positions into batches of size k and calculate the travel distance for each batch.\",\n    \"Sum the distances for all batches to get the total minimum distance for each test case.\",\n    \"Output the minimum distance for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = [x for x in positions if x > 0]\n        negative_positions = [-x for x in positions if x < 0]\n        \n        positive_positions.sort(reverse=True)\n        negative_positions.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive positions\n        for i in range(0, len(positive_positions), k):\n            total_distance += 2 * positive_positions[i]\n        \n        # Calculate distance for negative positions\n        for i in range(0, len(negative_positions), k):\n            total_distance += 2 * negative_positions[i]\n        \n        # Subtract the farthest trip since we don't return to origin after last delivery\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= negative_positions[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        \n        positions = list(map(int, data[index:index + n]))\n        index += n\n        \n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the integers n and k.\",\n        \"Read the list of depot positions, x, which contains n integers.\"\n      ]\n    },\n    {\n      \"description\": \"Separate the depot positions into positive and negative coordinates.\",\n      \"steps\": [\n        \"Iterate through the list of depot positions.\",\n        \"Create two separate lists: one for positive positions and one for negative positions.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots located at positive coordinates.\",\n      \"steps\": [\n        \"Sort the list of positive positions in descending order.\",\n        \"Group the positions into batches of size k.\",\n        \"For each batch, calculate the distance to the farthest depot in the batch and back to the origin.\",\n        \"Sum the distances for all batches.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots located at negative coordinates.\",\n      \"steps\": [\n        \"Sort the list of negative positions in ascending order (more negative to less negative).\",\n        \"Group the positions into batches of size k.\",\n        \"For each batch, calculate the distance to the farthest depot in the batch and back to the origin.\",\n        \"Sum the distances for all batches.\"\n      ]\n    },\n    {\n      \"description\": \"Combine the results from positive and negative coordinates to find the total minimum distance.\",\n      \"steps\": [\n        \"Sum the total distances calculated for positive and negative coordinates.\",\n        \"Subtract the distance of the farthest depot (either positive or negative) from the total, as the final trip does not require returning to the origin.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, separate depot positions into positive and negative lists.\",\n    \"Calculate the minimum distance for positive depot positions.\",\n    \"Calculate the minimum distance for negative depot positions.\",\n    \"Combine the distances from positive and negative calculations, adjusting for the final trip, to get the total minimum distance.\",\n    \"Output the minimum distance for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = [x for x in positions if x > 0]\n        negative_positions = [-x for x in positions if x < 0]\n        \n        positive_positions.sort(reverse=True)\n        negative_positions.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive positions\n        for i in range(0, len(positive_positions), k):\n            total_distance += 2 * positive_positions[i]\n        \n        # Calculate distance for negative positions\n        for i in range(0, len(negative_positions), k):\n            total_distance += 2 * negative_positions[i]\n        \n        # Subtract the farthest distance as we don't need to return to origin\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= negative_positions[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the integers n and k.\",\n        \"Read the list of depot positions, x, which contains n integers.\"\n      ]\n    },\n    {\n      \"description\": \"Separate depot positions into positive and negative coordinates.\",\n      \"steps\": [\n        \"Iterate through the list of depot positions.\",\n        \"Create two separate lists: one for positive positions and one for negative positions.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots.\",\n      \"steps\": [\n        \"For each list (positive and negative), sort the positions in descending order of their absolute values.\",\n        \"Group the positions into batches of size k.\",\n        \"For each batch, calculate the distance to the farthest depot in the batch and back to the origin, except for the last batch where you don't return to the origin.\",\n        \"Sum the distances for all batches.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum distance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, separate depot positions into positive and negative coordinates.\",\n    \"For each set of positions (positive and negative), calculate the minimum distance required to deliver the goods.\",\n    \"Sum the distances from both positive and negative sides to get the total minimum distance for each test case.\",\n    \"Output the total minimum distance for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, positions in test_cases:\n        positive_positions = [x for x in positions if x > 0]\n        negative_positions = [-x for x in positions if x < 0]\n        \n        positive_positions.sort(reverse=True)\n        negative_positions.sort(reverse=True)\n        \n        def calculate_distance(positions, k):\n            distance = 0\n            for i in range(0, len(positions), k):\n                distance += 2 * positions[i]\n            if positions:\n                distance -= positions[0]  # Don't return to origin after last delivery\n            return distance\n        \n        total_distance = calculate_distance(positive_positions, k) + calculate_distance(negative_positions, k)\n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        positions = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, positions))\n    \n    results = calculate_minimum_distance(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the integers n and k.\",\n        \"Read the list of depot positions, x, which contains n integers.\"\n      ]\n    },\n    {\n      \"description\": \"Separate the depot positions into positive and negative coordinates.\",\n      \"steps\": [\n        \"Iterate through the list of depot positions.\",\n        \"Create two separate lists: one for positive coordinates and one for negative coordinates.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots for each test case.\",\n      \"steps\": [\n        \"Sort the positive coordinates in descending order and the negative coordinates in ascending order.\",\n        \"For each group of k depots, calculate the distance to deliver goods and return to the origin.\",\n        \"For the last trip, do not return to the origin after delivering the goods.\",\n        \"Sum the distances for all trips to get the total minimum distance.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum distance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, separate the depot positions into positive and negative coordinates.\",\n    \"Sort the positive and negative coordinates appropriately.\",\n    \"Calculate the minimum distance required to deliver all goods for each test case.\",\n    \"Output the minimum distance for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def calculate_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = []\n        negative = []\n        \n        # Separate depots into positive and negative\n        for x in depots:\n            if x > 0:\n                positive.append(x)\n            elif x < 0:\n                negative.append(-x)  # Store negative as positive for easier handling\n        \n        # Sort the lists\n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive depots\n        for i in range(0, len(positive), k):\n            total_distance += 2 * positive[i]\n        \n        # Calculate distance for negative depots\n        for i in range(0, len(negative), k):\n            total_distance += 2 * negative[i]\n        \n        # Subtract the farthest point as we don't need to return to origin\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = calculate_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 148, "prompt": "A total of n depots are located on a number line. Depot i lies at the point x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots. You and the n bags are initially at the origin 0. You can carry up to k bags at a time. You must collect the required number of goods from the origin, deliver them to the respective depots, and then return to the origin to collect your next batch of goods.\n\nCalculate the minimum distance you need to cover to deliver all the bags of goods to the depots. You do not have to return to the origin after you have delivered all the bags. Assume the depots can be located at any point on the number line, including negative coordinates.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 20}
