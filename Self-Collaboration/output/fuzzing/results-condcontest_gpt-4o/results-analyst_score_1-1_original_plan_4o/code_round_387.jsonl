{"name": "1622_E. Math Test", "description": "Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.\n\nIf the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.\n\nFor the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 ", "tags": ["bitmasks", "brute force", "greedy"], "difficulty": 11, "id": 1622, "sample_io": [{"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n", "output": ["3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n"]}], "test_list": [{"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n001\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1 4 2 6 3 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 4 1 6 2 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n13 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n101\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 2\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n000110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n3 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111001\n", "output": ["3 1 2\n3 1 4 2\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 2\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n2 1\n"]}, {"input": "3\n4 3\n5 1 1 0\n111\n000\n101\n010\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["1 2 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000001\n111111\n", "output": ["3 1 2\n2 3 4 1\n4 1 5 2 3 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1101\n0010\n0110\n0111\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 4 1 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n2 4 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n4 1 2 3\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0011\n0110\n0001\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n1 2 4 3\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n001\n110\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["3 2 1\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0010\n0101\n3 2\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n101\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["2 1 3\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n9 1 4 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000100\n111101\n", "output": ["3 1 2\n2 3 4 1\n4 3 5 1 2 6\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n111\n100\n4 4\n6 2 0 10\n1001\n0011\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111011\n", "output": ["3 2 1\n1 2 4 3\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n001\n110\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["2 1 3\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n001\n110\n4 4\n0 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["2 1 3\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 3 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100100\n111101\n", "output": ["3 1 2\n2 3 4 1\n6 2 3 4 1 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n1 2 0 10\n1101\n0010\n0100\n0111\n3 6\n38 3 7\n010110\n100101\n111101\n", "output": ["3 1 2\n3 4 1 2\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n1 1 2 0\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0011\n0111\n0101\n3 1\n20 3 2\n011110\n000101\n111011\n", "output": ["3 1 2\n1 2 4 3\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n000\n4 4\n6 3 0 10\n0001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100100\n111101\n", "output": ["2 1 3\n2 3 4 1\n6 2 3 4 1 5\n"]}, {"input": "3\n4 3\n5 1 3 4\n100\n100\n101\n100\n4 4\n12 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 4\n010110\n010101\n111111\n", "output": ["1 2 3\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n110\n000\n100\n100\n4 4\n6 2 1 11\n1001\n0010\n0110\n0101\n3 6\n38 0 7\n110110\n000101\n111101\n", "output": ["3 2 1\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n000\n4 4\n6 3 0 1\n0001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100100\n111101\n", "output": ["2 1 3\n1 4 3 2\n6 2 3 4 1 5\n"]}, {"input": "3\n4 3\n3 1 3 2\n110\n000\n100\n100\n4 4\n6 2 1 11\n1001\n0010\n0110\n0101\n3 6\n38 0 7\n110110\n000101\n111101\n", "output": ["1 3 2\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n0 1 2 1\n110\n100\n100\n101\n4 4\n2 2 0 13\n1101\n0110\n0110\n0101\n3 6\n38 3 12\n010110\n000001\n111101\n", "output": ["3 1 2\n2 3 4 1\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 2\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 0 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 0 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 3 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n101\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 1 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n11 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 0 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 0\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n13 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 1 0\n111\n000\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0100\n0100\n3 2\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000001\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n1 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0111\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n011\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1101\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n36 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 0 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n1101\n3 1\n34 3 7\n010110\n000101\n110111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0001\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 18\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010010\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 2 2\n101\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 1\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 2\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 10\n0001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n100\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n001\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111101\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n110110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 0\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n110110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n54 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n1 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0110\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111011\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 4\n1001\n0010\n0110\n0101\n3 1\n20 0 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n110\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n4 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n000\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0110\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n100101\n110101\n", "output": ["3 1 2\n2 3 4 1\n3 4 1 6 2 5\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n101\n101\n100\n4 4\n6 2 0 10\n1001\n0000\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0010\n0001\n3 1\n30 1 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n11 1 1 11\n1001\n0010\n1110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 2 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 0 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110110\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n13 1 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 1 0\n011\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n1110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n101\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111011\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n1110\n0101\n3 6\n20 3 15\n000110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n2 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n1 1\n20 3 7\n010110\n010101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n9 1 4 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n011\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n101\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n36 3 7\n010100\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n100\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 18\n1001\n0010\n0110\n0101\n3 6\n20 3 0\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0100\n0101\n3 1\n20 3 7\n010010\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 2 2\n101\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n011110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n010101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n3 1 0 10\n0001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n100\n100\n4 4\n6 2 0 11\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n000\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 17\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n0 1 2 0\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 6\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n110110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n54 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n010\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111001\n", "output": ["3 1 2\n3 1 4 2\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n1 2 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n111\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111011\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n000\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n8 1 0 10\n1001\n0110\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n010\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n100101\n110101\n", "output": ["3 1 2\n2 3 4 1\n3 4 1 6 2 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0010\n0001\n3 1\n30 0 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 2 0 10\n1001\n0010\n0110\n0100\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 0 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n2 1\n66 3 2\n010110\n000101\n110110\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 0\n011\n100\n111\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n1110\n0100\n3 1\n20 0 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 2 4 2\n111\n101\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111011\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 0 1 0\n111\n000\n101\n010\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["1 2 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 17\n1001\n0010\n0110\n0101\n1 1\n20 3 7\n010110\n010101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n011\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1101\n0010\n0100\n0111\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 4 1 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n100\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 0\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0011\n0110\n0001\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n1 2 4 3\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 18\n1001\n0010\n0110\n0101\n3 6\n20 3 0\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n4 1 2 2\n101\n110\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n011110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n100\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n010101\n111111\n", "output": ["1 2 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n100\n100\n4 4\n6 2 1 11\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n4 1 2 2\n111\n100\n000\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 17\n1001\n0110\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n110110\n000100\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n111\n100\n101\n000\n4 4\n4 1 0 10\n1001\n0010\n0110\n0001\n3 1\n54 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n011\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111001\n", "output": ["3 1 2\n3 1 4 2\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n000\n4 4\n12 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n1 0 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n000\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000111\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n000\n4 4\n6 1 0 10\n1101\n0010\n0010\n0101\n3 2\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n8 1 0 10\n1001\n0110\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n101\n101\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["2 1 3\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 1 0\n011\n100\n111\n000\n4 4\n20 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 3 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111110\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 17\n1001\n0010\n0110\n0101\n1 1\n20 3 8\n010110\n010101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}], "task_id": "codecontest/158", "repair_prompt": ["Petya is a math instructor. n of his students has written a test consisting of m questions. It is known for each student which questions they have answered correctly and which they have not.\n\nIf the j-th question is answered correctly by the student, p_j points are awarded (otherwise, he receives 0 points). Moreover, the points for the questions are arranged in such a way that the array p is a permutation of numbers from 1 to m.\n\nPetya knows that the i-th student expects to achieve x_i points in the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to assist Petya in finding a permutation p for which the surprise value of the results is as high as possible. If there are multiple answers, print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we need to maximize the difference\n        # between expected and actual points. A simple strategy is to assign\n        # the highest points to the questions that are least answered correctly.\n        \n        # Count how many students answered each question correctly\n        correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_count[j] += 1\n        \n        # Create a list of question indices sorted by the number of correct answers\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_count[x])\n        \n        # Assign points in descending order to the questions with least correct answers\n        permutation = [0] * m\n        for i in range(m):\n            permutation[question_indices[i]] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        s = []\n        for _ in range(n):\n            s.append(data[index])\n            index += 1\n        \n        # We need to find a permutation of [1, 2, ..., m] that maximizes the surprise value\n        # A simple greedy approach is to assign the highest points to the questions that are most frequently answered correctly\n        question_correct_count = [0] * m\n        \n        for student_answers in s:\n            for j in range(m):\n                if student_answers[j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Create a list of (correct_count, question_index) and sort it by correct_count descending\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda j: -question_correct_count[j])\n        \n        # Assign the highest points to the most frequently correctly answered questions\n        p = [0] * m\n        for rank, question_index in enumerate(question_indices):\n            p[question_index] = m - rank\n        \n        results.append(' '.join(map(str, p)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\n\ndef parse_input():\n    input = sys.stdin.read().strip().split('\\n')\n    t = int(input[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m = map(int, input[index].split())\n        index += 1\n        expected_points = list(map(int, input[index].split()))\n        index += 1\n        answers = []\n        for _ in range(n):\n            answers.append(input[index])\n            index += 1\n        test_cases.append((n, m, expected_points, answers))\n    \n    return test_cases\n\ndef calculate_actual_points(answers, permutation):\n    actual_points = []\n    for answer in answers:\n        points = sum(permutation[j] for j in range(len(answer)) if answer[j] == '1')\n        actual_points.append(points)\n    return actual_points\n\ndef compute_surprise_value(expected_points, actual_points):\n    return sum(abs(expected - actual) for expected, actual in zip(expected_points, actual_points))\n\ndef find_max_surprise_permutation(n, m, expected_points, answers):\n    # To maximize the surprise value, we can assign the highest points to the questions\n    # that are least answered correctly. This is a greedy approach.\n    question_correct_count = [0] * m\n    for answer in answers:\n        for j in range(m):\n            if answer[j] == '1':\n                question_correct_count[j] += 1\n    \n    # Pair each question index with its correct count and sort by correct count\n    question_indices = list(range(m))\n    question_indices.sort(key=lambda x: question_correct_count[x])\n    \n    # Assign points in decreasing order to questions with increasing correct count\n    permutation = [0] * m\n    for i, index in enumerate(question_indices):\n        permutation[index] = m - i\n    \n    return permutation\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, m, expected_points, answers in test_cases:\n        best_permutation = find_max_surprise_permutation(n, m, expected_points, answers)\n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, x, s, p):\n    surprise_value = 0\n    for i in range(n):\n        r_i = sum(p[j] for j in range(m) if s[i][j] == '1')\n        surprise_value += abs(x[i] - r_i)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        s = []\n        for _ in range(n):\n            s.append(data[index])\n            index += 1\n        \n        # Generate the permutation of points\n        p = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in itertools.permutations(p):\n            surprise_value = calculate_surprise_value(n, m, x, s, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(best_permutation)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Create the permutation of points\n        permutation = [0] * m\n        for i, question_index in enumerate(question_indices):\n            permutation[question_index] = i + 1\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        s = []\n        for _ in range(n):\n            s.append(data[index])\n            index += 1\n        \n        # We need to find a permutation of [1, 2, ..., m] that maximizes the surprise value\n        # A simple greedy approach is to assign the highest points to the questions that are most often answered correctly\n        question_correct_count = [0] * m\n        \n        for student_answers in s:\n            for j in range(m):\n                if student_answers[j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Create a list of (correct_count, question_index) and sort it\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda j: question_correct_count[j], reverse=True)\n        \n        # Assign the highest points to the most frequently correctly answered questions\n        p = [0] * m\n        for rank, question_index in enumerate(question_indices):\n            p[question_index] = m - rank\n        \n        results.append(' '.join(map(str, p)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Count how many students answered each question correctly\n        question_correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Create a list of question indices sorted by the number of correct answers\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: question_correct_count[x])\n        \n        # Assign points in descending order to the questions with the least correct answers\n        permutation = [0] * m\n        for i in range(m):\n            permutation[question_indices[i]] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        s = []\n        for _ in range(n):\n            s.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we can simply reverse the permutation\n        # This is because the permutation that maximizes the surprise value is one\n        # that maximizes the difference between expected and actual points.\n        # Reversing the permutation will often achieve this.\n        p = list(range(1, m + 1))\n        p.reverse()\n        \n        results.append(' '.join(map(str, p)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        correctness_matrix = []\n        for _ in range(n):\n            correctness_matrix.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we can simply reverse the permutation\n        # This is because the surprise value is maximized when the actual points\n        # are as far as possible from the expected points.\n        permutation = list(range(1, m + 1))\n        permutation.reverse()\n        \n        results.append(\" \".join(map(str, permutation)))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we need to maximize the difference\n        # between expected and actual points. A simple strategy is to assign\n        # the highest points to the questions that are least answered correctly.\n        \n        # Count how many students answered each question correctly\n        correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_count[j] += 1\n        \n        # Create a list of question indices sorted by the number of correct answers\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_count[x])\n        \n        # Assign points in descending order to the questions with least correct answers\n        permutation = [0] * m\n        for i in range(m):\n            permutation[question_indices[i]] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"output\": \"A function that computes the actual points for each student based on a given permutation of question points.\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of absolute differences between expected and actual points for all students.\",\n      \"output\": \"A permutation of question points that maximizes the surprise value.\"\n    },\n    {\n      \"description\": \"Output the permutation of question points for each test case.\",\n      \"output\": \"Formatted output of the permutation for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a permutation of question points as a list of integers from 1 to m.\",\n    \"For each permutation of question points, calculate the actual points each student would receive and compute the surprise value.\",\n    \"Iterate over possible permutations of question points to find the one that maximizes the surprise value.\",\n    \"Store the permutation that results in the maximum surprise value for each test case.\",\n    \"Output the stored permutation for each test case in the required format.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we need to maximize the difference\n        # between expected and actual points. A simple strategy is to assign\n        # the highest points to the questions that are least answered correctly.\n        \n        # Count how many students answered each question correctly\n        correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_count[j] += 1\n        \n        # Create a list of question indices sorted by the number of correct answers\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_count[x])\n        \n        # Assign points in descending order to the questions with least correct answers\n        permutation = [0] * m\n        for i in range(m):\n            permutation[question_indices[i]] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points, and answers for each student.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers for each student as binary strings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student has achieved based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the total points by summing the points for correctly answered questions according to a permutation.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value.\",\n      \"steps\": [\n        \"Generate all possible permutations of points from 1 to m.\",\n        \"For each permutation, calculate the surprise value as the sum of absolute differences between expected and actual points for all students.\",\n        \"Select the permutation that results in the highest surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, iterate over all permutations of points from 1 to m.\",\n    \"Calculate the actual points for each student based on their answers and the current permutation.\",\n    \"Compute the surprise value for the current permutation.\",\n    \"Track the permutation with the highest surprise value.\",\n    \"Output the permutation with the highest surprise value for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 143)"}, "Round_1": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Structured data containing test cases with n, m, x_i, and s_i\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"input\": \"Structured data for a single test case\",\n      \"output\": \"List of actual points r_i for each student\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of absolute differences between expected and actual points for all students.\",\n      \"input\": \"List of expected points x_i and list of actual points r_i\",\n      \"output\": \"Permutation of question points p that maximizes the surprise value\"\n    },\n    {\n      \"description\": \"Output the permutation for each test case in the required format.\",\n      \"input\": \"Permutation of question points for each test case\",\n      \"output\": \"Formatted output string\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a permutation of question points from 1 to m.\",\n    \"Calculate the actual points each student would get for the current permutation.\",\n    \"Iterate over possible permutations of question points to find the one that maximizes the surprise value.\",\n    \"Store the permutation that gives the maximum surprise value for each test case.\",\n    \"Output the stored permutations in the required format.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        s = []\n        for _ in range(n):\n            s.append(data[index])\n            index += 1\n        \n        # We need to find a permutation of [1, 2, ..., m] that maximizes the surprise value\n        # A simple greedy approach is to assign the highest points to the questions that are most frequently answered correctly\n        question_correct_count = [0] * m\n        \n        for student_answers in s:\n            for j in range(m):\n                if student_answers[j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Create a list of (correct_count, question_index) and sort it by correct_count descending\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda j: -question_correct_count[j])\n        \n        # Assign the highest points to the most frequently correctly answered questions\n        p = [0] * m\n        for rank, question_index in enumerate(question_indices):\n            p[question_index] = m - rank\n        \n        results.append(' '.join(map(str, p)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: main() takes 0 positional arguments but 1 was given"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        s = []\n        for _ in range(n):\n            s.append(data[index])\n            index += 1\n        \n        # We need to find a permutation of [1, 2, ..., m] that maximizes the surprise value\n        # A simple greedy approach is to assign the highest points to the questions that are most frequently answered correctly\n        question_correct_count = [0] * m\n        \n        for student_answers in s:\n            for j in range(m):\n                if student_answers[j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Create a list of (correct_count, question_index) and sort it by correct_count descending\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda j: -question_correct_count[j])\n        \n        # Assign the highest points to the most frequently correctly answered questions\n        p = [0] * m\n        for rank, question_index in enumerate(question_indices):\n            p[question_index] = m - rank\n        \n        results.append(' '.join(map(str, p)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Structured data containing test cases with students, questions, expected points, and answers\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"input\": \"Structured data for a single test case\",\n      \"output\": \"List of actual points for each student based on a permutation of question points\"\n    },\n    {\n      \"description\": \"Compute the surprise value for a given permutation of question points by calculating the sum of absolute differences between expected and actual points for all students.\",\n      \"input\": \"Expected points, actual points for each student\",\n      \"output\": \"Surprise value for the permutation\"\n    },\n    {\n      \"description\": \"Generate permutations of question points and evaluate the surprise value for each permutation to find the permutation with the maximum surprise value.\",\n      \"input\": \"Number of questions (m)\",\n      \"output\": \"Permutation of question points that maximizes the surprise value\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a permutation of question points as a list of integers from 1 to m.\",\n    \"For each permutation of question points, calculate the actual points each student would receive.\",\n    \"Compute the surprise value for the current permutation by summing the absolute differences between expected and actual points for all students.\",\n    \"Track the permutation that results in the maximum surprise value.\",\n    \"Output the permutation with the maximum surprise value for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nimport itertools\n\ndef parse_input():\n    input = sys.stdin.read().strip().split('\\n')\n    t = int(input[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m = map(int, input[index].split())\n        index += 1\n        expected_points = list(map(int, input[index].split()))\n        index += 1\n        answers = []\n        for _ in range(n):\n            answers.append(input[index])\n            index += 1\n        test_cases.append((n, m, expected_points, answers))\n    \n    return test_cases\n\ndef calculate_actual_points(answers, permutation):\n    actual_points = []\n    for answer in answers:\n        points = sum(permutation[j] for j in range(len(answer)) if answer[j] == '1')\n        actual_points.append(points)\n    return actual_points\n\ndef compute_surprise_value(expected_points, actual_points):\n    return sum(abs(expected - actual) for expected, actual in zip(expected_points, actual_points))\n\ndef find_max_surprise_permutation(n, m, expected_points, answers):\n    max_surprise_value = -1\n    best_permutation = None\n    base_permutation = list(range(1, m + 1))\n    \n    # Generate permutations and evaluate surprise value\n    for permutation in itertools.permutations(base_permutation):\n        actual_points = calculate_actual_points(answers, permutation)\n        surprise_value = compute_surprise_value(expected_points, actual_points)\n        \n        if surprise_value > max_surprise_value:\n            max_surprise_value = surprise_value\n            best_permutation = permutation\n    \n    return best_permutation\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, m, expected_points, answers in test_cases:\n        best_permutation = find_max_surprise_permutation(n, m, expected_points, answers)\n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 63)"}, "Round_1": {"code": "import sys\n\ndef parse_input():\n    input = sys.stdin.read().strip().split('\\n')\n    t = int(input[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m = map(int, input[index].split())\n        index += 1\n        expected_points = list(map(int, input[index].split()))\n        index += 1\n        answers = []\n        for _ in range(n):\n            answers.append(input[index])\n            index += 1\n        test_cases.append((n, m, expected_points, answers))\n    \n    return test_cases\n\ndef calculate_actual_points(answers, permutation):\n    actual_points = []\n    for answer in answers:\n        points = sum(permutation[j] for j in range(len(answer)) if answer[j] == '1')\n        actual_points.append(points)\n    return actual_points\n\ndef compute_surprise_value(expected_points, actual_points):\n    return sum(abs(expected - actual) for expected, actual in zip(expected_points, actual_points))\n\ndef find_max_surprise_permutation(n, m, expected_points, answers):\n    # To maximize the surprise value, we can assign the highest points to the questions\n    # that are least answered correctly. This is a greedy approach.\n    question_correct_count = [0] * m\n    for answer in answers:\n        for j in range(m):\n            if answer[j] == '1':\n                question_correct_count[j] += 1\n    \n    # Pair each question index with its correct count and sort by correct count\n    question_indices = list(range(m))\n    question_indices.sort(key=lambda x: question_correct_count[x])\n    \n    # Assign points in decreasing order to questions with increasing correct count\n    permutation = [0] * m\n    for i, index in enumerate(question_indices):\n        permutation[index] = m - i\n    \n    return permutation\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, m, expected_points, answers in test_cases:\n        best_permutation = find_max_surprise_permutation(n, m, expected_points, answers)\n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points, and the answers matrix for each test case.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n and m representing the number of students and questions.\",\n        \"Read the list of expected points x for each student.\",\n        \"Read the matrix of answers s, where each row corresponds to a student's answers.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student has achieved based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the total points r_i by summing the points for correctly answered questions according to a permutation p.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points p that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"For each test case, generate permutations of the array p (which is a permutation of numbers from 1 to m).\",\n        \"Calculate the surprise value for each permutation using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Select the permutation that results in the highest surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation p for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation p that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, iterate over possible permutations of the points array.\",\n    \"Calculate the achieved points for each student and the corresponding surprise value for each permutation.\",\n    \"Select and output the permutation that maximizes the surprise value for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, x, s, p):\n    surprise_value = 0\n    for i in range(n):\n        r_i = sum(p[j] for j in range(m) if s[i][j] == '1')\n        surprise_value += abs(x[i] - r_i)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        s = []\n        for _ in range(n):\n            s.append(data[index])\n            index += 1\n        \n        # Generate the permutation of points\n        p = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in itertools.permutations(p):\n            surprise_value = calculate_surprise_value(n, m, x, s, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(best_permutation)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: calculate_surprise_value() missing 5 required positional arguments: 'n', 'm', 'x', 's', and 'p'"}, "Round_1": {"code": "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, x, s, p):\n    surprise_value = 0\n    for i in range(n):\n        r_i = sum(p[j] for j in range(m) if s[i][j] == '1')\n        surprise_value += abs(x[i] - r_i)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        s = []\n        for _ in range(n):\n            s.append(data[index])\n            index += 1\n        \n        # Generate the permutation of points\n        p = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in itertools.permutations(p):\n            surprise_value = calculate_surprise_value(n, m, x, s, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(best_permutation)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"output\": \"A function that computes the actual points for each student based on a permutation of question points.\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of absolute differences between expected and actual points for all students.\",\n      \"output\": \"A permutation of question points that maximizes the surprise value.\"\n    },\n    {\n      \"description\": \"Output the permutation of question points for each test case.\",\n      \"output\": \"Formatted output of the permutation for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a permutation of question points as a list of integers from 1 to m.\",\n    \"For each permutation of question points, calculate the actual points for each student and compute the surprise value.\",\n    \"Iterate over possible permutations to find the one that maximizes the surprise value.\",\n    \"Store the permutation that results in the maximum surprise value for each test case.\",\n    \"Output the stored permutation for each test case in the required format.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Create the permutation of points\n        permutation = [0] * m\n        for i, question_index in enumerate(question_indices):\n            permutation[question_index] = i + 1\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 95)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Create the permutation of points\n        permutation = [0] * m\n        for i, question_index in enumerate(question_indices):\n            permutation[question_index] = i + 1\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Structured data containing test cases with n, m, x_i, and s_i\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points r_i for each student based on their answers and a given permutation of points.\",\n      \"input\": \"Student answers and a permutation of points\",\n      \"output\": \"Actual points r_i for each student\"\n    },\n    {\n      \"description\": \"Compute the surprise value for a given permutation of points by calculating the sum of absolute differences between expected points x_i and actual points r_i for all students.\",\n      \"input\": \"Expected points x_i and actual points r_i\",\n      \"output\": \"Surprise value for the permutation\"\n    },\n    {\n      \"description\": \"Generate permutations of points and evaluate the surprise value for each permutation to find the permutation that maximizes the surprise value.\",\n      \"input\": \"Number of questions m\",\n      \"output\": \"Permutation of points that maximizes the surprise value\"\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case that results in the maximum surprise value.\",\n      \"input\": \"Permutation of points for each test case\",\n      \"output\": \"Formatted output for each test case\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a permutation of points from 1 to m.\",\n    \"Calculate the actual points r_i for each student using the current permutation.\",\n    \"Compute the surprise value for the current permutation.\",\n    \"Iterate over possible permutations of points to find the one that maximizes the surprise value.\",\n    \"Store the permutation that results in the maximum surprise value for each test case.\",\n    \"Output the stored permutation for each test case in the required format.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        s = []\n        for _ in range(n):\n            s.append(data[index])\n            index += 1\n        \n        # We need to find a permutation of [1, 2, ..., m] that maximizes the surprise value\n        # A simple greedy approach is to assign the highest points to the questions that are most often answered correctly\n        question_correct_count = [0] * m\n        \n        for student_answers in s:\n            for j in range(m):\n                if student_answers[j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Create a list of (correct_count, question_index) and sort it\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda j: question_correct_count[j], reverse=True)\n        \n        # Assign the highest points to the most frequently correctly answered questions\n        p = [0] * m\n        for rank, question_index in enumerate(question_indices):\n            p[question_index] = m - rank\n        \n        results.append(' '.join(map(str, p)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 98)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        s = []\n        for _ in range(n):\n            s.append(data[index])\n            index += 1\n        \n        # We need to find a permutation of [1, 2, ..., m] that maximizes the surprise value\n        # A simple greedy approach is to assign the highest points to the questions that are most often answered correctly\n        question_correct_count = [0] * m\n        \n        for student_answers in s:\n            for j in range(m):\n                if student_answers[j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Create a list of (correct_count, question_index) and sort it\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda j: question_correct_count[j], reverse=True)\n        \n        # Assign the highest points to the most frequently correctly answered questions\n        p = [0] * m\n        for rank, question_index in enumerate(question_indices):\n            p[question_index] = m - rank\n        \n        results.append(' '.join(map(str, p)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"output\": \"A function that computes the actual points for each student based on a given permutation of question points.\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of absolute differences between expected and actual points for all students.\",\n      \"output\": \"A permutation of question points that maximizes the surprise value.\"\n    },\n    {\n      \"description\": \"Output the permutation of question points for each test case.\",\n      \"output\": \"Formatted output of the permutation for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a permutation of question points as a list of integers from 1 to m.\",\n    \"For each permutation, calculate the actual points for each student and compute the surprise value.\",\n    \"Iterate over possible permutations to find the one that maximizes the surprise value.\",\n    \"Store the permutation that results in the maximum surprise value for each test case.\",\n    \"Output the stored permutation for each test case in the required format.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we need to maximize the difference\n        # between expected and actual points. A simple way to do this is to\n        # assign the highest points to the questions that are least answered.\n        \n        # Count how many students answered each question correctly\n        question_correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Create a list of question indices sorted by the number of correct answers\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: question_correct_count[x])\n        \n        # Assign points in descending order to the questions with the least correct answers\n        permutation = [0] * m\n        for i in range(m):\n            permutation[question_indices[i]] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 142)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Count how many students answered each question correctly\n        question_correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Create a list of question indices sorted by the number of correct answers\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: question_correct_count[x])\n        \n        # Assign points in descending order to the questions with the least correct answers\n        permutation = [0] * m\n        for i in range(m):\n            permutation[question_indices[i]] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Structured data containing test cases with n, m, x_i, and s_i\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points r_i for each student based on their answers and a given permutation of points.\",\n      \"input\": \"Structured data for a single test case\",\n      \"output\": \"List of actual points r_i for each student\"\n    },\n    {\n      \"description\": \"Determine a permutation of points p that maximizes the surprise value, which is the sum of absolute differences between expected and actual points for all students.\",\n      \"input\": \"Expected points x_i and actual points r_i for each student\",\n      \"output\": \"Permutation of points p that maximizes the surprise value\"\n    },\n    {\n      \"description\": \"Output the permutation p for each test case.\",\n      \"input\": \"Permutation p for each test case\",\n      \"output\": \"Formatted output for all test cases\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a permutation of points from 1 to m.\",\n    \"Calculate the actual points r_i for each student using the current permutation.\",\n    \"Iterate over possible permutations of points to find the one that maximizes the surprise value.\",\n    \"Store the permutation that results in the maximum surprise value for each test case.\",\n    \"Output the stored permutation for each test case in the required format.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        s = []\n        for _ in range(n):\n            s.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we can simply reverse the permutation\n        # This is because the permutation that maximizes the surprise value is one\n        # that maximizes the difference between expected and actual points.\n        # Reversing the permutation will often achieve this.\n        p = list(range(1, m + 1))\n        p.reverse()\n        \n        results.append(' '.join(map(str, p)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the correctness matrix for each student.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Structured data containing test cases with n, m, x_i, and s_i for each test case\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student received based on the correctness matrix and a given permutation of points.\",\n      \"input\": \"Correctness matrix and a permutation of points\",\n      \"output\": \"Actual points received by each student\"\n    },\n    {\n      \"description\": \"Calculate the surprise value for a given permutation of points by computing the sum of absolute differences between expected and actual points for all students.\",\n      \"input\": \"Expected points, actual points\",\n      \"output\": \"Surprise value\"\n    },\n    {\n      \"description\": \"Generate permutations of points and evaluate the surprise value for each permutation to find the permutation that maximizes the surprise value.\",\n      \"input\": \"Number of questions (m)\",\n      \"output\": \"Permutation of points that maximizes the surprise value\"\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"input\": \"Permutation of points for each test case\",\n      \"output\": \"Formatted output for each test case\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a permutation of points from 1 to m.\",\n    \"Calculate the actual points for each student using the correctness matrix and the current permutation.\",\n    \"Compute the surprise value for the current permutation by summing the absolute differences between expected and actual points.\",\n    \"Iterate over possible permutations of points to find the one that maximizes the surprise value.\",\n    \"Store the permutation that results in the maximum surprise value for each test case.\",\n    \"Output the stored permutation for each test case in the required format.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        correctness_matrix = []\n        for _ in range(n):\n            correctness_matrix.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we can simply reverse the permutation\n        # This is because the surprise value is maximized when the actual points\n        # are as far as possible from the expected points.\n        permutation = list(range(1, m + 1))\n        permutation.reverse()\n        \n        results.append(\" \".join(map(str, permutation)))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"output\": \"A function that computes the actual points for each student based on a given permutation of question points.\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of absolute differences between expected and actual points for all students.\",\n      \"output\": \"A permutation of question points that maximizes the surprise value.\"\n    },\n    {\n      \"description\": \"Output the permutation of question points for each test case.\",\n      \"output\": \"Formatted output of the permutation for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a permutation of question points as a list of integers from 1 to m.\",\n    \"For each permutation of question points, calculate the actual points each student would receive and compute the surprise value.\",\n    \"Iterate over possible permutations of question points to find the one that maximizes the surprise value.\",\n    \"Store the permutation that results in the maximum surprise value for each test case.\",\n    \"Output the stored permutation for each test case in the required format.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we need to maximize the difference\n        # between expected and actual points. A simple strategy is to assign\n        # the highest points to the questions that are least answered correctly.\n        \n        # Count how many students answered each question correctly\n        correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_count[j] += 1\n        \n        # Create a list of question indices sorted by the number of correct answers\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_count[x])\n        \n        # Assign points in descending order to the questions with least correct answers\n        permutation = [0] * m\n        for i in range(m):\n            permutation[question_indices[i]] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, true, false, false, false, false, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 387, "prompt": "Petya is a math instructor. n of his students has written a test consisting of m questions. It is known for each student which questions they have answered correctly and which they have not.\n\nIf the j-th question is answered correctly by the student, p_j points are awarded (otherwise, he receives 0 points). Moreover, the points for the questions are arranged in such a way that the array p is a permutation of numbers from 1 to m.\n\nPetya knows that the i-th student expects to achieve x_i points in the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to assist Petya in finding a permutation p for which the surprise value of the results is as high as possible. If there are multiple answers, print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 ", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 ", "mutate_method": "rephrase_one", "save_node": true, "parent_index": 115}
