{"name": "1591_B. Array Eversion", "description": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "tags": ["greedy"], "difficulty": 8, "id": 1591, "sample_io": [{"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}], "test_list": [{"input": "2\n1\n998244353\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 1 1\n", "output": ["1\n3\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 1\n", "output": ["0\n2\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 8 2\n2\n1 1 1 1\n", "output": ["1\n1\n0\n"]}, {"input": "3\n5\n2 8 1 4 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["2\n2\n0\n"]}, {"input": "3\n5\n2 1 1 5 6\n5\n5 3 4 4 1\n2\n0 1 1 1\n", "output": ["0\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n802364611\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 4 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n4 2 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 3 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 1 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n4 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 3 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n68829976\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 3 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 2 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 3 0 2\n", "output": ["0\n2\n"]}, {"input": "2\n1\n998244353\n4\n1 1 0 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 2 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 0 1\n", "output": ["1\n3\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n56749180\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1528037704\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n0 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n37862951\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 4 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n134212618\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n13173955\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n314070686\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n802364611\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n4 1 4 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 1 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 1 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n7 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 3 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n41454457\n4\n4 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 0 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n4 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n176445854\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n381715760\n4\n0 2 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 4\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 4 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n993551853\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n2 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1981447801\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 2 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n3 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 6 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 5 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 0 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 7 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n134212618\n4\n4 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n626625781\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n6643808\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 6 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 0 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 4 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 1 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 7 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n316067198\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 2\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n993551853\n4\n3 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1258355607\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1961051652\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 5 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n75994590\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 0 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n533265820\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n627592454\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n4 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 4 6 6\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n1 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 5 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n134212618\n4\n1 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n7874846\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n3\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 12 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n7680692\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n3713787\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n316067198\n4\n-1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n711911604\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n39720822\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 0 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1258355607\n4\n6 0 2 4\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n6 1 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 0 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n112473576\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 0 3\n", "output": ["0\n0\n"]}], "task_id": "codecontest/46", "repair_prompt": ["You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions. Consider edge cases where no elements need to be partitioned or when all elements belong to one part.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [num for num in a if num <= x]\n    right = [num for num in a if num > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [num for num in a if num <= x]\n    right = [num for num in a if num > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if all(a[i] <= a[i + 1] for i in range(n - 1)) or len(set(a)) == 1:\n            results.append(0)\n        else:\n            results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [num for num in a if num <= x]\n    right = [num for num in a if num > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index].strip())\n        index += 1\n        a = list(map(int, data[index].strip().split()))\n        index += 1\n        \n        if all(a[i] <= a[i + 1] for i in range(n - 1)):\n            results.append(0)\n        else:\n            results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        # Edge case: if all elements are the same, no eversions are needed\n        if all(x == a[0] for x in a):\n            results.append(0)\n            continue\n        \n        # Find the number of eversions needed\n        max_seen = a[-1]\n        eversions = 0\n        for i in range(n - 2, -1, -1):\n            if a[i] > max_seen:\n                eversions += 1\n                max_seen = a[i]\n        \n        results.append(eversions)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [num for num in a if num <= x]\n    right = [num for num in a if num > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if all(a[i] <= a[i + 1] for i in range(n - 1)):\n            results.append(0)\n        else:\n            results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [elem for elem in a if elem <= x]\n    right = [elem for elem in a if elem > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if all(a[i] <= a[i + 1] for i in range(n - 1)) or len(set(a)) == 1:\n            results.append(0)\n        else:\n            results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [elem for elem in a if elem <= x]\n    right = [elem for elem in a if elem > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if all(a[i] <= a[i + 1] for i in range(n - 1)):\n            results.append(0)\n        else:\n            results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [num for num in a if num <= x]\n    right = [num for num in a if num > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    current = a\n    k = 0\n    while True:\n        next_array = perform_eversion(current)\n        if next_array == current:\n            break\n        current = next_array\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        # Edge case: if all elements are the same or already sorted\n        if all(x == a[0] for x in a) or a == sorted(a):\n            results.append(0)\n            continue\n        \n        # Perform eversions\n        k = 0\n        while True:\n            x = a[-1]\n            left = [num for num in a if num <= x]\n            right = [num for num in a if num > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            k += 1\n        \n        results.append(k)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [elem for elem in a if elem <= x]\n    right = [elem for elem in a if elem > x]\n    return left + right\n\ndef min_eversions_to_stabilize(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if all(a[i] <= a[i + 1] for i in range(n - 1)):\n            results.append(0)\n        else:\n            results.append(min_eversions_to_stabilize(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [num for num in a if num <= x]\n    right = [num for num in a if num > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the corresponding arrays for each test case.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"List of test cases, each containing an integer n and a list of integers a\"\n    },\n    {\n      \"description\": \"Implement the eversion operation for a given array.\",\n      \"input\": \"Array a of length n\",\n      \"output\": \"Array after one eversion operation\"\n    },\n    {\n      \"description\": \"Determine the number of eversions required for the array to stop changing.\",\n      \"input\": \"Array a of length n\",\n      \"output\": \"Integer k representing the number of eversions after which the array stops changing\"\n    },\n    {\n      \"description\": \"Handle edge cases where no elements need to be partitioned or when all elements belong to one part.\",\n      \"input\": \"Array a of length n\",\n      \"output\": \"Integer k, which may be 0 if no eversions are needed\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, initialize a counter for the number of eversions.\",\n    \"Perform the eversion operation on the array and increment the counter.\",\n    \"Repeat the eversion operation until the array stops changing.\",\n    \"Check for edge cases where the array is already stable or requires no eversions.\",\n    \"Output the number of eversions required for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [num for num in a if num <= x]\n    right = [num for num in a if num > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: min_eversions_to_stable() missing 1 required positional argument: 'a'"}, "Round_1": {"code": "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [num for num in a if num <= x]\n    right = [num for num in a if num > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the corresponding arrays for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the integer n and the array a of length n.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the eversion operation for a given array.\",\n      \"steps\": [\n        \"Identify the last element of the array, x = a[n-1].\",\n        \"Partition the array into two parts: left (elements <= x) and right (elements > x).\",\n        \"Concatenate the left and right parts to form the new array.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum number of eversions required for the array to stop changing.\",\n      \"steps\": [\n        \"Initialize a counter for the number of eversions, k = 0.\",\n        \"Perform the eversion operation on the array.\",\n        \"Check if the array changes after the eversion. If it does, increment k and repeat the eversion.\",\n        \"If the array does not change, record the current value of k as the result for this test case.\"\n      ]\n    },\n    {\n      \"description\": \"Handle edge cases where no elements need to be partitioned or when all elements belong to one part.\",\n      \"steps\": [\n        \"If the array is already sorted in non-decreasing order, set k = 0.\",\n        \"If all elements are the same, set k = 0.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all test cases.\",\n      \"steps\": [\n        \"For each test case, output the computed value of k.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, perform the following:\",\n    \"  - Implement the eversion operation on the array.\",\n    \"  - Determine the minimum number of eversions required for the array to stop changing.\",\n    \"  - Handle any edge cases.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [num for num in a if num <= x]\n    right = [num for num in a if num > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if all(a[i] <= a[i + 1] for i in range(n - 1)) or len(set(a)) == 1:\n            results.append(0)\n        else:\n            results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the corresponding arrays for each test case.\",\n      \"details\": \"Read the first line to get the number of test cases, t. For each test case, read the integer n and the array of integers a.\"\n    },\n    {\n      \"description\": \"Implement the eversion operation for a given array.\",\n      \"details\": \"For a given array a, identify the last element x. Partition the array into two parts: elements less than or equal to x and elements greater than x. Concatenate these parts to form the new array.\"\n    },\n    {\n      \"description\": \"Determine the number of eversions required for the array to stop changing.\",\n      \"details\": \"Repeatedly apply the eversion operation until the array remains unchanged. Count the number of eversions performed.\"\n    },\n    {\n      \"description\": \"Handle edge cases where no eversions are needed.\",\n      \"details\": \"If the array is already sorted in non-decreasing order or all elements are the same, no eversions are needed.\"\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, output the number of eversions required for the array to stop changing.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases, t.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the integer n and the array a.\",\n    \"  b. Initialize a counter for the number of eversions, k, to 0.\",\n    \"  c. While the array changes after an eversion, perform the eversion operation and increment k.\",\n    \"  d. Check if the array is already sorted or all elements are the same to handle edge cases.\",\n    \"  e. Output the value of k for the current test case.\"\n  ]\n}\n```", "Round_0": {"code": "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [num for num in a if num <= x]\n    right = [num for num in a if num > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if all(a[i] <= a[i + 1] for i in range(n - 1)):\n            results.append(0)\n        else:\n            results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid literal for int() with base 10: '2 4 1 5 3'"}, "Round_1": {"code": "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [num for num in a if num <= x]\n    right = [num for num in a if num > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index].strip())\n        index += 1\n        a = list(map(int, data[index].strip().split()))\n        index += 1\n        \n        if all(a[i] <= a[i + 1] for i in range(n - 1)):\n            results.append(0)\n        else:\n            results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the corresponding arrays for each test case.\",\n      \"details\": \"Read the first line to get the number of test cases. For each test case, read the integer n and the array of n integers.\"\n    },\n    {\n      \"description\": \"Implement the eversion operation for a given array.\",\n      \"details\": \"For a given array, identify the last element as x. Partition the array into two parts: elements less than or equal to x and elements greater than x. Concatenate these parts to form the new array.\"\n    },\n    {\n      \"description\": \"Determine the number of eversions required for the array to stop changing.\",\n      \"details\": \"Repeatedly apply the eversion operation until the array no longer changes. Count the number of eversions performed.\"\n    },\n    {\n      \"description\": \"Handle edge cases where no eversions are needed.\",\n      \"details\": \"If the array is already sorted in non-decreasing order or all elements are the same, no eversions are needed.\"\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, output the number of eversions required for the array to stop changing.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the integer n and the array of n integers.\",\n    \"  b. Initialize a counter for the number of eversions.\",\n    \"  c. While the array changes after an eversion, perform the eversion operation and increment the counter.\",\n    \"  d. Check if the array is already sorted or all elements are the same to handle edge cases.\",\n    \"  e. Store the number of eversions required for the current test case.\",\n    \"Output the number of eversions for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        # Edge case: if all elements are the same, no eversions are needed\n        if all(x == a[0] for x in a):\n            results.append(0)\n            continue\n        \n        # Find the number of eversions needed\n        max_seen = a[-1]\n        eversions = 0\n        for i in range(n - 2, -1, -1):\n            if a[i] > max_seen:\n                eversions += 1\n                max_seen = a[i]\n        \n        results.append(eversions)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the corresponding arrays for each test case.\",\n      \"details\": \"Read the first line to get the number of test cases, t. For each test case, read the integer n and the array of integers a.\"\n    },\n    {\n      \"description\": \"Implement the eversion operation for a given array.\",\n      \"details\": \"For a given array a, identify the last element x. Partition the array into two parts: elements less than or equal to x and elements greater than x. Concatenate these parts to form the new array.\"\n    },\n    {\n      \"description\": \"Determine the number of eversions required for the array to stop changing.\",\n      \"details\": \"Repeatedly apply the eversion operation until the array remains unchanged. Count the number of eversions performed.\"\n    },\n    {\n      \"description\": \"Handle edge cases where no eversions are needed.\",\n      \"details\": \"If the array is already sorted in non-decreasing order or all elements are the same, no eversions are needed.\"\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, output the number of eversions required for the array to stop changing.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases, t.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the integer n and the array a.\",\n    \"  b. Initialize a counter for the number of eversions, k, to 0.\",\n    \"  c. While the array changes after an eversion, perform the eversion operation and increment k.\",\n    \"  d. Check if the array is already sorted or all elements are the same to handle edge cases.\",\n    \"  e. Output the value of k for the current test case.\"\n  ]\n}\n```", "Round_0": {"code": "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [num for num in a if num <= x]\n    right = [num for num in a if num > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if all(a[i] <= a[i + 1] for i in range(n - 1)):\n            results.append(0)\n        else:\n            results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: min_eversions_to_stable() missing 1 required positional argument: 'a'"}, "Round_1": {"code": "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [num for num in a if num <= x]\n    right = [num for num in a if num > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if all(a[i] <= a[i + 1] for i in range(n - 1)):\n            results.append(0)\n        else:\n            results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the corresponding arrays for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the integer n and the array a of length n.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the eversion operation for a given array.\",\n      \"steps\": [\n        \"Identify the last element of the array, x = a[n-1].\",\n        \"Partition the array into two parts: left (elements <= x) and right (elements > x).\",\n        \"Concatenate the left and right parts to form the new array.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum number of eversions required for the array to stop changing.\",\n      \"steps\": [\n        \"Initialize a counter k to track the number of eversions.\",\n        \"Perform the eversion operation on the array.\",\n        \"Check if the array changes after the eversion. If it does, increment k and repeat the eversion.\",\n        \"If the array does not change, record the value of k for the test case.\"\n      ]\n    },\n    {\n      \"description\": \"Handle edge cases where no elements need to be partitioned or when all elements belong to one part.\",\n      \"steps\": [\n        \"If the array is already sorted in non-decreasing order, set k to 0.\",\n        \"If all elements are the same, set k to 0.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the value of k, the number of eversions after which the array stops changing.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, perform the following:\",\n    \"Check for edge cases where no eversions are needed.\",\n    \"Initialize a counter for the number of eversions.\",\n    \"Perform the eversion operation iteratively until the array stops changing.\",\n    \"Output the number of eversions required for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [elem for elem in a if elem <= x]\n    right = [elem for elem in a if elem > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if all(a[i] <= a[i + 1] for i in range(n - 1)) or len(set(a)) == 1:\n            results.append(0)\n        else:\n            results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the integer n and the array a of length n.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the eversion operation for a given array.\",\n      \"steps\": [\n        \"Identify the last element of the array, x = a[n-1].\",\n        \"Partition the array into two parts: left (elements \u2264 x) and right (elements > x).\",\n        \"Concatenate the left and right parts to form the new array.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the number of eversions required for the array to stop changing.\",\n      \"steps\": [\n        \"Initialize a counter k to track the number of eversions.\",\n        \"Perform the eversion operation on the array.\",\n        \"Check if the array changes after the eversion. If it does, increment k and repeat the eversion.\",\n        \"Stop when the array no longer changes and record the value of k.\"\n      ]\n    },\n    {\n      \"description\": \"Handle edge cases.\",\n      \"steps\": [\n        \"If all elements in the array are the same, no eversions are needed (k = 0).\",\n        \"If the array is already sorted in non-decreasing order, no eversions are needed (k = 0).\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, print the integer k representing the number of eversions after which the array stops changing.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the arrays.\",\n    \"For each test case, perform the eversion operation until the array stops changing.\",\n    \"Handle edge cases where no eversions are needed.\",\n    \"Output the number of eversions required for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [elem for elem in a if elem <= x]\n    right = [elem for elem in a if elem > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if all(a[i] <= a[i + 1] for i in range(n - 1)):\n            results.append(0)\n        else:\n            results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the corresponding arrays for each test case.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"List of test cases, where each test case is a tuple containing the integer n and the list of integers a.\"\n    },\n    {\n      \"description\": \"Implement the eversion operation for a given array.\",\n      \"input\": \"Array a of length n\",\n      \"output\": \"New array after performing one eversion operation.\"\n    },\n    {\n      \"description\": \"Determine the number of eversions required for the array to stop changing.\",\n      \"input\": \"Array a of length n\",\n      \"output\": \"Integer k, the number of eversions after which the array stops changing.\"\n    },\n    {\n      \"description\": \"Handle edge cases where no elements need to be partitioned or when all elements belong to one part.\",\n      \"input\": \"Array a of length n\",\n      \"output\": \"Integer k, which may be 0 if no eversions are needed.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the corresponding arrays for each test case.\",\n    \"For each test case, initialize a counter for the number of eversions.\",\n    \"While the array changes after an eversion, perform the eversion operation and increment the counter.\",\n    \"Check if the array has stopped changing by comparing it to its previous state.\",\n    \"Once the array stops changing, record the number of eversions performed.\",\n    \"Output the number of eversions for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [num for num in a if num <= x]\n    right = [num for num in a if num > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    current = a\n    k = 0\n    while True:\n        next_array = perform_eversion(current)\n        if next_array == current:\n            break\n        current = next_array\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the integer n and the array a of length n.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the eversion operation for a given array.\",\n      \"steps\": [\n        \"Identify the last element of the array, x = a[n-1].\",\n        \"Partition the array into two parts: left (elements \u2264 x) and right (elements > x).\",\n        \"Concatenate the left and right parts to form the new array.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the number of eversions required for the array to stop changing.\",\n      \"steps\": [\n        \"Initialize a counter k to track the number of eversions.\",\n        \"Perform the eversion operation on the array.\",\n        \"Check if the array changes after the eversion. If it does, increment k and repeat the eversion.\",\n        \"Stop when the array no longer changes and record the value of k.\"\n      ]\n    },\n    {\n      \"description\": \"Handle edge cases.\",\n      \"steps\": [\n        \"If all elements in the array are the same, no eversions are needed (k = 0).\",\n        \"If the array is already sorted in non-decreasing order, no eversions are needed (k = 0).\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the integer k representing the number of eversions after which the array stops changing.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, perform the eversion operation on the array until it stops changing.\",\n    \"Determine the number of eversions required for the array to stop changing.\",\n    \"Handle edge cases where no eversions are needed.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        # Edge case: if all elements are the same or already sorted\n        if all(x == a[0] for x in a) or a == sorted(a):\n            results.append(0)\n            continue\n        \n        # Perform eversions\n        k = 0\n        while True:\n            x = a[-1]\n            left = [num for num in a if num <= x]\n            right = [num for num in a if num > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            k += 1\n        \n        results.append(k)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the integer n and the array a of length n.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the eversion operation for a given array.\",\n      \"steps\": [\n        \"Identify the last element of the array, x = a[n-1].\",\n        \"Partition the array into two parts: left (elements \u2264 x) and right (elements > x).\",\n        \"Concatenate the left and right parts to form the new array.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the number of eversions required for the array to stop changing.\",\n      \"steps\": [\n        \"Initialize a counter k to track the number of eversions.\",\n        \"Perform the eversion operation on the array.\",\n        \"Check if the array changes after the eversion. If it does, increment k and repeat the eversion.\",\n        \"Stop when the array no longer changes and record the value of k.\"\n      ]\n    },\n    {\n      \"description\": \"Handle edge cases.\",\n      \"steps\": [\n        \"If all elements in the array are the same, no eversions are needed (k = 0).\",\n        \"If the array is already sorted in non-decreasing order, no eversions are needed (k = 0).\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the integer k representing the number of eversions after which the array stops changing.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, perform the eversion operation iteratively until the array stops changing.\",\n    \"Handle edge cases where no eversions are needed.\",\n    \"Output the number of eversions required for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [elem for elem in a if elem <= x]\n    right = [elem for elem in a if elem > x]\n    return left + right\n\ndef min_eversions_to_stabilize(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if all(a[i] <= a[i + 1] for i in range(n - 1)):\n            results.append(0)\n        else:\n            results.append(min_eversions_to_stabilize(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: min_eversions_to_stabilize() missing 1 required positional argument: 'a'"}, "Round_1": {"code": "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [elem for elem in a if elem <= x]\n    right = [elem for elem in a if elem > x]\n    return left + right\n\ndef min_eversions_to_stabilize(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if all(a[i] <= a[i + 1] for i in range(n - 1)):\n            results.append(0)\n        else:\n            results.append(min_eversions_to_stabilize(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the corresponding arrays for each test case.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"List of test cases, each containing an integer n and a list of integers a\"\n    },\n    {\n      \"description\": \"Implement the eversion operation for a given array.\",\n      \"input\": \"Array a of length n\",\n      \"output\": \"Array after one eversion operation\"\n    },\n    {\n      \"description\": \"Determine the number of eversions required for the array to stop changing.\",\n      \"input\": \"Array a of length n\",\n      \"output\": \"Integer k representing the number of eversions after which the array stops changing\"\n    },\n    {\n      \"description\": \"Handle edge cases where no elements need to be partitioned or when all elements belong to one part.\",\n      \"input\": \"Array a of length n\",\n      \"output\": \"Integer k, which may be 0 if no eversions are needed\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, initialize a counter for the number of eversions.\",\n    \"Perform the eversion operation on the array and increment the counter.\",\n    \"Repeat the eversion operation until the array stops changing.\",\n    \"Check for edge cases where the array is already stable or requires no eversions.\",\n    \"Output the number of eversions required for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [num for num in a if num <= x]\n    right = [num for num in a if num > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: min_eversions_to_stable() missing 1 required positional argument: 'a'"}, "Round_1": {"code": "def perform_eversion(a):\n    n = len(a)\n    x = a[-1]\n    left = [num for num in a if num <= x]\n    right = [num for num in a if num > x]\n    return left + right\n\ndef min_eversions_to_stable(a):\n    k = 0\n    while True:\n        new_a = perform_eversion(a)\n        if new_a == a:\n            break\n        a = new_a\n        k += 1\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        results.append(min_eversions_to_stable(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 19, "prompt": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions. Consider edge cases where no elements need to be partitioned or when all elements belong to one part.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 19}
