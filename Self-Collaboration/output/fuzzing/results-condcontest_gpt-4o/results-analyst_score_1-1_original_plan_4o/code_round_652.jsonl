{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "repair_prompt": ["Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp holds n problems that his students have not seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are distinct, meaning there aren't two tasks with identical topics and difficulties simultaneously.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_ways = comb(n, 3)\n        \n        invalid_ways = 0\n        \n        for count in topics.values():\n            if count >= 3:\n                invalid_ways += comb(count, 3)\n        \n        for count in difficulties.values():\n            if count >= 3:\n                invalid_ways += comb(count, 3)\n        \n        topic_difficulty_pairs = defaultdict(int)\n        \n        for a_i, b_i in problems:\n            topic_difficulty_pairs[(a_i, b_i)] += 1\n        \n        for (a_i, b_i), count in topic_difficulty_pairs.items():\n            if topics[a_i] >= 2 and difficulties[b_i] >= 2:\n                invalid_ways -= (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "completions": ["import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_combinations = comb(n, 3)\n        \n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "import sys\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        invalid_combinations = 0\n        for a_i, b_i in problems:\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_combinations(n):\n    if n < 3:\n        return 0\n    return n * (n - 1) * (n - 2) // 6\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = calculate_combinations(n)\n        \n        invalid_topic_combinations = 0\n        for count in topic_count.values():\n            invalid_topic_combinations += calculate_combinations(count)\n        \n        invalid_difficulty_combinations = 0\n        for count in difficulty_count.values():\n            invalid_difficulty_combinations += calculate_combinations(count)\n        \n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "import sys\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef count_valid_combinations(n, problems):\n    # Calculate total combinations of 3 problems\n    total_combinations = n * (n - 1) * (n - 2) // 6\n    \n    # Count occurrences of each topic and difficulty\n    topic_count = defaultdict(int)\n    difficulty_count = defaultdict(int)\n    \n    for a, b in problems:\n        topic_count[a] += 1\n        difficulty_count[b] += 1\n    \n    # Calculate invalid combinations where topics or difficulties are not different\n    invalid_combinations = 0\n    \n    for a, b in problems:\n        # Calculate combinations where the current problem shares the same topic or difficulty\n        invalid_combinations += (topic_count[a] - 1) * (difficulty_count[b] - 1)\n    \n    # Valid combinations are total combinations minus invalid combinations\n    valid_combinations = total_combinations - invalid_combinations\n    return valid_combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            problems.append((a, b))\n            index += 2\n        \n        result = count_valid_combinations(n, problems)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Invalid combinations: all three problems have the same topic\n        invalid_topic_combinations = sum(comb(count, 3) for count in topics.values() if count >= 3)\n        \n        # Invalid combinations: all three problems have the same difficulty\n        invalid_difficulty_combinations = sum(comb(count, 3) for count in difficulties.values() if count >= 3)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_ways = comb(n, 3)\n        \n        # Invalid ways where all topics are the same\n        invalid_topic_ways = sum(comb(count, 3) for count in topics.values() if count >= 3)\n        \n        # Invalid ways where all difficulties are the same\n        invalid_difficulty_ways = sum(comb(count, 3) for count in difficulties.values() if count >= 3)\n        \n        # Valid ways\n        valid_ways = total_ways - invalid_topic_ways - invalid_difficulty_ways\n        \n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        # Ways to choose 3 problems with the same topic or same difficulty\n        invalid_ways = 0\n        \n        for a_i, b_i in problems:\n            invalid_ways += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "from sys import stdin, stdout\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef solve():\n    input = stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            topic_count[a] += 1\n            difficulty_count[b] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        invalid_combinations = 0\n        \n        for a, b in problems:\n            invalid_combinations += (topic_count[a] - 1) * (difficulty_count[b] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    solve()\n\nmain()", "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_ways = comb(n, 3)\n        \n        invalid_ways = 0\n        \n        for topic_count in topics.values():\n            if topic_count >= 3:\n                invalid_ways += comb(topic_count, 3)\n        \n        for difficulty_count in difficulties.values():\n            if difficulty_count >= 3:\n                invalid_ways += comb(difficulty_count, 3)\n        \n        results.append(total_ways - invalid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_ways = comb(n, 3)\n        \n        invalid_ways = 0\n        \n        for count in topics.values():\n            if count >= 3:\n                invalid_ways += comb(count, 3)\n        \n        for count in difficulties.values():\n            if count >= 3:\n                invalid_ways += comb(count, 3)\n        \n        topic_difficulty_pairs = defaultdict(int)\n        \n        for a_i, b_i in problems:\n            topic_difficulty_pairs[(a_i, b_i)] += 1\n        \n        for (a_i, b_i), count in topic_difficulty_pairs.items():\n            if topics[a_i] >= 2 and difficulties[b_i] >= 2:\n                invalid_ways -= (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read the integers a_i and b_i, which represent the topic and difficulty of the problem.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"steps\": [\n        \"Use combinatorial mathematics to calculate the total number of ways to select three problems from n problems, which is given by the combination formula C(n, 3).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of invalid selections where neither condition is satisfied.\",\n      \"steps\": [\n        \"Count the number of problems for each topic and difficulty.\",\n        \"Calculate the number of ways to select three problems with the same topic.\",\n        \"Calculate the number of ways to select three problems with the same difficulty.\",\n        \"Adjust for overcounting by considering problems with both the same topic and difficulty.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of valid selections where at least one condition is satisfied.\",\n      \"steps\": [\n        \"Subtract the number of invalid selections from the total number of ways to select three problems.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"Print the number of valid selections for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select three problems using combinatorial mathematics.\",\n    \"For each test case, calculate the number of invalid selections where neither condition is satisfied.\",\n    \"Subtract the number of invalid selections from the total number of ways to get the number of valid selections.\",\n    \"Output the number of valid selections for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_ways = comb(n, 3)\n        \n        invalid_ways = 0\n        \n        for count in topics.values():\n            if count >= 3:\n                invalid_ways += comb(count, 3)\n        \n        for count in difficulties.values():\n            if count >= 3:\n                invalid_ways += comb(count, 3)\n        \n        topic_difficulty_pairs = defaultdict(int)\n        \n        for a_i, b_i in problems:\n            topic_difficulty_pairs[(a_i, b_i)] += 1\n        \n        for (a_i, b_i), count in topic_difficulty_pairs.items():\n            if topics[a_i] >= 2 and difficulties[b_i] >= 2:\n                invalid_ways -= comb(topics[a_i] - 1, 2) * comb(difficulties[b_i] - 1, 2)\n        \n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 109)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_ways = comb(n, 3)\n        \n        invalid_ways = 0\n        \n        for count in topics.values():\n            if count >= 3:\n                invalid_ways += comb(count, 3)\n        \n        for count in difficulties.values():\n            if count >= 3:\n                invalid_ways += comb(count, 3)\n        \n        topic_difficulty_pairs = defaultdict(int)\n        \n        for a_i, b_i in problems:\n            topic_difficulty_pairs[(a_i, b_i)] += 1\n        \n        for (a_i, b_i), count in topic_difficulty_pairs.items():\n            if topics[a_i] >= 2 and difficulties[b_i] >= 2:\n                invalid_ways -= (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read two integers a_i and b_i, representing the topic and difficulty.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"details\": [\n        \"Use combinatorial logic to calculate the total number of combinations of three problems from n problems, which is C(n, 3).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of invalid combinations where neither condition is satisfied.\",\n      \"details\": [\n        \"Count the number of problems with the same topic and the number of problems with the same difficulty.\",\n        \"Calculate the number of combinations where all three problems have the same topic or all three problems have the same difficulty.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of valid combinations where at least one condition is satisfied.\",\n      \"details\": [\n        \"Subtract the number of invalid combinations from the total number of combinations to get the number of valid combinations.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": [\n        \"Print the number of valid combinations for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select three problems using combinatorial logic.\",\n    \"For each test case, calculate the number of invalid combinations where neither condition is satisfied.\",\n    \"Subtract the number of invalid combinations from the total number of combinations to get the number of valid combinations.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_combinations = comb(n, 3)\n        \n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_combinations = comb(n, 3)\n        \n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read the integers a_i and b_i, which represent the topic and difficulty of the problem.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems that satisfy the conditions for each test case.\",\n      \"details\": [\n        \"For each test case, generate all possible combinations of three problems from the list of n problems.\",\n        \"Check each combination to see if it satisfies at least one of the conditions: all topics are different or all difficulties are different.\",\n        \"Count the number of valid combinations.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": [\n        \"Print the number of valid combinations for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize a list to store the results for each test case.\",\n    \"For each test case, perform the following steps:\",\n    \"  Parse the number of problems and their respective topics and difficulties.\",\n    \"  Initialize a counter to track the number of valid combinations.\",\n    \"  Iterate over all combinations of three problems.\",\n    \"  For each combination, check if it satisfies the conditions.\",\n    \"  If valid, increment the counter.\",\n    \"  Append the counter value to the results list.\",\n    \"Print the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        invalid_combinations = 0\n        for a_i, b_i in problems:\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read two integers a_i and b_i, representing the topic and difficulty.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"details\": [\n        \"Use combinatorial mathematics to calculate the number of ways to choose 3 problems from n, which is C(n, 3) = n * (n - 1) * (n - 2) / 6.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of invalid selections where all three problems have the same topic.\",\n      \"details\": [\n        \"Group problems by topic.\",\n        \"For each topic group with at least 3 problems, calculate the number of ways to choose 3 problems from this group using C(count, 3).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of invalid selections where all three problems have the same difficulty.\",\n      \"details\": [\n        \"Group problems by difficulty.\",\n        \"For each difficulty group with at least 3 problems, calculate the number of ways to choose 3 problems from this group using C(count, 3).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of valid selections by subtracting invalid selections from total selections.\",\n      \"details\": [\n        \"Subtract the number of invalid selections (same topic and same difficulty) from the total number of selections.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select three problems using combinatorial mathematics.\",\n    \"Group problems by topic and calculate the number of invalid selections where all three problems have the same topic.\",\n    \"Group problems by difficulty and calculate the number of invalid selections where all three problems have the same difficulty.\",\n    \"Subtract the number of invalid selections from the total number of selections to get the number of valid selections.\",\n    \"Output the number of valid selections for each test case.\"\n  ]\n}\n", "Round_0": {"code": "def calculate_combinations(n):\n    if n < 3:\n        return 0\n    return n * (n - 1) * (n - 2) // 6\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = calculate_combinations(n)\n        \n        invalid_topic_combinations = 0\n        for count in topic_count.values():\n            invalid_topic_combinations += calculate_combinations(count)\n        \n        invalid_difficulty_combinations = 0\n        for count in difficulty_count.values():\n            invalid_difficulty_combinations += calculate_combinations(count)\n        \n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read the integers a_i and b_i, which represent the topic and difficulty of the problem.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems that satisfy the given conditions for each test case.\",\n      \"steps\": [\n        \"For each test case, generate all possible combinations of three problems from the list of n problems.\",\n        \"For each combination, check if the topics of the three problems are all different or if the difficulties are all different.\",\n        \"Count the number of combinations that satisfy at least one of the conditions.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print the number of valid combinations found.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, iterate over all possible combinations of three problems.\",\n    \"Check each combination to see if it satisfies the condition of having all different topics or all different difficulties.\",\n    \"Count and store the number of valid combinations for each test case.\",\n    \"Output the count for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef count_valid_combinations(n, problems):\n    # Calculate total combinations of 3 problems\n    total_combinations = n * (n - 1) * (n - 2) // 6\n    \n    # Count occurrences of each topic and difficulty\n    topic_count = defaultdict(int)\n    difficulty_count = defaultdict(int)\n    \n    for a, b in problems:\n        topic_count[a] += 1\n        difficulty_count[b] += 1\n    \n    # Calculate invalid combinations where topics or difficulties are not different\n    invalid_combinations = 0\n    \n    for a, b in problems:\n        # Calculate combinations where the current problem shares the same topic or difficulty\n        invalid_combinations += (topic_count[a] - 1) * (difficulty_count[b] - 1)\n    \n    # Valid combinations are total combinations minus invalid combinations\n    valid_combinations = total_combinations - invalid_combinations\n    return valid_combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            problems.append((a, b))\n            index += 2\n        \n        result = count_valid_combinations(n, problems)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read two integers a_i and b_i, representing the topic and difficulty.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"details\": [\n        \"Use combinatorial logic to calculate the total number of combinations of three problems from n problems, which is C(n, 3).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of invalid combinations where all three problems have the same topic or the same difficulty.\",\n      \"details\": [\n        \"Count the number of problems for each topic and difficulty.\",\n        \"For each topic, calculate the number of ways to select three problems with the same topic.\",\n        \"For each difficulty, calculate the number of ways to select three problems with the same difficulty.\"\n      ]\n    },\n    {\n      \"description\": \"Subtract the number of invalid combinations from the total combinations to get the valid combinations.\",\n      \"details\": [\n        \"Subtract the invalid combinations (same topic and same difficulty) from the total combinations to get the valid combinations.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select three problems using combinatorial logic.\",\n    \"Count the number of problems for each topic and difficulty.\",\n    \"Calculate the number of invalid combinations where all three problems have the same topic or the same difficulty.\",\n    \"Subtract the invalid combinations from the total combinations to get the valid combinations.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Invalid combinations: all three problems have the same topic\n        invalid_topic_combinations = sum(comb(count, 3) for count in topics.values() if count >= 3)\n        \n        # Invalid combinations: all three problems have the same difficulty\n        invalid_difficulty_combinations = sum(comb(count, 3) for count in difficulties.values() if count >= 3)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Invalid combinations: all three problems have the same topic\n        invalid_topic_combinations = sum(comb(count, 3) for count in topics.values() if count >= 3)\n        \n        # Invalid combinations: all three problems have the same difficulty\n        invalid_difficulty_combinations = sum(comb(count, 3) for count in difficulties.values() if count >= 3)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read the integers a_i and b_i, which represent the topic and difficulty of the problem.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the number of ways to select three problems that satisfy the conditions for each test case.\",\n      \"steps\": [\n        \"Calculate the total number of ways to select any three problems from n problems using combinations.\",\n        \"Calculate the number of ways to select three problems where all topics are the same.\",\n        \"Calculate the number of ways to select three problems where all difficulties are the same.\",\n        \"Subtract the invalid selections (where all topics or all difficulties are the same) from the total combinations.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output the number of valid ways to select three problems.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of combinations to select three problems.\",\n    \"For each test case, calculate the number of invalid combinations where all topics or all difficulties are the same.\",\n    \"Subtract the invalid combinations from the total combinations to get the number of valid ways.\",\n    \"Output the number of valid ways for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_ways = comb(n, 3)\n        \n        # Invalid ways where all topics are the same\n        invalid_topic_ways = sum(comb(count, 3) for count in topics.values() if count >= 3)\n        \n        # Invalid ways where all difficulties are the same\n        invalid_difficulty_ways = sum(comb(count, 3) for count in difficulties.values() if count >= 3)\n        \n        # Valid ways\n        valid_ways = total_ways - invalid_topic_ways - invalid_difficulty_ways\n        \n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_ways = comb(n, 3)\n        \n        # Invalid ways where all topics are the same\n        invalid_topic_ways = sum(comb(count, 3) for count in topics.values() if count >= 3)\n        \n        # Invalid ways where all difficulties are the same\n        invalid_difficulty_ways = sum(comb(count, 3) for count in difficulties.values() if count >= 3)\n        \n        # Valid ways\n        valid_ways = total_ways - invalid_topic_ways - invalid_difficulty_ways\n        \n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": \"Read the integer t from the first line, then for each test case, read the integer n followed by n pairs of integers representing topics and difficulties.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"details\": \"Use the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6 to calculate the total number of ways to select three problems.\"\n    },\n    {\n      \"description\": \"Count the number of ways to select three problems with different topics.\",\n      \"details\": \"Group problems by topic, count the number of problems for each topic, and calculate the number of ways to select three problems with different topics using combinations.\"\n    },\n    {\n      \"description\": \"Count the number of ways to select three problems with different difficulties.\",\n      \"details\": \"Group problems by difficulty, count the number of problems for each difficulty, and calculate the number of ways to select three problems with different difficulties using combinations.\"\n    },\n    {\n      \"description\": \"Calculate the number of valid problem sets for each test case.\",\n      \"details\": \"Subtract the number of invalid sets (same topic and same difficulty) from the total number of sets to get the number of valid sets.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select three problems using combinations.\",\n    \"For each test case, count the number of ways to select three problems with different topics.\",\n    \"For each test case, count the number of ways to select three problems with different difficulties.\",\n    \"For each test case, calculate the number of valid problem sets by subtracting invalid sets from the total number of sets.\",\n    \"Output the number of valid problem sets for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        # Ways to choose 3 problems with the same topic or same difficulty\n        invalid_ways = 0\n        \n        for a_i, b_i in problems:\n            invalid_ways += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": \"Read the integer t from the first line, then for each test case, read the integer n followed by n pairs of integers representing topics and difficulties.\"\n    },\n    {\n      \"description\": \"Generate all possible combinations of three problems from the list of problems for each test case.\",\n      \"details\": \"Use combinations to generate all possible sets of three problems from the n problems.\"\n    },\n    {\n      \"description\": \"Check if a combination of three problems satisfies at least one of the conditions: different topics or different difficulties.\",\n      \"details\": \"For each combination, verify if all three problems have different topics or all three have different difficulties.\"\n    },\n    {\n      \"description\": \"Count the number of valid combinations for each test case.\",\n      \"details\": \"Increment a counter for each combination that satisfies at least one of the conditions.\"\n    },\n    {\n      \"description\": \"Output the count of valid combinations for each test case.\",\n      \"details\": \"Print the result for each test case on a new line.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse the number of test cases and the list of problems for each test case.\",\n    \"For each test case, generate all possible combinations of three problems.\",\n    \"For each combination, check if it satisfies the condition of having different topics or different difficulties.\",\n    \"Count the number of combinations that satisfy at least one of the conditions.\",\n    \"Output the count for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "from sys import stdin, stdout\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef solve():\n    input = stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            topic_count[a] += 1\n            difficulty_count[b] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        invalid_combinations = 0\n        \n        for a, b in problems:\n            invalid_combinations += (topic_count[a] - 1) * (difficulty_count[b] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    solve()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read the integers a_i and b_i, which represent the topic and difficulty of the problem.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"steps\": [\n        \"Use combinatorial logic to calculate the total number of ways to select three problems from n problems, which is given by the combination formula C(n, 3).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of invalid selections where neither condition is satisfied.\",\n      \"steps\": [\n        \"Count the number of problems for each topic and difficulty.\",\n        \"For each topic, calculate the number of ways to select three problems with the same topic.\",\n        \"For each difficulty, calculate the number of ways to select three problems with the same difficulty.\",\n        \"Subtract the number of invalid selections from the total number of ways to get the valid selections.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of valid selections for each test case.\",\n      \"steps\": [\n        \"For each test case, print the number of valid selections.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select three problems using combinatorial logic.\",\n    \"For each test case, calculate the number of invalid selections where neither condition is satisfied.\",\n    \"Subtract the number of invalid selections from the total number of ways to get the valid selections.\",\n    \"Output the number of valid selections for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_ways = comb(n, 3)\n        \n        invalid_ways = 0\n        \n        for topic_count in topics.values():\n            if topic_count >= 3:\n                invalid_ways += comb(topic_count, 3)\n        \n        for difficulty_count in difficulties.values():\n            if difficulty_count >= 3:\n                invalid_ways += comb(difficulty_count, 3)\n        \n        results.append(total_ways - invalid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_ways = comb(n, 3)\n        \n        invalid_ways = 0\n        \n        for topic_count in topics.values():\n            if topic_count >= 3:\n                invalid_ways += comb(topic_count, 3)\n        \n        for difficulty_count in difficulties.values():\n            if difficulty_count >= 3:\n                invalid_ways += comb(difficulty_count, 3)\n        \n        results.append(total_ways - invalid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read the integers a_i and b_i, which represent the topic and difficulty of the problem.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"steps\": [\n        \"Use combinatorial mathematics to calculate the total number of ways to select three problems from n problems, which is given by the combination formula C(n, 3).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of invalid selections where neither condition is satisfied.\",\n      \"steps\": [\n        \"Count the number of problems for each topic and difficulty.\",\n        \"Calculate the number of ways to select three problems with the same topic.\",\n        \"Calculate the number of ways to select three problems with the same difficulty.\",\n        \"Adjust for overcounting by considering problems with both the same topic and difficulty.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of valid selections where at least one condition is satisfied.\",\n      \"steps\": [\n        \"Subtract the number of invalid selections from the total number of ways to select three problems.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"Print the number of valid selections for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select three problems using combinatorial mathematics.\",\n    \"For each test case, calculate the number of invalid selections where neither condition is satisfied.\",\n    \"Subtract the number of invalid selections from the total number of ways to get the number of valid selections.\",\n    \"Output the number of valid selections for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_ways = comb(n, 3)\n        \n        invalid_ways = 0\n        \n        for count in topics.values():\n            if count >= 3:\n                invalid_ways += comb(count, 3)\n        \n        for count in difficulties.values():\n            if count >= 3:\n                invalid_ways += comb(count, 3)\n        \n        topic_difficulty_pairs = defaultdict(int)\n        \n        for a_i, b_i in problems:\n            topic_difficulty_pairs[(a_i, b_i)] += 1\n        \n        for (a_i, b_i), count in topic_difficulty_pairs.items():\n            if topics[a_i] >= 2 and difficulties[b_i] >= 2:\n                invalid_ways -= comb(topics[a_i] - 1, 2) * comb(difficulties[b_i] - 1, 2)\n        \n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 109)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_ways = comb(n, 3)\n        \n        invalid_ways = 0\n        \n        for count in topics.values():\n            if count >= 3:\n                invalid_ways += comb(count, 3)\n        \n        for count in difficulties.values():\n            if count >= 3:\n                invalid_ways += comb(count, 3)\n        \n        topic_difficulty_pairs = defaultdict(int)\n        \n        for a_i, b_i in problems:\n            topic_difficulty_pairs[(a_i, b_i)] += 1\n        \n        for (a_i, b_i), count in topic_difficulty_pairs.items():\n            if topics[a_i] >= 2 and difficulties[b_i] >= 2:\n                invalid_ways -= (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}], "scores": [], "pass_results": [true, true, false, false, false, true, false, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 652, "prompt": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp holds n problems that his students have not seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are distinct, meaning there aren't two tasks with identical topics and difficulties simultaneously.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 306}
