{"name": "1615_A. Closing The Gap", "description": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\n\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "tags": ["greedy", "math"], "difficulty": 7, "id": 1615, "sample_io": [{"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}], "test_list": [{"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n1 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 3 -1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 0\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 1 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 10 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 5 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 0\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 4\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 0 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 0\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n1 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n24 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 -1 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n24 9 15\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n0 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n36 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 1\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n41 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 10 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 5\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 0 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 9\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n4 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n3 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n1 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n0 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n15 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 0 1 2\n5\n0 2 3 1 0\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 2 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 5 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n4 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 17 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 0 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n4 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 -1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 10\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n13 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 31 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n15 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 0 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n6 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 0 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n1 3 6 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 15\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 2 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 16\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 -1 3\n5\n0 3 6 1 5\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n11 12 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 2 4\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 2\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 0 6 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 1\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 14 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 2 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 14\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n1 3 10 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 19\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n0 0 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n-1 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 1\n5\n0 2 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 7\n", "output": ["0\n1\n0\n"]}], "task_id": "codecontest/119", "repair_prompt": ["There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days? Consider optimizing your approach for large values of n. Remember to account for edge cases where the number of towers is relatively small or when all towers have the same initial height.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def minimum_ugliness(t, test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_height_floor = total_blocks // n\n        target_height_ceil = (total_blocks + n - 1) // n  # Equivalent to math.ceil(total_blocks / n)\n\n        # Calculate the minimum possible ugliness\n        min_ugliness = target_height_ceil - target_height_floor\n        results.append(min_ugliness)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nmain()", "completions": ["def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_floor = total_blocks // n\n        target_ceil = (total_blocks + n - 1) // n  # Equivalent to math.ceil(total_blocks / n)\n\n        # Calculate excess and deficit\n        excess = sum(max(0, h - target_ceil) for h in heights)\n        deficit = sum(max(0, target_floor - h) for h in heights)\n\n        # Minimum ugliness is the maximum of excess and deficit\n        min_ugliness = max(excess, deficit)\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_floor = total_blocks // n\n        target_ceil = (total_blocks + n - 1) // n  # Equivalent to math.ceil(total_blocks / n)\n\n        # Calculate the number of towers that need to be at least target_ceil\n        num_ceil = total_blocks % n\n\n        # The minimum ugliness is the difference between the two target heights\n        min_ugliness = target_ceil - target_floor if num_ceil > 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_floor = total_blocks // n\n        target_ceil = (total_blocks + n - 1) // n  # Equivalent to math.ceil(total_blocks / n)\n\n        # Count how many towers need to be at least target_floor and target_ceil\n        count_floor = sum(1 for h in heights if h <= target_floor)\n        count_ceil = n - count_floor\n\n        # Calculate the minimum ugliness\n        # If all towers can be made target_floor, ugliness is 0\n        # Otherwise, the difference between target_ceil and target_floor is 1\n        if count_ceil * target_ceil + count_floor * target_floor == total_blocks:\n            results.append(target_ceil - target_floor)\n        else:\n            results.append(1)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average_height = total_sum // n\n        remainder = total_sum % n\n        \n        # To minimize ugliness, distribute blocks such that:\n        # remainder towers have height average_height + 1\n        # (n - remainder) towers have height average_height\n        # This will result in a maximum height difference of 1\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        average_height = total_height // n\n        remainder = total_height % n\n        \n        # The minimum possible ugliness is determined by the remainder\n        # If remainder is 0, all towers can be made equal\n        # If remainder is not 0, the minimum ugliness is 1\n        min_ugliness = 1 if remainder != 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_floor = total_blocks // n\n        target_ceil = (total_blocks + n - 1) // n  # Equivalent to math.ceil(total_blocks / n)\n\n        # Calculate the number of towers that should have the floor height and the ceil height\n        num_floor = n * target_ceil - total_blocks\n        num_ceil = n - num_floor\n\n        # The minimum ugliness is the difference between the ceil and floor target heights\n        min_ugliness = target_ceil - target_floor\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average_height = total_sum // n\n        remainder = total_sum % n\n        \n        # To minimize ugliness, distribute blocks such that:\n        # remainder towers have height average_height + 1\n        # (n - remainder) towers have height average_height\n        min_height = average_height\n        max_height = average_height + (1 if remainder > 0 else 0)\n        \n        min_ugliness = max_height - min_height\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        average_height = total_height // n\n        remainder = total_height % n\n        \n        # To minimize ugliness, distribute blocks such that:\n        # remainder towers have height average_height + 1\n        # (n - remainder) towers have height average_height\n        # The minimum ugliness is the difference between these two heights\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average_height = total_sum // n\n        # Calculate the minimum possible ugliness\n        # The minimum ugliness is determined by the difference between the max and min possible heights\n        # after redistributing blocks to achieve heights close to the average.\n        # We need to check the remainder when dividing the total sum by n to see if perfect distribution is possible.\n        remainder = total_sum % n\n        if remainder == 0:\n            # If the remainder is 0, we can perfectly distribute the blocks\n            min_ugliness = 0\n        else:\n            # If there is a remainder, the minimum ugliness will be 1\n            min_ugliness = 1\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(t, test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_height_floor = total_blocks // n\n        target_height_ceil = (total_blocks + n - 1) // n  # Equivalent to math.ceil(total_blocks / n)\n\n        # Calculate the minimum possible ugliness\n        min_ugliness = target_height_ceil - target_height_floor\n        results.append(min_ugliness)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Read the integer t, which represents the number of test cases. For each test case, read the integer n (number of towers) and the list of integers representing the heights of the towers.\"\n    },\n    {\n      \"description\": \"Calculate the total number of blocks across all towers for each test case.\",\n      \"details\": \"Sum up all the heights of the towers to get the total number of blocks.\"\n    },\n    {\n      \"description\": \"Determine the target height for minimizing ugliness.\",\n      \"details\": \"Calculate the target height by dividing the total number of blocks by the number of towers (n). Consider both the floor and ceiling of this division to handle cases where the total number of blocks is not perfectly divisible by n.\"\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"details\": \"Compute the difference between the maximum and minimum possible heights (target heights) that can be achieved by redistributing the blocks. This will be the minimum possible ugliness.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, output the calculated minimum possible ugliness.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases, t.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the number of towers, n, and their respective heights.\",\n    \"  b. Calculate the total number of blocks by summing the heights.\",\n    \"  c. Determine the target height by dividing the total blocks by n, considering both floor and ceiling values.\",\n    \"  d. Calculate the minimum possible ugliness as the difference between the maximum and minimum target heights.\",\n    \"  e. Store the result for the current test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(t, test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_height_floor = total_blocks // n\n        target_height_ceil = (total_blocks + n - 1) // n  # Equivalent to math.ceil(total_blocks / n)\n\n        # Calculate the minimum possible ugliness\n        min_ugliness = target_height_ceil - target_height_floor\n        results.append(min_ugliness)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(t, test_cases)\n    \n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Read the integer t, which represents the number of test cases. For each test case, read the integer n (number of towers) and the list of integers representing the heights of the towers.\"\n    },\n    {\n      \"description\": \"Calculate the total number of blocks across all towers for each test case.\",\n      \"details\": \"Sum up all the heights of the towers to get the total number of blocks.\"\n    },\n    {\n      \"description\": \"Determine the target height for minimizing ugliness.\",\n      \"details\": \"Calculate the target height by dividing the total number of blocks by the number of towers (n). Consider both the floor and ceiling of this division to handle cases where the total number of blocks is not perfectly divisible by n.\"\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"details\": \"Determine the maximum and minimum possible heights after redistributing blocks to achieve the target height. The minimum possible ugliness is the difference between these maximum and minimum heights.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data to get the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total number of blocks by summing the heights of all towers.\",\n    \"Compute the target height by dividing the total number of blocks by the number of towers, considering both floor and ceiling values.\",\n    \"Redistribute blocks to achieve the target height as evenly as possible across all towers.\",\n    \"Calculate the minimum possible ugliness by finding the difference between the maximum and minimum heights after redistribution.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_floor = total_blocks // n\n        target_ceil = (total_blocks + n - 1) // n  # Equivalent to math.ceil(total_blocks / n)\n\n        # Calculate excess and deficit\n        excess = sum(max(0, h - target_ceil) for h in heights)\n        deficit = sum(max(0, target_floor - h) for h in heights)\n\n        # Minimum ugliness is the maximum of excess and deficit\n        min_ugliness = max(excess, deficit)\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Read the integer t, which represents the number of test cases. For each test case, read the integer n (number of towers) and the list of integers representing the heights of the towers.\"\n    },\n    {\n      \"description\": \"Calculate the total number of blocks across all towers for each test case.\",\n      \"details\": \"Sum up all the heights of the towers to get the total number of blocks.\"\n    },\n    {\n      \"description\": \"Determine the target height for minimizing ugliness.\",\n      \"details\": \"Calculate the target height by dividing the total number of blocks by the number of towers (n). Consider both the floor and ceiling of this division to handle cases where the total number of blocks is not perfectly divisible by n.\"\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"details\": \"Determine the difference between the maximum and minimum possible heights (target heights) that can be achieved by redistributing the blocks. The minimum possible ugliness is the difference between these two target heights.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases, t.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the number of towers, n, and their respective heights.\",\n    \"  b. Calculate the total number of blocks by summing the heights.\",\n    \"  c. Compute the target heights by dividing the total blocks by n and considering both floor and ceiling values.\",\n    \"  d. Calculate the minimum possible ugliness as the difference between the maximum and minimum target heights.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_floor = total_blocks // n\n        target_ceil = (total_blocks + n - 1) // n  # Equivalent to math.ceil(total_blocks / n)\n\n        # Calculate the number of towers that need to be at least target_ceil\n        num_ceil = total_blocks % n\n\n        # The minimum ugliness is the difference between the two target heights\n        min_ugliness = target_ceil - target_floor if num_ceil > 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Read the integer t, which represents the number of test cases. For each test case, read the integer n (number of towers) and the list of integers representing the heights of the towers.\"\n    },\n    {\n      \"description\": \"Calculate the total number of blocks across all towers for each test case.\",\n      \"details\": \"Sum up all the heights of the towers to get the total number of blocks.\"\n    },\n    {\n      \"description\": \"Determine the target height for minimizing ugliness.\",\n      \"details\": \"Calculate the target height by dividing the total number of blocks by the number of towers (n). Consider both the floor and ceiling of this division to handle cases where the total number of blocks is not perfectly divisible by n.\"\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"details\": \"Determine the maximum and minimum possible heights after redistributing blocks to achieve the target height. The minimum possible ugliness is the difference between these maximum and minimum heights.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases, t.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the number of towers, n, and their respective heights.\",\n    \"  b. Calculate the total number of blocks.\",\n    \"  c. Compute the target height by dividing the total blocks by n, considering both floor and ceiling values.\",\n    \"  d. Calculate the minimum possible ugliness by redistributing blocks to achieve the target height.\",\n    \"  e. Output the minimum possible ugliness for the test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_floor = total_blocks // n\n        target_ceil = (total_blocks + n - 1) // n  # Equivalent to math.ceil(total_blocks / n)\n\n        # Count how many towers need to be at least target_floor and target_ceil\n        count_floor = sum(1 for h in heights if h <= target_floor)\n        count_ceil = n - count_floor\n\n        # Calculate the minimum ugliness\n        # If all towers can be made target_floor, ugliness is 0\n        # Otherwise, the difference between target_ceil and target_floor is 1\n        if count_ceil * target_ceil + count_floor * target_floor == total_blocks:\n            results.append(target_ceil - target_floor)\n        else:\n            results.append(1)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the total sum by n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks to achieve heights as close to the average as possible.\",\n        \"Consider edge cases where all buildings have the same height or where n is small.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the heights and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to achieve heights close to the average.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average_height = total_sum // n\n        remainder = total_sum % n\n        \n        # To minimize ugliness, distribute blocks such that:\n        # remainder towers have height average_height + 1\n        # (n - remainder) towers have height average_height\n        # This will result in a maximum height difference of 1\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the total sum by n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks to achieve heights as close to the average as possible.\",\n        \"Consider edge cases where all buildings have the same height or where n is small.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the heights of the buildings for each test case.\",\n    \"For each test case, calculate the minimum possible ugliness by redistributing blocks to minimize the height difference between the tallest and shortest buildings.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        average_height = total_height // n\n        remainder = total_height % n\n        \n        # The minimum possible ugliness is determined by the remainder\n        # If remainder is 0, all towers can be made equal\n        # If remainder is not 0, the minimum ugliness is 1\n        min_ugliness = 1 if remainder != 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Read the integer t, which represents the number of test cases. For each test case, read the integer n (number of towers) and the list of integers representing the heights of the towers.\"\n    },\n    {\n      \"description\": \"Calculate the total number of blocks across all towers for each test case.\",\n      \"details\": \"Sum up all the heights of the towers to get the total number of blocks.\"\n    },\n    {\n      \"description\": \"Determine the target height for minimizing ugliness.\",\n      \"details\": \"Calculate the target height by dividing the total number of blocks by the number of towers (n). Consider both the floor and ceiling of this division to handle cases where the total number of blocks is not perfectly divisible by n.\"\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"details\": \"Compute the difference between the maximum and minimum possible heights (target heights) that can be achieved by redistributing blocks. The minimum ugliness is the difference between the ceiling and floor values of the target height.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input values for the number of test cases and the details of each test case.\",\n    \"For each test case, calculate the total number of blocks by summing the heights of all towers.\",\n    \"Determine the target height by dividing the total number of blocks by the number of towers, considering both floor and ceiling values.\",\n    \"Calculate the minimum possible ugliness by finding the difference between the ceiling and floor target heights.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_floor = total_blocks // n\n        target_ceil = (total_blocks + n - 1) // n  # Equivalent to math.ceil(total_blocks / n)\n\n        # Calculate the number of towers that should have the floor height and the ceil height\n        num_floor = n * target_ceil - total_blocks\n        num_ceil = n - num_floor\n\n        # The minimum ugliness is the difference between the ceil and floor target heights\n        min_ugliness = target_ceil - target_floor\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the total sum by n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks to achieve heights as close to the average as possible.\",\n        \"Consider edge cases where all buildings have the same height or where n is small.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the heights and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to achieve heights close to the average.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average_height = total_sum // n\n        remainder = total_sum % n\n        \n        # To minimize ugliness, distribute blocks such that:\n        # remainder towers have height average_height + 1\n        # (n - remainder) towers have height average_height\n        min_height = average_height\n        max_height = average_height + (1 if remainder > 0 else 0)\n        \n        min_ugliness = max_height - min_height\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the total sum by n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks to achieve heights as close to the average as possible.\",\n        \"Consider edge cases where all buildings have the same height or where n is small.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the heights and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to achieve heights close to the average.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        average_height = total_height // n\n        remainder = total_height % n\n        \n        # To minimize ugliness, distribute blocks such that:\n        # remainder towers have height average_height + 1\n        # (n - remainder) towers have height average_height\n        # The minimum ugliness is the difference between these two heights\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the total sum by n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks to achieve heights as close to the average as possible.\",\n        \"Consider edge cases where all buildings have the same height or where n is small.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the heights and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to achieve heights close to the average.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average_height = total_sum // n\n        # Calculate the minimum possible ugliness\n        # The minimum ugliness is determined by the difference between the max and min possible heights\n        # after redistributing blocks to achieve heights close to the average.\n        # We need to check the remainder when dividing the total sum by n to see if perfect distribution is possible.\n        remainder = total_sum % n\n        if remainder == 0:\n            # If the remainder is 0, we can perfectly distribute the blocks\n            min_ugliness = 0\n        else:\n            # If there is a remainder, the minimum ugliness will be 1\n            min_ugliness = 1\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Read the integer t, which represents the number of test cases. For each test case, read the integer n (number of towers) and the list of integers representing the heights of the towers.\"\n    },\n    {\n      \"description\": \"Calculate the total number of blocks across all towers for each test case.\",\n      \"details\": \"Sum up all the heights of the towers to get the total number of blocks.\"\n    },\n    {\n      \"description\": \"Determine the target height for minimizing ugliness.\",\n      \"details\": \"Calculate the target height by dividing the total number of blocks by the number of towers (n). Consider both the floor and ceiling of this division to handle cases where the total number of blocks is not perfectly divisible by n.\"\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"details\": \"Compute the difference between the maximum and minimum possible heights (target heights) that can be achieved by redistributing the blocks. This will be the minimum possible ugliness.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, output the calculated minimum possible ugliness.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases, t.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the number of towers, n, and their respective heights.\",\n    \"  b. Calculate the total number of blocks by summing the heights.\",\n    \"  c. Determine the target height by dividing the total blocks by n, considering both floor and ceiling values.\",\n    \"  d. Calculate the minimum possible ugliness as the difference between the maximum and minimum target heights.\",\n    \"  e. Store the result for the current test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(t, test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_height_floor = total_blocks // n\n        target_height_ceil = (total_blocks + n - 1) // n  # Equivalent to math.ceil(total_blocks / n)\n\n        # Calculate the minimum possible ugliness\n        min_ugliness = target_height_ceil - target_height_floor\n        results.append(min_ugliness)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(t, test_cases)\n    \n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, false, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 491, "prompt": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days? Consider optimizing your approach for large values of n. Remember to account for edge cases where the number of towers is relatively small or when all towers have the same initial height.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 185}
