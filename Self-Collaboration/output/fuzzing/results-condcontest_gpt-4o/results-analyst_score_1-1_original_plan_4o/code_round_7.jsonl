{"name": "1579_C. Ticks", "description": "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white.\n\nLet us denote the cell with coordinates i vertically and j horizontally by (i, j). The upper left cell will be referred to as (1, 1) and the lower right cell as (n, m).\n\nCasimir draws ticks of different sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: \n\n  1. First, the center cell (i, j) is painted black. \n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. \n  3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted. In particular, a tick consists of 2d + 1 black cells. \n\n\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "tags": ["greedy", "implementation"], "difficulty": 9, "id": 1579, "sample_io": [{"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n"]}], "test_list": [{"input": "1\n1 1 1\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 1\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 1\n.....\n", "output": ["YES\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n..*...\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 2\n.....\n", "output": ["YES\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n...*.....\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 0\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n.*...\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 4\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 2\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/./*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 1 2\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*../..*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n1 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n+...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n-+.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n**.......\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*.\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 0\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*/\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n.-**..*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n..//\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n/...*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 3\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/.*.\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n../..\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n/*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n.0..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.../.\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n./+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n..-...\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*.-.\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n//.*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./-.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+-.\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n.../..\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*./\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-+..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*..\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..*.\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n*..0\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n..*../\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n..*.\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*/.\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n/*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..).\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n2 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 1 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n....-\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n-/*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n/.*..\n", "output": ["NO\n"]}, {"input": "1\n1 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n...**\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*../.\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n..**\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n2 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n.*..\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....)\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+..*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*/*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*.*...*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n).*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*-.\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n.*.*\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n**..\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*-.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n-...*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...).\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n...-.*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}], "task_id": "codecontest/15", "repair_prompt": ["Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white. Let us denote the cell with coordinates i vertically and j horizontally by (i, j), where the upper left cell is referred to as (1, 1) and the lower right cell as (n, m). Casimir draws ticks of different sizes on the field, where a tick of size d (d > 0) with its center in cell (i, j) is drawn by painting the center cell (i, j) black and then painting exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center black. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted, resulting in a tick consisting of 2d + 1 black cells. An already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3. <image> You are given a description of a checkered field of size n \u00d7 m, which Casimir claims was created by drawing some (possibly 0) ticks on it. The ticks could vary in size, but the size of each tick is at least k (that is, d \u2265 k for all the ticks). Determine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def can_form_ticks(n, m, k, field):\n    # Create a 2D list to mark cells that are covered by valid ticks\n    covered = [[False] * m for _ in range(n)]\n\n    # Iterate from bottom to top to ensure we can check for valid ticks\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if we can form a tick with center at (i, j)\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells as covered\n                if d > k:\n                    for h in range(d):\n                        covered[i - h][j - h] = True\n                        covered[i - h][j + h] = True\n\n    # Check if all '*' in the field are covered by valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def can_draw_ticks(n, m, k, field):\n    # Create a copy of the field to mark the cells that can be part of a tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to check if it can be the center of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size d >= k can be drawn with center at (i, j)\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If a tick of size d >= k is found, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Check if all '*' in the field are part of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_draw_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_draw_ticks(n, m, k, field):\n    # Create a boolean matrix to mark cells that are covered by valid ticks\n    covered = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to find potential tick centers\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size at least k can be drawn with center at (i, j)\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells as covered\n                if d > k:\n                    for h in range(d):\n                        covered[i - h][j - h] = True\n                        covered[i - h][j + h] = True\n\n    # Check if all '*' cells in the original field are covered by valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = data[index + 1:index + 1 + n]\n        index += 1 + n\n\n        if can_draw_ticks(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to mark visited cells\n    visited = [[False] * m for _ in range(n)]\n\n    # Function to check if a tick of size d can be centered at (i, j)\n    def can_draw_tick(i, j, d):\n        for h in range(d + 1):\n            if i - h < 0 or j - h < 0 or j + h >= m:\n                return False\n            if field[i - h][j - h] != '*' or field[i - h][j + h] != '*':\n                return False\n        return True\n\n    # Mark all cells that can be part of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Find the largest possible tick size centered at (i, j)\n                d = 0\n                while can_draw_tick(i, j, d):\n                    d += 1\n                d -= 1  # The last increment was invalid, so reduce by 1\n\n                # If the tick size is at least k, mark the cells as visited\n                if d >= k:\n                    for h in range(d + 1):\n                        visited[i - h][j - h] = True\n                        visited[i - h][j + h] = True\n\n    # Check if all '*' cells are visited\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not visited[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a matrix to track if a cell is covered by a tick\n    covered = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to find potential tick centers\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size at least k can be drawn\n                size = 0\n                while True:\n                    if i - size < 0 or j - size < 0 or j + size >= m:\n                        break\n                    if field[i - size][j - size] != '*' or field[i - size][j + size] != '*':\n                        break\n                    size += 1\n\n                # If the tick size is at least k, mark the cells as covered\n                if size > k:\n                    for h in range(size):\n                        covered[i - h][j - h] = True\n                        covered[i - h][j + h] = True\n\n    # Check if all '*' cells are covered\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = [data[index + i + 1] for i in range(n)]\n        index += n + 1\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a 2D list to mark cells that are part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Check for each cell if it can be the center of a tick of size d >= k\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Determine the maximum possible size of the tick centered at (i, j)\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Verify if all '*' in the field are part of a valid tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a boolean matrix to mark cells that can be covered by ticks\n    covered = [[False] * m for _ in range(n)]\n\n    # Iterate from bottom to top to ensure we can check for valid ticks\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size at least k can be centered at (i, j)\n                size = 0\n                while True:\n                    if i - size < 0 or j - size < 0 or j + size >= m:\n                        break\n                    if field[i - size][j - size] != '*' or field[i - size][j + size] != '*':\n                        break\n                    size += 1\n\n                # If the tick size is at least k, mark the cells as covered\n                if size > k:\n                    for h in range(size):\n                        covered[i - h][j - h] = True\n                        covered[i - h][j + h] = True\n\n    # Check if all '*' in the field are covered\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_form_ticks(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a matrix to mark cells that can be covered by ticks\n    covered = [[False] * m for _ in range(n)]\n\n    # Iterate from bottom to top to find potential tick centers\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size at least k can be formed with center at (i, j)\n                size = 0\n                while True:\n                    if i - size < 0 or j - size < 0 or j + size >= m:\n                        break\n                    if field[i - size][j - size] == '*' and field[i - size][j + size] == '*':\n                        size += 1\n                    else:\n                        break\n\n                # If a tick of size at least k is found, mark the cells as covered\n                if size > k:\n                    for h in range(size):\n                        covered[i - h][j - h] = True\n                        covered[i - h][j + h] = True\n\n    # Check if all '*' in the field are covered\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return False\n\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_form_ticks(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a helper grid to mark cells that can be part of a valid tick\n    valid_tick = [[False] * m for _ in range(n)]\n\n    # Iterate from bottom to top to check for possible tick centers\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check the maximum size of the tick that can be formed with (i, j) as the center\n                d = 0\n                while (i - d >= 0 and j - d >= 0 and j + d < m and\n                       field[i - d][j - d] == '*' and field[i - d][j + d] == '*'):\n                    d += 1\n                d -= 1  # Adjust d to the last valid size\n\n                # If the tick size is at least k, mark the cells as valid\n                if d >= k:\n                    for h in range(d + 1):\n                        valid_tick[i - h][j - h] = True\n                        valid_tick[i - h][j + h] = True\n\n    # Check if all '*' in the field are part of a valid tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not valid_tick[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to mark cells that can be part of a tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to check if it can be the center of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size d >= k can be formed with center at (i, j)\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If a tick of size d >= k is found, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n                    marked[i][j] = True\n\n    # Check if all '*' cells are marked\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a 2D list to mark cells that are covered by valid ticks\n    covered = [[False] * m for _ in range(n)]\n\n    # Iterate from bottom to top to ensure we can check for valid ticks\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if we can form a tick with center at (i, j)\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells as covered\n                if d > k:\n                    for h in range(d):\n                        covered[i - h][j - h] = True\n                        covered[i - h][j + h] = True\n\n    # Check if all '*' in the field are covered by valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the dimensions of the field, the minimum tick size, and the field's configuration.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, identify potential tick centers by iterating over each cell in the field and checking if it can be the center of a tick of size at least k.\",\n      \"output\": \"A list of potential tick centers for each test case.\"\n    },\n    {\n      \"description\": \"For each potential tick center, verify if a tick of size at least k can be drawn by checking the required cells diagonally from the center.\",\n      \"output\": \"A boolean value indicating whether a valid tick can be drawn for each potential center.\"\n    },\n    {\n      \"description\": \"Determine if the entire field can be explained by the ticks identified, ensuring all '*' cells are covered by valid ticks.\",\n      \"output\": \"A boolean value indicating whether the field can be obtained by drawing ticks of size at least k.\"\n    },\n    {\n      \"description\": \"Generate the output for each test case based on the results of the previous steps, indicating 'YES' or 'NO'.\",\n      \"output\": \"A list of results for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, iterate over each cell in the field to identify potential tick centers.\",\n    \"For each potential tick center, check if a tick of size at least k can be drawn by verifying the required diagonal cells.\",\n    \"Ensure all '*' cells in the field are covered by valid ticks. If any '*' cell is not covered, mark the test case as 'NO'.\",\n    \"Compile the results for each test case and print 'YES' or 'NO' based on whether the field can be obtained by drawing the required ticks.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a 2D list to mark cells that are covered by valid ticks\n    covered = [[False] * m for _ in range(n)]\n\n    # Iterate from bottom to top to ensure we can check for valid ticks\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if we can form a tick with center at (i, j)\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells as covered\n                if d > k:\n                    for h in range(d):\n                        covered[i - h][j - h] = True\n                        covered[i - h][j + h] = True\n\n    # Check if all '*' in the field are covered by valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, field dimensions, minimum tick size, and field patterns.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions n, m, and k.\",\n        \"Read the n lines representing the field pattern.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a tick of size d >= k can be drawn for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if the cell can be the center of a tick of size d >= k.\",\n        \"Verify that the tick can be drawn without violating the field pattern.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output 'YES' if the field can be obtained by drawing ticks of size d >= k, otherwise output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the necessary information for each test case.\",\n    \"For each test case, iterate over the field to check if ticks of size d >= k can be drawn.\",\n    \"Implement a function to verify if a tick can be drawn from a given center cell.\",\n    \"Output the result for each test case based on the verification.\"\n  ]\n}\n```", "Round_0": {"code": "def can_draw_ticks(n, m, k, field):\n    # Create a copy of the field to mark the cells that can be part of a tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to check if it can be the center of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size d >= k can be drawn with center at (i, j)\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If a tick of size d >= k is found, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Check if all '*' in the field are part of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_draw_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 85)"}, "Round_1": {"code": "def can_draw_ticks(n, m, k, field):\n    # Create a copy of the field to mark the cells that can be part of a tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to check if it can be the center of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size d >= k can be drawn with center at (i, j)\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If a tick of size d >= k is found, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Check if all '*' in the field are part of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_draw_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the dimensions of the field and the minimum tick size.\",\n      \"output\": \"A list of test cases, each containing the dimensions (n, m), minimum tick size (k), and the field representation as a list of strings.\"\n    },\n    {\n      \"description\": \"For each test case, identify potential tick centers by iterating over each cell in the field and checking if it can be the center of a tick of size at least k.\",\n      \"output\": \"A list of potential tick centers for each test case.\"\n    },\n    {\n      \"description\": \"For each potential tick center, verify if a tick of size at least k can be drawn by checking the required cells in the top-left and top-right diagonals.\",\n      \"output\": \"A boolean value indicating whether a valid tick can be drawn for each potential center.\"\n    },\n    {\n      \"description\": \"Mark cells that are part of valid ticks to ensure they are covered by at least one tick.\",\n      \"output\": \"A modified field representation where cells part of valid ticks are marked.\"\n    },\n    {\n      \"description\": \"Check if all '*' cells in the original field are covered by valid ticks by comparing the modified field with the original.\",\n      \"output\": \"A boolean value indicating whether the field can be obtained by drawing ticks of size at least k.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, iterate over each cell in the field to identify potential tick centers.\",\n    \"For each potential tick center, check if a tick of size at least k can be drawn.\",\n    \"Mark cells that are part of valid ticks.\",\n    \"Compare the modified field with the original to determine if all '*' cells are covered by valid ticks.\",\n    \"Output 'YES' if the field can be obtained by drawing ticks, otherwise output 'NO'.\"\n  ]\n}\n```", "Round_0": {"code": "def can_draw_ticks(n, m, k, field):\n    # Create a boolean matrix to mark cells that are covered by valid ticks\n    covered = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to find potential tick centers\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size at least k can be drawn with center at (i, j)\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells as covered\n                if d > k:\n                    for h in range(d):\n                        covered[i - h][j - h] = True\n                        covered[i - h][j + h] = True\n\n    # Check if all '*' cells in the original field are covered by valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = data[index + 1:index + 1 + n]\n        index += 1 + n\n\n        if can_draw_ticks(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: can_draw_ticks() missing 4 required positional arguments: 'n', 'm', 'k', and 'field'"}, "Round_1": {"code": "def can_draw_ticks(n, m, k, field):\n    # Create a boolean matrix to mark cells that are covered by valid ticks\n    covered = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to find potential tick centers\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size at least k can be drawn with center at (i, j)\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells as covered\n                if d > k:\n                    for h in range(d):\n                        covered[i - h][j - h] = True\n                        covered[i - h][j + h] = True\n\n    # Check if all '*' cells in the original field are covered by valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = data[index + 1:index + 1 + n]\n        index += 1 + n\n\n        if can_draw_ticks(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, field dimensions, minimum tick size, and field patterns.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n, m, and k representing the field dimensions and minimum tick size.\",\n        \"Read the next n lines to capture the field pattern consisting of '.' and '*' characters.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a tick of size d >= k can be drawn for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if the cell can be the center of a tick of size d >= k.\",\n        \"Verify if the diagonals from the center cell can be painted according to the tick rules.\",\n        \"Ensure all '*' cells can be part of a valid tick.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output 'YES' if the field can be obtained by drawing ticks of size d >= k, otherwise output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and field details.\",\n    \"For each test case, analyze the field to determine if it can be constructed using valid ticks.\",\n    \"Output the result for each test case based on the analysis.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to mark visited cells\n    visited = [[False] * m for _ in range(n)]\n\n    # Function to check if a tick of size d can be centered at (i, j)\n    def can_draw_tick(i, j, d):\n        for h in range(d + 1):\n            if i - h < 0 or j - h < 0 or j + h >= m:\n                return False\n            if field[i - h][j - h] != '*' or field[i - h][j + h] != '*':\n                return False\n        return True\n\n    # Mark all cells that can be part of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Find the largest possible tick size centered at (i, j)\n                d = 0\n                while can_draw_tick(i, j, d):\n                    d += 1\n                d -= 1  # The last increment was invalid, so reduce by 1\n\n                # If the tick size is at least k, mark the cells as visited\n                if d >= k:\n                    for h in range(d + 1):\n                        visited[i - h][j - h] = True\n                        visited[i - h][j + h] = True\n\n    # Check if all '*' cells are visited\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not visited[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the dimensions of the field, the minimum tick size, and the field's configuration.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, identify potential tick centers by iterating over each cell in the field and checking if it can be the center of a tick of size at least k.\",\n      \"output\": \"A list of potential tick centers for each test case.\"\n    },\n    {\n      \"description\": \"For each potential tick center, verify if a tick of size at least k can be drawn by checking the top-left and top-right diagonals for the required number of black cells.\",\n      \"output\": \"A boolean value indicating whether a valid tick can be drawn for each potential center.\"\n    },\n    {\n      \"description\": \"Determine if the entire field can be explained by the ticks identified, ensuring all '*' cells are covered by at least one tick.\",\n      \"output\": \"A boolean value indicating whether the field can be fully explained by the ticks.\"\n    },\n    {\n      \"description\": \"Generate the output for each test case based on whether the field can be explained by the ticks.\",\n      \"output\": \"A list of 'YES' or 'NO' for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, iterate over each cell in the field to identify potential tick centers.\",\n    \"For each potential tick center, check if a tick of size at least k can be drawn by verifying the diagonals.\",\n    \"Ensure all '*' cells in the field are covered by at least one valid tick.\",\n    \"Output 'YES' if the field can be explained by the ticks, otherwise output 'NO'.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a matrix to track if a cell is covered by a tick\n    covered = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to find potential tick centers\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size at least k can be drawn\n                size = 0\n                while True:\n                    if i - size < 0 or j - size < 0 or j + size >= m:\n                        break\n                    if field[i - size][j - size] != '*' or field[i - size][j + size] != '*':\n                        break\n                    size += 1\n\n                # If the tick size is at least k, mark the cells as covered\n                if size > k:\n                    for h in range(size):\n                        covered[i - h][j - h] = True\n                        covered[i - h][j + h] = True\n\n    # Check if all '*' cells are covered\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = [data[index + i + 1] for i in range(n)]\n        index += n + 1\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case including the dimensions of the field, minimum tick size, and the field itself.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read the integers n, m, and k representing the field dimensions and minimum tick size.\",\n        \"Read the next n lines to capture the field configuration as a list of strings.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the field can be obtained by drawing ticks of at least the given size.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field to identify potential tick centers.\",\n        \"For each potential tick center (i, j), check if a tick of size d >= k can be drawn.\",\n        \"Ensure that for each tick, the cells on both diagonals are painted black and remain within the field boundaries.\",\n        \"Mark cells that are part of a valid tick to avoid re-evaluation.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if the field configuration can be achieved with ticks of size d >= k, output 'YES'.\",\n        \"Otherwise, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test case details.\",\n    \"For each test case, iterate over the field to identify potential tick centers.\",\n    \"Validate if ticks of size d >= k can be drawn from each center.\",\n    \"Output 'YES' if the field can be achieved with valid ticks, otherwise output 'NO'.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a 2D list to mark cells that are part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Check for each cell if it can be the center of a tick of size d >= k\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Determine the maximum possible size of the tick centered at (i, j)\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # Verify if all '*' in the field are part of a valid tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the dimensions of the field, the minimum tick size, and the field itself.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, identify potential tick centers by iterating over each cell in the field and checking if it can be the center of a tick of size at least k.\",\n      \"output\": \"A list of potential tick centers for each test case.\"\n    },\n    {\n      \"description\": \"For each potential tick center, verify if a tick of size at least k can be drawn by checking the required cells diagonally from the center.\",\n      \"output\": \"A boolean value indicating whether a valid tick can be drawn for each potential center.\"\n    },\n    {\n      \"description\": \"Mark the cells covered by valid ticks to ensure no cell is left unaccounted for.\",\n      \"output\": \"A modified field representation where cells covered by valid ticks are marked.\"\n    },\n    {\n      \"description\": \"Compare the modified field with the original field to determine if all '*' cells can be accounted for by valid ticks.\",\n      \"output\": \"A boolean value indicating whether the field can be obtained by drawing ticks of size at least k.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, iterate over each cell in the field to identify potential tick centers.\",\n    \"For each potential tick center, check if a tick of size at least k can be drawn by verifying the required diagonal cells.\",\n    \"Mark the cells covered by valid ticks in a separate field representation.\",\n    \"Compare the modified field with the original field to check if all '*' cells are covered by valid ticks.\",\n    \"Output 'YES' if the field can be obtained by drawing ticks of size at least k, otherwise output 'NO'.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a boolean matrix to mark cells that can be covered by ticks\n    covered = [[False] * m for _ in range(n)]\n\n    # Iterate from bottom to top to ensure we can check for valid ticks\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size at least k can be centered at (i, j)\n                size = 0\n                while True:\n                    if i - size < 0 or j - size < 0 or j + size >= m:\n                        break\n                    if field[i - size][j - size] != '*' or field[i - size][j + size] != '*':\n                        break\n                    size += 1\n\n                # If the tick size is at least k, mark the cells as covered\n                if size > k:\n                    for h in range(size):\n                        covered[i - h][j - h] = True\n                        covered[i - h][j + h] = True\n\n    # Check if all '*' in the field are covered\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_form_ticks(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the dimensions of the field, the minimum tick size, and the field's configuration.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, identify potential tick centers by iterating over each cell in the field and checking if it can be the center of a tick of size at least k.\",\n      \"output\": \"A list of potential tick centers for each test case.\"\n    },\n    {\n      \"description\": \"For each potential tick center, verify if a tick of size at least k can be drawn by checking the required cells diagonally from the center.\",\n      \"output\": \"A boolean value indicating whether a valid tick can be drawn for each potential center.\"\n    },\n    {\n      \"description\": \"Determine if the entire field can be explained by the ticks identified, ensuring all '*' cells are covered by valid ticks.\",\n      \"output\": \"A boolean value indicating whether the field can be obtained by drawing ticks of size at least k.\"\n    },\n    {\n      \"description\": \"Generate the output for each test case based on the results of the previous steps, indicating 'YES' or 'NO'.\",\n      \"output\": \"A list of results for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, iterate over each cell in the field to identify potential tick centers.\",\n    \"For each potential tick center, check if a tick of size at least k can be drawn by verifying the required diagonal cells.\",\n    \"Ensure all '*' cells in the field are covered by valid ticks.\",\n    \"For each test case, output 'YES' if the field can be obtained by drawing ticks of size at least k, otherwise output 'NO'.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a matrix to mark cells that can be covered by ticks\n    covered = [[False] * m for _ in range(n)]\n\n    # Iterate from bottom to top to find potential tick centers\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size at least k can be formed with center at (i, j)\n                size = 0\n                while True:\n                    if i - size < 0 or j - size < 0 or j + size >= m:\n                        break\n                    if field[i - size][j - size] == '*' and field[i - size][j + size] == '*':\n                        size += 1\n                    else:\n                        break\n\n                # If a tick of size at least k is found, mark the cells as covered\n                if size > k:\n                    for h in range(size):\n                        covered[i - h][j - h] = True\n                        covered[i - h][j + h] = True\n\n    # Check if all '*' in the field are covered\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return False\n\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_form_ticks(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: can_form_ticks() missing 4 required positional arguments: 'n', 'm', 'k', and 'field'"}, "Round_1": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a matrix to mark cells that can be covered by ticks\n    covered = [[False] * m for _ in range(n)]\n\n    # Iterate from bottom to top to find potential tick centers\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size at least k can be formed with center at (i, j)\n                size = 0\n                while True:\n                    if i - size < 0 or j - size < 0 or j + size >= m:\n                        break\n                    if field[i - size][j - size] == '*' and field[i - size][j + size] == '*':\n                        size += 1\n                    else:\n                        break\n\n                # If a tick of size at least k is found, mark the cells as covered\n                if size > k:\n                    for h in range(size):\n                        covered[i - h][j - h] = True\n                        covered[i - h][j + h] = True\n\n    # Check if all '*' in the field are covered\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return False\n\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_form_ticks(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case including the dimensions of the field, minimum tick size, and the field itself.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n, m, and k representing the dimensions of the field and the minimum tick size.\",\n        \"Read the next n lines to capture the field configuration as a list of strings.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a tick of size d >= k can be drawn for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field to check if it can be the center of a tick of size d >= k.\",\n        \"For a cell (i, j) to be the center of a tick, ensure that the cells (i-h, j-h) and (i-h, j+h) for h = 0 to d are all marked with '*'.\",\n        \"Check if the tick size d is at least k.\"\n      ]\n    },\n    {\n      \"description\": \"Validate the field configuration against the tick drawing rules.\",\n      \"steps\": [\n        \"For each test case, verify if all '*' cells can be part of a valid tick of size d >= k.\",\n        \"If any '*' cell cannot be part of a valid tick, mark the test case as 'NO'.\",\n        \"Otherwise, mark the test case as 'YES'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, iterate over the field to identify potential tick centers and validate tick sizes.\",\n    \"Check if all '*' cells can be part of valid ticks of size d >= k.\",\n    \"Output 'YES' if the field configuration is valid, otherwise output 'NO'.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a helper grid to mark cells that can be part of a valid tick\n    valid_tick = [[False] * m for _ in range(n)]\n\n    # Iterate from bottom to top to check for possible tick centers\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check the maximum size of the tick that can be formed with (i, j) as the center\n                d = 0\n                while (i - d >= 0 and j - d >= 0 and j + d < m and\n                       field[i - d][j - d] == '*' and field[i - d][j + d] == '*'):\n                    d += 1\n                d -= 1  # Adjust d to the last valid size\n\n                # If the tick size is at least k, mark the cells as valid\n                if d >= k:\n                    for h in range(d + 1):\n                        valid_tick[i - h][j - h] = True\n                        valid_tick[i - h][j + h] = True\n\n    # Check if all '*' in the field are part of a valid tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not valid_tick[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, field dimensions, minimum tick size, and field patterns.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n, m, and k representing the field dimensions and minimum tick size.\",\n        \"Read the next n lines to capture the field pattern consisting of '.' and '*' characters.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a tick of size d >= k can be drawn for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if the cell can be the center of a tick of size d >= k.\",\n        \"Verify if the diagonals from the center cell can be painted according to the tick rules.\",\n        \"Ensure all '*' cells can be part of a valid tick.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output 'YES' if the field can be obtained by drawing ticks of size d >= k, otherwise output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and field details.\",\n    \"For each test case, analyze the field to determine if it can be constructed using valid ticks.\",\n    \"Output the result for each test case based on the analysis.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to mark cells that can be part of a tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to check if it can be the center of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size d >= k can be formed with center at (i, j)\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If a tick of size d >= k is found, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n                    marked[i][j] = True\n\n    # Check if all '*' cells are marked\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 93)"}, "Round_1": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to mark cells that can be part of a tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell to check if it can be the center of a tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size d >= k can be formed with center at (i, j)\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If a tick of size d >= k is found, mark the cells\n                if d > k:\n                    for h in range(d):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n                    marked[i][j] = True\n\n    # Check if all '*' cells are marked\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the dimensions of the field, the minimum tick size, and the field's configuration.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, identify potential tick centers by iterating over each cell in the field and checking if it can be the center of a tick of size at least k.\",\n      \"output\": \"A list of potential tick centers for each test case.\"\n    },\n    {\n      \"description\": \"For each potential tick center, verify if a tick of size at least k can be drawn by checking the required cells diagonally from the center.\",\n      \"output\": \"A boolean value indicating whether a valid tick can be drawn for each potential center.\"\n    },\n    {\n      \"description\": \"Determine if the entire field can be explained by the ticks identified, ensuring all '*' cells are covered by valid ticks.\",\n      \"output\": \"A boolean value indicating whether the field can be obtained by drawing ticks of size at least k.\"\n    },\n    {\n      \"description\": \"Generate the output for each test case based on the results of the previous steps, indicating 'YES' or 'NO'.\",\n      \"output\": \"A list of results for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, iterate over each cell in the field to identify potential tick centers.\",\n    \"For each potential tick center, check if a tick of size at least k can be drawn by verifying the required diagonal cells.\",\n    \"Ensure all '*' cells in the field are covered by valid ticks. If any '*' cell is not covered, mark the test case as 'NO'.\",\n    \"Compile the results for each test case and print 'YES' or 'NO' based on whether the field can be obtained by drawing the required ticks.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a 2D list to mark cells that are covered by valid ticks\n    covered = [[False] * m for _ in range(n)]\n\n    # Iterate from bottom to top to ensure we can check for valid ticks\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if we can form a tick with center at (i, j)\n                d = 0\n                while True:\n                    if i - d < 0 or j - d < 0 or j + d >= m:\n                        break\n                    if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                        break\n                    d += 1\n\n                # If the tick size is at least k, mark the cells as covered\n                if d > k:\n                    for h in range(d):\n                        covered[i - h][j - h] = True\n                        covered[i - h][j + h] = True\n\n    # Check if all '*' in the field are covered by valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 7, "prompt": "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white. Let us denote the cell with coordinates i vertically and j horizontally by (i, j), where the upper left cell is referred to as (1, 1) and the lower right cell as (n, m). Casimir draws ticks of different sizes on the field, where a tick of size d (d > 0) with its center in cell (i, j) is drawn by painting the center cell (i, j) black and then painting exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center black. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted, resulting in a tick consisting of 2d + 1 black cells. An already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3. <image> You are given a description of a checkered field of size n \u00d7 m, which Casimir claims was created by drawing some (possibly 0) ticks on it. The ticks could vary in size, but the size of each tick is at least k (that is, d \u2265 k for all the ticks). Determine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 7}
