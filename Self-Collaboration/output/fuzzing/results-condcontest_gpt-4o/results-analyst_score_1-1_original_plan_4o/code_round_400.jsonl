{"name": "1582_A. Luntik and Concerts", "description": "Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.\n\nHe wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.\n\nPlease help Luntik and find the minimal possible difference in minutes between the concerts durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "tags": ["math"], "difficulty": 7, "id": 1582, "sample_io": [{"input": "4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}], "test_list": [{"input": "4\n1 1 1\n2 1 3\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 2 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n4 2 0\n6 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n5 4 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n0 2 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 4 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 4 1\n4 2 0\n10 4 5\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 5\n2 1 2\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 4\n2 2 2\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 8 4\n2 2 2\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 1 5\n1 1 1\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 0\n2 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 0\n4 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n7 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n4 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 1\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 2 5\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 4 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 1 1\n3 2 8\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n1 2 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 7\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n1 2 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 2 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 9\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n4 1 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n4 2 1\n6 4 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 0\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n4 1 1\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 8\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 5\n1 2 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 2 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n6 4 9\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 4\n4 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 3 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n2 4 0\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 5\n1 1 6\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 1\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n1 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 3 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 1 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 9\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n0 2 4\n4 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 3 2\n3 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 4 5\n1 1 4\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n10 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n2 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 1\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 9\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 3 5\n1 1 4\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 4 0\n4 2 0\n10 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n2 4 0\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n6 2 1\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 2 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 3\n2 2 2\n3 2 3\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 1\n6 4 9\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n4 2 1\n6 3 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n1 4 0\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 2 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 8 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 1 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 4 1\n4 2 1\n6 3 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n4 2 0\n10 4 3\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n1 4 0\n1 1 0\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 1 1\n2 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 3\n2 2 2\n3 2 1\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 5\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n10 4 3\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 1 1\n4 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 1\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 5\n2 2 2\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n2 1 1\n2 3 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 4\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n6 4 3\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 1 1\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 5 4\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n6 4 6\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 1 2\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 3\n1 1 6\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n7 2 1\n6 4 6\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n2 2 3\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n3 8 4\n2 2 2\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 2\n1 1 6\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 1\n6 4 4\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n1 2 3\n3 1 2\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n4 8 4\n2 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n2 3 1\n10 4 2\n1 1 6\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 4\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n1 2 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n4 8 4\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n3 3 1\n10 4 2\n1 1 6\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 3\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 2 6\n1 1 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n4 8 4\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n3 3 1\n10 4 0\n1 1 6\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 2\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 4 6\n1 1 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n4 8 6\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 3 2\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n4 1 3\n5 5 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 2 1\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n4 2 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n4 1 1\n4 2 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n4 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 1 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n4 2 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 4 5\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 0\n5 2 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 0\n2 1 1\n3 2 5\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n4 2 1\n12 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 3 3\n7 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n4 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 0\n4 2 1\n6 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 0 0\n4 2 1\n6 4 1\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 4 5\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 4 1\n2 1 1\n3 2 10\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n2 4 5\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 2\n2 2 1\n3 2 2\n1 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n11 4 9\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 3 3\n4 1 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 2 2\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n9 4 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 0\n1 1 1\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 6\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 1 8\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n1 4 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 2 2\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 4\n2 2 1\n6 4 9\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 4\n3 1 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 4 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n4 2 0\n5 4 5\n1 1 0\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 1 1\n6 2 5\n1 1 6\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 4 1\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n1 1 1\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n2 3 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n4 1 2\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 7 9\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n0 2 4\n6 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 0\n4 3 2\n3 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n5 2 1\n3 4 5\n1 1 4\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4 2 1\n4 2 1\n2 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n2 2 0\n0 2 2\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 8\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 13\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 3 5\n1 1 1\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n1 2 0\n2 1 1\n6 2 1\n2 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 2 1\n0 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 6 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 2 1\n4 3 1\n1 4 0\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 2 1\n6 2 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 5 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 10\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 2 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 4 1\n4 2 1\n6 1 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 4 1\n4 2 0\n10 4 3\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n3 2 1\n1 4 0\n1 1 0\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 1 1\n2 2 1\n3 4 0\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 3\n2 2 1\n3 2 1\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n1 2 1\n3 8 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 4 1\n7 2 0\n10 4 3\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 1\n1 1 4\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 8 5\n2 2 2\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n2 1 1\n3 3 1\n6 4 3\n1 1 3\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 2\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}], "task_id": "codecontest/28", "repair_prompt": ["Luntik has decided to try singing. He has a one-minute songs, b two-minute songs, and c three-minute songs and wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Some insight into the optimal distribution strategy would be a great help. Consider exploring combinations of song distributions that approach a balance in total time for each concert. The challenge lies in minimizing the difference in concert durations while distributing varying song lengths effectively.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The goal is to split total_duration into two parts as evenly as possible\n        # We need to find the closest sum to total_duration // 2\n        half_duration = total_duration // 2\n        \n        # Initialize a set to store possible sums we can achieve\n        possible_sums = {0}\n        \n        # Try to achieve different sums using the songs\n        for _ in range(a):\n            possible_sums.update({x + 1 for x in possible_sums})\n        for _ in range(b):\n            possible_sums.update({x + 2 for x in possible_sums})\n        for _ in range(c):\n            possible_sums.update({x + 3 for x in possible_sums})\n        \n        # Find the closest sum to half_duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "completions": ["def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Calculate the minimal possible difference\n        # The difference is determined by the parity of the total duration\n        min_difference = total_duration % 2\n        \n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n\n        # Dynamic programming approach to find the closest sum to half_duration\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n\n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n\n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(half_duration, 0, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n\n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(half_duration, 0, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n\n        # Find the closest sum to half_duration\n        closest_sum = 0\n        for i in range(half_duration, -1, -1):\n            if dp[i]:\n                closest_sum = i\n                break\n\n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The goal is to find the closest sum to total_duration // 2\n        # Using a dynamic programming approach to solve this subset sum problem\n        max_possible_sum = total_duration // 2\n        dp = [False] * (max_possible_sum + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_sum, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_sum, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_sum, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum close to total_duration // 2\n        best_sum = 0\n        for j in range(max_possible_sum + 1):\n            if dp[j]:\n                best_sum = j\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * best_sum)\n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # We need to find the closest sum to total_duration // 2\n        target = total_duration // 2\n\n        # Dynamic programming approach to find the closest sum to target\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        # Process 1-minute songs\n        for _ in range(a):\n            for j in range(target, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n\n        # Process 2-minute songs\n        for _ in range(b):\n            for j in range(target, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n\n        # Process 3-minute songs\n        for _ in range(c):\n            for j in range(target, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n\n        # Find the best possible sum close to target\n        best_sum = 0\n        for i in range(target + 1):\n            if dp[i]:\n                best_sum = i\n\n        # Calculate the minimal difference\n        min_difference = abs(total_duration - 2 * best_sum)\n        results.append(min_difference)\n\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n\n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n        \n        # Use a set to track possible sums\n        possible_sums = {0}\n        \n        # Process one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Process two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Process three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the closest sum to half_duration\n        closest_sum = max(s for s in possible_sums if s <= half_duration)\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # The goal is to find the closest possible sum to total_duration // 2\n        # This is a variation of the subset sum problem\n        max_possible_sum = total_duration // 2\n        dp = [False] * (max_possible_sum + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_sum, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_sum, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_sum, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum\n        best_sum = 0\n        for j in range(max_possible_sum + 1):\n            if dp[j]:\n                best_sum = j\n        \n        # Calculate the minimal difference\n        minimal_diff = abs(total_duration - 2 * best_sum)\n        results.append(minimal_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The goal is to split the total_duration into two parts as evenly as possible\n        # We need to find the closest sum to total_duration // 2 using the available songs\n        \n        # Initialize a set to store possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the minimal possible difference\n        half_duration = total_duration // 2\n        min_diff = float('inf')\n        \n        for s in possible_sums:\n            min_diff = min(min_diff, abs(total_duration - 2 * s))\n        \n        results.append(min_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The goal is to split the total_duration into two parts as evenly as possible\n        # We need to find the closest sum to total_duration // 2 using the given songs\n        \n        # Initialize a set to store possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the minimal possible difference\n        half_duration = total_duration // 2\n        min_diff = float('inf')\n        for s in possible_sums:\n            min_diff = min(min_diff, abs(total_duration - 2 * s))\n        \n        results.append(min_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n        \n        # Initialize a set to store possible sums we can achieve\n        possible_sums = {0}\n        \n        # Try to add each song type to the possible sums\n        for _ in range(a):\n            possible_sums = {x + 1 for x in possible_sums} | possible_sums\n        for _ in range(b):\n            possible_sums = {x + 2 for x in possible_sums} | possible_sums\n        for _ in range(c):\n            possible_sums = {x + 3 for x in possible_sums} | possible_sums\n        \n        # Find the closest sum to half_duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * closest_sum)\n        results.append(min_difference)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The goal is to split total_duration into two parts as evenly as possible\n        # We need to find the closest sum to total_duration // 2\n        half_duration = total_duration // 2\n        \n        # Initialize a set to store possible sums we can achieve\n        possible_sums = {0}\n        \n        # Try to achieve different sums using the songs\n        for _ in range(a):\n            possible_sums.update({x + 1 for x in possible_sums})\n        for _ in range(b):\n            possible_sums.update({x + 2 for x in possible_sums})\n        for _ in range(c):\n            possible_sums.update({x + 3 for x in possible_sums})\n        \n        # Find the closest sum to half_duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of songs of each duration for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integers a, b, c from the input, representing the number of one-minute, two-minute, and three-minute songs respectively.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"steps\": [\n        \"For each test case, compute the total duration of all songs as total_duration = a * 1 + b * 2 + c * 3.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in concert durations.\",\n      \"steps\": [\n        \"For each test case, explore combinations of song distributions between two concerts.\",\n        \"Calculate the duration of each possible distribution and find the distribution that minimizes the absolute difference between the two concert durations.\",\n        \"Use a strategy to balance the total time for each concert, considering the varying song lengths.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimal possible difference for each test case.\",\n      \"steps\": [\n        \"For each test case, print the minimal possible difference in minutes between the concert durations.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and song counts for each test case.\",\n    \"For each test case, calculate the total duration of all songs.\",\n    \"For each test case, determine the minimal possible difference in concert durations by exploring song distribution combinations.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # The goal is to split total_duration into two parts as evenly as possible\n        # We need to find the closest sum to total_duration // 2\n        half_duration = total_duration // 2\n        \n        # Initialize a set to store possible sums we can achieve\n        possible_sums = {0}\n        \n        # Try to achieve different sums using the songs\n        for _ in range(a):\n            possible_sums.update({x + 1 for x in possible_sums})\n        for _ in range(b):\n            possible_sums.update({x + 2 for x in possible_sums})\n        for _ in range(c):\n            possible_sums.update({x + 3 for x in possible_sums})\n        \n        # Find the closest sum to half_duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The goal is to split total_duration into two parts as evenly as possible\n        # We need to find the closest sum to total_duration // 2\n        half_duration = total_duration // 2\n        \n        # Initialize a set to store possible sums we can achieve\n        possible_sums = {0}\n        \n        # Try to achieve different sums using the songs\n        for _ in range(a):\n            possible_sums.update({x + 1 for x in possible_sums})\n        for _ in range(b):\n            possible_sums.update({x + 2 for x in possible_sums})\n        for _ in range(c):\n            possible_sums.update({x + 3 for x in possible_sums})\n        \n        # Find the closest sum to half_duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"goal\": \"Extract and store the input data for processing.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total duration of all songs combined.\",\n      \"goal\": \"Determine the total duration of songs to understand the distribution challenge.\"\n    },\n    {\n      \"description\": \"Determine the possible ways to distribute the songs into two concerts such that the absolute difference in their durations is minimized.\",\n      \"goal\": \"Explore combinations of song distributions to find the minimal difference in concert durations.\"\n    },\n    {\n      \"description\": \"Calculate the minimal possible difference in minutes between the durations of the two concerts for each test case.\",\n      \"goal\": \"Output the minimal difference for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the number of one-minute, two-minute, and three-minute songs.\",\n    \"  b. Calculate the total duration of all songs.\",\n    \"  c. Use a dynamic programming approach to explore possible distributions of songs into two concerts.\",\n    \"  d. Calculate the absolute difference in durations for each distribution and track the minimal difference.\",\n    \"  e. Store the minimal difference for the current test case.\",\n    \"Output the minimal difference for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # We need to find the closest sum to total_duration // 2\n        target = total_duration // 2\n        \n        # Dynamic programming approach\n        # dp[i] will be True if a sum of i can be achieved\n        dp = [False] * (target + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(target, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(target, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(target, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the closest sum to target\n        for i in range(target, -1, -1):\n            if dp[i]:\n                closest_sum = i\n                break\n        \n        # Calculate the minimal difference\n        min_difference = abs(total_duration - 2 * closest_sum)\n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Calculate the minimal possible difference\n        # The difference is determined by the parity of the total duration\n        min_difference = total_duration % 2\n        \n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"goal\": \"Extract and store the input data in a structured format for further processing.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total duration of all songs combined.\",\n      \"goal\": \"Determine the total duration of songs to understand the distribution challenge.\"\n    },\n    {\n      \"description\": \"Determine the possible ways to distribute songs into two concerts to minimize the absolute difference in their durations.\",\n      \"goal\": \"Explore combinations of song distributions to find the optimal balance.\"\n    },\n    {\n      \"description\": \"Calculate the minimal possible difference in durations between the two concerts for each test case.\",\n      \"goal\": \"Output the minimal difference for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the number of one-minute, two-minute, and three-minute songs.\",\n    \"  b. Calculate the total duration of all songs.\",\n    \"  c. Use a dynamic programming approach to explore possible distributions of songs into two concerts.\",\n    \"  d. Calculate the absolute difference in durations for each distribution and track the minimal difference.\",\n    \"  e. Store the minimal difference for the current test case.\",\n    \"Output the minimal differences for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n\n        # Dynamic programming approach to find the closest sum to half_duration\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n\n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n\n        for _ in range(b):\n            for j in range(half_duration, 0, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n\n        for _ in range(c):\n            for j in range(half_duration, 0, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n\n        # Find the closest sum to half_duration\n        closest_sum = 0\n        for i in range(half_duration, -1, -1):\n            if dp[i]:\n                closest_sum = i\n                break\n\n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n\n        # Dynamic programming approach to find the closest sum to half_duration\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n\n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n\n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(half_duration, 0, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n\n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(half_duration, 0, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n\n        # Find the closest sum to half_duration\n        closest_sum = 0\n        for i in range(half_duration, -1, -1):\n            if dp[i]:\n                closest_sum = i\n                break\n\n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"input\": \"A single integer t followed by t lines, each containing three integers a, b, c.\",\n      \"output\": \"A list of tuples, each containing three integers (a, b, c) for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"input\": \"A tuple (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the total duration of all songs.\"\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in concert durations by exploring combinations of song distributions.\",\n      \"input\": \"The total duration of all songs and the number of each type of song (a, b, c).\",\n      \"output\": \"An integer representing the minimal possible difference in minutes between the concert durations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases and the number of each type of song for each test case.\",\n    \"For each test case, calculate the total duration of all songs using the formula: total_duration = a * 1 + b * 2 + c * 3.\",\n    \"For each test case, explore possible distributions of songs into two concerts to minimize the absolute difference in their durations.\",\n    \"Use a dynamic programming approach or a greedy strategy to find the optimal distribution of songs that minimizes the difference.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # We need to find the closest sum to total_duration // 2\n        # Using a dynamic programming approach to solve this subset sum problem\n        max_possible_sum = total_duration // 2\n        dp = [False] * (max_possible_sum + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_sum, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_sum, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_sum, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum close to total_duration // 2\n        best_sum = 0\n        for j in range(max_possible_sum + 1):\n            if dp[j]:\n                best_sum = j\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * best_sum)\n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The goal is to find the closest sum to total_duration // 2\n        # Using a dynamic programming approach to solve this subset sum problem\n        max_possible_sum = total_duration // 2\n        dp = [False] * (max_possible_sum + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_sum, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_sum, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_sum, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum close to total_duration // 2\n        best_sum = 0\n        for j in range(max_possible_sum + 1):\n            if dp[j]:\n                best_sum = j\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * best_sum)\n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of songs of each type for each test case.\",\n      \"details\": \"Read the input values and store them in a structured format for easy access during processing.\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"details\": \"For each test case, compute the total duration by summing up the products of the number of songs and their respective durations (1-minute, 2-minute, and 3-minute).\"\n    },\n    {\n      \"description\": \"Determine the optimal distribution of songs to minimize the difference in concert durations.\",\n      \"details\": \"Use a strategy to explore combinations of song distributions that approach a balance in total time for each concert. This involves finding a subset of songs whose total duration is as close as possible to half of the total duration.\"\n    },\n    {\n      \"description\": \"Calculate the minimal possible difference in concert durations for each test case.\",\n      \"details\": \"For each test case, compute the absolute difference between the total durations of the two concerts based on the optimal distribution found.\"\n    },\n    {\n      \"description\": \"Output the minimal possible difference for each test case.\",\n      \"details\": \"Print the result for each test case in the required format.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, read the number of one-minute, two-minute, and three-minute songs.\",\n    \"Calculate the total duration of all songs.\",\n    \"Implement a method to find a subset of songs that balances the total duration between two concerts.\",\n    \"Calculate the minimal possible difference in durations between the two concerts.\",\n    \"Output the minimal difference for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # We need to find the closest sum to total_duration // 2\n        target = total_duration // 2\n\n        # Dynamic programming approach to find the closest sum to target\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        # Process 1-minute songs\n        for _ in range(a):\n            for j in range(target, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n\n        # Process 2-minute songs\n        for _ in range(b):\n            for j in range(target, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n\n        # Process 3-minute songs\n        for _ in range(c):\n            for j in range(target, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n\n        # Find the best possible sum close to target\n        best_sum = 0\n        for i in range(target + 1):\n            if dp[i]:\n                best_sum = i\n\n        # Calculate the minimal difference\n        min_difference = abs(total_duration - 2 * best_sum)\n        results.append(min_difference)\n\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n\n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # We need to find the closest sum to total_duration // 2\n        target = total_duration // 2\n\n        # Dynamic programming approach to find the closest sum to target\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        # Process 1-minute songs\n        for _ in range(a):\n            for j in range(target, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n\n        # Process 2-minute songs\n        for _ in range(b):\n            for j in range(target, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n\n        # Process 3-minute songs\n        for _ in range(c):\n            for j in range(target, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n\n        # Find the best possible sum close to target\n        best_sum = 0\n        for i in range(target + 1):\n            if dp[i]:\n                best_sum = i\n\n        # Calculate the minimal difference\n        min_difference = abs(total_duration - 2 * best_sum)\n        results.append(min_difference)\n\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n\n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"goal\": \"Extract and store the input data for processing.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total duration of all songs combined.\",\n      \"goal\": \"Determine the total duration of songs to understand the distribution challenge.\"\n    },\n    {\n      \"description\": \"Determine the possible ways to distribute the songs into two concerts such that the absolute difference in their durations is minimized.\",\n      \"goal\": \"Explore combinations of song distributions to find the minimal difference in concert durations.\"\n    },\n    {\n      \"description\": \"Calculate the minimal possible difference in minutes between the durations of the two concerts for each test case.\",\n      \"goal\": \"Output the minimal difference for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the number of one-minute, two-minute, and three-minute songs.\",\n    \"  b. Calculate the total duration of all songs.\",\n    \"  c. Use a dynamic programming approach to explore possible distributions of songs into two concerts.\",\n    \"  d. Calculate the absolute difference in durations for each distribution and track the minimal difference.\",\n    \"  e. Store the minimal difference for the current test case.\",\n    \"Output the minimal difference for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # We need to find the closest possible sum to half of the total_duration\n        half_duration = total_duration // 2\n        \n        # Dynamic programming approach to find the closest sum to half_duration\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(half_duration, 0, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(half_duration, 0, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the closest sum to half_duration\n        closest_sum = 0\n        for i in range(half_duration + 1):\n            if dp[i]:\n                closest_sum = i\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n        \n        # Use a set to track possible sums\n        possible_sums = {0}\n        \n        # Process one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Process two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Process three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the closest sum to half_duration\n        closest_sum = max(s for s in possible_sums if s <= half_duration)\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"goal\": \"Extract and store the input data in a structured format for further processing.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total duration of all songs combined.\",\n      \"goal\": \"Determine the total duration of songs to understand the distribution challenge.\"\n    },\n    {\n      \"description\": \"Determine the possible ways to distribute songs into two concerts to minimize the absolute difference in their durations.\",\n      \"goal\": \"Explore combinations of song distributions to find the optimal balance.\"\n    },\n    {\n      \"description\": \"Calculate the minimal possible difference in durations between the two concerts for each test case.\",\n      \"goal\": \"Output the minimal difference for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse the number of test cases and the number of songs of each type for each test case.\",\n    \"For each test case, calculate the total duration of all songs.\",\n    \"Implement a strategy to explore possible distributions of songs into two concerts, aiming to balance the total durations as closely as possible.\",\n    \"For each distribution strategy, calculate the absolute difference in durations between the two concerts.\",\n    \"Track the minimal difference found for each test case.\",\n    \"Output the minimal difference for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # The goal is to find the closest possible sum to total_duration // 2\n        # This is a variation of the subset sum problem\n        max_possible_sum = total_duration // 2\n        dp = [False] * (max_possible_sum + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_sum, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_sum, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_sum, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum\n        best_sum = 0\n        for j in range(max_possible_sum + 1):\n            if dp[j]:\n                best_sum = j\n        \n        # Calculate the minimal difference\n        minimal_diff = abs(total_duration - 2 * best_sum)\n        results.append(minimal_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # The goal is to find the closest possible sum to total_duration // 2\n        # This is a variation of the subset sum problem\n        max_possible_sum = total_duration // 2\n        dp = [False] * (max_possible_sum + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_sum, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_sum, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_sum, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum\n        best_sum = 0\n        for j in range(max_possible_sum + 1):\n            if dp[j]:\n                best_sum = j\n        \n        # Calculate the minimal difference\n        minimal_diff = abs(total_duration - 2 * best_sum)\n        results.append(minimal_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the total duration of all songs.\",\n      \"details\": \"Sum the total minutes of all songs by multiplying the number of songs by their respective durations: total_duration = a * 1 + b * 2 + c * 3.\"\n    },\n    {\n      \"description\": \"Determine possible distributions of songs between two concerts.\",\n      \"details\": \"Explore combinations of song distributions that approach a balance in total time for each concert.\"\n    },\n    {\n      \"description\": \"Calculate the difference in durations between two concerts for each distribution.\",\n      \"details\": \"For each distribution, calculate the absolute difference between the total durations of the two concerts.\"\n    },\n    {\n      \"description\": \"Find the minimal possible difference.\",\n      \"details\": \"Identify the distribution that results in the smallest absolute difference in concert durations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"Calculate the total duration of all songs.\",\n    \"Generate all possible distributions of songs between two concerts.\",\n    \"For each distribution, calculate the absolute difference in durations between the two concerts.\",\n    \"Track the minimal difference encountered across all distributions.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The goal is to split the total_duration into two parts as evenly as possible\n        # We need to find the closest sum to total_duration // 2 using the available songs\n        \n        # Initialize a set to store possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the minimal possible difference\n        half_duration = total_duration // 2\n        min_diff = float('inf')\n        \n        for s in possible_sums:\n            min_diff = min(min_diff, abs(total_duration - 2 * s))\n        \n        results.append(min_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the total duration of all songs.\",\n      \"details\": \"Sum the total minutes of all songs by multiplying the number of songs by their respective durations: total_duration = a * 1 + b * 2 + c * 3.\"\n    },\n    {\n      \"description\": \"Determine possible distributions of songs between two concerts.\",\n      \"details\": \"Explore combinations of song distributions that approach a balance in total time for each concert.\"\n    },\n    {\n      \"description\": \"Calculate the difference in durations between two concerts for each distribution.\",\n      \"details\": \"For each distribution, calculate the absolute difference between the total durations of the two concerts.\"\n    },\n    {\n      \"description\": \"Find the minimal possible difference.\",\n      \"details\": \"Identify the distribution that results in the smallest difference in concert durations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"Calculate the total duration of all songs.\",\n    \"Generate all possible distributions of songs between two concerts.\",\n    \"For each distribution, calculate the absolute difference in durations between the two concerts.\",\n    \"Track the minimal difference encountered across all distributions.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The goal is to split the total_duration into two parts as evenly as possible\n        # We need to find the closest sum to total_duration // 2 using the given songs\n        \n        # Initialize a set to store possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the minimal possible difference\n        half_duration = total_duration // 2\n        min_diff = float('inf')\n        for s in possible_sums:\n            min_diff = min(min_diff, abs(total_duration - 2 * s))\n        \n        results.append(min_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 106)"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The goal is to split the total_duration into two parts as evenly as possible\n        # We need to find the closest sum to total_duration // 2 using the given songs\n        \n        # Initialize a set to store possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the minimal possible difference\n        half_duration = total_duration // 2\n        min_diff = float('inf')\n        for s in possible_sums:\n            min_diff = min(min_diff, abs(total_duration - 2 * s))\n        \n        results.append(min_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of songs of each type for each test case.\",\n      \"details\": \"Read the input to get the number of test cases 't'. For each test case, read the integers 'a', 'b', and 'c' which represent the number of one-minute, two-minute, and three-minute songs respectively.\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"details\": \"For each test case, compute the total duration of all songs as 'total_duration = a * 1 + b * 2 + c * 3'.\"\n    },\n    {\n      \"description\": \"Determine the optimal distribution of songs to minimize the difference in concert durations.\",\n      \"details\": \"Use a dynamic programming approach or a greedy strategy to explore combinations of song distributions that minimize the absolute difference between the two concert durations. Consider the total duration and aim to split it as evenly as possible.\"\n    },\n    {\n      \"description\": \"Compute the minimal possible difference for each test case.\",\n      \"details\": \"For each test case, calculate the minimal possible difference in minutes between the durations of the two concerts based on the optimal distribution strategy.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"Print the minimal possible difference for each test case in the order they were provided.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases 't'.\",\n    \"For each test case, read the integers 'a', 'b', and 'c'.\",\n    \"Calculate the total duration of all songs for the test case.\",\n    \"Implement a strategy to distribute songs into two concerts to minimize the duration difference.\",\n    \"Calculate the minimal possible difference in concert durations.\",\n    \"Output the minimal difference for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # We need to find the closest we can get to half of the total_duration\n        half_duration = total_duration // 2\n        \n        # Initialize a set to store possible sums we can achieve\n        possible_sums = {0}\n        \n        # Try to add each song type to the possible sums\n        for _ in range(a):\n            possible_sums = {x + 1 for x in possible_sums} | possible_sums\n        for _ in range(b):\n            possible_sums = {x + 2 for x in possible_sums} | possible_sums\n        for _ in range(c):\n            possible_sums = {x + 3 for x in possible_sums} | possible_sums\n        \n        # Find the closest sum to half_duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * closest_sum)\n        results.append(min_difference)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n        \n        # Initialize a set to store possible sums we can achieve\n        possible_sums = {0}\n        \n        # Try to add each song type to the possible sums\n        for _ in range(a):\n            possible_sums = {x + 1 for x in possible_sums} | possible_sums\n        for _ in range(b):\n            possible_sums = {x + 2 for x in possible_sums} | possible_sums\n        for _ in range(c):\n            possible_sums = {x + 3 for x in possible_sums} | possible_sums\n        \n        # Find the closest sum to half_duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * closest_sum)\n        results.append(min_difference)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of songs of each duration for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integers a, b, c from the input, representing the number of one-minute, two-minute, and three-minute songs respectively.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"steps\": [\n        \"For each test case, compute the total duration of all songs as total_duration = a * 1 + b * 2 + c * 3.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in concert durations.\",\n      \"steps\": [\n        \"For each test case, explore combinations of song distributions between two concerts.\",\n        \"Calculate the duration of each possible distribution and find the distribution that minimizes the absolute difference between the two concert durations.\",\n        \"Use a strategy to balance the total time for each concert, considering the varying song lengths.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimal possible difference for each test case.\",\n      \"steps\": [\n        \"For each test case, print the minimal possible difference in minutes between the concert durations.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and song counts for each test case.\",\n    \"For each test case, calculate the total duration of all songs.\",\n    \"For each test case, determine the minimal possible difference in concert durations by exploring song distribution combinations.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # The goal is to split total_duration into two parts as evenly as possible\n        # We need to find the closest sum to total_duration // 2\n        half_duration = total_duration // 2\n        \n        # Initialize a set to store possible sums we can achieve\n        possible_sums = {0}\n        \n        # Try to achieve different sums using the songs\n        for _ in range(a):\n            possible_sums.update({x + 1 for x in possible_sums})\n        for _ in range(b):\n            possible_sums.update({x + 2 for x in possible_sums})\n        for _ in range(c):\n            possible_sums.update({x + 3 for x in possible_sums})\n        \n        # Find the closest sum to half_duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The goal is to split total_duration into two parts as evenly as possible\n        # We need to find the closest sum to total_duration // 2\n        half_duration = total_duration // 2\n        \n        # Initialize a set to store possible sums we can achieve\n        possible_sums = {0}\n        \n        # Try to achieve different sums using the songs\n        for _ in range(a):\n            possible_sums.update({x + 1 for x in possible_sums})\n        for _ in range(b):\n            possible_sums.update({x + 2 for x in possible_sums})\n        for _ in range(c):\n            possible_sums.update({x + 3 for x in possible_sums})\n        \n        # Find the closest sum to half_duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 400, "prompt": "Luntik has decided to try singing. He has a one-minute songs, b two-minute songs, and c three-minute songs and wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Some insight into the optimal distribution strategy would be a great help. Consider exploring combinations of song distributions that approach a balance in total time for each concert. The challenge lies in minimizing the difference in concert durations while distributing varying song lengths effectively.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 256}
