{"name": "1591_C. Minimize Distance", "description": "A total of n depots are located on a number line. Depot i lies at the point x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots. You and the n bags are initially at the origin 0. You can carry up to k bags at a time. You must collect the required number of goods from the origin, deliver them to the respective depots, and then return to the origin to collect your next batch of goods.\n\nCalculate the minimum distance you need to cover to deliver all the bags of goods to the depots. You do not have to return to the origin after you have delivered all the bags.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "tags": ["greedy", "math"], "difficulty": 9, "id": 1591, "sample_io": [{"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n7\n3000000000\n"]}], "test_list": [{"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n7\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n23\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["30\n41\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n43\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n43\n25\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n0 1 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["21\n40\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n46\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n50\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n40\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n40\n10\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n41\n7\n3000010100\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["13\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 4 4\n5 3\n2 2 5 3 3\n4 2\n0000000000 1000000000 1000000000 1000000000\n", "output": ["25\n39\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n9\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n23\n1000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n41\n10\n3000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n41\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n43\n27\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n44\n7\n3000000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n23\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n9\n3001000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -15 5 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n44\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 6 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n46\n8\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 3 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n50\n12\n3000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["13\n41\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n51\n7\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -15 6 2 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n44\n11\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000010000\n", "output": ["27\n41\n23\n1000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n41\n13\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n41\n9\n3000100000\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-14 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 7\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n45\n27\n3000010000\n"]}, {"input": "4\n5 1\n0 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n44\n9\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 3 3 6 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["30\n46\n9\n3001000000\n"]}, {"input": "4\n5 1\n1 0 3 4 5\n9 3\n-9 -18 -1 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["21\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["25\n46\n10\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n44\n8\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n50\n8\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 8 3 9 3\n5 3\n1 2 6 3 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n42\n10\n7000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 0 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["13\n37\n7\n3000000000\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 0 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000001000 1000000000 1000000000 1000010000\n", "output": ["13\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n37\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n45\n13\n3000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 8 3 12 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n49\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n57\n27\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 7\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000001000 1000000000 1000010000\n", "output": ["23\n45\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010000000 1000000000\n", "output": ["27\n46\n7\n3010000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 0\n5 1\n2 4 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n27\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 6 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["30\n46\n7\n3001000000\n"]}, {"input": "4\n5 1\n2 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["27\n46\n10\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1010000000\n", "output": ["16\n44\n8\n3010000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n44\n8\n3000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 -1 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["13\n39\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 6 5 9 1 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n53\n7\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 7 0\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["19\n37\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000010 1000000000\n", "output": ["29\n44\n11\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 5\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000010000 1001010000\n", "output": ["25\n41\n9\n3001010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 4\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n43\n13\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n41\n9\n7000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 8 3 12 4\n5 1\n2 0 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n49\n21\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n57\n27\n1000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010010000 1000000000\n", "output": ["27\n46\n7\n3010010000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n46\n7\n3001000000\n"]}, {"input": "4\n5 1\n2 2 3 4 5\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["27\n53\n10\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1010100000\n", "output": ["16\n44\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["11\n44\n8\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n53\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 7 0\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 4 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["19\n37\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1010000000 1000000010 1000000000\n", "output": ["29\n44\n11\n3010000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 2 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n39\n9\n7000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 1 3 12 4\n5 1\n2 0 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n47\n21\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-14 -18 -13 6 2 8 3 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n42\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 8 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n46\n10\n3001000000\n"]}, {"input": "4\n5 1\n2 2 3 4 5\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 0 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["27\n53\n8\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n2 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["11\n44\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 7 3 9 3\n5 3\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n42\n11\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-14 -18 -13 6 2 8 6 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n57\n27\n1010010000\n"]}, {"input": "4\n5 1\n2 2 3 4 7\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 0 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["29\n53\n8\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 0 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1001000000 1000000000 1010100000\n", "output": ["16\n42\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 4\n2 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["11\n44\n6\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 7 3 9 3\n5 2\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n42\n17\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 6\n-14 -18 -13 6 2 8 6 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n34\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n135\n27\n1010010000\n"]}, {"input": "4\n5 1\n2 2 3 5 7\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 0 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["31\n53\n8\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 8 1\n9 3\n-9 -18 -6 6 5 8 3 0 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1001000000 1000000000 1010100000\n", "output": ["20\n42\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -10 -6 6 6 7 3 9 3\n5 2\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n40\n17\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 10\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000010100\n", "output": ["30\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 6\n-14 -18 -13 6 2 8 6 11 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n40\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 10\n9 5\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000010100\n", "output": ["30\n40\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -6 -15 10 5 8 4 0 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["27\n43\n13\n3000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["23\n135\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -6 -15 10 5 8 4 0 4\n5 3\n2 7 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000110000\n", "output": ["27\n43\n13\n1000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["23\n135\n31\n1010010000\n"]}, {"input": "4\n5 1\n0 0 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["19\n135\n31\n1010010000\n"]}, {"input": "4\n5 1\n0 0 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 4 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["19\n115\n31\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 3 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n41\n7\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 7\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n0000000000 1000000000 1000000000 1000000000\n", "output": ["27\n41\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 1\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["18\n41\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 4 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 2 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["27\n41\n7\n3000010000\n"]}, {"input": "4\n5 1\n1 0 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["21\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 4 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n29\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 1\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n43\n25\n7000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n1 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n43\n23\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 12 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n48\n25\n3000010000\n"]}, {"input": "4\n5 1\n0 1 3 4 3\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["18\n40\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 0 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 9 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n48\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["18\n50\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 0\n9 3\n-9 -12 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["14\n40\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 2 6 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["30\n41\n7\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 4 4\n5 3\n2 2 5 6 3\n4 2\n0000000000 1000000000 1000000000 1000000000\n", "output": ["25\n39\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -23 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n49\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 4\n-5 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n42\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 16 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["38\n41\n10\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-14 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000001 1000000000\n", "output": ["25\n44\n9\n3000000001\n"]}, {"input": "4\n5 1\n0 3 3 4 5\n9 3\n-9 -18 -15 6 5 3 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n40\n9\n3000000000\n"]}, {"input": "4\n5 1\n-1 2 3 4 5\n9 3\n-5 -10 -15 9 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n47\n25\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 2 10 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n28\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 0\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["18\n46\n9\n3001000000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -1 6 6 8 3 7 4\n5 5\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n5\n3000000000\n"]}, {"input": "4\n5 1\n1 2 1 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["21\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 0 3 4 1\n9 3\n-9 -18 -15 5 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["14\n44\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 3 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n49\n7\n3000010100\n"]}, {"input": "4\n5 2\n2 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000001000 1000000000 1000000000 1000010000\n", "output": ["15\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n2 2 3 7 5\n9 3\n-5 -10 -15 6 2 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["31\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 0 3 4 9\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n44\n11\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 0000000000 1000110000\n", "output": ["30\n41\n13\n1000110000\n"]}, {"input": "4\n5 1\n1 2 3 2 2\n9 3\n-14 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["17\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 7\n5 1\n2 3 3 0 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n45\n19\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n4 2 3 5 3\n4 3\n1000000000 1000001000 1000000000 1000010000\n", "output": ["23\n43\n29\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 6\n1 2 5 0 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n5\n3000000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 14 8 3 7 0\n5 1\n2 2 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n50\n23\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 0 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["25\n42\n10\n3000000001\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 0 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000001000 1000000000 1001000000 1000010000\n", "output": ["13\n39\n8\n3001000000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -9 6 2 8 3 0 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n32\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 5\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n44\n5\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 2\n-5 -10 -15 6 5 8 3 7 5\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000010000 1000010000\n", "output": ["25\n63\n9\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1001000000 1000000000 1000110000\n", "output": ["30\n45\n13\n3001000000\n"]}, {"input": "4\n5 1\n1 2 6 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000100000 1000000000 1000000000\n", "output": ["30\n41\n9\n3000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 4 8 3 12 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n47\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1010010000\n", "output": ["25\n57\n27\n3010010000\n"]}, {"input": "4\n5 1\n1 3 3 8 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010000000 1000000000\n", "output": ["32\n46\n7\n3010000000\n"]}, {"input": "4\n5 1\n0 2 3 6 5\n9 3\n-5 -10 -12 6 7 8 3 7 0\n5 1\n2 4 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["26\n40\n27\n3000010000\n"]}, {"input": "4\n5 2\n1 2 4 4 5\n9 3\n-5 -10 -15 6 -1 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["15\n39\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 7 0\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 2 3 8 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["19\n37\n12\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 2\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000010 1000000000\n", "output": ["29\n44\n15\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 6\n9 3\n-5 -10 -15 6 5 8 3 7 5\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000010000 1001010000\n", "output": ["26\n41\n9\n3001010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 4\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1010110000\n", "output": ["30\n43\n13\n3010110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 8\n5 3\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n43\n9\n7000100000\n"]}, {"input": "4\n5 1\n1 2 3 7 2\n9 3\n-14 -18 -13 6 5 8 3 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000100000 1000000000 1000000000 1000010000\n", "output": ["25\n57\n27\n1000100000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 1 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010010000 1000000000\n", "output": ["27\n44\n7\n3010010000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 5 3 2\n4 4\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n46\n7\n1001000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -6 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1010100000\n", "output": ["16\n35\n8\n3010100000\n"]}, {"input": "4\n5 2\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["7\n44\n8\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 2\n-5 -10 -25 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n73\n8\n3000010100\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -18 -15 6 5 1 3 12 4\n5 1\n2 0 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n50\n21\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 6\n4 5\n1000000000 1000000000 1000000010 1000010000\n", "output": ["25\n57\n32\n1000010000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -26 6 6 8 3 7 4\n5 3\n1 1 8 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n54\n10\n3001000000\n"]}, {"input": "4\n5 1\n2 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1001000000 1000000000 1010100000\n", "output": ["18\n44\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -14 -6 6 6 7 3 9 3\n5 3\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n44\n11\n7000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["13\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 2 1 8 3 7 4\n5 4\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n37\n9\n7000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 1 3 12 4\n5 1\n1 0 3 5 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n47\n19\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 6\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n57\n32\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000100001 1000000000 1000000000 1000010100\n", "output": ["25\n48\n8\n3000100001\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 1\n-7 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n139\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 0 3 4 1\n9 3\n-9 -10 -6 6 6 7 3 9 3\n5 2\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["14\n40\n17\n7000000010\n"]}, {"input": "4\n5 1\n0 2 3 4 10\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000010100\n", "output": ["28\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 4\n-5 -6 -15 10 5 8 4 0 0\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n35\n13\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 0\n9 6\n-14 -18 -13 6 2 8 6 11 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n40\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 1\n-5 -10 -20 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["25\n140\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 4 10\n9 5\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000000100\n", "output": ["30\n40\n8\n3000000100\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 1\n-2 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["23\n129\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -6 -15 10 5 8 4 0 4\n5 3\n2 7 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000111000\n", "output": ["27\n43\n13\n1000111000\n"]}, {"input": "4\n5 2\n0 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["11\n135\n31\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -4 -15 10 3 8 4 0 4\n5 3\n2 7 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000110000\n", "output": ["27\n41\n13\n1000110000\n"]}, {"input": "4\n5 1\n0 0 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 4 7\n5 1\n4 3 3 5 1\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["19\n115\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 5 4\n5 3\n2 2 5 3 3\n4 2\n1000001000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n9\n3000001000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 3 8 0 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["20\n41\n10\n3000010000\n"]}], "task_id": "codecontest/47", "repair_prompt": ["A total of n depots are positioned along a one-dimensional axis. Depot i is located at coordinate x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesperson with n bags of goods, starting at the origin 0 and striving to deliver one bag to every depot while carrying up to k bags simultaneously. You must collect the required number of goods from the origin, deliver them to the respective depots, and then return to the origin to collect your next batch of goods.\n\nCompute the smallest distance you need to travel to deliver all the bags of goods to the depots. You do not have to return to the origin after you have delivered all the bags. Consider optimizing the delivery sequence for efficiency.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def minimum_travel_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = []\n        negative = []\n        \n        # Separate depots into positive and negative lists\n        for x in depots:\n            if x > 0:\n                positive.append(x)\n            elif x < 0:\n                negative.append(-x)  # Store negative values as positive for easier sorting\n        \n        # Sort lists in descending order\n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive depots\n        for i in range(0, len(positive), k):\n            total_distance += 2 * positive[i]  # Round trip for each batch\n        \n        # Calculate distance for negative depots\n        for i in range(0, len(negative), k):\n            total_distance += 2 * negative[i]  # Round trip for each batch\n        \n        # Subtract the last trip back to origin\n        if positive:\n            total_distance -= positive[0]\n        if negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = minimum_travel_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def minimum_delivery_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = [x for x in depots if x > 0]\n        negative = [-x for x in depots if x < 0]\n        \n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive coordinates\n        for i in range(0, len(positive), k):\n            total_distance += 2 * positive[i]\n        \n        # Calculate distance for negative coordinates\n        for i in range(0, len(negative), k):\n            total_distance += 2 * negative[i]\n        \n        # Subtract the farthest one-way trip\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = minimum_delivery_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_delivery_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = sorted([x for x in depots if x > 0], reverse=True)\n        negative = sorted([-x for x in depots if x < 0], reverse=True)\n        \n        def calculate_distance(segment):\n            distance = 0\n            for i in range(0, len(segment), k):\n                distance += 2 * segment[i]\n            return distance\n        \n        pos_distance = calculate_distance(positive)\n        neg_distance = calculate_distance(negative)\n        \n        # The farthest point only needs to be visited once\n        max_distance = 0\n        if positive:\n            max_distance = max(max_distance, positive[0])\n        if negative:\n            max_distance = max(max_distance, negative[0])\n        \n        total_distance = pos_distance + neg_distance - max_distance\n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = minimum_delivery_distance(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def compute_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, coordinates in test_cases:\n        positive = sorted([x for x in coordinates if x > 0], reverse=True)\n        negative = sorted([-x for x in coordinates if x < 0], reverse=True)\n        \n        def calculate_distance(coords):\n            distance = 0\n            for i in range(0, len(coords), k):\n                distance += 2 * coords[i]\n            if coords:\n                distance -= coords[0]  # No need to return to origin on last trip\n            return distance\n        \n        total_distance = calculate_distance(positive) + calculate_distance(negative)\n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n, k = int(data[index]), int(data[index + 1])\n        index += 2\n        coordinates = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, coordinates))\n    \n    results = compute_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_delivery_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = []\n        negative = []\n        \n        # Separate depots into positive and negative lists\n        for x in depots:\n            if x > 0:\n                positive.append(x)\n            elif x < 0:\n                negative.append(-x)  # Store negative values as positive for easier handling\n        \n        # Sort the lists in descending order\n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        # Calculate the total distance\n        total_distance = 0\n        \n        # Process positive depots\n        for i in range(0, len(positive), k):\n            total_distance += 2 * positive[i]\n        \n        # Process negative depots\n        for i in range(0, len(negative), k):\n            total_distance += 2 * negative[i]\n        \n        # Subtract the farthest trip as it doesn't require a return\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = minimum_delivery_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_delivery_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = []\n        negative = []\n        \n        # Separate depots into positive and negative lists\n        for x in depots:\n            if x > 0:\n                positive.append(x)\n            elif x < 0:\n                negative.append(-x)  # Store negative values as positive for easier handling\n        \n        # Sort the lists in descending order\n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        # Calculate the total distance\n        total_distance = 0\n        \n        # Process positive coordinates\n        for i in range(0, len(positive), k):\n            total_distance += 2 * positive[i]\n        \n        # Process negative coordinates\n        for i in range(0, len(negative), k):\n            total_distance += 2 * negative[i]\n        \n        # Subtract the farthest point since we don't need to return to origin after last delivery\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = minimum_delivery_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_delivery_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = []\n        negative = []\n        \n        # Separate depots into positive and negative\n        for x in depots:\n            if x > 0:\n                positive.append(x)\n            elif x < 0:\n                negative.append(-x)  # Store negative as positive for easier handling\n        \n        # Sort the lists\n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        # Calculate distance for positive depots\n        total_distance = 0\n        for i in range(0, len(positive), k):\n            total_distance += 2 * positive[i]\n        \n        # Calculate distance for negative depots\n        for i in range(0, len(negative), k):\n            total_distance += 2 * negative[i]\n        \n        # Adjust for the last trip where we don't return to the origin\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = minimum_delivery_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_travel_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = []\n        negative = []\n        \n        # Separate depots into positive and negative lists\n        for x in depots:\n            if x > 0:\n                positive.append(x)\n            elif x < 0:\n                negative.append(-x)  # Store negative values as positive for easier sorting\n        \n        # Sort the lists in descending order\n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        # Calculate the total distance\n        total_distance = 0\n        \n        # Process positive depots\n        for i in range(0, len(positive), k):\n            total_distance += 2 * positive[i]\n        \n        # Process negative depots\n        for i in range(0, len(negative), k):\n            total_distance += 2 * negative[i]\n        \n        # Subtract the farthest one-way trip (no need to return to origin)\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = minimum_travel_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def compute_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = sorted([x for x in depots if x > 0], reverse=True)\n        negative = sorted([-x for x in depots if x < 0], reverse=True)\n        \n        def calculate_distance(coords):\n            distance = 0\n            for i in range(0, len(coords), k):\n                distance += 2 * coords[i]\n            return distance\n        \n        positive_distance = calculate_distance(positive)\n        negative_distance = calculate_distance(negative)\n        \n        # Subtract the farthest depot distance as we don't need to return to origin\n        total_distance = positive_distance + negative_distance\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = compute_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_travel_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = sorted([x for x in depots if x > 0], reverse=True)\n        negative = sorted([-x for x in depots if x < 0], reverse=True)\n        \n        def calculate_distance(coords):\n            distance = 0\n            for i in range(0, len(coords), k):\n                distance += 2 * coords[i]\n            if coords:\n                distance -= coords[0]  # Do not return to origin after last trip\n            return distance\n        \n        total_distance = calculate_distance(positive) + calculate_distance(negative)\n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = minimum_travel_distance(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_travel_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = []\n        negative = []\n        \n        # Separate depots into positive and negative lists\n        for x in depots:\n            if x > 0:\n                positive.append(x)\n            elif x < 0:\n                negative.append(-x)  # Store negative values as positive for easier sorting\n        \n        # Sort lists in descending order\n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive depots\n        for i in range(0, len(positive), k):\n            total_distance += 2 * positive[i]  # Round trip for each batch\n        \n        # Calculate distance for negative depots\n        for i in range(0, len(negative), k):\n            total_distance += 2 * negative[i]  # Round trip for each batch\n        \n        # Subtract the last trip back to origin\n        if positive:\n            total_distance -= positive[0]\n        if negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = minimum_travel_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the values of n, k, and the list of depot coordinates.\",\n      \"steps\": [\n        \"Read the number of test cases t.\",\n        \"For each test case, read integers n and k.\",\n        \"Read the list of n integers representing depot coordinates.\"\n      ]\n    },\n    {\n      \"description\": \"Separate depot coordinates into positive and negative lists for efficient delivery planning.\",\n      \"steps\": [\n        \"Initialize two lists: one for positive coordinates and one for negative coordinates.\",\n        \"Iterate through the list of depot coordinates and append each coordinate to the appropriate list based on its sign.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum travel distance for delivering goods to depots.\",\n      \"steps\": [\n        \"Sort both positive and negative lists in descending order of absolute values.\",\n        \"For each list, calculate the total distance by grouping coordinates into batches of size k and summing the round-trip distances for each batch.\",\n        \"For the last batch in each list, only add the one-way distance since no return to origin is needed after final delivery.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum travel distance for each test case.\",\n      \"steps\": [\n        \"For each test case, compute the total minimum distance by summing the distances calculated for positive and negative depot lists.\",\n        \"Print the result for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and depot coordinates.\",\n    \"Separate depot coordinates into positive and negative lists.\",\n    \"Sort the lists and calculate the minimum travel distance for each list.\",\n    \"Sum the distances from positive and negative lists to get the total minimum distance for each test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_travel_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = []\n        negative = []\n        \n        # Separate depots into positive and negative lists\n        for x in depots:\n            if x > 0:\n                positive.append(x)\n            elif x < 0:\n                negative.append(-x)  # Store negative values as positive for easier sorting\n        \n        # Sort lists in descending order\n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive depots\n        for i in range(0, len(positive), k):\n            total_distance += 2 * positive[i]  # Round trip for each batch\n        \n        # Calculate distance for negative depots\n        for i in range(0, len(negative), k):\n            total_distance += 2 * negative[i]  # Round trip for each batch\n        \n        # Subtract the last trip back to origin\n        if positive:\n            total_distance -= positive[0]\n        if negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = minimum_travel_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of depots, the maximum number of bags that can be carried at once, and the coordinates of the depots.\",\n      \"output\": \"A list of test cases, where each test case contains the number of depots, the maximum number of bags, and a list of depot coordinates.\"\n    },\n    {\n      \"description\": \"For each test case, separate the depot coordinates into positive and negative coordinates, as they represent different directions from the origin.\",\n      \"output\": \"Two lists for each test case: one for positive coordinates and one for negative coordinates.\"\n    },\n    {\n      \"description\": \"Sort the positive and negative coordinates in descending order of their absolute values to prioritize delivering to the farthest depots first.\",\n      \"output\": \"Sorted lists of positive and negative coordinates for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots in each direction (positive and negative) by grouping the coordinates into batches of size k and summing the round-trip distances, except for the last trip in each direction which is one-way.\",\n      \"output\": \"The total minimum distance for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into the number of test cases and their respective details.\",\n    \"For each test case, split the depot coordinates into positive and negative lists.\",\n    \"Sort both lists of coordinates in descending order based on their absolute values.\",\n    \"For each sorted list, calculate the total distance by iterating over the coordinates in batches of size k, adding twice the farthest coordinate in each batch to the total distance, except for the last batch which is added only once.\",\n    \"Sum the distances from both directions (positive and negative) to get the total minimum distance for the test case.\",\n    \"Output the minimum distance for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_delivery_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = [x for x in depots if x > 0]\n        negative = [-x for x in depots if x < 0]\n        \n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive coordinates\n        for i in range(0, len(positive), k):\n            total_distance += 2 * positive[i]\n        \n        # Calculate distance for negative coordinates\n        for i in range(0, len(negative), k):\n            total_distance += 2 * negative[i]\n        \n        # Subtract the farthest one-way trip\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = minimum_delivery_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"name\": \"Input Parsing\",\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the values of n, k, and the list of depot coordinates.\"\n    },\n    {\n      \"name\": \"Coordinate Segmentation\",\n      \"description\": \"Separate the depot coordinates into positive and negative segments to handle deliveries in opposite directions efficiently.\"\n    },\n    {\n      \"name\": \"Distance Calculation\",\n      \"description\": \"For each segment (positive and negative), calculate the minimum distance required to deliver goods by grouping deliveries into batches of size k.\"\n    },\n    {\n      \"name\": \"Optimization of Delivery Sequence\",\n      \"description\": \"Optimize the delivery sequence by minimizing the total travel distance for each test case, considering the need to return to the origin after each batch except the last.\"\n    },\n    {\n      \"name\": \"Output Generation\",\n      \"description\": \"For each test case, output the calculated minimum distance.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, separate the depot coordinates into positive and negative segments.\",\n    \"Sort each segment in descending order to facilitate efficient delivery planning.\",\n    \"Calculate the minimum travel distance for each segment by delivering goods in batches of size k.\",\n    \"Sum the distances from both segments to get the total minimum distance for the test case.\",\n    \"Output the total minimum distance for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_delivery_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = sorted([x for x in depots if x > 0], reverse=True)\n        negative = sorted([-x for x in depots if x < 0], reverse=True)\n        \n        def calculate_distance(segment):\n            distance = 0\n            for i in range(0, len(segment), k):\n                distance += 2 * segment[i]\n            return distance\n        \n        pos_distance = calculate_distance(positive)\n        neg_distance = calculate_distance(negative)\n        \n        # The farthest point only needs to be visited once\n        max_distance = 0\n        if positive:\n            max_distance = max(max_distance, positive[0])\n        if negative:\n            max_distance = max(max_distance, negative[0])\n        \n        total_distance = pos_distance + neg_distance - max_distance\n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = minimum_delivery_distance(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of depots, the maximum number of bags that can be carried at once, and the coordinates of the depots.\",\n      \"output\": \"A list of test cases, where each test case contains the number of depots, the maximum number of bags, and a list of depot coordinates.\"\n    },\n    {\n      \"description\": \"For each test case, separate the depot coordinates into positive and negative coordinates, as they represent different directions from the origin.\",\n      \"output\": \"Two lists for each test case: one for positive coordinates and one for negative coordinates.\"\n    },\n    {\n      \"description\": \"Sort the positive and negative coordinate lists in descending order of their absolute values to prioritize delivering to the farthest depots first.\",\n      \"output\": \"Sorted lists of positive and negative coordinates for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots in each direction (positive and negative) by grouping the coordinates into batches of size k and summing the round-trip distances, except for the last trip in each direction which does not require returning to the origin.\",\n      \"output\": \"The total minimum distance for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into the number of test cases and their respective details.\",\n    \"For each test case, split the depot coordinates into positive and negative lists.\",\n    \"Sort both lists in descending order based on the absolute values of the coordinates.\",\n    \"For each sorted list, calculate the total distance by iterating over the coordinates in batches of size k, summing the distances, and accounting for the non-return trip on the last batch.\",\n    \"Sum the distances from both directions to get the total minimum distance for each test case.\",\n    \"Output the minimum distance for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def compute_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, coordinates in test_cases:\n        positive = sorted([x for x in coordinates if x > 0], reverse=True)\n        negative = sorted([-x for x in coordinates if x < 0], reverse=True)\n        \n        def calculate_distance(coords):\n            distance = 0\n            for i in range(0, len(coords), k):\n                distance += 2 * coords[i]\n            if coords:\n                distance -= coords[0]  # No need to return to origin on last trip\n            return distance\n        \n        total_distance = calculate_distance(positive) + calculate_distance(negative)\n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n, k = int(data[index]), int(data[index + 1])\n        index += 2\n        coordinates = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, coordinates))\n    \n    results = compute_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the values of n, k, and the list of depot coordinates.\",\n      \"steps\": [\n        \"Read the number of test cases t.\",\n        \"For each test case, read integers n and k.\",\n        \"Read the list of n integers representing depot coordinates.\"\n      ]\n    },\n    {\n      \"description\": \"Separate depot coordinates into positive and negative lists for efficient delivery planning.\",\n      \"steps\": [\n        \"Initialize two lists: one for positive coordinates and one for negative coordinates.\",\n        \"Iterate through the list of depot coordinates and append each coordinate to the appropriate list based on its sign.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum travel distance for delivering goods to depots.\",\n      \"steps\": [\n        \"Sort both positive and negative lists in descending order of absolute values.\",\n        \"For each list, calculate the total distance by grouping depots into batches of size k and summing the round-trip distance for each batch.\",\n        \"Ensure the last batch does not require a return trip to the origin.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum travel distance for each test case.\",\n      \"steps\": [\n        \"For each test case, compute the total minimum distance by summing the distances calculated for positive and negative depot lists.\",\n        \"Print the result for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and depot coordinates.\",\n    \"Separate depot coordinates into positive and negative lists.\",\n    \"Sort the lists and calculate the minimum travel distance for each list.\",\n    \"Sum the distances from positive and negative lists to get the total minimum distance for each test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_delivery_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = []\n        negative = []\n        \n        # Separate depots into positive and negative lists\n        for x in depots:\n            if x > 0:\n                positive.append(x)\n            elif x < 0:\n                negative.append(-x)  # Store negative values as positive for easier handling\n        \n        # Sort the lists in descending order\n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        # Calculate the total distance\n        total_distance = 0\n        \n        # Process positive depots\n        for i in range(0, len(positive), k):\n            total_distance += 2 * positive[i]\n        \n        # Process negative depots\n        for i in range(0, len(negative), k):\n            total_distance += 2 * negative[i]\n        \n        # Subtract the farthest trip as it doesn't require a return\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = minimum_delivery_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the values of n, k, and the list of depot coordinates.\",\n      \"steps\": [\n        \"Read the number of test cases t.\",\n        \"For each test case, read integers n and k.\",\n        \"Read the list of depot coordinates x_i.\"\n      ]\n    },\n    {\n      \"description\": \"Separate depot coordinates into positive and negative lists for efficient delivery planning.\",\n      \"steps\": [\n        \"Initialize two lists: one for positive coordinates and one for negative coordinates.\",\n        \"Iterate through the list of depot coordinates and append each coordinate to the appropriate list based on its sign.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum travel distance for each test case by optimizing delivery sequences.\",\n      \"steps\": [\n        \"Sort the positive and negative lists in descending order of absolute values.\",\n        \"For each list, calculate the total distance by grouping coordinates into batches of size k and summing the round-trip distances for each batch.\",\n        \"Ensure the last batch does not require a return trip to the origin.\",\n        \"Sum the distances from both positive and negative lists to get the total minimum distance for the test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all test cases.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum distance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and their respective parameters.\",\n    \"For each test case, separate depot coordinates into positive and negative lists.\",\n    \"Sort the lists and calculate the minimum travel distance by optimizing delivery sequences.\",\n    \"Output the minimum distance for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_delivery_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = []\n        negative = []\n        \n        # Separate depots into positive and negative lists\n        for x in depots:\n            if x > 0:\n                positive.append(x)\n            elif x < 0:\n                negative.append(-x)  # Store negative values as positive for easier handling\n        \n        # Sort the lists in descending order\n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        # Calculate the total distance\n        total_distance = 0\n        \n        # Process positive coordinates\n        for i in range(0, len(positive), k):\n            total_distance += 2 * positive[i]\n        \n        # Process negative coordinates\n        for i in range(0, len(negative), k):\n            total_distance += 2 * negative[i]\n        \n        # Subtract the farthest point since we don't need to return to origin after last delivery\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = minimum_delivery_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the values of n, k, and the list of depot coordinates.\",\n      \"steps\": [\n        \"Read the number of test cases t.\",\n        \"For each test case, read the integers n and k.\",\n        \"Read the list of depot coordinates x_i.\"\n      ]\n    },\n    {\n      \"description\": \"Separate the depot coordinates into positive and negative lists to handle them independently.\",\n      \"steps\": [\n        \"Initialize two lists: one for positive coordinates and one for negative coordinates.\",\n        \"Iterate through the list of depot coordinates and append each coordinate to the appropriate list based on its sign.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots on the positive side of the axis.\",\n      \"steps\": [\n        \"Sort the list of positive coordinates in descending order.\",\n        \"Iterate over the sorted list in steps of k, calculating the round-trip distance for each batch of deliveries.\",\n        \"Accumulate the total distance traveled for positive coordinates.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots on the negative side of the axis.\",\n      \"steps\": [\n        \"Sort the list of negative coordinates in ascending order.\",\n        \"Iterate over the sorted list in steps of k, calculating the round-trip distance for each batch of deliveries.\",\n        \"Accumulate the total distance traveled for negative coordinates.\"\n      ]\n    },\n    {\n      \"description\": \"Combine the distances from both positive and negative sides to get the total minimum distance for each test case.\",\n      \"steps\": [\n        \"Sum the total distances calculated for positive and negative coordinates.\",\n        \"Subtract the farthest one-way trip (either positive or negative) from the total distance to account for not returning to the origin after the last delivery.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum distance for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum distance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and depot coordinates.\",\n    \"Separate depot coordinates into positive and negative lists.\",\n    \"Calculate the minimum delivery distance for positive coordinates.\",\n    \"Calculate the minimum delivery distance for negative coordinates.\",\n    \"Combine distances from both sides and adjust for the", "Round_0": {"code": "def minimum_delivery_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = []\n        negative = []\n        \n        # Separate depots into positive and negative\n        for x in depots:\n            if x > 0:\n                positive.append(x)\n            elif x < 0:\n                negative.append(-x)  # Store negative as positive for easier handling\n        \n        # Sort the lists\n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        # Calculate distance for positive depots\n        total_distance = 0\n        for i in range(0, len(positive), k):\n            total_distance += 2 * positive[i]\n        \n        # Calculate distance for negative depots\n        for i in range(0, len(negative), k):\n            total_distance += 2 * negative[i]\n        \n        # Adjust for the last trip where we don't return to the origin\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = minimum_delivery_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the values of n, k, and the list of depot coordinates.\",\n      \"steps\": [\n        \"Read the number of test cases t.\",\n        \"For each test case, read integers n and k.\",\n        \"Read the list of depot coordinates x_i.\"\n      ]\n    },\n    {\n      \"description\": \"Separate depot coordinates into positive and negative lists for efficient delivery planning.\",\n      \"steps\": [\n        \"Initialize two lists: one for positive coordinates and one for negative coordinates.\",\n        \"Iterate through the list of depot coordinates and append each coordinate to the appropriate list based on its sign.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum travel distance for delivering goods to depots.\",\n      \"steps\": [\n        \"Sort both positive and negative lists in descending order of absolute values.\",\n        \"For each list, compute the total travel distance by grouping coordinates into batches of size k.\",\n        \"For each batch, calculate the round-trip distance to the farthest depot in the batch.\",\n        \"Sum the distances for all batches, ensuring the last batch does not require a return trip to the origin.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum travel distance for each test case.\",\n      \"steps\": [\n        \"Store the computed minimum distance for each test case.\",\n        \"Print the results for all test cases.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and depot coordinates.\",\n    \"Separate depot coordinates into positive and negative lists.\",\n    \"Sort the lists and compute the minimum travel distance for each test case.\",\n    \"Output the computed minimum distances.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_travel_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = []\n        negative = []\n        \n        # Separate depots into positive and negative lists\n        for x in depots:\n            if x > 0:\n                positive.append(x)\n            elif x < 0:\n                negative.append(-x)  # Store negative values as positive for easier sorting\n        \n        # Sort the lists in descending order\n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        # Calculate the total distance\n        total_distance = 0\n        \n        # Process positive depots\n        for i in range(0, len(positive), k):\n            total_distance += 2 * positive[i]\n        \n        # Process negative depots\n        for i in range(0, len(negative), k):\n            total_distance += 2 * negative[i]\n        \n        # Subtract the farthest one-way trip (no need to return to origin)\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = minimum_travel_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the values of n, k, and the list of depot coordinates.\",\n      \"steps\": [\n        \"Read the number of test cases t.\",\n        \"For each test case, read the integers n and k.\",\n        \"Read the list of depot coordinates x_i.\"\n      ]\n    },\n    {\n      \"description\": \"Separate the depot coordinates into positive and negative lists to handle them independently.\",\n      \"steps\": [\n        \"Initialize two lists: one for positive coordinates and one for negative coordinates.\",\n        \"Iterate through the list of depot coordinates and append each coordinate to the appropriate list based on its sign.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots on the positive side of the axis.\",\n      \"steps\": [\n        \"Sort the positive coordinates in descending order.\",\n        \"Iterate over the sorted list in steps of k, calculating the round-trip distance for each batch of deliveries.\",\n        \"Accumulate the total distance traveled for all batches.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum distance for delivering goods to depots on the negative side of the axis.\",\n      \"steps\": [\n        \"Sort the negative coordinates in ascending order (since they are negative, this is equivalent to sorting by absolute value in descending order).\",\n        \"Iterate over the sorted list in steps of k, calculating the round-trip distance for each batch of deliveries.\",\n        \"Accumulate the total distance traveled for all batches.\"\n      ]\n    },\n    {\n      \"description\": \"Combine the results from positive and negative deliveries to compute the total minimum distance for each test case.\",\n      \"steps\": [\n        \"Sum the total distances calculated for positive and negative deliveries.\",\n        \"Subtract the distance of the farthest depot (either positive or negative) from the total, as the final return to the origin is not required.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum distance for each test case.\",\n      \"steps\": [\n        \"For each test case, output the computed minimum distance.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and depot coordinates.\",\n    \"Separate depot coordinates into positive and negative lists.\",\n    \"Calculate the minimum delivery distance for positive depots.\",\n    \"Calculate the minimum delivery distance for negative", "Round_0": {"code": "def compute_minimum_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = sorted([x for x in depots if x > 0], reverse=True)\n        negative = sorted([-x for x in depots if x < 0], reverse=True)\n        \n        def calculate_distance(coords):\n            distance = 0\n            for i in range(0, len(coords), k):\n                distance += 2 * coords[i]\n            return distance\n        \n        positive_distance = calculate_distance(positive)\n        negative_distance = calculate_distance(negative)\n        \n        # Subtract the farthest depot distance as we don't need to return to origin\n        total_distance = positive_distance + negative_distance\n        if positive and negative:\n            total_distance -= max(positive[0], negative[0])\n        elif positive:\n            total_distance -= positive[0]\n        elif negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = compute_minimum_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of depots, the maximum number of bags that can be carried at once, and the coordinates of the depots.\",\n      \"output\": \"A structured format containing all test cases with their respective n, k, and depot coordinates.\"\n    },\n    {\n      \"description\": \"Separate the depot coordinates into positive and negative values to handle them independently, as they represent different directions along the axis.\",\n      \"output\": \"Two lists: one for positive coordinates and one for negative coordinates.\"\n    },\n    {\n      \"description\": \"For each list of coordinates (positive and negative), determine the optimal delivery sequence that minimizes the travel distance. This involves sorting the coordinates and grouping them into batches of size k.\",\n      \"output\": \"A sequence of trips for each direction that minimizes the travel distance.\"\n    },\n    {\n      \"description\": \"Calculate the total travel distance for each test case by summing the distances of all trips, ensuring that the final trip does not require a return to the origin.\",\n      \"output\": \"The minimum travel distance for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, separate the depot coordinates into positive and negative lists.\",\n    \"Sort each list of coordinates in descending order to prioritize the farthest depots first.\",\n    \"For each sorted list, divide the coordinates into batches of size k and calculate the travel distance for each batch, ensuring the last trip does not return to the origin.\",\n    \"Sum the travel distances for all batches in both directions to get the total minimum distance for the test case.\",\n    \"Output the minimum travel distance for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_travel_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = sorted([x for x in depots if x > 0], reverse=True)\n        negative = sorted([-x for x in depots if x < 0], reverse=True)\n        \n        def calculate_distance(coords):\n            distance = 0\n            for i in range(0, len(coords), k):\n                distance += 2 * coords[i]\n            if coords:\n                distance -= coords[0]  # Do not return to origin after last trip\n            return distance\n        \n        total_distance = calculate_distance(positive) + calculate_distance(negative)\n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = minimum_travel_distance(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the values of n, k, and the list of depot coordinates.\",\n      \"steps\": [\n        \"Read the number of test cases t.\",\n        \"For each test case, read integers n and k.\",\n        \"Read the list of n integers representing depot coordinates.\"\n      ]\n    },\n    {\n      \"description\": \"Separate depot coordinates into positive and negative lists for efficient delivery planning.\",\n      \"steps\": [\n        \"Initialize two lists: one for positive coordinates and one for negative coordinates.\",\n        \"Iterate through the list of depot coordinates and append each coordinate to the appropriate list based on its sign.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum travel distance for delivering goods to depots.\",\n      \"steps\": [\n        \"Sort both positive and negative lists in descending order of absolute values.\",\n        \"For each list, calculate the total distance by grouping coordinates into batches of size k and summing the round-trip distances for each batch.\",\n        \"For the last batch in each list, only add the one-way distance since no return to origin is needed after final delivery.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum travel distance for each test case.\",\n      \"steps\": [\n        \"For each test case, compute the total minimum distance by summing the distances calculated for positive and negative depot lists.\",\n        \"Print the result for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and depot coordinates.\",\n    \"Separate depot coordinates into positive and negative lists.\",\n    \"Sort the lists and calculate the minimum travel distance for each list.\",\n    \"Sum the distances from positive and negative lists to get the total minimum distance for each test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_travel_distance(test_cases):\n    results = []\n    \n    for n, k, depots in test_cases:\n        positive = []\n        negative = []\n        \n        # Separate depots into positive and negative lists\n        for x in depots:\n            if x > 0:\n                positive.append(x)\n            elif x < 0:\n                negative.append(-x)  # Store negative values as positive for easier sorting\n        \n        # Sort lists in descending order\n        positive.sort(reverse=True)\n        negative.sort(reverse=True)\n        \n        total_distance = 0\n        \n        # Calculate distance for positive depots\n        for i in range(0, len(positive), k):\n            total_distance += 2 * positive[i]  # Round trip for each batch\n        \n        # Calculate distance for negative depots\n        for i in range(0, len(negative), k):\n            total_distance += 2 * negative[i]  # Round trip for each batch\n        \n        # Subtract the last trip back to origin\n        if positive:\n            total_distance -= positive[0]\n        if negative:\n            total_distance -= negative[0]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = minimum_travel_distance(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, false, true, true, true, true, false, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 604, "prompt": "A total of n depots are positioned along a one-dimensional axis. Depot i is located at coordinate x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesperson with n bags of goods, starting at the origin 0 and striving to deliver one bag to every depot while carrying up to k bags simultaneously. You must collect the required number of goods from the origin, deliver them to the respective depots, and then return to the origin to collect your next batch of goods.\n\nCompute the smallest distance you need to travel to deliver all the bags of goods to the depots. You do not have to return to the origin after you have delivered all the bags. Consider optimizing the delivery sequence for efficiency.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 350}
