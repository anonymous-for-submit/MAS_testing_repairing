{"name": "1615_A. Closing The Gap", "description": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\n\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "tags": ["greedy", "math"], "difficulty": 7, "id": 1615, "sample_io": [{"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}], "test_list": [{"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n1 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 3 -1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 0\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 1 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 10 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 5 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 0\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 4\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 0 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 0\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n1 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n24 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 -1 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n24 9 15\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n0 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n36 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 1\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n41 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 10 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 5\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 0 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 9\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n4 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n3 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n1 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n0 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n15 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 0 1 2\n5\n0 2 3 1 0\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 2 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 5 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n4 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 17 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 0 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n4 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 -1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 10\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n13 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 31 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n15 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 0 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n6 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 0 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n1 3 6 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 15\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 2 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 16\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 -1 3\n5\n0 3 6 1 5\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n11 12 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 2 4\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 2\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 0 6 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 1\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 14 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 2 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 14\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n1 3 10 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 19\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n0 0 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n-1 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 1\n5\n0 2 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 7\n", "output": ["0\n1\n0\n"]}], "task_id": "codecontest/119", "repair_prompt": ["There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. This operation allows you to balance out the heights. Trading blocks is beneficial because it can help achieve a more uniform look. By performing this swap between blocks, the towers can become more evenly distributed.\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the minimum possible ugliness\n        # If total_blocks is perfectly divisible by n, the minimum ugliness is 0\n        # Otherwise, it is 1 because we can distribute blocks such that the difference\n        # between the tallest and shortest is at most 1.\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        # Calculate the average height\n        average_height = total_height // n\n        # Calculate the remainder\n        remainder = total_height % n\n        # The minimum ugliness is determined by the remainder\n        # If remainder is 0, all buildings can be made the same height\n        # If remainder is not 0, the minimum ugliness is 1\n        min_ugliness = 1 if remainder else 0\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the minimum possible ugliness\n        # The minimum ugliness is determined by the distribution of blocks around the average height\n        # If the total_blocks is perfectly divisible by n, the minimum ugliness is 0\n        # Otherwise, it is 1 because we can have at most one building with height different by 1\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the minimum possible ugliness\n        # We need to check if the total_blocks is perfectly divisible by n\n        # If it is, the minimum ugliness is 0, otherwise it is 1\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_floor = total_blocks // n\n        target_ceil = (total_blocks + n - 1) // n  # Equivalent to math.ceil(total_blocks / n)\n        min_ugliness = target_ceil - target_floor\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the minimum possible ugliness\n        # The minimum ugliness is determined by the distribution of blocks around the average height\n        # If total_blocks is perfectly divisible by n, the minimum ugliness is 0\n        # Otherwise, it is 1 because we can distribute blocks such that the difference is at most 1\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the minimum possible ugliness\n        # If total_blocks % n == 0, all towers can be made equal to average_height\n        # Otherwise, the minimum ugliness will be 1 because some towers will be average_height and some will be average_height + 1\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the minimum possible ugliness\n        # The minimum ugliness is determined by the distribution of blocks around the average height\n        # If total_blocks is perfectly divisible by n, the minimum ugliness is 0\n        # Otherwise, the minimum ugliness is 1 because we can have at most one building with height\n        # one more than the average and one with one less.\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the minimum possible ugliness\n        # The minimum ugliness is determined by the distribution of blocks around the average height\n        # If total_blocks % n == 0, all towers can be made to have the same height\n        # Otherwise, the minimum ugliness is 1 because we can't perfectly balance the blocks\n        min_ugliness = 1 if total_blocks % n != 0 else 0\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the minimum possible ugliness\n        # If total_blocks is perfectly divisible by n, the minimum ugliness is 0\n        # Otherwise, it is 1 because we can distribute blocks such that the difference\n        # between the tallest and shortest is at most 1.\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the minimum possible ugliness\n        # If total_blocks is perfectly divisible by n, the minimum ugliness is 0\n        # Otherwise, it is 1 because we can distribute blocks such that the difference\n        # between the tallest and shortest is at most 1.\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total number of blocks by summing the heights of the buildings.\",\n        \"Determine the average height by dividing the total number of blocks by n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks around the average height.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total number of blocks and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to achieve a uniform distribution around the average height.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the minimum possible ugliness\n        # If total_blocks is perfectly divisible by n, the minimum ugliness is 0\n        # Otherwise, it is 1 because we can distribute blocks such that the difference\n        # between the tallest and shortest is at most 1.\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers a, which represents the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the sum by the number of buildings, n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks to achieve the closest possible uniform height.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each test case.\",\n    \"For each test case, calculate the sum of the heights and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to achieve the closest uniform height.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        # Calculate the average height\n        average_height = total_height // n\n        # Calculate the remainder\n        remainder = total_height % n\n        # The minimum ugliness is determined by the remainder\n        # If remainder is 0, all buildings can be made the same height\n        # If remainder is not 0, the minimum ugliness is 1\n        min_ugliness = 1 if remainder else 0\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total number of blocks by summing the heights of the buildings.\",\n        \"Determine the average height by dividing the total number of blocks by n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks around the average height.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total number of blocks and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to achieve a uniform distribution around the average height.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the minimum possible ugliness\n        # The minimum ugliness is determined by the distribution of blocks around the average height\n        # If the total_blocks is perfectly divisible by n, the minimum ugliness is 0\n        # Otherwise, it is 1 because we can have at most one building with height different by 1\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total number of blocks by summing the heights of all towers.\",\n        \"Determine the average height by dividing the total number of blocks by the number of towers, n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks around the average height.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total number of blocks and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to achieve heights close to the average.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the minimum possible ugliness\n        # We need to check if the total_blocks is perfectly divisible by n\n        # If it is, the minimum ugliness is 0, otherwise it is 1\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Read the integer t, which represents the number of test cases. For each test case, read the integer n (number of buildings) and the list of integers representing the heights of the buildings.\"\n    },\n    {\n      \"description\": \"Calculate the total number of blocks across all towers for each test case.\",\n      \"details\": \"Sum up all the heights of the towers to get the total number of blocks.\"\n    },\n    {\n      \"description\": \"Determine the target height for each tower to minimize ugliness.\",\n      \"details\": \"Calculate the target height by dividing the total number of blocks by the number of towers (n). Consider both the floor and ceiling of this division to handle cases where the total number of blocks is not perfectly divisible by n.\"\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"details\": \"The minimum possible ugliness is determined by the difference between the maximum and minimum target heights (ceiling and floor values from the previous step).\"\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, output the calculated minimum possible ugliness.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases, t.\",\n    \"For each test case, perform the following steps:\",\n    \"  - Read the number of buildings, n, and their respective heights.\",\n    \"  - Calculate the total number of blocks by summing the heights.\",\n    \"  - Determine the target height by dividing the total blocks by n, considering both floor and ceiling values.\",\n    \"  - Calculate the minimum possible ugliness as the difference between the ceiling and floor target heights.\",\n    \"  - Store the result for this test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_floor = total_blocks // n\n        target_ceil = (total_blocks + n - 1) // n  # Equivalent to math.ceil(total_blocks / n)\n        min_ugliness = target_ceil - target_floor\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total number of blocks by summing the heights of all towers.\",\n        \"Determine the average height by dividing the total number of blocks by the number of towers (n).\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks around the average height.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each test case.\",\n    \"For each test case, calculate the total number of blocks and determine the average height.\",\n    \"Calculate the minimum possible ugliness by balancing the heights around the average.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the minimum possible ugliness\n        # The minimum ugliness is determined by the distribution of blocks around the average height\n        # If total_blocks is perfectly divisible by n, the minimum ugliness is 0\n        # Otherwise, it is 1 because we can distribute blocks such that the difference is at most 1\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total number of blocks by summing the heights of all towers.\",\n        \"Determine the average height by dividing the total number of blocks by the number of towers (n).\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks around the average height.\",\n        \"Ensure that the difference between the tallest and shortest buildings is minimized.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total number of blocks and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to minimize the height difference.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the minimum possible ugliness\n        # If total_blocks % n == 0, all towers can be made equal to average_height\n        # Otherwise, the minimum ugliness will be 1 because some towers will be average_height and some will be average_height + 1\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total number of blocks by summing the heights of the buildings.\",\n        \"Determine the average height by dividing the total number of blocks by n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks around the average height.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total number of blocks and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to achieve a uniform distribution around the average height.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the minimum possible ugliness\n        # The minimum ugliness is determined by the distribution of blocks around the average height\n        # If total_blocks is perfectly divisible by n, the minimum ugliness is 0\n        # Otherwise, the minimum ugliness is 1 because we can have at most one building with height\n        # one more than the average and one with one less.\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total number of blocks by summing the heights of the buildings.\",\n        \"Determine the average height by dividing the total number of blocks by n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks around the average height.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each test case.\",\n    \"For each test case, calculate the total number of blocks and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to achieve a more uniform height distribution.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the minimum possible ugliness\n        # The minimum ugliness is determined by the distribution of blocks around the average height\n        # If total_blocks % n == 0, all towers can be made to have the same height\n        # Otherwise, the minimum ugliness is 1 because we can't perfectly balance the blocks\n        min_ugliness = 1 if total_blocks % n != 0 else 0\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total number of blocks by summing the heights of the buildings.\",\n        \"Determine the average height by dividing the total number of blocks by n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks around the average height.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total number of blocks and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to achieve a uniform distribution around the average height.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the minimum possible ugliness\n        # If total_blocks is perfectly divisible by n, the minimum ugliness is 0\n        # Otherwise, it is 1 because we can distribute blocks such that the difference\n        # between the tallest and shortest is at most 1.\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total number of blocks by summing the heights of the buildings.\",\n        \"Determine the average height by dividing the total number of blocks by n.\",\n        \"Calculate the minimum possible ugliness by considering the distribution of blocks around the average height.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total number of blocks and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to achieve a uniform distribution around the average height.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the minimum possible ugliness\n        # If total_blocks is perfectly divisible by n, the minimum ugliness is 0\n        # Otherwise, it is 1 because we can distribute blocks such that the difference\n        # between the tallest and shortest is at most 1.\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 605, "prompt": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. This operation allows you to balance out the heights. Trading blocks is beneficial because it can help achieve a more uniform look. By performing this swap between blocks, the towers can become more evenly distributed.\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "mutate_method": "expand_one2two", "save_node": false, "parent_index": 76}
