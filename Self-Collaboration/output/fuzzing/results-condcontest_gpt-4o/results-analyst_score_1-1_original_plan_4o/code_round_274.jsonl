{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "repair_prompt": ["In the large island of Baltia, N individuals reside, identified by numbers ranging from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. Note that each pair counts as a bidirectional friendship.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    friends = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique_of_5():\n        for a in range(1, N + 1):\n            for b in friends[a]:\n                if b <= a:\n                    continue\n                for c in friends[a].intersection(friends[b]):\n                    if c <= b:\n                        continue\n                    for d in friends[a].intersection(friends[b], friends[c]):\n                        if d <= c:\n                            continue\n                        for e in friends[a].intersection(friends[b], friends[c], friends[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set_of_5():\n        non_friends = set(range(1, N + 1))\n        for a in range(1, N + 1):\n            if len(non_friends) < 5:\n                break\n            non_friends.discard(a)\n            for b in non_friends:\n                if b in friends[a]:\n                    continue\n                non_friends.discard(b)\n                for c in non_friends:\n                    if c in friends[a] or c in friends[b]:\n                        continue\n                    non_friends.discard(c)\n                    for d in non_friends:\n                        if d in friends[a] or d in friends[b] or d in friends[c]:\n                            continue\n                        non_friends.discard(d)\n                        for e in non_friends:\n                            if e in friends[a] or e in friends[b] or e in friends[c] or e in friends[d]:\n                                continue\n                            return [a, b, c, d, e]\n                        non_friends.add(d)\n                    non_friends.add(c)\n                non_friends.add(b)\nmain()", "completions": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create graph representation\n    graph = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Function to find a clique of size 5\n    def find_clique_of_size_5():\n        for u in range(1, N + 1):\n            if len(graph[u]) >= 4:\n                neighbors = list(graph[u])\n                for i in range(len(neighbors)):\n                    for j in range(i + 1, len(neighbors)):\n                        for k in range(j + 1, len(neighbors)):\n                            for l in range(k + 1, len(neighbors)):\n                                a, b, c, d = neighbors[i], neighbors[j], neighbors[k], neighbors[l]\n                                if (b in graph[a] and c in graph[a] and d in graph[a] and\n                                    c in graph[b] and d in graph[b] and\n                                    d in graph[c]):\n                                    return [u, a, b, c, d]\n        return None\n    \n    # Function to find an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for u in range(1, N + 1):\n            if len(non_friends) < 5:\n                break\n            non_friends -= graph[u]\n            non_friends.discard(u)\n            if len(non_friends) >= 5:\n                return list(non_friends)[:5]\n            non_friends = set(range(1, N + 1))\n        return None\n    \n    # Check for a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    # Check for an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        print(' '.join(map(str, independent_set\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create graph\n    graph = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Check for a clique of size 5\n    def find_clique_of_size_5():\n        for a in range(1, N + 1):\n            for b in graph[a]:\n                if b <= a:\n                    continue\n                for c in graph[a].intersection(graph[b]):\n                    if c <= b:\n                        continue\n                    for d in graph[a].intersection(graph[b], graph[c]):\n                        if d <= c:\n                            continue\n                        for e in graph[a].intersection(graph[b], graph[c], graph[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for a in range(1, N + 1):\n            for b in non_friends - graph[a]:\n                if b <= a:\n                    continue\n                for c in non_friends - graph[a] - graph[b]:\n                    if c <= b:\n                        continue\n                    for d in non_friends - graph[a] - graph[b] - graph[c]:\n                        if d <= c:\n                            continue\n                        for e in non_friends - graph[a] - graph[b] - graph[c] - graph[d]:\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Determine if a successful party is possible\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        print(\" \".join(map(str, independent_set)))\n        return\n    \n    print(-1)\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Parse the friendship pairs\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique_of_size_5():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[j] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[i]] and\n                                    friends[l] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[k]]):\n                                    return [person, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) <= N - 5:\n                potential_set = non_friends - friendships[person] - {person}\n                if len(potential_set) >= 4:\n                    return [person] + list(potential_set)[:4]\n        return None\n    \n    # Try to find a clique of size 5\n    result = find_clique_of_size_5()\n    if result:\n        print(\" \".join(map(str, result)))\n        return\n    \n    # Try to find an independent set of size 5\n    result = find_independent_set_of_size_5()\n    if result:\n        print(\" \".join(map(str, result)))\n        return\n    \n    # If neither\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Parse the friendship pairs\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a clique of size 5\n    def find_clique_of_size_5():\n        for u in range(1, N + 1):\n            if len(friendships[u]) >= 4:\n                friends = list(friendships[u])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[i] in friendships[friends[j]] and\n                                    friends[i] in friendships[friends[k]] and\n                                    friends[i] in friendships[friends[l]] and\n                                    friends[j] in friendships[friends[k]] and\n                                    friends[j] in friendships[friends[l]] and\n                                    friends[k] in friendships[friends[l]]):\n                                    return [u, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for u in range(1, N + 1):\n            if len(friendships[u]) <= N - 5:\n                potential_set = non_friends - friendships[u] - {u}\n                if len(potential_set) >= 4:\n                    return [u] + list(potential_set)[:4]\n        return None\n    \n    # Try to find a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    # Try to find an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    # If neither is found, print -1\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    graph = defaultdict(set)\n    \n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Function to find a clique of size 5\n    def find_clique_of_size_5():\n        for a in range(1, N + 1):\n            for b in graph[a]:\n                if b <= a:\n                    continue\n                for c in graph[a].intersection(graph[b]):\n                    if c <= b:\n                        continue\n                    for d in graph[a].intersection(graph[b], graph[c]):\n                        if d <= c:\n                            continue\n                        for e in graph[a].intersection(graph[b], graph[c], graph[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Function to find an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for a in range(1, N + 1):\n            for b in non_friends - graph[a]:\n                if b <= a:\n                    continue\n                for c in non_friends - graph[a] - graph[b]:\n                    if c <= b:\n                        continue\n                    for d in non_friends - graph[a] - graph[b] - graph[c]:\n                        if d <= c:\n                            continue\n                        for e in non_friends - graph[a] - graph[b] - graph[c] - graph[d]:\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    # Check for an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    friends = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique_of_size_5():\n        for node in range(1, N + 1):\n            if len(friends[node]) >= 4:\n                potential_clique = [node] + list(friends[node])\n                if len(potential_clique) >= 5:\n                    for i in range(len(potential_clique)):\n                        for j in range(i + 1, len(potential_clique)):\n                            if potential_clique[j] not in friends[potential_clique[i]]:\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        return potential_clique[:5]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for node in range(1, N + 1):\n            if len(friends[node]) < N - 1:\n                non_friends -= friends[node]\n                non_friends.remove(node)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    # Try to find a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    # Try to find an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        print(\" \".join(map(str, independent_set)))\n        return\n    \n    # If neither is found, print -1\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Parse the friendship pairs\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph (clique) of size 5\n    def find_clique_of_size_5():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[j] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[i]] and\n                                    friends[l] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[k]]):\n                                    return [person, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for a set of 5 individuals with no friendships among them\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) <= N - 5:\n                potential_set = non_friends - friendships[person] - {person}\n                if len(potential_set) >= 4:\n                    return [person] + list(potential_set)[:4]\n        return None\n    \n    # Try to find a successful party\n    result = find_clique_of_size_5()\n    if result is None:\n        result = find_independent_set_of_size_5()\n    \n    if result is None:\n        print(-1)\n    else:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    friends = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique_of_size_5():\n        for node in range(1, N + 1):\n            if len(friends[node]) >= 4:\n                potential_clique = [node] + list(friends[node])\n                if len(potential_clique) >= 5:\n                    for i in range(len(potential_clique)):\n                        for j in range(i + 1, len(potential_clique)):\n                            if potential_clique[j] not in friends[potential_clique[i]]:\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        return potential_clique[:5]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for node in range(1, N + 1):\n            if len(friends[node]) < N - 1:\n                non_friends -= friends[node]\n                non_friends.discard(node)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    # Try to find a successful party configuration\n    clique = find_clique_of_size_5()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    # If no configuration is found, print -1\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    friends = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for a clique of size 5\n    def find_clique_of_size_5():\n        for a in range(1, N + 1):\n            for b in friends[a]:\n                if b <= a:\n                    continue\n                for c in friends[a].intersection(friends[b]):\n                    if c <= b:\n                        continue\n                    for d in friends[a].intersection(friends[b], friends[c]):\n                        if d <= c:\n                            continue\n                        for e in friends[a].intersection(friends[b], friends[c], friends[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for a in range(1, N + 1):\n            if len(non_friends) < 5:\n                break\n            non_friends.discard(a)\n            for b in non_friends:\n                if b in friends[a]:\n                    continue\n                non_friends.discard(b)\n                for c in non_friends:\n                    if c in friends[a] or c in friends[b]:\n                        continue\n                    non_friends.discard(c)\n                    for d in non_friends:\n                        if d in friends[a] or d in friends[b] or d in friends[c]:\n                            continue\n                        non_friends.discard(d)\n                        for e in non_friends:\n                            if e in friends[a] or e in friends[b] or e in friends[c] or e in friends[d]:\n                                continue\n                            return [a, b, c, d, e]\n                        non_friends.add(d)\n                    non_friends.add(c)\n                non_friends.add(b)\n            non_f\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    friends = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique_of_5():\n        for a in range(1, N + 1):\n            for b in friends[a]:\n                if b <= a:\n                    continue\n                for c in friends[a].intersection(friends[b]):\n                    if c <= b:\n                        continue\n                    for d in friends[a].intersection(friends[b], friends[c]):\n                        if d <= c:\n                            continue\n                        for e in friends[a].intersection(friends[b], friends[c], friends[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set_of_5():\n        non_friends = set(range(1, N + 1))\n        for a in range(1, N + 1):\n            if len(non_friends) < 5:\n                break\n            non_friends.discard(a)\n            for b in non_friends:\n                if b in friends[a]:\n                    continue\n                non_friends.discard(b)\n                for c in non_friends:\n                    if c in friends[a] or c in friends[b]:\n                        continue\n                    non_friends.discard(c)\n                    for d in non_friends:\n                        if d in friends[a] or d in friends[b] or d in friends[c]:\n                            continue\n                        non_friends.discard(d)\n                        for e in non_friends:\n                            if e in friends[a] or e in friends[b] or e in friends[c] or e in friends[d]:\n                                continue\n                            return [a, b, c, d, e]\n                        non_friends.add(d)\n                    non_friends.add(c)\n                non_friends.add(b)\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where all 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a complete subgraph of 5 nodes in the friendship graph.\",\n        \"Use graph traversal techniques to identify cliques of size 5.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where no two of the 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a set of 5 nodes with no edges between them in the friendship graph.\",\n        \"Use graph traversal techniques to identify independent sets of size 5.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, print the 5 individuals.\",\n        \"If no configuration is found, print -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Construct a graph representation using adjacency lists or matrices.\",\n    \"Check for a complete subgraph of 5 nodes (clique) in the graph.\",\n    \"Check for an independent set of 5 nodes in the graph.\",\n    \"Output the result based on whether a successful party configuration is found.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    friends = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique_of_5():\n        for a in range(1, N + 1):\n            for b in friends[a]:\n                if b <= a:\n                    continue\n                for c in friends[a].intersection(friends[b]):\n                    if c <= b:\n                        continue\n                    for d in friends[a].intersection(friends[b], friends[c]):\n                        if d <= c:\n                            continue\n                        for e in friends[a].intersection(friends[b], friends[c], friends[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set_of_5():\n        non_friends = set(range(1, N + 1))\n        for a in range(1, N + 1):\n            if len(non_friends) < 5:\n                break\n            non_friends.discard(a)\n            for b in non_friends:\n                if b in friends[a]:\n                    continue\n                non_friends.discard(b)\n                for c in non_friends:\n                    if c in friends[a] or c in friends[b]:\n                        continue\n                    non_friends.discard(c)\n                    for d in non_friends:\n                        if d in friends[a] or d in friends[b] or d in friends[c]:\n                            continue\n                        non_friends.discard(d)\n                        for e in non_friends:\n                            if e in friends[a] or e in friends[b] or e in friends[c] or e in friends[d]:\n                                continue\n                            return [a, b, c, d, e]\n                        non_friends.add(d)\n                    non_friends.add(c)\n                non_friends.add(b)", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph data structure representing friendships.\"\n    },\n    {\n      \"description\": \"Check for a clique of size 5 in the graph, where all 5 people are friends with each other.\",\n      \"output\": \"A list of 5 people forming a clique or an indication that no such clique exists.\"\n    },\n    {\n      \"description\": \"Check for an independent set of size 5 in the graph, where no two people are friends with each other.\",\n      \"output\": \"A list of 5 people forming an independent set or an indication that no such set exists.\"\n    },\n    {\n      \"description\": \"Determine if either a clique or an independent set of size 5 exists and output the result.\",\n      \"output\": \"5 numbers indicating a successful party or -1 if no successful party is possible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendship pairs.\",\n    \"Construct a graph using the friendship pairs.\",\n    \"Search for a clique of size 5 in the graph.\",\n    \"If a clique is found, output the 5 people in the clique.\",\n    \"If no clique is found, search for an independent set of size 5.\",\n    \"If an independent set is found, output the 5 people in the set.\",\n    \"If neither a clique nor an independent set is found, output -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create graph representation\n    graph = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Function to find a clique of size 5\n    def find_clique_of_size_5():\n        for u in range(1, N + 1):\n            if len(graph[u]) >= 4:\n                neighbors = list(graph[u])\n                for i in range(len(neighbors)):\n                    for j in range(i + 1, len(neighbors)):\n                        for k in range(j + 1, len(neighbors)):\n                            for l in range(k + 1, len(neighbors)):\n                                a, b, c, d = neighbors[i], neighbors[j], neighbors[k], neighbors[l]\n                                if (b in graph[a] and c in graph[a] and d in graph[a] and\n                                    c in graph[b] and d in graph[b] and\n                                    d in graph[c]):\n                                    return [u, a, b, c, d]\n        return None\n    \n    # Function to find an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for u in range(1, N + 1):\n            if len(non_friends) < 5:\n                break\n            non_friends -= graph[u]\n            non_friends.discard(u)\n            if len(non_friends) >= 5:\n                return list(non_friends)[:5]\n            non_friends = set(range(1, N + 1))\n        return None\n    \n    # Check for a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    # Check for an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        print(' '.join(map(str, independent_set", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 64)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create graph representation\n    graph = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Function to find a clique of size 5\n    def find_clique_of_size_5():\n        for u in range(1, N + 1):\n            if len(graph[u]) >= 4:\n                neighbors = list(graph[u])\n                for i in range(len(neighbors)):\n                    for j in range(i + 1, len(neighbors)):\n                        for k in range(j + 1, len(neighbors)):\n                            for l in range(k + 1, len(neighbors)):\n                                a, b, c, d = neighbors[i], neighbors[j], neighbors[k], neighbors[l]\n                                if (b in graph[a] and c in graph[a] and d in graph[a] and\n                                    c in graph[b] and d in graph[b] and\n                                    d in graph[c]):\n                                    return [u, a, b, c, d]\n        return None\n    \n    # Function to find an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for u in range(1, N + 1):\n            if len(non_friends) < 5:\n                break\n            non_friends -= graph[u]\n            non_friends.discard(u)\n            if len(non_friends) >= 5:\n                return list(non_friends)[:5]\n            non_friends = set(range(1, N + 1))\n        return None\n    \n    # Check for a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    # Check for an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        print(' '.join(map(str, independent_set"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list or adjacency matrix.\",\n      \"output\": \"Graph data structure representing friendships.\"\n    },\n    {\n      \"description\": \"Check for a clique of size 5 in the graph, where all 5 people are friends with each other.\",\n      \"output\": \"List of 5 people if such a clique exists, otherwise null.\"\n    },\n    {\n      \"description\": \"Check for an independent set of size 5 in the graph, where no two people are friends with each other.\",\n      \"output\": \"List of 5 people if such an independent set exists, otherwise null.\"\n    },\n    {\n      \"description\": \"Determine if either a clique or an independent set of size 5 exists and output the result.\",\n      \"output\": \"List of 5 people for a successful party or -1 if no such party is possible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendship pairs.\",\n    \"Construct a graph using the friendship pairs.\",\n    \"Search for a clique of size 5 in the graph.\",\n    \"If a clique is found, output the list of 5 people.\",\n    \"If no clique is found, search for an independent set of size 5.\",\n    \"If an independent set is found, output the list of 5 people.\",\n    \"If neither a clique nor an independent set is found, output -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create graph\n    graph = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Check for a clique of size 5\n    def find_clique_of_size_5():\n        for a in range(1, N + 1):\n            for b in graph[a]:\n                if b <= a:\n                    continue\n                for c in graph[a].intersection(graph[b]):\n                    if c <= b:\n                        continue\n                    for d in graph[a].intersection(graph[b], graph[c]):\n                        if d <= c:\n                            continue\n                        for e in graph[a].intersection(graph[b], graph[c], graph[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for a in range(1, N + 1):\n            for b in non_friends - graph[a]:\n                if b <= a:\n                    continue\n                for c in non_friends - graph[a] - graph[b]:\n                    if c <= b:\n                        continue\n                    for d in non_friends - graph[a] - graph[b] - graph[c]:\n                        if d <= c:\n                            continue\n                        for e in non_friends - graph[a] - graph[b] - graph[c] - graph[d]:\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Determine if a successful party is possible\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        print(\" \".join(map(str, independent_set)))\n        return\n    \n    print(-1)", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where all 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a complete subgraph of 5 nodes in the friendship graph.\",\n        \"Use graph traversal techniques to identify cliques of size 5.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where no two of the 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a set of 5 nodes with no edges between them in the friendship graph.\",\n        \"Use graph traversal techniques to identify independent sets of size 5.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, print the 5 individuals.\",\n        \"If no configuration is found, print -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Construct a graph representation using adjacency lists or matrices.\",\n    \"Check for a complete subgraph of 5 nodes (clique) in the graph.\",\n    \"Check for an independent set of 5 nodes in the graph.\",\n    \"Output the result based on whether a successful party configuration is found.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Parse the friendship pairs\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique_of_size_5():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[j] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[i]] and\n                                    friends[l] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[k]]):\n                                    return [person, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) <= N - 5:\n                potential_set = non_friends - friendships[person] - {person}\n                if len(potential_set) >= 4:\n                    return [person] + list(potential_set)[:4]\n        return None\n    \n    # Try to find a clique of size 5\n    result = find_clique_of_size_5()\n    if result:\n        print(\" \".join(map(str, result)))\n        return\n    \n    # Try to find an independent set of size 5\n    result = find_independent_set_of_size_5()\n    if result:\n        print(\" \".join(map(str, result)))\n        return\n    \n    # If neither", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 109)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Parse the friendship pairs\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique_of_size_5():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[j] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[i]] and\n                                    friends[l] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[k]]):\n                                    return [person, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) <= N - 5:\n                potential_set = non_friends - friendships[person] - {person}\n                if len(potential_set) >= 4:\n                    return [person] + list(potential_set)[:4]\n        return None\n    \n    # Try to find a clique of size 5\n    result = find_clique_of_size_5()\n    if result:\n        print(\" \".join(map(str, result)))\n        return\n    \n    # Try to find an independent set of size 5\n    result = find_independent_set_of_size_5()\n    if result:\n        print(\" \".join(map(str, result)))\n        return\n    \n    # If neither", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where all 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a complete subgraph (clique) of size 5 in the friendship graph.\",\n        \"Use graph traversal techniques to identify cliques.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where no two of the 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a set of 5 individuals with no edges between them in the friendship graph.\",\n        \"Use graph traversal techniques to identify independent sets.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, print the 5 individuals.\",\n        \"If no configuration is found, print -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Construct a graph representation using adjacency lists or matrices.\",\n    \"Check for a clique of size 5 in the graph.\",\n    \"Check for an independent set of size 5 in the graph.\",\n    \"Output the result based on the presence of a successful party configuration.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Parse the friendship pairs\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a clique of size 5\n    def find_clique_of_size_5():\n        for u in range(1, N + 1):\n            if len(friendships[u]) >= 4:\n                friends = list(friendships[u])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[i] in friendships[friends[j]] and\n                                    friends[i] in friendships[friends[k]] and\n                                    friends[i] in friendships[friends[l]] and\n                                    friends[j] in friendships[friends[k]] and\n                                    friends[j] in friendships[friends[l]] and\n                                    friends[k] in friendships[friends[l]]):\n                                    return [u, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for u in range(1, N + 1):\n            if len(friendships[u]) <= N - 5:\n                potential_set = non_friends - friendships[u] - {u}\n                if len(potential_set) >= 4:\n                    return [u] + list(potential_set)[:4]\n        return None\n    \n    # Try to find a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    # Try to find an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    # If neither is found, print -1", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 99)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Parse the friendship pairs\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a clique of size 5\n    def find_clique_of_size_5():\n        for u in range(1, N + 1):\n            if len(friendships[u]) >= 4:\n                friends = list(friendships[u])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[i] in friendships[friends[j]] and\n                                    friends[i] in friendships[friends[k]] and\n                                    friends[i] in friendships[friends[l]] and\n                                    friends[j] in friendships[friends[k]] and\n                                    friends[j] in friendships[friends[l]] and\n                                    friends[k] in friendships[friends[l]]):\n                                    return [u, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for u in range(1, N + 1):\n            if len(friendships[u]) <= N - 5:\n                potential_set = non_friends - friendships[u] - {u}\n                if len(potential_set) >= 4:\n                    return [u] + list(potential_set)[:4]\n        return None\n    \n    # Try to find a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    # Try to find an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    # If neither is found, print -1"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph data structure representing friendships.\"\n    },\n    {\n      \"description\": \"Check for a clique of size 5 in the graph, where all 5 people are friends with each other.\",\n      \"output\": \"A list of 5 people forming a clique or an indication that no such clique exists.\"\n    },\n    {\n      \"description\": \"Check for an independent set of size 5 in the graph, where no two people are friends with each other.\",\n      \"output\": \"A list of 5 people forming an independent set or an indication that no such set exists.\"\n    },\n    {\n      \"description\": \"Determine if either a clique or an independent set of size 5 exists and output the result.\",\n      \"output\": \"5 numbers indicating a successful party or -1 if no successful party is possible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendship pairs.\",\n    \"Construct a graph using the friendship pairs.\",\n    \"Search for a clique of size 5 in the graph.\",\n    \"If a clique is found, output the 5 people in the clique.\",\n    \"If no clique is found, search for an independent set of size 5.\",\n    \"If an independent set is found, output the 5 people in the set.\",\n    \"If neither a clique nor an independent set is found, output -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    graph = defaultdict(set)\n    \n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Function to find a clique of size 5\n    def find_clique_of_size_5():\n        for a in range(1, N + 1):\n            for b in graph[a]:\n                if b <= a:\n                    continue\n                for c in graph[a].intersection(graph[b]):\n                    if c <= b:\n                        continue\n                    for d in graph[a].intersection(graph[b], graph[c]):\n                        if d <= c:\n                            continue\n                        for e in graph[a].intersection(graph[b], graph[c], graph[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Function to find an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for a in range(1, N + 1):\n            for b in non_friends - graph[a]:\n                if b <= a:\n                    continue\n                for c in non_friends - graph[a] - graph[b]:\n                    if c <= b:\n                        continue\n                    for d in non_friends - graph[a] - graph[b] - graph[c]:\n                        if d <= c:\n                            continue\n                        for e in non_friends - graph[a] - graph[b] - graph[c] - graph[d]:\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    # Check for an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if independent_set:", "report": "The compilation output of the preceding code is: expected an indented block (<string>, line 72)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    graph = defaultdict(set)\n    \n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Function to find a clique of size 5\n    def find_clique_of_size_5():\n        for a in range(1, N + 1):\n            for b in graph[a]:\n                if b <= a:\n                    continue\n                for c in graph[a].intersection(graph[b]):\n                    if c <= b:\n                        continue\n                    for d in graph[a].intersection(graph[b], graph[c]):\n                        if d <= c:\n                            continue\n                        for e in graph[a].intersection(graph[b], graph[c], graph[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Function to find an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for a in range(1, N + 1):\n            for b in non_friends - graph[a]:\n                if b <= a:\n                    continue\n                for c in non_friends - graph[a] - graph[b]:\n                    if c <= b:\n                        continue\n                    for d in non_friends - graph[a] - graph[b] - graph[c]:\n                        if d <= c:\n                            continue\n                        for e in non_friends - graph[a] - graph[b] - graph[c] - graph[d]:\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    # Check for an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if independent_set:"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where all 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a complete subgraph of 5 nodes in the friendship graph.\",\n        \"Use graph traversal techniques to identify cliques of size 5.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where no two of the 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a set of 5 nodes with no edges between them in the friendship graph.\",\n        \"Use graph traversal techniques to identify independent sets of size 5.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, print the 5 individuals.\",\n        \"If no configuration is found, print -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Construct a graph representation using adjacency lists or matrices.\",\n    \"Check for a complete subgraph of 5 nodes (clique) in the graph.\",\n    \"Check for an independent set of 5 nodes in the graph.\",\n    \"Output the result based on whether a successful party configuration is found.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    friends = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique_of_size_5():\n        for node in range(1, N + 1):\n            if len(friends[node]) >= 4:\n                potential_clique = [node] + list(friends[node])\n                if len(potential_clique) >= 5:\n                    for i in range(len(potential_clique)):\n                        for j in range(i + 1, len(potential_clique)):\n                            if potential_clique[j] not in friends[potential_clique[i]]:\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        return potential_clique[:5]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for node in range(1, N + 1):\n            if len(friends[node]) < N - 1:\n                non_friends -= friends[node]\n                non_friends.remove(node)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    # Try to find a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    # Try to find an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        print(\" \".join(map(str, independent_set)))\n        return\n    \n    # If neither is found, print -1\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where all 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a complete subgraph (clique) of size 5 in the friendship graph.\",\n        \"If found, return the 5 individuals in the clique.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where no two of the 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a set of 5 individuals such that no two individuals in the set are friends.\",\n        \"If found, return the 5 individuals in the set.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If either condition is satisfied, print the 5 individuals.\",\n        \"If neither condition is satisfied, print -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Construct a graph representation using adjacency lists or matrices.\",\n    \"Check for a complete subgraph (clique) of size 5.\",\n    \"Check for a set of 5 individuals with no friendships among them.\",\n    \"Output the result based on the checks.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Parse the friendship pairs\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph (clique) of size 5\n    def find_clique_of_size_5():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[j] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[i]] and\n                                    friends[l] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[k]]):\n                                    return [person, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for a set of 5 individuals with no friendships among them\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) <= N - 5:\n                potential_set = non_friends - friendships[person] - {person}\n                if len(potential_set) >= 4:\n                    return [person] + list(potential_set)[:4]\n        return None\n    \n    # Try to find a successful party\n    result = find_clique_of_size_5()\n    if result is None:\n        result = find_independent_set_of_size_5()\n    \n    if result is None:\n        print(-1)\n    else:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 87)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Parse the friendship pairs\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph (clique) of size 5\n    def find_clique_of_size_5():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[j] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[i]] and\n                                    friends[l] in friendships[friends[i]] and\n                                    friends[k] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[j]] and\n                                    friends[l] in friendships[friends[k]]):\n                                    return [person, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for a set of 5 individuals with no friendships among them\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) <= N - 5:\n                potential_set = non_friends - friendships[person] - {person}\n                if len(potential_set) >= 4:\n                    return [person] + list(potential_set)[:4]\n        return None\n    \n    # Try to find a successful party\n    result = find_clique_of_size_5()\n    if result is None:\n        result = find_independent_set_of_size_5()\n    \n    if result is None:\n        print(-1)\n    else:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where all 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a complete subgraph of 5 nodes in the friendship graph.\",\n        \"Use graph traversal techniques to identify cliques of size 5.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where no two of the 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a set of 5 nodes with no edges between them in the friendship graph.\",\n        \"Use graph traversal techniques to identify independent sets of size 5.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, print the 5 individuals.\",\n        \"If no configuration is found, print -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Construct a graph representation using adjacency lists or matrices.\",\n    \"Check for a complete subgraph of 5 nodes (clique) in the graph.\",\n    \"Check for an independent set of 5 nodes in the graph.\",\n    \"Output the result based on whether a successful party configuration is found.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    friends = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique_of_size_5():\n        for node in range(1, N + 1):\n            if len(friends[node]) >= 4:\n                potential_clique = [node] + list(friends[node])\n                if len(potential_clique) >= 5:\n                    for i in range(len(potential_clique)):\n                        for j in range(i + 1, len(potential_clique)):\n                            if potential_clique[j] not in friends[potential_clique[i]]:\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        return potential_clique[:5]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for node in range(1, N + 1):\n            if len(friends[node]) < N - 1:\n                non_friends -= friends[node]\n                non_friends.discard(node)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    # Try to find a successful party configuration\n    clique = find_clique_of_size_5()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    # If no configuration is found, print -1\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where all 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a complete subgraph (clique) of size 5 in the friendship graph.\",\n        \"Use graph traversal techniques to identify cliques.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where no two of the 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a set of 5 individuals with no edges between them in the friendship graph.\",\n        \"Use graph traversal techniques to identify independent sets.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, print the 5 individuals.\",\n        \"If no configuration is found, print -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Construct a graph representation using adjacency lists or matrices.\",\n    \"Check for a clique of size 5 in the graph.\",\n    \"Check for an independent set of size 5 in the graph.\",\n    \"Output the result based on the checks.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    friends = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for a clique of size 5\n    def find_clique_of_size_5():\n        for a in range(1, N + 1):\n            for b in friends[a]:\n                if b <= a:\n                    continue\n                for c in friends[a].intersection(friends[b]):\n                    if c <= b:\n                        continue\n                    for d in friends[a].intersection(friends[b], friends[c]):\n                        if d <= c:\n                            continue\n                        for e in friends[a].intersection(friends[b], friends[c], friends[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for a in range(1, N + 1):\n            if len(non_friends) < 5:\n                break\n            non_friends.discard(a)\n            for b in non_friends:\n                if b in friends[a]:\n                    continue\n                non_friends.discard(b)\n                for c in non_friends:\n                    if c in friends[a] or c in friends[b]:\n                        continue\n                    non_friends.discard(c)\n                    for d in non_friends:\n                        if d in friends[a] or d in friends[b] or d in friends[c]:\n                            continue\n                        non_friends.discard(d)\n                        for e in non_friends:\n                            if e in friends[a] or e in friends[b] or e in friends[c] or e in friends[d]:\n                                continue\n                            return [a, b, c, d, e]\n                        non_friends.add(d)\n                    non_friends.add(c)\n                non_friends.add(b)\n            non_f", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where all 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a complete subgraph of 5 nodes in the friendship graph.\",\n        \"Use graph traversal techniques to identify cliques of size 5.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where no two of the 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a set of 5 nodes with no edges between them in the friendship graph.\",\n        \"Use graph traversal techniques to identify independent sets of size 5.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, print the 5 individuals.\",\n        \"If no configuration is found, print -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Construct a graph representation using adjacency lists or matrices.\",\n    \"Check for a complete subgraph of 5 nodes (clique) in the graph.\",\n    \"Check for an independent set of 5 nodes in the graph.\",\n    \"Output the result based on whether a successful party configuration is found.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    friends = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique_of_5():\n        for a in range(1, N + 1):\n            for b in friends[a]:\n                if b <= a:\n                    continue\n                for c in friends[a].intersection(friends[b]):\n                    if c <= b:\n                        continue\n                    for d in friends[a].intersection(friends[b], friends[c]):\n                        if d <= c:\n                            continue\n                        for e in friends[a].intersection(friends[b], friends[c], friends[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set_of_5():\n        non_friends = set(range(1, N + 1))\n        for a in range(1, N + 1):\n            if len(non_friends) < 5:\n                break\n            non_friends.discard(a)\n            for b in non_friends:\n                if b in friends[a]:\n                    continue\n                non_friends.discard(b)\n                for c in non_friends:\n                    if c in friends[a] or c in friends[b]:\n                        continue\n                    non_friends.discard(c)\n                    for d in non_friends:\n                        if d in friends[a] or d in friends[b] or d in friends[c]:\n                            continue\n                        non_friends.discard(d)\n                        for e in non_friends:\n                            if e in friends[a] or e in friends[b] or e in friends[c] or e in friends[d]:\n                                continue\n                            return [a, b, c, d, e]\n                        non_friends.add(d)\n                    non_friends.add(c)\n                non_friends.add(b)", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 274, "prompt": "In the large island of Baltia, N individuals reside, identified by numbers ranging from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. Note that each pair counts as a bidirectional friendship.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "rephrase_one", "save_node": true, "parent_index": 182}
