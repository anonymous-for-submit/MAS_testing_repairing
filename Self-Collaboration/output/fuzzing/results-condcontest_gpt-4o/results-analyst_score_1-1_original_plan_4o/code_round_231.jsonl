{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "repair_prompt": ["CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks, and each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns, and corners can be any type.\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal. Assume that both n and m are always greater than or equal to 5. You are tasked with designing an algorithm to solve this problem efficiently.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n                        \n                        # Check the border conditions for obsidian blocks\n                        for x in range(start_row + 1, start_row + a - 1):\n                            if grid[x][start_col] != '1':\n                                operations += 1\n                            if grid[x][start_col + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(start_col + 1, start_col + b - 1):\n                            if grid[start_row][y] != '1':\n                                operations += 1\n                            if grid[start_row + a - 1][y] != '1':\n                                operations += 1\n                        \n                        # Check the inner blocks for empty blocks\n                        for x in range(start_row + 1, start_row + a - 1):\n                            for y in range(start_col + 1, start_col + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Track the minimum number of operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = 0\n                        \n                        # Check border conditions for obsidian blocks\n                        # Top and bottom borders\n                        for x in range(1, b - 1):\n                            if grid[i][j + x] != '1':\n                                operations += 1\n                            if grid[i + a - 1][j + x] != '1':\n                                operations += 1\n                        \n                        # Left and right borders\n                        for y in range(1, a - 1):\n                            if grid[i + y][j] != '1':\n                                operations += 1\n                            if grid[i + y][j + b - 1] != '1':\n                                operations += 1\n                        \n                        # Inner blocks should be empty\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    operations += 1\n                        \n                        # Track the minimum number of operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles of size a x b\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        operations = 0\n                        \n                        # Check the borders and inner blocks of the sub-rectangle\n                        for x in range(a):\n                            for y in range(b):\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and y == 0) or (x == 0 and y == b - 1) or (x == a - 1 and y == 0) or (x == a - 1 and y == b - 1):\n                                        # Corners can be any type, no operation needed\n                                        continue\n                                    else:\n                                        # Borders must be obsidian blocks\n                                        if grid[i + x][j + y] == '0':\n                                            operations += 1\n                                else:\n                                    # Inner blocks must be empty\n                                    if grid[i + x][j + y] == '1':\n                                        operations += 1\n                        \n                        # Track the minimum number of operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):  # a >= 5\n            for start_col in range(m - 3):  # b >= 4\n                # Check all possible sizes of sub-rectangles starting from (start_row, start_col)\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations to make this sub-rectangle a portal\n                        operations = 0\n                        \n                        # Top and bottom borders\n                        for x in range(1, b - 1):\n                            if grid[start_row][start_col + x] == '0':  # Top border\n                                operations += 1\n                            if grid[start_row + a - 1][start_col + x] == '0':  # Bottom border\n                                operations += 1\n                        \n                        # Left and right borders\n                        for y in range(1, a - 1):\n                            if grid[start_row + y][start_col] == '0':  # Left border\n                                operations += 1\n                            if grid[start_row + y][start_col + b - 1] == '0':  # Right border\n                                operations += 1\n                        \n                        # Inner area\n                        for y in range(1, a - 1):\n                            for x in range(1, b - 1):\n                                if grid[start_row + y][start_col + x] == '1':\n                                    operations += 1\n                        \n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m,\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles of size a x b\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        operations = 0\n                        \n                        # Check the borders and inner blocks of the sub-rectangle\n                        for x in range(a):\n                            for y in range(b):\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and y == 0) or (x == 0 and y == b - 1) or (x == a - 1 and y == 0) or (x == a - 1 and y == b - 1):\n                                        # Corners can be any type, no operation needed\n                                        continue\n                                    else:\n                                        # Border blocks must be obsidian (1)\n                                        if grid[i + x][j + y] == '0':\n                                            operations += 1\n                                else:\n                                    # Inner blocks must be empty (0)\n                                    if grid[i + x][j + y] == '1':\n                                        operations += 1\n                        \n                        # Track the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check the border conditions\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and (y == 0 or y == b - 1)) or (x == a - 1 and (y == 0 or y == b - 1)):\n                                        # Corners can be any type\n                                        continue\n                                    else:\n                                        # Border should be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inside should be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = 0\n                        \n                        # Check border conditions\n                        for x in range(1, a - 1):\n                            if grid[i + x][j] != '1':\n                                operations += 1\n                            if grid[i + x][j + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(1, b - 1):\n                            if grid[i][j + y] != '1':\n                                operations += 1\n                            if grid[i + a - 1][j + y] != '1':\n                                operations += 1\n                        \n                        # Check inner area conditions\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    operations += 1\n                        \n                        # Update minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Iterate over all possible sizes of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check the border conditions\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and (y == 0 or y == b - 1)) or (x == a - 1 and (y == 0 or y == b - 1)):\n                                        # Corners can be any type, no operation needed\n                                        continue\n                                    else:\n                                        # Border should be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inside should be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Calculate operations needed for sub-rectangle of size 5x4\n                operations = 0\n                \n                # Check the borders and inner blocks\n                for i in range(5):\n                    for j in range(4):\n                        current_block = grid[start_row + i][start_col + j]\n                        \n                        if i == 0 or i == 4:  # Top and bottom borders\n                            if j > 0 and j < 3:  # Must be obsidian\n                                if current_block == '0':\n                                    operations += 1\n                        elif j == 0 or j == 3:  # Left and right borders\n                            if i > 0 and i < 4:  # Must be obsidian\n                                if current_block == '0':\n                                    operations += 1\n                        else:  # Inner blocks must be empty\n                            if current_block == '1':\n                                operations += 1\n                \n                # Update minimum operations\n                min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Check all possible sizes of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n                        \n                        # Check the borders and inner blocks\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                if (x == 0 or x == a - 1) and (y == 0 or y == b - 1):\n                                    # Corners can be any type, no operation needed\n                                    continue\n                                elif x == 0 or x == a - 1 or y == 0 or y == b - 1:\n                                    # Border blocks must be obsidian (1)\n                                    if current_block == '0':\n                                        operations += 1\n                                else:\n                                    # Inner blocks must be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Track the minimum number of operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n                        \n                        # Check the border conditions for obsidian blocks\n                        for x in range(start_row + 1, start_row + a - 1):\n                            if grid[x][start_col] != '1':\n                                operations += 1\n                            if grid[x][start_col + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(start_col + 1, start_col + b - 1):\n                            if grid[start_row][y] != '1':\n                                operations += 1\n                            if grid[start_row + a - 1][y] != '1':\n                                operations += 1\n                        \n                        # Check the inner blocks for empty blocks\n                        for x in range(start_row + 1, start_row + a - 1):\n                            for y in range(start_col + 1, start_col + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Track the minimum number of operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the block configuration for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read integers n and m, the dimensions of the rectangle.\",\n        \"Read n lines of m characters representing the block configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given rectangle that can potentially be transformed into a portal.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles within the n \u00d7 m rectangle.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b where a \u2265 5 and b \u2265 4.\",\n        \"Ensure the sub-rectangle fits within the bounds of the n \u00d7 m rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of operations needed to transform each sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each candidate sub-rectangle, check the border conditions for obsidian blocks.\",\n        \"Count the number of changes needed to satisfy the portal conditions.\",\n        \"Track the minimum number of operations across all candidate sub-rectangles.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum number of operations for each test case.\",\n      \"steps\": [\n        \"Store the minimum number of operations for each test case.\",\n        \"Print the result for each test case on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and block configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles of size a \u00d7 b.\",\n    \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n    \"Track and output the minimum number of operations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n                        \n                        # Check the border conditions for obsidian blocks\n                        for x in range(start_row + 1, start_row + a - 1):\n                            if grid[x][start_col] != '1':\n                                operations += 1\n                            if grid[x][start_col + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(start_col + 1, start_col + b - 1):\n                            if grid[start_row][y] != '1':\n                                operations += 1\n                            if grid[start_row + a - 1][y] != '1':\n                                operations += 1\n                        \n                        # Check the inner blocks for empty blocks\n                        for x in range(start_row + 1, start_row + a - 1):\n                            for y in range(start_col + 1, start_col + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Track the minimum number of operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the integers n and m.\",\n        \"For each test case, read the n lines of m characters representing the grid.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b that can be potential portals.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles within the grid.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b where a \u2265 5 and b \u2265 4.\",\n        \"Ensure that the sub-rectangle fits within the bounds of the grid.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of operations needed to transform each sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each candidate sub-rectangle, check the border conditions for obsidian blocks.\",\n        \"Count the number of changes needed to satisfy the portal conditions.\",\n        \"Track the minimum number of operations required across all candidate sub-rectangles.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum number of operations for each test case.\",\n      \"steps\": [\n        \"Store the minimum operations for each test case.\",\n        \"Print the result for each test case on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles of size a \u00d7 b.\",\n    \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n    \"Track and output the minimum number of operations required for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = 0\n                        \n                        # Check border conditions for obsidian blocks\n                        # Top and bottom borders\n                        for x in range(1, b - 1):\n                            if grid[i][j + x] != '1':\n                                operations += 1\n                            if grid[i + a - 1][j + x] != '1':\n                                operations += 1\n                        \n                        # Left and right borders\n                        for y in range(1, a - 1):\n                            if grid[i + y][j] != '1':\n                                operations += 1\n                            if grid[i + y][j + b - 1] != '1':\n                                operations += 1\n                        \n                        # Inner blocks should be empty\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    operations += 1\n                        \n                        # Track the minimum number of operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposition\": [\n    {\n      \"subproblem\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal.\"\n    },\n    {\n      \"subproblem\": \"Check if a sub-rectangle satisfies the portal conditions.\",\n      \"details\": \"Verify the conditions for the borders and the inner blocks of the sub-rectangle.\"\n    },\n    {\n      \"subproblem\": \"Calculate the number of operations needed to convert a sub-rectangle into a portal.\",\n      \"details\": \"Count the number of changes required for each block to satisfy the portal conditions.\"\n    },\n    {\n      \"subproblem\": \"Determine the minimum number of operations across all possible sub-rectangles.\",\n      \"details\": \"Keep track of the minimum operations needed for any valid portal configuration.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse the input to extract the number of test cases and the dimensions and block configurations for each test case.\"\n    },\n    {\n      \"step\": \"For each test case, iterate over all possible sub-rectangles of size a \u00d7 b within the n \u00d7 m rectangle.\"\n    },\n    {\n      \"step\": \"For each sub-rectangle, check if it can be transformed into a portal by verifying the conditions for obsidian and empty blocks.\"\n    },\n    {\n      \"step\": \"Calculate the number of operations needed to transform the sub-rectangle into a portal.\"\n    },\n    {\n      \"step\": \"Track the minimum number of operations required for any sub-rectangle to become a portal.\"\n    },\n    {\n      \"step\": \"Output the minimum number of operations for each test case.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles of size a x b\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        operations = 0\n                        \n                        # Check the borders and inner blocks of the sub-rectangle\n                        for x in range(a):\n                            for y in range(b):\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and y == 0) or (x == 0 and y == b - 1) or (x == a - 1 and y == 0) or (x == a - 1 and y == b - 1):\n                                        # Corners can be any type, no operation needed\n                                        continue\n                                    else:\n                                        # Borders must be obsidian blocks\n                                        if grid[i + x][j + y] == '0':\n                                            operations += 1\n                                else:\n                                    # Inner blocks must be empty\n                                    if grid[i + x][j + y] == '1':\n                                        operations += 1\n                        \n                        # Track the minimum number of operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"details\": \"Read the input data and store it in a structured format for easy access during processing.\"\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m grid.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and ensure the dimensions meet the minimum requirements (a \u2265 5, b \u2265 4).\"\n    },\n    {\n      \"description\": \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n      \"details\": \"Check each block in the sub-rectangle against the portal conditions and count the number of changes required.\"\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required across all possible sub-rectangles for each test case.\",\n      \"details\": \"Compare the operation counts for all sub-rectangles and select the minimum value.\"\n    },\n    {\n      \"description\": \"Output the minimum number of operations for each test case.\",\n      \"details\": \"Format the results according to the specified output requirements.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases, dimensions, and grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles of size a \u00d7 b within the n \u00d7 m grid.\",\n    \"For each sub-rectangle, evaluate the number of operations needed to convert it into a portal.\",\n    \"Track the minimum number of operations required for each test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):  # a >= 5\n            for start_col in range(m - 3):  # b >= 4\n                # Check all possible sizes of sub-rectangles starting from (start_row, start_col)\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations to make this sub-rectangle a portal\n                        operations = 0\n                        \n                        # Top and bottom borders\n                        for x in range(1, b - 1):\n                            if grid[start_row][start_col + x] == '0':  # Top border\n                                operations += 1\n                            if grid[start_row + a - 1][start_col + x] == '0':  # Bottom border\n                                operations += 1\n                        \n                        # Left and right borders\n                        for y in range(1, a - 1):\n                            if grid[start_row + y][start_col] == '0':  # Left border\n                                operations += 1\n                            if grid[start_row + y][start_col + b - 1] == '0':  # Right border\n                                operations += 1\n                        \n                        # Inner area\n                        for y in range(1, a - 1):\n                            for x in range(1, b - 1):\n                                if grid[start_row + y][start_col + x] == '1':\n                                    operations += 1\n                        \n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m,", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 62)"}, "Round_1": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):  # a >= 5\n            for start_col in range(m - 3):  # b >= 4\n                # Check all possible sizes of sub-rectangles starting from (start_row, start_col)\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations to make this sub-rectangle a portal\n                        operations = 0\n                        \n                        # Top and bottom borders\n                        for x in range(1, b - 1):\n                            if grid[start_row][start_col + x] == '0':  # Top border\n                                operations += 1\n                            if grid[start_row + a - 1][start_col + x] == '0':  # Bottom border\n                                operations += 1\n                        \n                        # Left and right borders\n                        for y in range(1, a - 1):\n                            if grid[start_row + y][start_col] == '0':  # Left border\n                                operations += 1\n                            if grid[start_row + y][start_col + b - 1] == '0':  # Right border\n                                operations += 1\n                        \n                        # Inner area\n                        for y in range(1, a - 1):\n                            for x in range(1, b - 1):\n                                if grid[start_row + y][start_col + x] == '1':\n                                    operations += 1\n                        \n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m,"}}, {"plan": "```json\n{\n  \"decomposition\": [\n    {\n      \"subproblem\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal.\"\n    },\n    {\n      \"subproblem\": \"Check if a sub-rectangle satisfies the portal conditions.\",\n      \"details\": \"Verify the conditions for the borders and the inner blocks of the sub-rectangle.\"\n    },\n    {\n      \"subproblem\": \"Calculate the number of operations needed to convert a sub-rectangle into a portal.\",\n      \"details\": \"Count the number of changes required for each block to satisfy the portal conditions.\"\n    },\n    {\n      \"subproblem\": \"Determine the minimum number of operations across all possible sub-rectangles.\",\n      \"details\": \"Keep track of the minimum operations needed for any valid portal configuration.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse the input to extract the number of test cases and the dimensions and block configurations for each test case.\"\n    },\n    {\n      \"step\": \"For each test case, iterate over all possible sub-rectangles of size a \u00d7 b within the n \u00d7 m rectangle.\"\n    },\n    {\n      \"step\": \"For each sub-rectangle, check if it can be transformed into a portal by verifying the conditions for obsidian and empty blocks.\"\n    },\n    {\n      \"step\": \"Calculate the number of operations needed to transform the sub-rectangle into a portal.\"\n    },\n    {\n      \"step\": \"Track the minimum number of operations required for any sub-rectangle to become a portal.\"\n    },\n    {\n      \"step\": \"Output the minimum number of operations for each test case.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles of size a x b\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        operations = 0\n                        \n                        # Check the borders and inner blocks of the sub-rectangle\n                        for x in range(a):\n                            for y in range(b):\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and y == 0) or (x == 0 and y == b - 1) or (x == a - 1 and y == 0) or (x == a - 1 and y == b - 1):\n                                        # Corners can be any type, no operation needed\n                                        continue\n                                    else:\n                                        # Border blocks must be obsidian (1)\n                                        if grid[i + x][j + y] == '0':\n                                            operations += 1\n                                else:\n                                    # Inner blocks must be empty (0)\n                                    if grid[i + x][j + y] == '1':\n                                        operations += 1\n                        \n                        # Track the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the dimensions n and m.\",\n        \"Read the n lines of m characters representing the grid configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b that can be potential portals.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles within the grid.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b where a \u2265 5 and b \u2265 4.\",\n        \"Ensure the sub-rectangle fits within the grid boundaries.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of operations needed to transform each sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each candidate sub-rectangle, check the border conditions for obsidian blocks.\",\n        \"Count the number of changes needed to satisfy the portal conditions.\",\n        \"Consider the flexibility of corner blocks which can be any type.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required for each test case.\",\n      \"steps\": [\n        \"For each test case, track the minimum operations needed across all candidate sub-rectangles.\",\n        \"Store the result for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles that can be transformed into a portal.\",\n    \"For each sub-rectangle, calculate the number of operations needed to meet the portal conditions.\",\n    \"Track and output the minimum number of operations required for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check the border conditions\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and (y == 0 or y == b - 1)) or (x == a - 1 and (y == 0 or y == b - 1)):\n                                        # Corners can be any type\n                                        continue\n                                    else:\n                                        # Border should be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inside should be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: min_operations_to_portal() missing 1 required positional argument: 'test_cases'"}, "Round_1": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check the border conditions\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and (y == 0 or y == b - 1)) or (x == a - 1 and (y == 0 or y == b - 1)):\n                                        # Corners can be any type\n                                        continue\n                                    else:\n                                        # Border should be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inside should be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the dimensions n and m.\",\n        \"Read the n lines of m characters representing the grid configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m grid that can potentially be transformed into a portal.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles within the grid.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b where a \u2265 5 and b \u2265 4.\",\n        \"Ensure that the sub-rectangle fits within the bounds of the n \u00d7 m grid.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of operations required to transform each identified sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each sub-rectangle, check the border conditions for obsidian blocks and count the number of changes needed.\",\n        \"Check the inner area conditions for empty blocks and count the number of changes needed.\",\n        \"Sum the changes to get the total operations required for each sub-rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required across all possible sub-rectangles for each test case.\",\n      \"steps\": [\n        \"Compare the total operations required for each sub-rectangle within a test case.\",\n        \"Select the minimum value as the result for that test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles of size a \u00d7 b.\",\n    \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n    \"Track the minimum number of operations required for each test case.\",\n    \"Output the minimum number of operations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = 0\n                        \n                        # Check border conditions\n                        for x in range(1, a - 1):\n                            if grid[i + x][j] != '1':\n                                operations += 1\n                            if grid[i + x][j + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(1, b - 1):\n                            if grid[i][j + y] != '1':\n                                operations += 1\n                            if grid[i + a - 1][j + y] != '1':\n                                operations += 1\n                        \n                        # Check inner area conditions\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    operations += 1\n                        \n                        # Update minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"details\": \"Read the input data and store it in a structured format for easy access during processing.\"\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m grid.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and ensure the dimensions meet the minimum requirements (a \u2265 5, b \u2265 4).\"\n    },\n    {\n      \"description\": \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n      \"details\": \"Check each block in the sub-rectangle against the portal conditions and count the number of changes required.\"\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required across all possible sub-rectangles for each test case.\",\n      \"details\": \"Compare the operation counts for all sub-rectangles and select the minimum value.\"\n    },\n    {\n      \"description\": \"Output the minimum number of operations for each test case.\",\n      \"details\": \"Format the results according to the specified output requirements.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases, dimensions, and grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles of size a \u00d7 b within the n \u00d7 m grid.\",\n    \"For each sub-rectangle, evaluate the number of operations needed to convert it into a portal.\",\n    \"Track the minimum number of operations required for each test case.\",\n    \"Output the minimum number of operations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Iterate over all possible sizes of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check the border conditions\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and (y == 0 or y == b - 1)) or (x == a - 1 and (y == 0 or y == b - 1)):\n                                        # Corners can be any type, no operation needed\n                                        continue\n                                    else:\n                                        # Border should be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inside should be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposition\": [\n    {\n      \"subproblem\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal.\"\n    },\n    {\n      \"subproblem\": \"Check if a sub-rectangle satisfies the portal conditions.\",\n      \"details\": \"Verify the conditions for the borders and the inner blocks of the sub-rectangle.\"\n    },\n    {\n      \"subproblem\": \"Calculate the number of operations needed to convert a sub-rectangle into a portal.\",\n      \"details\": \"Count the number of changes required for each block to satisfy the portal conditions.\"\n    },\n    {\n      \"subproblem\": \"Determine the minimum number of operations across all possible sub-rectangles.\",\n      \"details\": \"Keep track of the minimum operations needed for any valid portal configuration.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse the input to extract the number of test cases and the dimensions and block configurations for each test case.\"\n    },\n    {\n      \"step\": \"For each test case, iterate over all possible sub-rectangles of size a \u00d7 b within the n \u00d7 m rectangle.\"\n    },\n    {\n      \"step\": \"For each sub-rectangle, check if it can be transformed into a portal by verifying the conditions for obsidian and empty blocks.\"\n    },\n    {\n      \"step\": \"Calculate the number of operations needed to transform the sub-rectangle into a portal.\"\n    },\n    {\n      \"step\": \"Track the minimum number of operations required for any sub-rectangle to become a portal.\"\n    },\n    {\n      \"step\": \"Output the minimum number of operations for each test case.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Calculate operations needed for sub-rectangle of size 5x4\n                operations = 0\n                \n                # Check the borders and inner blocks\n                for i in range(5):\n                    for j in range(4):\n                        current_block = grid[start_row + i][start_col + j]\n                        \n                        if i == 0 or i == 4:  # Top and bottom borders\n                            if j > 0 and j < 3:  # Must be obsidian\n                                if current_block == '0':\n                                    operations += 1\n                        elif j == 0 or j == 3:  # Left and right borders\n                            if i > 0 and i < 4:  # Must be obsidian\n                                if current_block == '0':\n                                    operations += 1\n                        else:  # Inner blocks must be empty\n                            if current_block == '1':\n                                operations += 1\n                \n                # Update minimum operations\n                min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal.\"\n    },\n    {\n      \"description\": \"Check if a sub-rectangle satisfies the portal conditions.\",\n      \"details\": \"Verify the conditions for the borders and the inner blocks of the sub-rectangle.\"\n    },\n    {\n      \"description\": \"Calculate the number of operations needed to convert a sub-rectangle into a portal.\",\n      \"details\": \"Count the number of changes required for each block in the sub-rectangle to meet the portal conditions.\"\n    },\n    {\n      \"description\": \"Determine the minimum number of operations across all sub-rectangles.\",\n      \"details\": \"Compare the operation counts for all valid sub-rectangles and select the minimum.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, read the dimensions n and m, and the n \u00d7 m grid.\",\n    \"Iterate over all possible sub-rectangles of size a \u00d7 b within the grid.\",\n    \"For each sub-rectangle, check if it can be transformed into a portal.\",\n    \"Calculate the number of operations needed for each sub-rectangle to become a portal.\",\n    \"Track the minimum number of operations required across all sub-rectangles.\",\n    \"Output the minimum number of operations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Check all possible sizes of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n                        \n                        # Check the borders and inner blocks\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                if (x == 0 or x == a - 1) and (y == 0 or y == b - 1):\n                                    # Corners can be any type, no operation needed\n                                    continue\n                                elif x == 0 or x == a - 1 or y == 0 or y == b - 1:\n                                    # Border blocks must be obsidian (1)\n                                    if current_block == '0':\n                                        operations += 1\n                                else:\n                                    # Inner blocks must be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Track the minimum number of operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the block configuration for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read integers n and m, the dimensions of the rectangle.\",\n        \"Read n lines of m characters representing the block configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given rectangle that can potentially be transformed into a portal.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles within the n \u00d7 m rectangle.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b where a \u2265 5 and b \u2265 4.\",\n        \"Ensure the sub-rectangle fits within the bounds of the n \u00d7 m rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of operations needed to transform each sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each candidate sub-rectangle, check the border conditions for obsidian blocks.\",\n        \"Count the number of changes needed to satisfy the portal conditions.\",\n        \"Track the minimum number of operations across all candidate sub-rectangles.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum number of operations for each test case.\",\n      \"steps\": [\n        \"Store the minimum number of operations for each test case.\",\n        \"Print the result for each test case on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and block configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles of size a \u00d7 b.\",\n    \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n    \"Track and output the minimum number of operations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n                        \n                        # Check the border conditions for obsidian blocks\n                        for x in range(start_row + 1, start_row + a - 1):\n                            if grid[x][start_col] != '1':\n                                operations += 1\n                            if grid[x][start_col + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(start_col + 1, start_col + b - 1):\n                            if grid[start_row][y] != '1':\n                                operations += 1\n                            if grid[start_row + a - 1][y] != '1':\n                                operations += 1\n                        \n                        # Check the inner blocks for empty blocks\n                        for x in range(start_row + 1, start_row + a - 1):\n                            for y in range(start_col + 1, start_col + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Track the minimum number of operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, false, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 231, "prompt": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks, and each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns, and corners can be any type.\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal. Assume that both n and m are always greater than or equal to 5. You are tasked with designing an algorithm to solve this problem efficiently.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "add_1_sentence_at_end", "save_node": true, "parent_index": 151}
