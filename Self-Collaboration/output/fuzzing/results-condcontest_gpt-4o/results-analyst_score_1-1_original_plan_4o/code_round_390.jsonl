{"name": "1607_E. Robot on the Board 1", "description": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nThe sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).\n\nDetermine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "tags": ["implementation"], "difficulty": 11, "id": 1607, "sample_io": [{"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}], "test_list": [{"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n5 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n1 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 1\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 4\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n1 1\n3 4\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n2 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 1\n2 1\n4 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRUDLLLDU\n", "output": ["1 2\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n2 2\nLUUDRLDLRLUU\n", "output": ["1 1\n1 2\n2 1\n2 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 1\nUULDRR\n4 2\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 1\n1 1\n4 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 1\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nLRDRUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 2\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n17 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 1\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 1\n3 1\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n4 4\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n5 2\nL\n3 3\nRRDLUU\n6 3\nLUUURRDLLLDU\n", "output": ["1 1\n1 2\n2 1\n4 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n4 4\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 4\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 1\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n4 3\nRRDLUU\n3 4\nDUULRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n2 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 2\nUULRRD\n6 2\nUULULDRRDULL\n", "output": ["1 1\n1 2\n3 2\n4 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n13 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n9 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n22 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n8 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n6 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n1 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRDRLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n5 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n4 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUT\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n6 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRDRLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n4 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n6 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDURDURL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n10 3\nRRDLUU\n6 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 2\nLUUDRLDLRLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n7 3\nRRDLUU\n8 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n8 3\nLUUDRRDLLLUT\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n5 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n3 3\nRRDUUL\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n6 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n3 3\nUULDRR\n11 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n7 3\nRRDLUU\n8 2\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n3 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nDRRLUU\n6 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n12 3\nRRDLUU\n8 2\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n2 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n5 2\nL\n3 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n10 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n4 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nLUULRRDLDLUU\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n2 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n5 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n2 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n10 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n6 3\nRRDLUU\n9 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRRDLUU\n8 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n2 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nUULDRR\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n4 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRDRLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nLUULRRDDLLUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nUULDRR\n4 2\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n6 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 4\nLUUDRRLLLDUU\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDURDURL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n1 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n2 2\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n5 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n8 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nDRRLUU\n6 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n5 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n12 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nUULDRR\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDTUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n5 3\nUUULLDRRDULL\n", "output": ["1 1\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 1\nL\n10 2\nL\n2 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 2\nUULDRR\n10 3\nLUULRRDDLLUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n23 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDTUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n13 2\nL\n2 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n6 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n9 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n15 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLRUURDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n4 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDUUL\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n4 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n11 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUV\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n5 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n12 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nUULRDR\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}], "task_id": "codecontest/102", "repair_prompt": ["The robot is positioned on a checkered board with dimensions n \u00d7 m, where n is the number of rows and m is the number of columns, and the rows are numbered from top to bottom starting at 1 while columns are numbered from left to right beginning at 1. The robot is capable of moving from its current position to any of the four adjacent cells.\n\nThe robot follows a given sequence of commands, denoted by the symbols 'L', 'R', 'D', or 'U', which correspond to movements to the left, right, down, or up, respectively.\n\nThe robot is free to begin its journey from any cell, and it follows the commands in the exact order they are presented in the sequence s, but moving off the board results in the robot falling and breaking, and such a command isn't counted as successful.\n\nThe goal for the robot is to carry out as many commands as it can without falling off the board. For instance, on a 3 \u00d7 3 board, if the robot begins the sequence s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the center, it will execute one command, but the next will make it cross the edge. Starting from cell (2, 1) (second row, first column), the robot will execute all commands and finish at cell (1, 2) (first row, second column).\n\n<image> The robot begins at cell (2, 1) (second row, first column), moves to the right twice, down, left, and up twice, and in this situation concludes at cell (1, 2) (first row, second column).\n\nFigure out the starting cell for the robot to maximize the execution of commands without going off the board.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def find_optimal_starting_position(n, m, s):\n    # Calculate the net effect of the command sequence\n    min_row, max_row, min_col, max_col = 0, 0, 0, 0\n    current_row, current_col = 0, 0\n    \n    for command in s:\n        if command == 'L':\n            current_col -= 1\n        elif command == 'R':\n            current_col += 1\n        elif command == 'U':\n            current_row -= 1\n        elif command == 'D':\n            current_row += 1\n        \n        min_row = min(min_row, current_row)\n        max_row = max(max_row, current_row)\n        min_col = min(min_col, current_col)\n        max_col = max(max_col, current_col)\n    \n    # Determine the optimal starting position\n    start_row = 1 - min_row\n    start_col = 1 - min_col\n    \n    # Ensure the starting position is within bounds\n    if start_row + max_row <= n and start_col + max_col <= m:\n        return start_row, start_col\n    else:\n        return None\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        result = find_optimal_starting_position(n, m, s)\n        if result:\n            results.append(f\"{result[0]} {result[1]}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def simulate_robot(n, m, s, start_r, start_c):\n    r, c = start_r, start_c\n    successful_commands = 0\n    \n    for command in s:\n        if command == 'L':\n            c -= 1\n        elif command == 'R':\n            c += 1\n        elif command == 'U':\n            r -= 1\n        elif command == 'D':\n            r += 1\n        \n        if r < 1 or r > n or c < 1 or c > m:\n            break\n        \n        successful_commands += 1\n    \n    return successful_commands\n\ndef find_optimal_start(n, m, s):\n    max_commands = 0\n    optimal_start = (1, 1)\n    \n    for start_r in range(1, n + 1):\n        for start_c in range(1, m + 1):\n            commands_executed = simulate_robot(n, m, s, start_r, start_c)\n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                optimal_start = (start_r, start_c)\n    \n    return optimal_start\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        s = data[index + 1]\n        index += 2\n        \n        optimal_start = find_optimal_start(n, m, s)\n        results.append(f\"{optimal_start[0]} {optimal_start[1]}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_robot(n, m, s, start_r, start_c):\n    r, c = start_r, start_c\n    successful_commands = 0\n    \n    for command in s:\n        if command == 'L':\n            c -= 1\n        elif command == 'R':\n            c += 1\n        elif command == 'U':\n            r -= 1\n        elif command == 'D':\n            r += 1\n        \n        if r < 1 or r > n or c < 1 or c > m:\n            break\n        \n        successful_commands += 1\n    \n    return successful_commands\n\ndef find_optimal_start(n, m, s):\n    max_commands = 0\n    optimal_start = (1, 1)\n    \n    for start_r in range(1, n + 1):\n        for start_c in range(1, m + 1):\n            commands_executed = simulate_robot(n, m, s, start_r, start_c)\n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                optimal_start = (start_r, start_c)\n    \n    return optimal_start\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        s = data[index + 1]\n        index += 2\n        \n        optimal_start = find_optimal_start(n, m, s)\n        results.append(f\"{optimal_start[0]} {optimal_start[1]}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_best_starting_position(n, m, commands):\n    # Initialize variables to track the best starting position\n    max_successful_commands = 0\n    best_starting_position = (1, 1)\n\n    # Iterate over all possible starting positions\n    for start_row in range(1, n + 1):\n        for start_col in range(1, m + 1):\n            current_row, current_col = start_row, start_col\n            successful_commands = 0\n\n            # Simulate the robot's movement\n            for command in commands:\n                if command == 'L':\n                    current_col -= 1\n                elif command == 'R':\n                    current_col += 1\n                elif command == 'U':\n                    current_row -= 1\n                elif command == 'D':\n                    current_row += 1\n\n                # Check if the robot is still on the board\n                if 1 <= current_row <= n and 1 <= current_col <= m:\n                    successful_commands += 1\n                else:\n                    break\n\n            # Update the best starting position if needed\n            if successful_commands > max_successful_commands:\n                max_successful_commands = successful_commands\n                best_starting_position = (start_row, start_col)\n\n    return best_starting_position\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        commands = data[index + 1]\n        index += 2\n\n        best_position = find_best_starting_position(n, m, commands)\n        results.append(f\"{best_position[0]} {best_position[1]}\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        # Calculate the net effect of the command sequence\n        min_row, max_row, min_col, max_col = 0, 0, 0, 0\n        current_row, current_col = 0, 0\n        \n        for command in s:\n            if command == 'L':\n                current_col -= 1\n            elif command == 'R':\n                current_col += 1\n            elif command == 'U':\n                current_row -= 1\n            elif command == 'D':\n                current_row += 1\n            \n            min_row = min(min_row, current_row)\n            max_row = max(max_row, current_row)\n            min_col = min(min_col, current_col)\n            max_col = max(max_col, current_col)\n        \n        # Determine the best starting position\n        start_row = 1 - min_row\n        start_col = 1 - min_col\n        \n        if start_row + max_row <= n and start_col + max_col <= m:\n            results.append(f\"{start_row} {start_col}\")\n        else:\n            # If the calculated start position is invalid, adjust it\n            if start_row + max_row > n:\n                start_row = n - max_row\n            if start_col + max_col > m:\n                start_col = m - max_col\n            results.append(f\"{start_row} {start_col}\")\n    \n    # Output results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def max_commands_starting_position(n, m, s):\n    # Initialize variables to track the maximum commands executed and the best starting position\n    max_commands = 0\n    best_start = (1, 1)\n\n    # Iterate over all possible starting positions\n    for start_row in range(1, n + 1):\n        for start_col in range(1, m + 1):\n            # Simulate the robot's movement from the current starting position\n            current_row, current_col = start_row, start_col\n            commands_executed = 0\n\n            for command in s:\n                if command == 'L':\n                    current_col -= 1\n                elif command == 'R':\n                    current_col += 1\n                elif command == 'U':\n                    current_row -= 1\n                elif command == 'D':\n                    current_row += 1\n\n                # Check if the robot is still on the board\n                if 1 <= current_row <= n and 1 <= current_col <= m:\n                    commands_executed += 1\n                else:\n                    break\n\n            # Update the maximum commands and best starting position if needed\n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                best_start = (start_row, start_col)\n\n    return best_start\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n\n    results = []\n\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n\n        result = max_commands_starting_position(n, m, s)\n        results.append(result)\n\n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        # Calculate the net effect of the command sequence\n        min_row, max_row, min_col, max_col = 0, 0, 0, 0\n        current_row, current_col = 0, 0\n        \n        for command in s:\n            if command == 'L':\n                current_col -= 1\n            elif command == 'R':\n                current_col += 1\n            elif command == 'U':\n                current_row -= 1\n            elif command == 'D':\n                current_row += 1\n            \n            min_row = min(min_row, current_row)\n            max_row = max(max_row, current_row)\n            min_col = min(min_col, current_col)\n            max_col = max(max_col, current_col)\n        \n        # Determine the best starting position\n        start_row = 1 - min_row\n        start_col = 1 - min_col\n        \n        # Ensure the starting position is within the board\n        if start_row + max_row <= n and start_col + max_col <= m:\n            results.append(f\"{start_row} {start_col}\")\n        else:\n            # If the calculated starting position is not valid, adjust it\n            # This is a fallback, but given the constraints, it should not be needed\n            results.append(\"1 1\")\n    \n    # Output results\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_best_starting_position(n, m, s):\n    # Initialize the boundaries\n    min_row, max_row = 0, 0\n    min_col, max_col = 0, 0\n    \n    # Current position\n    current_row, current_col = 0, 0\n    \n    # Traverse the command sequence to find the boundaries\n    for command in s:\n        if command == 'L':\n            current_col -= 1\n        elif command == 'R':\n            current_col += 1\n        elif command == 'U':\n            current_row -= 1\n        elif command == 'D':\n            current_row += 1\n        \n        # Update boundaries\n        min_row = min(min_row, current_row)\n        max_row = max(max_row, current_row)\n        min_col = min(min_col, current_col)\n        max_col = max(max_col, current_col)\n    \n    # Calculate the best starting position\n    start_row = 1 - min_row\n    start_col = 1 - min_col\n    \n    # Ensure the starting position is within the board\n    if start_row + max_row < n and start_col + max_col < m:\n        return start_row, start_col\n    else:\n        return None\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        result = find_best_starting_position(n, m, s)\n        if result:\n            results.append(f\"{result[0]} {result[1]}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_optimal_starting_position(n, m, s):\n    # Calculate the net effect of the command sequence\n    min_row, max_row, min_col, max_col = 0, 0, 0, 0\n    current_row, current_col = 0, 0\n    \n    for command in s:\n        if command == 'L':\n            current_col -= 1\n        elif command == 'R':\n            current_col += 1\n        elif command == 'U':\n            current_row -= 1\n        elif command == 'D':\n            current_row += 1\n        \n        min_row = min(min_row, current_row)\n        max_row = max(max_row, current_row)\n        min_col = min(min_col, current_col)\n        max_col = max(max_col, current_col)\n    \n    # Determine the optimal starting position\n    start_row = 1 - min_row\n    start_col = 1 - min_col\n    \n    # Ensure the starting position is within the board boundaries\n    if start_row + max_row <= n and start_col + max_col <= m:\n        return start_row, start_col\n    else:\n        return None\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        result = find_optimal_starting_position(n, m, s)\n        if result:\n            results.append(f\"{result[0]} {result[1]}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        # Calculate the net effect of the command sequence\n        min_row, max_row, min_col, max_col = 0, 0, 0, 0\n        current_row, current_col = 0, 0\n        \n        for command in s:\n            if command == 'L':\n                current_col -= 1\n            elif command == 'R':\n                current_col += 1\n            elif command == 'U':\n                current_row -= 1\n            elif command == 'D':\n                current_row += 1\n            \n            min_row = min(min_row, current_row)\n            max_row = max(max_row, current_row)\n            min_col = min(min_col, current_col)\n            max_col = max(max_col, current_col)\n        \n        # Determine the best starting position\n        start_row = 1 - min_row\n        start_col = 1 - min_col\n        \n        if start_row + max_row <= n and start_col + max_col <= m:\n            results.append(f\"{start_row} {start_col}\")\n        else:\n            # If the calculated start position is invalid, adjust it\n            if start_row + max_row > n:\n                start_row -= (start_row + max_row - n)\n            if start_col + max_col > m:\n                start_col -= (start_col + max_col - m)\n            results.append(f\"{start_row} {start_col}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_optimal_starting_position(n, m, s):\n    # Calculate the net effect of the command sequence\n    min_row, max_row, min_col, max_col = 0, 0, 0, 0\n    current_row, current_col = 0, 0\n    \n    for command in s:\n        if command == 'L':\n            current_col -= 1\n        elif command == 'R':\n            current_col += 1\n        elif command == 'U':\n            current_row -= 1\n        elif command == 'D':\n            current_row += 1\n        \n        min_row = min(min_row, current_row)\n        max_row = max(max_row, current_row)\n        min_col = min(min_col, current_col)\n        max_col = max(max_col, current_col)\n    \n    # Determine the optimal starting position\n    start_row = 1 - min_row\n    start_col = 1 - min_col\n    \n    # Ensure the starting position is within bounds\n    if start_row + max_row <= n and start_col + max_col <= m:\n        return start_row, start_col\n    else:\n        return None\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        result = find_optimal_starting_position(n, m, s)\n        if result:\n            results.append(f\"{result[0]} {result[1]}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n and m representing the board dimensions.\",\n        \"Read the string s representing the sequence of commands.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board for each test case to determine the optimal starting position.\",\n      \"steps\": [\n        \"Initialize variables to track the maximum number of successful commands and the corresponding starting position.\",\n        \"Iterate over all possible starting positions on the board.\",\n        \"For each starting position, simulate the robot's movement according to the command sequence s.\",\n        \"Track the number of successful commands executed before the robot falls off the board.\",\n        \"Update the maximum number of successful commands and the starting position if the current simulation yields a better result.\"\n      ]\n    },\n    {\n      \"description\": \"Output the optimal starting position for each test case.\",\n      \"steps\": [\n        \"For each test case, print the row and column of the optimal starting position that maximizes the number of successful commands.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences.\",\n    \"For each test case, iterate over all possible starting positions on the board.\",\n    \"Simulate the robot's movement for each starting position and track the number of successful commands.\",\n    \"Determine the starting position that allows the maximum number of successful commands without falling off the board.\",\n    \"Output the optimal starting position for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def find_optimal_starting_position(n, m, s):\n    # Calculate the net effect of the command sequence\n    min_row, max_row, min_col, max_col = 0, 0, 0, 0\n    current_row, current_col = 0, 0\n    \n    for command in s:\n        if command == 'L':\n            current_col -= 1\n        elif command == 'R':\n            current_col += 1\n        elif command == 'U':\n            current_row -= 1\n        elif command == 'D':\n            current_row += 1\n        \n        min_row = min(min_row, current_row)\n        max_row = max(max_row, current_row)\n        min_col = min(min_col, current_col)\n        max_col = max(max_col, current_col)\n    \n    # Determine the optimal starting position\n    start_row = 1 - min_row\n    start_col = 1 - min_col\n    \n    # Ensure the starting position is within bounds\n    if start_row + max_row <= n and start_col + max_col <= m:\n        return start_row, start_col\n    else:\n        return None\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        result = find_optimal_starting_position(n, m, s)\n        if result:\n            results.append(f\"{result[0]} {result[1]}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the board dimensions and the command sequence.\",\n      \"output\": \"A list of test cases, each containing the board dimensions (n, m) and the command sequence (s).\"\n    },\n    {\n      \"description\": \"For each test case, determine the possible starting positions on the board and simulate the robot's movement according to the command sequence.\",\n      \"output\": \"A function that simulates the robot's movement from a given starting position and returns the number of successful commands executed before falling off the board.\"\n    },\n    {\n      \"description\": \"Identify the starting position that allows the robot to execute the maximum number of commands without falling off the board.\",\n      \"output\": \"The coordinates (r, c) of the optimal starting position for each test case.\"\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"output\": \"Print the coordinates of the optimal starting position for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases from the input.\",\n    \"For each test case, read the board dimensions and the command sequence.\",\n    \"Initialize variables to track the maximum number of commands executed and the corresponding starting position.\",\n    \"Iterate over all possible starting positions on the board.\",\n    \"For each starting position, simulate the robot's movement according to the command sequence.\",\n    \"Count the number of successful commands executed before the robot falls off the board.\",\n    \"Update the maximum number of commands and the starting position if the current position allows more commands to be executed.\",\n    \"After evaluating all starting positions, store the optimal starting position for the current test case.\",\n    \"Output the optimal starting position for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def simulate_robot(n, m, s, start_r, start_c):\n    r, c = start_r, start_c\n    successful_commands = 0\n    \n    for command in s:\n        if command == 'L':\n            c -= 1\n        elif command == 'R':\n            c += 1\n        elif command == 'U':\n            r -= 1\n        elif command == 'D':\n            r += 1\n        \n        if r < 1 or r > n or c < 1 or c > m:\n            break\n        \n        successful_commands += 1\n    \n    return successful_commands\n\ndef find_optimal_start(n, m, s):\n    max_commands = 0\n    optimal_start = (1, 1)\n    \n    for start_r in range(1, n + 1):\n        for start_c in range(1, m + 1):\n            commands_executed = simulate_robot(n, m, s, start_r, start_c)\n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                optimal_start = (start_r, start_c)\n    \n    return optimal_start\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        s = data[index + 1]\n        index += 2\n        \n        optimal_start = find_optimal_start(n, m, s)\n        results.append(f\"{optimal_start[0]} {optimal_start[1]}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the board dimensions and the command sequence.\",\n      \"output\": \"A list of test cases, each containing the board dimensions (n, m) and the command sequence (s).\"\n    },\n    {\n      \"description\": \"For each test case, determine the possible starting positions on the board and simulate the robot's movement according to the command sequence.\",\n      \"output\": \"A function that simulates the robot's movement from a given starting position and returns the number of successful commands executed before falling off the board.\"\n    },\n    {\n      \"description\": \"Identify the starting position that allows the robot to execute the maximum number of commands without falling off the board.\",\n      \"output\": \"The coordinates (r, c) of the optimal starting position for each test case.\"\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"output\": \"Print the coordinates of the optimal starting position for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases from the input.\",\n    \"For each test case, read the board dimensions and the command sequence.\",\n    \"Initialize variables to track the maximum number of commands executed and the corresponding starting position.\",\n    \"Iterate over all possible starting positions on the board.\",\n    \"For each starting position, simulate the robot's movement according to the command sequence.\",\n    \"Track the number of successful commands executed before the robot falls off the board.\",\n    \"Update the maximum number of commands and the starting position if the current simulation results in more successful commands.\",\n    \"After evaluating all starting positions, store the optimal starting position for the current test case.\",\n    \"Output the optimal starting position for each test case in the required format.\"\n  ]\n}\n```", "Round_0": {"code": "def simulate_robot(n, m, s, start_r, start_c):\n    r, c = start_r, start_c\n    successful_commands = 0\n    \n    for command in s:\n        if command == 'L':\n            c -= 1\n        elif command == 'R':\n            c += 1\n        elif command == 'U':\n            r -= 1\n        elif command == 'D':\n            r += 1\n        \n        if r < 1 or r > n or c < 1 or c > m:\n            break\n        \n        successful_commands += 1\n    \n    return successful_commands\n\ndef find_optimal_start(n, m, s):\n    max_commands = 0\n    optimal_start = (1, 1)\n    \n    for start_r in range(1, n + 1):\n        for start_c in range(1, m + 1):\n            commands_executed = simulate_robot(n, m, s, start_r, start_c)\n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                optimal_start = (start_r, start_c)\n    \n    return optimal_start\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        s = data[index + 1]\n        index += 2\n        \n        optimal_start = find_optimal_start(n, m, s)\n        results.append(f\"{optimal_start[0]} {optimal_start[1]}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the board dimensions and the command sequence.\",\n      \"output\": \"A list of test cases, each containing the board dimensions and the command sequence.\"\n    },\n    {\n      \"description\": \"For each test case, determine the possible starting positions on the board.\",\n      \"output\": \"A list of all possible starting positions for the robot on the board.\"\n    },\n    {\n      \"description\": \"Simulate the robot's movement from each possible starting position according to the command sequence, ensuring the robot does not move off the board.\",\n      \"output\": \"The number of successful commands executed from each starting position.\"\n    },\n    {\n      \"description\": \"Identify the starting position that allows the maximum number of commands to be executed without the robot falling off the board.\",\n      \"output\": \"The starting position (row and column) that maximizes the number of successful commands.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, read the board dimensions and the command sequence.\",\n    \"Initialize a variable to track the maximum number of successful commands and the corresponding starting position.\",\n    \"Iterate over all possible starting positions on the board.\",\n    \"For each starting position, simulate the robot's movement according to the command sequence.\",\n    \"Track the number of successful commands executed before the robot falls off the board.\",\n    \"Update the maximum number of successful commands and the starting position if the current simulation exceeds the previous maximum.\",\n    \"After evaluating all starting positions, store the starting position with the maximum successful commands for the current test case.\",\n    \"Output the starting position for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def find_best_starting_position(n, m, commands):\n    # Initialize variables to track the best starting position\n    max_successful_commands = 0\n    best_starting_position = (1, 1)\n\n    # Iterate over all possible starting positions\n    for start_row in range(1, n + 1):\n        for start_col in range(1, m + 1):\n            current_row, current_col = start_row, start_col\n            successful_commands = 0\n\n            # Simulate the robot's movement\n            for command in commands:\n                if command == 'L':\n                    current_col -= 1\n                elif command == 'R':\n                    current_col += 1\n                elif command == 'U':\n                    current_row -= 1\n                elif command == 'D':\n                    current_row += 1\n\n                # Check if the robot is still on the board\n                if 1 <= current_row <= n and 1 <= current_col <= m:\n                    successful_commands += 1\n                else:\n                    break\n\n            # Update the best starting position if needed\n            if successful_commands > max_successful_commands:\n                max_successful_commands = successful_commands\n                best_starting_position = (start_row, start_col)\n\n    return best_starting_position\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        commands = data[index + 1]\n        index += 2\n\n        best_position = find_best_starting_position(n, m, commands)\n        results.append(f\"{best_position[0]} {best_position[1]}\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read the integers n and m representing the board dimensions.\",\n        \"Read the string s representing the sequence of commands.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board for each test case to determine the optimal starting position.\",\n      \"steps\": [\n        \"Initialize variables to track the maximum number of successful commands and the corresponding starting position.\",\n        \"Iterate over all possible starting positions on the board.\",\n        \"For each starting position, simulate the robot's movement according to the command sequence s.\",\n        \"Track the number of successful commands executed before the robot falls off the board.\",\n        \"Update the maximum number of successful commands and the starting position if the current simulation results in more successful commands.\"\n      ]\n    },\n    {\n      \"description\": \"Output the optimal starting position for each test case.\",\n      \"steps\": [\n        \"For each test case, print the row and column of the starting position that maximizes the number of successful commands.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences.\",\n    \"For each test case, iterate over all possible starting positions on the board.\",\n    \"Simulate the robot's movement for each starting position and track the number of successful commands.\",\n    \"Determine the starting position that allows the maximum number of successful commands.\",\n    \"Output the optimal starting position for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        # Calculate the net effect of the command sequence\n        min_row, max_row, min_col, max_col = 0, 0, 0, 0\n        current_row, current_col = 0, 0\n        \n        for command in s:\n            if command == 'L':\n                current_col -= 1\n            elif command == 'R':\n                current_col += 1\n            elif command == 'U':\n                current_row -= 1\n            elif command == 'D':\n                current_row += 1\n            \n            min_row = min(min_row, current_row)\n            max_row = max(max_row, current_row)\n            min_col = min(min_col, current_col)\n            max_col = max(max_col, current_col)\n        \n        # Determine the best starting position\n        start_row = 1 - min_row\n        start_col = 1 - min_col\n        \n        if start_row + max_row <= n and start_col + max_col <= m:\n            results.append(f\"{start_row} {start_col}\")\n        else:\n            # If the calculated start position is invalid, adjust it\n            if start_row + max_row > n:\n                start_row = n - max_row\n            if start_col + max_col > m:\n                start_col = m - max_col\n            results.append(f\"{start_row} {start_col}\")\n    \n    # Output results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the board dimensions and the command sequence.\",\n      \"output\": \"A list of test cases, each containing the board dimensions and the command sequence.\"\n    },\n    {\n      \"description\": \"For each test case, determine the possible starting positions on the board.\",\n      \"output\": \"A list of all possible starting positions for the robot on the board.\"\n    },\n    {\n      \"description\": \"Simulate the robot's movement from each possible starting position, following the command sequence, and track the number of successful commands executed before the robot falls off the board.\",\n      \"output\": \"For each starting position, the number of commands successfully executed.\"\n    },\n    {\n      \"description\": \"Identify the starting position that allows the maximum number of commands to be executed without the robot falling off the board.\",\n      \"output\": \"The starting position (row and column) that maximizes the number of executed commands.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases from the input.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Parse the board dimensions (n, m) and the command sequence (s).\",\n    \"  b. Initialize a variable to track the maximum number of commands executed and the corresponding starting position.\",\n    \"  c. Iterate over all possible starting positions on the board.\",\n    \"  d. For each starting position, simulate the robot's movement according to the command sequence.\",\n    \"  e. Count the number of commands executed before the robot falls off the board.\",\n    \"  f. If the current starting position results in more commands executed than previously recorded, update the maximum and the starting position.\",\n    \"Output the starting position for each test case that allows the maximum number of commands to be executed.\"\n  ]\n}\n```", "Round_0": {"code": "def max_commands_starting_position(n, m, s):\n    # Initialize variables to track the maximum commands executed and the best starting position\n    max_commands = 0\n    best_start = (1, 1)\n\n    # Iterate over all possible starting positions\n    for start_row in range(1, n + 1):\n        for start_col in range(1, m + 1):\n            # Simulate the robot's movement from the current starting position\n            current_row, current_col = start_row, start_col\n            commands_executed = 0\n\n            for command in s:\n                if command == 'L':\n                    current_col -= 1\n                elif command == 'R':\n                    current_col += 1\n                elif command == 'U':\n                    current_row -= 1\n                elif command == 'D':\n                    current_row += 1\n\n                # Check if the robot is still on the board\n                if 1 <= current_row <= n and 1 <= current_col <= m:\n                    commands_executed += 1\n                else:\n                    break\n\n            # Update the maximum commands and best starting position if needed\n            if commands_executed > max_commands:\n                max_commands = commands_executed\n                best_start = (start_row, start_col)\n\n    return best_start\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n\n    results = []\n\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n\n        result = max_commands_starting_position(n, m, s)\n        results.append(result)\n\n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the board dimensions and the command sequence.\",\n      \"output\": \"A list of test cases, each containing the board dimensions and the command sequence.\"\n    },\n    {\n      \"description\": \"For each test case, determine the possible starting positions on the board.\",\n      \"output\": \"A list of all possible starting positions for the robot on the board.\"\n    },\n    {\n      \"description\": \"Simulate the robot's movement from each possible starting position, following the command sequence, and track the number of successful commands executed before the robot falls off the board.\",\n      \"output\": \"For each starting position, the number of commands successfully executed.\"\n    },\n    {\n      \"description\": \"Identify the starting position that allows the maximum number of commands to be executed without the robot falling off the board.\",\n      \"output\": \"The starting position (row and column) that maximizes the number of executed commands.\"\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"output\": \"The starting position for each test case that maximizes command execution, formatted as required.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format containing the number of test cases and details for each test case.\",\n    \"For each test case, iterate over all possible starting positions on the board.\",\n    \"For each starting position, simulate the robot's movement according to the command sequence, keeping track of the number of commands executed before the robot falls off the board.\",\n    \"Compare the results of all starting positions to find the one that allows the maximum number of commands to be executed.\",\n    \"Store the optimal starting position for each test case.\",\n    \"Output the optimal starting positions for all test cases in the required format.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        # Calculate the net effect of the command sequence\n        min_row, max_row, min_col, max_col = 0, 0, 0, 0\n        current_row, current_col = 0, 0\n        \n        for command in s:\n            if command == 'L':\n                current_col -= 1\n            elif command == 'R':\n                current_col += 1\n            elif command == 'U':\n                current_row -= 1\n            elif command == 'D':\n                current_row += 1\n            \n            min_row = min(min_row, current_row)\n            max_row = max(max_row, current_row)\n            min_col = min(min_col, current_col)\n            max_col = max(max_col, current_col)\n        \n        # Determine the best starting position\n        start_row = 1 - min_row\n        start_col = 1 - min_col\n        \n        # Ensure the starting position is within the board\n        if start_row + max_row <= n and start_col + max_col <= m:\n            results.append(f\"{start_row} {start_col}\")\n        else:\n            # If the calculated starting position is not valid, adjust it\n            # This is a fallback, but given the constraints, it should not be needed\n            results.append(\"1 1\")\n    \n    # Output results\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the board dimensions and the command sequence.\",\n      \"output\": \"A list of test cases, each containing the board dimensions (n, m) and the command sequence (s).\"\n    },\n    {\n      \"description\": \"For each test case, determine the possible starting positions on the board.\",\n      \"output\": \"A list of all possible starting positions (r, c) for the robot on the board.\"\n    },\n    {\n      \"description\": \"Simulate the robot's movement from each possible starting position according to the command sequence, ensuring the robot does not fall off the board.\",\n      \"output\": \"For each starting position, the number of successful commands executed before the robot would fall off the board.\"\n    },\n    {\n      \"description\": \"Identify the starting position that allows the maximum number of commands to be executed without the robot falling off the board.\",\n      \"output\": \"The starting position (r, c) that maximizes the number of successful commands.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Parse the board dimensions (n, m) and the command sequence (s).\",\n    \"  b. Initialize a variable to track the maximum number of successful commands and the corresponding starting position.\",\n    \"  c. Iterate over all possible starting positions on the board.\",\n    \"  d. For each starting position, simulate the robot's movement according to the command sequence.\",\n    \"  e. Track the number of successful commands executed before the robot would fall off the board.\",\n    \"  f. Update the maximum number of successful commands and the starting position if the current position allows more commands.\",\n    \"Output the starting position for each test case that allows the maximum number of commands to be executed.\"\n  ]\n}\n```", "Round_0": {"code": "def find_best_starting_position(n, m, s):\n    # Initialize the boundaries\n    min_row, max_row = 0, 0\n    min_col, max_col = 0, 0\n    \n    # Current position\n    current_row, current_col = 0, 0\n    \n    # Traverse the command sequence to find the boundaries\n    for command in s:\n        if command == 'L':\n            current_col -= 1\n        elif command == 'R':\n            current_col += 1\n        elif command == 'U':\n            current_row -= 1\n        elif command == 'D':\n            current_row += 1\n        \n        # Update boundaries\n        min_row = min(min_row, current_row)\n        max_row = max(max_row, current_row)\n        min_col = min(min_col, current_col)\n        max_col = max(max_col, current_col)\n    \n    # Calculate the best starting position\n    start_row = 1 - min_row\n    start_col = 1 - min_col\n    \n    # Ensure the starting position is within the board\n    if start_row + max_row < n and start_col + max_col < m:\n        return start_row, start_col\n    else:\n        return None\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        result = find_best_starting_position(n, m, s)\n        if result:\n            results.append(f\"{result[0]} {result[1]}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read the integers n and m representing the board dimensions.\",\n        \"Read the string s representing the sequence of commands.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board for each test case to determine the optimal starting position.\",\n      \"steps\": [\n        \"Initialize variables to track the maximum number of successful commands and the corresponding starting position.\",\n        \"Iterate over all possible starting positions on the board.\",\n        \"For each starting position, simulate the robot's movement according to the command sequence s.\",\n        \"Track the number of successful commands executed before the robot falls off the board.\",\n        \"Update the maximum number of successful commands and the starting position if the current simulation results in more successful commands.\"\n      ]\n    },\n    {\n      \"description\": \"Output the optimal starting position for each test case.\",\n      \"steps\": [\n        \"For each test case, print the row and column of the starting position that maximizes the number of successful commands.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences.\",\n    \"For each test case, iterate over all possible starting positions on the board.\",\n    \"Simulate the robot's movement for each starting position and track the number of successful commands.\",\n    \"Determine the starting position that allows the maximum number of successful commands.\",\n    \"Output the optimal starting position for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def find_optimal_starting_position(n, m, s):\n    # Calculate the net effect of the command sequence\n    min_row, max_row, min_col, max_col = 0, 0, 0, 0\n    current_row, current_col = 0, 0\n    \n    for command in s:\n        if command == 'L':\n            current_col -= 1\n        elif command == 'R':\n            current_col += 1\n        elif command == 'U':\n            current_row -= 1\n        elif command == 'D':\n            current_row += 1\n        \n        min_row = min(min_row, current_row)\n        max_row = max(max_row, current_row)\n        min_col = min(min_col, current_col)\n        max_col = max(max_col, current_col)\n    \n    # Determine the optimal starting position\n    start_row = 1 - min_row\n    start_col = 1 - min_col\n    \n    # Ensure the starting position is within the board boundaries\n    if start_row + max_row <= n and start_col + max_col <= m:\n        return start_row, start_col\n    else:\n        return None\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        result = find_optimal_starting_position(n, m, s)\n        if result:\n            results.append(f\"{result[0]} {result[1]}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the board dimensions and the command sequence.\",\n      \"output\": \"A list of test cases, each containing the board dimensions and the command sequence.\"\n    },\n    {\n      \"description\": \"For each test case, determine the possible starting positions on the board.\",\n      \"output\": \"A list of all possible starting positions for the robot on the board.\"\n    },\n    {\n      \"description\": \"Simulate the robot's movement from each possible starting position, following the command sequence, and track the number of successful commands executed before the robot falls off the board.\",\n      \"output\": \"For each starting position, the number of commands successfully executed.\"\n    },\n    {\n      \"description\": \"Identify the starting position that allows the maximum number of commands to be executed without the robot falling off the board.\",\n      \"output\": \"The starting position (row and column) that maximizes the number of executed commands.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the board dimensions and the command sequence.\",\n    \"  b. Generate all possible starting positions on the board.\",\n    \"  c. For each starting position, simulate the robot's movement according to the command sequence.\",\n    \"  d. Track the number of successful commands executed for each starting position.\",\n    \"  e. Determine the starting position with the maximum number of successful commands.\",\n    \"Output the optimal starting position for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        # Calculate the net effect of the command sequence\n        min_row, max_row, min_col, max_col = 0, 0, 0, 0\n        current_row, current_col = 0, 0\n        \n        for command in s:\n            if command == 'L':\n                current_col -= 1\n            elif command == 'R':\n                current_col += 1\n            elif command == 'U':\n                current_row -= 1\n            elif command == 'D':\n                current_row += 1\n            \n            min_row = min(min_row, current_row)\n            max_row = max(max_row, current_row)\n            min_col = min(min_col, current_col)\n            max_col = max(max_col, current_col)\n        \n        # Determine the best starting position\n        start_row = 1 - min_row\n        start_col = 1 - min_col\n        \n        if start_row + max_row <= n and start_col + max_col <= m:\n            results.append(f\"{start_row} {start_col}\")\n        else:\n            # If the calculated start position is invalid, adjust it\n            if start_row + max_row > n:\n                start_row -= (start_row + max_row - n)\n            if start_col + max_col > m:\n                start_col -= (start_col + max_col - m)\n            results.append(f\"{start_row} {start_col}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n and m representing the board dimensions.\",\n        \"Read the string s representing the sequence of commands.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board for each test case to determine the optimal starting position.\",\n      \"steps\": [\n        \"Initialize variables to track the maximum number of successful commands and the corresponding starting position.\",\n        \"Iterate over all possible starting positions on the board.\",\n        \"For each starting position, simulate the robot's movement according to the command sequence s.\",\n        \"Track the number of successful commands executed before the robot falls off the board.\",\n        \"Update the maximum number of successful commands and the starting position if the current simulation yields a better result.\"\n      ]\n    },\n    {\n      \"description\": \"Output the optimal starting position for each test case.\",\n      \"steps\": [\n        \"For each test case, print the row and column of the optimal starting position that maximizes the number of successful commands.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences.\",\n    \"For each test case, iterate over all possible starting positions on the board.\",\n    \"Simulate the robot's movement for each starting position and track the number of successful commands.\",\n    \"Determine the starting position that allows the maximum number of successful commands without falling off the board.\",\n    \"Output the optimal starting position for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def find_optimal_starting_position(n, m, s):\n    # Calculate the net effect of the command sequence\n    min_row, max_row, min_col, max_col = 0, 0, 0, 0\n    current_row, current_col = 0, 0\n    \n    for command in s:\n        if command == 'L':\n            current_col -= 1\n        elif command == 'R':\n            current_col += 1\n        elif command == 'U':\n            current_row -= 1\n        elif command == 'D':\n            current_row += 1\n        \n        min_row = min(min_row, current_row)\n        max_row = max(max_row, current_row)\n        min_col = min(min_col, current_col)\n        max_col = max(max_col, current_col)\n    \n    # Determine the optimal starting position\n    start_row = 1 - min_row\n    start_col = 1 - min_col\n    \n    # Ensure the starting position is within bounds\n    if start_row + max_row <= n and start_col + max_col <= m:\n        return start_row, start_col\n    else:\n        return None\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        result = find_optimal_starting_position(n, m, s)\n        if result:\n            results.append(f\"{result[0]} {result[1]}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, false, true, true, false, false, false, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 390, "prompt": "The robot is positioned on a checkered board with dimensions n \u00d7 m, where n is the number of rows and m is the number of columns, and the rows are numbered from top to bottom starting at 1 while columns are numbered from left to right beginning at 1. The robot is capable of moving from its current position to any of the four adjacent cells.\n\nThe robot follows a given sequence of commands, denoted by the symbols 'L', 'R', 'D', or 'U', which correspond to movements to the left, right, down, or up, respectively.\n\nThe robot is free to begin its journey from any cell, and it follows the commands in the exact order they are presented in the sequence s, but moving off the board results in the robot falling and breaking, and such a command isn't counted as successful.\n\nThe goal for the robot is to carry out as many commands as it can without falling off the board. For instance, on a 3 \u00d7 3 board, if the robot begins the sequence s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the center, it will execute one command, but the next will make it cross the edge. Starting from cell (2, 1) (second row, first column), the robot will execute all commands and finish at cell (1, 2) (first row, second column).\n\n<image> The robot begins at cell (2, 1) (second row, first column), moves to the right twice, down, left, and up twice, and in this situation concludes at cell (1, 2) (first row, second column).\n\nFigure out the starting cell for the robot to maximize the execution of commands without going off the board.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 74}
