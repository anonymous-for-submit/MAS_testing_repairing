{"name": "1594_D. The Number of Imposters", "description": "Theofanis started playing the new online game called \"Among them\". However, he always plays with Cypriot players, and they all have the same name: \"Andreas\" (the most common name in Cyprus).\n\nIn each game, Theofanis plays with n other players. Since they all have the same name, they are numbered from 1 to n.\n\nThe players write m comments in the chat. A comment has the structure of \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate). The comment means that player i said that player j has the role c.\n\nAn imposter always lies, and a crewmate always tells the truth. \n\nHelp Theofanis find the maximum possible number of imposters among all the other Cypriot players, or determine that the comments contradict each other (see the notes for further explanation).\n\nNote that each player has exactly one role: either imposter or crewmate.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.", "tags": ["constructive algorithms", "dfs and similar", "dp", "dsu", "graphs"], "difficulty": 10, "id": 1594, "sample_io": [{"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}], "test_list": [{"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n2\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["4\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n-1\n2\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n4\n1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n4\n-1\n2\n9\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n9\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n10 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n9\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n3\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n1 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n4\n2\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n5\n1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["2\n4\n-1\n2\n13\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n4 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n3\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 3 crewmate\n1 3 imposter\n10 0\n", "output": ["4\n3\n-1\n2\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n4 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n4 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n3\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n8 0\n", "output": ["2\n4\n1\n-1\n8\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n-1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n2\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n2 0\n", "output": ["2\n4\n-1\n5\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n2\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["4\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n-1\n-1\n2\n9\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n-1\n1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 3 crewmate\n2 3 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["-1\n4\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n15 0\n", "output": ["2\n4\n1\n-1\n15\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n4\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n6 0\n", "output": ["2\n3\n1\n-1\n6\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n3\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n7 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n6\n-1\n2\n7\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n4\n2\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n5 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n4\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n3\n-1\n2\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["2\n4\n1\n2\n13\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n4 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n4 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n-1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n7 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 4 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n6\n3\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n4 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n2 0\n", "output": ["2\n4\n-1\n2\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n10 0\n", "output": ["2\n4\n2\n2\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n-1\n1\n-1\n9\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n10 0\n", "output": ["2\n4\n1\n-1\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n-1\n-1\n-1\n4\n"]}, {"input": "5\n6 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 1 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["5\n4\n-1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["4\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 4 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n-1\n1\n-1\n7\n"]}, {"input": "5\n4 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["3\n3\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n-1\n1\n-1\n5\n"]}, {"input": "5\n8 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["7\n4\n2\n-1\n2\n"]}, {"input": "5\n6 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["5\n4\n1\n2\n13\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 4 imposter\n2 1 crewmate\n6 5\n1 1 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n4\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n4 5 crewmate\n1 4 imposter\n2 1 imposter\n4 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n3\n-1\n5\n"]}, {"input": "5\n4 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["3\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n10 0\n", "output": ["2\n4\n2\n-1\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 3 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n5\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n2 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n2 0\n", "output": ["2\n4\n-1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n1 3 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n2 2 crewmate\n1 2 imposter\n2 0\n", "output": ["2\n4\n1\n2\n2\n"]}, {"input": "5\n5 2\n1 2 imposter\n4 2 crewmate\n10 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n8\n-1\n2\n5\n"]}, {"input": "5\n10 2\n1 2 imposter\n4 2 crewmate\n10 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["9\n8\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n3\n2\n5\n"]}, {"input": "5\n6 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["5\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n4\n-1\n2\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n3\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 1 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n-1\n-1\n2\n4\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n-1\n1\n-1\n2\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 4 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 2 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n-1\n5\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n4 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n-1\n1\n2\n5\n"]}, {"input": "5\n4 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["3\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n8 0\n", "output": ["2\n4\n1\n2\n8\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n2\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n3 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n-1\n2\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 3 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n4\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 3 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 3 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 3 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 3 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n1 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n3 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 4 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 1 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n5\n1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n2 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n3 5 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 4 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n3\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 3 imposter\n3 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 1 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n8 0\n", "output": ["2\n4\n1\n-1\n8\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n1 4 imposter\n2 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n3 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n3 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 4 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n4\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n2\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n4 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 3 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n4\n-1\n2\n9\n"]}, {"input": "5\n3 2\n1 2 imposter\n3 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n4\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 1 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n4 2\n1 4 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n3\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n3 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n7 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 1 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 2 crewmate\n2 5 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["4\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 1 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n4 5 crewmate\n1 4 imposter\n2 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n2 3 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n2\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 2 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 3 imposter\n2 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 1 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 5 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 1 crewmate\n2 4 imposter\n1 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 5 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 3 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 1 crewmate\n2 5 crewmate\n2 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 3 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n2 3 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n4\n1\n-1\n2\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 3 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["2\n4\n-1\n2\n13\n"]}], "task_id": "codecontest/54", "repair_prompt": ["Theofanis is eager to become skillful at the game by correctly figuring out the roles of players, based on the comments exchanged.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        visited = {}\n        max_imposters = 0\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if node in visited:\n                    if visited[node] != role:\n                        return -1, 0, 0\n                    continue\n                \n                visited[node] = role\n                if role == 'imposter':\n                    local_imposters += 1\n                else:\n                    local_crewmates += 1\n                \n                for neighbor, relation in graph[node]:\n                    if relation == 'imposter':\n                        queue.append((neighbor, 'crewmate' if role == 'imposter' else 'imposter'))\n                    else:\n                        queue.append((neighbor, role))\n            \n            return 0, local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                result, imposters, crewmates = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "completions": ["def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        visited = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            visited[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if visited[neighbor] == -1:\n                        visited[neighbor] = expected_role\n                        count[expected_role] += 1\n                        queue.append((neighbor, expected_role))\n                    elif visited[neighbor] != expected_role:\n                        return -1, 0\n            \n            return max(count), 1\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if visited[player] == -1:\n                result, valid = bfs(player)\n                if not valid:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.role = [-1] * n  # -1: unknown, 0: crewmate, 1: imposter\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v, role_relation):\n        root_u = self.find(u)\n        root_v = self.find(v)\n\n        if root_u == root_v:\n            # Check for contradiction\n            if self.role[u] != -1 and self.role[v] != -1:\n                if (self.role[u] ^ self.role[v]) != role_relation:\n                    return False\n            return True\n\n        # Union by rank\n        if self.rank[root_u] > self.rank[root_v]:\n            self.parent[root_v] = root_u\n            if self.role[v] != -1:\n                self.role[root_u] = self.role[v] ^ role_relation\n        elif self.rank[root_u] < self.rank[root_v]:\n            self.parent[root_u] = root_v\n            if self.role[u] != -1:\n                self.role[root_v] = self.role[u] ^ role_relation\n        else:\n            self.parent[root_v] = root_u\n            self.rank[root_u] += 1\n            if self.role[v] != -1:\n                self.role[root_u] = self.role[v] ^ role_relation\n\n        # Set roles if unknown\n        if self.role[u] == -1 and self.role[v] != -1:\n            self.role[u] = self.role[v] ^ role_relation\n        elif self.role[v] == -1 and self.role[u] != -1:\n            self.role[v] = self.role[u] ^ role_relation\n\n        return True\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n\n        uf = UnionFind(n + 1)  # Players are 1-indexed\n\n        contradiction = False\n\n        for _\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        color = {}\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            color[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = col if relation == 'crewmate' else 1 - col\n                    \n                    if neighbor in color:\n                        if color[neighbor] != expected_color:\n                            return -1\n                    else:\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append((neighbor, expected_color))\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if player not in color:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        color = {}\n        \n        def dfs(node, col):\n            if node in color:\n                return color[node] == col\n            color[node] = col\n            for neighbor, relation in graph[node]:\n                if relation == 'imposter':\n                    if not dfs(neighbor, 1 - col):\n                        return False\n                else:  # relation == 'crewmate'\n                    if not dfs(neighbor, col):\n                        return False\n            return True\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if player not in color:\n                count = [0, 0]\n                stack = [(player, 0)]\n                while stack:\n                    node, col = stack.pop()\n                    if node in color:\n                        if color[node] != col:\n                            results.append(-1)\n                            break\n                        continue\n                    color[node] = col\n                    count[col] += 1\n                    for neighbor, relation in graph[node]:\n                        if relation == 'imposter':\n                            stack.append((neighbor, 1 - col))\n                        else:  # relation == 'crewmate'\n                            stack.append((neighbor, col))\n                else:\n                    max_imposters += max(count)\n            else:\n                continue\n            if results and results[-1] == -1:\n                break\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = {}\n        \n        def dfs(player, role):\n            if player in roles:\n                return roles[player] == role\n            roles[player] = role\n            for neighbor, comment in graph[player]:\n                if comment == \"imposter\":\n                    if not dfs(neighbor, 1 - role):\n                        return False\n                else:  # comment == \"crewmate\"\n                    if not dfs(neighbor, role):\n                        return False\n            return True\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if player not in roles:\n                imposters_count = [0, 0]\n                if not dfs(player, 0):\n                    results.append(-1)\n                    break\n                for p in roles:\n                    imposters_count[roles[p]] += 1\n                max_imposters += max(imposters_count)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1 means unvisited, 0 means crewmate, 1 means imposter\n        contradiction = False\n        max_imposters = 0\n        \n        def bfs(start):\n            nonlocal contradiction\n            queue = deque([(start, 0)])  # start with crewmate\n            roles[start] = 0\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                if role == 0:\n                    local_crewmates += 1\n                else:\n                    local_imposters += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append((neighbor, expected_role))\n                    elif roles[neighbor] != expected_role:\n                        contradiction = True\n                        return 0, 0\n            \n            return local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                imposters, crewmates = bfs(player)\n                if contradiction:\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == 'imposter':\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        visited = {}\n        contradiction = False\n        max_imposters = 0\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            visited[start] = 0\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                node, role = queue.popleft()\n                count[role] += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if neighbor in visited:\n                        if visited[neighbor] != expected_role:\n                            return -1\n                    else:\n                        visited[neighbor] = expected_role\n                        queue.append((neighbor, expected_role))\n            \n            return max(count)\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.role = [-1] * n  # -1: unassigned, 0: crewmate, 1: imposter\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v, role_relation):\n        root_u = self.find(u)\n        root_v = self.find(v)\n\n        if root_u == root_v:\n            # Check for contradiction\n            if self.role[u] != -1 and self.role[v] != -1:\n                if (self.role[u] == self.role[v]) != (role_relation == 'crewmate'):\n                    return False\n            return True\n\n        # Union by rank\n        if self.rank[root_u] > self.rank[root_v]:\n            self.parent[root_v] = root_u\n            if self.role[v] != -1:\n                self.role[root_u] = self.role[v] if role_relation == 'crewmate' else 1 - self.role[v]\n        elif self.rank[root_u] < self.rank[root_v]:\n            self.parent[root_u] = root_v\n            if self.role[u] != -1:\n                self.role[root_v] = self.role[u] if role_relation == 'crewmate' else 1 - self.role[u]\n        else:\n            self.parent[root_v] = root_u\n            self.rank[root_u] += 1\n            if self.role[v] != -1:\n                self.role[root_u] = self.role[v] if role_relation == 'crewmate' else 1 - self.role[v]\n\n        # Assign roles if not already assigned\n        if self.role[u] == -1 and self.role[v] != -1:\n            self.role[u] = self.role[v] if role_relation == 'crewmate' else 1 - self.role[v]\n        elif self.role[v] == -1 and self.role[u] != -1:\n            self.role[v] = self.role[u] if role_relation == 'crewmate' else 1 - self.role[u]\n\n        return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int\nmain()", "def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0] * size\n        self.role = [-1] * size  # -1 means unassigned, 0 means crewmate, 1 means imposter\n\n    def find(self, u):\n        if self.parent[u] != u:\n            root = self.find(self.parent[u])\n            self.role[u] ^= self.role[self.parent[u]]  # Update role based on parent\n            self.parent[u] = root\n        return self.parent[u]\n\n    def union(self, u, v, relation):\n        root_u = self.find(u)\n        root_v = self.find(v)\n\n        if root_u == root_v:\n            # Check for contradiction\n            if (self.role[u] ^ self.role[v]) != relation:\n                return False\n            return True\n\n        # Union by rank\n        if self.rank[root_u] > self.rank[root_v]:\n            self.parent[root_v] = root_u\n            self.role[root_v] = self.role[u] ^ self.role[v] ^ relation\n        elif self.rank[root_u] < self.rank[root_v]:\n            self.parent[root_u] = root_v\n            self.role[root_u] = self.role[u] ^ self.role[v] ^ relation\n        else:\n            self.parent[root_v] = root_u\n            self.role[root_v] = self.role[u] ^ self.role[v] ^ relation\n            self.rank[root_u] += 1\n\n        return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        uf = UnionFind(n + 1)\n        contradiction = False\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            relation = 1 if c == \"imposter\" else 0\n            \n            if not uf.union(i, j, relation):\n                contradiction = True\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            # Calculate maximum imposters\n            max_imposters =\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        visited = {}\n        max_imposters = 0\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if node in visited:\n                    if visited[node] != role:\n                        return -1, 0, 0\n                    continue\n                \n                visited[node] = role\n                if role == 'imposter':\n                    local_imposters += 1\n                else:\n                    local_crewmates += 1\n                \n                for neighbor, relation in graph[node]:\n                    if relation == 'imposter':\n                        queue.append((neighbor, 'crewmate' if role == 'imposter' else 'imposter'))\n                    else:\n                        queue.append((neighbor, role))\n            \n            return 0, local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                result, imposters, crewmates = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of players, number of comments, and the comments themselves.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases where each test case contains the number of players, number of comments, and a list of comments.\"\n    },\n    {\n      \"description\": \"For each test case, determine the relationships between players based on the comments. This involves creating a graph where nodes represent players and edges represent the relationship (imposter or crewmate) between them.\",\n      \"output\": \"A graph representation for each test case, where nodes are players and edges are labeled with the relationship type.\"\n    },\n    {\n      \"description\": \"Detect contradictions in the comments for each test case. A contradiction occurs if there is a cycle in the graph that implies conflicting roles for any player.\",\n      \"output\": \"A boolean value for each test case indicating whether a contradiction exists.\"\n    },\n    {\n      \"description\": \"If no contradiction is found, calculate the maximum possible number of imposters by exploring the graph and assigning roles to players in a way that maximizes imposters.\",\n      \"output\": \"An integer for each test case representing the maximum number of imposters, or -1 if a contradiction is found.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, construct a graph based on the comments, where nodes are players and edges are labeled with 'imposter' or 'crewmate'.\",\n    \"Check the graph for contradictions by attempting to assign roles to players. Use a graph traversal method (e.g., DFS or BFS) to detect cycles and inconsistencies.\",\n    \"If a contradiction is detected, record -1 for that test case. Otherwise, calculate the maximum number of imposters by exploring possible role assignments.\",\n    \"Output the result for each test case, either the maximum number of imposters or -1 if a contradiction was found.\"\n  ]\n}\n```", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        visited = {}\n        max_imposters = 0\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if node in visited:\n                    if visited[node] != role:\n                        return -1, 0, 0\n                    continue\n                \n                visited[node] = role\n                if role == 'imposter':\n                    local_imposters += 1\n                else:\n                    local_crewmates += 1\n                \n                for neighbor, relation in graph[node]:\n                    if relation == 'imposter':\n                        queue.append((neighbor, 'crewmate' if role == 'imposter' else 'imposter'))\n                    else:\n                        queue.append((neighbor, role))\n            \n            return 0, local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                result, imposters, crewmates = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        visited = {}\n        max_imposters = 0\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if node in visited:\n                    if visited[node] != role:\n                        return -1, 0, 0\n                    continue\n                \n                visited[node] = role\n                if role == 'imposter':\n                    local_imposters += 1\n                else:\n                    local_crewmates += 1\n                \n                for neighbor, relation in graph[node]:\n                    if relation == 'imposter':\n                        queue.append((neighbor, 'crewmate' if role == 'imposter' else 'imposter'))\n                    else:\n                        queue.append((neighbor, role))\n            \n            return 0, local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                result, imposters, crewmates = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of players, number of comments, and the comments themselves.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, model the problem as a graph where players are nodes and comments are edges with labels indicating 'imposter' or 'crewmate'.\",\n      \"output\": \"A graph representation for each test case.\"\n    },\n    {\n      \"description\": \"Implement a method to detect contradictions in the comments for each test case. This involves checking for cycles in the graph that violate the 'imposter' or 'crewmate' conditions.\",\n      \"output\": \"A boolean indicating whether a contradiction exists for each test case.\"\n    },\n    {\n      \"description\": \"If no contradictions are found, determine the maximum number of imposters possible by exploring valid configurations of player roles.\",\n      \"output\": \"The maximum number of imposters for each test case.\"\n    },\n    {\n      \"description\": \"Output the result for each test case, either the maximum number of imposters or -1 if a contradiction is found.\",\n      \"output\": \"Formatted output for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, construct a graph where nodes represent players and edges represent comments with labels.\",\n    \"Implement a function to check for contradictions in the graph by detecting cycles that violate the comment conditions.\",\n    \"If a contradiction is detected, store -1 for that test case.\",\n    \"If no contradiction is detected, use a graph traversal method to determine the maximum number of imposters possible.\",\n    \"Store the result for each test case.\",\n    \"Output the results for all test cases in the required format.\"\n  ]\n}\n```", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        visited = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            visited[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if visited[neighbor] == -1:\n                        visited[neighbor] = expected_role\n                        count[expected_role] += 1\n                        queue.append((neighbor, expected_role))\n                    elif visited[neighbor] != expected_role:\n                        return -1, 0\n            \n            return max(count), 1\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if visited[player] == -1:\n                result, valid = bfs(player)\n                if not valid:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 145)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        visited = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            visited[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if visited[neighbor] == -1:\n                        visited[neighbor] = expected_role\n                        count[expected_role] += 1\n                        queue.append((neighbor, expected_role))\n                    elif visited[neighbor] != expected_role:\n                        return -1, 0\n            \n            return max(count), 1\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if visited[player] == -1:\n                result, valid = bfs(player)\n                if not valid:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integers n and m, representing the number of players and the number of comments.\",\n        \"For each of the m comments, read the integers i, j, and the string c, representing the players involved and the type of comment.\"\n      ]\n    },\n    {\n      \"description\": \"Model the problem as a graph where players are nodes and comments are edges with labels.\",\n      \"steps\": [\n        \"Create a graph representation where each player is a node.\",\n        \"For each comment, add an edge between nodes i and j with the label 'imposter' or 'crewmate'.\"\n      ]\n    },\n    {\n      \"description\": \"Detect contradictions in the comments for each test case.\",\n      \"steps\": [\n        \"Use a union-find or disjoint set data structure to manage groups of players.\",\n        \"For each comment, check if it contradicts previous comments using the union-find structure.\",\n        \"If a contradiction is found, mark the test case as having a contradiction.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum possible number of imposters for each test case without contradictions.\",\n      \"steps\": [\n        \"For each connected component in the graph, determine the maximum number of imposters by considering both possible roles for the starting node.\",\n        \"Use a depth-first search (DFS) or breadth-first search (BFS) to explore each component and count imposters.\",\n        \"Keep track of the maximum number of imposters found for each test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a contradiction was found, output -1.\",\n        \"Otherwise, output the maximum number of imposters calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, construct a graph based on the comments.\",\n    \"Use a union-find data structure to detect contradictions in the comments.\",\n    \"For non-contradictory test cases, calculate the maximum number of imposters using graph traversal.\",\n    \"Output the results for each", "Round_0": {"code": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.role = [-1] * n  # -1: unknown, 0: crewmate, 1: imposter\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v, role_relation):\n        root_u = self.find(u)\n        root_v = self.find(v)\n\n        if root_u == root_v:\n            # Check for contradiction\n            if self.role[u] != -1 and self.role[v] != -1:\n                if (self.role[u] ^ self.role[v]) != role_relation:\n                    return False\n            return True\n\n        # Union by rank\n        if self.rank[root_u] > self.rank[root_v]:\n            self.parent[root_v] = root_u\n            if self.role[v] != -1:\n                self.role[root_u] = self.role[v] ^ role_relation\n        elif self.rank[root_u] < self.rank[root_v]:\n            self.parent[root_u] = root_v\n            if self.role[u] != -1:\n                self.role[root_v] = self.role[u] ^ role_relation\n        else:\n            self.parent[root_v] = root_u\n            self.rank[root_u] += 1\n            if self.role[v] != -1:\n                self.role[root_u] = self.role[v] ^ role_relation\n\n        # Set roles if unknown\n        if self.role[u] == -1 and self.role[v] != -1:\n            self.role[u] = self.role[v] ^ role_relation\n        elif self.role[v] == -1 and self.role[u] != -1:\n            self.role[v] = self.role[u] ^ role_relation\n\n        return True\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n\n        uf = UnionFind(n + 1)  # Players are 1-indexed\n\n        comments = defaultdict(list)\n        contradiction", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 105)"}, "Round_1": {"code": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.role = [-1] * n  # -1: unknown, 0: crewmate, 1: imposter\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v, role_relation):\n        root_u = self.find(u)\n        root_v = self.find(v)\n\n        if root_u == root_v:\n            # Check for contradiction\n            if self.role[u] != -1 and self.role[v] != -1:\n                if (self.role[u] ^ self.role[v]) != role_relation:\n                    return False\n            return True\n\n        # Union by rank\n        if self.rank[root_u] > self.rank[root_v]:\n            self.parent[root_v] = root_u\n            if self.role[v] != -1:\n                self.role[root_u] = self.role[v] ^ role_relation\n        elif self.rank[root_u] < self.rank[root_v]:\n            self.parent[root_u] = root_v\n            if self.role[u] != -1:\n                self.role[root_v] = self.role[u] ^ role_relation\n        else:\n            self.parent[root_v] = root_u\n            self.rank[root_u] += 1\n            if self.role[v] != -1:\n                self.role[root_u] = self.role[v] ^ role_relation\n\n        # Set roles if unknown\n        if self.role[u] == -1 and self.role[v] != -1:\n            self.role[u] = self.role[v] ^ role_relation\n        elif self.role[v] == -1 and self.role[u] != -1:\n            self.role[v] = self.role[u] ^ role_relation\n\n        return True\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n\n        uf = UnionFind(n + 1)  # Players are 1-indexed\n\n        contradiction = False\n\n        for _"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"name\": \"Parse Input\",\n      \"description\": \"Read and parse the input data to extract the number of test cases, players, comments, and their relationships.\"\n    },\n    {\n      \"name\": \"Model Relationships\",\n      \"description\": \"Represent the relationships between players using a graph structure where nodes are players and edges are comments indicating 'imposter' or 'crewmate'.\"\n    },\n    {\n      \"name\": \"Detect Contradictions\",\n      \"description\": \"Check for contradictions in comments for each test case. If a contradiction is found, mark the test case as invalid.\"\n    },\n    {\n      \"name\": \"Calculate Maximum Imposters\",\n      \"description\": \"For valid test cases, calculate the maximum number of imposters possible based on the comments and relationships.\"\n    },\n    {\n      \"name\": \"Output Results\",\n      \"description\": \"Output the results for each test case, either the maximum number of imposters or -1 if contradictions are present.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Initialize\",\n      \"description\": \"Set up data structures to store players, comments, and relationships for each test case.\"\n    },\n    {\n      \"step\": \"Process Input\",\n      \"description\": \"Iterate over the input data to populate the data structures with players and comments for each test case.\"\n    },\n    {\n      \"step\": \"Build Graph\",\n      \"description\": \"For each test case, construct a graph where nodes represent players and edges represent comments ('imposter' or 'crewmate').\"\n    },\n    {\n      \"step\": \"Check for Contradictions\",\n      \"description\": \"Traverse the graph to detect any contradictions in comments. Use a method like DFS or BFS to ensure consistency in player roles.\"\n    },\n    {\n      \"step\": \"Compute Maximum Imposters\",\n      \"description\": \"For non-contradictory graphs, calculate the maximum number of imposters by analyzing the graph structure and comments.\"\n    },\n    {\n      \"step\": \"Output Results\",\n      \"description\": \"For each test case, output the maximum number of imposters or -1 if contradictions are found.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        color = {}\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            color[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = col if relation == 'crewmate' else 1 - col\n                    \n                    if neighbor in color:\n                        if color[neighbor] != expected_color:\n                            return -1\n                    else:\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append((neighbor, expected_color))\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if player not in color:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 145)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        color = {}\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            color[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = col if relation == 'crewmate' else 1 - col\n                    \n                    if neighbor in color:\n                        if color[neighbor] != expected_color:\n                            return -1\n                    else:\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append((neighbor, expected_color))\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if player not in color:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of players, number of comments, and the comments themselves.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases where each test case contains the number of players, number of comments, and a list of comments.\"\n    },\n    {\n      \"description\": \"For each test case, determine the relationships between players based on the comments. Use a graph-based approach where players are nodes and comments define edges with labels (imposter or crewmate).\",\n      \"output\": \"A graph representation for each test case where nodes represent players and edges represent the relationship (imposter or crewmate) between them.\"\n    },\n    {\n      \"description\": \"Detect contradictions in the comments for each test case. A contradiction occurs if there is a cycle in the graph that violates the imposter-crewmate relationship rules.\",\n      \"output\": \"A boolean value for each test case indicating whether a contradiction exists.\"\n    },\n    {\n      \"description\": \"If no contradiction is found, calculate the maximum possible number of imposters by exploring valid configurations of player roles.\",\n      \"output\": \"An integer representing the maximum number of imposters for each test case.\"\n    },\n    {\n      \"description\": \"Handle edge cases such as no comments or all players being potential imposters.\",\n      \"output\": \"Correct handling of edge cases to ensure accurate results.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, construct a graph where nodes represent players and edges represent the relationship (imposter or crewmate) between them.\",\n    \"Check for contradictions in the graph by attempting to assign roles to players and detecting any inconsistencies.\",\n    \"If a contradiction is found, output -1 for that test case.\",\n    \"If no contradiction is found, calculate the maximum number of imposters by exploring valid role assignments.\",\n    \"Output the result for each test case, either the maximum number of imposters or -1 if a contradiction exists.\"\n  ]\n}\n```", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        color = {}\n        \n        def dfs(node, col):\n            if node in color:\n                return color[node] == col\n            color[node] = col\n            for neighbor, relation in graph[node]:\n                if relation == 'imposter':\n                    if not dfs(neighbor, 1 - col):\n                        return False\n                else:  # relation == 'crewmate'\n                    if not dfs(neighbor, col):\n                        return False\n            return True\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if player not in color:\n                count = [0, 0]\n                stack = [(player, 0)]\n                while stack:\n                    node, col = stack.pop()\n                    if node in color:\n                        if color[node] != col:\n                            results.append(-1)\n                            break\n                        continue\n                    color[node] = col\n                    count[col] += 1\n                    for neighbor, relation in graph[node]:\n                        if relation == 'imposter':\n                            stack.append((neighbor, 1 - col))\n                        else:  # relation == 'crewmate'\n                            stack.append((neighbor, col))\n                else:\n                    max_imposters += max(count)\n            else:\n                continue\n            if results and results[-1] == -1:\n                break\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        color = {}\n        \n        def dfs(node, col):\n            if node in color:\n                return color[node] == col\n            color[node] = col\n            for neighbor, relation in graph[node]:\n                if relation == 'imposter':\n                    if not dfs(neighbor, 1 - col):\n                        return False\n                else:  # relation == 'crewmate'\n                    if not dfs(neighbor, col):\n                        return False\n            return True\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if player not in color:\n                count = [0, 0]\n                stack = [(player, 0)]\n                while stack:\n                    node, col = stack.pop()\n                    if node in color:\n                        if color[node] != col:\n                            results.append(-1)\n                            break\n                        continue\n                    color[node] = col\n                    count[col] += 1\n                    for neighbor, relation in graph[node]:\n                        if relation == 'imposter':\n                            stack.append((neighbor, 1 - col))\n                        else:  # relation == 'crewmate'\n                            stack.append((neighbor, col))\n                else:\n                    max_imposters += max(count)\n            else:\n                continue\n            if results and results[-1] == -1:\n                break\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, players, comments, and the details of each comment.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n and m representing the number of players and comments.\",\n        \"For each comment, read integers i, j and string c representing the players involved and the type of comment.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the roles of players based on comments and check for contradictions.\",\n      \"steps\": [\n        \"Initialize a data structure to track the roles of players (e.g., a dictionary or array).\",\n        \"Iterate through each comment and update the roles of players based on the comment type (imposter or crewmate).\",\n        \"Check for contradictions in comments (e.g., if a player is labeled both imposter and crewmate).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum possible number of imposters or detect contradictions.\",\n      \"steps\": [\n        \"For each test case, if no contradictions are found, calculate the maximum number of imposters based on the roles determined.\",\n        \"If contradictions are found, return -1 for that test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, print the result (either the maximum number of imposters or -1 if contradictions exist).\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases, players, and comments.\",\n    \"For each test case, determine the roles of players based on comments.\",\n    \"Check for contradictions in comments and calculate the maximum number of imposters.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = {}\n        \n        def dfs(player, role):\n            if player in roles:\n                return roles[player] == role\n            roles[player] = role\n            for neighbor, comment in graph[player]:\n                if comment == \"imposter\":\n                    if not dfs(neighbor, 1 - role):\n                        return False\n                else:  # comment == \"crewmate\"\n                    if not dfs(neighbor, role):\n                        return False\n            return True\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if player not in roles:\n                imposters_count = [0, 0]\n                if not dfs(player, 0):\n                    results.append(-1)\n                    break\n                for p in roles:\n                    imposters_count[roles[p]] += 1\n                max_imposters += max(imposters_count)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 143)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = {}\n        \n        def dfs(player, role):\n            if player in roles:\n                return roles[player] == role\n            roles[player] = role\n            for neighbor, comment in graph[player]:\n                if comment == \"imposter\":\n                    if not dfs(neighbor, 1 - role):\n                        return False\n                else:  # comment == \"crewmate\"\n                    if not dfs(neighbor, role):\n                        return False\n            return True\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if player not in roles:\n                imposters_count = [0, 0]\n                if not dfs(player, 0):\n                    results.append(-1)\n                    break\n                for p in roles:\n                    imposters_count[roles[p]] += 1\n                max_imposters += max(imposters_count)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of players, number of comments, and the comments themselves.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases where each test case contains the number of players, number of comments, and a list of comments.\"\n    },\n    {\n      \"description\": \"For each test case, determine the relationships between players based on the comments. Use a graph-based approach where players are nodes and comments define edges with labels (imposter or crewmate).\",\n      \"output\": \"A graph representation for each test case where nodes represent players and edges represent the relationship (imposter or crewmate) between them.\"\n    },\n    {\n      \"description\": \"Detect contradictions in the graph. A contradiction occurs if there is a cycle in the graph that implies conflicting roles for any player.\",\n      \"output\": \"A boolean value indicating whether a contradiction exists for each test case.\"\n    },\n    {\n      \"description\": \"If no contradiction exists, calculate the maximum possible number of imposters by exploring the graph and assigning roles to maximize imposters while respecting the given relationships.\",\n      \"output\": \"An integer representing the maximum number of imposters for each test case, or -1 if a contradiction is found.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, construct a graph where nodes are players and edges are labeled with the relationship (imposter or crewmate).\",\n    \"Check the graph for contradictions by attempting to assign roles to players. If a contradiction is found, mark the test case as invalid.\",\n    \"If no contradiction is found, use a graph traversal technique (such as DFS or BFS) to assign roles and calculate the maximum number of imposters.\",\n    \"Output the result for each test case, either the maximum number of imposters or -1 if a contradiction was detected.\"\n  ]\n}\n```", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1 means unvisited, 0 means crewmate, 1 means imposter\n        contradiction = False\n        max_imposters = 0\n        \n        def bfs(start):\n            nonlocal contradiction\n            queue = deque([(start, 0)])  # start with crewmate\n            roles[start] = 0\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                if role == 0:\n                    local_crewmates += 1\n                else:\n                    local_imposters += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append((neighbor, expected_role))\n                    elif roles[neighbor] != expected_role:\n                        contradiction = True\n                        return 0, 0\n            \n            return local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                imposters, crewmates = bfs(player)\n                if contradiction:\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: solve() takes 0 positional arguments but 1 was given"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1 means unvisited, 0 means crewmate, 1 means imposter\n        contradiction = False\n        max_imposters = 0\n        \n        def bfs(start):\n            nonlocal contradiction\n            queue = deque([(start, 0)])  # start with crewmate\n            roles[start] = 0\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                if role == 0:\n                    local_crewmates += 1\n                else:\n                    local_imposters += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append((neighbor, expected_role))\n                    elif roles[neighbor] != expected_role:\n                        contradiction = True\n                        return 0, 0\n            \n            return local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                imposters, crewmates = bfs(player)\n                if contradiction:\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read integers n and m, followed by m lines of comments in the format 'i j c'.\"\n    },\n    {\n      \"description\": \"Model the problem as a graph where players are nodes and comments are edges with labels.\",\n      \"details\": \"Each player is a node. Each comment 'i j c' is an edge between nodes i and j with label 'c' (either 'imposter' or 'crewmate').\"\n    },\n    {\n      \"description\": \"Detect contradictions in the comments for each test case.\",\n      \"details\": \"Use a graph traversal (e.g., DFS or BFS) to check for contradictions. If a contradiction is found, mark the test case as unsolvable (-1).\"\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters possible for each test case without contradictions.\",\n      \"details\": \"For each connected component of the graph, calculate the maximum number of imposters by considering both possible role assignments and choosing the one with the most imposters.\"\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, output the maximum number of imposters or -1 if a contradiction was found.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, read the number of players and comments.\",\n    \"Construct a graph where nodes represent players and edges represent comments with labels.\",\n    \"Perform a graph traversal to detect contradictions in the comments.\",\n    \"If a contradiction is found, output -1 for that test case.\",\n    \"If no contradiction is found, calculate the maximum number of imposters possible.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == 'imposter':\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        visited = {}\n        contradiction = False\n        max_imposters = 0\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            visited[start] = 0\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                node, role = queue.popleft()\n                count[role] += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if neighbor in visited:\n                        if visited[neighbor] != expected_role:\n                            return -1\n                    else:\n                        visited[neighbor] = expected_role\n                        queue.append((neighbor, expected_role))\n            \n            return max(count)\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integers n and m, representing the number of players and the number of comments.\",\n        \"For each of the m comments, read the integers i, j, and the string c, representing the players involved and the type of comment.\"\n      ]\n    },\n    {\n      \"description\": \"Model the problem as a graph where players are nodes and comments are edges with labels.\",\n      \"steps\": [\n        \"Create a graph representation where each player is a node.\",\n        \"For each comment, add an edge between nodes i and j with the label 'imposter' or 'crewmate'.\"\n      ]\n    },\n    {\n      \"description\": \"Detect contradictions in the comments for each test case.\",\n      \"steps\": [\n        \"Use a union-find or disjoint set data structure to manage groups of players.\",\n        \"For each comment, check if it contradicts previous comments using the union-find structure.\",\n        \"If a contradiction is found, mark the test case as having a contradiction.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum possible number of imposters for each test case without contradictions.\",\n      \"steps\": [\n        \"For each connected component in the graph, determine the maximum number of imposters by considering both possible roles for the starting node.\",\n        \"Use a depth-first search (DFS) or breadth-first search (BFS) to explore each component and count imposters.\",\n        \"Keep track of the maximum number of imposters found for each test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a contradiction was found, output -1.\",\n        \"Otherwise, output the maximum number of imposters calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, construct a graph based on the comments.\",\n    \"Use a union-find structure to detect contradictions in the comments.\",\n    \"For non-contradictory test cases, calculate the maximum number of imposters using graph traversal.\",\n    \"Output the results for each test", "Round_0": {"code": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.role = [-1] * n  # -1: unassigned, 0: crewmate, 1: imposter\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v, role_relation):\n        root_u = self.find(u)\n        root_v = self.find(v)\n\n        if root_u == root_v:\n            # Check for contradiction\n            if self.role[u] != -1 and self.role[v] != -1:\n                if (self.role[u] == self.role[v]) != (role_relation == 'crewmate'):\n                    return False\n            return True\n\n        # Union by rank\n        if self.rank[root_u] > self.rank[root_v]:\n            self.parent[root_v] = root_u\n            if self.role[v] != -1:\n                self.role[root_u] = self.role[v] if role_relation == 'crewmate' else 1 - self.role[v]\n        elif self.rank[root_u] < self.rank[root_v]:\n            self.parent[root_u] = root_v\n            if self.role[u] != -1:\n                self.role[root_v] = self.role[u] if role_relation == 'crewmate' else 1 - self.role[u]\n        else:\n            self.parent[root_v] = root_u\n            self.rank[root_u] += 1\n            if self.role[v] != -1:\n                self.role[root_u] = self.role[v] if role_relation == 'crewmate' else 1 - self.role[v]\n\n        # Assign roles if not already assigned\n        if self.role[u] == -1 and self.role[v] != -1:\n            self.role[u] = self.role[v] if role_relation == 'crewmate' else 1 - self.role[v]\n        elif self.role[v] == -1 and self.role[u] != -1:\n            self.role[v] = self.role[u] if role_relation == 'crewmate' else 1 - self.role[u]\n\n        return True\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0", "report": "The compilation output of the preceding code is: solve() takes 0 positional arguments but 1 was given"}, "Round_1": {"code": "def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.role = [-1] * n  # -1: unassigned, 0: crewmate, 1: imposter\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v, role_relation):\n        root_u = self.find(u)\n        root_v = self.find(v)\n\n        if root_u == root_v:\n            # Check for contradiction\n            if self.role[u] != -1 and self.role[v] != -1:\n                if (self.role[u] == self.role[v]) != (role_relation == 'crewmate'):\n                    return False\n            return True\n\n        # Union by rank\n        if self.rank[root_u] > self.rank[root_v]:\n            self.parent[root_v] = root_u\n            if self.role[v] != -1:\n                self.role[root_u] = self.role[v] if role_relation == 'crewmate' else 1 - self.role[v]\n        elif self.rank[root_u] < self.rank[root_v]:\n            self.parent[root_u] = root_v\n            if self.role[u] != -1:\n                self.role[root_v] = self.role[u] if role_relation == 'crewmate' else 1 - self.role[u]\n        else:\n            self.parent[root_v] = root_u\n            self.rank[root_u] += 1\n            if self.role[v] != -1:\n                self.role[root_u] = self.role[v] if role_relation == 'crewmate' else 1 - self.role[v]\n\n        # Assign roles if not already assigned\n        if self.role[u] == -1 and self.role[v] != -1:\n            self.role[u] = self.role[v] if role_relation == 'crewmate' else 1 - self.role[v]\n        elif self.role[v] == -1 and self.role[u] != -1:\n            self.role[v] = self.role[u] if role_relation == 'crewmate' else 1 - self.role[u]\n\n        return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integers n and m, representing the number of players and comments respectively.\",\n        \"For each of the m comments, read the integers i, j and the string c, representing the players involved and the type of comment.\"\n      ]\n    },\n    {\n      \"description\": \"Model the problem as a graph where players are nodes and comments are edges with labels.\",\n      \"steps\": [\n        \"Create a graph representation where each player is a node.\",\n        \"For each comment, add an edge between nodes i and j with the label 'imposter' or 'crewmate'.\"\n      ]\n    },\n    {\n      \"description\": \"Detect contradictions in the comments for each test case.\",\n      \"steps\": [\n        \"Use a union-find data structure to manage connected components and detect contradictions.\",\n        \"For each comment, check if adding the edge creates a contradiction based on existing connections and labels.\",\n        \"If a contradiction is found, mark the test case as invalid.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum possible number of imposters for each valid test case.\",\n      \"steps\": [\n        \"For each connected component in the graph, determine the maximum number of imposters by considering possible role assignments.\",\n        \"Use a bipartite graph approach to assign roles and maximize imposters.\",\n        \"Sum the maximum imposters from all components for the test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if a contradiction was detected, output -1.\",\n        \"Otherwise, output the calculated maximum number of imposters.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, construct a graph based on the comments.\",\n    \"Use a union-find data structure to detect contradictions in the comments.\",\n    \"For each valid test case, calculate the maximum possible number of imposters using a bipartite graph approach.\",\n    \"Output the result for each test case, either the maximum number of imposters or -1 if a contradiction is found.\"\n  ]\n", "Round_0": {"code": "def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0] * size\n        self.role = [-1] * size  # -1 means unassigned, 0 means crewmate, 1 means imposter\n\n    def find(self, u):\n        if self.parent[u] != u:\n            root = self.find(self.parent[u])\n            self.role[u] ^= self.role[self.parent[u]]  # Update role based on parent\n            self.parent[u] = root\n        return self.parent[u]\n\n    def union(self, u, v, relation):\n        root_u = self.find(u)\n        root_v = self.find(v)\n\n        if root_u == root_v:\n            # Check for contradiction\n            if (self.role[u] ^ self.role[v]) != relation:\n                return False\n            return True\n\n        # Union by rank\n        if self.rank[root_u] > self.rank[root_v]:\n            self.parent[root_v] = root_u\n            self.role[root_v] = self.role[u] ^ self.role[v] ^ relation\n        elif self.rank[root_u] < self.rank[root_v]:\n            self.parent[root_u] = root_v\n            self.role[root_u] = self.role[u] ^ self.role[v] ^ relation\n        else:\n            self.parent[root_v] = root_u\n            self.role[root_v] = self.role[u] ^ self.role[v] ^ relation\n            self.rank[root_u] += 1\n\n        return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        uf = UnionFind(n + 1)\n        contradiction = False\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            relation = 1 if c == \"imposter\" else 0\n            \n            if not uf.union(i, j, relation):\n                contradiction = True\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            # Calculate maximum imposters\n            max_imposters =", "report": "The compilation output of the preceding code is: unindent does not match any outer indentation level (<string>, line 6)"}, "Round_1": {"code": "def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0] * size\n        self.role = [-1] * size  # -1 means unassigned, 0 means crewmate, 1 means imposter\n\n    def find(self, u):\n        if self.parent[u] != u:\n            root = self.find(self.parent[u])\n            self.role[u] ^= self.role[self.parent[u]]  # Update role based on parent\n            self.parent[u] = root\n        return self.parent[u]\n\n    def union(self, u, v, relation):\n        root_u = self.find(u)\n        root_v = self.find(v)\n\n        if root_u == root_v:\n            # Check for contradiction\n            if (self.role[u] ^ self.role[v]) != relation:\n                return False\n            return True\n\n        # Union by rank\n        if self.rank[root_u] > self.rank[root_v]:\n            self.parent[root_v] = root_u\n            self.role[root_v] = self.role[u] ^ self.role[v] ^ relation\n        elif self.rank[root_u] < self.rank[root_v]:\n            self.parent[root_u] = root_v\n            self.role[root_u] = self.role[u] ^ self.role[v] ^ relation\n        else:\n            self.parent[root_v] = root_u\n            self.role[root_v] = self.role[u] ^ self.role[v] ^ relation\n            self.rank[root_u] += 1\n\n        return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        uf = UnionFind(n + 1)\n        contradiction = False\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            relation = 1 if c == \"imposter\" else 0\n            \n            if not uf.union(i, j, relation):\n                contradiction = True\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            # Calculate maximum imposters\n            max_imposters ="}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of players, number of comments, and the comments themselves.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases where each test case contains the number of players, number of comments, and a list of comments.\"\n    },\n    {\n      \"description\": \"For each test case, determine the relationships between players based on the comments. This involves creating a graph where nodes represent players and edges represent the relationship (imposter or crewmate) between them.\",\n      \"output\": \"A graph representation for each test case, where nodes are players and edges are labeled with the relationship type.\"\n    },\n    {\n      \"description\": \"Detect contradictions in the comments for each test case. A contradiction occurs if there is a cycle in the graph that implies conflicting roles for any player.\",\n      \"output\": \"A boolean value for each test case indicating whether a contradiction exists.\"\n    },\n    {\n      \"description\": \"If no contradiction is found, calculate the maximum possible number of imposters by exploring the graph and assigning roles to players in a way that maximizes imposters.\",\n      \"output\": \"An integer for each test case representing the maximum number of imposters, or -1 if a contradiction is found.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, construct a graph based on the comments, where nodes are players and edges are labeled with 'imposter' or 'crewmate'.\",\n    \"Check the graph for contradictions by attempting to assign roles to players. Use a graph traversal method (e.g., DFS or BFS) to detect cycles and inconsistencies.\",\n    \"If a contradiction is detected, record -1 for that test case. Otherwise, calculate the maximum number of imposters by exploring possible role assignments.\",\n    \"Output the result for each test case, either the maximum number of imposters or -1 if a contradiction was found.\"\n  ]\n}\n```", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        visited = {}\n        max_imposters = 0\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if node in visited:\n                    if visited[node] != role:\n                        return -1, 0, 0\n                    continue\n                \n                visited[node] = role\n                if role == 'imposter':\n                    local_imposters += 1\n                else:\n                    local_crewmates += 1\n                \n                for neighbor, relation in graph[node]:\n                    if relation == 'imposter':\n                        queue.append((neighbor, 'crewmate' if role == 'imposter' else 'imposter'))\n                    else:\n                        queue.append((neighbor, role))\n            \n            return 0, local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                result, imposters, crewmates = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        visited = {}\n        max_imposters = 0\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if node in visited:\n                    if visited[node] != role:\n                        return -1, 0, 0\n                    continue\n                \n                visited[node] = role\n                if role == 'imposter':\n                    local_imposters += 1\n                else:\n                    local_crewmates += 1\n                \n                for neighbor, relation in graph[node]:\n                    if relation == 'imposter':\n                        queue.append((neighbor, 'crewmate' if role == 'imposter' else 'imposter'))\n                    else:\n                        queue.append((neighbor, role))\n            \n            return 0, local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                result, imposters, crewmates = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}], "scores": [], "pass_results": [false, false, false, false, true, true, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 132, "prompt": "Theofanis is eager to become skillful at the game by correctly figuring out the roles of players, based on the comments exchanged.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.", "mutate_method": "rephrase_one", "save_node": true, "parent_index": 109}
