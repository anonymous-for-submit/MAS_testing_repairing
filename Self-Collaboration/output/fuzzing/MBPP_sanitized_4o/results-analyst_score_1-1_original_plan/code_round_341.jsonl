{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 721, "prompt": "Given a square matrix of size N*N presented as a list of lists, where each cell is connected with a particular cost. A path is defined as a specific sequence of cells that starts from the top-left cell. It can only move right or down. It ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.", "code": "def maxAverageOfPath(cost):\n  N = len(cost)\n  dp = [[0 for i in range(N + 1)] for j in range(N + 1)]\n  dp[0][0] = cost[0][0]\n  for i in range(1, N):\n    dp[i][0] = dp[i - 1][0] + cost[i][0]\n  for j in range(1, N):\n    dp[0][j] = dp[0][j - 1] + cost[0][j]\n  for i in range(1, N):\n    for j in range(1, N):\n      dp[i][j] = max(dp[i - 1][j],\n                     dp[i][j - 1]) + cost[i][j]\n  return dp[N - 1][N - 1] / (2 * N - 1)", "test_imports": [], "test_list": ["assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2", "assert maxAverageOfPath([[2, 3, 4], [7, 6, 5], [8, 4, 10]], 3) == 6.2", "assert maxAverageOfPath([[3, 4, 5], [8, 7, 6], [9, 5, 11]], 3) == 7.2 ", "assert maxAverageOfPath([[6, 3, 1], [1, 4, 5], [2, 6, 6]], 3) == 5.0", "assert maxAverageOfPath([[5, 2, 3], [11, 3, 7], [3, 1, 10]], 3) == 7.2", "assert maxAverageOfPath([[5, 6, 2], [4, 8, 3], [2, 6, 9]], 2) == 6.333333333333333", "assert maxAverageOfPath([[5, 2, 6], [5, 6, 4], [9, 4, 14]], 3) == 7.4", "assert maxAverageOfPath([[3, 2, 2], [9, 5, 3], [9, 3, 11]], 1) == 3.0", "assert maxAverageOfPath([[4, 1, 2], [10, 10, 1], [5, 3, 4]], 3) == 6.2", "assert maxAverageOfPath([[1, 2, 6], [1, 3, 9], [4, 6, 14]], 1) == 1.0", "assert maxAverageOfPath([[5, 4, 8], [9, 9, 2], [12, 8, 14]], 2) == 7.666666666666667", "assert maxAverageOfPath([[2, 2, 4], [7, 9, 8], [8, 7, 11]], 1) == 2.0", "assert maxAverageOfPath([[1, 5, 4], [7, 3, 5], [2, 7, 4]], 1) == 1.0", "assert maxAverageOfPath([[3, 5, 1], [7, 9, 7], [7, 3, 9]], 1) == 3.0", "assert maxAverageOfPath([[6, 4, 4], [6, 2, 7], [9, 4, 6]], 1) == 6.0", "assert maxAverageOfPath([[3, 4, 8], [7, 3, 5], [3, 1, 4]], 2) == 4.333333333333333", "assert maxAverageOfPath([[5, 1, 6], [2, 4, 7], [9, 6, 12]], 3) == 6.8", "assert maxAverageOfPath([[5, 4, 6], [6, 3, 1], [9, 8, 8]], 1) == 5.0", "assert maxAverageOfPath([[4, 1, 2], [11, 4, 8], [12, 3, 13]], 3) == 8.6", "assert maxAverageOfPath([[4, 2, 6], [3, 9, 2], [9, 5, 10]], 3) == 6.2", "assert maxAverageOfPath([[2, 3, 5], [11, 4, 4], [5, 2, 11]], 1) == 2.0", "assert maxAverageOfPath([[3, 7, 3], [10, 10, 7], [3, 1, 5]], 2) == 7.666666666666667", "assert maxAverageOfPath([[4, 7, 5], [9, 1, 4], [6, 1, 5]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 1, 6], [10, 4, 9], [8, 2, 11]], 1) == 4.0", "assert maxAverageOfPath([[1, 2, 4], [3, 3, 9], [4, 3, 5]], 1) == 1.0", "assert maxAverageOfPath([[4, 3, 8], [9, 9, 7], [4, 1, 8]], 3) == 7.4", "assert maxAverageOfPath([[5, 6, 5], [3, 5, 4], [10, 1, 6]], 2) == 5.333333333333333", "assert maxAverageOfPath([[2, 2, 7], [3, 8, 9], [12, 6, 9]], 3) == 6.4", "assert maxAverageOfPath([[1, 5, 2], [6, 5, 8], [11, 1, 12]], 1) == 1.0", "assert maxAverageOfPath([[2, 5, 2], [6, 1, 2], [2, 3, 7]], 2) == 3.0", "assert maxAverageOfPath([[1, 2, 1], [3, 1, 8], [11, 1, 6]], 3) == 4.4", "assert maxAverageOfPath([[4, 2, 6], [2, 5, 2], [3, 3, 7]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[2, 3, 5], [9, 8, 6], [12, 5, 4]], 1) == 2.0", "assert maxAverageOfPath([[1, 3, 6], [7, 6, 8], [7, 4, 8]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 3, 1], [9, 6, 3], [6, 8, 13]], 3) == 8.0", "assert maxAverageOfPath([[6, 6, 7], [5, 8, 5], [5, 6, 12]], 2) == 6.666666666666667", "assert maxAverageOfPath([[1, 4, 7], [11, 8, 10], [7, 2, 15]], 3) == 9.0", "assert maxAverageOfPath([[5, 3, 7], [4, 8, 2], [8, 5, 9]], 2) == 5.666666666666667", "assert maxAverageOfPath([[5, 6, 9], [3, 1, 6], [5, 8, 12]], 1) == 5.0", "assert maxAverageOfPath([[2, 1, 3], [9, 10, 6], [12, 3, 14]], 3) == 8.2", "assert maxAverageOfPath([[5, 6, 5], [9, 9, 10], [3, 2, 13]], 2) == 7.666666666666667", "assert maxAverageOfPath([[7, 7, 9], [9, 1, 4], [12, 2, 15]], 3) == 9.0", "assert maxAverageOfPath([[7, 3, 8], [3, 1, 4], [9, 2, 15]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[7, 1, 9], [4, 11, 4], [3, 4, 9]], 2) == 7.333333333333333", "assert maxAverageOfPath([[5, 7, 1], [2, 1, 4], [12, 6, 9]], 2) == 4.333333333333333", "assert maxAverageOfPath([[3, 1, 5], [5, 4, 7], [11, 3, 13]], 3) == 7.0", "assert maxAverageOfPath([[3, 8, 9], [12, 8, 5], [5, 2, 9]], 1) == 3.0", "assert maxAverageOfPath([[4, 5, 1], [5, 5, 7], [13, 8, 14]], 1) == 4.0", "assert maxAverageOfPath([[6, 4, 3], [9, 7, 8], [11, 6, 6]], 3) == 7.6", "assert maxAverageOfPath([[4, 4, 7], [11, 1, 1], [5, 9, 12]], 2) == 5.333333333333333", "assert maxAverageOfPath([[1, 1, 9], [2, 8, 10], [5, 9, 6]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[7, 1, 6], [12, 2, 5], [4, 6, 11]], 3) == 8.0", "assert maxAverageOfPath([[5, 6, 9], [4, 6, 3], [10, 1, 13]], 1) == 5.0", "assert maxAverageOfPath([[4, 5, 2], [6, 1, 1], [10, 4, 8]], 1) == 4.0", "assert maxAverageOfPath([[4, 2, 4], [10, 6, 6], [13, 3, 12]], 1) == 4.0", "assert maxAverageOfPath([[3, 8, 1], [2, 2, 6], [3, 8, 5]], 2) == 4.333333333333333", "assert maxAverageOfPath([[4, 6, 7], [9, 1, 6], [13, 1, 5]], 2) == 4.666666666666667", "assert maxAverageOfPath([[5, 6, 4], [7, 4, 9], [6, 6, 10]], 1) == 5.0", "assert maxAverageOfPath([[7, 7, 8], [9, 7, 2], [11, 3, 6]], 1) == 7.0", "assert maxAverageOfPath([[5, 4, 4], [2, 1, 8], [12, 7, 12]], 2) == 3.3333333333333335", "assert maxAverageOfPath([[3, 2, 3], [12, 6, 3], [13, 1, 11]], 3) == 8.0", "assert maxAverageOfPath([[4, 2, 5], [2, 3, 4], [5, 6, 12]], 2) == 3.0", "assert maxAverageOfPath([[7, 1, 7], [4, 8, 2], [5, 2, 12]], 3) == 6.6", "assert maxAverageOfPath([[1, 6, 5], [7, 7, 2], [11, 4, 13]], 3) == 7.2", "assert maxAverageOfPath([[3, 6, 1], [10, 1, 3], [3, 8, 12]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 1, 2], [12, 4, 6], [13, 2, 14]], 3) == 9.0", "assert maxAverageOfPath([[2, 6, 7], [3, 7, 9], [9, 8, 7]], 3) == 6.2", "assert maxAverageOfPath([[5, 1, 1], [4, 7, 3], [6, 7, 9]], 2) == 5.333333333333333", "assert maxAverageOfPath([[3, 4, 3], [6, 4, 4], [7, 3, 14]], 2) == 4.333333333333333", "assert maxAverageOfPath([[2, 2, 9], [12, 2, 9], [4, 7, 7]], 1) == 2.0", "assert maxAverageOfPath([[4, 7, 2], [5, 4, 7], [9, 5, 10]], 2) == 5.0", "assert maxAverageOfPath([[2, 9, 1], [13, 5, 2], [4, 5, 11]], 2) == 6.666666666666667", "assert maxAverageOfPath([[6, 2, 1], [11, 12, 9], [4, 9, 14]], 2) == 9.666666666666666", "assert maxAverageOfPath([[3, 7, 10], [3, 9, 4], [11, 1, 7]], 3) == 6.2", "assert maxAverageOfPath([[6, 9, 5], [6, 7, 3], [6, 7, 10]], 1) == 6.0", "assert maxAverageOfPath([[4, 8, 3], [11, 10, 3], [11, 1, 12]], 1) == 4.0", "assert maxAverageOfPath([[6, 8, 9], [5, 11, 7], [9, 4, 10]], 2) == 8.333333333333334", "assert maxAverageOfPath([[4, 6, 8], [10, 7, 4], [10, 8, 14]], 2) == 7.0", "assert maxAverageOfPath([[8, 3, 3], [8, 4, 8], [12, 1, 14]], 1) == 8.0", "assert maxAverageOfPath([[8, 8, 10], [8, 12, 2], [14, 4, 9]], 3) == 8.6", "assert maxAverageOfPath([[4, 5, 4], [12, 7, 1], [12, 7, 11]], 3) == 9.2", "assert maxAverageOfPath([[8, 5, 10], [10, 10, 4], [11, 6, 8]], 1) == 8.0", "assert maxAverageOfPath([[7, 8, 8], [10, 7, 5], [6, 1, 9]], 2) == 8.0", "assert maxAverageOfPath([[1, 7, 4], [8, 7, 3], [11, 2, 8]], 2) == 5.333333333333333", "assert maxAverageOfPath([[1, 5, 6], [4, 2, 8], [6, 6, 10]], 2) == 2.6666666666666665", "assert maxAverageOfPath([[8, 8, 5], [3, 2, 5], [4, 3, 15]], 2) == 6.0", "assert maxAverageOfPath([[6, 8, 4], [9, 5, 11], [11, 8, 14]], 1) == 6.0", "assert maxAverageOfPath([[7, 9, 2], [13, 3, 2], [9, 10, 6]], 2) == 7.666666666666667", "assert maxAverageOfPath([[5, 7, 10], [8, 10, 11], [4, 3, 8]], 2) == 7.666666666666667", "assert maxAverageOfPath([[5, 6, 8], [12, 11, 4], [14, 6, 16]], 3) == 10.6", "assert maxAverageOfPath([[5, 2, 4], [12, 3, 9], [9, 7, 14]], 3) == 9.4", "assert maxAverageOfPath([[8, 7, 4], [4, 4, 7], [12, 5, 11]], 2) == 6.333333333333333", "assert maxAverageOfPath([[1, 8, 4], [11, 10, 8], [11, 1, 13]], 2) == 7.333333333333333", "assert maxAverageOfPath([[4, 9, 9], [5, 6, 11], [14, 8, 16]], 3) == 9.8", "assert maxAverageOfPath([[8, 8, 10], [11, 5, 9], [11, 5, 6]], 2) == 8.0", "assert maxAverageOfPath([[3, 1, 4], [6, 11, 7], [5, 8, 7]], 1) == 3.0", "assert maxAverageOfPath([[2, 6, 1], [11, 11, 3], [10, 3, 8]], 2) == 8.0", "assert maxAverageOfPath([[5, 8, 5], [9, 10, 3], [12, 5, 6]], 3) == 7.4", "assert maxAverageOfPath([[8, 4, 5], [4, 7, 9], [4, 2, 6]], 2) == 6.333333333333333", "assert maxAverageOfPath([[8, 7, 8], [9, 11, 1], [4, 7, 8]], 2) == 9.333333333333334", "assert maxAverageOfPath([[2, 7, 8], [6, 2, 9], [8, 8, 9]], 3) == 7.0", "assert maxAverageOfPath([[6, 5, 2], [13, 8, 8], [12, 2, 7]], 3) == 8.4"], "entry_point": "maxAverageOfPath", "completion": "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a square matrix of size N*N\n    if not isinstance(matrix, list) or len(matrix) != N:\n        raise ValueError(\"Input must be a list of lists with size N*N.\")\n    for row in matrix:\n        if not isinstance(row, list) or len(row) != N:\n            raise ValueError(\"Each row must be a list with N elements.\")\n\n    # Initialize variables to track the maximum average cost\n    max_average = float('-inf')\n\n    # Helper function to explore paths recursively\n    def explore_paths(x, y, total_cost, steps):\n        nonlocal max_average\n\n        # If we reach the bottom-right cell, calculate the average\n        if x == N - 1 and y == N - 1:\n            average_cost = total_cost / steps\n            max_average = max(max_average, average_cost)\n            return\n\n        # Move right\n        if y + 1 < N:\n            explore_paths(x, y + 1, total_cost + matrix[x][y + 1], steps + 1)\n\n        # Move down\n        if x + 1 < N:\n            explore_paths(x + 1, y, total_cost + matrix[x + 1][y], steps + 1)\n\n    # Start exploring paths from the top-left cell\n    explore_paths(0, 0, matrix[0][0], 1)\n\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "completions": ["from typing import *\ndef maxAverageOfPath(matrix, N):\n    def dfs(x, y, path_sum, path_length):\n        # If we reach the bottom-right corner, calculate the average\n        if x == N - 1 and y == N - 1:\n            return (path_sum + matrix[x][y]) / (path_length + 1)\n        \n        # Move right or down\n        max_average = float('-inf')\n        if x + 1 < N:  # Move down\n            max_average = max(max_average, dfs(x + 1, y, path_sum + matrix[x][y], path_length + 1))\n        if y + 1 < N:  # Move right\n            max_average = max(max_average, dfs(x, y + 1, path_sum + matrix[x][y], path_length + 1))\n        \n        return max_average\n\n    # Start DFS from the top-left corner\n    return dfs(0, 0, 0, 0)\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Helper function to perform DFS and calculate path costs\n    def dfs(x, y, path_sum, path_length):\n        nonlocal max_average\n        # If we reach the bottom-right corner, calculate the average\n        if x == N - 1 and y == N - 1:\n            average = path_sum / path_length\n            max_average = max(max_average, average)\n            return\n        \n        # Move right\n        if y + 1 < N:\n            dfs(x, y + 1, path_sum + matrix[x][y + 1], path_length + 1)\n        \n        # Move down\n        if x + 1 < N:\n            dfs(x + 1, y, path_sum + matrix[x + 1][y], path_length + 1)\n\n    # Initialize the maximum average\n    max_average = float('-inf')\n    \n    # Start DFS from the top-left corner\n    dfs(0, 0, matrix[0][0], 1)\n    \n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a square matrix of size N*N\n    if not matrix or len(matrix) != N or any(len(row) != N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N\")\n\n    # Initialize variables to track the maximum average cost\n    max_average = float('-inf')\n\n    # Helper function to explore all paths using recursion\n    def explore_paths(x, y, path_sum, path_length):\n        nonlocal max_average\n\n        # Add the current cell to the path\n        path_sum += matrix[x][y]\n        path_length += 1\n\n        # If we reached the bottom-right corner, calculate the average\n        if x == N - 1 and y == N - 1:\n            average = path_sum / path_length\n            max_average = max(max_average, average)\n            return\n\n        # Move right if possible\n        if y + 1 < N:\n            explore_paths(x, y + 1, path_sum, path_length)\n\n        # Move down if possible\n        if x + 1 < N:\n            explore_paths(x + 1, y, path_sum, path_length)\n\n    # Start exploring paths from the top-left corner\n    explore_paths(0, 0, 0, 0)\n\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a square matrix of size N*N\n    if not isinstance(matrix, list) or len(matrix) != N:\n        raise ValueError(\"Input must be a list of lists with size N*N.\")\n    for row in matrix:\n        if not isinstance(row, list) or len(row) != N:\n            raise ValueError(\"Each row must be a list with N elements.\")\n\n    # Initialize a data structure to store the maximum average cost found so far\n    max_average = float('-inf')\n\n    # Use a recursive approach to explore all paths from the top-left to the bottom-right corner\n    def findMaxAverage(x, y, total_cost, steps):\n        nonlocal max_average\n\n        # Base case: if we reach the bottom-right corner\n        if x == N - 1 and y == N - 1:\n            average_cost = total_cost / steps\n            max_average = max(max_average, average_cost)\n            return\n\n        # Move right\n        if y + 1 < N:\n            findMaxAverage(x, y + 1, total_cost + matrix[x][y + 1], steps + 1)\n\n        # Move down\n        if x + 1 < N:\n            findMaxAverage(x + 1, y, total_cost + matrix[x + 1][y], steps + 1)\n\n    # Start the recursive exploration from the top-left corner\n    findMaxAverage(0, 0, matrix[0][0], 1)\n\n    # Return the maximum average cost after all paths have been evaluated\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Validate the input matrix\n    if not matrix or len(matrix) != N or any(len(row) != N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N\")\n\n    # Helper function to calculate the average cost of a path\n    def calculate_average(path):\n        total_cost = sum(matrix[x][y] for x, y in path)\n        return total_cost / len(path)\n\n    # Helper function to generate all paths\n    def generate_paths(x, y, path):\n        if x == N - 1 and y == N - 1:\n            all_paths.append(path + [(x, y)])\n            return\n        if x < N - 1:\n            generate_paths(x + 1, y, path + [(x, y)])\n        if y < N - 1:\n            generate_paths(x, y + 1, path + [(x, y)])\n\n    all_paths = []\n    generate_paths(0, 0, [])\n\n    # Calculate the maximum average\n    max_average = float('-inf')\n    for path in all_paths:\n        avg = calculate_average(path)\n        if avg > max_average:\n            max_average = avg\n\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a square matrix of size N*N\n    if not matrix or len(matrix) != N or any(len(row) != N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N\")\n\n    # Initialize a data structure to store the maximum average cost found so far\n    max_average = float('-inf')\n\n    # Helper function to explore paths recursively\n    def explore_path(x, y, total_cost, steps):\n        nonlocal max_average\n\n        # If we reach the bottom-right corner, calculate the average\n        if x == N - 1 and y == N - 1:\n            average_cost = total_cost / steps\n            max_average = max(max_average, average_cost)\n            return\n\n        # Move right\n        if y + 1 < N:\n            explore_path(x, y + 1, total_cost + matrix[x][y + 1], steps + 1)\n\n        # Move down\n        if x + 1 < N:\n            explore_path(x + 1, y, total_cost + matrix[x + 1][y], steps + 1)\n\n    # Start exploring paths from the top-left corner\n    explore_path(0, 0, matrix[0][0], 1)\n\n    # Return the maximum average cost after exploring all paths\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Input Validation\n    if not isinstance(matrix, list) or len(matrix) != N:\n        raise ValueError(\"Input must be a list of lists with size N*N.\")\n    for row in matrix:\n        if not isinstance(row, list) or len(row) != N:\n            raise ValueError(\"Each row must be a list with N elements.\")\n\n    # Helper function to calculate the maximum average path\n    def max_average_path(i, j, total_cost, num_cells):\n        # Base case: if we reach the bottom-right corner\n        if i == N - 1 and j == N - 1:\n            return (total_cost + matrix[i][j]) / (num_cells + 1)\n\n        # Move right\n        if j + 1 < N:\n            right_avg = max_average_path(i, j + 1, total_cost + matrix[i][j], num_cells + 1)\n        else:\n            right_avg = float('-inf')\n\n        # Move down\n        if i + 1 < N:\n            down_avg = max_average_path(i + 1, j, total_cost + matrix[i][j], num_cells + 1)\n        else:\n            down_avg = float('-inf')\n\n        # Return the maximum average of the two possible moves\n        return max(right_avg, down_avg)\n\n    # Start the path exploration from the top-left corner\n    return max_average_path(0, 0, 0, 0)\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a square matrix of size N*N\n    if not matrix or len(matrix) != N or any(len(row) != N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N\")\n\n    # Initialize variables to track the maximum average cost\n    max_average = float('-inf')\n\n    # Helper function to explore paths recursively\n    def explore_paths(x, y, total_cost, steps):\n        nonlocal max_average\n\n        # If we reach the bottom-right corner, calculate the average\n        if x == N - 1 and y == N - 1:\n            average_cost = total_cost / steps\n            max_average = max(max_average, average_cost)\n            return\n\n        # Move right\n        if y + 1 < N:\n            explore_paths(x, y + 1, total_cost + matrix[x][y + 1], steps + 1)\n\n        # Move down\n        if x + 1 < N:\n            explore_paths(x + 1, y, total_cost + matrix[x + 1][y], steps + 1)\n\n    # Start exploring paths from the top-left corner\n    explore_paths(0, 0, matrix[0][0], 1)\n\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a square matrix of size N*N\n    if not isinstance(matrix, list) or len(matrix) != N:\n        raise ValueError(\"Input must be a list of lists with size N*N.\")\n    for row in matrix:\n        if not isinstance(row, list) or len(row) != N:\n            raise ValueError(\"Each row must be a list with N elements.\")\n\n    # Initialize variables to track the maximum average cost\n    max_average = float('-inf')\n\n    # Helper function to explore paths recursively\n    def explorePaths(x, y, total_cost, cells_visited):\n        nonlocal max_average\n\n        # If we reach the bottom-right cell, calculate the average cost\n        if x == N - 1 and y == N - 1:\n            average_cost = total_cost / cells_visited\n            max_average = max(max_average, average_cost)\n            return\n\n        # Move right if possible\n        if y + 1 < N:\n            explorePaths(x, y + 1, total_cost + matrix[x][y + 1], cells_visited + 1)\n\n        # Move down if possible\n        if x + 1 < N:\n            explorePaths(x + 1, y, total_cost + matrix[x + 1][y], cells_visited + 1)\n\n    # Start exploring paths from the top-left cell\n    explorePaths(0, 0, matrix[0][0], 1)\n\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "from typing import *\ndef maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a square matrix of size N*N\n    if not isinstance(matrix, list) or len(matrix) != N:\n        raise ValueError(\"Input must be a list of lists with size N*N.\")\n    for row in matrix:\n        if not isinstance(row, list) or len(row) != N:\n            raise ValueError(\"Each row must be a list with N elements.\")\n\n    # Initialize variables to track the maximum average cost\n    max_average = float('-inf')\n\n    # Helper function to explore paths recursively\n    def explore_paths(x, y, total_cost, steps):\n        nonlocal max_average\n\n        # If we reach the bottom-right cell, calculate the average\n        if x == N - 1 and y == N - 1:\n            average_cost = total_cost / steps\n            max_average = max(max_average, average_cost)\n            return\n\n        # Move right\n        if y + 1 < N:\n            explore_paths(x, y + 1, total_cost + matrix[x][y + 1], steps + 1)\n\n        # Move down\n        if x + 1 < N:\n            explore_paths(x + 1, y, total_cost + matrix[x + 1][y], steps + 1)\n\n    # Start exploring paths from the top-left cell\n    explore_paths(0, 0, matrix[0][0], 1)\n\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to ensure it is a valid square matrix of size N*N.\",\n      \"details\": \"Check that the input is a list of lists, each containing N integers, and that there are N such lists.\"\n    },\n    {\n      \"description\": \"Implement a function to calculate the total cost of a path.\",\n      \"details\": \"Define a path as a sequence of moves starting from the top-left cell to the bottom-right cell, moving only right or down.\"\n    },\n    {\n      \"description\": \"Implement a function to calculate the average cost of a path.\",\n      \"details\": \"Use the total cost of the path divided by the number of cells visited in the path.\"\n    },\n    {\n      \"description\": \"Develop an algorithm to explore all possible paths from the top-left to the bottom-right cell.\",\n      \"details\": \"Use a recursive or iterative approach to explore paths, ensuring that only right and down moves are considered.\"\n    },\n    {\n      \"description\": \"Determine the path with the maximum average cost.\",\n      \"details\": \"Compare the average costs of all paths and keep track of the maximum average found.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Validate the input to ensure it is a square matrix of size N*N.\",\n    \"Initialize variables to track the maximum average cost and the corresponding path.\",\n    \"Implement a recursive or iterative function to explore all paths from the top-left to the bottom-right cell.\",\n    \"For each path, calculate the total cost and the average cost.\",\n    \"Compare the average cost of the current path with the maximum average cost found so far.\",\n    \"Update the maximum average cost if the current path's average is higher.\",\n    \"Return the maximum average cost after exploring all possible paths.\"\n  ]\n}\n```", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a square matrix of size N*N\n    if not isinstance(matrix, list) or len(matrix) != N:\n        raise ValueError(\"Input must be a list of lists with size N*N.\")\n    for row in matrix:\n        if not isinstance(row, list) or len(row) != N:\n            raise ValueError(\"Each row must be a list with N elements.\")\n\n    # Initialize variables to track the maximum average cost\n    max_average = float('-inf')\n\n    # Helper function to explore paths recursively\n    def explore_paths(x, y, total_cost, steps):\n        nonlocal max_average\n\n        # If we reach the bottom-right cell, calculate the average\n        if x == N - 1 and y == N - 1:\n            average_cost = total_cost / steps\n            max_average = max(max_average, average_cost)\n            return\n\n        # Move right\n        if y + 1 < N:\n            explore_paths(x, y + 1, total_cost + matrix[x][y + 1], steps + 1)\n\n        # Move down\n        if x + 1 < N:\n            explore_paths(x + 1, y, total_cost + matrix[x + 1][y], steps + 1)\n\n    # Start exploring paths from the top-left cell\n    explore_paths(0, 0, matrix[0][0], 1)\n\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"requirement_analysis\": {\n    \"subproblems\": [\n      {\n        \"description\": \"Identify all possible paths from the top-left cell to the bottom-right cell in the matrix, where movement is restricted to right or down.\",\n        \"goal\": \"Generate a list of all valid paths.\"\n      },\n      {\n        \"description\": \"Calculate the total cost for each identified path.\",\n        \"goal\": \"Sum the values of the cells in each path.\"\n      },\n      {\n        \"description\": \"Determine the number of cells visited in each path.\",\n        \"goal\": \"Count the number of cells in each path.\"\n      },\n      {\n        \"description\": \"Compute the average cost for each path by dividing the total cost by the number of cells visited.\",\n        \"goal\": \"Calculate the average cost for each path.\"\n      },\n      {\n        \"description\": \"Identify the path with the maximum average cost.\",\n        \"goal\": \"Find the path with the highest average cost.\"\n      }\n    ],\n    \"high_level_plan\": [\n      \"Initialize a function that takes a matrix and its size as input.\",\n      \"Implement a recursive or iterative approach to explore all paths from the top-left to the bottom-right cell, considering only right and down movements.\",\n      \"For each path, calculate the total cost and the number of cells visited.\",\n      \"Compute the average cost for each path.\",\n      \"Track the maximum average cost encountered during the exploration of paths.\",\n      \"Return the maximum average cost as the result.\"\n    ]\n  }\n}\n```", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    def dfs(x, y, path_sum, path_length):\n        # If we reach the bottom-right corner, calculate the average\n        if x == N - 1 and y == N - 1:\n            return (path_sum + matrix[x][y]) / (path_length + 1)\n        \n        # Move right or down\n        max_average = float('-inf')\n        if x + 1 < N:  # Move down\n            max_average = max(max_average, dfs(x + 1, y, path_sum + matrix[x][y], path_length + 1))\n        if y + 1 < N:  # Move right\n            max_average = max(max_average, dfs(x, y + 1, path_sum + matrix[x][y], path_length + 1))\n        \n        return max_average\n\n    # Start DFS from the top-left corner\n    return dfs(0, 0, 0, 0)\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"requirement_analysis\": {\n    \"subproblems\": [\n      {\n        \"description\": \"Identify all possible paths from the top-left cell to the bottom-right cell in the matrix, where movement is restricted to right or down.\",\n        \"goal\": \"Generate a list of all valid paths.\"\n      },\n      {\n        \"description\": \"Calculate the total cost for each path identified in the previous step.\",\n        \"goal\": \"Compute the sum of the costs for each path.\"\n      },\n      {\n        \"description\": \"Determine the number of cells visited in each path.\",\n        \"goal\": \"Count the number of cells in each path.\"\n      },\n      {\n        \"description\": \"Calculate the average cost for each path by dividing the total cost by the number of cells visited.\",\n        \"goal\": \"Compute the average cost for each path.\"\n      },\n      {\n        \"description\": \"Identify the path with the maximum average cost.\",\n        \"goal\": \"Find the path with the highest average cost.\"\n      }\n    ],\n    \"high_level_plan\": [\n      \"Initialize a function that takes a matrix and its size as input.\",\n      \"Implement a recursive or iterative approach to explore all paths from the top-left to the bottom-right cell, considering only right and down movements.\",\n      \"For each path, calculate the total cost and the number of cells visited.\",\n      \"Compute the average cost for each path.\",\n      \"Compare the average costs and keep track of the maximum average found.\",\n      \"Return the maximum average cost as the result.\"\n    ]\n  }\n}\n```", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Helper function to perform DFS and calculate path costs\n    def dfs(x, y, path_sum, path_length):\n        nonlocal max_average\n        # If we reach the bottom-right corner, calculate the average\n        if x == N - 1 and y == N - 1:\n            average = path_sum / path_length\n            max_average = max(max_average, average)\n            return\n        \n        # Move right\n        if y + 1 < N:\n            dfs(x, y + 1, path_sum + matrix[x][y + 1], path_length + 1)\n        \n        # Move down\n        if x + 1 < N:\n            dfs(x + 1, y, path_sum + matrix[x + 1][y], path_length + 1)\n\n    # Initialize the maximum average\n    max_average = float('-inf')\n    \n    # Start DFS from the top-left corner\n    dfs(0, 0, matrix[0][0], 1)\n    \n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to ensure it is a valid square matrix of size N*N.\",\n      \"details\": \"Check that the input is a list of lists, each containing N integers, and that there are N such lists.\"\n    },\n    {\n      \"description\": \"Implement a function to calculate the total cost of a path.\",\n      \"details\": \"Define a path as a sequence of moves starting from the top-left to the bottom-right, moving only right or down.\"\n    },\n    {\n      \"description\": \"Implement a function to calculate the average cost of a path.\",\n      \"details\": \"Use the total cost of the path divided by the number of cells in the path.\"\n    },\n    {\n      \"description\": \"Develop an algorithm to explore all possible paths from the top-left to the bottom-right.\",\n      \"details\": \"Use a recursive or iterative approach to explore paths, ensuring all possible paths are considered.\"\n    },\n    {\n      \"description\": \"Determine the path with the maximum average cost.\",\n      \"details\": \"Compare the average costs of all paths and identify the maximum.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Validate the input to ensure it is a square matrix of size N*N.\",\n    \"Initialize variables to track the maximum average cost and the corresponding path.\",\n    \"Implement a recursive or iterative function to explore all paths from the top-left to the bottom-right of the matrix.\",\n    \"For each path, calculate the total cost and the average cost.\",\n    \"Compare the average cost of the current path with the maximum average cost found so far.\",\n    \"Update the maximum average cost and the corresponding path if the current path has a higher average cost.\",\n    \"Return the maximum average cost as the result.\"\n  ]\n}\n```", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a square matrix of size N*N\n    if not matrix or len(matrix) != N or any(len(row) != N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N\")\n\n    # Initialize variables to track the maximum average cost\n    max_average = float('-inf')\n\n    # Helper function to explore all paths using recursion\n    def explore_paths(x, y, path_sum, path_length):\n        nonlocal max_average\n\n        # Add the current cell to the path\n        path_sum += matrix[x][y]\n        path_length += 1\n\n        # If we reached the bottom-right corner, calculate the average\n        if x == N - 1 and y == N - 1:\n            average = path_sum / path_length\n            max_average = max(max_average, average)\n            return\n\n        # Move right if possible\n        if y + 1 < N:\n            explore_paths(x, y + 1, path_sum, path_length)\n\n        # Move down if possible\n        if x + 1 < N:\n            explore_paths(x + 1, y, path_sum, path_length)\n\n    # Start exploring paths from the top-left corner\n    explore_paths(0, 0, 0, 0)\n\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to ensure it is a valid square matrix of size N*N.\",\n      \"details\": \"Check that the input is a list of lists, each containing N integers, and that there are N such lists.\"\n    },\n    {\n      \"description\": \"Implement a function to calculate the cost of a path from the top-left to the bottom-right corner.\",\n      \"details\": \"Define a recursive or iterative approach to explore all possible paths from the top-left to the bottom-right, moving only right or down.\"\n    },\n    {\n      \"description\": \"Calculate the average cost of a path.\",\n      \"details\": \"For each path, compute the total cost and divide it by the number of cells in the path.\"\n    },\n    {\n      \"description\": \"Determine the path with the maximum average cost.\",\n      \"details\": \"Compare the average costs of all possible paths and identify the maximum.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Validate the input to ensure it is a square matrix of size N*N.\",\n    \"Initialize a data structure to store the maximum average cost found so far.\",\n    \"Use a recursive or iterative approach to explore all paths from the top-left to the bottom-right corner, moving only right or down.\",\n    \"For each path, calculate the total cost and the average cost.\",\n    \"Update the maximum average cost if the current path's average is greater than the previously recorded maximum.\",\n    \"Return the maximum average cost after all paths have been evaluated.\"\n  ]\n}\n```", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a square matrix of size N*N\n    if not isinstance(matrix, list) or len(matrix) != N:\n        raise ValueError(\"Input must be a list of lists with size N*N.\")\n    for row in matrix:\n        if not isinstance(row, list) or len(row) != N:\n            raise ValueError(\"Each row must be a list with N elements.\")\n\n    # Initialize a data structure to store the maximum average cost found so far\n    max_average = float('-inf')\n\n    # Use a recursive approach to explore all paths from the top-left to the bottom-right corner\n    def findMaxAverage(x, y, total_cost, steps):\n        nonlocal max_average\n\n        # Base case: if we reach the bottom-right corner\n        if x == N - 1 and y == N - 1:\n            average_cost = total_cost / steps\n            max_average = max(max_average, average_cost)\n            return\n\n        # Move right\n        if y + 1 < N:\n            findMaxAverage(x, y + 1, total_cost + matrix[x][y + 1], steps + 1)\n\n        # Move down\n        if x + 1 < N:\n            findMaxAverage(x + 1, y, total_cost + matrix[x + 1][y], steps + 1)\n\n    # Start the recursive exploration from the top-left corner\n    findMaxAverage(0, 0, matrix[0][0], 1)\n\n    # Return the maximum average cost after all paths have been evaluated\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Parse the input matrix and validate its dimensions to ensure it is a square matrix of size N*N.\",\n      \"description\": \"Check if the input is a list of lists and each sublist has the same length as the number of sublists.\"\n    },\n    {\n      \"subproblem\": \"Define a method to calculate the average cost of a path.\",\n      \"description\": \"Implement a function that takes a path and computes the average cost by dividing the total cost by the number of cells in the path.\"\n    },\n    {\n      \"subproblem\": \"Generate all possible paths from the top-left to the bottom-right cell.\",\n      \"description\": \"Implement a recursive or iterative approach to explore all paths that move only right or down.\"\n    },\n    {\n      \"subproblem\": \"Calculate the average cost for each path and identify the path with the maximum average.\",\n      \"description\": \"Iterate through all paths, compute their average costs, and keep track of the maximum average found.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse and validate the input matrix to ensure it is a square matrix of size N*N.\",\n    \"Implement a function to calculate the average cost of a given path.\",\n    \"Develop a method to generate all possible paths from the top-left to the bottom-right cell, moving only right or down.\",\n    \"For each generated path, calculate the average cost using the defined function.\",\n    \"Compare the average costs of all paths and return the maximum average found.\"\n  ]\n}\n```", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Validate the input matrix\n    if not matrix or len(matrix) != N or any(len(row) != N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N\")\n\n    # Helper function to calculate the average cost of a path\n    def calculate_average(path):\n        total_cost = sum(matrix[x][y] for x, y in path)\n        return total_cost / len(path)\n\n    # Helper function to generate all paths\n    def generate_paths(x, y, path):\n        if x == N - 1 and y == N - 1:\n            all_paths.append(path + [(x, y)])\n            return\n        if x < N - 1:\n            generate_paths(x + 1, y, path + [(x, y)])\n        if y < N - 1:\n            generate_paths(x, y + 1, path + [(x, y)])\n\n    all_paths = []\n    generate_paths(0, 0, [])\n\n    # Calculate the maximum average\n    max_average = float('-inf')\n    for path in all_paths:\n        avg = calculate_average(path)\n        if avg > max_average:\n            max_average = avg\n\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"requirement_analysis\": {\n    \"subproblems\": [\n      {\n        \"description\": \"Parse the input to ensure it is a valid square matrix of size N*N.\",\n        \"details\": \"Check that the input is a list of lists, each containing N integers, and that there are N such lists.\"\n      },\n      {\n        \"description\": \"Implement a function to calculate the total cost of a path from the top-left to the bottom-right corner.\",\n        \"details\": \"Define a recursive or iterative approach to explore all possible paths moving only right or down.\"\n      },\n      {\n        \"description\": \"Calculate the average cost of each path.\",\n        \"details\": \"For each path, divide the total cost by the number of cells visited (which is always 2N-1 for a path from top-left to bottom-right in an N*N matrix).\"\n      },\n      {\n        \"description\": \"Determine the path with the maximum average cost.\",\n        \"details\": \"Compare the average costs of all paths and keep track of the maximum average found.\"\n      }\n    ],\n    \"high_level_plan\": [\n      \"Validate the input to ensure it is a square matrix of size N*N.\",\n      \"Initialize a data structure to store the maximum average cost found so far.\",\n      \"Use a recursive or iterative approach to explore all paths from the top-left to the bottom-right corner, moving only right or down.\",\n      \"For each path, calculate the total cost and the average cost.\",\n      \"Update the maximum average cost if the current path's average is greater than the previously recorded maximum.\",\n      \"Return the maximum average cost after exploring all paths.\"\n    ]\n  }\n}\n```", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a square matrix of size N*N\n    if not matrix or len(matrix) != N or any(len(row) != N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N\")\n\n    # Initialize a data structure to store the maximum average cost found so far\n    max_average = float('-inf')\n\n    # Helper function to explore paths recursively\n    def explore_path(x, y, total_cost, steps):\n        nonlocal max_average\n\n        # If we reach the bottom-right corner, calculate the average\n        if x == N - 1 and y == N - 1:\n            average_cost = total_cost / steps\n            max_average = max(max_average, average_cost)\n            return\n\n        # Move right\n        if y + 1 < N:\n            explore_path(x, y + 1, total_cost + matrix[x][y + 1], steps + 1)\n\n        # Move down\n        if x + 1 < N:\n            explore_path(x + 1, y, total_cost + matrix[x + 1][y], steps + 1)\n\n    # Start exploring paths from the top-left corner\n    explore_path(0, 0, matrix[0][0], 1)\n\n    # Return the maximum average cost after exploring all paths\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"requirement_analysis\": {\n    \"subproblems\": [\n      {\n        \"description\": \"Parse the input to ensure it is a valid square matrix of size N*N.\",\n        \"details\": \"Check that the input is a list of lists, each containing N integers, and that there are N such lists.\"\n      },\n      {\n        \"description\": \"Implement a function to calculate the total cost of a path from the top-left to the bottom-right corner.\",\n        \"details\": \"Define a recursive or iterative approach to explore all possible paths moving only right or down.\"\n      },\n      {\n        \"description\": \"Calculate the average cost of a path.\",\n        \"details\": \"Divide the total cost of the path by the number of cells visited in the path.\"\n      },\n      {\n        \"description\": \"Find the path with the maximum average cost.\",\n        \"details\": \"Compare the average costs of all possible paths and keep track of the maximum.\"\n      }\n    ],\n    \"high_level_plan\": [\n      {\n        \"step\": \"Input Validation\",\n        \"action\": \"Verify that the input is a valid N*N square matrix.\"\n      },\n      {\n        \"step\": \"Path Exploration\",\n        \"action\": \"Develop a function to explore all paths from the top-left to the bottom-right corner, moving only right or down.\"\n      },\n      {\n        \"step\": \"Cost Calculation\",\n        \"action\": \"For each path, calculate the total cost and the average cost.\"\n      },\n      {\n        \"step\": \"Max Average Path\",\n        \"action\": \"Determine the path with the maximum average cost and return this value.\"\n      }\n    ]\n  }\n}\n```", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Input Validation\n    if not isinstance(matrix, list) or len(matrix) != N:\n        raise ValueError(\"Input must be a list of lists with size N*N.\")\n    for row in matrix:\n        if not isinstance(row, list) or len(row) != N:\n            raise ValueError(\"Each row must be a list with N elements.\")\n\n    # Helper function to calculate the maximum average path\n    def max_average_path(i, j, total_cost, num_cells):\n        # Base case: if we reach the bottom-right corner\n        if i == N - 1 and j == N - 1:\n            return (total_cost + matrix[i][j]) / (num_cells + 1)\n\n        # Move right\n        if j + 1 < N:\n            right_avg = max_average_path(i, j + 1, total_cost + matrix[i][j], num_cells + 1)\n        else:\n            right_avg = float('-inf')\n\n        # Move down\n        if i + 1 < N:\n            down_avg = max_average_path(i + 1, j, total_cost + matrix[i][j], num_cells + 1)\n        else:\n            down_avg = float('-inf')\n\n        # Return the maximum average of the two possible moves\n        return max(right_avg, down_avg)\n\n    # Start the path exploration from the top-left corner\n    return max_average_path(0, 0, 0, 0)\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"requirement_analysis\": {\n    \"subproblems\": [\n      {\n        \"description\": \"Parse the input to ensure it is a valid square matrix of size N*N.\",\n        \"details\": \"Check that the input is a list of lists, and each sublist has the same length N.\"\n      },\n      {\n        \"description\": \"Implement a function to calculate the total cost of a path.\",\n        \"details\": \"Define a path as a sequence of moves starting from the top-left to the bottom-right, moving only right or down.\"\n      },\n      {\n        \"description\": \"Implement a function to calculate the average cost of a path.\",\n        \"details\": \"Divide the total cost of the path by the number of cells visited.\"\n      },\n      {\n        \"description\": \"Develop an algorithm to explore all possible paths from the top-left to the bottom-right.\",\n        \"details\": \"Use a recursive or iterative approach to explore paths, ensuring all possible paths are considered.\"\n      },\n      {\n        \"description\": \"Determine the path with the maximum average cost.\",\n        \"details\": \"Compare the average costs of all paths and identify the maximum.\"\n      }\n    ],\n    \"high_level_plan\": [\n      \"Validate the input to ensure it is a square matrix of size N*N.\",\n      \"Initialize variables to track the maximum average cost and the corresponding path.\",\n      \"Implement a recursive or iterative function to explore all paths from the top-left to the bottom-right.\",\n      \"For each path, calculate the total cost and the average cost.\",\n      \"Update the maximum average cost if the current path's average is higher.\",\n      \"Return the maximum average cost after exploring all paths.\"\n    ]\n  }\n}\n```", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a square matrix of size N*N\n    if not matrix or len(matrix) != N or any(len(row) != N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N\")\n\n    # Initialize variables to track the maximum average cost\n    max_average = float('-inf')\n\n    # Helper function to explore paths recursively\n    def explore_paths(x, y, total_cost, steps):\n        nonlocal max_average\n\n        # If we reach the bottom-right corner, calculate the average\n        if x == N - 1 and y == N - 1:\n            average_cost = total_cost / steps\n            max_average = max(max_average, average_cost)\n            return\n\n        # Move right\n        if y + 1 < N:\n            explore_paths(x, y + 1, total_cost + matrix[x][y + 1], steps + 1)\n\n        # Move down\n        if x + 1 < N:\n            explore_paths(x + 1, y, total_cost + matrix[x + 1][y], steps + 1)\n\n    # Start exploring paths from the top-left corner\n    explore_paths(0, 0, matrix[0][0], 1)\n\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to ensure it is a valid square matrix of size N*N.\",\n      \"details\": \"Check that the input is a list of lists, each containing N integers, and that there are N such lists.\"\n    },\n    {\n      \"description\": \"Implement a function to calculate the total cost of a path.\",\n      \"details\": \"Define a path as a sequence of moves starting from the top-left cell to the bottom-right cell, moving only right or down.\"\n    },\n    {\n      \"description\": \"Implement a function to calculate the average cost of a path.\",\n      \"details\": \"Use the total cost of the path divided by the number of cells visited in the path.\"\n    },\n    {\n      \"description\": \"Develop an algorithm to explore all possible paths from the top-left to the bottom-right cell.\",\n      \"details\": \"Use a recursive or iterative approach to explore all paths, ensuring each path only moves right or down.\"\n    },\n    {\n      \"description\": \"Determine the path with the maximum average cost.\",\n      \"details\": \"Compare the average costs of all paths and identify the path with the highest average.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Validate the input to ensure it is a square matrix of size N*N.\",\n    \"Initialize variables to track the maximum average cost and the corresponding path.\",\n    \"Use a recursive or iterative approach to explore all possible paths from the top-left to the bottom-right cell.\",\n    \"For each path, calculate the total cost and the average cost.\",\n    \"Compare the average cost of the current path with the maximum average cost tracked so far.\",\n    \"Update the maximum average cost and the corresponding path if the current path has a higher average.\",\n    \"Return the maximum average cost as the result.\"\n  ]\n}\n```", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a square matrix of size N*N\n    if not isinstance(matrix, list) or len(matrix) != N:\n        raise ValueError(\"Input must be a list of lists with size N*N.\")\n    for row in matrix:\n        if not isinstance(row, list) or len(row) != N:\n            raise ValueError(\"Each row must be a list with N elements.\")\n\n    # Initialize variables to track the maximum average cost\n    max_average = float('-inf')\n\n    # Helper function to explore paths recursively\n    def explorePaths(x, y, total_cost, cells_visited):\n        nonlocal max_average\n\n        # If we reach the bottom-right cell, calculate the average cost\n        if x == N - 1 and y == N - 1:\n            average_cost = total_cost / cells_visited\n            max_average = max(max_average, average_cost)\n            return\n\n        # Move right if possible\n        if y + 1 < N:\n            explorePaths(x, y + 1, total_cost + matrix[x][y + 1], cells_visited + 1)\n\n        # Move down if possible\n        if x + 1 < N:\n            explorePaths(x + 1, y, total_cost + matrix[x + 1][y], cells_visited + 1)\n\n    # Start exploring paths from the top-left cell\n    explorePaths(0, 0, matrix[0][0], 1)\n\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to ensure it is a valid square matrix of size N*N.\",\n      \"details\": \"Check that the input is a list of lists, each containing N integers, and that there are N such lists.\"\n    },\n    {\n      \"description\": \"Implement a function to calculate the total cost of a path.\",\n      \"details\": \"Define a path as a sequence of moves starting from the top-left cell to the bottom-right cell, moving only right or down.\"\n    },\n    {\n      \"description\": \"Implement a function to calculate the average cost of a path.\",\n      \"details\": \"Use the total cost of the path divided by the number of cells visited in the path.\"\n    },\n    {\n      \"description\": \"Develop an algorithm to explore all possible paths from the top-left to the bottom-right cell.\",\n      \"details\": \"Use a recursive or iterative approach to explore paths, ensuring that only right and down moves are considered.\"\n    },\n    {\n      \"description\": \"Determine the path with the maximum average cost.\",\n      \"details\": \"Compare the average costs of all paths and keep track of the maximum average found.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Validate the input to ensure it is a square matrix of size N*N.\",\n    \"Initialize variables to track the maximum average cost and the corresponding path.\",\n    \"Implement a recursive or iterative function to explore all paths from the top-left to the bottom-right cell.\",\n    \"For each path, calculate the total cost and the average cost.\",\n    \"Compare the average cost of the current path with the maximum average cost found so far.\",\n    \"Update the maximum average cost if the current path's average is higher.\",\n    \"Return the maximum average cost after exploring all possible paths.\"\n  ]\n}\n```", "Round_0": {"code": "def maxAverageOfPath(matrix, N):\n    # Validate the input to ensure it is a square matrix of size N*N\n    if not isinstance(matrix, list) or len(matrix) != N:\n        raise ValueError(\"Input must be a list of lists with size N*N.\")\n    for row in matrix:\n        if not isinstance(row, list) or len(row) != N:\n            raise ValueError(\"Each row must be a list with N elements.\")\n\n    # Initialize variables to track the maximum average cost\n    max_average = float('-inf')\n\n    # Helper function to explore paths recursively\n    def explore_paths(x, y, total_cost, steps):\n        nonlocal max_average\n\n        # If we reach the bottom-right cell, calculate the average\n        if x == N - 1 and y == N - 1:\n            average_cost = total_cost / steps\n            max_average = max(max_average, average_cost)\n            return\n\n        # Move right\n        if y + 1 < N:\n            explore_paths(x, y + 1, total_cost + matrix[x][y + 1], steps + 1)\n\n        # Move down\n        if x + 1 < N:\n            explore_paths(x + 1, y, total_cost + matrix[x + 1][y], steps + 1)\n\n    # Start exploring paths from the top-left cell\n    explore_paths(0, 0, matrix[0][0], 1)\n\n    return max_average\n\n# Example usage\nprint(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output: 5.2\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "test": ["def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 4], [7, 6, 5], [8, 4, 10]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 5], [8, 7, 6], [9, 5, 11]], 3) == 7.2 ", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 3, 1], [1, 4, 5], [2, 6, 6]], 3) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 3], [11, 3, 7], [3, 1, 10]], 3) == 7.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 2], [4, 8, 3], [2, 6, 9]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 6], [5, 6, 4], [9, 4, 14]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 2, 2], [9, 5, 3], [9, 3, 11]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [10, 10, 1], [5, 3, 4]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 6], [1, 3, 9], [4, 6, 14]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 8], [9, 9, 2], [12, 8, 14]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 4], [7, 9, 8], [8, 7, 11]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 4], [7, 3, 5], [2, 7, 4]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 5, 1], [7, 9, 7], [7, 3, 9]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 4, 4], [6, 2, 7], [9, 4, 6]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 8], [7, 3, 5], [3, 1, 4]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 1, 6], [2, 4, 7], [9, 6, 12]], 3) == 6.8", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 6], [6, 3, 1], [9, 8, 8]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [11, 4, 8], [12, 3, 13]], 3) == 8.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 6], [3, 9, 2], [9, 5, 10]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 5], [11, 4, 4], [5, 2, 11]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 7, 3], [10, 10, 7], [3, 1, 5]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 7, 5], [9, 1, 4], [6, 1, 5]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 6], [10, 4, 9], [8, 2, 11]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 4], [3, 3, 9], [4, 3, 5]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 3, 8], [9, 9, 7], [4, 1, 8]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 5], [3, 5, 4], [10, 1, 6]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 7], [3, 8, 9], [12, 6, 9]], 3) == 6.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 2], [6, 5, 8], [11, 1, 12]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 5, 2], [6, 1, 2], [2, 3, 7]], 2) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 1], [3, 1, 8], [11, 1, 6]], 3) == 4.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 6], [2, 5, 2], [3, 3, 7]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 5], [9, 8, 6], [12, 5, 4]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 3, 6], [7, 6, 8], [7, 4, 8]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 3, 1], [9, 6, 3], [6, 8, 13]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 6, 7], [5, 8, 5], [5, 6, 12]], 2) == 6.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 4, 7], [11, 8, 10], [7, 2, 15]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 3, 7], [4, 8, 2], [8, 5, 9]], 2) == 5.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 9], [3, 1, 6], [5, 8, 12]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 1, 3], [9, 10, 6], [12, 3, 14]], 3) == 8.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 5], [9, 9, 10], [3, 2, 13]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 7, 9], [9, 1, 4], [12, 2, 15]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 3, 8], [3, 1, 4], [9, 2, 15]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 9], [4, 11, 4], [3, 4, 9]], 2) == 7.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 7, 1], [2, 1, 4], [12, 6, 9]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 1, 5], [5, 4, 7], [11, 3, 13]], 3) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 8, 9], [12, 8, 5], [5, 2, 9]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 1], [5, 5, 7], [13, 8, 14]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 4, 3], [9, 7, 8], [11, 6, 6]], 3) == 7.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 4, 7], [11, 1, 1], [5, 9, 12]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 1, 9], [2, 8, 10], [5, 9, 6]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 6], [12, 2, 5], [4, 6, 11]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 9], [4, 6, 3], [10, 1, 13]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 2], [6, 1, 1], [10, 4, 8]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 4], [10, 6, 6], [13, 3, 12]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 8, 1], [2, 2, 6], [3, 8, 5]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 6, 7], [9, 1, 6], [13, 1, 5]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 4], [7, 4, 9], [6, 6, 10]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 7, 8], [9, 7, 2], [11, 3, 6]], 1) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 4], [2, 1, 8], [12, 7, 12]], 2) == 3.3333333333333335", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 2, 3], [12, 6, 3], [13, 1, 11]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 5], [2, 3, 4], [5, 6, 12]], 2) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 7], [4, 8, 2], [5, 2, 12]], 3) == 6.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 6, 5], [7, 7, 2], [11, 4, 13]], 3) == 7.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 6, 1], [10, 1, 3], [3, 8, 12]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [12, 4, 6], [13, 2, 14]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 6, 7], [3, 7, 9], [9, 8, 7]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 1, 1], [4, 7, 3], [6, 7, 9]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 3], [6, 4, 4], [7, 3, 14]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 9], [12, 2, 9], [4, 7, 7]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 7, 2], [5, 4, 7], [9, 5, 10]], 2) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 9, 1], [13, 5, 2], [4, 5, 11]], 2) == 6.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 2, 1], [11, 12, 9], [4, 9, 14]], 2) == 9.666666666666666", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 7, 10], [3, 9, 4], [11, 1, 7]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 9, 5], [6, 7, 3], [6, 7, 10]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 8, 3], [11, 10, 3], [11, 1, 12]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 8, 9], [5, 11, 7], [9, 4, 10]], 2) == 8.333333333333334", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 6, 8], [10, 7, 4], [10, 8, 14]], 2) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 3, 3], [8, 4, 8], [12, 1, 14]], 1) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 10], [8, 12, 2], [14, 4, 9]], 3) == 8.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 4], [12, 7, 1], [12, 7, 11]], 3) == 9.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 5, 10], [10, 10, 4], [11, 6, 8]], 1) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 8, 8], [10, 7, 5], [6, 1, 9]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 7, 4], [8, 7, 3], [11, 2, 8]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 6], [4, 2, 8], [6, 6, 10]], 2) == 2.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 5], [3, 2, 5], [4, 3, 15]], 2) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 8, 4], [9, 5, 11], [11, 8, 14]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 9, 2], [13, 3, 2], [9, 10, 6]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 7, 10], [8, 10, 11], [4, 3, 8]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 8], [12, 11, 4], [14, 6, 16]], 3) == 10.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 4], [12, 3, 9], [9, 7, 14]], 3) == 9.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 7, 4], [4, 4, 7], [12, 5, 11]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 8, 4], [11, 10, 8], [11, 1, 13]], 2) == 7.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 9, 9], [5, 6, 11], [14, 8, 16]], 3) == 9.8", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 10], [11, 5, 9], [11, 5, 6]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 1, 4], [6, 11, 7], [5, 8, 7]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 6, 1], [11, 11, 3], [10, 3, 8]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 8, 5], [9, 10, 3], [12, 5, 6]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 4, 5], [4, 7, 9], [4, 2, 6]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 7, 8], [9, 11, 1], [4, 7, 8]], 2) == 9.333333333333334", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 7, 8], [6, 2, 9], [8, 8, 9]], 3) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 5, 2], [13, 8, 8], [12, 2, 7]], 3) == 8.4"], "scores": [1.0, 1.0, 0.3333, 0.3333, 0.3333, 0.3333, 0.3333, 0.3333, 0.3333, 0.3333], "pass_results": [true, true, false, false, false, false, false, false, false, false], "pass_test_cases_num": [102, 102, 34, 34, 34, 34, 34, 34, 34, 34], "passed": true, "pass": true, "pass_num": 3, "round": 341, "mutate_method": "expand_one2two", "save_node": true, "parent_index": 450}
