../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/
Namespace(dataset='codecontest', output_path='../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/', input_path='/home/zlyuaj/muti-agent/MetaGPT/output/basedataset/results-codecontest_gpt-35-turbo/codecontest.jsonl', mutate_method='random', output_file_name='repair_fuzzing_gpt-35-turbo_codecontest_1-1', num_round=1000, num_generate=10, save_seed=1, recover=0, calc_analyst=1, calc_final_result=1, save_all_seed=0, clean_data=1, set_threshold_analyst=1, calc_relative_reward=1, clean_mutate_method=1, MBPP_test_case_num=1, max_visit_num=15, recover_path='', parallel=1, split_input=1, mutate_level='sentence', llm_critic='none', with_reference=1, only_consider_passed_cases=0, alpha=1.0, beta=1, workspace='workspace_repair_fuzzing_gpt-35-turbo_codecontest', signature=False, model='gpt-35-turbo', max_round=2, max_tokens=512, majority=1, temperature=0.0, top_p=0.95, fail_list=[], append=False, verbose=False, timeout=10, add_monitor=1, repair_plan=1, repair_code=1, run_multi_gen=1, repair_prompt_num=2)
165
len of loaded seeds: 13
----------------------------------------round: 0------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:0
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7!

--------------------------------------------------
Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this efficiently for large input sizes.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek has an array a of n integers. One can calculate the prettiness value of a by summing the products of the greatest common divisors of elements and their indices. 

The prettiness value of an array a is determined by the sum of the products of greatest common divisors of elements and their indices.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
Mr. Chanek has an array a of n integers, help him find the prettiness value of a, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this efficiently for large input sizes.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
in generating...
in generating repo





in generating repo





in generating repo








in generating repo








in generating repo








in generating repo











in generating repo





in generating repo





in generating repo








in generating repo





in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, True, False, False, True, False, False, True]
True
----------updating----------
analyst reward: 0.3087748885154724
final_output reward: 0.4
total reward: 0.7087748885154724
add mutated seed into prompt node list
seed_index: 0
mutated_seed_index: 13
reward = 0.7087748885154724
saving......
----------------------------------------round: 1------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:1
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i. 

You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. 

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i.

You can select an item from the present sequence and discard it, then join the leftover elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. 

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i. If you remove an element from the sequence and concatenate the remaining elements, you can potentially increase the value of f(a). 

You want to strategically remove elements from a to maximize f(a). Determine the highest possible value of f(a) that you can achieve through this process.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n and defines f(a) as the count of indices where a_i equals i, to maximize this count by removing elements from the sequence.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo








in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, True, True, False, False, False, True, False]
True
----------updating----------
analyst reward: 0.26713472604751587
final_output reward: 0.6
total reward: 0.8671347260475158
add mutated seed into prompt node list
seed_index: 1
mutated_seed_index: 14
reward = 0.8671347260475158
saving......
in recording...
len prompt_nodes
15
initial_seed_num
13
[False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:13
------------------------------
saving result into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_final_result.jsonl
------------------------------
saving original node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_original_node.jsonl
------------------------------
saving node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_node_1.jsonl
----------------------------------------round: 2------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:2
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only. Each turn he can choose to do one of the two following actions:

  * he can either erase exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent); 
  * or he can erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string (these letters don't have to be adjacent). 



Therefore, each turn the length of the string is decreased exactly by 2. All turns are independent so for each turn, Casimir can choose any of two possible actions.

For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example.

For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only. Each turn he can choose to do one of the two following actions: he can either erase exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent); or he can erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string (these letters don't have to be adjacent). Therefore, each turn the length of the string is decreased exactly by 2, and all turns are independent so for each turn, Casimir can choose any of two possible actions. For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example. For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Casimir, with a string s of capital Latin letters 'A', 'B', and 'C', can erase either one 'A' and one 'B' or one 'B' and one 'C' in each turn, reducing the string length by 2. All turns are independent, with options to choose between the two actions. With the goal of erasing all letters from the string, determine if there exists a sequence of actions that leads to an empty string from the given string s.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
multi-gen-prompt:
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only and for a given string s determine whether there is a sequence of actions leading to an empty string, in other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo






in generating repo







in generating repo









in generating repo







in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, False, False, False, False, False, False]
False
----------updating----------
seed 2 finish fuzzing!
seed_index: 2
mutated_seed_index: 15
current seed length: 12
saving......
----------------------------------------round: 3------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:3
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs and he wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Luntik has decided to try singing. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
Luntik has decided to try singing, he has a one-minute songs, b two-minute songs and c three-minute songs and he wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
in generating...
in generating repo





in generating repo






in generating repo









in generating repo



[1;31mGive Feedback / Get Help: https://github.com/BerriAI/litellm/issues/new[0m
LiteLLM.Info: If you need to debug this error, use `litellm._turn_on_debug()'.






in generating repo





in generating repo





in generating repo





in generating repo






in generating repo








in generating repo









in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, False, False, True, False, False, False]
True
----------updating----------
analyst reward: 0.2697361707687378
final_output reward: 0.2
total reward: 0.4697361707687378
add mutated seed into prompt node list
seed_index: 3
mutated_seed_index: 16
reward = 0.4697361707687378
saving......
----------------------------------------round: 4------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:4
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You are given a string s of length n consisting of characters a and/or b.

Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring.

In one step, you can choose any index i and replace s_i with character a or b.

What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Reminder:

The number of occurrences of string d in s as substring is the number of indices i (1 ≤ i ≤ |s| - |d| + 1) such that substring s_i s_{i + 1} ... s_{i + |d| - 1} is equal to d. For example, \operatorname{AB}(aabbbabaa) = 2 since there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa.

--------------------------------------------------
You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) and \operatorname{BA}(s) be the number of occurrences of string ab and ba in s as substrings respectively.

In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Reminder:

The number of occurrences of string d in s as substring is the number of indices i (1 ≤ i ≤ |s| - |d| + 1) such that substring s_i s_{i + 1} ... s_{i + |d| - 1} is equal to d; for example, \operatorname{AB}(aabbbabaa) = 2 since there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
You are given a string s of length n consisting of characters a and/or b. The minimum number of steps needed to achieve AB(s) = BA(s) by replacing characters at any chosen index i with character a or b is what you need to find.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
multi-gen-prompt:
You are given a string s of length n consisting of characters a and/or b, and in one step, you can choose any index i and replace s_i with character a or b to achieve \operatorname{AB}(s) = \operatorname{BA}(s). What is the minimum number of steps you need to make?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo






in generating repo









in generating repo









in generating repo










in generating repo








in generating repo






in generating repo












in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_4_3/codecontest_4_3
evaluating ...
[True, False, False, False, False, False, True, False, False, False]
True
----------updating----------
analyst reward: 0.1951339840888977
final_output reward: 0.1
total reward: 0.2951339840888977
add mutated seed into prompt node list
seed_index: 4
mutated_seed_index: 17
reward = 0.2951339840888977
saving......
----------------------------------------round: 5------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:5
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
In Berland, n different types of banknotes are used. Banknotes of the i-th type have denomination 10^{a_i} burles (burles are the currency used in Berland); the denomination of banknotes of the first type is exactly 1.

Let's denote f(s) as the minimum number of banknotes required to represent exactly s burles. For example, if the denominations of banknotes used in Berland are 1, 10 and 100, then f(59) = 14: 9 banknotes with denomination of 1 burle and 5 banknotes with denomination of 10 burles can be used to represent exactly 9 ⋅ 1 + 5 ⋅ 10 = 59 burles, and there's no way to do it with fewer banknotes.

For a given integer k, find the minimum positive number of burles s that cannot be represented with k or fewer banknotes (that is, f(s) > k).

--------------------------------------------------
In Berland, n different types of banknotes are utilized. Banknotes of the i-th type have denomination 10^{a_i} burles (burles are the currency used in Berland); the denomination of banknotes of the first type is exactly 1.

Let's denote f(s) as the minimum number of banknotes required to represent exactly s burles. For example, if the denominations of banknotes used in Berland are 1, 10 and 100, then f(59) = 14: 9 banknotes with denomination of 1 burle and 5 banknotes with denomination of 10 burles can be used to represent exactly 9 ⋅ 1 + 5 ⋅ 10 = 59 burles, and there's no way to do it with fewer banknotes.

Given an integer k, determine the smallest positive number of burles s that can't be represented with k or fewer banknotes (that is, f(s) > k).

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — number of test cases.

The first line of each test case contains two integers n and k (1 ≤ n ≤ 10; 1 ≤ k ≤ 10^9).

The next line contains n integers a_1, a_2, ..., a_n (0 = a_1 < a_2 < ... < a_n ≤ 9).

Output

For each test case, print one integer — the minimum positive number of burles s that cannot be represented with k or fewer banknotes.

Example

Input


4
3 13
0 1 2
2 777
0 4
3 255
0 1 3
10 1000000000
0 1 2 3 4 5 6 7 8 9


Output


59
778
148999
999999920999999999
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
In Berland, n different types of banknotes are utilized. The denomination of banknotes of the i-th type have a denomination of 10^{a_i} burles, with the denomination of banknotes of the first type being exactly 1. 

Let's denote f(s) as the minimum number of banknotes required to represent exactly s burles. If the denominations of banknotes in Berland are 1, 10, and 100, then f(59) = 14, showing how to represent 59 burles with 1 and 10 burle banknotes. Given an integer k, find the smallest positive number of burles s that can't be represented with k or fewer banknotes (f(s) > k).

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — number of test cases.

The first line of each test case contains two integers n and k (1 ≤ n ≤ 10; 1 ≤ k ≤ 10^9).

The next line contains n integers a_1, a_2, ..., a_n (0 = a_1 < a_2 < ... < a_n ≤ 9).

Output

For each test case, print one integer — the minimum positive number of burles s that cannot be represented with k or fewer banknotes.

Example

Input


4
3 13
0 1 2
2 777
0 4
3 255
0 1 3
10 1000000000
0 1 2 3 4 5 6 7 8 9


Output


59
778
148999
999999920999999999
multi-gen-prompt:
In Berland, n different types of banknotes are utilized, and Let's denote f(s) as the minimum number of banknotes required to represent exactly s burles. Given an integer k, determine the smallest positive number of burles s that can't be represented with k or fewer banknotes (that is, f(s) > k).

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — number of test cases.

The first line of each test case contains two integers n and k (1 ≤ n ≤ 10; 1 ≤ k ≤ 10^9).

The next line contains n integers a_1, a_2, ..., a_n (0 = a_1 < a_2 < ... < a_n ≤ 9).

Output

For each test case, print one integer — the minimum positive number of burles s that cannot be represented with k or fewer banknotes.

Example

Input


4
3 13
0 1 2
2 777
0 4
3 255
0 1 3
10 1000000000
0 1 2 3 4 5 6 7 8 9


Output


59
778
148999
999999920999999999
in generating...
in generating repo





in generating repo






in generating repo





in generating repo







in generating repo






in generating repo








in generating repo








in generating repo





in generating repo





in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_5_8/codecontest_5_8
evaluating ...
[False, False, False, False, False, False, False, False, False, False]
False
----------updating----------
seed 5 finish fuzzing!
seed_index: 5
mutated_seed_index: 18
current seed length: 11
saving......
----------------------------------------round: 6------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:6
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

The sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.

The robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible.

--------------------------------------------------
The machine is situated on a checkered rectangular board with dimensions n × m, where n represents rows and m represents columns. The rows in the board are assigned numbers from 1 to n starting at the top, and the columns — from 1 to m beginning at the left side.

The robot has the ability to transition from its current position to one of the four neighboring cells on the sides.

The sequence of orders s carried out by the robot is provided. Each order is symbolized by one of the letters 'L', 'R', 'D' or 'U', and initiates the movement to the left, right, downward or upward, respectively.

The robot's movement can commence in any cell. The robot processes the orders beginning with the initial one, following the sequence they appear in s. If the robot travels past the boundaries of the board, it falls and sustains damage. An order that leads to the robot's damage is not deemed successfully completed.

The robot's mission is to carry out the maximum number of orders without departing from the board. For instance, on a 3 × 3 board, if the robot begins a set of operations s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the middle cell, the robot will execute one order before the subsequent command leads it off the boundary. If the robot commences movement from the cell (2, 1) (second row, first column) then every order will be successfully executed, concluding at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Ascertain the cell from which the robot should initiate its movement to carry out the maximum number of commands possible.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
The robot's movement can commence in any cell. The robot processes the orders beginning with the initial one, following the sequence they appear in s. 

The machine is situated on a checkered rectangular board with dimensions n × m, where n represents rows and m represents columns. The rows in the board are assigned numbers from 1 to n starting at the top, and the columns — from 1 to m beginning at the left side. 

The robot has the ability to transition from its current position to one of the four neighboring cells on the sides.

The sequence of orders s carried out by the robot is provided. Each order is symbolized by one of the letters 'L', 'R', 'D' or 'U', and initiates the movement to the left, right, downward or upward, respectively.

The robot's mission is to carry out the maximum number of orders without departing from the board. For instance, on a 3 × 3 board, if the robot begins a set of operations s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the middle cell, the robot will execute one order before the subsequent command leads it off the boundary. If the robot commences movement from the cell (2, 1) (second row, first column) then every order will be successfully executed, concluding at the cell (1, 2) (first row, second column).

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
multi-gen-prompt:
The robot's mission is to carry out the maximum number of orders without departing from the board, beginning from a specific cell to ensure successful execution of every order.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo







in generating repo









in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, False, True, True, False, True, False, True, True]
True
----------updating----------
analyst reward: 0.2869102358818054
final_output reward: 0
total reward: 0.2869102358818054
add mutated seed into prompt node list
seed_index: 6
mutated_seed_index: 19
reward = 0.2869102358818054
saving......
----------------------------------------round: 7------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:7
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively.

The robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. 

  * If the robot moves beyond the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 



Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.

Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom. The columns are numbered from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively.

The robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. 

  * If the robot moves beyond the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 

Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.

Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
The columns are numbered from 1 to m from left to right, allowing the robot to navigate horizontally. Each cell has a symbol indicating the direction for the robot to move, guiding its path throughout the board.

The robot's objective is to start from a square that enables it to execute the maximum number of steps successfully. Which square should the robot choose as its starting point to achieve this goal?

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
multi-gen-prompt:
The robot can start its movement in any cell and moves to the adjacent square in the direction indicated on the current square in one move. Determine from which square the robot should start its movement to make the maximum number of steps before breaking or stopping.

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
in generating...
in generating repo





in generating repo





in generating repo






in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo









in generating repo






in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, False, True, False, False, False, True]
True
----------updating----------
analyst reward: 0.2507282495498657
final_output reward: 0.2
total reward: 0.45072824954986573
add mutated seed into prompt node list
seed_index: 7
mutated_seed_index: 20
reward = 0.45072824954986573
saving......
----------------------------------------round: 8------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:8
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end.

Now Monocarp asks you to compare these two numbers. Can you help him?

--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Analyze the format carefully in order to determine which of the two numbers is larger, or if they are equal.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end. Analyze the format carefully in order to determine which of the two numbers is larger, or if they are equal.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard, both following a specific format: a positive integer x with p zeros appended to its end; now Monocarp asks you to compare these two numbers. Can you help him analyze the format carefully to determine which of the two numbers is larger, or if they are equal?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo






in generating repo






in generating repo





in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, True, True, True, True, True, True, True, True]
True
----------updating----------
analyst reward: 0.263205885887146
final_output reward: 0
total reward: 0.263205885887146
add mutated seed into prompt node list
seed_index: 8
mutated_seed_index: 21
reward = 0.263205885887146
saving......
----------------------------------------round: 9------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:9
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You are given strings S and T, consisting of lowercase English letters. It is guaranteed that T is a permutation of the string abc. 

Find string S', the lexicographically smallest permutation of S such that T is not a subsequence of S'.

String a is a permutation of string b if the number of occurrences of each distinct character is the same in both strings.

A string a is a subsequence of a string b if a can be obtained from b by deletion of several (possibly, zero or all) elements.

A string a is lexicographically smaller than a string b if and only if one of the following holds:

  * a is a prefix of b, but a ≠ b;
  * in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b.

--------------------------------------------------
You are given strings S and T, consisting of lowercase English letters, with the guarantee that T is a permutation of the string abc. 

Find string S', the lexicographically smallest permutation of S such that T is not a subsequence of S', where string a is a permutation of string b if the number of occurrences of each distinct character is the same in both strings.

A string a is a subsequence of a string b if a can be obtained from b by deletion of several (possibly, zero or all) elements.

A string a is lexicographically smaller than a string b if and only if one of the following holds:

  * a is a prefix of b, but a ≠ b;
  * in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b.

Input

Each test contains multiple test cases. The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases. Description of the test cases follows.

The first line of each test case contains a string S (1 ≤ |S| ≤ 100), consisting of lowercase English letters.

The second line of each test case contains a string T that is a permutation of the string abc. (Hence, |T| = 3).

Note that there is no limit on the sum of |S| across all test cases.

Output

For each test case, output a single string S', the lexicographically smallest permutation of S such that T is not a subsequence of S'.

Example

Input


7
abacaba
abc
cccba
acb
dbsic
bac
abracadabra
abc
dddddddddddd
cba
bbc
abc
ac
abc


Output


aaaacbb
abccc
bcdis
aaaaacbbdrr
dddddddddddd
bbc
ac

Note

In the first test case, both aaaabbc and aaaabcb are lexicographically smaller than aaaacbb, but they contain abc as a subsequence.

In the second test case, abccc is the smallest permutation of cccba and does not contain acb as a subsequence.

In the third test case, bcdis is the smallest permutation of dbsic and does not contain bac as a subsequence.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
You are given strings S and T, consisting of lowercase English letters, with the guarantee that T is a permutation of the string abc. Find string S', the lexicographically smallest permutation of S such that T is not a subsequence of S', where string a is a permutation of string b if the number of occurrences of each distinct character is the same in both strings. The lexicographically smallest string S' is the one where in the first position where a and b differ, the string S' has a letter that appears earlier in the alphabet than the corresponding letter in S.

Input

Each test contains multiple test cases. The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases. Description of the test cases follows.

The first line of each test case contains a string S (1 ≤ |S| ≤ 100), consisting of lowercase English letters.

The second line of each test case contains a string T that is a permutation of the string abc. (Hence, |T| = 3).

Note that there is no limit on the sum of |S| across all test cases.

Output

For each test case, output a single string S', the lexicographically smallest permutation of S such that T is not a subsequence of S'.

Example

Input


7
abacaba
abc
cccba
acb
dbsic
bac
abracadabra
abc
dddddddddddd
cba
bbc
abc
ac
abc


Output


aaaacbb
abccc
bcdis
aaaaacbbdrr
dddddddddddd
bbc
ac

Note

In the first test case, both aaaabbc and aaaabcb are lexicographically smaller than aaaacbb, but they contain abc as a subsequence.

In the second test case, abccc is the smallest permutation of cccba and does not contain acb as a subsequence.

In the third test case, bcdis is the smallest permutation of dbsic and does not contain bac as a subsequence.
multi-gen-prompt:
You are given strings S and T, consisting of lowercase English letters, with the guarantee that T is a permutation of the string abc. Find string S', the lexicographically smallest permutation of S such that T is not a subsequence of S', where string a is a permutation of string b if the number of occurrences of each distinct character is the same in both strings.

Input

Each test contains multiple test cases. The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases. Description of the test cases follows.

The first line of each test case contains a string S (1 ≤ |S| ≤ 100), consisting of lowercase English letters.

The second line of each test case contains a string T that is a permutation of the string abc. (Hence, |T| = 3).

Note that there is no limit on the sum of |S| across all test cases.

Output

For each test case, output a single string S', the lexicographically smallest permutation of S such that T is not a subsequence of S'.

Example

Input


7
abacaba
abc
cccba
acb
dbsic
bac
abracadabra
abc
dddddddddddd
cba
bbc
abc
ac
abc


Output


aaaacbb
abccc
bcdis
aaaaacbbdrr
dddddddddddd
bbc
ac

Note

In the first test case, both aaaabbc and aaaabcb are lexicographically smaller than aaaacbb, but they contain abc as a subsequence.

In the second test case, abccc is the smallest permutation of cccba and does not contain acb as a subsequence.

In the third test case, bcdis is the smallest permutation of dbsic and does not contain bac as a subsequence.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo






in generating repo






in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_9_5/codecontest_9_5
evaluating ...
[False, False, False, False, False, False, False, False, False, False]
False
----------updating----------
seed 9 finish fuzzing!
seed_index: 9
mutated_seed_index: 22
current seed length: 10
saving......
----------------------------------------round: 10------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:10
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
A string is called square if it is some string written twice in a row. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

--------------------------------------------------
A string is termed square if it is a sequence repeated two times consecutively. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
A string is termed square if it is a sequence repeated two times consecutively. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square. Determine if a given string s is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
A string is termed square if it is a sequence repeated two times consecutively, determine if a given string s is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
in generating...
in generating repo





in generating repo





in generating repo








in generating repo








in generating repo








in generating repo







in generating repo











in generating repo









in generating repo








in generating repo






in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_10_2/codecontest_10_2
evaluating ...
[False, False, False, False, False, False, False, False, False, True]
True
----------updating----------
analyst reward: 0.21496683359146118
final_output reward: 0.9
total reward: 1.114966833591461
add mutated seed into prompt node list
seed_index: 10
mutated_seed_index: 23
reward = 1.114966833591461
saving......
----------------------------------------round: 11------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:11
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times. 

--------------------------------------------------
You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You need to execute q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times. 


Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
You are given a permutation p of n elements, where a permutation is an array containing integers from 1 to n exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations. You need to execute q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times. 

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
multi-gen-prompt:
You are given a permutation p of n elements, execute q queries.

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
in generating...
in generating repo





in generating repo






in generating repo







in generating repo








in generating repo








in generating repo





in generating repo







in generating repo








in generating repo








in generating repo












in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_11_2/codecontest_11_2
evaluating ...
[False, False, False, False, False, False, False, False, False, False]
False
----------updating----------
seed 11 finish fuzzing!
seed_index: 11
mutated_seed_index: 24
current seed length: 9
saving......
in recording...
len prompt_nodes
25
initial_seed_num
13
[False, False, True, False, False, True, False, False, False, True, False, True, False]
total pass@10:9
------------------------------
saving result into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_final_result.jsonl
------------------------------
saving original node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_original_node.jsonl
------------------------------
saving node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_node_11.jsonl
----------------------------------------round: 12------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:12
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You have an array of integers (initially empty).

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 



Find the resulting array after performing all the queries.

--------------------------------------------------
You have an array of integers (initially empty). You have to perform q queries, and each query is of one of two types: 

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
You have an array of integers (initially empty). You have to perform q queries, and each query is of one of two types: 

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 

Find the resulting array after performing all the queries. After replacing all occurrences of x with y, determine the final state of the array.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
You have an array of integers (initially empty) and need to perform q queries, with one of two types being "1 x" to add x to the end of the array, and the other being "2 x y" to replace all occurrences of x with y. Find the resulting array after performing all queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo








in generating repo





in generating repo









in generating repo







in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, True, False, True, False, True, True, True, True]
True
----------updating----------
analyst reward: 0.14881151914596558
final_output reward: 0
total reward: 0.14881151914596558
add mutated seed into prompt node list
seed_index: 12
mutated_seed_index: 25
reward = 0.14881151914596558
saving......
----------------------------------------round: 13------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:23
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
A string is termed square if it is a sequence repeated two times consecutively. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

--------------------------------------------------
A string is termed square if it is a sequence repeated two times consecutively; for example, the strings "aa", "abcabc", "abab" and "baabaa" are square, but the strings "aaa", "abaaab" and "abcdabc" are not square. For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
A string is termed square if it is a sequence repeated two times consecutively; for example, the strings "aa", "abcabc", "abab" and "baabaa" are square, but the strings "aaa", "abaaab" and "abcdabc" are not square. For a given string s, check if it is square by validating if it repeats its sequence twice in a row.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
A string is square if it is a sequence repeated two times consecutively like "aa" or "abcabc"; determine if a given string s is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
in generating...
in generating repo





in generating repo






in generating repo






in generating repo






in generating repo






in generating repo







in generating repo






in generating repo






in generating repo






in generating repo






in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_13_0/codecontest_13_0
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_13_1/codecontest_13_1
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_13_3/codecontest_13_3
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_13_4/codecontest_13_4
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_13_5/codecontest_13_5
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_13_6/codecontest_13_6
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_13_8/codecontest_13_8
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_13_9/codecontest_13_9
evaluating ...
[True, True, False, False, True, False, False, False, False, False]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 14------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:14
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i.

You can select an item from the present sequence and discard it, then join the leftover elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. 

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i.

You can select an item from the present sequence and discard it, then join the leftover elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). You can analyze the sequence to identify positions that do not contribute to f(a) before deciding which elements to remove.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i. One possible approach is to analyze the sequence to identify positions that do not contribute to f(a) before deciding which elements to remove in order to maximize f(a). 

You can select an item from the present sequence and discard it, then join the leftover elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. Find the largest possible f(a) by removing some elements from a while considering the positions that do not contribute to f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n, and you can select an item from the present sequence and discard it to join the leftover elements together, aiming to maximize f(a). Identify positions that do not contribute to f(a) before deciding which elements to remove.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
in generating...
in generating repo





in generating repo








in generating repo





in generating repo





in generating repo








in generating repo








in generating repo








in generating repo








in generating repo








in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, True, False, True, False, False, False, True, True]
True
----------updating----------
analyst reward: 0.16751915216445923
final_output reward: 0
total reward: 0.16751915216445923
add mutated seed into prompt node list
seed_index: 14
mutated_seed_index: 26
reward = 0.16751915216445923
saving......
----------------------------------------round: 15------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:13
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this efficiently for large input sizes.

--------------------------------------------------
Mr. Chanek possesses a collection of n numbers in array a. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

Put differently, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this efficiently for large input sizes.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek's collection of numbers in array a has a prettiness value that is calculated using the greatest common divisors of the array elements and their indices. In simpler terms, the prettiness value of the array a is the sum of products of GCDs of array elements and their indices in all possible pairs. Can you assist Mr. Chanek in determining the prettiness value of array a efficiently for large input sizes, and output the result modulo 10^9 + 7?

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
Mr. Chanek needs help finding the prettiness value of array a efficiently for large input sizes, calculated as the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j), and output the result modulo 10^9 + 7.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
in generating...
in generating repo





in generating repo






in generating repo





in generating repo





in generating repo





in generating repo








in generating repo





in generating repo





in generating repo








in generating repo









in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, False, True, False, False, False, False]
True
----------updating----------
analyst reward: 0.1000128984451294
final_output reward: 0.2
total reward: 0.3000128984451294
add mutated seed into prompt node list
seed_index: 13
mutated_seed_index: 27
reward = 0.3000128984451294
saving......
----------------------------------------round: 16------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:16
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs and he wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs and he wants to distribute all songs into two concerts such that every song should be included to exactly one concert, and he wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Luntik has a one-minute songs, b two-minute songs and c three-minute songs and he wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He aims to make the absolute difference of durations of the concerts as small as possible. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
Luntik has decided to try singing and has one-minute songs, b two-minute songs, and c three-minute songs that he wants to distribute into two concerts with the smallest possible absolute difference in durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
in generating...
in generating repo





in generating repo






in generating repo






in generating repo






in generating repo









in generating repo








in generating repo







in generating repo









in generating repo





in generating repo







in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, True, False, False, False, False, False, False, False, False]
True
----------updating----------
analyst reward: 0.11625957489013672
final_output reward: 0
total reward: 0.11625957489013672
add mutated seed into prompt node list
seed_index: 16
mutated_seed_index: 28
reward = 0.11625957489013672
saving......
----------------------------------------round: 17------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:20
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom. The columns are numbered from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively.

The robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. 

  * If the robot moves beyond the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 

Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.

Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

--------------------------------------------------
The robot is situated on a checkered rectangular board of dimensions n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom. The columns are numbered from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively.

The robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. 

  * If the robot surpasses the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 

Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.

Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
The robot can start its movement in any cell, then moves to the adjacent square in the direction indicated on the current square in one move. If the robot surpasses the edge of the board, it falls and breaks.

The robot is situated on a checkered rectangular board of dimensions n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom. The columns are numbered from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side. 

Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively. 

Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops. 

Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
multi-gen-prompt:
The robot can start its movement in any cell, then moves to the adjacent square in the indicated direction, aiming to make the maximum number of steps before breaking or stopping. Determine the square from which the robot should start to achieve this goal.

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
in generating...
in generating repo





in generating repo





in generating repo





in generating repo






in generating repo





in generating repo






in generating repo





in generating repo





in generating repo





in generating repo






in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, False, False, False, True, False, False, False, False, False]
True
----------updating----------
analyst reward: 0.10877352952957153
final_output reward: 0
total reward: 0.10877352952957153
add mutated seed into prompt node list
seed_index: 20
mutated_seed_index: 29
reward = 0.10877352952957153
saving......
----------------------------------------round: 18------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:17
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) and \operatorname{BA}(s) be the number of occurrences of string ab and ba in s as substrings respectively.

In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Reminder:

The number of occurrences of string d in s as substring is the number of indices i (1 ≤ i ≤ |s| - |d| + 1) such that substring s_i s_{i + 1} ... s_{i + |d| - 1} is equal to d; for example, \operatorname{AB}(aabbbabaa) = 2 since there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa.

--------------------------------------------------
You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) and \operatorname{BA}(s) be the number of occurrences of string ab and ba in s as substrings respectively.

In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Reminder:

The number of occurrences of string d in s as substring is the number of indices i (1 ≤ i ≤ |s| - |d| + 1) such that substring s_i s_{i + 1} ... s_{i + |d| - 1} is equal to d; for example, \operatorname{AB}(aabbbabaa) = 2 since there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa. Assume every operation is optimal to reduce the difference between \operatorname{AB}(s) and \operatorname{BA}(s).

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Let \operatorname{AB}(s) be the number of occurrences of string ab in s as substrings. To achieve \operatorname{AB}(s) = \operatorname{BA}(s), you can choose any index i and replace s_i with character a or b in one step.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
multi-gen-prompt:
You are given a string s of length n consisting of characters a and/or b and need to make minimum steps to achieve \operatorname{AB}(s) = \operatorname{BA}(s); in one step, replace s_i with character a or b.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
in generating...
in generating repo





in generating repo





in generating repo








in generating repo





in generating repo








in generating repo








in generating repo






in generating repo








in generating repo








in generating repo









in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, False, False, False, False, True, False]
True
----------updating----------
analyst reward: 0.15134859085083008
final_output reward: 0.1
total reward: 0.25134859085083006
add mutated seed into prompt node list
seed_index: 17
mutated_seed_index: 30
reward = 0.25134859085083006
saving......
----------------------------------------round: 19------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:19
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
The machine is situated on a checkered rectangular board with dimensions n × m, where n represents rows and m represents columns. The rows in the board are assigned numbers from 1 to n starting at the top, and the columns — from 1 to m beginning at the left side.

The robot has the ability to transition from its current position to one of the four neighboring cells on the sides.

The sequence of orders s carried out by the robot is provided. Each order is symbolized by one of the letters 'L', 'R', 'D' or 'U', and initiates the movement to the left, right, downward or upward, respectively.

The robot's movement can commence in any cell. The robot processes the orders beginning with the initial one, following the sequence they appear in s. If the robot travels past the boundaries of the board, it falls and sustains damage. An order that leads to the robot's damage is not deemed successfully completed.

The robot's mission is to carry out the maximum number of orders without departing from the board. For instance, on a 3 × 3 board, if the robot begins a set of operations s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the middle cell, the robot will execute one order before the subsequent command leads it off the boundary. If the robot commences movement from the cell (2, 1) (second row, first column) then every order will be successfully executed, concluding at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Ascertain the cell from which the robot should initiate its movement to carry out the maximum number of commands possible.

--------------------------------------------------
The machine is situated on a checkered rectangular board with dimensions n × m, where n represents rows and m represents columns. The rows in the board are assigned numbers from 1 to n starting at the top, and the columns — from 1 to m beginning at the left side.

The robot has the ability to transition from its current position to one of the four neighboring cells on the sides.

The sequence of orders s carried out by the robot is provided. Each order is symbolized by one of the letters 'L', 'R', 'D' or 'U'. These letters initiate the movement to the left, right, downward or upward, respectively.

The robot's movement can commence in any cell. The robot processes the orders beginning with the initial one, following the sequence they appear in s. If the robot travels past the boundaries of the board, it falls and sustains damage. An order that leads to the robot's damage is not deemed successfully completed.

The robot's mission is to carry out the maximum number of orders without departing from the board. For instance, on a 3 × 3 board, if the robot begins a set of operations s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the middle cell, the robot will execute one order before the subsequent command leads it off the boundary. If the robot commences movement from the cell (2, 1) (second row, first column) then every order will be successfully executed. It will conclude at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Ascertain the cell from which the robot should initiate its movement to carry out the maximum number of commands possible.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
The robot's movement can commence in any cell; however, it must follow the sequence of orders provided without going past the boundaries of the board. Therefore, selecting the correct starting cell is crucial for the robot to successfully execute the maximum number of orders. 

The machine is situated on a checkered rectangular board with dimensions n × m, where n represents rows and m represents columns. The rows in the board are assigned numbers from 1 to n starting at the top, and the columns — from 1 to m beginning at the left side.

The robot has the ability to transition from its current position to one of the four neighboring cells on the sides.

The sequence of orders s carried out by the robot is provided. Each order is symbolized by one of the letters 'L', 'R', 'D' or 'U'. These letters initiate the movement to the left, right, downward or upward, respectively.

The robot's movement can commence in any cell. The robot processes the orders beginning with the initial one, following the sequence they appear in s. If the robot travels past the boundaries of the board, it falls and sustains damage. An order that leads to the robot's damage is not deemed successfully completed.

The robot's mission is to carry out the maximum number of orders without departing from the board. For instance, on a 3 × 3 board, if the robot begins a set of operations s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the middle cell, the robot will execute one order before the subsequent command leads it off the boundary. If the robot commences movement from the cell (2, 1) (second row, first column) then every order will be successfully executed. It will conclude at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Ascertain the cell from which the robot should initiate its movement to carry out the maximum number of commands possible.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
multi-gen-prompt:
The machine is situated on a checkered rectangular board with dimensions n × m, where n represents rows and m represents columns, and the robot has the ability to transition from its current position to one of the four neighboring cells on the sides.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
in generating...
in generating repo





in generating repo





in generating repo







in generating repo





in generating repo








in generating repo









in generating repo





in generating repo









in generating repo








in generating repo







in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, True, False, True, False, True, False, False, False]
True
----------updating----------
analyst reward: 0.14120155572891235
final_output reward: 0.2
total reward: 0.34120155572891236
add mutated seed into prompt node list
seed_index: 19
mutated_seed_index: 31
reward = 0.34120155572891236
saving......
----------------------------------------round: 20------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:21
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Analyze the format carefully in order to determine which of the two numbers is larger, or if they are equal.

--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers adhere to a certain structure: a positive integer x with p zeros attached to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Analyze the format carefully in order to determine which of the two numbers is larger, or if they are equal.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard. Both numbers adhere to a certain structure: a positive integer x with p zeros attached to its end. Analyze the format carefully to determine which of the two numbers is larger, or if they are equal.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard, both adhere to a certain structure: a positive integer x with p zeros attached to its end asks you to compare these two numbers. Can you help Monocarp? Analyze the format carefully in order to determine which of the two numbers is larger, or if they are equal.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, True, True, True, True, True, True, False, True, False]
True
----------updating----------
analyst reward: 0
final_output reward: 0.3
total reward: 0.3
add mutated seed into prompt node list
seed_index: 21
mutated_seed_index: 32
reward = 0.3
saving......
----------------------------------------round: 21------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:25
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You have an array of integers (initially empty). You have to perform q queries, and each query is of one of two types: 

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 

Find the resulting array after performing all the queries.

--------------------------------------------------
You possess an initially empty list of integers. You have to perform q queries, and each query is of one of two types: 

  * "1 x" — insert the element x at the end of the array; 
  * "2 x y" — substitute every occurrence of x in the array with y. 

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
You possess an initially empty list of integers. You have to perform q queries, and each query is of one of two types: 

  * "1 x" — insert the element x at the end of the array; 
  * "2 x y" — substitute every occurrence of x in the array with y. 

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
You possess an initially empty list of integers and have to perform q queries, with each query being either "1 x" to insert x at the end of the array or "2 x y" to substitute every occurrence of x with y. Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo







in generating repo








in generating repo








in generating repo







in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, True, True, True, True, False, True, False, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
in recording...
len prompt_nodes
33
initial_seed_num
13
[False, False, True, False, False, True, False, False, False, True, False, True, False]
total pass@10:9
------------------------------
saving result into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_final_result.jsonl
------------------------------
saving original node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_original_node.jsonl
------------------------------
saving node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_node_21.jsonl
----------------------------------------round: 22------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:23
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
A string is termed square if it is a sequence repeated two times consecutively. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

--------------------------------------------------
A string is termed square if it is a sequence repeated two times consecutively. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square. Ensure to consider edge cases such as an empty string or a string with only one character.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
A string is termed square if it is a sequence repeated two times consecutively. For instance, the strings "aa" and "abcabc" are examples of square strings.

For a given string s, evaluate if it is square by checking if it repeats itself twice in a row. Make sure to handle edge cases like an empty string or a string with a single character.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
A string is termed square if it is a sequence repeated two times consecutively, for example, the strings "aa", "abcabc", "abab" and "baabaa" are square, but the strings "aaa", "abaaab" and "abcdabc" are not square.
For a given string s determine if it is square. Ensure to consider edge cases such as an empty string or a string with only one character.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
in generating...
in generating repo






in generating repo








in generating repo






in generating repo









in generating repo












in generating repo






in generating repo








in generating repo





in generating repo








in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_22_2/codecontest_22_2
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_22_5/codecontest_22_5
evaluating ...
[False, True, False, True, False, False, False, False, False, False]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 23------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:26
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i.

You can select an item from the present sequence and discard it, then join the leftover elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). You can analyze the sequence to identify positions that do not contribute to f(a) before deciding which elements to remove.

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i.

You can select an item from the present sequence and discard it, then join the leftover elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). You can analyze the sequence to identify positions that do not contribute to f(a) before deciding which elements to remove. Consider both the current and potential future state of f(a) when deciding which elements to discard.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i. Identify positions that do not contribute to f(a) and strategically remove elements to maximize f(a), considering both the current and potential future state of f(a) in the sequence.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n, define f(a) as the count of indices where a_i equals i. You can select an item from the present sequence and discard it, then join the leftover elements together in order to maximize f(a). Find the largest possible f(a) considering both the current and potential future state of f(a) when deciding which elements to discard.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
in generating...
in generating repo





in generating repo









in generating repo








in generating repo





in generating repo








in generating repo








in generating repo








in generating repo








in generating repo








in generating repo









in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, True, True, False, True, False, True]
True
----------updating----------
analyst reward: 0.1097402572631836
final_output reward: 0
total reward: 0.1097402572631836
add mutated seed into prompt node list
seed_index: 26
mutated_seed_index: 33
reward = 0.1097402572631836
saving......
----------------------------------------round: 24------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:27
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Mr. Chanek possesses a collection of n numbers in array a. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

Put differently, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this efficiently for large input sizes.

--------------------------------------------------
Mr. Chanek possesses a collection of n numbers in array a. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y. The GCD is the largest positive integer that divides both x and y without leaving a remainder.

Put differently, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this efficiently for large input sizes.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek possesses a collection of n numbers in array a. The prettiness value of a can be calculated as the sum of the product of the greatest common divisors of elements ai and aj, multiplied by the GCD of their corresponding indices i and j. 

Help Mr. Chanek find the prettiness value of a efficiently for large input sizes, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this. 

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
Mr. Chanek needs help finding the prettiness value of array a efficiently for large input sizes, outputting the result modulo 10^9 + 7.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
in generating...
in generating repo





in generating repo





in generating repo





in generating repo








in generating repo





in generating repo





in generating repo





in generating repo








in generating repo








in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, False, False, False, True, True, False]
True
----------updating----------
analyst reward: 0.10670077800750732
final_output reward: 0
total reward: 0.10670077800750732
add mutated seed into prompt node list
seed_index: 27
mutated_seed_index: 34
reward = 0.10670077800750732
saving......
----------------------------------------round: 25------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:31
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
The machine is situated on a checkered rectangular board with dimensions n × m, where n represents rows and m represents columns. The rows in the board are assigned numbers from 1 to n starting at the top, and the columns — from 1 to m beginning at the left side.

The robot has the ability to transition from its current position to one of the four neighboring cells on the sides.

The sequence of orders s carried out by the robot is provided. Each order is symbolized by one of the letters 'L', 'R', 'D' or 'U'. These letters initiate the movement to the left, right, downward or upward, respectively.

The robot's movement can commence in any cell. The robot processes the orders beginning with the initial one, following the sequence they appear in s. If the robot travels past the boundaries of the board, it falls and sustains damage. An order that leads to the robot's damage is not deemed successfully completed.

The robot's mission is to carry out the maximum number of orders without departing from the board. For instance, on a 3 × 3 board, if the robot begins a set of operations s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the middle cell, the robot will execute one order before the subsequent command leads it off the boundary. If the robot commences movement from the cell (2, 1) (second row, first column) then every order will be successfully executed. It will conclude at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Ascertain the cell from which the robot should initiate its movement to carry out the maximum number of commands possible.

--------------------------------------------------
The machine is located on a checkered rectangular board with dimensions n × m, where n stands for rows and m signifies columns. The rows in the board are assigned numbers from 1 to n starting at the top, and the columns — from 1 to m beginning at the left side.

The robot has the ability to transition from its current position to one of the four neighboring cells on the sides.

The sequence of orders s carried out by the robot is provided. Each order is represented by one of the letters 'L', 'R', 'D' or 'U'. These letters initiate the movement to the left, right, downward or upward, respectively.

The robot's movement can commence in any cell. The robot processes the orders beginning with the initial one, following the sequence they appear in s. If the robot travels past the boundaries of the board, it falls and sustains damage. An order that leads to the robot's damage is not deemed successfully completed.

The robot's mission is to carry out the maximum number of orders without departing from the board. For example, in a 3 × 3 grid, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the middle cell, the robot will execute one order before the subsequent command leads it off the boundary. If the robot commences movement from the cell (2, 1) (second row, first column) then every order will be successfully executed. It will conclude at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Determine the starting cell from which the robot should begin its movement to execute the maximum number of commands possible.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
The robot's movement can commence in any cell. The robot processes the orders beginning with the initial one, following the sequence they appear in s. If the robot travels past the boundaries of the board, it falls and sustains damage. 

The machine is located on a checkered rectangular board with dimensions n × m, where n stands for rows and m signifies columns. The rows in the board are assigned numbers from 1 to n starting at the top, and the columns — from 1 to m beginning at the left side.

The robot has the ability to transition from its current position to one of the four neighboring cells on the sides.

The sequence of orders s carried out by the robot is provided. Each order is represented by one of the letters 'L', 'R', 'D' or 'U'. These letters initiate the movement to the left, right, downward or upward, respectively.

An order that leads to the robot's damage is not deemed successfully completed. The robot's mission is to carry out the maximum number of orders without departing from the board. For example, in a 3 × 3 grid, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the middle cell, the robot will execute one order before the subsequent command leads it off the boundary. If the robot commences movement from the cell (2, 1) (second row, first column) then every order will be successfully executed. It will conclude at the cell (1, 2) (first row, second column).

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
multi-gen-prompt:
The robot starts from cell (2, 1) (second row, first column) and moves right, right, down, left, up, and up to end at the cell (1, 2) (first row, second column). Determine the starting cell from which the robot should begin its movement to execute the maximum number of commands possible.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
in generating...
in generating repo





in generating repo







in generating repo





in generating repo





in generating repo







in generating repo





in generating repo







in generating repo






in generating repo








in generating repo





in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, True, True, False, True, False, False, False, True, True]
True
----------updating----------
analyst reward: 0.14208197593688965
final_output reward: 0
total reward: 0.14208197593688965
add mutated seed into prompt node list
seed_index: 31
mutated_seed_index: 35
reward = 0.14208197593688965
saving......
----------------------------------------round: 26------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:3
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs and wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Luntik wants to make the absolute difference of durations of the concerts as small as possible. He needs to find the minimal possible difference in minutes between the concerts durations. Can you help him with this optimization problem?  

Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs and wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
Luntik has decided to try singing, b two-minute songs, and c three-minute songs and wants to distribute all songs into two concerts such that every song should be included to exactly one concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
in generating...
in generating repo





in generating repo





in generating repo






in generating repo






in generating repo





in generating repo







in generating repo








in generating repo








in generating repo









in generating repo










in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, True, True, True, False, False, False, True, False]
True
----------updating----------
analyst reward: 0.3146035671234131
final_output reward: 0
total reward: 0.3146035671234131
add mutated seed into prompt node list
seed_index: 3
mutated_seed_index: 36
reward = 0.3146035671234131
saving......
----------------------------------------round: 27------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:29
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
The robot is situated on a checkered rectangular board of dimensions n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom. The columns are numbered from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively.

The robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. 

  * If the robot surpasses the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 

Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.

Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

--------------------------------------------------
The robot is situated on a checkered rectangular board of dimensions n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom. The columns are numbered from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side. The adjacent cells are only the ones directly to the left, right, above, or below the current cell.

Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively.

The robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move.

  * If the robot surpasses the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 

Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.

Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
The rows in the board are numbered from 1 to n from top to bottom, while the columns are numbered from 1 to m from left to right. Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively.

The robot can start its movement in any cell, aiming to make the maximum number of steps before it breaks or stops. Determine from which square the robot should start its movement to execute as many commands as possible.

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
multi-gen-prompt:
The robot is situated on a checkered rectangular board of dimensions n × m where it can move to adjacent cells in four directions. Each cell has a direction symbol, and the robot's goal is to make the maximum number of steps before breaking or stopping. Determine the square from which the robot should start its movement for maximum efficiency.

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo






in generating repo





in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, True, False, False, True, False, False, False]
True
----------updating----------
analyst reward: 0.12326228618621826
final_output reward: 0
total reward: 0.12326228618621826
add mutated seed into prompt node list
seed_index: 29
mutated_seed_index: 37
reward = 0.12326228618621826
saving......
----------------------------------------round: 28------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:32
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers adhere to a certain structure: a positive integer x with p zeros attached to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Analyze the format carefully in order to determine which of the two numbers is larger, or if they are equal.

--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers adhere to a certain structure: a positive integer x with p zeros attached to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Analyze the format carefully in order to determine which of the two numbers is larger, or if they are equal. Consider edge cases where the numbers might differ in their original integers or the number of zeros appended.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard. Both numbers adhere to a certain structure: a positive integer x with p zeros attached to its end. Ensure to carefully analyze the format specified to ascertain which number between the two is greater, or if they are equivalent. Acquaint yourself with scenarios where the original integers or the quantity of appended zeros vary to address potential edge cases effectively. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard with a given structure, and asks you to compare them to determine which is larger or if they are equal. Analyze the format carefully, including edge cases of different original integers or varying numbers of zeros attached.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo






in generating repo





in generating repo





in generating repo





in generating repo








in generating repo








in generating repo






in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_28_6/codecontest_28_6
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_28_8/codecontest_28_8
evaluating ...
[True, True, True, False, True, True, True, True, True, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 29------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:4
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You are given a string s of length n consisting of characters a and/or b.

Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring.

In one step, you can choose any index i and replace s_i with character a or b.

What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Reminder:

The number of occurrences of string d in s as substring is the number of indices i (1 ≤ i ≤ |s| - |d| + 1) such that substring s_i s_{i + 1} ... s_{i + |d| - 1} is equal to d. For example, \operatorname{AB}(aabbbabaa) = 2 since there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa.

--------------------------------------------------
You are given a string s of length n consisting of characters a and/or b.

Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring, and analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring.

In one step, you can choose any index i and replace s_i with character a or b.

What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Reminder:

The number of occurrences of string d in s as substring is the number of indices i (1 ≤ i ≤ |s| - |d| + 1) such that substring s_i s_{i + 1} ... s_{i + |d| - 1} is equal to d; for example, \operatorname{AB}(aabbbabaa) = 2 since there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
In one step, you can choose any index i and replace s_i with character a or b. When calculating the occurrences of string ab and ba in s, what is the minimum number of steps needed to make them equal?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
multi-gen-prompt:
You are given a string s of length n consisting of characters a and/or b, what is the minimum number of steps you need to achieve \operatorname{AB}(s) = \operatorname{BA}(s)? Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring, and the number of occurrences of ba in s as a substring is \operatorname{BA}(s). In one step, you can choose any index i and replace s_i with character a or b.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
in generating...
in generating repo







in generating repo






in generating repo







in generating repo









in generating repo






in generating repo









in generating repo









in generating repo






in generating repo










in generating repo






in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_29_6/codecontest_29_6
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_29_7/codecontest_29_7
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_29_8/codecontest_29_8
evaluating ...
[False, False, False, False, False, False, False, False, False, False]
False
----------updating----------
seed 4 finish fuzzing!
seed_index: 4
mutated_seed_index: 38
current seed length: 8
saving......
----------------------------------------round: 30------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:23
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
A string is termed square if it is a sequence repeated two times consecutively. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

--------------------------------------------------
A string is termed square if it is a sequence repeated two times consecutively, for example, the strings "aa", "abcabc", "abab" and "baabaa" are square, but the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
A string is termed square if it is a sequence repeated two times consecutively. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. Can you determine if a given string s is square or not?

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
A string is termed square if it is a sequence repeated two times consecutively, for example, the strings "aa", "abcabc", "abab" and "baabaa" are square, but determine if a given string s is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
in generating...
in generating repo





in generating repo





in generating repo





in generating repo








in generating repo









in generating repo





in generating repo









in generating repo






in generating repo








in generating repo






in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_30_0/codecontest_30_0
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_30_1/codecontest_30_1
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_30_9/codecontest_30_9
evaluating ...
[True, True, True, False, True, True, True, False, True, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 31------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:33
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i.

You can select an item from the present sequence and discard it, then join the leftover elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). You can analyze the sequence to identify positions that do not contribute to f(a) before deciding which elements to remove. Consider both the current and potential future state of f(a) when deciding which elements to discard.

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i.

You can select an item from the present sequence and discard it, then join the leftover elements together; for example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). You can analyze the sequence to identify positions that do not contribute to f(a) before deciding which elements to remove. Consider both the current and potential future state of f(a) when deciding which elements to discard.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i. Identify positions within the sequence where a_i equals i before choosing elements to discard in order to maximize f(a); take into account both the current and potential future state of f(a) during the decision-making process.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n and define f(a) as the count of indices where a_i equals i, maximizing f(a) by removing elements from a while considering both current and potential future state of f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
in generating...
in generating repo





in generating repo





in generating repo







in generating repo





in generating repo







in generating repo








in generating repo







in generating repo









in generating repo








in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, True, False, False, True, True, False, False, True, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
in recording...
len prompt_nodes
39
initial_seed_num
13
[False, False, True, False, True, True, False, False, False, True, False, True, False]
total pass@10:8
------------------------------
saving result into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_final_result.jsonl
------------------------------
saving original node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_original_node.jsonl
------------------------------
saving node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_node_31.jsonl
----------------------------------------round: 32------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:34
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Mr. Chanek possesses a collection of n numbers in array a. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y. The GCD is the largest positive integer that divides both x and y without leaving a remainder.

Put differently, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this efficiently for large input sizes.

--------------------------------------------------
Mr. Chanek possesses a collection of n numbers in array a. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y, and is the largest positive integer that divides both x and y without leaving a remainder. Put differently, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this efficiently for large input sizes.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek wishes to determine the prettiness value of array a represented by a complex mathematical formula involving the greatest common divisor (GCD) of pairs of elements and indices. This involves finding the sum of the products of these GCD values for all possible pairs in the array and then applying modulo 10^9 + 7 for efficiency in dealing with large input sizes. Can you assist him in computing this prettiness value efficiently?

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
Mr. Chanek possesses a collection of n numbers in array a; the prettiness value of a is denoted as the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j). Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this efficiently for large input sizes.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, True, True, False, False, False, True]
True
----------updating----------
analyst reward: 0.15200912952423096
final_output reward: 0
total reward: 0.15200912952423096
add mutated seed into prompt node list
seed_index: 34
mutated_seed_index: 39
reward = 0.15200912952423096
saving......
----------------------------------------round: 33------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:36
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs and wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Luntik wants to distribute his one-minute, two-minute, and three-minute songs into two concerts with the smallest possible difference in durations. Can you assist Luntik in finding the minimal possible difference in minutes between the concerts?

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
Luntik has a one-minute, b two-minute, and c three-minute songs and wants to distribute them into two concerts with the smallest possible difference in their durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
in generating...
in generating repo





in generating repo





in generating repo







in generating repo






in generating repo






in generating repo







in generating repo









in generating repo









in generating repo






in generating repo





in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_33_0/codecontest_33_0
evaluating ...
[False, True, False, False, True, False, True, False, False, False]
True
----------updating----------
analyst reward: 0.13939106464385986
final_output reward: 0.1
total reward: 0.23939106464385987
add mutated seed into prompt node list
seed_index: 36
mutated_seed_index: 40
reward = 0.23939106464385987
saving......
----------------------------------------round: 34------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:25
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You have an array of integers (initially empty). You have to perform q queries, and each query is of one of two types: 

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 

Find the resulting array after performing all the queries.

--------------------------------------------------
You have an array of integers (initially empty). You have to perform q queries, and each query is of one of two types:

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. You need to replace all instances of the number x found in the array. Substitute each occurrence with the new value y.

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
You have to replace all occurrences of x in the array with y. Replace each occurrence of the number x found in the array with the new value y. 

You have an array of integers (initially empty). You have to perform q queries, and each query is of one of two types:

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. You need to replace all instances of the number x found in the array. Substitute each occurrence with the new value y.

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
You have to perform q queries, and each query is of one of two types: "1 x" — add the element x to the end of the array; "2 x y" — replace all occurrences of x in the array with y. Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
in generating...
in generating repo





in generating repo





in generating repo






in generating repo







in generating repo





in generating repo








in generating repo








in generating repo







in generating repo








in generating repo









in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, True, False, True, False, True, True, True, False, False]
True
----------updating----------
analyst reward: 0.11967486143112183
final_output reward: 0.3
total reward: 0.4196748614311218
add mutated seed into prompt node list
seed_index: 25
mutated_seed_index: 41
reward = 0.4196748614311218
saving......
----------------------------------------round: 35------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:35
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
The machine is located on a checkered rectangular board with dimensions n × m, where n stands for rows and m signifies columns. The rows in the board are assigned numbers from 1 to n starting at the top, and the columns — from 1 to m beginning at the left side.

The robot has the ability to transition from its current position to one of the four neighboring cells on the sides.

The sequence of orders s carried out by the robot is provided. Each order is represented by one of the letters 'L', 'R', 'D' or 'U'. These letters initiate the movement to the left, right, downward or upward, respectively.

The robot's movement can commence in any cell. The robot processes the orders beginning with the initial one, following the sequence they appear in s. If the robot travels past the boundaries of the board, it falls and sustains damage. An order that leads to the robot's damage is not deemed successfully completed.

The robot's mission is to carry out the maximum number of orders without departing from the board. For example, in a 3 × 3 grid, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the middle cell, the robot will execute one order before the subsequent command leads it off the boundary. If the robot commences movement from the cell (2, 1) (second row, first column) then every order will be successfully executed. It will conclude at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Determine the starting cell from which the robot should begin its movement to execute the maximum number of commands possible.

--------------------------------------------------
The machine is placed on a checkered rectangular board with measurements n × m, where n indicates rows and m denotes columns. The rows in the board are assigned numbers from 1 to n starting at the top, and the columns — from 1 to m beginning at the left side.

The robot has the ability to transition from its current position to one of the four neighboring cells on the sides.

The sequence of orders s carried out by the robot is provided. Each order is represented by one of the letters 'L', 'R', 'D' or 'U'. These letters initiate the movement to the left, right, downward or upward, respectively.

The robot's movement can commence in any cell. The robot processes the orders beginning with the initial one, following the sequence they appear in s. If the robot travels past the boundaries of the board, it falls and sustains damage. An order that leads to the robot's damage is not deemed successfully completed.

The robot's mission is to carry out the maximum number of orders without departing from the board. For example, in a 3 × 3 grid, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the middle cell, the robot will execute one order before the subsequent command leads it off the boundary. If the robot commences movement from the cell (2, 1) (second row, first column) then every order will be successfully executed. It will conclude at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Find out the cell where the robot should initiate its movement to perform the maximum number of orders possible.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
The robot should initiate its movement from the cell (2, 1) (second row, first column) in order to successfully execute every order and conclude at the cell (1, 2) (first row, second column).

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
multi-gen-prompt:
The robot's mission is to carry out the maximum number of orders without departing from the board, find out the cell where the robot should initiate its movement to perform the maximum number of orders possible.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo









in generating repo









in generating repo








in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, False, False, False, False, False, False]
False
----------updating----------
seed 35 finish fuzzing!
seed_index: 35
mutated_seed_index: 42
current seed length: 7
saving......
----------------------------------------round: 36------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:37
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
The robot is situated on a checkered rectangular board of dimensions n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom. The columns are numbered from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side. The adjacent cells are only the ones directly to the left, right, above, or below the current cell.

Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively.

The robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move.

  * If the robot surpasses the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 

Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.

Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

--------------------------------------------------
The robot is situated on a checkered rectangular board of dimensions n × m (n rows, m columns), with rows numbered from 1 to n from top to bottom and columns numbered from 1 to m from left to right. The robot is able to move from the current cell to one of the four cells adjacent by side, which are only the ones directly to the left, right, above, or below the current cell.

Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively. The robot can start its movement in any cell, then moves to the adjacent square in the direction indicated on the current square in one move.

  * If the robot surpasses the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 

Robot can choose any cell as the starting cell, and its goal is to make the maximum number of steps before it breaks or stops.

Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
The robot can start its movement in any cell, then moves to the adjacent square in the direction indicated on the current square in one move. This allows it to make the maximum number of steps before it breaks or stops.

The robot is situated on a checkered rectangular board of dimensions n × m (n rows, m columns), with rows numbered from 1 to n from top to bottom and columns numbered from 1 to m from left to right. The robot is able to move from the current cell to one of the four cells adjacent by side, which are only the ones directly to the left, right, above, or below the current cell. 

Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively. The robot can start its movement in any cell, then moves to the adjacent square in the direction indicated on the current square in one move.

If the robot surpasses the edge of the board, it falls and breaks. If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 

Robot can choose any cell as the starting cell, and its goal is to make the maximum number of steps before it breaks or stops.

Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
multi-gen-prompt:
The robot can choose any cell as the starting cell, then moves to the adjacent square in the direction indicated on the current square in one move, aiming to make the maximum number of steps before breaking or stopping.

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo







in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, False, False, False, False, True, False, False, False]
True
----------updating----------
analyst reward: 0.14309096336364746
final_output reward: 0
total reward: 0.14309096336364746
add mutated seed into prompt node list
seed_index: 37
mutated_seed_index: 43
reward = 0.14309096336364746
saving......
----------------------------------------round: 37------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:32
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers adhere to a certain structure: a positive integer x with p zeros attached to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Analyze the format carefully in order to determine which of the two numbers is larger, or if they are equal.

--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers adhere to a certain structure: a positive integer x with p zeros attached to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Analyze the format carefully in order to determine which of the two numbers is larger, or if they are equal. Ensure that your solution accounts for potential leading zeros that may affect the comparison outcome.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard. Both numbers adhere to a certain structure: a positive integer x with p zeros attached to its end. One must carefully analyze the format to determine which of the two numbers is larger, or if they are equal, accounting for potential leading zeros that may influence the comparison outcome. Can you help Monocarp with this task?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard, both adhering to a certain structure: a positive integer x with p zeros attached to its end. Now Monocarp asks you to compare these two numbers. Can you help him with a solution that accounts for leading zeros that may affect the comparison outcome?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo





in generating repo






in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, False, False, True, False, True, True, True, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 38------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:41
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You have an array of integers (initially empty). You have to perform q queries, and each query is of one of two types:

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. You need to replace all instances of the number x found in the array. Substitute each occurrence with the new value y.

Find the resulting array after performing all the queries.

--------------------------------------------------
You have an array of integers (initially empty). You have to perform q queries, and each query is of one of two types:

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. You have to find and replace every instance of x in the array. It is essential to substitute all occurrences with y.

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Find the resulting array after performing all the queries. You have to find and replace every instance of x in the array, it is essential to substitute all occurrences with y.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
You have to perform q queries, and each query is of one of two types: "1 x" (add the element x to the end of the array) or "2 x y" (replace all occurrences of x with y).

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
in generating...
in generating repo





in generating repo





in generating repo








in generating repo





in generating repo








in generating repo





in generating repo





in generating repo









in generating repo







in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, False, False, True, True, False, False, True, False]
True
----------updating----------
analyst reward: 0.12646061182022095
final_output reward: 0
total reward: 0.12646061182022095
add mutated seed into prompt node list
seed_index: 41
mutated_seed_index: 44
reward = 0.12646061182022095
saving......
----------------------------------------round: 39------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:39
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Mr. Chanek possesses a collection of n numbers in array a. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y, and is the largest positive integer that divides both x and y without leaving a remainder. Put differently, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this efficiently for large input sizes.

--------------------------------------------------
Mr. Chanek possesses a collection of n numbers in array a. The prettiness value of a is denoted as: $$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$ where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y, and is the largest positive integer that divides both x and y without leaving a remainder; put differently, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j). Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this efficiently for large input sizes.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek possesses a collection of n numbers in array a. The calculation of the prettiness value involves finding the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j) in the array. Help Mr. Chanek determine this value and output the result modulo 10^9 + 7 to handle large input sizes efficiently! Your task is to implement a solution to calculate this efficiently for large input sizes.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
Mr. Chanek needs help finding the prettiness value of array a efficiently for large input sizes, outputting the result modulo 10^9 + 7.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo








in generating repo









in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, True, False, False, True, False, False, True]
True
----------updating----------
analyst reward: 0.14968782663345337
final_output reward: 0
total reward: 0.14968782663345337
add mutated seed into prompt node list
seed_index: 39
mutated_seed_index: 45
reward = 0.14968782663345337
saving......
----------------------------------------round: 40------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:23
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
A string is termed square if it is a sequence repeated two times consecutively. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

--------------------------------------------------
A string is termed square if it is a sequence repeated two times consecutively, for example, the strings "aa", "abcabc", "abab" and "baabaa" are square, but the strings "aaa", "abaaab" and "abcdabc" are not square. For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
A string is termed square if it is a sequence repeated two times consecutively, for example, the strings "aa", "abcabc", "abab" and "baabaa" are square, but the strings "aaa", "abaaab" and "abcdabc" are not square. Determine if a given string s is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
A string is termed square if it is a sequence repeated two times consecutively, for example, the strings "aa", "abcabc" are square, but the strings "aaa" are not square. For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
in generating...
in generating repo








in generating repo








in generating repo








in generating repo






in generating repo






in generating repo








in generating repo









in generating repo










in generating repo






in generating repo






in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_40_0/codecontest_40_0
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_40_7/codecontest_40_7
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_40_8/codecontest_40_8
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_40_9/codecontest_40_9
evaluating ...
[False, False, False, True, False, False, True, False, False, False]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 41------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:33
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i.

You can select an item from the present sequence and discard it, then join the leftover elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). You can analyze the sequence to identify positions that do not contribute to f(a) before deciding which elements to remove. Consider both the current and potential future state of f(a) when deciding which elements to discard.

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i.

You can select an item from the present sequence and discard it, then join the leftover elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], it will result in a shorter sequence, [4, 2, 1]. This sequence is achieved after omitting the specified element.

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). You can analyze the sequence to identify positions that do not contribute to f(a) before deciding which elements to remove. Consider both the current and potential future state of f(a) when deciding which elements to discard.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i.

For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], it will result in a shorter sequence, [4, 2, 1]. This sequence is achieved after omitting the specified element. 

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). You can analyze the sequence to identify positions that do not contribute to f(a) before deciding which elements to remove. Consider both the current and potential future state of f(a) when deciding which elements to discard.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n, define f(a) as the count of indices where a_i equals i. You can select an item from the present sequence and discard it to join the leftover elements, aiming to maximize f(a). Find the largest possible f(a) by analyzing the sequence and considering the current and potential future state of f(a) before deciding which elements to remove.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
in generating...
in generating repo





in generating repo








in generating repo





in generating repo








in generating repo









in generating repo








in generating repo








in generating repo









in generating repo









in generating repo









in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, False, False, False, True, False, True, False, True, False]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
in recording...
len prompt_nodes
46
initial_seed_num
13
[False, False, True, False, True, True, True, False, False, True, False, True, False]
total pass@10:7
------------------------------
saving result into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_final_result.jsonl
------------------------------
saving original node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_original_node.jsonl
------------------------------
saving node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_node_41.jsonl
----------------------------------------round: 42------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:40
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider both even and odd values for the number of songs to find the optimal solution.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Luntik wants to distribute all his songs into two concerts in a way that the absolute difference of durations between the concerts is minimized. Help him find the minimal possible difference by considering both even and odd values for the number of songs. He has a one-minute songs, b two-minute songs, and c three-minute songs to be assigned to the concerts.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
Luntik has one-minute songs, b two-minute songs, and c three-minute songs to distribute into two concerts, aiming for the smallest absolute difference in duration between the concerts. Please find the minimal possible difference in minutes between the concerts durations by considering both even and odd values for the number of songs to reach the optimal solution.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
in generating...
in generating repo






in generating repo





in generating repo





in generating repo






in generating repo





in generating repo








in generating repo







in generating repo








in generating repo






in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, False, False, False, True, False, True, False, False, True]
True
----------updating----------
analyst reward: 0.10727393627166748
final_output reward: 0
total reward: 0.10727393627166748
add mutated seed into prompt node list
seed_index: 40
mutated_seed_index: 46
reward = 0.10727393627166748
saving......
----------------------------------------round: 43------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:43
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
The robot is situated on a checkered rectangular board of dimensions n × m (n rows, m columns), with rows numbered from 1 to n from top to bottom and columns numbered from 1 to m from left to right. The robot is able to move from the current cell to one of the four cells adjacent by side, which are only the ones directly to the left, right, above, or below the current cell.

Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively. The robot can start its movement in any cell, then moves to the adjacent square in the direction indicated on the current square in one move.

  * If the robot surpasses the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 

Robot can choose any cell as the starting cell, and its goal is to make the maximum number of steps before it breaks or stops.

Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

--------------------------------------------------
The robot is positioned on a checkered rectangular board with dimensions n × m (n rows, m columns), where rows are numbered from 1 to n top to bottom and columns are numbered from 1 to m left to right. The robot is able to move from the current cell to one of the four cells adjacent by side, which are only the ones directly to the left, right, above, or below the current cell.

Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively. The robot can start its movement in any cell, then moves to the adjacent square in the direction indicated on the current square in one move.

  * If the robot surpasses the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 

Robot can choose any cell as the starting cell, and its goal is to make the maximum number of steps before it breaks or stops.

Decide from which square the robot should begin its movement in order to carry out the most commands possible. A command is considered successfully executed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
The robot is able to move from the current cell to one of the four cells adjacent by side, which are only the ones directly to the left, right, above, or below the current cell. Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell.

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
multi-gen-prompt:
The robot is positioned on a checkered rectangular board with dimensions n × m (n rows, m columns) and is able to move from the current cell to one of the four adjacent cells. Each cell has a direction indicated by 'L', 'R', 'D' or 'U', and the goal is to make the maximum number of steps before breaking or stopping.

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo







in generating repo





in generating repo








in generating repo







in generating repo






in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, True, False, False, False, False, False, False, False, False]
True
----------updating----------
analyst reward: 0.17242199182510376
final_output reward: 0.2
total reward: 0.37242199182510377
add mutated seed into prompt node list
seed_index: 43
mutated_seed_index: 47
reward = 0.37242199182510377
saving......
----------------------------------------round: 44------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False]
current seed index:45
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek possesses a collection of n numbers in array a. The prettiness value of a is denoted as: $$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$ where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y, and is the largest positive integer that divides both x and y without leaving a remainder; put differently, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j). Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this efficiently for large input sizes.

--------------------------------------------------
Mr. Chanek has a collection of n integers in array a. The prettiness value of a is denoted as: $$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$ where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y, and is the largest positive integer that divides both x and y without leaving a remainder; in other words, the prettiness value of an array a is the overall sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j). Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this efficiently for large input sizes.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek has a collection of n integers in array a. The prettiness value of a is the sum of the GCD of pairs of elements and indices, making it a crucial metric for evaluating the uniqueness of the array. Help Mr. Chanek determine this value efficiently for large input sizes and output the result modulo 10^9 + 7.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
Mr. Chanek has a collection of n integers in array a, and the prettiness value of a is calculated using GCD, help him find this value modulo 10^9 + 7 efficiently for large input sizes.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, True, True, False, False, False, False, False, False, False]
True
----------updating----------
analyst reward: 0.18117809295654297
final_output reward: 0.1
total reward: 0.28117809295654295
add mutated seed into prompt node list
seed_index: 45
mutated_seed_index: 48
reward = 0.28117809295654295
saving......
----------------------------------------round: 45------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:28
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs and he wants to distribute all songs into two concerts such that every song should be included to exactly one concert, and he wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Luntik has a collection of songs with varied durations. He needs to split them into two concerts with minimal difference in total duration. Can you help him achieve this by finding the smallest possible gap in minutes between the concerts?

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
Luntik has decided to try singing and has a one-minute songs, b two-minute songs and c three-minute songs, requiring help to find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
in generating...
in generating repo





in generating repo






in generating repo





in generating repo






in generating repo







in generating repo






in generating repo






in generating repo








in generating repo





[1;31mGive Feedback / Get Help: https://github.com/BerriAI/litellm/issues/new[0m
LiteLLM.Info: If you need to debug this error, use `litellm._turn_on_debug()'.






in generating repo









in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, True, True, False, False, False, True, True, True, False]
True
----------updating----------
analyst reward: 0.14258956909179688
final_output reward: 0
total reward: 0.14258956909179688
add mutated seed into prompt node list
seed_index: 28
mutated_seed_index: 49
reward = 0.14258956909179688
saving......
----------------------------------------round: 46------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:25
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You have an array of integers (initially empty). You have to perform q queries, and each query is of one of two types: 

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 

Find the resulting array after performing all the queries.

--------------------------------------------------
You have an array of integers (initially empty). You have to perform q queries where each query is of one of two types: 

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
You have an array of integers (initially empty). You have to perform q queries where each query is of one of two types: 
Add the element x to the end of the array and replace all occurrences of x with y in the array. Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
You have an array of integers (initially empty) and need to perform q queries: "1 x" to add a specific element to the end and "2 x y" to replace all occurrences of x with y. Find the resulting array after all queries are executed.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo








in generating repo








in generating repo









in generating repo





in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, True, False, True, False, True, False, True, True, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0.2
total reward: 0.2
add mutated seed into prompt node list
seed_index: 25
mutated_seed_index: 50
reward = 0.2
saving......
----------------------------------------round: 47------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:23
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
A string is termed square if it is a sequence repeated two times consecutively. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

--------------------------------------------------
A string is termed square if it is a sequence repeated two times consecutively; for example, the strings "aa", "abcabc", "abab" and "baabaa" are square, but the strings "aaa", "abaaab" and "abcdabc" are not square. For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
A string is termed square if it is a sequence repeated two times consecutively; for example, the strings "aa", "abcabc", "abab" and "baabaa" are square, but the strings "aaa", "abaaab" and "abcdabc" are not square. An input string is provided, and the task is to check if it qualifies as a square string.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
A string is termed square if it is a sequence repeated two times consecutively; for example, the strings "aa", "abcabc", "abab" and "baabaa" are square, but the strings "aaa", "abaaab" and "abcdabc" are not square. Determine if a given string s is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
in generating...
in generating repo





in generating repo








in generating repo






in generating repo






in generating repo





in generating repo






in generating repo






in generating repo





in generating repo






in generating repo






in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_47_0/codecontest_47_0
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_47_1/codecontest_47_1
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_47_2/codecontest_47_2
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_47_3/codecontest_47_3
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_47_4/codecontest_47_4
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_47_5/codecontest_47_5
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_47_8/codecontest_47_8
evaluating ...
[True, True, True, True, True, True, True, True, True, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 48------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:33
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i.

You can select an item from the present sequence and discard it, then join the leftover elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). You can analyze the sequence to identify positions that do not contribute to f(a) before deciding which elements to remove. Consider both the current and potential future state of f(a) when deciding which elements to discard.

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i. You can select an item from the present sequence and discard it, then join the leftover elements together, for example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to remove some elements from a in order to maximize f(a), using zero or more operations, and find the largest possible f(a). You can analyze the sequence to identify positions that do not contribute to f(a) before deciding which elements to remove, while considering both the current and potential future state of f(a) when deciding which elements to discard.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i. If you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to remove some elements from a in order to maximize f(a), using zero or more operations, and find the largest possible f(a). You can analyze the sequence to identify positions that do not contribute to f(a) before deciding which elements to remove, while considering both the current and potential future state of f(a) when deciding which elements to discard.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n, define f(a) as the count of indices where a_i equals i, wants to remove some elements from a in order to maximize f(a) by analyzing the sequence to identify positions that do not contribute to f(a) before deciding which elements to remove, while considering both the current and potential future state of f(a) when deciding which elements to discard. You can select an item from the present sequence and discard it, then join the leftover elements together, for example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
in generating...
in generating repo





in generating repo








in generating repo







in generating repo





in generating repo








in generating repo








in generating repo








in generating repo









in generating repo








in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, True, False, False, True, True, True, True, False]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 49------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:32
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers adhere to a certain structure: a positive integer x with p zeros attached to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Analyze the format carefully in order to determine which of the two numbers is larger, or if they are equal.

--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers adhere to a certain structure. This structure is a positive integer x with p zeros attached to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Analyze the format carefully in order to determine which of the two numbers is larger, or if they are equal.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Monocarp asks you to compare two numbers that adhere to a specific structure, consisting of a positive integer x with p zeros at the end. Analyze the format carefully to determine the relative size of these numbers or if they are equal. Can you assist Monocarp with this task?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard, both adhering to a structure of a positive integer x with p zeros attached to its end. Now Monocarp asks you to compare these two numbers and analyze the format carefully to determine which of the two numbers is larger, or if they are equal.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
in generating...
in generating repo





in generating repo





in generating repo








in generating repo





in generating repo





in generating repo





in generating repo






in generating repo






in generating repo






in generating repo






in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_49_6/codecontest_49_6
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_49_8/codecontest_49_8
evaluating ...
[True, True, True, True, True, True, True, True, True, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 50------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False]
current seed index:47
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
The robot is positioned on a checkered rectangular board with dimensions n × m (n rows, m columns), where rows are numbered from 1 to n top to bottom and columns are numbered from 1 to m left to right. The robot is able to move from the current cell to one of the four cells adjacent by side, which are only the ones directly to the left, right, above, or below the current cell.

Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively. The robot can start its movement in any cell, then moves to the adjacent square in the direction indicated on the current square in one move.

  * If the robot surpasses the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 

Robot can choose any cell as the starting cell, and its goal is to make the maximum number of steps before it breaks or stops.

Decide from which square the robot should begin its movement in order to carry out the most commands possible. A command is considered successfully executed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

--------------------------------------------------
The robot is placed on a checkered rectangular board with size n × m (n rows, m columns), with rows numbered from 1 to n top to bottom and columns numbered from 1 to m left to right. The robot can move from its current spot to one of the four adjacent cells by side, which are only the ones directly to the left, right, above, or below its current spot.

Each cell has one of the symbols 'L', 'R', 'D' or 'U' on it, indicating the direction in which the robot will move when it reaches that cell — left, right, down or up, respectively. The robot can initiate its movement in any cell, then makes a move to the neighboring square in the direction shown on the current square in one move.

  * If the robot crosses over the edge of the board, it falls and breaks. 
  * If the robot ends up in the cell it already passed through before, it breaks (it ceases and doesn't move anymore). 

Robot can pick any cell as the starting cell, and its objective is to make the maximum number of steps before it breaks or stops.

Determine from which square the robot should commence its movement in order to execute the maximum number of commands possible. A command is regarded as successfully executed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
The robot can initiate its movement in any cell, then makes a move to the neighboring square in the direction shown on the current square in one move. This allows the robot to pick any cell as the starting cell to maximize the number of steps before breaking or stopping. 

The robot is placed on a checkered rectangular board with size n × m (n rows, m columns), with rows numbered from 1 to n top to bottom and columns numbered from 1 to m left to right. The robot can move from its current spot to one of the four adjacent cells by side, which are only the ones directly to the left, right, above, or below its current spot.

Each cell has one of the symbols 'L', 'R', 'D' or 'U' on it, indicating the direction in which the robot will move when it reaches that cell — left, right, down or up, respectively. The robot can initiate its movement in any cell, then makes a move to the neighboring square in the direction shown on the current square in one move.

If the robot crosses over the edge of the board, it falls and breaks. If the robot ends up in the cell it already passed through before, it breaks (it ceases and doesn't move anymore). 

Robot can pick any cell as the starting cell, and its objective is to make the maximum number of steps before it breaks or stops. Determine from which square the robot should commence its movement in order to execute the maximum number of commands possible. A command is regarded as successfully executed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
multi-gen-prompt:
The robot is placed on a checkered rectangular board with size n × m (n rows, m columns) and can move to one of the four adjacent cells by side, each with a symbol indicating the direction of movement. Determine the starting square for the robot to maximize the number of successful commands executed.

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo









in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, True, False, True, False, True, False, True]
True
----------updating----------
analyst reward: 0.14637529850006104
final_output reward: 0
total reward: 0.14637529850006104
add mutated seed into prompt node list
seed_index: 47
mutated_seed_index: 51
reward = 0.14637529850006104
saving......
----------------------------------------round: 51------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:0
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7!

--------------------------------------------------
Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a modulo 10^9 + 7 and output the result!

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek needs assistance in determining the prettiness value for his array, which is calculated by summing the product of the greatest common divisor of elements and their indices. Find the prettiness value of array a modulo 10^9 + 7 and provide the output to Mr. Chanek.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
Mr. Chanek has an array a of n integers, and the prettiness value of a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j). Help Mr. Chanek find the prettiness value of a modulo 10^9 + 7 and output the result!

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo





in generating repo





in generating repo





in generating repo








in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, False, False, True, False, False, False]
True
----------updating----------
analyst reward: 0.2268015742301941
final_output reward: 0.6
total reward: 0.8268015742301941
add mutated seed into prompt node list
seed_index: 0
mutated_seed_index: 52
reward = 0.8268015742301941
saving......
in recording...
len prompt_nodes
53
initial_seed_num
13
[False, False, True, False, True, True, True, False, False, True, False, True, False]
total pass@10:7
------------------------------
saving result into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_final_result.jsonl
------------------------------
saving original node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_original_node.jsonl
------------------------------
saving node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_node_51.jsonl
----------------------------------------round: 52------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:52
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a modulo 10^9 + 7 and output the result!

--------------------------------------------------
Mr. Chanek owns an array a consisting of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

In other words, the prettiness value of an array a is the cumulative sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek determine the prettiness value of a modulo 10^9 + 7 and output the result!

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek needs assistance to calculate the prettiness value of array a, which involves finding the sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for each pair (i, j), and then taking the sum modulo 10^9 + 7 before returning the result.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
Mr. Chanek needs help determining the prettiness value of array a modulo 10^9 + 7, which is the cumulative sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo





in generating repo








in generating repo





in generating repo





in generating repo







in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, True, False, False, True, True, False, False]
True
----------updating----------
analyst reward: 0.12099385261535645
final_output reward: 0
total reward: 0.12099385261535645
add mutated seed into prompt node list
seed_index: 52
mutated_seed_index: 53
reward = 0.12099385261535645
saving......
----------------------------------------round: 53------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:50
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You have an array of integers (initially empty). You have to perform q queries where each query is of one of two types: 

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 

Find the resulting array after performing all the queries.

--------------------------------------------------
You have an array of integers (initially empty). Each query is of one of two types: "1 x" — add the element x to the end of the array, and "2 x y" — replace all occurrences of x in the array with y. Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
You have an array of integers (initially empty). Each query is of one of two types: "1 x" — add the element x to the end of the array, and "2 x y" — replace all occurrences of x in the array with y. Find the resulting array after adding elements and replacing occurrences as specified.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
You have an array of integers (initially empty), with queries in two types: "1 x" to add x to the end, and "2 x y" to replace all occurrences of x with y. Find the resulting array after all queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
in generating...
in generating repo





in generating repo





in generating repo






in generating repo





in generating repo








in generating repo








in generating repo





in generating repo








in generating repo





in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, True, True, True, True, True, False, True, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 54------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:46
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider both even and odd values for the number of songs to find the optimal solution.

--------------------------------------------------
Luntik has chosen to attempt singing. He has a total of one-minute songs denoted by a, two-minute songs denoted by b, and three-minute songs denoted by c. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider both even and odd values for the number of songs to find the optimal solution.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Luntik wants to distribute all songs into two concerts in a way that ensures every song is included in exactly one concert. He aims to minimize the absolute difference of durations between the two concerts by strategically allocating his one-minute, two-minute, and three-minute songs. Please help Luntik find the smallest possible gap in minutes between the durations of the two concerts, considering both even and odd values for the number of songs to achieve the best solution.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
Luntik wants to distribute all songs into two concerts such that every song should be included to exactly one concert, making the absolute difference of durations of the concerts as small as possible. Please find the minimal possible difference in minutes between the concerts durations considering both even and odd values for the number of songs to find the optimal solution.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
in generating...
in generating repo





in generating repo






in generating repo






in generating repo





in generating repo






in generating repo





in generating repo






in generating repo









in generating repo






in generating repo









in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, False, True, False, False, False, False]
True
----------updating----------
analyst reward: 0
final_output reward: 0.3
total reward: 0.3
add mutated seed into prompt node list
seed_index: 46
mutated_seed_index: 54
reward = 0.3
saving......
----------------------------------------round: 55------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:53
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Mr. Chanek owns an array a consisting of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

In other words, the prettiness value of an array a is the cumulative sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek determine the prettiness value of a modulo 10^9 + 7 and output the result!

--------------------------------------------------
Mr. Chanek owns an array a consisting of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

In other words, the prettiness value of an array a is the cumulative sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek determine the prettiness value of a modulo 10^9 + 7 and output the result! Assume that the array indices are 1-based when calculating the formula.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek owns an array a consisting of n integers. The prettiness value of a is calculated by summing the products of the greatest common divisor of elements a_i and a_j, with the greatest common divisor of their respective indices i and j. 

Help Mr. Chanek determine the prettiness value of a modulo 10^9 + 7 and output the result! Assume that the array indices are 1-based when calculating the formula.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
Mr. Chanek needs help in determining the prettiness value of an array a modulo 10^9 + 7 and output the result!

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo





in generating repo








in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, True, False, False, False, True, True]
True
----------updating----------
analyst reward: 0.1398625373840332
final_output reward: 0
total reward: 0.1398625373840332
add mutated seed into prompt node list
seed_index: 53
mutated_seed_index: 55
reward = 0.1398625373840332
saving......
----------------------------------------round: 56------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:23
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
A string is termed square if it is a sequence repeated two times consecutively. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

--------------------------------------------------
A string is termed square if it is a sequence repeated twice consecutively; for example, the strings "aa", "abcabc", "abab" and "baabaa" are square, but the strings "aaa", "abaaab" and "abcdabc" are not square. For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
A string is termed square if it is a sequence repeated twice consecutively; for example, the strings "aa", "abcabc", "abab" and "baabaa" are square, but the strings "aaa", "abaaab" and "abcdabc" are not square. Determine if a given string s is square by checking if it repeats consecutively in the input.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
A string is termed square if it is a sequence repeated twice consecutively, determine if a given string is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
in generating...
in generating repo









in generating repo





in generating repo






in generating repo








in generating repo





in generating repo






in generating repo






in generating repo






in generating repo












in generating repo










in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_56_0/codecontest_56_0
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_56_2/codecontest_56_2
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_56_3/codecontest_56_3
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_56_4/codecontest_56_4
evaluating ...
[True, False, True, False, True, True, True, False, True, False]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 57------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:14
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i.

You can select an item from the present sequence and discard it, then join the leftover elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. 

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

--------------------------------------------------
Mr. Chanek provides you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i is equal to i.

You can select an item from the present sequence and discard it, then join the leftover elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You aim to eliminate certain elements from a to maximize f(a), using zero or more operations. Determine the maximum possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek provides you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i is equal to i. Let's aim to eliminate certain elements from a to maximize f(a), using zero or more operations by selecting an item from the present sequence, discarding it, and joining the leftover elements together. Determine the maximum possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
Mr. Chanek provides you a sequence a indexed from 1 to n where f(a) is the number of indices where a_i is equal to i. You aim to eliminate certain elements from a to maximize f(a), using zero or more operations. Determine the maximum possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo







in generating repo





in generating repo







in generating repo








in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, False, False, False, False, False, False, True, True]
True
----------updating----------
analyst reward: 0.14102238416671753
final_output reward: 0
total reward: 0.14102238416671753
add mutated seed into prompt node list
seed_index: 14
mutated_seed_index: 56
reward = 0.14102238416671753
saving......
----------------------------------------round: 58------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:20
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom. The columns are numbered from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively.

The robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. 

  * If the robot moves beyond the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 

Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.

Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

--------------------------------------------------
The automaton is situated on a checkered rectangular grid with dimensions n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom. The columns are numbered from 1 to m from left to right.

The robot can transition from its current position to one of the four neighboring cells by side.

Each cell is marked with one of the symbols 'L', 'R', 'D' or 'U', denoting the direction the robot will travel once it enters that cell — left, right, down or up, respectively.

The robot can commence its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. 

  * If the robot moves beyond the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 

Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.

Ascertain from which square the robot should initiate its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
The robot can commence its movement in any cell, then moves to the adjacent square in the direction indicated on the current square in one move. If the robot moves beyond the edge of the board, it falls and breaks.

The automaton is situated on a checkered rectangular grid with dimensions n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom. The columns are numbered from 1 to m from left to right. The robot can transition from its current position to one of the four neighboring cells by side. Each cell is marked with one of the symbols 'L', 'R', 'D' or 'U', denoting the direction the robot will travel once it enters that cell — left, right, down or up, respectively. If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops. Ascertain from which square the robot should initiate its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
multi-gen-prompt:
The automaton is situated on a checkered rectangular grid with dimensions n × m (n rows, m columns) and can transition from its current position to one of the four neighboring cells by side. The robot can choose any cell as the starting cell to make the maximum number of steps before it breaks or stops.

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo







in generating repo





in generating repo





in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, True, False, False, False, True, False, False, False, False]
True
----------updating----------
analyst reward: 0.18943434953689575
final_output reward: 0
total reward: 0.18943434953689575
add mutated seed into prompt node list
seed_index: 20
mutated_seed_index: 57
reward = 0.18943434953689575
saving......
----------------------------------------round: 59------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:49
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs, and he wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Luntik has a one-minute songs, b two-minute songs and c three-minute songs, and he wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. Please help Luntik and find the minimal possible difference in minutes between the concerts durations. For this task, you need to optimize the distribution of songs in order to minimize the difference in concert durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
Luntik has decided to try singing and wants to distribute all songs into two concerts, making the absolute difference of durations of the concerts as small as possible. Please help Luntik find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo







in generating repo






in generating repo






in generating repo









in generating repo









in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, False, False, False, True, False, False]
True
----------updating----------
analyst reward: 0.12293404340744019
final_output reward: 0.4
total reward: 0.5229340434074402
add mutated seed into prompt node list
seed_index: 49
mutated_seed_index: 58
reward = 0.5229340434074402
saving......
----------------------------------------round: 60------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:32
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers adhere to a certain structure: a positive integer x with p zeros attached to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Analyze the format carefully in order to determine which of the two numbers is larger, or if they are equal.

--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers adhere to a certain structure. One structure consists of a positive integer x with p zeros attached to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Analyze the format carefully in order to determine which of the two numbers is larger, or if they are equal.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard. Both numbers adhere to a certain structure. One structure consists of a positive integer x with p zeros attached to its end. Your task is to carefully analyze the format in order to determine which of the two numbers is larger, or if they are equal.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard, with one structure consisting of a positive integer x with p zeros attached to its end; now he asks you to compare these two numbers. Can you help him analyze the format in order to determine which of the two numbers is larger, or if they are equal?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo





in generating repo





in generating repo






in generating repo





in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, True, False, True, True, False, True, True, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 61------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:55
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Mr. Chanek owns an array a consisting of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

In other words, the prettiness value of an array a is the cumulative sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek determine the prettiness value of a modulo 10^9 + 7 and output the result! Assume that the array indices are 1-based when calculating the formula.

--------------------------------------------------
Mr. Chanek owns an array a consisting of n integers. The prettiness value of a is denoted as: $$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$. Help Mr. Chanek determine the prettiness value of a modulo 10^9 + 7 and output the result! Assume that the array indices are 1-based when calculating the formula.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek owns an array a consisting of n integers. The calculation involves determining the prettiness value of a modulo 10^9 + 7 by considering the greatest common divisors and array indices. Help Mr. Chanek with this task and output the result! Assume that the array indices are 1-based when calculating the formula.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
Mr. Chanek owns an array a consisting of n integers, and he needs help determining the prettiness value of a modulo 10^9 + 7 and outputting the result, with array indices being 1-based.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
in generating...
in generating repo





in generating repo





in generating repo





in generating repo








in generating repo








in generating repo








in generating repo








in generating repo








in generating repo





in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, False, True, False, False, False, False]
True
----------updating----------
analyst reward: 0.13268578052520752
final_output reward: 0.2
total reward: 0.33268578052520753
add mutated seed into prompt node list
seed_index: 55
mutated_seed_index: 59
reward = 0.33268578052520753
saving......
in recording...
len prompt_nodes
60
initial_seed_num
13
[False, False, True, False, True, True, True, False, False, True, False, True, False]
total pass@10:7
------------------------------
saving result into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_final_result.jsonl
------------------------------
saving original node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_original_node.jsonl
------------------------------
saving node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_node_61.jsonl
----------------------------------------round: 62------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:58
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs, and he wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Luntik wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
Luntik has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert, and wants to make the absolute difference of durations of the concerts as small as possible. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
in generating...
in generating repo





in generating repo





in generating repo






in generating repo





in generating repo








in generating repo





in generating repo





in generating repo










in generating repo





in generating repo









in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, False, False, True, True, False, False, False, False, True]
True
----------updating----------
analyst reward: 0.1020280122756958
final_output reward: 0
total reward: 0.1020280122756958
add mutated seed into prompt node list
seed_index: 58
mutated_seed_index: 60
reward = 0.1020280122756958
saving......
----------------------------------------round: 63------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:44
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You have an array of integers (initially empty). You have to perform q queries, and each query is of one of two types:

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. You have to find and replace every instance of x in the array. It is essential to substitute all occurrences with y.

Find the resulting array after performing all the queries.

--------------------------------------------------
You have an array of integers (initially empty). You have to perform q queries, and each query is of one of two types:

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y, ensuring every instance of x is substituted with y.

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
You have to perform q queries. Replace all occurrences of x in the array with y, ensuring every instance of x is substituted with y. 

You have an array of integers (initially empty). You have to perform q queries, and each query is of one of two types:

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y, ensuring every instance of x is substituted with y.

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
You have to perform q queries, and each query is of one of two types: "1 x" — add the element x to the end of the array; "2 x y" — replace all occurrences of x in the array with y, ensuring every instance of x is substituted with y. 

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo





in generating repo





in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, True, True, True, True, True, False, False, True, True]
True
----------updating----------
analyst reward: 0.11346149444580078
final_output reward: 0
total reward: 0.11346149444580078
add mutated seed into prompt node list
seed_index: 44
mutated_seed_index: 61
reward = 0.11346149444580078
saving......
----------------------------------------round: 64------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:59
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Mr. Chanek owns an array a consisting of n integers. The prettiness value of a is denoted as: $$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$. Help Mr. Chanek determine the prettiness value of a modulo 10^9 + 7 and output the result! Assume that the array indices are 1-based when calculating the formula.

--------------------------------------------------
Mr. Chanek owns an array a consisting of n integers. Help Mr. Chanek determine the prettiness value of $$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$ modulo 10^9 + 7 and output the result! Assume that the array indices are 1-based when calculating the formula.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek wants to determine the prettiness value of an array a by calculating the sum of gcd values multiplied by gcd of corresponding indices, and then output the result modulo 10^9 + 7!

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
Mr. Chanek needs assistance determining the prettiness value of the formula $$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$ modulo 10^9 + 7 and output the result!

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
in generating...
in generating repo





in generating repo





in generating repo





in generating repo









in generating repo








in generating repo








in generating repo








in generating repo






in generating repo






in generating repo






in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_64_0/codecontest_64_0
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_64_2/codecontest_64_2
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_64_9/codecontest_64_9
evaluating ...
[False, False, False, False, True, False, False, False, False, False]
True
----------updating----------
analyst reward: 0.1589028239250183
final_output reward: 0
total reward: 0.1589028239250183
add mutated seed into prompt node list
seed_index: 59
mutated_seed_index: 62
reward = 0.1589028239250183
saving......
----------------------------------------round: 65------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:56
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek provides you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i is equal to i.

You can select an item from the present sequence and discard it, then join the leftover elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You aim to eliminate certain elements from a to maximize f(a), using zero or more operations. Determine the maximum possible f(a).

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i.

You can select an item from the present sequence and discard it, then join the leftover elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You aim to eliminate certain elements from a to maximize f(a), using zero or more operations. Determine the greatest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i. If you remove an item from the sequence and join the remaining elements together, you can potentially increase the value of f(a). You aim to eliminate certain elements from a to maximize f(a), using zero or more operations. Determine the greatest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n where f(a) counts the indices where a_i equals i, and you aim to eliminate certain elements from a to maximize f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo






in generating repo








in generating repo








in generating repo








in generating repo








in generating repo







in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, False, False, True, True, False, False, True, True]
True
----------updating----------
analyst reward: 0.11331713199615479
final_output reward: 0
total reward: 0.11331713199615479
add mutated seed into prompt node list
seed_index: 56
mutated_seed_index: 63
reward = 0.11331713199615479
saving......
----------------------------------------round: 66------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:57
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
The automaton is situated on a checkered rectangular grid with dimensions n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom. The columns are numbered from 1 to m from left to right.

The robot can transition from its current position to one of the four neighboring cells by side.

Each cell is marked with one of the symbols 'L', 'R', 'D' or 'U', denoting the direction the robot will travel once it enters that cell — left, right, down or up, respectively.

The robot can commence its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. 

  * If the robot moves beyond the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 

Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.

Ascertain from which square the robot should initiate its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

--------------------------------------------------
The automaton is situated on a checkered rectangular grid with dimensions n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom. The columns are numbered from 1 to m from left to right.

The robot can transition from its current position to one of the four neighboring cells by side.

Each cell is marked with one of the symbols 'L', 'R', 'D' or 'U', denoting the direction the robot will travel once it enters that cell — left, right, down or up, respectively.

The robot can commence its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. 

  * If the robot moves beyond the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 

Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.

Ascertain from which square the robot should initiate its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board). The task is to find the starting cell that allows the robot to travel the longest path possible.

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
The robot can commence its movement in any cell, then moves to the adjacent square in the direction indicated on the current square in one move. If the robot moves beyond the edge of the board, it falls and breaks.

Each cell is marked with one of the symbols 'L', 'R', 'D' or 'U', denoting the direction the robot will travel once it enters that cell — left, right, down or up, respectively. If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 

Ascertain from which square the robot should initiate its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board). The task is to find the starting cell that allows the robot to travel the longest path possible.

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
multi-gen-prompt:
The automaton is situated on a checkered rectangular grid with dimensions n × m (n rows, m columns) and can transition to one of the four neighboring cells by side. The robot aims to find the starting cell that allows it to travel the longest path possible by following the directions marked on each cell with symbols 'L', 'R', 'D' or 'U'.

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo







in generating repo






in generating repo








in generating repo





in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, True, True, False, False, False, True, False]
True
----------updating----------
analyst reward: 0.16707515716552734
final_output reward: 0
total reward: 0.16707515716552734
add mutated seed into prompt node list
seed_index: 57
mutated_seed_index: 64
reward = 0.16707515716552734
saving......
----------------------------------------round: 67------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:23
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
A string is termed square if it is a sequence repeated two times consecutively. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

--------------------------------------------------
A string is termed square if it is a sequence repeated two times consecutively; for example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
A string is termed square if it is a sequence repeated two times consecutively; for example, the strings "aa", "abcabc", "abab" and "baabaa" are square. Take note that the strings "aaa", "abaaab" and "abcdabc" are not square. 

For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
A string is termed square if it is a sequence repeated two times consecutively; for example, the strings "aa", "abcabc", "abab" and "baabaa" are square, determine if a given string s is square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
in generating...
in generating repo





in generating repo





in generating repo








in generating repo








in generating repo








in generating repo








in generating repo






in generating repo













in generating repo













in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_67_1/codecontest_67_1
evaluating ...
[True, False, False, False, False, False, False, False, False, False]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 68------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:3
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

--------------------------------------------------
Luntik has decided to try singing. He possesses a songs that last one minute, b songs that last two minutes, and c songs that last three minutes. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
He wants to make the absolute difference of durations of the concerts as small as possible, which means he needs to distribute the songs evenly between the two concerts. The duration of the concert is the sum of durations of all songs in that concert, so he needs to balance the durations to minimize the difference.  

Luntik has decided to try singing. He possesses a songs that last one minute, b songs that last two minutes, and c songs that last three minutes. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
Luntik has decided to try singing and possesses songs that last one minute, b songs that last two minutes, and c songs that last three minutes, wanting to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo







in generating repo







in generating repo









in generating repo








in generating repo









in generating repo









in generating repo





in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, False, False, True, False, False, False]
True
----------updating----------
analyst reward: 0.27720504999160767
final_output reward: 0.2
total reward: 0.4772050499916077
add mutated seed into prompt node list
seed_index: 3
mutated_seed_index: 65
reward = 0.4772050499916077
saving......
----------------------------------------round: 69------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:65
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Luntik has decided to try singing. He possesses a songs that last one minute, b songs that last two minutes, and c songs that last three minutes. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

--------------------------------------------------
Luntik has decided to try singing. He has a songs that last one minute, b songs that last two minutes, and c songs that last three minutes. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Luntik wants to make the absolute difference of durations of the concerts as small as possible in order to distribute his songs. The duration of the concert is the sum of durations of all songs in that concert, and he needs to find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
Luntik has decided to try singing and wants to make the absolute difference of durations of the concerts as small as possible by distributing songs into two concerts. He has a songs that last one minute, b songs that last two minutes, and c songs that last three minutes, and wants to find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo






in generating repo







in generating repo









in generating repo









in generating repo









in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, False, False, True, False, False, True]
True
----------updating----------
analyst reward: 0.15218710899353027
final_output reward: 0
total reward: 0.15218710899353027
add mutated seed into prompt node list
seed_index: 65
mutated_seed_index: 66
reward = 0.15218710899353027
saving......
----------------------------------------round: 70------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:32
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers adhere to a certain structure: a positive integer x with p zeros attached to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Analyze the format carefully in order to determine which of the two numbers is larger, or if they are equal.

--------------------------------------------------
Monocarp jotted down a pair of numbers on a whiteboard. Both numbers adhere to a certain structure: a positive integer x with p zeros appended to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Analyze the format carefully in order to determine which of the two numbers is larger, or if they are equal.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Monocarp jotted down a pair of numbers on a whiteboard. Both numbers adhere to a certain structure: a positive integer x with p zeros appended to its end. Make sure to carefully analyze the format to determine which of the two numbers is larger, or if they are equal.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
Monocarp jotted down a pair of numbers on a whiteboard, both adhering to a certain structure: a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers and analyze the format carefully to determine which is larger, or if they are equal.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo






in generating repo






in generating repo








in generating repo








in generating repo











in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, True, True, True, True, True, True, False, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 71------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:55
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Mr. Chanek owns an array a consisting of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

In other words, the prettiness value of an array a is the cumulative sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek determine the prettiness value of a modulo 10^9 + 7 and output the result! Assume that the array indices are 1-based when calculating the formula.

--------------------------------------------------
Mr. Chanek owns an array a consisting of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

In other words, the prettiness value of an array a is the cumulative sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j). The value \gcd(a_i, a_j) represents the greatest common divisor of the elements a_i and a_j. Similarly, \gcd(i, j) stands for the greatest common divisor of the indices i and j.

Help Mr. Chanek determine the prettiness value of a modulo 10^9 + 7 and output the result! Assume that the array indices are 1-based when calculating the formula.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
The prettiness value of an array a is calculated by summing the products of greatest common divisors of its elements with the greatest common divisors of their indices. This results in a cumulative sum that represents the overall prettiness of the array.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
Mr. Chanek owns an array a consisting of n integers and needs help determining the prettiness value of a modulo 10^9 + 7.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo






in generating repo






in generating repo





in generating repo







in generating repo








in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, False, True, False, True, False, False, True, False, False]
True
----------updating----------
analyst reward: 0.11865752935409546
final_output reward: 0
total reward: 0.11865752935409546
add mutated seed into prompt node list
seed_index: 55
mutated_seed_index: 67
reward = 0.11865752935409546
saving......
in recording...
len prompt_nodes
68
initial_seed_num
13
[False, False, True, False, True, True, True, False, False, True, False, True, False]
total pass@10:7
------------------------------
saving result into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_final_result.jsonl
------------------------------
saving original node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_original_node.jsonl
------------------------------
saving node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_node_71.jsonl
----------------------------------------round: 72------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:64
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
The automaton is situated on a checkered rectangular grid with dimensions n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom. The columns are numbered from 1 to m from left to right.

The robot can transition from its current position to one of the four neighboring cells by side.

Each cell is marked with one of the symbols 'L', 'R', 'D' or 'U', denoting the direction the robot will travel once it enters that cell — left, right, down or up, respectively.

The robot can commence its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. 

  * If the robot moves beyond the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 

Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.

Ascertain from which square the robot should initiate its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board). The task is to find the starting cell that allows the robot to travel the longest path possible.

--------------------------------------------------
The automaton is situated on a checkered rectangular grid with dimensions n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom. The columns are numbered from 1 to m from left to right.

The robot can transition from its current position to one of the four neighboring cells by side.

Each cell is marked with one of the symbols 'L', 'R', 'D' or 'U', denoting the direction the robot will travel once it enters that cell — left, right, down or up, respectively.

The robot can commence its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. 

  * If the robot moves beyond the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 

Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.

Ascertain from which square the robot should initiate its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board). The task is to find the starting cell that allows the robot to travel the longest path possible. Carefully consider edge cases, such as one or more rows or columns, when devising your solution.

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
The robot can commence its movement in any cell, then moves to the adjacent square in the direction indicated on the current square in one move. If the robot moves beyond the edge of the board, it falls and breaks.

The automaton is situated on a checkered rectangular grid with dimensions n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom. The columns are numbered from 1 to m from left to right. 

The robot can transition from its current position to one of the four neighboring cells by side. Each cell is marked with one of the symbols 'L', 'R', 'D' or 'U', denoting the direction the robot will travel once it enters that cell — left, right, down or up, respectively. If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops. Ascertain from which square the robot should initiate its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board). The task is to find the starting cell that allows the robot to travel the longest path possible. Carefully consider edge cases, such as one or more rows or columns, when devising your solution.

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
multi-gen-prompt:
The automaton is situated on a checkered rectangular grid with dimensions n × m (n rows, m columns) numbered from 1 to n from top to bottom and from 1 to m from left to right, and can transition to neighboring cells marked with 'L', 'R', 'D' or 'U' symbols for left, right, down or up directions. The robot aims to start from a square to travel the longest path without falling or visiting the same cell twice.

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
in generating...
in generating repo





in generating repo





in generating repo







in generating repo






in generating repo








in generating repo





in generating repo






in generating repo








in generating repo





in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, False, False, False, False, False, False]
False
----------updating----------
seed 64 finish fuzzing!
seed_index: 64
mutated_seed_index: 68
current seed length: 6
saving......
----------------------------------------round: 73------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:63
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i.

You can select an item from the present sequence and discard it, then join the leftover elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You aim to eliminate certain elements from a to maximize f(a), using zero or more operations. Determine the greatest possible f(a).

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i. You can select an item from the present sequence and discard it, then join the leftover elements together; for example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You aim to eliminate certain elements from a to maximize f(a), using zero or more operations. Determine the greatest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i. If you remove an element from the sequence and join the remaining ones, you can potentially increase the value of f(a). You aim to eliminate certain elements from a to maximize f(a), determine the greatest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n and defines f(a) as the count of indices where a_i equals i, aiming to eliminate certain elements from a to maximize f(a). You can select an item from the present sequence and discard it, then join the leftover elements together.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo









in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, True, False, True, False, True, False, False, False]
True
----------updating----------
analyst reward: 0
final_output reward: 0.3
total reward: 0.3
add mutated seed into prompt node list
seed_index: 63
mutated_seed_index: 69
reward = 0.3
saving......
----------------------------------------round: 74------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:25
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You have an array of integers (initially empty). You have to perform q queries, and each query is of one of two types: 

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 

Find the resulting array after performing all the queries.

--------------------------------------------------
You have an array of integers (initially empty). You have to perform q queries, and each query is of one of two types: 

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 

Find the resulting array after performing all the queries. Ensure to handle edge cases such as empty arrays and overlapping values for replacement efficiently.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Find the resulting array after performing all the queries, ensuring to handle edge cases like empty arrays and efficiently replacing overlapping values for replacement.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
You have an array of integers (initially empty) and you have to perform q queries, either adding elements to the end or replacing occurrences of a value. Find the resulting array after performing all the queries, considering edge cases efficiently.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
in generating...
in generating repo





in generating repo









in generating repo








in generating repo





in generating repo








in generating repo









in generating repo








in generating repo








in generating repo







in generating repo









in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, True, False, False, False, True, False, False]
True
----------updating----------
analyst reward: 0
final_output reward: 0.6
total reward: 0.6
add mutated seed into prompt node list
seed_index: 25
mutated_seed_index: 70
reward = 0.6
saving......
----------------------------------------round: 75------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:12
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You have an array of integers (initially empty).

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 



Find the resulting array after performing all the queries.

--------------------------------------------------
You have an array of integers (initially empty).

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array. The element you add should be x.
  * "2 x y" — replace all occurrences of x in the array with y. 



Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
You have to perform q queries. Each query is of one of two types: The element you add should be x, "1 x" — add the element x to the end of the array.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
You have to perform q queries, with "1 x" adding x to the end of the array and "2 x y" replacing all occurrences of x with y. 

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
in generating...
in generating repo





in generating repo





in generating repo





in generating repo







in generating repo








in generating repo








in generating repo








in generating repo







in generating repo








in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, True, True, True, True, False, True, True, True]
True
----------updating----------
analyst reward: 0.18135643005371094
final_output reward: 0
total reward: 0.18135643005371094
add mutated seed into prompt node list
seed_index: 12
mutated_seed_index: 71
reward = 0.18135643005371094
saving......
----------------------------------------round: 76------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:66
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Luntik has decided to try singing. He has a songs that last one minute, b songs that last two minutes, and c songs that last three minutes. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

--------------------------------------------------
Luntik has decided to try singing. He has a songs that last one minute, b songs that last two minutes, and c songs that last three minutes. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider edge cases where there are significantly more songs of one duration than others.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Luntik wants to distribute all his songs into two concerts with minimal duration difference. The duration of each concert is the sum of all song durations, aiming for a balance in distribution. Find the minimum possible difference in minutes between the concerts' durations, even when one song duration is more frequent than others.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
Luntik has songs of different durations and wants to distribute them into two concerts to minimize the absolute difference in duration between them. Find the minimal possible difference in minutes between the concerts' durations. Consider edge cases with significantly more songs of one duration.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
in generating...
in generating repo





in generating repo






in generating repo





in generating repo








in generating repo






in generating repo









in generating repo





in generating repo








in generating repo






in generating repo






in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, True, False, False, False, False, True]
True
----------updating----------
analyst reward: 0.1402420997619629
final_output reward: 0
total reward: 0.1402420997619629
add mutated seed into prompt node list
seed_index: 66
mutated_seed_index: 72
reward = 0.1402420997619629
saving......
----------------------------------------round: 77------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:71
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You have an array of integers (initially empty).

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array. The element you add should be x.
  * "2 x y" — replace all occurrences of x in the array with y. 



Find the resulting array after performing all the queries.

--------------------------------------------------
You possess a list of integers that starts empty.

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — append the element x to the end of the array. The element you add should be x.
  * "2 x y" — substitute all instances of x in the array with y. 

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
You possess a list of integers that starts empty. As you perform q queries, remember that each query is of one of two types. 

  * "1 x" — append the element x to the end of the array. The element you add should be x.
  * "2 x y" — substitute all instances of x in the array with y. 

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
You possess a list of integers that starts empty and have to perform q queries, with each query being of one of the two types: "1 x" to append x to the end of the array or "2 x y" to substitute all instances of x with y. Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo






in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, False, True, False, True, True, True, False, True, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 78------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:27
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Mr. Chanek possesses a collection of n numbers in array a. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

Put differently, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this efficiently for large input sizes.

--------------------------------------------------
Mr. Chanek possesses a collection of n numbers in array a. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

Put differently, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this efficiently for large input sizes. Ensure that your implementation handles edge cases gracefully to maintain robustness.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek needs assistance to determine the prettiness value of array a, which involves calculating the sum of the GCD of pairs of elements multiplied by the GCD of their respective indices. It is crucial to create a solution that efficiently handles large input sizes and edge cases, ensuring the output is modulo 10^9 + 7.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
Mr. Chanek needs help to find the prettiness value of array a efficiently and output the result modulo 10^9 + 7, considering all pairs (i, j) in the array.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
in generating...
in generating repo





in generating repo





in generating repo





in generating repo







in generating repo





in generating repo








in generating repo





in generating repo








in generating repo








in generating repo






in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_78_5/codecontest_78_5
evaluating ...
[False, False, False, False, False, True, False, False, False, False]
True
----------updating----------
analyst reward: 0.15100359916687012
final_output reward: 0
total reward: 0.15100359916687012
add mutated seed into prompt node list
seed_index: 27
mutated_seed_index: 73
reward = 0.15100359916687012
saving......
----------------------------------------round: 79------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:23
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
A string is termed square if it is a sequence repeated two times consecutively. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

--------------------------------------------------
A string is considered square if it is a sequence repeated twice in a row. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
A string is considered square if it is a sequence repeated twice in a row. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square. Determine if a given string s is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
A string is considered square if it is a sequence repeated twice in a row, determine if a given string s is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
in generating...
in generating repo





in generating repo





in generating repo





in generating repo






in generating repo








in generating repo






in generating repo






in generating repo






in generating repo






in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_79_0/codecontest_79_0
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_79_1/codecontest_79_1
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_79_2/codecontest_79_2
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_79_5/codecontest_79_5
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_79_9/codecontest_79_9
evaluating ...
[False, True, True, True, True, True, True, True, False, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 80------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:14
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i.

You can select an item from the present sequence and discard it, then join the leftover elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. 

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i.

You can select an item from the present sequence and discard it, then join the leftover elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. 

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). Consider various sequences to identify patterns that help in maximizing f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of indices where a_i equals i. For instance, if a_3 equals 3 in the sequence [4, 2, 3, 1], it contributes to f(a).

You can select an item from the present sequence and discard it, then join the leftover elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. 

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). Consider various sequences to identify patterns that help in maximizing f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n where you can select an item from the present sequence and discard it, then join the leftover elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. 

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). Consider various sequences to identify patterns that help in maximizing f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
in generating...
in generating repo





in generating repo








in generating repo








in generating repo






in generating repo








in generating repo









in generating repo






in generating repo








in generating repo








in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, False, False, False, True, False, True, True, True, True]
True
----------updating----------
analyst reward: 0.12597441673278809
final_output reward: 0
total reward: 0.12597441673278809
add mutated seed into prompt node list
seed_index: 14
mutated_seed_index: 74
reward = 0.12597441673278809
saving......
----------------------------------------round: 81------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:72
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Luntik has decided to try singing. He has a songs that last one minute, b songs that last two minutes, and c songs that last three minutes. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider edge cases where there are significantly more songs of one duration than others.

--------------------------------------------------
Luntik has decided to try singing. He has a songs that last one minute, b songs that last two minutes, and c songs that last three minutes. He wants to distribute all songs into two concerts. Each concert should include every song in such a way that every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider edge cases where there are significantly more songs of one duration than others.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Luntik, who has songs of varying lengths, wants to divide them into two concerts with minimal duration difference. The goal is to ensure each concert includes every song exactly once to achieve this balance. What is the smallest possible gap in minutes between the durations of the two concerts, especially when one song duration is more abundant than the others?

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
Luntik wants to distribute his songs into two concerts, aiming for the smallest possible difference in total duration between the concerts, considering the different durations of his songs. Please help Luntik find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
in generating...
in generating repo





in generating repo





in generating repo






in generating repo





in generating repo







in generating repo





in generating repo





in generating repo





in generating repo





in generating repo









in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, True, False, False, False, False, False, False, False]
True
----------updating----------
analyst reward: 0.11025577783584595
final_output reward: 0.1
total reward: 0.21025577783584595
add mutated seed into prompt node list
seed_index: 72
mutated_seed_index: 75
reward = 0.21025577783584595
saving......
in recording...
len prompt_nodes
76
initial_seed_num
13
[False, False, True, False, True, True, True, True, False, True, False, True, False]
total pass@10:6
------------------------------
saving result into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_final_result.jsonl
------------------------------
saving original node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_original_node.jsonl
------------------------------
saving node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_node_81.jsonl
----------------------------------------round: 82------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:32
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers adhere to a certain structure: a positive integer x with p zeros attached to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Analyze the format carefully in order to determine which of the two numbers is larger, or if they are equal.

--------------------------------------------------
Monocarp noted a couple of numbers on a whiteboard. Both numbers adhere to a certain structure: a positive integer x with p zeros attached to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Scrutinize the format meticulously to determine which of the two numbers is larger, or if they are equal.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Monocarp noted a couple of numbers on a whiteboard. Both numbers adhere to a certain structure: a positive integer x with p zeros attached to its end. 
Now Monocarp asks you to compare these two numbers. Can you help him? Scrutinize the format meticulously to determine which of the two numbers is larger, or if they are equal. One key aspect to focus on is whether the length of the numbers affect their comparison.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
Monocarp noted a couple of numbers on a whiteboard, where one number is a positive integer x with p zeros attached to its end. Now Monocarp asks you to compare these two numbers and determine which is larger, or if they are equal. Can you help him scrutinize the format meticulously?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo








in generating repo





in generating repo





in generating repo









in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, True, True, True, True, True, True, True, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 83------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:67
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek owns an array a consisting of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

In other words, the prettiness value of an array a is the cumulative sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j). The value \gcd(a_i, a_j) represents the greatest common divisor of the elements a_i and a_j. Similarly, \gcd(i, j) stands for the greatest common divisor of the indices i and j.

Help Mr. Chanek determine the prettiness value of a modulo 10^9 + 7 and output the result! Assume that the array indices are 1-based when calculating the formula.

--------------------------------------------------
Mr. Chanek possesses a sequence a made up of n integers. The prettiness value of a is given as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

Essentially, the prettiness value of array a is the aggregate of \gcd(a_i, a_j) ⋅ \gcd(i, j) for every pair (i, j). The value \gcd(a_i, a_j) signifies the highest common divisor of the elements a_i and a_j. Likewise, \gcd(i, j) denotes the greatest common divisor of the indices i and j.

Help Mr. Chanek determine the prettiness value of a modulo 10^9 + 7 and output the result! Assume that the array indices are 1-based when calculating the formula.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Essentially, the prettiness value of array a is the aggregate of \gcd(a_i, a_j) ⋅ \gcd(i, j) for every pair (i, j). This value signifies the highest common divisor of the elements a_i and a_j, and \gcd(i, j) denotes the greatest common divisor of the indices i and j.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
Mr. Chanek needs help in determining the prettiness value of array a modulo 10^9 + 7 by aggregating \gcd(a_i, a_j) ⋅ \gcd(i, j) for every pair (i, j).

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo








in generating repo








in generating repo








in generating repo









in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, True, False, False, False, False, False, True, False]
True
----------updating----------
analyst reward: 0.13025039434432983
final_output reward: 0.2
total reward: 0.33025039434432985
add mutated seed into prompt node list
seed_index: 67
mutated_seed_index: 76
reward = 0.33025039434432985
saving......
----------------------------------------round: 84------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:1
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i. 

You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. 

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i.

You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). Consider all possible removals to achieve this goal.


Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i. Choose an element from the sequence, remove it, then join the remaining elements to maximize f(a) by considering all possible removals.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n, define f(a) as the number of indices where a_i = i. You can pick an element from the current sequence and remove it, then concatenate the remaining elements together to remove some elements from a in order to maximize f(a). Find the largest possible f(a). Consider all possible removals to achieve this goal.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo







in generating repo





in generating repo








in generating repo








in generating repo








in generating repo








in generating repo





in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, True, True, True, True, False, False, False, True, True]
True
----------updating----------
analyst reward: 0.2642543315887451
final_output reward: 0.3
total reward: 0.5642543315887452
add mutated seed into prompt node list
seed_index: 1
mutated_seed_index: 77
reward = 0.5642543315887452
saving......
----------------------------------------round: 85------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:77
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i.

You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). Consider all possible removals to achieve this goal.


--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. You are required to define f(a) as the number of indices where a_i equals i. 

You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. You need to find the largest possible f(a). Consider all possible removals to achieve this goal.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n. You are required to define f(a) as the number of indices where a_i equals i. 

If you pick an element from the current sequence and remove it, then concatenate the remaining elements together, the resulting sequence may change. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. You need to find the largest possible f(a). Consider all possible removals to achieve this goal.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n and you are required to define f(a) as the number of indices where a_i equals i. You can pick an element from the current sequence, remove it, then concatenate the remaining elements together to maximize f(a). Consider all possible removals to achieve this goal.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
in generating...
in generating repo





in generating repo








in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo








in generating repo









in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, False, False, False, True, False, True, True, True, True]
True
----------updating----------
analyst reward: 0.15914702415466309
final_output reward: 0
total reward: 0.15914702415466309
add mutated seed into prompt node list
seed_index: 77
mutated_seed_index: 78
reward = 0.15914702415466309
saving......
----------------------------------------round: 86------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:71
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You have an array of integers (initially empty).

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array. The element you add should be x.
  * "2 x y" — replace all occurrences of x in the array with y. 



Find the resulting array after performing all the queries.

--------------------------------------------------
You have an array of integers (initially empty).

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array. The element you add should be x.
  * "2 x y" — replace all occurrences of x in the array with y. 
  
Make sure to handle large inputs efficiently as the number of queries can be substantial.

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Make sure to efficiently handle large inputs as the number of queries can be substantial. The resulting array should be found after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
You have to perform q queries, each query is of one of two types: "1 x" — add the element x to the end of the array and "2 x y" — replace all occurrences of x in the array with y. Make sure to handle large inputs efficiently as the number of queries can be substantial. 

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, True, True, False, True, True, True, False, False]
True
----------updating----------
analyst reward: 0
final_output reward: 0.2
total reward: 0.2
add mutated seed into prompt node list
seed_index: 71
mutated_seed_index: 79
reward = 0.2
saving......
----------------------------------------round: 87------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:54
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Luntik has chosen to attempt singing. He has a total of one-minute songs denoted by a, two-minute songs denoted by b, and three-minute songs denoted by c. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider both even and odd values for the number of songs to find the optimal solution.

--------------------------------------------------
Luntik has chosen to attempt singing. He has a total of one-minute songs denoted by a, two-minute songs denoted by b, and three-minute songs denoted by c. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He desires to minimize the difference in lengths of the concerts as much as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider both even and odd values for the number of songs to find the optimal solution.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Luntik desires to minimize the difference in lengths of the concerts by distributing his one-minute, two-minute, and three-minute songs into two concerts. The optimal solution should consider both even and odd values for the number of songs to find the minimal possible difference in minutes between the concerts durations. 
What is the minimal possible difference in minutes between the concerts durations after distributing the songs? Luntik needs your help!

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
Luntik wants to distribute all songs into two concerts such that every song should be included to exactly one concert, minimizing the difference in lengths of the concerts as much as possible.  He desires to find the minimal possible difference in minutes between the concerts durations. Consider both even and odd values for the number of songs to find the optimal solution.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
in generating...
in generating repo





in generating repo






in generating repo






in generating repo







in generating repo








in generating repo






in generating repo








in generating repo





in generating repo








in generating repo









in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, False, False, True, False, True, True, True, False]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 88------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:78
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. You are required to define f(a) as the number of indices where a_i equals i. 

You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. You need to find the largest possible f(a). Consider all possible removals to achieve this goal.

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. You need to define f(a) as the count of positions where a_i equals i. 

You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. You need to find the largest possible f(a). Consider all possible removals to achieve this goal.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n. You need to define f(a) as the count of positions where a_i equals i. For example, if a = [3, 2, 1], then f(a) = 1 because a_3 = 3.

You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For instance, removing the 2-nd element from [5, 2, 1, 4] results in [5, 1, 4].  You want to remove some elements from a in order to maximize f(a), using zero or more operations. You need to find the largest possible f(a). Consider all possible removals to achieve this goal.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n, and you need to define f(a) as the count of positions where a_i equals i. You want to maximize f(a) by removing some elements from a, considering all possible removals to achieve this goal.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo







in generating repo







in generating repo









in generating repo





in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, True, True, True, False, False, False, True, False]
True
----------updating----------
analyst reward: 0.17007112503051758
final_output reward: 0.2
total reward: 0.3700711250305176
add mutated seed into prompt node list
seed_index: 78
mutated_seed_index: 80
reward = 0.3700711250305176
saving......
----------------------------------------round: 89------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False]
current seed index:76
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek possesses a sequence a made up of n integers. The prettiness value of a is given as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

Essentially, the prettiness value of array a is the aggregate of \gcd(a_i, a_j) ⋅ \gcd(i, j) for every pair (i, j). The value \gcd(a_i, a_j) signifies the highest common divisor of the elements a_i and a_j. Likewise, \gcd(i, j) denotes the greatest common divisor of the indices i and j.

Help Mr. Chanek determine the prettiness value of a modulo 10^9 + 7 and output the result! Assume that the array indices are 1-based when calculating the formula.

--------------------------------------------------
Mr. Chanek possesses a sequence a made up of n integers. The prettiness value of a is given as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

Essentially, the prettiness value of array a is the sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for every pair (i, j). The value \gcd(a_i, a_j) signifies the highest common divisor of the elements a_i and a_j. Likewise, \gcd(i, j) denotes the greatest common divisor of the indices i and j.

Help Mr. Chanek find the prettiness value of a modulo 10^9 + 7 and output the result! Assume that the array indices are 1-based when calculating the formula.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Help Mr. Chanek determine the prettiness value of array a by calculating the sum of the product of highest common divisors of elements and indices in pairs. The value of the prettiness of array a is essentially the sum of these products.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
Mr. Chanek needs help to find the prettiness value of array a, which is the sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for every pair (i, j), modulo 10^9 + 7.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
in generating...
in generating repo





in generating repo





in generating repo







in generating repo








in generating repo





in generating repo





in generating repo








in generating repo





in generating repo








in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, True, False, False, False, False, False]
True
----------updating----------
analyst reward: 0.11295318603515625
final_output reward: 0.1
total reward: 0.21295318603515626
add mutated seed into prompt node list
seed_index: 76
mutated_seed_index: 81
reward = 0.21295318603515626
saving......
----------------------------------------round: 90------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:23
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
A string is termed square if it is a sequence repeated two times consecutively. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

--------------------------------------------------
A string is termed square if it is a sequence repeated two times consecutively. It must be noted that the sequence is exactly repeated. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
A string is termed square if it is a sequence repeated two times consecutively, without any variations in the repetition. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square, but "aaa", "abaaab" and "abcdabc" do not fit this pattern. 

For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
A string is termed square if it is a sequence repeated two times consecutively exactly. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square; but the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
in generating...
in generating repo





in generating repo








in generating repo






in generating repo





in generating repo





in generating repo





in generating repo






in generating repo






in generating repo






in generating repo









in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_90_3/codecontest_90_3
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_90_5/codecontest_90_5
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_90_6/codecontest_90_6
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_90_7/codecontest_90_7
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_90_8/codecontest_90_8
evaluating ...
[True, True, True, True, True, True, False, True, True, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 91------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:80
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. You need to define f(a) as the count of positions where a_i equals i. 

You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. You need to find the largest possible f(a). Consider all possible removals to achieve this goal.

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. You need to define f(a) as the count of positions where a_i equals i. You can pick an element from the current sequence and remove it, then concatenate the remaining elements together; for example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to remove some elements from a in order to maximize f(a), using zero or more operations. You need to find the largest possible f(a). Consider all possible removals to achieve this goal.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n. You need to define f(a) as the count of positions where a_i equals i. For instance, if a_3 equals 3, it contributes to f(a). You want to remove some elements from a in order to maximize f(a), considering all possible removals to achieve this goal.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n, defining f(a) as the count of positions where a_i equals i, to maximize f(a) by removing elements from a through various operations.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
in generating...
in generating repo





in generating repo








in generating repo





in generating repo





in generating repo








in generating repo








in generating repo








in generating repo








in generating repo







in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, True, False, True, False, True, True, True, True, True]
True
----------updating----------
analyst reward: 0.109652578830719
final_output reward: 0
total reward: 0.109652578830719
add mutated seed into prompt node list
seed_index: 80
mutated_seed_index: 82
reward = 0.109652578830719
saving......
in recording...
len prompt_nodes
83
initial_seed_num
13
[False, False, True, False, True, True, True, True, False, True, False, True, False]
total pass@10:6
------------------------------
saving result into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_final_result.jsonl
------------------------------
saving original node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_original_node.jsonl
------------------------------
saving node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_node_91.jsonl
----------------------------------------round: 92------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:79
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You have an array of integers (initially empty).

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array. The element you add should be x.
  * "2 x y" — replace all occurrences of x in the array with y. 
  
Make sure to handle large inputs efficiently as the number of queries can be substantial.

Find the resulting array after performing all the queries.

--------------------------------------------------
You have an array of integers (initially empty).

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array. The element you add should be x.
  * "2 x y" — replace all occurrences of x in the array with y. 

Make sure to handle large inputs efficiently as the number of queries can be substantial.

Find the resulting array after performing all the queries. Optimize your solution for both time and space complexity to ensure scalability.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
You have to perform q queries. Each query can either add the element x to the end of the array or replace all occurrences of x with y. Make sure to handle large inputs efficiently as the number of queries can be substantial. Find the resulting array after performing all the queries. Optimize your solution for both time and space complexity to ensure scalability.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
You have an array of integers (initially empty) and you have to perform q queries, where each query is of one of two types: "1 x" to add the element x to the end of the array or "2 x y" to replace all occurrences of x in the array with y. Make sure to handle large inputs efficiently as the number of queries can be substantial. Find the resulting array after performing all the queries and optimize your solution for both time and space complexity to ensure scalability.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
in generating...
in generating repo





in generating repo





in generating repo





in generating repo








in generating repo





in generating repo





in generating repo









in generating repo








in generating repo





in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, True, True, True, True, True, False]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 93------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:73
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Mr. Chanek possesses a collection of n numbers in array a. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

Put differently, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this efficiently for large input sizes. Ensure that your implementation handles edge cases gracefully to maintain robustness.

--------------------------------------------------
Mr. Chanek possesses a collection of n numbers in array a. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

Put differently, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this efficiently for large input sizes. Ensure that your implementation handles edge cases gracefully to maintain robustness. Consider optimizing the GCD calculations to improve the algorithm’s performance for very large arrays.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek needs assistance in determining the prettiness value of array a based on the specified formula involving GCD calculations.  It is important to optimize the GCD calculations to enhance the efficiency of the algorithm, especially when dealing with large arrays. 

Mr. Chanek possesses a collection of n numbers in array a. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

Put differently, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this efficiently for large input sizes. Ensure that your implementation handles edge cases gracefully to maintain robustness. Consider optimizing the GCD calculations to improve the algorithm’s performance for very large arrays.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
Mr. Chanek possesses a collection of n numbers in array a, and the prettiness value of a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j). Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Your task is to implement a solution to calculate this efficiently for large input sizes. Ensure that your implementation handles edge cases gracefully to maintain robustness. Consider optimizing the GCD calculations to improve the algorithm’s performance for very large arrays.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
in generating...
in generating repo





in generating repo





in generating repo





in generating repo








in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, True, True, False, False, False, False, True, False]
True
----------updating----------
analyst reward: 0.14719581604003906
final_output reward: 0
total reward: 0.14719581604003906
add mutated seed into prompt node list
seed_index: 73
mutated_seed_index: 83
reward = 0.14719581604003906
saving......
----------------------------------------round: 94------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:8
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end.

Now Monocarp asks you to compare these two numbers. Can you help him?

--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x that has p zeros appended to its end. These zeros are attached to the integer x, extending its overall length and value.

Now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x that has p zeros appended to its end, which are attached to the integer x, extending its overall length and value. Now, Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard, both following a specific format: a positive integer x that has p zeros appended to its end, attached to the integer x, extending its overall length and value. Can you help him compare these two numbers?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo







in generating repo





in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, True, True, True, True, True, True, True, True]
True
----------updating----------
analyst reward: 0.28216278553009033
final_output reward: 0
total reward: 0.28216278553009033
add mutated seed into prompt node list
seed_index: 8
mutated_seed_index: 84
reward = 0.28216278553009033
saving......
----------------------------------------round: 95------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:75
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Luntik has decided to try singing. He has a songs that last one minute, b songs that last two minutes, and c songs that last three minutes. He wants to distribute all songs into two concerts. Each concert should include every song in such a way that every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider edge cases where there are significantly more songs of one duration than others.

--------------------------------------------------
Luntik has decided to try singing. He has a songs that last one minute, b songs that last two minutes, and c songs that last three minutes, and he wants to distribute all songs into two concerts. Each concert should include every song in such a way that every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider edge cases where there are significantly more songs of one duration than others.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Luntik wants to distribute all his songs into two concerts in a way that minimizes the absolute difference in durations. The difference in minutes between the concerts' durations should be as small as possible. He has a diverse mix of songs, some lasting one minute, some lasting two minutes, and some lasting three minutes. Let's help Luntik achieve his goal by finding the minimal possible difference in minutes between the concerts' durations, considering scenarios where there are significantly more songs of one duration than others.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
Luntik has songs that last one minute, two minutes, and three minutes, and he wants to distribute them into two concerts to minimize the absolute difference in duration between the concerts. Please find the minimal possible difference in minutes between the concerts durations, considering edge cases with significantly more songs of one duration than others.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
in generating...
in generating repo






in generating repo






in generating repo





in generating repo








in generating repo









in generating repo








in generating repo








in generating repo






in generating repo






in generating repo









in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_95_4/codecontest_95_4
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_95_6/codecontest_95_6
evaluating ...
[False, False, False, False, False, False, True, False, False, False]
True
----------updating----------
analyst reward: 0.11141449213027954
final_output reward: 0
total reward: 0.11141449213027954
add mutated seed into prompt node list
seed_index: 75
mutated_seed_index: 85
reward = 0.11141449213027954
saving......
----------------------------------------round: 96------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:82
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. You need to define f(a) as the count of positions where a_i equals i. You can pick an element from the current sequence and remove it, then concatenate the remaining elements together; for example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to remove some elements from a in order to maximize f(a), using zero or more operations. You need to find the largest possible f(a). Consider all possible removals to achieve this goal.

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. You need to define f(a) as the count of positions where a_i equals i. You can pick an element from the current sequence and remove it. After removing the element, concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to remove some elements from a in order to maximize f(a), using zero or more operations. You need to find the largest possible f(a). Consider all possible removals to achieve this goal.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the count of positions where a_i equals i, then aim to maximize f(a) by removing elements from the sequence and concatenating the remaining elements together.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n where you need to define f(a) as the count of positions where a_i equals i, and then remove some elements from a in order to maximize f(a) by considering all possible removals.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
in generating...
in generating repo





in generating repo








in generating repo





in generating repo








in generating repo









in generating repo








in generating repo








in generating repo









in generating repo








in generating repo





in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, True, True, False, True, True, True, False, True]
True
----------updating----------
analyst reward: 0.10739994049072266
final_output reward: 0
total reward: 0.10739994049072266
add mutated seed into prompt node list
seed_index: 82
mutated_seed_index: 86
reward = 0.10739994049072266
saving......
----------------------------------------round: 97------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:84
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x that has p zeros appended to its end. These zeros are attached to the integer x, extending its overall length and value.

Now Monocarp asks you to compare these two numbers. Can you help him?

--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x that has p zeros appended to its end, extending its overall length and value.

Now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x that has p zeros appended to its end, extending its overall length and value. Can you help him compare these extended numbers and determine which one is larger?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard, a positive integer x with p zeros at the end of each number, and asks you to compare them. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo






in generating repo





in generating repo





in generating repo





in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, False, True, False, True, True, True, True, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0.2
total reward: 0.2
add mutated seed into prompt node list
seed_index: 84
mutated_seed_index: 87
reward = 0.2
saving......
----------------------------------------round: 98------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:23
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
A string is termed square if it is a sequence repeated two times consecutively. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

--------------------------------------------------
A string is termed square if it is a sequence repeated two times consecutively. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. These are sequences that appear twice back-to-back, creating a square string. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
A string is termed square if it is a sequence repeated two times consecutively. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square because they are sequences that appear twice back-to-back, creating a square string.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
A string is termed square if it is a sequence repeated two times consecutively, determine if a given string is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
in generating...
in generating repo





in generating repo





in generating repo





in generating repo








in generating repo








in generating repo






in generating repo







in generating repo






in generating repo






in generating repo










in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_98_1/codecontest_98_1
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_98_2/codecontest_98_2
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_98_4/codecontest_98_4
evaluating ...
[True, True, True, True, False, False, False, True, True, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 99------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:79
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You have an array of integers (initially empty).

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array. The element you add should be x.
  * "2 x y" — replace all occurrences of x in the array with y. 
  
Make sure to handle large inputs efficiently as the number of queries can be substantial.

Find the resulting array after performing all the queries.

--------------------------------------------------
You have an array of integers (initially empty).

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array. The element you add should be x. This means that after the operation, the last element will be x.
  * "2 x y" — replace all occurrences of x in the array with y. 

Make sure to handle large inputs efficiently as the number of queries can be substantial.

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
You have to perform q queries. Each query is of one of two types: 

Make sure to handle large inputs efficiently as the number of queries can be substantial. 

You have an array of integers (initially empty). 

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array. The element you add should be x. This means that after the operation, the last element will be x.
  * "2 x y" — replace all occurrences of x in the array with y. 

Make sure to handle large inputs efficiently as the number of queries can be substantial.

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
You have an array of integers (initially empty). Perform q queries of two types: "1 x" adds element x to the end, while "2 x y" replaces all occurrences of x with y. Make sure to handle large inputs efficiently as the number of queries can be substantial. Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo






in generating repo





in generating repo








in generating repo








in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, True, True, False, True, True, False, True, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 100------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:16
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs and he wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs and he wants to distribute all songs into two concerts such that every song should be included to exactly one concert, aiming to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Luntik has a one-minute songs, b two-minute songs, and c three-minute songs, and he wants to distribute all songs into two concerts such that every song should be included to exactly one concert. The goal is to make the absolute difference of durations of the concerts as small as possible. Please help Luntik find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
Luntik has one-minute, two-minute, and three-minute songs and wants to distribute them into two concerts to minimize the absolute difference in durations. Find the minimal possible difference between the concerts' durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
in generating...
in generating repo





in generating repo





in generating repo







in generating repo






in generating repo






in generating repo






in generating repo






in generating repo









in generating repo





in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, False, False, False, True, False, False, False, False, False]
True
----------updating----------
analyst reward: 0.10052227973937988
final_output reward: 0
total reward: 0.10052227973937988
add mutated seed into prompt node list
seed_index: 16
mutated_seed_index: 88
reward = 0.10052227973937988
saving......
----------------------------------------round: 101------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:87
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x that has p zeros appended to its end, extending its overall length and value.

Now Monocarp asks you to compare these two numbers. Can you help him?

--------------------------------------------------
Monocarp jotted down a pair of numbers on a whiteboard. Both numbers conform to a certain format: a positive integer x that has p zeros added to its end, increasing its length and value in total.

Now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Monocarp jotted down a pair of numbers on a whiteboard. One of the numbers is a positive integer x with p zeros added to its end, increasing both its length and value in total exponentially. Now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
Monocarp jotted down a pair of numbers on a whiteboard, where a positive integer x has p zeros added to its end, increasing its length and value in total. Now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo







in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, False, False, True, True, True, True, True, False]
True
----------updating----------
analyst reward: 0
final_output reward: 0.1
total reward: 0.1
add mutated seed into prompt node list
seed_index: 87
mutated_seed_index: 89
reward = 0.1
saving......
in recording...
len prompt_nodes
90
initial_seed_num
13
[False, False, True, False, True, True, True, True, False, True, False, True, False]
total pass@10:6
------------------------------
saving result into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_final_result.jsonl
------------------------------
saving original node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_original_node.jsonl
------------------------------
saving node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_node_101.jsonl
----------------------------------------round: 102------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:82
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. You need to define f(a) as the count of positions where a_i equals i. You can pick an element from the current sequence and remove it, then concatenate the remaining elements together; for example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to remove some elements from a in order to maximize f(a), using zero or more operations. You need to find the largest possible f(a). Consider all possible removals to achieve this goal.

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. You need to define f(a) as the count of positions where a_i equals i. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1], because you can pick an element from the current sequence and remove it, then concatenate the remaining elements together. You want to remove some elements from a in order to maximize f(a), using zero or more operations. You need to find the largest possible f(a). Consider all possible removals to achieve this goal.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n. Let's define f(a) as the count of positions where a_i equals i. For instance, after removing the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. How can you maximize f(a) by removing some elements from a, considering all possible removals to achieve this goal?

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
Mr. Chanek gives you a sequence a indexed from 1 to n where you need to define f(a) as the count of positions where a_i equals i by removing some elements to maximize f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo








in generating repo








in generating repo








in generating repo





in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, True, True, True, True, False, True, True, True, True]
True
----------updating----------
analyst reward: 0.10577517747879028
final_output reward: 0
total reward: 0.10577517747879028
add mutated seed into prompt node list
seed_index: 82
mutated_seed_index: 90
reward = 0.10577517747879028
saving......
----------------------------------------round: 103------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:10
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
A string is called square if it is some string written twice in a row. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

--------------------------------------------------
A string is called square if it is some string written twice in a row. For example, the strings "aa" are square. The strings "abcabc", "abab" and "baabaa" are also square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
A string is called square if it is some string written twice in a row, like the strings "aa". Another example of a square string is "abcabc", where the string "abc" is repeated twice. The strings "aaa", "abaaab" and "abcdabc" do not satisfy the condition of being square. 

For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
A string is called square if it is some string written twice in a row, determine if a given string s is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
in generating...
in generating repo






in generating repo






in generating repo






in generating repo






in generating repo






in generating repo






in generating repo






in generating repo












in generating repo






in generating repo












in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_103_1/codecontest_103_1
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_103_2/codecontest_103_2
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_103_4/codecontest_103_4
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_103_6/codecontest_103_6
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_103_7/codecontest_103_7
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_103_8/codecontest_103_8
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_103_9/codecontest_103_9
evaluating ...
[True, False, True, False, False, False, False, False, False, False]
True
----------updating----------
analyst reward: 0.1754225492477417
final_output reward: 0.8
total reward: 0.9754225492477417
add mutated seed into prompt node list
seed_index: 10
mutated_seed_index: 91
reward = 0.9754225492477417
saving......
----------------------------------------round: 104------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:91
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
A string is called square if it is some string written twice in a row. For example, the strings "aa" are square. The strings "abcabc", "abab" and "baabaa" are also square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

--------------------------------------------------
A string is labeled square if it consists of a smaller string duplicated consecutively. For example, the strings "aa" are square. The strings "abcabc", "abab" and "baabaa" are also square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
A string is labeled square if it consists of a smaller string duplicated consecutively. For example, the strings "aa" are square. The strings "abcabc", "abab" and "baabaa" are also square. However, the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
A string is labeled square if it consists of a smaller string duplicated consecutively, determine if a given string s is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
in generating...
in generating repo





in generating repo





in generating repo





in generating repo







in generating repo






in generating repo








in generating repo







in generating repo







in generating repo










in generating repo





in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_104_9/codecontest_104_9
evaluating ...
[False, False, False, False, False, False, False, False, False, False]
False
----------updating----------
seed 91 finish fuzzing!
seed_index: 91
mutated_seed_index: 92
current seed length: 5
saving......
----------------------------------------round: 105------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:79
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You have an array of integers (initially empty).

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array. The element you add should be x.
  * "2 x y" — replace all occurrences of x in the array with y. 
  
Make sure to handle large inputs efficiently as the number of queries can be substantial.

Find the resulting array after performing all the queries.

--------------------------------------------------
You have an array of integers (initially empty).

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array.
  * "2 x y" — replace all occurrences of x in the array with y. 

Make sure to handle large inputs efficiently as the number of queries can be substantial.

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array.
  * "2 x y" — replace all occurrences of x in the array with y. 
  
Ensure efficient handling of large inputs as the number of queries can be substantial.

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
You have an array of integers (initially empty) and need to perform q queries, either adding an element to the end of the array or replacing all occurrences of x with y efficiently as the number of queries can be substantial. Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo







in generating repo







in generating repo







in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_105_1/codecontest_105_1
evaluating ...
[True, False, True, False, True, True, True, False, True, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 106------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:84
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x that has p zeros appended to its end. These zeros are attached to the integer x, extending its overall length and value.

Now Monocarp asks you to compare these two numbers. Can you help him?

--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x that has p zeros appended to its end. These zeros are attached to the integer x. They extend its overall length and value. 

Now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x that has p zeros appended to its end, increasing its length and value significantly. Now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard, where a positive integer x has p zeros appended to its end to extend its overall length and value, and asks you to compare them. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo








in generating repo







in generating repo





in generating repo





in generating repo








in generating repo








in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, True, True, True, True, True, True, True, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 107------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:70
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You have an array of integers (initially empty). You have to perform q queries, and each query is of one of two types: 

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 

Find the resulting array after performing all the queries. Ensure to handle edge cases such as empty arrays and overlapping values for replacement efficiently.

--------------------------------------------------
You have an array of integers (initially empty). You have to perform q queries, and each query is of one of two types: 

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. Find the resulting array after performing all the queries.

Ensure to handle edge cases such as empty arrays and overlapping values for replacement efficiently.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
You have to perform q queries, and each query is of one of two types:  "1 x" — add the element x to the end of the array, and "2 x y" — replace all occurrences of x in the array with y. It is important to handle edge cases such as empty arrays and overlapping values for replacement efficiently.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
You have an array of integers (initially empty) and perform q queries, where each query is either "1 x" to add x to the end or "2 x y" to replace x with y, finding the resulting array after all queries while efficiently handling edge cases.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo








in generating repo








in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, False, False, False, False, False, False, True, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 108------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:8
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end.

Now Monocarp asks you to compare these two numbers. Can you help him?

--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard, and both numbers follow a specific format: a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard, and both numbers follow a specific format: a positive integer x with p zeros appended to its end. Monocarp now needs your assistance in comparing these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard, both following a specific format: a positive integer x with p zeros appended to its end, and now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo







in generating repo





in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, True, True, True, True, True, True, True, True]
True
----------updating----------
analyst reward: 0.27529388666152954
final_output reward: 0
total reward: 0.27529388666152954
add mutated seed into prompt node list
seed_index: 8
mutated_seed_index: 93
reward = 0.27529388666152954
saving......
----------------------------------------round: 109------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:93
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard, and both numbers follow a specific format: a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers. Can you help him?

--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard, and both numbers follow a specific format: a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers. Can you help him? Consider efficiency in your solution, as numbers can be extremely large due to the number of appended zeros.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard, and both numbers follow a specific format: a positive integer x with p zeros appended to its end, making them potential large numbers. Now Monocarp asks you to compare these two numbers. Can you help him? Consider efficiency in your solution, as numbers can be extremely large due to the number of appended zeros.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard, and both numbers follow a specific format: a positive integer x with p zeros appended to its end, Can you help him compare these two numbers? Consider efficiency in your solution, as numbers can be extremely large due to the number of appended zeros.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo








in generating repo








in generating repo








in generating repo








in generating repo





in generating repo





in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[False, True, True, True, False, True, True, True, False, True]
True
----------updating----------
analyst reward: 0.13182008266448975
final_output reward: 0.3
total reward: 0.43182008266448973
add mutated seed into prompt node list
seed_index: 93
mutated_seed_index: 94
reward = 0.43182008266448973
saving......
----------------------------------------round: 110------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:8
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end.

Now Monocarp asks you to compare these two numbers. Can you help him?

--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Assume both numbers can be extremely large, and consider the use of efficient comparison techniques.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end, making them potentially very large.

Now Monocarp asks you to compare these two numbers. Can you help him? Assume both numbers can be extremely large, and consider the use of efficient comparison techniques.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard, with a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers. Can you help him? Assume both numbers can be extremely large, and consider the use of efficient comparison techniques.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo










in generating repo






in generating repo









in generating repo





in generating repo





in generating repo








in generating repo





in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
code file path not exist! /home/zlyuaj/muti-agent/MetaGPT/workspace_repair_fuzzing_gpt-35-turbo_codecontest/codecontest_110_8/codecontest_110_8
evaluating ...
[True, False, True, True, True, False, True, True, True, False]
True
----------updating----------
analyst reward: 0.2998642325401306
final_output reward: 0.3
total reward: 0.5998642325401307
add mutated seed into prompt node list
seed_index: 8
mutated_seed_index: 95
reward = 0.5998642325401307
saving......
----------------------------------------round: 111------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:95
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Assume both numbers can be extremely large, and consider the use of efficient comparison techniques.

--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Assume both numbers can be extremely large, and consider the use of efficient comparison techniques. Your task is to determine which number is greater, or if they are equal, utilizing logarithmic or other optimized methods.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end. One of the numbers could potentially be larger due to the number of zeros appended, and Monocarp needs help comparing them efficiently. Can you assist in determining which number is greater using optimized methods for potentially large numbers?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
Monocarp wrote down two numbers on a whiteboard where each number is a positive integer x with p zeros appended to its end, and now asks you to compare them. Can you help him? Assume both numbers can be extremely large, and consider the use of efficient comparison techniques. Your task is to determine which number is greater, or if they are equal, utilizing logarithmic or other optimized methods.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
in generating...
in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo








in generating repo









in generating repo








in generating repo





in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, True, True, True, True, True, False, False, False, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
in recording...
len prompt_nodes
96
initial_seed_num
13
[False, False, True, False, True, True, True, True, False, True, True, True, False]
total pass@10:5
------------------------------
saving result into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_final_result.jsonl
------------------------------
saving original node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_original_node.jsonl
------------------------------
saving node into: ../../output/repair_fuzzing/results-repair_fuzzing_gpt-35-turbo_codecontest_1-1_2/_node_111.jsonl
----------------------------------------round: 112------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:79
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You have an array of integers (initially empty).

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array. The element you add should be x.
  * "2 x y" — replace all occurrences of x in the array with y. 
  
Make sure to handle large inputs efficiently as the number of queries can be substantial.

Find the resulting array after performing all the queries.

--------------------------------------------------
You have an array of integers (initially empty).

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array. You should add the element x to the array. Place x at the end of the array when adding it.
  * "2 x y" — replace all occurrences of x in the array with y. 

Make sure to handle large inputs efficiently as the number of queries can be substantial.

Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
You have to perform q queries. Each query is of one of two types: "1 x" — add the element x to the end of the array. Ensure that you add the element x to the array by placing it at the end of the array when adding it. 

You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types: "1 x" — add the element x to the end of the array. You should add the element x to the array. Place x at the end of the array when adding it. "2 x y" — replace all occurrences of x in the array with y. Make sure to handle large inputs efficiently as the number of queries can be substantial. Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
You have an array of integers (initially empty) and have to perform q queries, handling large inputs efficiently as the number of queries can be substantial. You should find the resulting array after performing all the queries: 

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array. You should add the element x to the array. Place x at the end of the array when adding it.
  * "2 x y" — replace all occurrences of x in the array with y.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
in generating...
in generating repo





in generating repo





in generating repo








in generating repo





in generating repo





in generating repo





in generating repo





in generating repo








in generating repo







in generating repo








in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
in generating...
Can't pickle local object 'parse_gitignore.<locals>.<lambda>'
evaluating ...
[True, False, False, True, True, True, True, True, True, True]
True
----------updating----------
analyst reward: 0
final_output reward: 0
total reward: 0.0
reward = 0
saving......
----------------------------------------round: 113------------------------------
----------selecting seed----------
