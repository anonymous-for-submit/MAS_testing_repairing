{"source_file": "Ellen's Copy of Benchmark Questions Verification V2.ipynb", "task_id": 297, "prompt": "Write a function to flatten a given nested list structure. The function should handle lists with arbitrary levels of nesting.", "code": "def flatten_list(list1):\n    result_list = []\n    if not list1: return result_list\n    stack = [list(list1)]\n    while stack:\n        c_num = stack.pop()\n        next = c_num.pop()\n        if c_num: stack.append(c_num)\n        if isinstance(next, list):\n            if next: stack.append(list(next))\n        else: result_list.append(next)\n    result_list.reverse()\n    return result_list ", "test_imports": [], "test_list": ["assert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]", "assert flatten_list([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]])==[10, 20, 40, 30, 56, 25, 10, 20, 33, 40]", "assert flatten_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])==[1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]", "assert flatten_list([5, 15, [17, 25], 39, 49, [65, 69, 78], [86, 97, 110, 123]]) == [5, 15, 17, 25, 39, 49, 65, 69, 78, 86, 97, 110, 123]", "assert flatten_list([5, 7, [15, 33], 39, 45, [65, 75, 82], [92, 104, 115, 116]]) == [5, 7, 15, 33, 39, 45, 65, 75, 82, 92, 104, 115, 116]", "assert flatten_list([2, 9, [22, 28], 35, 52, [58, 68, 81], [87, 100, 105, 117]]) == [2, 9, 22, 28, 35, 52, 58, 68, 81, 87, 100, 105, 117]", "assert flatten_list([5, 10, [24, 29], 42, 49, [65, 72, 85], [92, 97, 105, 119]]) == [5, 10, 24, 29, 42, 49, 65, 72, 85, 92, 97, 105, 119]", "assert flatten_list([5, 15, [24, 32], 36, 50, [63, 74, 78], [85, 101, 113, 115]]) == [5, 15, 24, 32, 36, 50, 63, 74, 78, 85, 101, 113, 115]", "assert flatten_list([4, 11, [15, 25], 37, 51, [64, 74, 82], [94, 101, 110, 117]]) == [4, 11, 15, 25, 37, 51, 64, 74, 82, 94, 101, 110, 117]", "assert flatten_list([1, 10, [17, 26], 39, 49, [65, 75, 77], [87, 103, 112, 121]]) == [1, 10, 17, 26, 39, 49, 65, 75, 77, 87, 103, 112, 121]", "assert flatten_list([3, 7, [24, 25], 43, 45, [55, 69, 83], [90, 105, 108, 121]]) == [3, 7, 24, 25, 43, 45, 55, 69, 83, 90, 105, 108, 121]", "assert flatten_list([5, 15, [16, 34], 37, 49, [61, 68, 84], [95, 95, 114, 125]]) == [5, 15, 16, 34, 37, 49, 61, 68, 84, 95, 95, 114, 125]", "assert flatten_list([3, 5, [20, 29], 35, 48, [56, 71, 85], [85, 104, 108, 122]]) == [3, 5, 20, 29, 35, 48, 56, 71, 85, 85, 104, 108, 122]", "assert flatten_list([1, 11, [22, 26], 45, 53, [61, 74, 83], [90, 97, 113, 118]]) == [1, 11, 22, 26, 45, 53, 61, 74, 83, 90, 97, 113, 118]", "assert flatten_list([5, 8, [15, 32], 41, 50, [56, 75, 82], [90, 104, 114, 125]]) == [5, 8, 15, 32, 41, 50, 56, 75, 82, 90, 104, 114, 125]", "assert flatten_list([4, 8, [23, 27], 36, 55, [60, 71, 78], [85, 105, 108, 125]]) == [4, 8, 23, 27, 36, 55, 60, 71, 78, 85, 105, 108, 125]", "assert flatten_list([2, 11, [22, 34], 41, 48, [65, 68, 82], [85, 101, 108, 124]]) == [2, 11, 22, 34, 41, 48, 65, 68, 82, 85, 101, 108, 124]", "assert flatten_list([4, 11, [19, 35], 37, 55, [63, 70, 75], [95, 97, 108, 116]]) == [4, 11, 19, 35, 37, 55, 63, 70, 75, 95, 97, 108, 116]", "assert flatten_list([1, 13, [16, 28], 40, 46, [62, 72, 78], [95, 101, 109, 117]]) == [1, 13, 16, 28, 40, 46, 62, 72, 78, 95, 101, 109, 117]", "assert flatten_list([3, 9, [23, 27], 38, 53, [63, 71, 79], [93, 104, 111, 117]]) == [3, 9, 23, 27, 38, 53, 63, 71, 79, 93, 104, 111, 117]", "assert flatten_list([2, 15, [15, 35], 37, 51, [57, 68, 75], [90, 96, 112, 116]]) == [2, 15, 15, 35, 37, 51, 57, 68, 75, 90, 96, 112, 116]", "assert flatten_list([2, 6, [23, 35], 43, 52, [56, 69, 75], [86, 95, 112, 120]]) == [2, 6, 23, 35, 43, 52, 56, 69, 75, 86, 95, 112, 120]", "assert flatten_list([5, 7, [23, 33], 44, 48, [63, 71, 76], [85, 104, 114, 117]]) == [5, 7, 23, 33, 44, 48, 63, 71, 76, 85, 104, 114, 117]", "assert flatten_list([2, 12, [20, 35], 35, 48, [57, 72, 76], [85, 95, 105, 119]]) == [2, 12, 20, 35, 35, 48, 57, 72, 76, 85, 95, 105, 119]", "assert flatten_list([5, 8, [23, 25], 45, 48, [57, 75, 80], [90, 98, 108, 120]]) == [5, 8, 23, 25, 45, 48, 57, 75, 80, 90, 98, 108, 120]", "assert flatten_list([2, 13, [19, 26], 35, 51, [64, 70, 80], [92, 100, 107, 115]]) == [2, 13, 19, 26, 35, 51, 64, 70, 80, 92, 100, 107, 115]", "assert flatten_list([2, 11, [19, 29], 44, 53, [58, 71, 82], [93, 103, 111, 116]]) == [2, 11, 19, 29, 44, 53, 58, 71, 82, 93, 103, 111, 116]", "assert flatten_list([4, 14, [19, 32], 44, 45, [59, 74, 84], [93, 97, 115, 122]]) == [4, 14, 19, 32, 44, 45, 59, 74, 84, 93, 97, 115, 122]", "assert flatten_list([2, 10, [16, 35], 43, 54, [64, 75, 85], [86, 98, 106, 116]]) == [2, 10, 16, 35, 43, 54, 64, 75, 85, 86, 98, 106, 116]", "assert flatten_list([2, 8, [16, 31], 36, 49, [55, 68, 77], [94, 103, 105, 124]]) == [2, 8, 16, 31, 36, 49, 55, 68, 77, 94, 103, 105, 124]", "assert flatten_list([1, 13, [22, 26], 37, 46, [61, 73, 81], [90, 103, 107, 124]]) == [1, 13, 22, 26, 37, 46, 61, 73, 81, 90, 103, 107, 124]", "assert flatten_list([3, 14, [22, 26], 44, 45, [56, 73, 85], [89, 103, 112, 121]]) == [3, 14, 22, 26, 44, 45, 56, 73, 85, 89, 103, 112, 121]", "assert flatten_list([3, 11, [20, 26], 38, 53, [59, 65, 76], [93, 99, 114, 122]]) == [3, 11, 20, 26, 38, 53, 59, 65, 76, 93, 99, 114, 122]", "assert flatten_list([4, 6, [16, 31], 42, 48, [55, 67, 85], [86, 97, 112, 124]]) == [4, 6, 16, 31, 42, 48, 55, 67, 85, 86, 97, 112, 124]", "assert flatten_list([5, 9, [16, 26], 35, 49, [65, 74, 77], [91, 98, 109, 119]]) == [5, 9, 16, 26, 35, 49, 65, 74, 77, 91, 98, 109, 119]", "assert flatten_list([4, 5, [25, 25], 45, 55, [63, 68, 77], [91, 105, 105, 118]]) == [4, 5, 25, 25, 45, 55, 63, 68, 77, 91, 105, 105, 118]", "assert flatten_list([[11, 21], [42], [28, 57, 26], [11, 16], [36], [37]]) == [11, 21, 42, 28, 57, 26, 11, 16, 36, 37]", "assert flatten_list([[10, 23], [40], [31, 51, 25], [15, 18], [37], [43]]) == [10, 23, 40, 31, 51, 25, 15, 18, 37, 43]", "assert flatten_list([[6, 21], [37], [30, 61, 29], [7, 22], [33], [41]]) == [6, 21, 37, 30, 61, 29, 7, 22, 33, 41]", "assert flatten_list([[12, 23], [39], [33, 53, 22], [10, 22], [38], [43]]) == [12, 23, 39, 33, 53, 22, 10, 22, 38, 43]", "assert flatten_list([[11, 17], [40], [31, 57, 24], [9, 15], [30], [43]]) == [11, 17, 40, 31, 57, 24, 9, 15, 30, 43]", "assert flatten_list([[15, 20], [35], [27, 55, 28], [13, 21], [38], [39]]) == [15, 20, 35, 27, 55, 28, 13, 21, 38, 39]", "assert flatten_list([[13, 22], [35], [31, 54, 27], [15, 24], [37], [41]]) == [13, 22, 35, 31, 54, 27, 15, 24, 37, 41]", "assert flatten_list([[12, 23], [43], [32, 55, 27], [5, 18], [32], [43]]) == [12, 23, 43, 32, 55, 27, 5, 18, 32, 43]", "assert flatten_list([[8, 21], [40], [30, 61, 21], [11, 22], [33], [42]]) == [8, 21, 40, 30, 61, 21, 11, 22, 33, 42]", "assert flatten_list([[11, 20], [39], [28, 60, 27], [8, 22], [31], [42]]) == [11, 20, 39, 28, 60, 27, 8, 22, 31, 42]", "assert flatten_list([[6, 19], [39], [31, 53, 24], [8, 23], [33], [42]]) == [6, 19, 39, 31, 53, 24, 8, 23, 33, 42]", "assert flatten_list([[9, 23], [37], [29, 55, 23], [15, 18], [35], [36]]) == [9, 23, 37, 29, 55, 23, 15, 18, 35, 36]", "assert flatten_list([[13, 23], [44], [28, 52, 24], [11, 17], [29], [40]]) == [13, 23, 44, 28, 52, 24, 11, 17, 29, 40]", "assert flatten_list([[11, 21], [36], [35, 60, 24], [7, 15], [29], [39]]) == [11, 21, 36, 35, 60, 24, 7, 15, 29, 39]", "assert flatten_list([[6, 20], [35], [30, 51, 21], [13, 19], [31], [35]]) == [6, 20, 35, 30, 51, 21, 13, 19, 31, 35]", "assert flatten_list([[14, 18], [40], [26, 53, 30], [11, 24], [34], [36]]) == [14, 18, 40, 26, 53, 30, 11, 24, 34, 36]", "assert flatten_list([[15, 16], [43], [26, 60, 25], [8, 20], [28], [37]]) == [15, 16, 43, 26, 60, 25, 8, 20, 28, 37]", "assert flatten_list([[7, 25], [35], [25, 51, 26], [8, 21], [29], [45]]) == [7, 25, 35, 25, 51, 26, 8, 21, 29, 45]", "assert flatten_list([[13, 23], [44], [35, 56, 27], [12, 16], [31], [45]]) == [13, 23, 44, 35, 56, 27, 12, 16, 31, 45]", "assert flatten_list([[9, 18], [39], [30, 61, 29], [9, 20], [31], [41]]) == [9, 18, 39, 30, 61, 29, 9, 20, 31, 41]", "assert flatten_list([[12, 16], [45], [33, 54, 24], [13, 19], [38], [43]]) == [12, 16, 45, 33, 54, 24, 13, 19, 38, 43]", "assert flatten_list([[14, 23], [38], [30, 58, 24], [7, 16], [37], [43]]) == [14, 23, 38, 30, 58, 24, 7, 16, 37, 43]", "assert flatten_list([[6, 17], [45], [26, 58, 23], [8, 18], [32], [36]]) == [6, 17, 45, 26, 58, 23, 8, 18, 32, 36]", "assert flatten_list([[15, 19], [43], [26, 57, 28], [7, 22], [34], [39]]) == [15, 19, 43, 26, 57, 28, 7, 22, 34, 39]", "assert flatten_list([[6, 16], [37], [25, 61, 25], [8, 20], [36], [42]]) == [6, 16, 37, 25, 61, 25, 8, 20, 36, 42]", "assert flatten_list([[12, 15], [41], [33, 60, 24], [10, 18], [33], [38]]) == [12, 15, 41, 33, 60, 24, 10, 18, 33, 38]", "assert flatten_list([[13, 18], [35], [26, 51, 22], [13, 19], [31], [45]]) == [13, 18, 35, 26, 51, 22, 13, 19, 31, 45]", "assert flatten_list([[15, 22], [39], [29, 53, 20], [9, 22], [29], [36]]) == [15, 22, 39, 29, 53, 20, 9, 22, 29, 36]", "assert flatten_list([[8, 15], [40], [25, 52, 23], [7, 18], [33], [35]]) == [8, 15, 40, 25, 52, 23, 7, 18, 33, 35]", "assert flatten_list([[11, 24], [39], [34, 53, 29], [5, 17], [33], [35]]) == [11, 24, 39, 34, 53, 29, 5, 17, 33, 35]", "assert flatten_list([[14, 24], [43], [27, 58, 20], [9, 16], [35], [40]]) == [14, 24, 43, 27, 58, 20, 9, 16, 35, 40]", "assert flatten_list([[9, 21], [44], [32, 54, 21], [10, 15], [36], [36]]) == [9, 21, 44, 32, 54, 21, 10, 15, 36, 36]", "assert flatten_list([[6, 18], [35], [32, 54, 25], [11, 23], [30], [42]]) == [6, 18, 35, 32, 54, 25, 11, 23, 30, 42]", "assert flatten_list([[3, 4, 4], [9, 7, 8], [10, 15, 16], [11, 4, 12]]) == [3, 4, 4, 9, 7, 8, 10, 15, 16, 11, 4, 12]", "assert flatten_list([[4, 1, 4], [3, 1, 5], [13, 11, 8], [10, 3, 4]]) == [4, 1, 4, 3, 1, 5, 13, 11, 8, 10, 3, 4]", "assert flatten_list([[3, 1, 3], [1, 6, 4], [13, 6, 16], [11, 12, 10]]) == [3, 1, 3, 1, 6, 4, 13, 6, 16, 11, 12, 10]", "assert flatten_list([[3, 2, 7], [7, 9, 8], [14, 8, 7], [5, 6, 8]]) == [3, 2, 7, 7, 9, 8, 14, 8, 7, 5, 6, 8]", "assert flatten_list([[4, 1, 2], [9, 6, 2], [9, 15, 17], [9, 5, 13]]) == [4, 1, 2, 9, 6, 2, 9, 15, 17, 9, 5, 13]", "assert flatten_list([[1, 2, 2], [8, 1, 7], [10, 14, 12], [11, 11, 10]]) == [1, 2, 2, 8, 1, 7, 10, 14, 12, 11, 11, 10]", "assert flatten_list([[2, 7, 2], [8, 4, 3], [10, 10, 13], [3, 3, 5]]) == [2, 7, 2, 8, 4, 3, 10, 10, 13, 3, 3, 5]", "assert flatten_list([[3, 6, 5], [2, 1, 8], [6, 16, 16], [4, 13, 7]]) == [3, 6, 5, 2, 1, 8, 6, 16, 16, 4, 13, 7]", "assert flatten_list([[2, 3, 1], [8, 9, 2], [15, 16, 8], [7, 9, 6]]) == [2, 3, 1, 8, 9, 2, 15, 16, 8, 7, 9, 6]", "assert flatten_list([[3, 3, 8], [6, 6, 11], [15, 6, 10], [8, 4, 13]]) == [3, 3, 8, 6, 6, 11, 15, 6, 10, 8, 4, 13]", "assert flatten_list([[2, 2, 2], [5, 4, 4], [14, 8, 11], [3, 11, 13]]) == [2, 2, 2, 5, 4, 4, 14, 8, 11, 3, 11, 13]", "assert flatten_list([[2, 2, 8], [7, 9, 6], [8, 6, 17], [9, 9, 12]]) == [2, 2, 8, 7, 9, 6, 8, 6, 17, 9, 9, 12]", "assert flatten_list([[2, 4, 3], [1, 4, 10], [10, 8, 14], [10, 8, 4]]) == [2, 4, 3, 1, 4, 10, 10, 8, 14, 10, 8, 4]", "assert flatten_list([[1, 1, 1], [5, 5, 1], [12, 12, 9], [4, 4, 10]]) == [1, 1, 1, 5, 5, 1, 12, 12, 9, 4, 4, 10]", "assert flatten_list([[5, 1, 5], [6, 5, 10], [8, 14, 12], [10, 9, 14]]) == [5, 1, 5, 6, 5, 10, 8, 14, 12, 10, 9, 14]", "assert flatten_list([[1, 2, 2], [5, 4, 11], [14, 11, 16], [6, 12, 9]]) == [1, 2, 2, 5, 4, 11, 14, 11, 16, 6, 12, 9]", "assert flatten_list([[3, 2, 3], [2, 8, 11], [13, 16, 9], [2, 7, 13]]) == [3, 2, 3, 2, 8, 11, 13, 16, 9, 2, 7, 13]", "assert flatten_list([[2, 6, 6], [1, 4, 5], [5, 11, 10], [3, 12, 6]]) == [2, 6, 6, 1, 4, 5, 5, 11, 10, 3, 12, 6]", "assert flatten_list([[5, 6, 8], [6, 4, 8], [5, 11, 10], [8, 8, 4]]) == [5, 6, 8, 6, 4, 8, 5, 11, 10, 8, 8, 4]", "assert flatten_list([[2, 4, 7], [8, 1, 1], [8, 16, 8], [7, 13, 9]]) == [2, 4, 7, 8, 1, 1, 8, 16, 8, 7, 13, 9]", "assert flatten_list([[1, 2, 3], [9, 3, 8], [10, 7, 13], [10, 8, 13]]) == [1, 2, 3, 9, 3, 8, 10, 7, 13, 10, 8, 13]", "assert flatten_list([[1, 5, 8], [1, 9, 5], [5, 7, 9], [12, 11, 6]]) == [1, 5, 8, 1, 9, 5, 5, 7, 9, 12, 11, 6]", "assert flatten_list([[1, 3, 2], [3, 9, 10], [5, 11, 16], [11, 5, 5]]) == [1, 3, 2, 3, 9, 10, 5, 11, 16, 11, 5, 5]", "assert flatten_list([[3, 5, 4], [8, 6, 6], [9, 7, 16], [6, 7, 9]]) == [3, 5, 4, 8, 6, 6, 9, 7, 16, 6, 7, 9]", "assert flatten_list([[1, 1, 1], [2, 3, 7], [9, 13, 12], [9, 13, 7]]) == [1, 1, 1, 2, 3, 7, 9, 13, 12, 9, 13, 7]", "assert flatten_list([[4, 5, 3], [8, 4, 1], [8, 16, 11], [7, 11, 6]]) == [4, 5, 3, 8, 4, 1, 8, 16, 11, 7, 11, 6]", "assert flatten_list([[3, 2, 8], [4, 9, 4], [10, 7, 13], [2, 7, 13]]) == [3, 2, 8, 4, 9, 4, 10, 7, 13, 2, 7, 13]", "assert flatten_list([[4, 7, 5], [6, 5, 5], [12, 11, 12], [3, 13, 5]]) == [4, 7, 5, 6, 5, 5, 12, 11, 12, 3, 13, 5]", "assert flatten_list([[1, 1, 4], [6, 7, 8], [10, 16, 9], [3, 6, 10]]) == [1, 1, 4, 6, 7, 8, 10, 16, 9, 3, 6, 10]", "assert flatten_list([[6, 1, 7], [4, 5, 11], [8, 14, 11], [9, 8, 12]]) == [6, 1, 7, 4, 5, 11, 8, 14, 11, 9, 8, 12]", "assert flatten_list([[3, 4, 4], [8, 9, 6], [10, 6, 16], [8, 4, 11]]) == [3, 4, 4, 8, 9, 6, 10, 6, 16, 8, 4, 11]", "assert flatten_list([[2, 4, 8], [8, 10, 6], [5, 13, 8], [6, 3, 14]]) == [2, 4, 8, 8, 10, 6, 5, 13, 8, 6, 3, 14]", "assert flatten_list([[3, 7, 8], [8, 10, 4], [9, 9, 9], [9, 13, 7]]) == [3, 7, 8, 8, 10, 4, 9, 9, 9, 9, 13, 7]"], "entry_point": "flatten_list", "repair_prompt": ["Write a function flatten_list to flatten a given nested list structure. The function should handle lists with arbitrary levels of nesting.\nflatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n", " Write a function flatten_list to flatten a given nested list structure. The function should handle lists with arbitrary levels of nesting. The function should recursively traverse through the nested lists and collect all elements into a single list.\nflatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n", " Write a function flatten_list that recursively flattens a nested list, regardless of its depth, into a single list.\nflatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n"], "completions": ["from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Flattens a nested list structure.\n\n    Args:\n        nested_list (list): A list that may contain other lists as elements.\n\n    Returns:\n        list: A flattened list containing all elements from the nested list.\n    \"\"\"\n    result = []\n\n    def _flatten_list(sublist):\n        for item in sublist:\n            if isinstance(item, list):\n                _flatten_list(item)\n            else:\n                result.append(item)\n\n    _flatten_list(nested_list)\n    return result\n", "from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Flattens a nested list structure.\n\n    Args:\n        nested_list (list): A list that may contain other lists as elements.\n\n    Returns:\n        list: A flattened list containing all elements from the nested structure.\n    \"\"\"\n    result = []\n\n    def _flatten_list(sublist):\n        for item in sublist:\n            if isinstance(item, list):\n                _flatten_list(item)\n            else:\n                result.append(item)\n\n    _flatten_list(nested_list)\n    return result\n", "from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Flattens a nested list.\n\n    Args:\n        nested_list (list): A list that may contain other lists as elements.\n\n    Returns:\n        list: A flattened list with no nested lists.\n    \"\"\"\n    flattened_list = []\n\n    def _flatten(sublist):\n        for item in sublist:\n            if isinstance(item, list):\n                _flatten(item)\n            else:\n                flattened_list.append(item)\n\n    _flatten(nested_list)\n    return flattened_list\n", "from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Flattens a nested list.\n\n    Args:\n        nested_list (list): A list that may contain other lists as elements.\n\n    Returns:\n        list: A flattened list containing all elements from the nested list.\n    \"\"\"\n    result = []\n\n    def _flatten_list(sublist):\n        for item in sublist:\n            if isinstance(item, list):\n                _flatten_list(item)\n            else:\n                result.append(item)\n\n    _flatten_list(nested_list)\n    return result\n", "from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Flattens a nested list.\n\n    Args:\n        nested_list (list): A list that may contain other lists as elements.\n\n    Returns:\n        list: A flattened list with no nested lists.\n    \"\"\"\n    result = []\n\n    def _flatten_list(sublist):\n        for item in sublist:\n            if isinstance(item, list):\n                _flatten_list(item)\n            else:\n                result.append(item)\n\n    _flatten_list(nested_list)\n    return result\n", "from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Flattens a nested list to a single list.\n\n    Args:\n        nested_list (list): A list that may contain other lists as elements.\n\n    Returns:\n        list: A flattened list with no nested lists.\n    \"\"\"\n    result = []\n    \n    for item in nested_list:\n        if isinstance(item, list):\n            result.extend(flatten_list(item))\n        else:\n            result.append(item)\n    \n    return result\n", "from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Recursively flattens a nested list into a single list.\n\n    Args:\n        nested_list (list): The list to be flattened.\n\n    Returns:\n        list: A flattened list.\n    \"\"\"\n    result = []\n\n    def _flatten(sublist):\n        for item in sublist:\n            if isinstance(item, list):\n                _flatten(item)\n            else:\n                result.append(item)\n\n    _flatten(nested_list)\n    return result\n", "from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Flattens a nested list structure into a single list.\n\n    Args:\n        nested_list (list): A list containing elements, which can be either integers or nested lists.\n\n    Returns:\n        list: A flattened list containing all integers from the nested list.\n    \"\"\"\n    result = []\n\n    def _flatten_list(sublist):\n        for item in sublist:\n            if isinstance(item, list):\n                _flatten_list(item)\n            else:\n                result.append(item)\n\n    _flatten_list(nested_list)\n    return result\n", "from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Flattens a nested list into a single list.\n    \n    Args:\n        nested_list (list): The list to be flattened.\n        \n    Returns:\n        list: A flattened list.\n    \"\"\"\n    result = []\n    \n    def _flatten(sublist):\n        for item in sublist:\n            if isinstance(item, list):\n                _flatten(item)\n            else:\n                result.append(item)\n    \n    _flatten(nested_list)\n    return result\n", "from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Flattens a nested list structure.\n\n    Args:\n        nested_list (list): A list containing other lists as elements.\n\n    Returns:\n        list: A flattened list with all elements in the original order.\n    \"\"\"\n    def is_list(element):\n        \"\"\"\n        Checks if the element is a list.\n\n        Args:\n            element: The element to check.\n\n        Returns:\n            bool: True if the element is a list, False otherwise.\n        \"\"\"\n        return isinstance(element, list)\n\n    def flatten(lst):\n        \"\"\"\n        Recursively flattens the nested list.\n\n        Args:\n            lst (list): The list to flatten.\n\n        Yields:\n            The elements of the flattened list.\n        \"\"\"\n        for element in lst:\n            if is_list(element):\n                yield from flatten(element)\n            else:\n                yield element\n\n    return list(flatten(nested_list))\n\n# Example usage:\n# print(flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]))\n# Output: [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n"], "plans": ["requirement analysis:\nThe requirement is to create a function that can flatten any nested list structure, regardless of the depth of nesting. This function should be efficient and handle lists with arbitrary levels of nesting. The function should be compatible with Python's standard library and should be easy to integrate into existing projects.\nrequirement pool:\n- The main code should be simple and easy to understand.\n- The function should handle lists with arbitrary levels of nesting.\n- The function should be optimized for performance.\n- The function should be compatible with Python's standard library.\n- The function should include comprehensive testing to ensure reliability.\nTo create a function that can flatten any nested list structure, we will utilize Python's built-in functions and the itertools module. The function will recursively check each element of the list; if an element is a list, it will be flattened and concatenated with the rest of the elements. This approach ensures that the function can handle lists with arbitrary levels of nesting efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': a list that contains other lists as its elements.\n    Explanation: In the requirement, we are dealing with a list that can contain other lists within it, potentially at any depth. The goal is to flatten this structure into a single list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the flattening, we can use a recursive approach. We'll iterate through each element in the list. If an element is a list, we'll recursively call the flattening function on it. Otherwise, we'll add the element to our result list. This way, we ensure that all levels of nesting are flattened.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists and nested lists. The function should correctly flatten these to produce a single list with all elements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach already accounts for empty lists and nested lists.\n\n# [core concept]\n    'recursive': using a function that calls itself to solve a problem.\n    Explanation: In the plan, we are instructed to use a recursive approach to handle the arbitrary levels of nesting in the list. This is a core concept in programming where a function solves a problem by solving smaller instances of the same problem.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the flattening, we can define a helper function that takes a list as input. If an element is a list, we recursively call the helper function on it. Otherwise, we add the element to our result list. This ensures that all levels of nesting are flattened.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists and nested lists. The function should correctly flatten these to produce a single list with all elements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach already accounts for empty lists and nested lists.\n", "requirement analysis:\nThe requirement is to create a function that can flatten any nested list structure, regardless of the depth of nesting. This function should be efficient and handle large datasets without performance issues. The function should be compatible with Python's standard library and should be easy to integrate into existing projects.\nrequirement pool:\n- The main code should be written in Python.\n- The function should handle lists with arbitrary levels of nesting.\n- The function should be optimized for performance.\n- The function should be documented and include type hints.\n- The function should include unit tests to ensure reliability.\nTo create a function that can flatten any nested list structure, we will use a recursive approach. This method will iterate through each element in the list, and if an element is a list itself, it will recursively flatten it. We will use Python's built-in functions and the itertools library to efficiently handle the flattening process.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': a list that contains other lists as its elements.\n    Explanation: In the requirement, the function needs to handle lists that can contain other lists at any depth, which is a core concept of nested lists.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests a recursive approach to handle the nested lists. The steps include:\n    1. Iterate through each element in the list.\n    2. If the element is a list, recursively flatten it.\n    3. Append the flattened elements to the result list.\n    4. Return the final flattened list.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The edge case includes an empty list and lists with nested lists. The expected output is a flattened list containing all elements from the nested structure.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach in the plan naturally handles empty lists and nested lists without requiring additional code.\n\n# [core concept]\n    'recursive approach': a method where the solution to a problem depends on solutions to smaller instances of the same problem.\n    Explanation: The plan uses a recursive approach to handle the nested lists, which is a core concept of recursive programming.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests a recursive approach to handle the nested lists. The steps include:\n    1. Iterate through each element in the list.\n    2. If the element is a list, recursively flatten it.\n    3. Append the flattened elements to the result list.\n    4. Return the final flattened list.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The edge case includes an empty list and lists with nested lists. The expected output is a flattened list containing all elements from the nested structure.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach in the plan naturally handles empty lists and nested lists without requiring additional code.\n", "requirement analysis:\nThe requirement is to create a function that can flatten a nested list structure. This involves handling lists with varying levels of nesting, which can be achieved through recursive methods. The function should be efficient and capable of handling lists of arbitrary depth.\nrequirement pool:\n- Implement a recursive function to flatten the list.\n- Ensure the function can handle lists with multiple levels of nesting.\n- Optimize the function for readability and maintainability.\n- Test the function with various nested lists to ensure correctness.\n- Document the function with clear examples and usage instructions.\nTo implement the `flatten_list` function, we will use a recursive approach to handle the nested lists. This method will involve iterating through each element in the list, and if an element is a list itself, we will recursively call the function on that element. This approach ensures that we can handle lists with arbitrary levels of nesting efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': a list that contains other lists as its elements.\n    Explanation: In the requirement, the function needs to handle lists that can contain other lists within them, potentially at any depth.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests a recursive approach to handle the nested lists. The steps include:\n    1. Iterate through each element in the list.\n    2. If the element is a list, recursively call the function on that element.\n    3. If the element is not a list, add it to the result list.\n    4. Return the flattened list.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The edge case includes an empty list and nested lists. The function should handle these by skipping empty lists and recursively flattening nested lists.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach in the plan naturally handles empty lists and nested structures.\n\n# [core concept]\n    'recursive': a method of solving a problem by having a function call itself to solve a smaller instance of the same problem.\n    Explanation: The plan suggests using recursion to handle the nested lists, which is a core concept in programming for solving complex structures.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests a recursive approach to handle the nested lists. The steps include:\n    1. Iterate through each element in the list.\n    2. If the element is a list, recursively call the function on that element.\n    3. If the element is not a list, add it to the result list.\n    4. Return the flattened list.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The edge case includes an empty list and nested lists. The function should handle these by skipping empty lists and recursively flattening nested lists.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach in the plan naturally handles empty lists and nested structures.\n", "requirement analysis:\nThe requirement is to create a function that can flatten any nested list structure. This involves handling lists with arbitrary levels of nesting, which requires a recursive approach to traverse through the nested lists and collect all elements into a single list. The function should be efficient and handle large lists without excessive memory usage.\nrequirement pool:\n- Implement a recursive function to handle arbitrary levels of nesting.\n- Ensure the function can handle large lists efficiently.\n- Optimize memory usage to prevent excessive memory consumption.\n- Provide clear and concise documentation for easy understanding and usage.\n- Test the function with various nested list structures to ensure reliability.\nTo implement the `flatten_list` function, we will use a recursive approach to traverse through the nested lists. This method will allow us to handle lists with arbitrary levels of nesting efficiently. We will ensure that the function can handle large lists without excessive memory usage by using a generator to yield elements one at a time, which will help in conserving memory.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': a list that contains other lists as its elements.\n    Explanation: In the requirement, the function needs to handle lists that can contain other lists within them, potentially at any depth. This concept is crucial for understanding how to traverse and flatten such structures.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the `flatten_list` function, we will use a recursive approach to traverse through the nested lists. This method will allow us to handle lists with arbitrary levels of nesting efficiently. We will ensure that the function can handle large lists without excessive memory usage by using a generator to yield elements one at a time, which will help in conserving memory.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists and nested lists. The function should correctly flatten these structures to produce a single list containing all elements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach will naturally handle cases where the nested lists are empty or contain other nested lists.\n\n# [core concept]\n    'recursive approach': a method of solving a problem by breaking it down into smaller, similar subproblems, and then solving each subproblem by applying the same technique.\n    Explanation: The requirement specifies a recursive approach to handle the nested lists. This means the function will call itself with smaller instances of the problem until it reaches a base case, which in this context might be a list without any nested lists.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the `flatten_list` function using recursion, we will define a helper function that takes a list as input. If the list contains nested lists, the function will iterate through each element. If an element is a list, the function will call itself with this element as the argument. If an element is not a list, it will be added to the result. This process will continue until all nested lists are flattened.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists and nested lists. The function should correctly flatten these structures to produce a single list containing all elements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach will naturally handle cases where the nested lists are empty or contain other nested lists.\n", "requirement analysis:\nThe requirement is to create a function that can flatten any nested list structure, regardless of the depth of nesting. This involves a recursive approach to traverse through all levels of the list and collect all elements into a single list. The function should be efficient and handle large lists without excessive memory usage.\nrequirement pool:\n- Implement a recursive function to flatten the list structure.\n- Ensure the function can handle lists with arbitrary levels of nesting.\n- Optimize memory usage to handle large lists efficiently.\n- Provide clear and concise documentation for easy understanding and usage.\n- Test the function with various nested list structures to ensure reliability.\nTo implement the `flatten_list` function, we will use a recursive approach to traverse through the nested lists. We will iterate through each element in the list, and if an element is a list, we will recursively call the function on that element. Otherwise, we will add the element to our result list. This approach ensures that we handle lists with arbitrary levels of nesting efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': a list that contains other lists as its elements.\n    Explanation: In the requirement, the function needs to handle lists that can contain other lists within them, potentially at any depth.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests a recursive approach to handle the nested lists. The steps include:\n    1. Iterate through each element in the list.\n    2. If the element is a list, recursively call the function on that element.\n    3. If the element is not a list, add it to the result list.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists and nested lists. The function should flatten these into a single list, ignoring empty lists.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach inherently handles cases where the list contains empty lists or multiple levels of nesting.\n\n# [core concept]\n    'recursive': a programming technique where a function calls itself in order to solve a problem by breaking it down into smaller instances of the same problem.\n    Explanation: In the requirement, the function needs to handle lists with arbitrary levels of nesting, which is a perfect use case for recursion.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests a recursive approach to handle the nested lists. The steps include:\n    1. Iterate through each element in the list.\n    2. If the element is a list, recursively call the function on that element.\n    3. If the element is not a list, add it to the result list.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists and nested lists. The function should flatten these into a single list, ignoring empty lists.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach inherently handles cases where the list contains empty lists or multiple levels of nesting.\n", "requirement analysis:\nThe requirement is clear and straightforward. The function needs to handle lists with arbitrary levels of nesting, which requires a recursive approach. The function should be efficient and handle large lists without excessive memory usage. The output should be a single flattened list.\nrequirement pool:\n- Implement a recursive function to handle arbitrary levels of nesting.\n- Ensure the function is efficient and handles large lists without excessive memory usage.\n- Return a single flattened list as the output.\n- Add optional parameters for specifying the depth of flattening if needed.\n- Include error handling for non-list inputs to ensure robustness.\nWe will implement the `flatten_list` function using a recursive approach to handle arbitrary levels of nesting. The function will iterate through each element in the input list, checking if it is a list. If it is, the function will recursively call itself on that sublist. If it is not a list, the element will be added to the result list. The function will also include error handling to ensure that non-list inputs are handled gracefully.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': a list that contains other lists as its elements.\n    Explanation: In the requirement, the function needs to handle lists that can be nested to any depth, meaning elements can be lists themselves, and these sublists can also contain lists, and so on.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The function will use a recursive approach to flatten the list. Here's a detailed logic:\n    1. Define the `flatten_list` function.\n    2. Initialize an empty list to store the flattened elements.\n    3. Iterate through each element in the input list.\n    4. If the element is a list, recursively call `flatten_list` on this sublist and extend the result to the main result list.\n    5. If the element is not a list, append it directly to the result list.\n    6. Return the result list after the iteration is complete.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists and nested lists. The function should handle these cases by recursively flattening each sublist and collecting all elements into a single list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach will naturally handle cases where there are empty lists or deeply nested lists.\n\n# [code logic continued]\n    Here's the Python code to implement the logic:\n\n    ```python\n    def flatten_list(nested_list):\n        result = []\n        for item in nested_list:\n            if isinstance(item, list):\n                result.extend(flatten_list(item))\n            else:\n                result.append(item)\n        return result\n    ```\n", "requirement analysis:\nThe requirement is to create a function that can flatten any nested list into a single list. This includes handling lists within lists within lists, and ensuring the function is efficient and easy to use. The function should be able to handle various depths of nesting and should be robust against errors such as non-list elements.\nrequirement pool:\n- The main code should be simple and easy to understand.\n- The function should handle lists of varying depths.\n- Ensure the function is optimized for performance.\n- Implement error handling for non-list elements.\n- Provide clear documentation and examples for user guidance.\nTo create a function that can recursively flatten any nested list into a single list, we will use a simple and efficient approach. We will utilize Python's built-in functions and itertools to handle the flattening process. The function will iterate through each element of the list, and if an element is a list, it will recursively flatten it. Otherwise, it will add the element to the result list. This approach ensures that the function can handle lists of varying depths and is optimized for performance.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'recursion': the process of a function calling itself to solve a problem by breaking it down into smaller instances of the same problem.\n    'flattening': the process of converting a nested structure into a single list, disregarding the original structure.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The function will use a recursive approach to flatten the nested list. Here's a detailed logic:\n    1. Define the function `flatten_list` that takes a list as an argument.\n    2. Initialize an empty list to store the flattened result.\n    3. Iterate through each element in the input list.\n    4. If an element is a list, recursively call `flatten_list` on that element and extend the result list with the returned flattened list.\n    5. If an element is not a list, append it to the result list.\n    6. Return the result list after the iteration is complete.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists and nested lists. The function should handle these cases by recursively flattening each nested list and ignoring empty lists.\n    flatten_list([1, [2, [3, [4, 5]]], 6]) = [1, 2, 3, 4, 5, 6]\n    Explanation: The input list contains a nested structure with varying depths. The function should correctly flatten all levels of nesting.\n    flatten_list([1, 2, 3, 4, 5]) = [1, 2, 3, 4, 5]\n    Explanation: The input list is already flat, so the function should return it as is.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The recursive approach in the code logic is sufficient to handle lists with varying depths and empty lists.\n", "requirement analysis:\nThe requirement is to create a function that can flatten any nested list structure into a single list. This includes handling lists within lists, within lists, and so on. The function should be able to handle different depths of nesting and should be efficient in terms of both time and space complexity.\nrequirement pool:\n- The main code should be able to handle any level of nesting in the input list.\n- The function should be able to handle mixed data types without errors.\n- The function should be optimized for performance, especially with large datasets.\n- The function should be tested for edge cases, such as empty lists and lists with non-list elements.\n- The documentation should clearly explain how to use the function and its limitations.\nTo create a function that can recursively flatten any nested list structure into a single list, we will use a combination of Python's built-in functions and a simple iterative approach. This method ensures efficiency and scalability, making it suitable for handling deeply nested lists and large datasets.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'recursion': the process of a function calling itself to solve a problem by breaking it down into smaller instances of the same problem.\n    Explanation: In the requirement, the function `flatten_list` needs to handle nested lists of unknown depth. By using recursion, the function can call itself on each nested list until all elements are flattened into a single list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests a clear iterative approach to recursion for flattening the list. The steps include:\n    1. Iterate through each element in the list.\n    2. If an element is a list, recursively call the function on that element.\n    3. If an element is not a list, add it to the result list.\n    4. Continue until all elements are processed.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists and nested lists. The function should handle these cases by recursively flattening each nested list and ignoring empty lists.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic already accounts for empty lists by simply ignoring them during the iteration process.\n\n# [core concept]\n    'recursion': the process of a function calling itself to solve a problem by breaking it down into smaller instances of the same problem.\n    Explanation: In the requirement, the function `flatten_list` needs to handle nested lists of unknown depth. By using recursion, the function can call itself on each nested list until all elements are flattened into a single list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests a clear iterative approach to recursion for flattening the list. The steps include:\n    1. Iterate through each element in the list.\n    2. If an element is a list, recursively call the function on that element.\n    3. If an element is not a list, add it to the result list.\n    4. Continue until all elements are processed.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists and nested lists. The function should handle these cases by recursively flattening each nested list and ignoring empty lists.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic already accounts for empty lists by simply ignoring them during the iteration process.\n", "requirement analysis:\nThe requirement is to create a function that can flatten any nested list, regardless of its depth, into a single list. This function should be efficient and handle mixed data types without errors. The solution should also be robust enough to handle large datasets without crashing.\nrequirement pool:\n- The main code should be able to handle deeply nested lists efficiently.\n- The function should work with mixed data types without errors.\n- The solution should be optimized for performance, especially for large datasets.\n- The function should be well-documented and easy to understand.\n- The solution should include tests to ensure reliability.\nTo create a function that can flatten any nested list, regardless of its depth, into a single list efficiently, we will utilize Python's built-in capabilities and leverage the itertools library for handling the flattening process. The itertools library provides a powerful way to create iterators for efficient looping, which will be particularly useful for handling deeply nested lists. We will ensure that the function can handle mixed data types gracefully and is optimized for performance, making it suitable for large datasets.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'recursively flatten a nested list'\n    This means that the function should be able to handle lists within lists within lists, and it should continue to flatten them until there are no more nested lists.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To recursively flatten a nested list, we can use a helper function that checks each element of the list. If the element is a list, we recursively call the function on that element. If the element is not a list, we add it to the result list. This process continues until all elements have been processed.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists and nested lists. The function should flatten these into a single list, ignoring empty lists and including all other elements.\n    flatten_list([1, [2, [3, [4, 5]]], 6]) = [1, 2, 3, 4, 5, 6]\n    Explanation: The input list contains a nested structure. The function should flatten all levels of nesting into a single list.\n    flatten_list([[1, 2], [3, 4], [5, 6]]) = [1, 2, 3, 4, 5, 6]\n    Explanation: The input list contains multiple nested lists. The function should flatten all levels of nesting into a single list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic already handles empty lists and nested lists appropriately.\n", "requirement analysis:\nThe requirement is to create a function that can flatten any nested list structure, regardless of the depth of nesting. This function should be efficient and handle large datasets without performance issues. It should be compatible with Python's standard library and other common data manipulation tools.\nrequirement pool:\n- The main code should be simple and easy to understand.\n- The function should handle arbitrary levels of nesting.\n- The function should be optimized for performance.\n- The function should be compatible with Python's standard library.\n- The function should handle large datasets efficiently.\nWe will use a recursive approach to flatten the nested list structure. This method will be efficient and handle arbitrary levels of nesting. The function will utilize Python's built-in list and generator functions to achieve the desired result.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': a list that contains other lists as its elements\n    'flatten': to simplify a structure by removing nested layers, resulting in a single, flat list\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The function will recursively traverse the nested list, and for each element, it will check if the element is a list. If it is, the function will call itself with this sublist as the argument. If it's not a list, the element will be added to the result list. This process will continue until all levels of nesting are removed.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists and nested lists. The function should ignore these empty lists and correctly flatten the nested list structure.\n    flatten_list([1, [2, [3, [4, 5]]], 6]) = [1, 2, 3, 4, 5, 6]\n    Explanation: The function should handle multiple levels of nesting and correctly flatten the entire structure into a single list.\n    flatten_list([[1, 2], [[3, 4], [5, 6]]]) = [1, 2, 3, 4, 5, 6]\n    Explanation: The function should handle lists with two levels of nesting and ensure all elements are included in the final flattened list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The recursive approach will naturally handle cases with empty lists and multiple levels of nesting without additional code.\n"], "test": ["def check(flatten_list):\n\tassert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]", "def check(flatten_list):\n\tassert flatten_list([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]])==[10, 20, 40, 30, 56, 25, 10, 20, 33, 40]", "def check(flatten_list):\n\tassert flatten_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])==[1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]", "def check(flatten_list):\n\tassert flatten_list([5, 15, [17, 25], 39, 49, [65, 69, 78], [86, 97, 110, 123]]) == [5, 15, 17, 25, 39, 49, 65, 69, 78, 86, 97, 110, 123]", "def check(flatten_list):\n\tassert flatten_list([5, 7, [15, 33], 39, 45, [65, 75, 82], [92, 104, 115, 116]]) == [5, 7, 15, 33, 39, 45, 65, 75, 82, 92, 104, 115, 116]", "def check(flatten_list):\n\tassert flatten_list([2, 9, [22, 28], 35, 52, [58, 68, 81], [87, 100, 105, 117]]) == [2, 9, 22, 28, 35, 52, 58, 68, 81, 87, 100, 105, 117]", "def check(flatten_list):\n\tassert flatten_list([5, 10, [24, 29], 42, 49, [65, 72, 85], [92, 97, 105, 119]]) == [5, 10, 24, 29, 42, 49, 65, 72, 85, 92, 97, 105, 119]", "def check(flatten_list):\n\tassert flatten_list([5, 15, [24, 32], 36, 50, [63, 74, 78], [85, 101, 113, 115]]) == [5, 15, 24, 32, 36, 50, 63, 74, 78, 85, 101, 113, 115]", "def check(flatten_list):\n\tassert flatten_list([4, 11, [15, 25], 37, 51, [64, 74, 82], [94, 101, 110, 117]]) == [4, 11, 15, 25, 37, 51, 64, 74, 82, 94, 101, 110, 117]", "def check(flatten_list):\n\tassert flatten_list([1, 10, [17, 26], 39, 49, [65, 75, 77], [87, 103, 112, 121]]) == [1, 10, 17, 26, 39, 49, 65, 75, 77, 87, 103, 112, 121]", "def check(flatten_list):\n\tassert flatten_list([3, 7, [24, 25], 43, 45, [55, 69, 83], [90, 105, 108, 121]]) == [3, 7, 24, 25, 43, 45, 55, 69, 83, 90, 105, 108, 121]", "def check(flatten_list):\n\tassert flatten_list([5, 15, [16, 34], 37, 49, [61, 68, 84], [95, 95, 114, 125]]) == [5, 15, 16, 34, 37, 49, 61, 68, 84, 95, 95, 114, 125]", "def check(flatten_list):\n\tassert flatten_list([3, 5, [20, 29], 35, 48, [56, 71, 85], [85, 104, 108, 122]]) == [3, 5, 20, 29, 35, 48, 56, 71, 85, 85, 104, 108, 122]", "def check(flatten_list):\n\tassert flatten_list([1, 11, [22, 26], 45, 53, [61, 74, 83], [90, 97, 113, 118]]) == [1, 11, 22, 26, 45, 53, 61, 74, 83, 90, 97, 113, 118]", "def check(flatten_list):\n\tassert flatten_list([5, 8, [15, 32], 41, 50, [56, 75, 82], [90, 104, 114, 125]]) == [5, 8, 15, 32, 41, 50, 56, 75, 82, 90, 104, 114, 125]", "def check(flatten_list):\n\tassert flatten_list([4, 8, [23, 27], 36, 55, [60, 71, 78], [85, 105, 108, 125]]) == [4, 8, 23, 27, 36, 55, 60, 71, 78, 85, 105, 108, 125]", "def check(flatten_list):\n\tassert flatten_list([2, 11, [22, 34], 41, 48, [65, 68, 82], [85, 101, 108, 124]]) == [2, 11, 22, 34, 41, 48, 65, 68, 82, 85, 101, 108, 124]", "def check(flatten_list):\n\tassert flatten_list([4, 11, [19, 35], 37, 55, [63, 70, 75], [95, 97, 108, 116]]) == [4, 11, 19, 35, 37, 55, 63, 70, 75, 95, 97, 108, 116]", "def check(flatten_list):\n\tassert flatten_list([1, 13, [16, 28], 40, 46, [62, 72, 78], [95, 101, 109, 117]]) == [1, 13, 16, 28, 40, 46, 62, 72, 78, 95, 101, 109, 117]", "def check(flatten_list):\n\tassert flatten_list([3, 9, [23, 27], 38, 53, [63, 71, 79], [93, 104, 111, 117]]) == [3, 9, 23, 27, 38, 53, 63, 71, 79, 93, 104, 111, 117]", "def check(flatten_list):\n\tassert flatten_list([2, 15, [15, 35], 37, 51, [57, 68, 75], [90, 96, 112, 116]]) == [2, 15, 15, 35, 37, 51, 57, 68, 75, 90, 96, 112, 116]", "def check(flatten_list):\n\tassert flatten_list([2, 6, [23, 35], 43, 52, [56, 69, 75], [86, 95, 112, 120]]) == [2, 6, 23, 35, 43, 52, 56, 69, 75, 86, 95, 112, 120]", "def check(flatten_list):\n\tassert flatten_list([5, 7, [23, 33], 44, 48, [63, 71, 76], [85, 104, 114, 117]]) == [5, 7, 23, 33, 44, 48, 63, 71, 76, 85, 104, 114, 117]", "def check(flatten_list):\n\tassert flatten_list([2, 12, [20, 35], 35, 48, [57, 72, 76], [85, 95, 105, 119]]) == [2, 12, 20, 35, 35, 48, 57, 72, 76, 85, 95, 105, 119]", "def check(flatten_list):\n\tassert flatten_list([5, 8, [23, 25], 45, 48, [57, 75, 80], [90, 98, 108, 120]]) == [5, 8, 23, 25, 45, 48, 57, 75, 80, 90, 98, 108, 120]", "def check(flatten_list):\n\tassert flatten_list([2, 13, [19, 26], 35, 51, [64, 70, 80], [92, 100, 107, 115]]) == [2, 13, 19, 26, 35, 51, 64, 70, 80, 92, 100, 107, 115]", "def check(flatten_list):\n\tassert flatten_list([2, 11, [19, 29], 44, 53, [58, 71, 82], [93, 103, 111, 116]]) == [2, 11, 19, 29, 44, 53, 58, 71, 82, 93, 103, 111, 116]", "def check(flatten_list):\n\tassert flatten_list([4, 14, [19, 32], 44, 45, [59, 74, 84], [93, 97, 115, 122]]) == [4, 14, 19, 32, 44, 45, 59, 74, 84, 93, 97, 115, 122]", "def check(flatten_list):\n\tassert flatten_list([2, 10, [16, 35], 43, 54, [64, 75, 85], [86, 98, 106, 116]]) == [2, 10, 16, 35, 43, 54, 64, 75, 85, 86, 98, 106, 116]", "def check(flatten_list):\n\tassert flatten_list([2, 8, [16, 31], 36, 49, [55, 68, 77], [94, 103, 105, 124]]) == [2, 8, 16, 31, 36, 49, 55, 68, 77, 94, 103, 105, 124]", "def check(flatten_list):\n\tassert flatten_list([1, 13, [22, 26], 37, 46, [61, 73, 81], [90, 103, 107, 124]]) == [1, 13, 22, 26, 37, 46, 61, 73, 81, 90, 103, 107, 124]", "def check(flatten_list):\n\tassert flatten_list([3, 14, [22, 26], 44, 45, [56, 73, 85], [89, 103, 112, 121]]) == [3, 14, 22, 26, 44, 45, 56, 73, 85, 89, 103, 112, 121]", "def check(flatten_list):\n\tassert flatten_list([3, 11, [20, 26], 38, 53, [59, 65, 76], [93, 99, 114, 122]]) == [3, 11, 20, 26, 38, 53, 59, 65, 76, 93, 99, 114, 122]", "def check(flatten_list):\n\tassert flatten_list([4, 6, [16, 31], 42, 48, [55, 67, 85], [86, 97, 112, 124]]) == [4, 6, 16, 31, 42, 48, 55, 67, 85, 86, 97, 112, 124]", "def check(flatten_list):\n\tassert flatten_list([5, 9, [16, 26], 35, 49, [65, 74, 77], [91, 98, 109, 119]]) == [5, 9, 16, 26, 35, 49, 65, 74, 77, 91, 98, 109, 119]", "def check(flatten_list):\n\tassert flatten_list([4, 5, [25, 25], 45, 55, [63, 68, 77], [91, 105, 105, 118]]) == [4, 5, 25, 25, 45, 55, 63, 68, 77, 91, 105, 105, 118]", "def check(flatten_list):\n\tassert flatten_list([[11, 21], [42], [28, 57, 26], [11, 16], [36], [37]]) == [11, 21, 42, 28, 57, 26, 11, 16, 36, 37]", "def check(flatten_list):\n\tassert flatten_list([[10, 23], [40], [31, 51, 25], [15, 18], [37], [43]]) == [10, 23, 40, 31, 51, 25, 15, 18, 37, 43]", "def check(flatten_list):\n\tassert flatten_list([[6, 21], [37], [30, 61, 29], [7, 22], [33], [41]]) == [6, 21, 37, 30, 61, 29, 7, 22, 33, 41]", "def check(flatten_list):\n\tassert flatten_list([[12, 23], [39], [33, 53, 22], [10, 22], [38], [43]]) == [12, 23, 39, 33, 53, 22, 10, 22, 38, 43]", "def check(flatten_list):\n\tassert flatten_list([[11, 17], [40], [31, 57, 24], [9, 15], [30], [43]]) == [11, 17, 40, 31, 57, 24, 9, 15, 30, 43]", "def check(flatten_list):\n\tassert flatten_list([[15, 20], [35], [27, 55, 28], [13, 21], [38], [39]]) == [15, 20, 35, 27, 55, 28, 13, 21, 38, 39]", "def check(flatten_list):\n\tassert flatten_list([[13, 22], [35], [31, 54, 27], [15, 24], [37], [41]]) == [13, 22, 35, 31, 54, 27, 15, 24, 37, 41]", "def check(flatten_list):\n\tassert flatten_list([[12, 23], [43], [32, 55, 27], [5, 18], [32], [43]]) == [12, 23, 43, 32, 55, 27, 5, 18, 32, 43]", "def check(flatten_list):\n\tassert flatten_list([[8, 21], [40], [30, 61, 21], [11, 22], [33], [42]]) == [8, 21, 40, 30, 61, 21, 11, 22, 33, 42]", "def check(flatten_list):\n\tassert flatten_list([[11, 20], [39], [28, 60, 27], [8, 22], [31], [42]]) == [11, 20, 39, 28, 60, 27, 8, 22, 31, 42]", "def check(flatten_list):\n\tassert flatten_list([[6, 19], [39], [31, 53, 24], [8, 23], [33], [42]]) == [6, 19, 39, 31, 53, 24, 8, 23, 33, 42]", "def check(flatten_list):\n\tassert flatten_list([[9, 23], [37], [29, 55, 23], [15, 18], [35], [36]]) == [9, 23, 37, 29, 55, 23, 15, 18, 35, 36]", "def check(flatten_list):\n\tassert flatten_list([[13, 23], [44], [28, 52, 24], [11, 17], [29], [40]]) == [13, 23, 44, 28, 52, 24, 11, 17, 29, 40]", "def check(flatten_list):\n\tassert flatten_list([[11, 21], [36], [35, 60, 24], [7, 15], [29], [39]]) == [11, 21, 36, 35, 60, 24, 7, 15, 29, 39]", "def check(flatten_list):\n\tassert flatten_list([[6, 20], [35], [30, 51, 21], [13, 19], [31], [35]]) == [6, 20, 35, 30, 51, 21, 13, 19, 31, 35]", "def check(flatten_list):\n\tassert flatten_list([[14, 18], [40], [26, 53, 30], [11, 24], [34], [36]]) == [14, 18, 40, 26, 53, 30, 11, 24, 34, 36]", "def check(flatten_list):\n\tassert flatten_list([[15, 16], [43], [26, 60, 25], [8, 20], [28], [37]]) == [15, 16, 43, 26, 60, 25, 8, 20, 28, 37]", "def check(flatten_list):\n\tassert flatten_list([[7, 25], [35], [25, 51, 26], [8, 21], [29], [45]]) == [7, 25, 35, 25, 51, 26, 8, 21, 29, 45]", "def check(flatten_list):\n\tassert flatten_list([[13, 23], [44], [35, 56, 27], [12, 16], [31], [45]]) == [13, 23, 44, 35, 56, 27, 12, 16, 31, 45]", "def check(flatten_list):\n\tassert flatten_list([[9, 18], [39], [30, 61, 29], [9, 20], [31], [41]]) == [9, 18, 39, 30, 61, 29, 9, 20, 31, 41]", "def check(flatten_list):\n\tassert flatten_list([[12, 16], [45], [33, 54, 24], [13, 19], [38], [43]]) == [12, 16, 45, 33, 54, 24, 13, 19, 38, 43]", "def check(flatten_list):\n\tassert flatten_list([[14, 23], [38], [30, 58, 24], [7, 16], [37], [43]]) == [14, 23, 38, 30, 58, 24, 7, 16, 37, 43]", "def check(flatten_list):\n\tassert flatten_list([[6, 17], [45], [26, 58, 23], [8, 18], [32], [36]]) == [6, 17, 45, 26, 58, 23, 8, 18, 32, 36]", "def check(flatten_list):\n\tassert flatten_list([[15, 19], [43], [26, 57, 28], [7, 22], [34], [39]]) == [15, 19, 43, 26, 57, 28, 7, 22, 34, 39]", "def check(flatten_list):\n\tassert flatten_list([[6, 16], [37], [25, 61, 25], [8, 20], [36], [42]]) == [6, 16, 37, 25, 61, 25, 8, 20, 36, 42]", "def check(flatten_list):\n\tassert flatten_list([[12, 15], [41], [33, 60, 24], [10, 18], [33], [38]]) == [12, 15, 41, 33, 60, 24, 10, 18, 33, 38]", "def check(flatten_list):\n\tassert flatten_list([[13, 18], [35], [26, 51, 22], [13, 19], [31], [45]]) == [13, 18, 35, 26, 51, 22, 13, 19, 31, 45]", "def check(flatten_list):\n\tassert flatten_list([[15, 22], [39], [29, 53, 20], [9, 22], [29], [36]]) == [15, 22, 39, 29, 53, 20, 9, 22, 29, 36]", "def check(flatten_list):\n\tassert flatten_list([[8, 15], [40], [25, 52, 23], [7, 18], [33], [35]]) == [8, 15, 40, 25, 52, 23, 7, 18, 33, 35]", "def check(flatten_list):\n\tassert flatten_list([[11, 24], [39], [34, 53, 29], [5, 17], [33], [35]]) == [11, 24, 39, 34, 53, 29, 5, 17, 33, 35]", "def check(flatten_list):\n\tassert flatten_list([[14, 24], [43], [27, 58, 20], [9, 16], [35], [40]]) == [14, 24, 43, 27, 58, 20, 9, 16, 35, 40]", "def check(flatten_list):\n\tassert flatten_list([[9, 21], [44], [32, 54, 21], [10, 15], [36], [36]]) == [9, 21, 44, 32, 54, 21, 10, 15, 36, 36]", "def check(flatten_list):\n\tassert flatten_list([[6, 18], [35], [32, 54, 25], [11, 23], [30], [42]]) == [6, 18, 35, 32, 54, 25, 11, 23, 30, 42]", "def check(flatten_list):\n\tassert flatten_list([[3, 4, 4], [9, 7, 8], [10, 15, 16], [11, 4, 12]]) == [3, 4, 4, 9, 7, 8, 10, 15, 16, 11, 4, 12]", "def check(flatten_list):\n\tassert flatten_list([[4, 1, 4], [3, 1, 5], [13, 11, 8], [10, 3, 4]]) == [4, 1, 4, 3, 1, 5, 13, 11, 8, 10, 3, 4]", "def check(flatten_list):\n\tassert flatten_list([[3, 1, 3], [1, 6, 4], [13, 6, 16], [11, 12, 10]]) == [3, 1, 3, 1, 6, 4, 13, 6, 16, 11, 12, 10]", "def check(flatten_list):\n\tassert flatten_list([[3, 2, 7], [7, 9, 8], [14, 8, 7], [5, 6, 8]]) == [3, 2, 7, 7, 9, 8, 14, 8, 7, 5, 6, 8]", "def check(flatten_list):\n\tassert flatten_list([[4, 1, 2], [9, 6, 2], [9, 15, 17], [9, 5, 13]]) == [4, 1, 2, 9, 6, 2, 9, 15, 17, 9, 5, 13]", "def check(flatten_list):\n\tassert flatten_list([[1, 2, 2], [8, 1, 7], [10, 14, 12], [11, 11, 10]]) == [1, 2, 2, 8, 1, 7, 10, 14, 12, 11, 11, 10]", "def check(flatten_list):\n\tassert flatten_list([[2, 7, 2], [8, 4, 3], [10, 10, 13], [3, 3, 5]]) == [2, 7, 2, 8, 4, 3, 10, 10, 13, 3, 3, 5]", "def check(flatten_list):\n\tassert flatten_list([[3, 6, 5], [2, 1, 8], [6, 16, 16], [4, 13, 7]]) == [3, 6, 5, 2, 1, 8, 6, 16, 16, 4, 13, 7]", "def check(flatten_list):\n\tassert flatten_list([[2, 3, 1], [8, 9, 2], [15, 16, 8], [7, 9, 6]]) == [2, 3, 1, 8, 9, 2, 15, 16, 8, 7, 9, 6]", "def check(flatten_list):\n\tassert flatten_list([[3, 3, 8], [6, 6, 11], [15, 6, 10], [8, 4, 13]]) == [3, 3, 8, 6, 6, 11, 15, 6, 10, 8, 4, 13]", "def check(flatten_list):\n\tassert flatten_list([[2, 2, 2], [5, 4, 4], [14, 8, 11], [3, 11, 13]]) == [2, 2, 2, 5, 4, 4, 14, 8, 11, 3, 11, 13]", "def check(flatten_list):\n\tassert flatten_list([[2, 2, 8], [7, 9, 6], [8, 6, 17], [9, 9, 12]]) == [2, 2, 8, 7, 9, 6, 8, 6, 17, 9, 9, 12]", "def check(flatten_list):\n\tassert flatten_list([[2, 4, 3], [1, 4, 10], [10, 8, 14], [10, 8, 4]]) == [2, 4, 3, 1, 4, 10, 10, 8, 14, 10, 8, 4]", "def check(flatten_list):\n\tassert flatten_list([[1, 1, 1], [5, 5, 1], [12, 12, 9], [4, 4, 10]]) == [1, 1, 1, 5, 5, 1, 12, 12, 9, 4, 4, 10]", "def check(flatten_list):\n\tassert flatten_list([[5, 1, 5], [6, 5, 10], [8, 14, 12], [10, 9, 14]]) == [5, 1, 5, 6, 5, 10, 8, 14, 12, 10, 9, 14]", "def check(flatten_list):\n\tassert flatten_list([[1, 2, 2], [5, 4, 11], [14, 11, 16], [6, 12, 9]]) == [1, 2, 2, 5, 4, 11, 14, 11, 16, 6, 12, 9]", "def check(flatten_list):\n\tassert flatten_list([[3, 2, 3], [2, 8, 11], [13, 16, 9], [2, 7, 13]]) == [3, 2, 3, 2, 8, 11, 13, 16, 9, 2, 7, 13]", "def check(flatten_list):\n\tassert flatten_list([[2, 6, 6], [1, 4, 5], [5, 11, 10], [3, 12, 6]]) == [2, 6, 6, 1, 4, 5, 5, 11, 10, 3, 12, 6]", "def check(flatten_list):\n\tassert flatten_list([[5, 6, 8], [6, 4, 8], [5, 11, 10], [8, 8, 4]]) == [5, 6, 8, 6, 4, 8, 5, 11, 10, 8, 8, 4]", "def check(flatten_list):\n\tassert flatten_list([[2, 4, 7], [8, 1, 1], [8, 16, 8], [7, 13, 9]]) == [2, 4, 7, 8, 1, 1, 8, 16, 8, 7, 13, 9]", "def check(flatten_list):\n\tassert flatten_list([[1, 2, 3], [9, 3, 8], [10, 7, 13], [10, 8, 13]]) == [1, 2, 3, 9, 3, 8, 10, 7, 13, 10, 8, 13]", "def check(flatten_list):\n\tassert flatten_list([[1, 5, 8], [1, 9, 5], [5, 7, 9], [12, 11, 6]]) == [1, 5, 8, 1, 9, 5, 5, 7, 9, 12, 11, 6]", "def check(flatten_list):\n\tassert flatten_list([[1, 3, 2], [3, 9, 10], [5, 11, 16], [11, 5, 5]]) == [1, 3, 2, 3, 9, 10, 5, 11, 16, 11, 5, 5]", "def check(flatten_list):\n\tassert flatten_list([[3, 5, 4], [8, 6, 6], [9, 7, 16], [6, 7, 9]]) == [3, 5, 4, 8, 6, 6, 9, 7, 16, 6, 7, 9]", "def check(flatten_list):\n\tassert flatten_list([[1, 1, 1], [2, 3, 7], [9, 13, 12], [9, 13, 7]]) == [1, 1, 1, 2, 3, 7, 9, 13, 12, 9, 13, 7]", "def check(flatten_list):\n\tassert flatten_list([[4, 5, 3], [8, 4, 1], [8, 16, 11], [7, 11, 6]]) == [4, 5, 3, 8, 4, 1, 8, 16, 11, 7, 11, 6]", "def check(flatten_list):\n\tassert flatten_list([[3, 2, 8], [4, 9, 4], [10, 7, 13], [2, 7, 13]]) == [3, 2, 8, 4, 9, 4, 10, 7, 13, 2, 7, 13]", "def check(flatten_list):\n\tassert flatten_list([[4, 7, 5], [6, 5, 5], [12, 11, 12], [3, 13, 5]]) == [4, 7, 5, 6, 5, 5, 12, 11, 12, 3, 13, 5]", "def check(flatten_list):\n\tassert flatten_list([[1, 1, 4], [6, 7, 8], [10, 16, 9], [3, 6, 10]]) == [1, 1, 4, 6, 7, 8, 10, 16, 9, 3, 6, 10]", "def check(flatten_list):\n\tassert flatten_list([[6, 1, 7], [4, 5, 11], [8, 14, 11], [9, 8, 12]]) == [6, 1, 7, 4, 5, 11, 8, 14, 11, 9, 8, 12]", "def check(flatten_list):\n\tassert flatten_list([[3, 4, 4], [8, 9, 6], [10, 6, 16], [8, 4, 11]]) == [3, 4, 4, 8, 9, 6, 10, 6, 16, 8, 4, 11]", "def check(flatten_list):\n\tassert flatten_list([[2, 4, 8], [8, 10, 6], [5, 13, 8], [6, 3, 14]]) == [2, 4, 8, 8, 10, 6, 5, 13, 8, 6, 3, 14]", "def check(flatten_list):\n\tassert flatten_list([[3, 7, 8], [8, 10, 4], [9, 9, 9], [9, 13, 7]]) == [3, 7, 8, 8, 10, 4, 9, 9, 9, 9, 13, 7]"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [102, 102, 102, 102, 102, 102, 102, 102, 102, 102], "completion": "from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Flattens a nested list structure.\n\n    Args:\n        nested_list (list): A list containing other lists as elements.\n\n    Returns:\n        list: A flattened list with all elements in the original order.\n    \"\"\"\n    def is_list(element):\n        \"\"\"\n        Checks if the element is a list.\n\n        Args:\n            element: The element to check.\n\n        Returns:\n            bool: True if the element is a list, False otherwise.\n        \"\"\"\n        return isinstance(element, list)\n\n    def flatten(lst):\n        \"\"\"\n        Recursively flattens the nested list.\n\n        Args:\n            lst (list): The list to flatten.\n\n        Yields:\n            The elements of the flattened list.\n        \"\"\"\n        for element in lst:\n            if is_list(element):\n                yield from flatten(element)\n            else:\n                yield element\n\n    return list(flatten(nested_list))\n\n# Example usage:\n# print(flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]))\n# Output: [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n", "passed": true, "pass": true, "pass_num": 10, "round": 123, "mutate_method": "add_1_sentence_at_end", "parent_index": 123}
