{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 721, "prompt": "Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells. The path starts from the top-left cell. It moves only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.", "code": "def maxAverageOfPath(cost):\n  N = len(cost)\n  dp = [[0 for i in range(N + 1)] for j in range(N + 1)]\n  dp[0][0] = cost[0][0]\n  for i in range(1, N):\n    dp[i][0] = dp[i - 1][0] + cost[i][0]\n  for j in range(1, N):\n    dp[0][j] = dp[0][j - 1] + cost[0][j]\n  for i in range(1, N):\n    for j in range(1, N):\n      dp[i][j] = max(dp[i - 1][j],\n                     dp[i][j - 1]) + cost[i][j]\n  return dp[N - 1][N - 1] / (2 * N - 1)", "test_imports": [], "test_list": ["assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2", "assert maxAverageOfPath([[2, 3, 4], [7, 6, 5], [8, 4, 10]], 3) == 6.2", "assert maxAverageOfPath([[3, 4, 5], [8, 7, 6], [9, 5, 11]], 3) == 7.2 ", "assert maxAverageOfPath([[6, 3, 1], [1, 4, 5], [2, 6, 6]], 3) == 5.0", "assert maxAverageOfPath([[5, 2, 3], [11, 3, 7], [3, 1, 10]], 3) == 7.2", "assert maxAverageOfPath([[5, 6, 2], [4, 8, 3], [2, 6, 9]], 2) == 6.333333333333333", "assert maxAverageOfPath([[5, 2, 6], [5, 6, 4], [9, 4, 14]], 3) == 7.4", "assert maxAverageOfPath([[3, 2, 2], [9, 5, 3], [9, 3, 11]], 1) == 3.0", "assert maxAverageOfPath([[4, 1, 2], [10, 10, 1], [5, 3, 4]], 3) == 6.2", "assert maxAverageOfPath([[1, 2, 6], [1, 3, 9], [4, 6, 14]], 1) == 1.0", "assert maxAverageOfPath([[5, 4, 8], [9, 9, 2], [12, 8, 14]], 2) == 7.666666666666667", "assert maxAverageOfPath([[2, 2, 4], [7, 9, 8], [8, 7, 11]], 1) == 2.0", "assert maxAverageOfPath([[1, 5, 4], [7, 3, 5], [2, 7, 4]], 1) == 1.0", "assert maxAverageOfPath([[3, 5, 1], [7, 9, 7], [7, 3, 9]], 1) == 3.0", "assert maxAverageOfPath([[6, 4, 4], [6, 2, 7], [9, 4, 6]], 1) == 6.0", "assert maxAverageOfPath([[3, 4, 8], [7, 3, 5], [3, 1, 4]], 2) == 4.333333333333333", "assert maxAverageOfPath([[5, 1, 6], [2, 4, 7], [9, 6, 12]], 3) == 6.8", "assert maxAverageOfPath([[5, 4, 6], [6, 3, 1], [9, 8, 8]], 1) == 5.0", "assert maxAverageOfPath([[4, 1, 2], [11, 4, 8], [12, 3, 13]], 3) == 8.6", "assert maxAverageOfPath([[4, 2, 6], [3, 9, 2], [9, 5, 10]], 3) == 6.2", "assert maxAverageOfPath([[2, 3, 5], [11, 4, 4], [5, 2, 11]], 1) == 2.0", "assert maxAverageOfPath([[3, 7, 3], [10, 10, 7], [3, 1, 5]], 2) == 7.666666666666667", "assert maxAverageOfPath([[4, 7, 5], [9, 1, 4], [6, 1, 5]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 1, 6], [10, 4, 9], [8, 2, 11]], 1) == 4.0", "assert maxAverageOfPath([[1, 2, 4], [3, 3, 9], [4, 3, 5]], 1) == 1.0", "assert maxAverageOfPath([[4, 3, 8], [9, 9, 7], [4, 1, 8]], 3) == 7.4", "assert maxAverageOfPath([[5, 6, 5], [3, 5, 4], [10, 1, 6]], 2) == 5.333333333333333", "assert maxAverageOfPath([[2, 2, 7], [3, 8, 9], [12, 6, 9]], 3) == 6.4", "assert maxAverageOfPath([[1, 5, 2], [6, 5, 8], [11, 1, 12]], 1) == 1.0", "assert maxAverageOfPath([[2, 5, 2], [6, 1, 2], [2, 3, 7]], 2) == 3.0", "assert maxAverageOfPath([[1, 2, 1], [3, 1, 8], [11, 1, 6]], 3) == 4.4", "assert maxAverageOfPath([[4, 2, 6], [2, 5, 2], [3, 3, 7]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[2, 3, 5], [9, 8, 6], [12, 5, 4]], 1) == 2.0", "assert maxAverageOfPath([[1, 3, 6], [7, 6, 8], [7, 4, 8]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 3, 1], [9, 6, 3], [6, 8, 13]], 3) == 8.0", "assert maxAverageOfPath([[6, 6, 7], [5, 8, 5], [5, 6, 12]], 2) == 6.666666666666667", "assert maxAverageOfPath([[1, 4, 7], [11, 8, 10], [7, 2, 15]], 3) == 9.0", "assert maxAverageOfPath([[5, 3, 7], [4, 8, 2], [8, 5, 9]], 2) == 5.666666666666667", "assert maxAverageOfPath([[5, 6, 9], [3, 1, 6], [5, 8, 12]], 1) == 5.0", "assert maxAverageOfPath([[2, 1, 3], [9, 10, 6], [12, 3, 14]], 3) == 8.2", "assert maxAverageOfPath([[5, 6, 5], [9, 9, 10], [3, 2, 13]], 2) == 7.666666666666667", "assert maxAverageOfPath([[7, 7, 9], [9, 1, 4], [12, 2, 15]], 3) == 9.0", "assert maxAverageOfPath([[7, 3, 8], [3, 1, 4], [9, 2, 15]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[7, 1, 9], [4, 11, 4], [3, 4, 9]], 2) == 7.333333333333333", "assert maxAverageOfPath([[5, 7, 1], [2, 1, 4], [12, 6, 9]], 2) == 4.333333333333333", "assert maxAverageOfPath([[3, 1, 5], [5, 4, 7], [11, 3, 13]], 3) == 7.0", "assert maxAverageOfPath([[3, 8, 9], [12, 8, 5], [5, 2, 9]], 1) == 3.0", "assert maxAverageOfPath([[4, 5, 1], [5, 5, 7], [13, 8, 14]], 1) == 4.0", "assert maxAverageOfPath([[6, 4, 3], [9, 7, 8], [11, 6, 6]], 3) == 7.6", "assert maxAverageOfPath([[4, 4, 7], [11, 1, 1], [5, 9, 12]], 2) == 5.333333333333333", "assert maxAverageOfPath([[1, 1, 9], [2, 8, 10], [5, 9, 6]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[7, 1, 6], [12, 2, 5], [4, 6, 11]], 3) == 8.0", "assert maxAverageOfPath([[5, 6, 9], [4, 6, 3], [10, 1, 13]], 1) == 5.0", "assert maxAverageOfPath([[4, 5, 2], [6, 1, 1], [10, 4, 8]], 1) == 4.0", "assert maxAverageOfPath([[4, 2, 4], [10, 6, 6], [13, 3, 12]], 1) == 4.0", "assert maxAverageOfPath([[3, 8, 1], [2, 2, 6], [3, 8, 5]], 2) == 4.333333333333333", "assert maxAverageOfPath([[4, 6, 7], [9, 1, 6], [13, 1, 5]], 2) == 4.666666666666667", "assert maxAverageOfPath([[5, 6, 4], [7, 4, 9], [6, 6, 10]], 1) == 5.0", "assert maxAverageOfPath([[7, 7, 8], [9, 7, 2], [11, 3, 6]], 1) == 7.0", "assert maxAverageOfPath([[5, 4, 4], [2, 1, 8], [12, 7, 12]], 2) == 3.3333333333333335", "assert maxAverageOfPath([[3, 2, 3], [12, 6, 3], [13, 1, 11]], 3) == 8.0", "assert maxAverageOfPath([[4, 2, 5], [2, 3, 4], [5, 6, 12]], 2) == 3.0", "assert maxAverageOfPath([[7, 1, 7], [4, 8, 2], [5, 2, 12]], 3) == 6.6", "assert maxAverageOfPath([[1, 6, 5], [7, 7, 2], [11, 4, 13]], 3) == 7.2", "assert maxAverageOfPath([[3, 6, 1], [10, 1, 3], [3, 8, 12]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 1, 2], [12, 4, 6], [13, 2, 14]], 3) == 9.0", "assert maxAverageOfPath([[2, 6, 7], [3, 7, 9], [9, 8, 7]], 3) == 6.2", "assert maxAverageOfPath([[5, 1, 1], [4, 7, 3], [6, 7, 9]], 2) == 5.333333333333333", "assert maxAverageOfPath([[3, 4, 3], [6, 4, 4], [7, 3, 14]], 2) == 4.333333333333333", "assert maxAverageOfPath([[2, 2, 9], [12, 2, 9], [4, 7, 7]], 1) == 2.0", "assert maxAverageOfPath([[4, 7, 2], [5, 4, 7], [9, 5, 10]], 2) == 5.0", "assert maxAverageOfPath([[2, 9, 1], [13, 5, 2], [4, 5, 11]], 2) == 6.666666666666667", "assert maxAverageOfPath([[6, 2, 1], [11, 12, 9], [4, 9, 14]], 2) == 9.666666666666666", "assert maxAverageOfPath([[3, 7, 10], [3, 9, 4], [11, 1, 7]], 3) == 6.2", "assert maxAverageOfPath([[6, 9, 5], [6, 7, 3], [6, 7, 10]], 1) == 6.0", "assert maxAverageOfPath([[4, 8, 3], [11, 10, 3], [11, 1, 12]], 1) == 4.0", "assert maxAverageOfPath([[6, 8, 9], [5, 11, 7], [9, 4, 10]], 2) == 8.333333333333334", "assert maxAverageOfPath([[4, 6, 8], [10, 7, 4], [10, 8, 14]], 2) == 7.0", "assert maxAverageOfPath([[8, 3, 3], [8, 4, 8], [12, 1, 14]], 1) == 8.0", "assert maxAverageOfPath([[8, 8, 10], [8, 12, 2], [14, 4, 9]], 3) == 8.6", "assert maxAverageOfPath([[4, 5, 4], [12, 7, 1], [12, 7, 11]], 3) == 9.2", "assert maxAverageOfPath([[8, 5, 10], [10, 10, 4], [11, 6, 8]], 1) == 8.0", "assert maxAverageOfPath([[7, 8, 8], [10, 7, 5], [6, 1, 9]], 2) == 8.0", "assert maxAverageOfPath([[1, 7, 4], [8, 7, 3], [11, 2, 8]], 2) == 5.333333333333333", "assert maxAverageOfPath([[1, 5, 6], [4, 2, 8], [6, 6, 10]], 2) == 2.6666666666666665", "assert maxAverageOfPath([[8, 8, 5], [3, 2, 5], [4, 3, 15]], 2) == 6.0", "assert maxAverageOfPath([[6, 8, 4], [9, 5, 11], [11, 8, 14]], 1) == 6.0", "assert maxAverageOfPath([[7, 9, 2], [13, 3, 2], [9, 10, 6]], 2) == 7.666666666666667", "assert maxAverageOfPath([[5, 7, 10], [8, 10, 11], [4, 3, 8]], 2) == 7.666666666666667", "assert maxAverageOfPath([[5, 6, 8], [12, 11, 4], [14, 6, 16]], 3) == 10.6", "assert maxAverageOfPath([[5, 2, 4], [12, 3, 9], [9, 7, 14]], 3) == 9.4", "assert maxAverageOfPath([[8, 7, 4], [4, 4, 7], [12, 5, 11]], 2) == 6.333333333333333", "assert maxAverageOfPath([[1, 8, 4], [11, 10, 8], [11, 1, 13]], 2) == 7.333333333333333", "assert maxAverageOfPath([[4, 9, 9], [5, 6, 11], [14, 8, 16]], 3) == 9.8", "assert maxAverageOfPath([[8, 8, 10], [11, 5, 9], [11, 5, 6]], 2) == 8.0", "assert maxAverageOfPath([[3, 1, 4], [6, 11, 7], [5, 8, 7]], 1) == 3.0", "assert maxAverageOfPath([[2, 6, 1], [11, 11, 3], [10, 3, 8]], 2) == 8.0", "assert maxAverageOfPath([[5, 8, 5], [9, 10, 3], [12, 5, 6]], 3) == 7.4", "assert maxAverageOfPath([[8, 4, 5], [4, 7, 9], [4, 2, 6]], 2) == 6.333333333333333", "assert maxAverageOfPath([[8, 7, 8], [9, 11, 1], [4, 7, 8]], 2) == 9.333333333333334", "assert maxAverageOfPath([[2, 7, 8], [6, 2, 9], [8, 8, 9]], 3) == 7.0", "assert maxAverageOfPath([[6, 5, 2], [13, 8, 8], [12, 2, 7]], 3) == 8.4"], "entry_point": "maxAverageOfPath", "repair_prompt": ["Given a maxAverageOfPath square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells. The path starts from the top-left cell. It moves only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n", " Given amaxAverageOfPath  square matrix of size N*N represented as a list of lists, where each cell contains a certain cost, we need to find the path that starts from the top-left corner and ends at the bottom-right corner. The path can only move right or down. Our goal is to determine the path with the highest average cost per cell visited among all possible paths. The average is calculated by dividing the total cost of the path by the number of cells it traverses.\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n", " Given amaxAverageOfPath  square matrix of size N*N represented as a list of lists, where each cell has a specific cost, we need to find the path that starts from the top-left cell and moves only right or down to the bottom-right cell, aiming to maximize the average cost over all possible paths. The average is calculated by dividing the total cost of the path by the number of cells visited.\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n"], "completions": ["from typing import List\n## main.py\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    if N == 0:\n        return 0.0\n\n    # Initialize the dp array with the same size as the matrix\n    dp = [[0.0] * N for _ in range(N)]\n    \n    # Set the value of the top-left cell\n    dp[0][0] = matrix[0][0]\n    \n    # Fill the first row\n    for j in range(1, N):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n    \n    # Fill the first column\n    for i in range(1, N):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n    \n    # Fill the rest of the dp array\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n    \n    # Calculate the maximum average cost path\n    max_average = dp[N - 1][N - 1] / (2 * N - 1)\n    \n    return max_average\n\n# Example usage:\n# print(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output should be 5.2\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    # Initialize the DP table with the same dimensions as the matrix\n    dp = [[0 for _ in range(N)] for _ in range(N)]\n    \n    # Set the value for the starting cell\n    dp[0][0] = matrix[0][0]\n    \n    # Fill the first row\n    for j in range(1, N):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    \n    # Fill the first column\n    for i in range(1, N):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    \n    # Fill the rest of the DP table\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    # Calculate the average of the maximum path\n    max_average = dp[N-1][N-1] / (2*N-1)\n    \n    return max_average\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    if N == 1:\n        return matrix[0][0]\n    \n    # Initialize the dp table\n    dp = [[0.0] * N for _ in range(N)]\n    dp[0][0] = matrix[0][0]\n    \n    # Fill the first row\n    for j in range(1, N):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    \n    # Fill the first column\n    for i in range(1, N):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    \n    # Fill the rest of the dp table\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    # The maximum average cost path is in the bottom-right cell\n    return dp[N-1][N-1] / (2 * N - 1)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    Calculate the highest average cost per cell visited in the given matrix.\n\n    Args:\n        matrix (List[List[int]]): A 2D list of integers representing the cost of each cell.\n        N (int): The size of the matrix (number of rows/columns).\n\n    Returns:\n        float: The highest average cost per cell visited.\n    \"\"\"\n    if not matrix or N <= 0:\n        raise ValueError(\"Matrix is empty or N is not positive\")\n\n    # Initialize the dp array with the same size as the matrix\n    dp = [[0.0] * N for _ in range(N)]\n\n    # Set the cost of the starting cell\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row\n    for j in range(1, N):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, N):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    # Fill the rest of the dp array\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    # Calculate the highest average cost per cell visited\n    max_average = dp[N - 1][N - 1] / N\n\n    return max_average\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# N = 2\n# print(maxAverageOfPath(matrix, N))  # Output: 2.5\n", "from typing import List\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    # Initialize the dp array with the same dimensions as the matrix\n    dp = [[0.0 for _ in range(N)] for _ in range(N)]\n    \n    # Set the value for the top-left cell\n    dp[0][0] = matrix[0][0]\n    \n    # Initialize the first row and first column\n    for i in range(1, N):\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n    for i in range(1, N):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    \n    # Fill the dp array\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    # Calculate the average cost per cell for the path\n    total_cost = dp[N-1][N-1]\n    num_cells = N * N\n    average_cost = total_cost / num_cells\n    \n    return average_cost\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    This function implements the dynamic programming approach to find the highest average cost path in a matrix.\n    \n    Args:\n        matrix (List[List[int]]): A 2D list representing the cost of each cell in the matrix.\n        N (int): The size of the matrix (NxN).\n    \n    Returns:\n        float: The highest average cost of a path from the top-left to the bottom-right corner.\n    \"\"\"\n    # Initialize the dp array with zeros\n    dp = [[0.0] * N for _ in range(N)]\n    \n    # Set the cost of the starting cell\n    dp[0][0] = matrix[0][0]\n    \n    # Fill the first row\n    for j in range(1, N):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n    \n    # Fill the first column\n    for i in range(1, N):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n    \n    # Fill the rest of the dp array\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n    \n    # Calculate the average cost of the path\n    average_cost = dp[N - 1][N - 1] / (N * N)\n    \n    return round(average_cost, 1)\n\n# Example usage:\n# print(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output should be 5.2\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    This function calculates the maximum average cost of a path from the top-left to the bottom-right corner of a given N*N matrix.\n    \n    Args:\n        matrix (List[List[int]]): A 2D list representing the cost of each cell in the matrix.\n        N (int): The size of the matrix (N*N).\n    \n    Returns:\n        float: The maximum average cost of a path from the top-left to the bottom-right corner.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        raise ValueError(\"The matrix is empty or not properly defined.\")\n    \n    # Initialize the dp table with the same size as the matrix\n    dp = [[0.0] * N for _ in range(N)]\n    \n    # Set the value of the starting cell\n    dp[0][0] = matrix[0][0]\n    \n    # Fill the first row\n    for j in range(1, N):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    \n    # Fill the first column\n    for i in range(1, N):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    \n    # Fill the rest of the dp table\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    # Correct the calculation of the maximum average cost\n    max_average_cost = dp[N-1][N-1] / (N*N)\n    \n    return max_average_cost\n\n# Example usage:\n# matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n# N = 3\n# print(maxAverageOfPath(matrix, N))  # Output should be the maximum average cost of the path\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    This function calculates the maximum average cost of a path from the top-left to the bottom-right corner of a given matrix.\n    \n    Args:\n        matrix (List[List[int]]): A 2D list representing the cost of each cell in the matrix.\n        N (int): The size of the matrix (number of rows/columns).\n    \n    Returns:\n        float: The maximum average cost of a path from the top-left to the bottom-right corner.\n    \"\"\"\n    if N == 1:\n        return matrix[0][0]\n    \n    # Initialize the dp table with the same size as the matrix\n    dp = [[0.0] * N for _ in range(N)]\n    \n    # Set the value of the starting cell\n    dp[0][0] = matrix[0][0]\n    \n    # Fill the dp table for the first row\n    for j in range(1, N):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    \n    # Fill the dp table for the first column\n    for i in range(1, N):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    \n    # Fill the dp table for the rest of the matrix\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    # Calculate the maximum average cost\n    max_average = dp[N-1][N-1] / (N + N - 1)\n    \n    return max_average\n\n# Example usage:\n# matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n# N = 3\n# print(maxAverageOfPath(matrix, N))  # Output should be the maximum average cost of the path\n", "from typing import List\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    This function calculates the maximum average cost path in a given matrix.\n    \n    Args:\n        matrix (List[List[int]]): A 2D list representing the cost of each cell in the matrix.\n        N (int): The size of the matrix (number of rows/columns).\n        \n    Returns:\n        float: The maximum average cost of the path from the top-left to the bottom-right cell.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        raise ValueError(\"The matrix is empty or not properly defined.\")\n    \n    # Initialize the dp array with the same size as the matrix\n    dp = [[0.0] * N for _ in range(N)]\n    \n    # Set the value of the starting cell\n    dp[0][0] = matrix[0][0]\n    \n    # Fill the first row\n    for j in range(1, N):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n    \n    # Fill the first column\n    for i in range(1, N):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n    \n    # Fill the rest of the dp array\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n    \n    # Calculate the maximum average cost path\n    total_cost = dp[N - 1][N - 1]\n    num_cells = N * N\n    max_average = total_cost / num_cells\n    \n    return max_average\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# N = 2\n# print(maxAverageOfPath(matrix, N))  # Output: 2.5\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    This function calculates the maximum average cost of a path from the top-left to the bottom-right corner of a given square matrix.\n    \n    Args:\n        matrix (List[List[int]]): A 2D list representing the cost of each cell in the matrix.\n        N (int): The size of the matrix (number of rows/columns).\n    \n    Returns:\n        float: The maximum average cost of the path from the top-left to the bottom-right corner.\n    \"\"\"\n    if N == 0:\n        return 0.0\n\n    # Initialize the dp array with the same size as the matrix\n    dp = [[0.0 for _ in range(N)] for _ in range(N)]\n\n    # Set the value of the top-left cell\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row\n    for j in range(1, N):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, N):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    # Fill the rest of the dp array\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = (max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]) / 2\n\n    # The result is the value in the bottom-right cell of dp\n    return dp[N - 1][N - 1]\n\n# Example usage:\n# print(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output should be 5.2\n"], "plans": ["requirement analysis:\nThe requirement is to find the path with the maximum average cost in a given matrix. This involves pathfinding and calculating the average of the path's costs. The solution should be efficient and scalable, capable of handling large matrices and providing clear results.\nrequirement pool:\n- Implement a pathfinding algorithm that can handle large matrices efficiently.\n- Calculate the average cost of the path and find the path with the maximum average.\n- Ensure the solution is scalable and can handle matrices of size N*N.\n- Provide clear and easily understandable results.\n- Optimize the algorithm for performance to handle large matrices quickly.\nTo solve the problem of finding the path with the maximum average cost in a given matrix, we will use dynamic programming. This approach will allow us to efficiently compute the path with the highest average cost, even for large matrices. We will leverage the properties of dynamic programming to avoid redundant calculations and ensure scalability.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This is a technique used to solve complex problems by breaking them down into simpler subproblems and storing the results of these subproblems to avoid redundant calculations.\n\n    'maximum average path': The goal is to find the path from the top-left to the bottom-right of the matrix that has the highest average cost.\n\n    Explanation: Dynamic programming is used to solve this problem by creating a 2D array where each cell stores the maximum average that can be achieved to reach that cell from the top-left. The value in each cell is updated based on the values of its neighboring cells (above and left), ensuring that the path with the highest average is considered.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Initialize a 2D array `dp` of the same size as the input matrix, where `dp[i][j]` will store the maximum average cost to reach cell `(i, j)` from the top-left cell `(0, 0)`.\n    2. Set `dp[0][0]` to the value of the top-left cell since it's the starting point.\n    3. Iterate through each cell in the matrix, updating the `dp` array based on the maximum average cost from the neighboring cells.\n    4. The value of `dp[i][j]` is updated using the formula:\n       dp[i][j] = max(dp[i-1][j] if i > 0 else float('-inf'), dp[i][j-1] if j > 0 else float('-inf')) + matrix[i][j]\n    5. After filling the `dp` array, the value at `dp[N-1][N-1]` will be the maximum average cost path.\n\n# [edge case] \n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: Since the matrix contains only one cell, the path is trivial, and the average is the cost itself.\n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with the maximum average is through cells (0,0) -> (0,1) -> (1,1), with an average of (1+2+4)/3 = 2.33, which rounds to 2.5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic already covers the edge case of a 1x1 matrix.\n\n    However, for the second edge case, if the matrix is very large, we might need to optimize memory usage by only keeping track of the current and previous row/column in the `dp` array, reducing the space complexity to O(N).\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a given matrix. This involves pathfinding and calculating the average cost of the path. The solution should be efficient and scalable, capable of handling larger matrices without significant performance degradation. The output should clearly display the path with the highest average cost.\nrequirement pool:\n- Implement a pathfinding algorithm that can handle large matrices efficiently.\n- Calculate the average cost of each path and select the one with the maximum average.\n- Ensure the solution is user-friendly and provides clear results.\n- Optimize the algorithm for performance to handle larger matrices.\nTo address the requirement of finding the path with the maximum average cost in a given matrix, we will utilize dynamic programming. This approach will allow us to efficiently compute the path with the highest average cost by considering the cost of each cell and the path taken to reach it. We will use Python's built-in libraries and ensure the solution is scalable and efficient.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This is a method for solving complex problems by breaking them down into simpler subproblems. It is particularly useful for optimization problems where the goal is to find the best solution among many possible solutions.\n\n    'maximum average path': The goal is to find a path from the top-left to the bottom-right of the matrix that has the highest average cost. The average is calculated by dividing the total cost of the path by the number of cells in the path.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Initialize a DP table of the same size as the input matrix to store the maximum average cost for each cell.\n    2. Set the value for the starting cell (top-left) to be the cost of the cell itself.\n    3. Iterate through the matrix, updating the DP table to reflect the maximum average cost to reach each cell.\n    4. The value for each cell (i, j) will be the maximum of the values from the cell above it (i-1, j) or the cell to the left of it (i, j-1), plus the cost of the current cell.\n    5. The final value in the DP table (bottom-right cell) will be the maximum average cost path.\n\n# [edge case] \n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: Since there's only one cell, the path consists of that cell, and the average is the cost of the cell itself.\n    maxAverageOfPath([[1, 10], [10, 1]], 2) = 5.5\n    Explanation: The path with the maximum average is to go right to the second cell (10) and then down to the second cell (1), giving an average of (10+1)/2 = 5.5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided covers the scenario of a 1x1 matrix.\n\n# [code logic continued]\n    Here's a more detailed implementation of the code logic:\n    ```python\n    def maxAverageOfPath(matrix, N):\n        # Initialize the DP table with the same dimensions as the matrix\n        dp = [[0 for _ in range(N)] for _ in range(N)]\n        \n        # Set the value for the starting cell\n        dp[0][0] = matrix[0][0]\n        \n        # Fill the first row\n        for j in range(1, N):\n            dp[0][j] = dp[0][j-1] + matrix[0][j]\n        \n        # Fill the first column\n        for i in range(1, N):\n            dp[i][0] = dp[i-1][0] + matrix[i][0]\n        \n        # Fill the rest of the DP table\n        for i in range(1, N):\n            for j in range(1, N):\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n        \n        # Calculate the average of the maximum path\n        max_average = dp[N-1][N-1] / (2*N-1)\n        \n        return max_average\n    ```\n\n# [edge case continued]\n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with the maximum average is to go right to the second cell (2) and then down to the second cell (4), giving an average of (1+2+3+4)/4 = 2.5.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a given matrix. This involves pathfinding and calculating the average of the path's costs. The solution should be efficient and scalable, capable of handling large matrices and providing clear results.\nrequirement pool:\n- Implement a pathfinding algorithm that can handle large matrices.\n- Calculate the average cost of the path.\n- Ensure the solution is optimized for performance.\n- Provide clear and easily understandable results.\nTo solve the problem of finding the path with the maximum average cost in a given matrix, we will use dynamic programming. This approach will allow us to efficiently compute the path with the highest average cost, even for large matrices. We will leverage the properties of dynamic programming to avoid redundant calculations and ensure scalability.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This is a technique used to solve complex problems by breaking them down into simpler subproblems and storing the results of these subproblems to avoid redundant calculations.\n\n    'maximum average path': The goal is to find the path from the top-left to the bottom-right of the matrix that has the highest average cost.\n\n    Explanation: Dynamic programming is used to solve this problem by creating a 2D array that stores the maximum average cost achievable up to each cell. The value in each cell is computed based on the values of the cells directly above and to the left, considering the path that leads to that cell.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Initialize a 2D array `dp` of the same size as the input matrix to store the maximum average cost up to each cell.\n    2. Set the value of the top-left cell to be the initial value.\n    3. Iterate through each cell in the matrix, updating the `dp` array based on the maximum average cost from the cells above and to the left.\n    4. The value in the bottom-right cell of the `dp` array will represent the maximum average cost path.\n\n# [edge case] \n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: Since there's only one cell, the path consists of that cell, and the average is simply the cost of the cell itself.\n    maxAverageOfPath([[1, 10], [10, 1]], 2) = 3.5\n    Explanation: The optimal path is either [1, 10] or [10, 1], both with an average of (1+10)/2 = 5.5 or (10+1)/2 = 5.5.\n\n# [extra code for edge case]\n    No extra code is needed for this edge case as the dynamic programming approach inherently handles single-cell matrices.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The dynamic programming approach inherently handles single-cell matrices.\n", "requirement analysis:\nThe requirement is to find the path with the highest average cost per cell visited in a given N*N matrix. The path can only move right or down. The average cost per cell is calculated by dividing the total cost of the path by the number of cells it traverses. This requirement involves both pathfinding and average calculation.\nrequirement pool:\n- The main code should find the path with the highest average cost per cell visited.\n- The path should only move right or down.\n- The average cost per cell should be calculated by dividing the total cost of the path by the number of cells it traverses.\n- The matrix should be represented as a list of lists, where each cell contains a certain cost.\n- The function should return the highest average cost per cell visited among all possible paths.\nTo solve this problem, we will use dynamic programming to find the path with the highest average cost per cell visited. The idea is to maintain a 2D array where each cell represents the maximum average cost achievable to reach that cell from the top-left corner. We will iterate through the matrix, updating the values in this array based on the cost of the current cell and the maximum average cost from the previous cells. Finally, the value in the bottom-right cell of this array will represent the highest average cost per cell visited.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This concept involves breaking down a complex problem into simpler subproblems and solving each subproblem once, storing their solutions to avoid redundant calculations.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests using dynamic programming to solve the problem. Here's a detailed logic:\n    1. Initialize a 2D array `dp` of the same size as the input matrix, where `dp[i][j]` represents the maximum average cost achievable to reach cell `(i, j)` from the top-left corner.\n    2. Set `dp[0][0]` to the cost of the starting cell.\n    3. Iterate through the matrix, updating each `dp[i][j]` based on the maximum average cost from the previous cells:\n       - For the first row, the only way to reach a cell is from the left, so `dp[0][j] = dp[0][j-1] + matrix[0][j]`.\n       - For the first column, the only way to reach a cell is from above, so `dp[i][0] = dp[i-1][0] + matrix[i][0]`.\n       - For other cells, `dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]`.\n    4. After filling the `dp` array, the value at `dp[N-1][N-1]` will be the total cost of the optimal path. To find the average, divide this value by the number of cells in the path (which is `N`).\n\n# [edge case] \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The optimal path is (0,0) -> (0,1) -> (1,1), with a total cost of 1+2+4=7 and an average cost per cell of 7/4=1.75.\n    maxAverageOfPath([[10]], 1) = 10.0\n    Explanation: There's only one cell, so the path cost is 10 and the average is 10/1=10.0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The dynamic programming approach inherently handles single-cell matrices by directly assigning the cell's value as the path cost and average.\n", "requirement analysis:\nThe requirement is to find the path with the highest average cost per cell visited in a given N*N matrix. The path can only move right or down. The average cost per cell is calculated by dividing the total cost of the path by the number of cells it traverses. This requirement involves both pathfinding and average calculation.\nrequirement pool:\n- The main code should find the path with the highest average cost per cell visited.\n- The path should only move right or down.\n- The average cost per cell should be calculated by dividing the total cost of the path by the number of cells it traverses.\n- The matrix should be represented as a list of lists, where each cell contains a certain cost.\n- The function should return the highest average cost per cell visited among all possible paths.\nTo solve this problem, we will use dynamic programming to find the path with the highest average cost per cell visited. The idea is to maintain a 2D array where each cell represents the maximum average cost achievable to reach that cell from the top-left corner. We will iterate through the matrix, updating the values in this array based on the cost of the current cell and the maximum average cost from the previous cells. Finally, the value in the bottom-right cell of this array will represent the highest average cost per cell visited.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This concept involves breaking down a problem into smaller subproblems and solving each subproblem once, storing the results in a table (in this case, a 2D array) so each subproblem is only solved once.\n\n    'path traversal': The problem requires finding the optimal path from the top-left to the bottom-right of the matrix, where the path can only move right or down.\n\n    'average cost per cell': The goal is to maximize the average cost of the path, calculated by dividing the total cost of the path by the number of cells it traverses.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests using dynamic programming to solve the problem. Here's a detailed logic:\n    1. Initialize a 2D array `dp` of the same size as the input matrix, where `dp[i][j]` represents the maximum average cost achievable to reach cell `(i, j)` from the top-left corner.\n    2. Set `dp[0][0]` to the cost of the starting cell since the path starts here.\n    3. Iterate through the matrix, updating each `dp[i][j]` based on the maximum average cost from the cell above it (`dp[i-1][j]`) or the cell to the left of it (`dp[i][j-1]`), whichever gives the higher average cost.\n    4. The value in `dp[N-1][N-1]` will be the maximum average cost path from the top-left to the bottom-right.\n\n# [edge case] \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: There are only two paths, both with the same total cost (1+3 or 1+2+4). The average cost for both paths is (1+3)/2 = 2 and (1+2+4)/3 = 2.33, respectively. The maximum average cost is 2.5.\n    maxAverageOfPath([[10]], 1) = 10.0\n    Explanation: There's only one cell, so the path's average cost is the cost of the cell itself.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The dynamic programming approach inherently handles the case of a single cell by setting the result to the cost of that cell.\n", "requirement analysis:\nThe requirement is to find the path with the highest average cost per cell visited in a given matrix. The path can only move right or down. The solution should be efficient and scalable, capable of handling large matrices. The average cost is calculated by dividing the total cost of the path by the number of cells it traverses.\nrequirement pool:\n- Implement a pathfinding algorithm that calculates the path with the highest average cost.\n- Ensure the algorithm is scalable and can handle matrices of size N*N.\n- Optimize the algorithm for performance to handle large matrices efficiently.\n- Include a method to calculate the average cost of the path.\nTo solve this problem, we will use dynamic programming to find the path with the highest average cost. The idea is to maintain a 2D array where each cell represents the maximum average cost achievable to reach that cell from the top-left corner. We will iterate through the matrix, updating the values in this array based on the cost of the current cell and the maximum average cost from the previous cells. Finally, the value in the bottom-right cell of this array will represent the highest average cost path.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This concept involves breaking down a problem into smaller subproblems and solving each subproblem once, storing the results in a table (array) so each subproblem is only solved once. This is used here to find the path with the highest average cost.\n\n    'path traversal': The path can only move right or down, which means we need to consider all possible paths from the top-left to the bottom-right corner of the matrix.\n\n    'average cost': The average cost per cell is calculated by dividing the total cost of the path by the number of cells it traverses.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement this, we will follow these steps:\n    1. Initialize a 2D array `dp` of the same size as the input matrix, where `dp[i][j]` will store the maximum average cost to reach cell `(i, j)` from the top-left corner.\n    2. Set `dp[0][0]` to the cost of the starting cell since the path starts here.\n    3. Iterate through the matrix, updating each `dp[i][j]` to be the maximum of the current cell's cost plus the maximum average cost from the cell above or to the left.\n    4. After filling the `dp` array, the value at `dp[N-1][N-1]` will be the maximum average cost path.\n\n# [edge case] \n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: Since there's only one cell, the path's average cost is the cost of the cell itself.\n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with the highest average cost is through the cells in the order (0,0) -> (0,1) -> (1,1), with an average cost of (1+2+4)/3 = 2.33, which rounds to 2.5 when considering a single decimal place.\n\n# [extra code for edge case]\n    No extra code is needed for this edge case as the logic already handles single-cell matrices. However, for larger matrices, the dynamic programming approach ensures that all possible paths are considered, and the highest average cost is found.\n", "requirement analysis:\nThe primary requirement is to find the path with the maximum average cost from the top-left to the bottom-right of the matrix. This involves dynamic programming to explore all possible paths and calculate their average costs. The system should be efficient and able to handle matrices of various sizes.\nrequirement pool:\n- Implement a function to calculate the average cost of a path.\n- Ensure the pathfinding algorithm is optimized for large matrices.\n- Develop a user-friendly interface for inputting and displaying matrix data.\n- Include features for visualizing the path with the highest average cost.\n- Conduct thorough testing to verify the accuracy and efficiency of the pathfinding algorithm.\nTo solve the problem of finding the path with the maximum average cost in a given N*N matrix, we will use dynamic programming. This approach will allow us to explore all possible paths efficiently and calculate their average costs. We will implement a function that computes the maximum average cost path and ensure it is optimized for large matrices.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This is a method for solving complex problems by breaking them down into simpler subproblems. It is particularly useful for optimization problems where the goal is to find the best solution among many possible solutions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Initialize a 2D array `dp` of the same size as the input matrix to store the maximum average cost for each cell.\n    2. Set the value of the starting cell `dp[0][0]` to the cost of the cell itself.\n    3. Iterate through the matrix, updating the `dp` array to reflect the maximum average cost to reach each cell.\n    4. For each cell `(i, j)`, the maximum average cost to reach that cell is the maximum of the average costs to reach the cell from the left `(i, j-1)` or from above `(i-1, j)`, plus the cost of the current cell.\n    5. After filling the `dp` array, the maximum average cost to reach the bottom-right cell will be the result.\n\n# [edge case] \n    maxAverageOfPath([[10]], 1) = 10.0\n    Explanation: There is only one cell, so the path cost is 10, and since there is only one cell visited, the average is 10.\n    maxAverageOfPath([[-1, -2, -3], [-6, -5, -4], [-7, -3, -9]], 3) = -4.0\n    Explanation: All cells have negative costs, and the path with the maximum average cost will be the one that minimizes the total cost. The average of the path with the minimum total cost will be the most negative value, which is -4.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The dynamic programming approach inherently handles the case of a single cell matrix.\n", "requirement analysis:\nThe primary requirement is to find the path with the maximum average cost in a given matrix. This involves dynamic programming to explore all possible paths and calculate the average cost. The system should be efficient and able to handle matrices of various sizes. The user interface should be intuitive, allowing users to input the matrix and view the results clearly.\nrequirement pool:\n- Implement a function to calculate the maximum average cost path.\n- Ensure the system can handle matrices of different sizes.\n- Design an intuitive user interface for easy matrix input and result viewing.\n- Include features for path visualization and detailed analytics.\n- Optimize the algorithm for efficiency and scalability.\nTo solve the problem of finding the path with the maximum average cost in a given matrix, we will use dynamic programming. This approach will allow us to explore all possible paths efficiently and calculate the average cost for each path. We will also ensure that the system can handle matrices of different sizes by designing a flexible algorithm. The user interface will be designed to be intuitive, allowing users to input the matrix and view the results clearly.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This is a method for solving complex problems by breaking them down into simpler subproblems. It is particularly useful for optimization problems where the goal is to find the best solution among many possible solutions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution using dynamic programming, we can follow these steps:\n    1. Initialize a 2D array `dp` of the same size as the input matrix to store the maximum average cost for each cell.\n    2. Set the value of the starting cell `dp[0][0]` to the cost of the cell itself.\n    3. Iterate through the matrix, updating the `dp` array to reflect the maximum average cost to reach each cell.\n    4. For each cell `(i, j)`, the maximum average cost can be obtained by either coming from the left `(i, j-1)` or from above `(i-1, j)`, and adding the cost of the current cell.\n    5. After filling the `dp` array, the maximum average cost to reach the bottom-right cell will be in `dp[N-1][N-1]`.\n\n# [edge case] \n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: Since the matrix contains only one cell, the path consists of that single cell, and the average cost is simply the cost of the cell itself.\n    maxAverageOfPath([[1, 10], [10, 1]], 2) = 3.5\n    Explanation: The optimal path is either (0,0) -> (0,1) -> (1,1) with an average of (1+10+1)/(1+1+1) = 4.0, or (0,0) -> (1,0) -> (1,1) with an average of (1+10+1)/(1+1+1) = 4.0. Both paths have the same average cost, so any of them is correct.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The dynamic programming approach inherently handles the case where the matrix is of size 1x1.\n", "requirement analysis:\nThe primary requirement is to find the path with the highest average cost in a given matrix. This involves dynamic programming techniques to explore all possible paths. The product should be efficient and provide clear results. The user interface should be intuitive, allowing users to input the matrix and view the results without confusion.\nrequirement pool:\n- Implement a function to calculate the maximum average path cost.\n- Ensure the user interface is clean and easy to navigate.\n- Optimize the algorithm for efficiency.\n- Include a feature to visualize the path with the highest average cost.\n- Add support for different matrix sizes and cost distributions.\nTo solve the problem of finding the path with the highest average cost in a given matrix, we will use dynamic programming. This approach will allow us to explore all possible paths efficiently. We will define a function that takes a square matrix as input and returns the maximum average cost path. The function will use a 2D array to store the maximum average cost achievable to reach each cell in the matrix. By iterating through the matrix and updating this array, we can determine the path with the highest average cost. The user interface will be designed to be clean and intuitive, allowing users to input the matrix and view the results without confusion.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This is a technique used to solve complex problems by breaking them down into simpler subproblems and storing the results of these subproblems to avoid redundant calculations.\n    Explanation: In this problem, we use dynamic programming to find the path with the highest average cost in a matrix. We store the maximum average cost achievable to reach each cell, which helps in efficiently calculating the optimal path.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Initialize a 2D array `dp` of the same size as the input matrix to store the maximum average cost achievable to reach each cell.\n    2. Set the value of `dp[0][0]` to the cost of the starting cell.\n    3. Iterate through the matrix, updating the `dp` array to reflect the maximum average cost achievable to reach each cell.\n    4. The value of `dp[N-1][N-1]` will represent the maximum average cost path from the top-left to the bottom-right cell.\n\n# [edge case] \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with the highest average cost is (0,0) -> (0,1) -> (1,1), with a total cost of 1+2+4=7 and 3 cells visited. The average cost is 7/3 \u2248 2.5.\n    maxAverageOfPath([[10]], 1) = 10.0\n    Explanation: There is only one cell, so the path is (0,0) with a cost of 10 and 1 cell visited. The average cost is 10.0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles the case where the matrix has only one cell.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles the case where the matrix has only one cell.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a given square matrix. The path starts from the top-left cell and moves only right or down to the bottom-right cell. The average cost is computed by dividing the total cost of the path by the number of cells visited. The solution should be efficient and scalable, capable of handling large matrices.\nrequirement pool:\n- Implement an efficient algorithm to find the path with the maximum average cost.\n- Ensure the algorithm can handle matrices of size N*N efficiently.\n- Optimize the pathfinding algorithm for performance.\n- Ensure the solution is clear and easy to understand.\n- Provide a user interface to visualize the path and its average cost.\nTo solve the problem of finding the path with the maximum average cost in a given square matrix, we will use dynamic programming. This approach will allow us to efficiently compute the path with the highest average cost by considering all possible paths from the top-left to the bottom-right corner of the matrix. We will use a 2D array to store the maximum average cost for each cell, and then backtrack to find the actual path.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This is a technique used to solve complex problems by breaking them down into simpler subproblems and storing the results of these subproblems to avoid redundant calculations.\n\n    'maximum average': The goal is to find a path with the highest average cost, which is calculated by dividing the total cost of the path by the number of cells in the path.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Initialize a 2D array `dp` of the same size as the input matrix to store the maximum average cost for each cell.\n    2. Set the value of the top-left cell `dp[0][0]` to the cost of the cell itself.\n    3. Fill the first row and the first column of the `dp` array with the running sum of costs, as there is only one way to reach any cell in the first row or column (either by moving right or down, respectively).\n    4. For each remaining cell `(i, j)`, calculate the maximum average cost by considering the maximum average cost of the cell directly above it `(i-1, j)` and the cell directly to the left of it `(i, j-1)`, and add the cost of the current cell `matrix[i][j]`.\n    5. The value of `dp[i][j]` will be the maximum average cost for the path ending at `(i, j)`.\n    6. After filling the `dp` array, the value at `dp[N-1][N-1]` will be the maximum average cost for the path from the top-left to the bottom-right corner.\n    7. To find the actual path, we can backtrack from `dp[N-1][N-1]` to `dp[0][0]`, choosing the direction (right or down) that gives the maximum average cost at each step.\n\n# [edge case] \n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: Since there is only one cell, the path consists of that cell, and the average is 1.0.\n    maxAverageOfPath([[1, 10], [10, 1]], 2) = 5.5\n    Explanation: The path with the maximum average is to go right to the second cell (10) and then down to the bottom-right cell (1), giving a total cost of 11 and an average of 5.5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided can handle a 1x1 matrix as well.\n"], "test": ["def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 4], [7, 6, 5], [8, 4, 10]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 5], [8, 7, 6], [9, 5, 11]], 3) == 7.2 ", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 3, 1], [1, 4, 5], [2, 6, 6]], 3) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 3], [11, 3, 7], [3, 1, 10]], 3) == 7.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 2], [4, 8, 3], [2, 6, 9]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 6], [5, 6, 4], [9, 4, 14]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 2, 2], [9, 5, 3], [9, 3, 11]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [10, 10, 1], [5, 3, 4]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 6], [1, 3, 9], [4, 6, 14]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 8], [9, 9, 2], [12, 8, 14]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 4], [7, 9, 8], [8, 7, 11]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 4], [7, 3, 5], [2, 7, 4]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 5, 1], [7, 9, 7], [7, 3, 9]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 4, 4], [6, 2, 7], [9, 4, 6]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 8], [7, 3, 5], [3, 1, 4]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 1, 6], [2, 4, 7], [9, 6, 12]], 3) == 6.8", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 6], [6, 3, 1], [9, 8, 8]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [11, 4, 8], [12, 3, 13]], 3) == 8.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 6], [3, 9, 2], [9, 5, 10]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 5], [11, 4, 4], [5, 2, 11]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 7, 3], [10, 10, 7], [3, 1, 5]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 7, 5], [9, 1, 4], [6, 1, 5]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 6], [10, 4, 9], [8, 2, 11]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 4], [3, 3, 9], [4, 3, 5]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 3, 8], [9, 9, 7], [4, 1, 8]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 5], [3, 5, 4], [10, 1, 6]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 7], [3, 8, 9], [12, 6, 9]], 3) == 6.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 2], [6, 5, 8], [11, 1, 12]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 5, 2], [6, 1, 2], [2, 3, 7]], 2) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 1], [3, 1, 8], [11, 1, 6]], 3) == 4.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 6], [2, 5, 2], [3, 3, 7]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 5], [9, 8, 6], [12, 5, 4]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 3, 6], [7, 6, 8], [7, 4, 8]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 3, 1], [9, 6, 3], [6, 8, 13]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 6, 7], [5, 8, 5], [5, 6, 12]], 2) == 6.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 4, 7], [11, 8, 10], [7, 2, 15]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 3, 7], [4, 8, 2], [8, 5, 9]], 2) == 5.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 9], [3, 1, 6], [5, 8, 12]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 1, 3], [9, 10, 6], [12, 3, 14]], 3) == 8.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 5], [9, 9, 10], [3, 2, 13]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 7, 9], [9, 1, 4], [12, 2, 15]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 3, 8], [3, 1, 4], [9, 2, 15]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 9], [4, 11, 4], [3, 4, 9]], 2) == 7.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 7, 1], [2, 1, 4], [12, 6, 9]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 1, 5], [5, 4, 7], [11, 3, 13]], 3) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 8, 9], [12, 8, 5], [5, 2, 9]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 1], [5, 5, 7], [13, 8, 14]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 4, 3], [9, 7, 8], [11, 6, 6]], 3) == 7.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 4, 7], [11, 1, 1], [5, 9, 12]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 1, 9], [2, 8, 10], [5, 9, 6]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 6], [12, 2, 5], [4, 6, 11]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 9], [4, 6, 3], [10, 1, 13]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 2], [6, 1, 1], [10, 4, 8]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 4], [10, 6, 6], [13, 3, 12]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 8, 1], [2, 2, 6], [3, 8, 5]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 6, 7], [9, 1, 6], [13, 1, 5]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 4], [7, 4, 9], [6, 6, 10]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 7, 8], [9, 7, 2], [11, 3, 6]], 1) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 4], [2, 1, 8], [12, 7, 12]], 2) == 3.3333333333333335", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 2, 3], [12, 6, 3], [13, 1, 11]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 5], [2, 3, 4], [5, 6, 12]], 2) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 7], [4, 8, 2], [5, 2, 12]], 3) == 6.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 6, 5], [7, 7, 2], [11, 4, 13]], 3) == 7.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 6, 1], [10, 1, 3], [3, 8, 12]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [12, 4, 6], [13, 2, 14]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 6, 7], [3, 7, 9], [9, 8, 7]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 1, 1], [4, 7, 3], [6, 7, 9]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 3], [6, 4, 4], [7, 3, 14]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 9], [12, 2, 9], [4, 7, 7]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 7, 2], [5, 4, 7], [9, 5, 10]], 2) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 9, 1], [13, 5, 2], [4, 5, 11]], 2) == 6.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 2, 1], [11, 12, 9], [4, 9, 14]], 2) == 9.666666666666666", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 7, 10], [3, 9, 4], [11, 1, 7]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 9, 5], [6, 7, 3], [6, 7, 10]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 8, 3], [11, 10, 3], [11, 1, 12]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 8, 9], [5, 11, 7], [9, 4, 10]], 2) == 8.333333333333334", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 6, 8], [10, 7, 4], [10, 8, 14]], 2) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 3, 3], [8, 4, 8], [12, 1, 14]], 1) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 10], [8, 12, 2], [14, 4, 9]], 3) == 8.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 4], [12, 7, 1], [12, 7, 11]], 3) == 9.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 5, 10], [10, 10, 4], [11, 6, 8]], 1) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 8, 8], [10, 7, 5], [6, 1, 9]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 7, 4], [8, 7, 3], [11, 2, 8]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 6], [4, 2, 8], [6, 6, 10]], 2) == 2.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 5], [3, 2, 5], [4, 3, 15]], 2) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 8, 4], [9, 5, 11], [11, 8, 14]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 9, 2], [13, 3, 2], [9, 10, 6]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 7, 10], [8, 10, 11], [4, 3, 8]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 8], [12, 11, 4], [14, 6, 16]], 3) == 10.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 4], [12, 3, 9], [9, 7, 14]], 3) == 9.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 7, 4], [4, 4, 7], [12, 5, 11]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 8, 4], [11, 10, 8], [11, 1, 13]], 2) == 7.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 9, 9], [5, 6, 11], [14, 8, 16]], 3) == 9.8", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 10], [11, 5, 9], [11, 5, 6]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 1, 4], [6, 11, 7], [5, 8, 7]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 6, 1], [11, 11, 3], [10, 3, 8]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 8, 5], [9, 10, 3], [12, 5, 6]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 4, 5], [4, 7, 9], [4, 2, 6]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 7, 8], [9, 11, 1], [4, 7, 8]], 2) == 9.333333333333334", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 7, 8], [6, 2, 9], [8, 8, 9]], 3) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 5, 2], [13, 8, 8], [12, 2, 7]], 3) == 8.4"], "scores": [1.0, 1.0, 1.0, 0.2647, 0.2647, 0.2647, 0.2647, 1.0, 0.2647, 0.2647], "pass_results": [true, true, true, false, false, false, false, true, false, false], "pass_test_cases_num": [102, 102, 102, 27, 27, 27, 27, 102, 27, 27], "completion": "from typing import List\n## main.py\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    This function calculates the maximum average cost of a path from the top-left to the bottom-right corner of a given matrix.\n    \n    Args:\n        matrix (List[List[int]]): A 2D list representing the cost of each cell in the matrix.\n        N (int): The size of the matrix (number of rows/columns).\n    \n    Returns:\n        float: The maximum average cost of a path from the top-left to the bottom-right corner.\n    \"\"\"\n    if N == 1:\n        return matrix[0][0]\n    \n    # Initialize the dp table with the same size as the matrix\n    dp = [[0.0] * N for _ in range(N)]\n    \n    # Set the value of the starting cell\n    dp[0][0] = matrix[0][0]\n    \n    # Fill the dp table for the first row\n    for j in range(1, N):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    \n    # Fill the dp table for the first column\n    for i in range(1, N):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    \n    # Fill the dp table for the rest of the matrix\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    # Calculate the maximum average cost\n    max_average = dp[N-1][N-1] / (N + N - 1)\n    \n    return max_average\n\n# Example usage:\n# matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n# N = 3\n# print(maxAverageOfPath(matrix, N))  # Output should be the maximum average cost of the path\n", "passed": true, "pass": true, "pass_num": 4, "round": 207, "mutate_method": "expand_one2two", "parent_index": 207}
