{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 721, "prompt": "Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells. The path starts from the top-left cell. It moves only right or down. The path ends on the bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.", "code": "def maxAverageOfPath(cost):\n  N = len(cost)\n  dp = [[0 for i in range(N + 1)] for j in range(N + 1)]\n  dp[0][0] = cost[0][0]\n  for i in range(1, N):\n    dp[i][0] = dp[i - 1][0] + cost[i][0]\n  for j in range(1, N):\n    dp[0][j] = dp[0][j - 1] + cost[0][j]\n  for i in range(1, N):\n    for j in range(1, N):\n      dp[i][j] = max(dp[i - 1][j],\n                     dp[i][j - 1]) + cost[i][j]\n  return dp[N - 1][N - 1] / (2 * N - 1)", "test_imports": [], "test_list": ["assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2", "assert maxAverageOfPath([[2, 3, 4], [7, 6, 5], [8, 4, 10]], 3) == 6.2", "assert maxAverageOfPath([[3, 4, 5], [8, 7, 6], [9, 5, 11]], 3) == 7.2 ", "assert maxAverageOfPath([[6, 3, 1], [1, 4, 5], [2, 6, 6]], 3) == 5.0", "assert maxAverageOfPath([[5, 2, 3], [11, 3, 7], [3, 1, 10]], 3) == 7.2", "assert maxAverageOfPath([[5, 6, 2], [4, 8, 3], [2, 6, 9]], 2) == 6.333333333333333", "assert maxAverageOfPath([[5, 2, 6], [5, 6, 4], [9, 4, 14]], 3) == 7.4", "assert maxAverageOfPath([[3, 2, 2], [9, 5, 3], [9, 3, 11]], 1) == 3.0", "assert maxAverageOfPath([[4, 1, 2], [10, 10, 1], [5, 3, 4]], 3) == 6.2", "assert maxAverageOfPath([[1, 2, 6], [1, 3, 9], [4, 6, 14]], 1) == 1.0", "assert maxAverageOfPath([[5, 4, 8], [9, 9, 2], [12, 8, 14]], 2) == 7.666666666666667", "assert maxAverageOfPath([[2, 2, 4], [7, 9, 8], [8, 7, 11]], 1) == 2.0", "assert maxAverageOfPath([[1, 5, 4], [7, 3, 5], [2, 7, 4]], 1) == 1.0", "assert maxAverageOfPath([[3, 5, 1], [7, 9, 7], [7, 3, 9]], 1) == 3.0", "assert maxAverageOfPath([[6, 4, 4], [6, 2, 7], [9, 4, 6]], 1) == 6.0", "assert maxAverageOfPath([[3, 4, 8], [7, 3, 5], [3, 1, 4]], 2) == 4.333333333333333", "assert maxAverageOfPath([[5, 1, 6], [2, 4, 7], [9, 6, 12]], 3) == 6.8", "assert maxAverageOfPath([[5, 4, 6], [6, 3, 1], [9, 8, 8]], 1) == 5.0", "assert maxAverageOfPath([[4, 1, 2], [11, 4, 8], [12, 3, 13]], 3) == 8.6", "assert maxAverageOfPath([[4, 2, 6], [3, 9, 2], [9, 5, 10]], 3) == 6.2", "assert maxAverageOfPath([[2, 3, 5], [11, 4, 4], [5, 2, 11]], 1) == 2.0", "assert maxAverageOfPath([[3, 7, 3], [10, 10, 7], [3, 1, 5]], 2) == 7.666666666666667", "assert maxAverageOfPath([[4, 7, 5], [9, 1, 4], [6, 1, 5]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 1, 6], [10, 4, 9], [8, 2, 11]], 1) == 4.0", "assert maxAverageOfPath([[1, 2, 4], [3, 3, 9], [4, 3, 5]], 1) == 1.0", "assert maxAverageOfPath([[4, 3, 8], [9, 9, 7], [4, 1, 8]], 3) == 7.4", "assert maxAverageOfPath([[5, 6, 5], [3, 5, 4], [10, 1, 6]], 2) == 5.333333333333333", "assert maxAverageOfPath([[2, 2, 7], [3, 8, 9], [12, 6, 9]], 3) == 6.4", "assert maxAverageOfPath([[1, 5, 2], [6, 5, 8], [11, 1, 12]], 1) == 1.0", "assert maxAverageOfPath([[2, 5, 2], [6, 1, 2], [2, 3, 7]], 2) == 3.0", "assert maxAverageOfPath([[1, 2, 1], [3, 1, 8], [11, 1, 6]], 3) == 4.4", "assert maxAverageOfPath([[4, 2, 6], [2, 5, 2], [3, 3, 7]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[2, 3, 5], [9, 8, 6], [12, 5, 4]], 1) == 2.0", "assert maxAverageOfPath([[1, 3, 6], [7, 6, 8], [7, 4, 8]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 3, 1], [9, 6, 3], [6, 8, 13]], 3) == 8.0", "assert maxAverageOfPath([[6, 6, 7], [5, 8, 5], [5, 6, 12]], 2) == 6.666666666666667", "assert maxAverageOfPath([[1, 4, 7], [11, 8, 10], [7, 2, 15]], 3) == 9.0", "assert maxAverageOfPath([[5, 3, 7], [4, 8, 2], [8, 5, 9]], 2) == 5.666666666666667", "assert maxAverageOfPath([[5, 6, 9], [3, 1, 6], [5, 8, 12]], 1) == 5.0", "assert maxAverageOfPath([[2, 1, 3], [9, 10, 6], [12, 3, 14]], 3) == 8.2", "assert maxAverageOfPath([[5, 6, 5], [9, 9, 10], [3, 2, 13]], 2) == 7.666666666666667", "assert maxAverageOfPath([[7, 7, 9], [9, 1, 4], [12, 2, 15]], 3) == 9.0", "assert maxAverageOfPath([[7, 3, 8], [3, 1, 4], [9, 2, 15]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[7, 1, 9], [4, 11, 4], [3, 4, 9]], 2) == 7.333333333333333", "assert maxAverageOfPath([[5, 7, 1], [2, 1, 4], [12, 6, 9]], 2) == 4.333333333333333", "assert maxAverageOfPath([[3, 1, 5], [5, 4, 7], [11, 3, 13]], 3) == 7.0", "assert maxAverageOfPath([[3, 8, 9], [12, 8, 5], [5, 2, 9]], 1) == 3.0", "assert maxAverageOfPath([[4, 5, 1], [5, 5, 7], [13, 8, 14]], 1) == 4.0", "assert maxAverageOfPath([[6, 4, 3], [9, 7, 8], [11, 6, 6]], 3) == 7.6", "assert maxAverageOfPath([[4, 4, 7], [11, 1, 1], [5, 9, 12]], 2) == 5.333333333333333", "assert maxAverageOfPath([[1, 1, 9], [2, 8, 10], [5, 9, 6]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[7, 1, 6], [12, 2, 5], [4, 6, 11]], 3) == 8.0", "assert maxAverageOfPath([[5, 6, 9], [4, 6, 3], [10, 1, 13]], 1) == 5.0", "assert maxAverageOfPath([[4, 5, 2], [6, 1, 1], [10, 4, 8]], 1) == 4.0", "assert maxAverageOfPath([[4, 2, 4], [10, 6, 6], [13, 3, 12]], 1) == 4.0", "assert maxAverageOfPath([[3, 8, 1], [2, 2, 6], [3, 8, 5]], 2) == 4.333333333333333", "assert maxAverageOfPath([[4, 6, 7], [9, 1, 6], [13, 1, 5]], 2) == 4.666666666666667", "assert maxAverageOfPath([[5, 6, 4], [7, 4, 9], [6, 6, 10]], 1) == 5.0", "assert maxAverageOfPath([[7, 7, 8], [9, 7, 2], [11, 3, 6]], 1) == 7.0", "assert maxAverageOfPath([[5, 4, 4], [2, 1, 8], [12, 7, 12]], 2) == 3.3333333333333335", "assert maxAverageOfPath([[3, 2, 3], [12, 6, 3], [13, 1, 11]], 3) == 8.0", "assert maxAverageOfPath([[4, 2, 5], [2, 3, 4], [5, 6, 12]], 2) == 3.0", "assert maxAverageOfPath([[7, 1, 7], [4, 8, 2], [5, 2, 12]], 3) == 6.6", "assert maxAverageOfPath([[1, 6, 5], [7, 7, 2], [11, 4, 13]], 3) == 7.2", "assert maxAverageOfPath([[3, 6, 1], [10, 1, 3], [3, 8, 12]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 1, 2], [12, 4, 6], [13, 2, 14]], 3) == 9.0", "assert maxAverageOfPath([[2, 6, 7], [3, 7, 9], [9, 8, 7]], 3) == 6.2", "assert maxAverageOfPath([[5, 1, 1], [4, 7, 3], [6, 7, 9]], 2) == 5.333333333333333", "assert maxAverageOfPath([[3, 4, 3], [6, 4, 4], [7, 3, 14]], 2) == 4.333333333333333", "assert maxAverageOfPath([[2, 2, 9], [12, 2, 9], [4, 7, 7]], 1) == 2.0", "assert maxAverageOfPath([[4, 7, 2], [5, 4, 7], [9, 5, 10]], 2) == 5.0", "assert maxAverageOfPath([[2, 9, 1], [13, 5, 2], [4, 5, 11]], 2) == 6.666666666666667", "assert maxAverageOfPath([[6, 2, 1], [11, 12, 9], [4, 9, 14]], 2) == 9.666666666666666", "assert maxAverageOfPath([[3, 7, 10], [3, 9, 4], [11, 1, 7]], 3) == 6.2", "assert maxAverageOfPath([[6, 9, 5], [6, 7, 3], [6, 7, 10]], 1) == 6.0", "assert maxAverageOfPath([[4, 8, 3], [11, 10, 3], [11, 1, 12]], 1) == 4.0", "assert maxAverageOfPath([[6, 8, 9], [5, 11, 7], [9, 4, 10]], 2) == 8.333333333333334", "assert maxAverageOfPath([[4, 6, 8], [10, 7, 4], [10, 8, 14]], 2) == 7.0", "assert maxAverageOfPath([[8, 3, 3], [8, 4, 8], [12, 1, 14]], 1) == 8.0", "assert maxAverageOfPath([[8, 8, 10], [8, 12, 2], [14, 4, 9]], 3) == 8.6", "assert maxAverageOfPath([[4, 5, 4], [12, 7, 1], [12, 7, 11]], 3) == 9.2", "assert maxAverageOfPath([[8, 5, 10], [10, 10, 4], [11, 6, 8]], 1) == 8.0", "assert maxAverageOfPath([[7, 8, 8], [10, 7, 5], [6, 1, 9]], 2) == 8.0", "assert maxAverageOfPath([[1, 7, 4], [8, 7, 3], [11, 2, 8]], 2) == 5.333333333333333", "assert maxAverageOfPath([[1, 5, 6], [4, 2, 8], [6, 6, 10]], 2) == 2.6666666666666665", "assert maxAverageOfPath([[8, 8, 5], [3, 2, 5], [4, 3, 15]], 2) == 6.0", "assert maxAverageOfPath([[6, 8, 4], [9, 5, 11], [11, 8, 14]], 1) == 6.0", "assert maxAverageOfPath([[7, 9, 2], [13, 3, 2], [9, 10, 6]], 2) == 7.666666666666667", "assert maxAverageOfPath([[5, 7, 10], [8, 10, 11], [4, 3, 8]], 2) == 7.666666666666667", "assert maxAverageOfPath([[5, 6, 8], [12, 11, 4], [14, 6, 16]], 3) == 10.6", "assert maxAverageOfPath([[5, 2, 4], [12, 3, 9], [9, 7, 14]], 3) == 9.4", "assert maxAverageOfPath([[8, 7, 4], [4, 4, 7], [12, 5, 11]], 2) == 6.333333333333333", "assert maxAverageOfPath([[1, 8, 4], [11, 10, 8], [11, 1, 13]], 2) == 7.333333333333333", "assert maxAverageOfPath([[4, 9, 9], [5, 6, 11], [14, 8, 16]], 3) == 9.8", "assert maxAverageOfPath([[8, 8, 10], [11, 5, 9], [11, 5, 6]], 2) == 8.0", "assert maxAverageOfPath([[3, 1, 4], [6, 11, 7], [5, 8, 7]], 1) == 3.0", "assert maxAverageOfPath([[2, 6, 1], [11, 11, 3], [10, 3, 8]], 2) == 8.0", "assert maxAverageOfPath([[5, 8, 5], [9, 10, 3], [12, 5, 6]], 3) == 7.4", "assert maxAverageOfPath([[8, 4, 5], [4, 7, 9], [4, 2, 6]], 2) == 6.333333333333333", "assert maxAverageOfPath([[8, 7, 8], [9, 11, 1], [4, 7, 8]], 2) == 9.333333333333334", "assert maxAverageOfPath([[2, 7, 8], [6, 2, 9], [8, 8, 9]], 3) == 7.0", "assert maxAverageOfPath([[6, 5, 2], [13, 8, 8], [12, 2, 7]], 3) == 8.4"], "entry_point": "maxAverageOfPath", "repair_prompt": ["Given a maxAverageOfPath square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells. The path starts from the top-left cell. It moves only right or down. The path ends on the bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n", " Given amaxAverageOfPath  square matrix of size N*N represented as a list of lists, where each cell contains a certain cost, a path consists of a sequence of cells. The path begins at the top-left corner and can only move right or down to reach the bottom-right corner. Our goal is to determine the path with the highest average cost among all possible paths. The average cost is calculated by dividing the total cost of the path by the number of cells visited in the path.\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n", " Given amaxAverageOfPath  square matrix of size N*N represented as a list of lists, where each cell has a specific cost, we need to find a path that starts from the top-left cell and moves only right or down to reach the bottom-right cell. The goal is to find the path with the maximum average over all possible paths, where the average is calculated as the total cost divided by the number of cells visited in the path.\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n"], "completions": ["from typing import List\n## main.py\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    Function to find the maximum average of a path in the matrix.\n    \n    Args:\n        matrix (List[List[int]]): The input matrix.\n        N (int): The size of the matrix (N*N).\n        \n    Returns:\n        float: The maximum average cost of the path.\n    \"\"\"\n    if not matrix or N <= 0:\n        raise ValueError(\"Matrix must be non-empty and N must be positive.\")\n\n    # Initialize a 2D array to store the maximum average cost achievable up to each cell\n    dp = [[0.0] * N for _ in range(N)]\n    \n    # Set the value of the top-left cell (dp[0][0]) to the cost of the cell itself\n    dp[0][0] = matrix[0][0]\n    \n    # Fill the first row and the first column of the dp array\n    for i in range(1, N):\n        dp[0][i] = dp[0][i - 1] + matrix[0][i]\n    for i in range(1, N):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n    \n    # Fill the rest of the dp array\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n    \n    # Ensure the sum of the path costs is not zero before performing the division\n    total_cost = dp[N - 1][N - 1]\n    if total_cost == 0:\n        return 0.0\n    return total_cost / (N * N)\n\n# Example usage:\n# print(maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Output should be 5.2\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    Calculate the maximum average path cost in a given matrix.\n\n    Args:\n        matrix (List[List[int]]): A 2D list of integers representing the cost of each cell in the matrix.\n        N (int): The size of the matrix (number of rows/columns).\n\n    Returns:\n        float: The maximum average path cost.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        raise ValueError(\"The matrix is empty or not properly defined.\")\n\n    # Initialize the DP table with the same dimensions as the matrix\n    dp = [[0.0] * N for _ in range(N)]\n\n    # Set the value of the top-left cell to its own value\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row\n    for j in range(1, N):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, N):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    # Fill the rest of the DP table\n    for i in range(1, N):\n        for j in range(1, N):\n            # Update the DP table with the maximum average cost\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    # Calculate the maximum average path cost\n    max_average = dp[N - 1][N - 1] / (2 * N - 1)\n\n    return max_average\n\n# Example usage:\n# matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n# N = 3\n# print(maxAverageOfPath(matrix, N))  # Output should be the maximum average path cost\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    Calculate the maximum average cost of a path from the top-left corner to the bottom-right corner of a given N*N matrix.\n\n    Args:\n        matrix (List[List[int]]): A 2D list representing the cost of each cell in the matrix.\n        N (int): The size of the matrix (N*N).\n\n    Returns:\n        float: The maximum average cost of a path from the top-left to the bottom-right corner.\n    \"\"\"\n    if not matrix or N <= 0:\n        raise ValueError(\"The matrix must be non-empty and N must be a positive integer.\")\n\n    # Initialize the DP table with the same dimensions as the matrix\n    dp = [[0.0] * N for _ in range(N)]\n\n    # Set the value of the starting cell (top-left corner)\n    dp[0][0] = matrix[0][0] / 1.0\n\n    # Fill the first row\n    for j in range(1, N):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j] / (j + 1.0)\n\n    # Fill the first column\n    for i in range(1, N):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0] / (i + 1.0)\n\n    # Fill the rest of the DP table\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j] / (i + j + 1.0)\n\n    # The value in the bottom-right cell of the DP table is the maximum average path cost\n    return dp[N - 1][N - 1] / N\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# N = 2\n# print(maxAverageOfPath(matrix, N))  # Output: 2.5\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    This function calculates the maximum average cost of a path from the top-left to the bottom-right corner of a given matrix.\n    \n    Args:\n        matrix (List[List[int]]): A 2D list of integers representing the cost of each cell in the matrix.\n        N (int): The size of the matrix (number of rows/columns).\n    \n    Returns:\n        float: The maximum average cost of a path from the top-left to the bottom-right corner.\n    \"\"\"\n    # Initialize a 2D array to store the maximum average cost to reach each cell\n    dp = [[0.0 for _ in range(N)] for _ in range(N)]\n    \n    # Set the initial value of the top-left cell\n    dp[0][0] = matrix[0][0]\n    \n    # Fill the first row\n    for j in range(1, N):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    \n    # Fill the first column\n    for i in range(1, N):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    \n    # Fill the rest of the dp array\n    for i in range(1, N):\n        for j in range(1, N):\n            # Update the cell with the maximum average cost to reach that cell\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    # Calculate the maximum average cost of the path\n    total_cost = dp[N-1][N-1]\n    num_cells = (N * N)  # Ensure this is the total number of cells in the path\n    max_average = total_cost / num_cells\n    \n    return max_average\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# N = 2\n# print(maxAverageOfPath(matrix, N))  # Output: 2.5\n", "from typing import List\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    Calculate the maximum average cost path in a given matrix.\n\n    Args:\n        matrix (List[List[int]]): The cost matrix where each element represents the cost of the cell.\n        N (int): The size of the matrix (NxN).\n\n    Returns:\n        float: The highest average cost of a path.\n    \"\"\"\n    if N == 1:\n        return matrix[0][0]\n\n    # Initialize dp array with the same size as the matrix\n    dp = [[0] * N for _ in range(N)]\n\n    # Set the value of the first cell in dp\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row and the first column of dp\n    for i in range(1, N):\n        dp[0][i] = dp[0][i - 1] + matrix[0][i]\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    # Fill the rest of the dp array\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    # Calculate the maximum average cost path\n    max_sum = dp[N - 1][N - 1]\n    average_cost = max_sum / (2 * N - 1)\n\n    return average_cost\n\n# Example usage:\n# matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n# N = 3\n# print(maxAverageOfPath(matrix, N))  # Output should be the highest average cost of a path\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    # Initialize a 2D array `dp` of the same size as the input matrix\n    dp = [[0] * N for _ in range(N)]\n    \n    # Set the value of the first cell in `dp` to be the value of the first cell in the matrix\n    dp[0][0] = matrix[0][0]\n    \n    # Fill the first row of `dp` with the cumulative sum of the matrix's first row\n    for j in range(1, N):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n    \n    # Fill the first column of `dp` with the cumulative sum of the matrix's first column\n    for i in range(1, N):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n    \n    # Iterate through the matrix starting from the second row and second column\n    for i in range(1, N):\n        for j in range(1, N):\n            # For each cell, calculate the maximum sum of the path\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n    \n    # The value in the bottom-right cell of `dp` will be the maximum sum of the path\n    max_sum = dp[N - 1][N - 1]\n    \n    # To find the highest average cost path, divide the maximum sum by the number of cells in the path\n    average_cost = max_sum / N\n    \n    return average_cost\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# N = 2\n# print(maxAverageOfPath(matrix, N))  # Output should be 2.5\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    This function calculates the maximum average of all possible paths from the top-left to the bottom-right of a given matrix.\n    \n    Args:\n        matrix (List[List[int]]): A 2D list representing the cost of each cell in the matrix.\n        N (int): The size of the matrix (NxN).\n    \n    Returns:\n        float: The maximum average of all possible paths from the top-left to the bottom-right.\n    \"\"\"\n    if N == 0:\n        return 0\n    \n    # Initialize the dp table with the same size as the matrix\n    dp = [[0.0] * N for _ in range(N)]\n    \n    # Set the value of the starting cell\n    dp[0][0] = matrix[0][0]\n    \n    # Fill the dp table for the first row\n    for j in range(1, N):\n        dp[0][j] = (dp[0][j-1] * (j) + matrix[0][j]) / (j + 1)\n    \n    # Fill the dp table for the first column\n    for i in range(1, N):\n        dp[i][0] = (dp[i-1][0] * (i) + matrix[i][0]) / (i + 1)\n    \n    # Fill the dp table for the rest of the matrix\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max((dp[i-1][j] * i + matrix[i][j]) / (i + 1), (dp[i][j-1] * j + matrix[i][j]) / (j + 1))\n    \n    # Calculate the maximum average for the path from top-left to bottom-right\n    max_average = dp[N-1][N-1]\n    return max_average\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# N = 2\n# print(maxAverageOfPath(matrix, N))  # Output: 2.5\n", "from typing import List\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    Calculate the maximum average cost of a path from the top-left to the bottom-right corner of the matrix.\n\n    Args:\n        matrix (List[List[int]]): A 2D list representing the cost of each cell in the matrix.\n        N (int): The size of the matrix (number of rows or columns).\n\n    Returns:\n        float: The maximum average cost of a path from the top-left to the bottom-right corner.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        raise ValueError(\"The matrix is empty or not properly defined.\")\n\n    # Initialize a DP table with the same size as matrix\n    dp = [[0.0] * N for _ in range(N)]\n\n    # Set the first cell of dp to matrix[0][0]\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row and first column of dp with cumulative sums\n    for i in range(1, N):\n        dp[0][i] = dp[0][i - 1] + matrix[0][i]\n    for i in range(1, N):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    # Calculate the maximum average for each cell in dp\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    # The result is the value in the bottom-right cell of dp divided by N\n    return dp[N - 1][N - 1] / N\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# N = 2\n# print(maxAverageOfPath(matrix, N))  # Output: 2.5\n", "from typing import List\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    This function calculates the maximum average of all possible paths in a given square matrix.\n    \n    Args:\n        matrix (List[List[int]]): A 2D list representing the cost of each cell in the matrix.\n        N (int): The size of the matrix (number of rows/columns).\n        \n    Returns:\n        float: The maximum average of all possible paths in the matrix.\n    \"\"\"\n    # Initialize a 2D array to store the maximum average for each cell\n    dp = [[0.0] * N for _ in range(N)]\n    \n    # Set the value of the starting cell\n    dp[0][0] = matrix[0][0]\n    \n    # Fill the first row\n    for j in range(1, N):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n    \n    # Fill the first column\n    for i in range(1, N):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n    \n    # Fill the rest of the dp table\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n    \n    # Calculate the maximum average\n    max_average = dp[N - 1][N - 1] / (N * N)\n    \n    return max_average\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# N = 2\n# print(maxAverageOfPath(matrix, N))  # Output: 2.5\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    Calculate the maximum average path cost in a given N*N matrix.\n\n    Args:\n        matrix (List[List[int]]): A 2D list representing the matrix with integer values.\n        N (int): The size of the matrix (N*N).\n\n    Returns:\n        float: The maximum average path cost.\n    \"\"\"\n    if not matrix or N <= 0:\n        raise ValueError(\"Matrix must be non-empty and N must be positive.\")\n\n    # Initialize the dp table with [0, 0]\n    dp = [[[0, 0] for _ in range(N)] for _ in range(N)]\n\n    # Set the starting point\n    dp[0][0] = [matrix[0][0], 1]\n\n    # Fill the first row\n    for j in range(1, N):\n        dp[0][j] = [dp[0][j-1][0] + matrix[0][j], dp[0][j-1][1] + 1]\n\n    # Fill the first column\n    for i in range(1, N):\n        dp[i][0] = [dp[i-1][0][0] + matrix[i][0], dp[i-1][0][1] + 1]\n\n    # Fill the rest of the dp table\n    for i in range(1, N):\n        for j in range(1, N):\n            # Calculate the maximum average path cost up to the current cell\n            max_cost, num_cells = max(dp[i-1][j], dp[i][j-1], key=lambda x: x[0] / x[1])\n            dp[i][j] = [max_cost + matrix[i][j], num_cells + 1]\n\n    # The maximum average path cost is the value in the bottom-right corner\n    max_avg_cost, _ = dp[N-1][N-1]\n    return max_avg_cost / dp[N-1][N-1][1]\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# N = 2\n# print(maxAverageOfPath(matrix, N))  # Output: 2.5\n"], "plans": ["requirement analysis:\nThe requirement is to find the path with the maximum average cost in a given square matrix. The path starts from the top-left cell and moves only right or down to the bottom-right cell. The average cost is calculated by dividing the total cost of the path by the number of cells visited. This problem can be solved using dynamic programming to efficiently find the optimal path.\nrequirement pool:\n- The main code should efficiently find the path with the maximum average cost.\n- The algorithm should handle matrices of any size N*N.\n- The user interface should allow easy selection of difficulty levels.\n- The game should be responsive and work well on mobile devices.\n- The UI should be visually appealing and provide clear feedback.\nTo solve the problem of finding the path with the maximum average cost in a given square matrix, we will use dynamic programming. This approach will allow us to efficiently compute the optimal path by breaking down the problem into smaller subproblems. We will define a function that takes a matrix and its size as input and returns the maximum average cost path. The function will use a 2D array to store the maximum average cost achievable up to each cell in the matrix. By iterating through the matrix and updating this array, we can determine the path with the highest average cost.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This is a technique used to solve problems by breaking them down into smaller subproblems and solving each subproblem only once. The results are stored in a table for future reference, avoiding redundant calculations.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests using dynamic programming to solve the problem. The steps include:\n    1. Initialize a 2D array `dp` of the same size as the input matrix to store the maximum average cost achievable up to each cell.\n    2. Set the value of the top-left cell (dp[0][0]) to the cost of the cell itself.\n    3. Fill the first row and the first column of the `dp` array with the cumulative sum of the costs from the start to that cell, as there's only one way to reach any cell in the first row or column (either move right or down, respectively).\n    4. For each remaining cell in the matrix, compute the maximum average cost by considering the maximum average cost of the cell above it and the cell to its left, and then taking the maximum of these two values plus the cost of the current cell.\n    5. The value in the bottom-right cell of the `dp` array will represent the maximum average cost path.\n\n# [edge case] \n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: With only one cell, the path consists of that cell, and the average is simply the cost of the cell itself.\n    maxAverageOfPath([[1, 10], [10, 1]], 2) = 3.5\n    Explanation: The optimal path is (1, 1) -> (2, 1), with a total cost of 2 and 2 cells, resulting in an average of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan already covers the edge case of a 1x1 matrix.\n\n# [extra code for edge case]\n    No extra code is needed for the edge case as the provided logic already handles it.\n", "requirement analysis:\nThe requirement involves finding the path with the maximum average cost in a given matrix. The path can only move right or down. The solution should be efficient and scalable. The user interface should be simple and intuitive.\nrequirement pool:\n- Implement a function to calculate the maximum average path cost.\n- Ensure the solution is efficient and can handle large matrices.\n- Design a user-friendly interface for easy navigation.\n- Include features to display the path and its average cost.\n- Optimize the algorithm for better performance on smaller matrices.\nTo solve the problem of finding the path with the maximum average cost in a given matrix, we will use dynamic programming. This approach will ensure efficiency and scalability, making it suitable for large matrices. We will define a function that calculates the maximum average path cost by considering all possible paths from the top-left to the bottom-right corner of the matrix. Each cell in the matrix will store the maximum average cost achievable up to that cell. The final result will be the maximum average cost of the path from the top-left to the bottom-right corner.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This concept involves breaking down a complex problem into simpler subproblems and solving each subproblem once, storing their solutions to avoid redundant calculations.\n\n    'maximum average path': The goal is to find the path with the highest average cost, calculated as the total cost of the path divided by the number of cells in the path.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Initialize a DP table of the same size as the input matrix, where each cell will store the maximum average cost achievable up to that cell.\n    2. Set the value of the top-left cell to its own value since it's the starting point.\n    3. Iterate through the matrix, updating each cell's value based on the maximum average cost of the paths that can reach it (from the left or from above).\n    4. The value of each cell will be the maximum of the values from the left and above cells plus its own cost, divided by 2 (since moving right or down increases the number of cells by 1).\n    5. The value in the bottom-right cell of the DP table will be the maximum average cost of the path from the top-left to the bottom-right corner.\n\n# [edge case] \n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: Since the matrix has only one cell, the path consists of that cell, and the average is 1/1 = 1.0.\n    maxAverageOfPath([[1, 10], [10, 1]], 2) = 5.5\n    Explanation: The path with the maximum average is to go right to the second cell (10) and then down to the second cell (1), giving a total cost of 11 and an average of 11/2 = 5.5.\n\n# [extra code for edge case]\n    No extra code is needed for the edge case since the logic already handles single-cell matrices correctly.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a given N*N matrix. The path starts at the top-left and ends at the bottom-right, moving only right or down. The average cost is calculated by dividing the total cost of the path by the number of cells visited. The solution should be efficient and scalable.\nrequirement pool:\n- Implement a function to calculate the maximum average path cost.\n- Ensure the solution is efficient and works for large matrices.\n- Develop a user-friendly interface for easy matrix input and result display.\n- Include features to handle different matrix sizes and cell costs.\n- Optimize the algorithm for performance and scalability.\nTo solve the problem of finding the path with the maximum average cost in a given N*N matrix, we will use dynamic programming. This approach will ensure efficiency and scalability, making it suitable for large matrices. We will calculate the maximum average path by considering the cost of each cell and the path that leads to it. The dynamic programming table will store the maximum average for each cell, and we will use this information to reconstruct the path with the highest average cost.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This concept involves breaking down a problem into smaller subproblems and solving each subproblem once, storing the results in a table for later use. This approach helps in solving complex problems efficiently.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests using dynamic programming to solve the problem. The steps include:\n    1. Initialize a DP table with the same dimensions as the input matrix to store the maximum average for each cell.\n    2. Set the value of the starting cell (top-left corner) to its own cost divided by 1 (since it's the first cell).\n    3. Iterate through the matrix, updating the DP table for each cell by considering the maximum average of the paths coming from the left and from above.\n    4. The value in the DP table for the bottom-right cell will represent the maximum average path cost.\n    5. To reconstruct the path, backtrack from the bottom-right cell to the top-left cell, choosing the path with the maximum average.\n\n# [edge case] \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with the maximum average is through the cells (0,0) -> (0,1) -> (1,1), with a total cost of 1+2+4=7 and 3 cells visited, giving an average of 7/3 \u2248 2.5.\n    maxAverageOfPath([[10]], 1) = 10.0\n    Explanation: There's only one cell, so the path's average is the cell's cost itself.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The dynamic programming approach inherently handles the case of a single cell matrix.\n", "requirement analysis:\nThe requirement is to find the path with the highest average cost in a given matrix. The path can only move right or down. The average cost is calculated by dividing the total cost of the path by the number of cells visited. This requirement involves dynamic programming to explore all possible paths and calculate the average cost for each.\nrequirement pool:\n- The main code should calculate the maximum average path cost efficiently.\n- Ensure the path finding algorithm is optimized for large matrices.\n- Implement a user interface to display the matrix and the path with the highest average cost.\n- Include options for the user to input the matrix size and cell costs.\n- Provide a clear and intuitive user interface for easy navigation.\nTo solve the problem of finding the path with the highest average cost in a given matrix, we will use dynamic programming. This approach will allow us to efficiently explore all possible paths and calculate the average cost for each. We will define a function that takes a matrix as input and returns the maximum average cost of a path from the top-left to the bottom-right corner. The function will use a 2D array to store the maximum average cost achievable to reach each cell in the matrix. By iterating through the matrix and updating this array, we can determine the optimal path.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This concept involves breaking down a problem into smaller subproblems and solving each subproblem only once, storing the results to avoid redundant calculations.\n\n    'path traversal': The process of moving from the start to the end of a matrix, typically only moving right or down, to explore all possible routes.\n\n    'average cost': The sum of the costs along a path divided by the number of cells in the path, used to evaluate the efficiency of a path.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the value of interest must be greater than a certain threshold.\n\n# [degree adverb] \n    'highest': Indicates the goal is to find the maximum or best possible value.\n\n# [code logic]\n    To implement the solution, we will use dynamic programming to build a table where each cell contains the maximum average cost to reach that cell from the start. We will initialize the first cell with its own value and then iterate through the matrix, updating the table based on the possible moves (right or down). Finally, the value in the bottom-right cell of the table will represent the maximum average cost path.\n\n# [edge case] \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with the highest average cost could be (0,0) -> (0,1) -> (1,1) with an average cost of (1+2+4)/3 = 2.33. However, since we are looking for the highest average, we consider the path (0,0) -> (1,0) -> (1,1) with an average cost of (1+3+4)/3 = 2.67, which is the highest.\n\n    maxAverageOfPath([[10, 20], [30, 40]], 2) = 30.0\n    Explanation: There is only one path, (0,0) -> (1,0) -> (1,1), with an average cost of (10+30+40)/3 = 26.67, which is not the highest due to the high initial cost.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The dynamic programming approach inherently handles the case where the matrix is very small, as it will simply return the average of the single path available.\n", "requirement analysis:\nThe requirement is to find the path with the highest average cost in a given matrix. The path can only move right or down. The average cost is calculated by dividing the total cost of the path by the number of cells visited. This problem can be solved using dynamic programming to avoid recalculating paths.\nrequirement pool:\n- Implement a function to calculate the maximum average path cost\n- Ensure the path calculation is efficient and handles large matrices\n- Design a user-friendly interface for choosing difficulty levels\n- Include a restart button in the game interface\n- Improve the visual appeal of the game interface\nTo solve the problem of finding the path with the highest average cost in a given matrix, we will use dynamic programming. This approach will help us efficiently calculate the maximum average path cost without recalculating paths multiple times. We will define a function that takes a matrix and its size as input and returns the highest average cost path.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This is a method for solving complex problems by breaking them down into simpler subproblems. It is particularly useful for optimization problems where the goal is to find the best solution among many possible solutions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Initialize a 2D array `dp` of the same size as the input matrix to store the maximum sum path cost up to each cell.\n    2. Set the value of the first cell in `dp` to be the value of the first cell in the matrix.\n    3. Fill the first row and the first column of `dp` with the cumulative sum of the matrix values, as there's only one way to reach any cell in the first row or column from the start.\n    4. Iterate over the rest of the matrix cells, and for each cell, calculate the maximum sum path cost by considering the maximum path cost from the left and top cells, and add the current cell's cost to it.\n    5. After filling the `dp` array, the value in the bottom-right cell of `dp` will represent the maximum sum path cost.\n    6. To find the path with the highest average cost, we will divide this maximum sum by the number of cells in the path (which is `2N-1` for an `N*N` matrix).\n\n# [edge case] \n    maxAverageOfPath([[1]], 1) = 1.0\n    Explanation: Since there's only one cell, the path consists of that cell, and the average cost is the cost of the cell itself.\n    maxAverageOfPath([[1, 10], [10, 1]], 2) = 5.5\n    Explanation: The path with the highest average cost is either [1, 10] or [10, 1], both with an average cost of (1+10)/2 = 5.5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided can handle a 1x1 matrix as well.\n", "requirement analysis:\nThe requirement is to find the path with the highest average cost in a given matrix. The path can only move right or down. The average cost is calculated by dividing the total cost of the path by the number of cells visited. This problem can be solved using dynamic programming to avoid recalculating paths.\nrequirement pool:\n- Implement a function to calculate the maximum average path cost\n- Ensure the path calculation is efficient and handles large matrices\n- Develop a user interface for choosing matrix size and cell costs\n- Include a feature to display the calculated path and its average cost\n- Optimize the UI for better user experience and responsiveness\nTo solve the problem of finding the path with the highest average cost in a given matrix, we will use dynamic programming. This approach will allow us to efficiently calculate the maximum average path cost without recalculating paths multiple times. We will define a function that takes a square matrix as input and returns the highest average cost path's average cost.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This is a technique used to solve complex problems by breaking them down into simpler subproblems and storing the results of these subproblems to avoid redundant calculations.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution using dynamic programming, we will follow these steps:\n    1. Initialize a 2D array `dp` of the same size as the input matrix to store the maximum sum of the path up to each cell.\n    2. Set the value of the first cell in `dp` to be the value of the first cell in the matrix.\n    3. Fill the first row and the first column of `dp` with the cumulative sum of the matrix's first row and first column, respectively.\n    4. Iterate through the matrix starting from the second row and second column:\n        - For each cell, calculate the maximum sum of the path by taking the maximum of the sum from the left cell or the sum from the above cell and adding the current cell's value.\n    5. The value in the bottom-right cell of `dp` will be the maximum sum of the path in the matrix.\n    6. To find the highest average cost path, we will divide the maximum sum by the number of cells in the path (which is `2*N-1` for an N*N matrix).\n\n# [edge case] \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with the highest average cost is through the cells (0,0) -> (0,1) -> (1,1), with a total cost of 1+2+4=7 and an average cost of 7/4=1.75. However, this is not the highest average cost path. The highest average cost path is through the cells (0,0) -> (1,0) -> (1,1), with a total cost of 1+3+4=8 and an average cost of 8/3=2.67. But since we are looking for the highest average cost among all possible paths, the correct output should be the average of the highest sum path, which is 2.5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic already considers the smallest possible matrix size.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average over all possible paths in a given matrix. The average is calculated as the total cost divided by the number of cells visited. This requires dynamic programming to explore all possible paths and calculate the average for each, then select the maximum.\nrequirement pool:\n- Implement a function to calculate the maximum average path cost.\n- Ensure the solution is efficient and can handle matrices of size N*N.\n- Develop a user-friendly interface for easy matrix input and result display.\n- Include features to handle different matrix sizes and cell costs.\n- Optimize the algorithm for better performance on large matrices.\nTo solve the problem of finding the path with the maximum average over all possible paths in a given matrix, we will use dynamic programming. This approach will allow us to explore all possible paths efficiently and calculate the average for each path. We will also ensure that the solution can handle matrices of size N*N, making it versatile for different sizes.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This is a method for solving complex problems by breaking them down into simpler subproblems, solving each subproblem once, and storing their solutions to avoid redundant calculations.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution using dynamic programming, we will follow these steps:\n    1. Initialize a 2D array `dp` of the same size as the input matrix to store the maximum average for each cell.\n    2. Set the value of the starting cell `dp[0][0]` to the cost of the cell itself.\n    3. Iterate through the matrix, updating the `dp` array to reflect the maximum average path to each cell.\n    4. For each cell `(i, j)`, the maximum average path to that cell can be obtained by considering the maximum average paths from the cell above `(i-1, j)` and the cell to the left `(i, j-1)`, adding the cost of the current cell, and dividing by 2 (since we are considering the average over all possible paths).\n    5. After filling the `dp` array, the value at `dp[N-1][N-1]` will be the maximum average path for the entire matrix.\n\n# [edge case] \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with the maximum average is through the cells (0,0) -> (0,1) -> (1,1), with a total cost of 1+2+4=7 and 3 cells visited, giving an average of 7/3 \u2248 2.5.\n    maxAverageOfPath([[10]], 1) = 10\n    Explanation: There is only one cell, so the maximum average is the cost of that cell itself.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles the case of a 1x1 matrix by simply returning the cost of the single cell.\n", "requirement analysis:\nThe primary requirement is to find the path with the maximum average cost in a given matrix. This involves pathfinding algorithms and average calculation. The product should be efficient and scalable, ensuring it works well even for large matrices. The user interface should be simple and intuitive, providing a good user experience.\nrequirement pool:\n- Implement a pathfinding algorithm that considers the average cost of each path.\n- Ensure the solution is efficient and can handle large matrices.\n- Design a simple and intuitive user interface.\n- Optimize the algorithm for performance and scalability.\n- Include features for user feedback and performance tracking.\nTo solve the problem of finding the path with the maximum average cost in a given matrix, we will use dynamic programming. This approach will ensure efficiency and scalability, making it suitable for large matrices. We will calculate the average cost for each path and keep track of the maximum average found. The user interface will be designed to be simple and intuitive, providing a clear display of the matrix and the optimal path.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This is a method for solving complex problems by breaking them down into simpler subproblems. It is particularly useful for optimization problems where the goal is to find the best solution among many possible solutions.\n\n    'maximum average': The goal is to find the path with the highest average cost, calculated by dividing the total cost of the path by the number of cells visited.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will use dynamic programming to calculate the maximum average path cost. We will create a 2D array to store the maximum average cost for each cell in the matrix. We will then iterate through the matrix, updating the maximum average cost for each cell based on the cost of the current cell and the maximum average costs of the cells from which it can be reached. Finally, the maximum average cost for the bottom-right cell will be the result.\n\n# [edge case] \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: There are two paths with the same total cost (5), but the path (0,0) -> (0,1) -> (1,1) has the higher average cost (1+2+4)/3 = 2.33, which is greater than the average cost of the other path (1+3+4)/3 = 2.67.\n    maxAverageOfPath([[10]], 1) = 10.0\n    Explanation: There is only one cell in the matrix, so the path cost is 10, and the average cost is 10/1 = 10.0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The dynamic programming approach inherently handles the case where the matrix has only one cell.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The dynamic programming approach inherently handles the case where the matrix has only one cell.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average over all possible paths in a given square matrix. The average is calculated as the total cost divided by the number of cells visited in the path. This requires dynamic programming to explore all possible paths and calculate the average for each.\nrequirement pool:\n- The main code should efficiently find the path with the maximum average.\n- The UI should be responsive and visually appealing.\n- The game should allow users to choose difficulty levels.\nTo solve the problem of finding the path with the maximum average over all possible paths in a given square matrix, we will use dynamic programming. This approach will allow us to explore all possible paths efficiently and calculate the average for each path. We will also ensure the UI is responsive and visually appealing, allowing users to choose difficulty levels.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This is a method for solving complex problems by breaking them down into simpler subproblems. It is particularly useful for optimization problems where the goal is to find the best solution among many possible solutions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution using dynamic programming, we will follow these steps:\n    1. Initialize a 2D array `dp` of the same size as the input matrix to store the maximum average for each cell.\n    2. Set the value of the starting cell `dp[0][0]` to the value of the input matrix at the same position.\n    3. Iterate through the matrix, updating the `dp` array to store the maximum average path sum up to each cell.\n    4. For each cell `(i, j)`, the maximum average path sum can be obtained by taking the maximum of the average paths from the cell above `(i-1, j)` and the cell to the left `(i, j-1)`, adding the current cell's value, and dividing by 2 (since we are considering the number of cells visited).\n    5. Continue this process until the last cell `(N-1, N-1)` is reached.\n    6. The value at `dp[N-1][N-1]` will be the maximum average path sum for the entire matrix.\n\n# [edge case] \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: There are two paths with the maximum average:\n    - Path 1: 1 -> 2, average = (1 + 2) / 2 = 1.5\n    - Path 2: 1 -> 3 -> 4, average = (1 + 3 + 4) / 3 = 2.666...\n    The maximum average is 2.5, which is the average of the path 1 -> 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The dynamic programming approach inherently considers all possible paths and finds the one with the maximum average.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a given N*N matrix. The path starts from the top-left and moves only right or down to the bottom-right. The average cost is calculated by dividing the total cost of the path by the number of cells visited. The solution should be efficient and scalable.\nrequirement pool:\n- Implement a function to calculate the maximum average path cost.\n- Ensure the solution is efficient and works for large matrices.\n- Develop a user-friendly interface for easy navigation.\n- Include accessibility features for users with disabilities.\n- Enhance the visual appeal of the user interface.\nTo solve the problem of finding the path with the maximum average cost in a given N*N matrix, we will use dynamic programming. This approach will ensure efficiency and scalability for large matrices. We will calculate the maximum average path by considering the cost of each cell and the number of cells visited. The dynamic programming table will store the maximum average achievable up to each cell, allowing us to reconstruct the path with the highest average cost.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'dynamic programming': This concept involves breaking down a problem into smaller subproblems and solving each subproblem once, storing their solutions to avoid redundant calculations.\n\n    'maximum average path': The goal is to find the path with the highest average cost, calculated as the total cost divided by the number of cells visited.\n\n    Explanation: In this problem, we need to traverse a matrix from the top-left to the bottom-right corner, moving only right or down. We aim to find the path that maximizes the average cost, which is the total cost of the path divided by the number of cells in the path.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will use dynamic programming to build a table that stores the maximum average achievable up to each cell. We will iterate through the matrix, updating the table based on the cost of the current cell and the values from previous cells. Finally, we will reconstruct the path with the highest average cost from the table.\n\n# [edge case] \n    maxAverageOfPath([[1, 2], [3, 4]], 2) = 2.5\n    Explanation: The path with the maximum average in this 2x2 matrix is through the cells (0,0) -> (0,1) -> (1,1), with a total cost of 1+2+4=7 and 3 cells visited. The average is 7/3 \u2248 2.5.\n\n    maxAverageOfPath([[10, 20], [30, 40]], 2) = 30.0\n    Explanation: The path with the maximum average in this 2x2 matrix is directly from the top-left to the bottom-right cell, with a total cost of 10+30+40=80 and 3 cells visited. The average is 80/3 \u2248 26.67, but since we are looking for the highest average, we consider the direct path with the highest cost.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The dynamic programming approach inherently handles the smallest possible matrix (2x2) and ensures we find the maximum average path.\n\n# [extra code for edge case]\n    No extra code is needed for edge cases as the dynamic programming approach inherently handles all matrix sizes.\n"], "test": ["def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 4], [7, 6, 5], [8, 4, 10]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 5], [8, 7, 6], [9, 5, 11]], 3) == 7.2 ", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 3, 1], [1, 4, 5], [2, 6, 6]], 3) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 3], [11, 3, 7], [3, 1, 10]], 3) == 7.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 2], [4, 8, 3], [2, 6, 9]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 6], [5, 6, 4], [9, 4, 14]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 2, 2], [9, 5, 3], [9, 3, 11]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [10, 10, 1], [5, 3, 4]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 6], [1, 3, 9], [4, 6, 14]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 8], [9, 9, 2], [12, 8, 14]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 4], [7, 9, 8], [8, 7, 11]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 4], [7, 3, 5], [2, 7, 4]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 5, 1], [7, 9, 7], [7, 3, 9]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 4, 4], [6, 2, 7], [9, 4, 6]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 8], [7, 3, 5], [3, 1, 4]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 1, 6], [2, 4, 7], [9, 6, 12]], 3) == 6.8", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 6], [6, 3, 1], [9, 8, 8]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [11, 4, 8], [12, 3, 13]], 3) == 8.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 6], [3, 9, 2], [9, 5, 10]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 5], [11, 4, 4], [5, 2, 11]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 7, 3], [10, 10, 7], [3, 1, 5]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 7, 5], [9, 1, 4], [6, 1, 5]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 6], [10, 4, 9], [8, 2, 11]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 4], [3, 3, 9], [4, 3, 5]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 3, 8], [9, 9, 7], [4, 1, 8]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 5], [3, 5, 4], [10, 1, 6]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 7], [3, 8, 9], [12, 6, 9]], 3) == 6.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 2], [6, 5, 8], [11, 1, 12]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 5, 2], [6, 1, 2], [2, 3, 7]], 2) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 1], [3, 1, 8], [11, 1, 6]], 3) == 4.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 6], [2, 5, 2], [3, 3, 7]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 5], [9, 8, 6], [12, 5, 4]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 3, 6], [7, 6, 8], [7, 4, 8]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 3, 1], [9, 6, 3], [6, 8, 13]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 6, 7], [5, 8, 5], [5, 6, 12]], 2) == 6.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 4, 7], [11, 8, 10], [7, 2, 15]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 3, 7], [4, 8, 2], [8, 5, 9]], 2) == 5.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 9], [3, 1, 6], [5, 8, 12]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 1, 3], [9, 10, 6], [12, 3, 14]], 3) == 8.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 5], [9, 9, 10], [3, 2, 13]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 7, 9], [9, 1, 4], [12, 2, 15]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 3, 8], [3, 1, 4], [9, 2, 15]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 9], [4, 11, 4], [3, 4, 9]], 2) == 7.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 7, 1], [2, 1, 4], [12, 6, 9]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 1, 5], [5, 4, 7], [11, 3, 13]], 3) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 8, 9], [12, 8, 5], [5, 2, 9]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 1], [5, 5, 7], [13, 8, 14]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 4, 3], [9, 7, 8], [11, 6, 6]], 3) == 7.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 4, 7], [11, 1, 1], [5, 9, 12]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 1, 9], [2, 8, 10], [5, 9, 6]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 6], [12, 2, 5], [4, 6, 11]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 9], [4, 6, 3], [10, 1, 13]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 2], [6, 1, 1], [10, 4, 8]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 4], [10, 6, 6], [13, 3, 12]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 8, 1], [2, 2, 6], [3, 8, 5]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 6, 7], [9, 1, 6], [13, 1, 5]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 4], [7, 4, 9], [6, 6, 10]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 7, 8], [9, 7, 2], [11, 3, 6]], 1) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 4], [2, 1, 8], [12, 7, 12]], 2) == 3.3333333333333335", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 2, 3], [12, 6, 3], [13, 1, 11]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 5], [2, 3, 4], [5, 6, 12]], 2) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 7], [4, 8, 2], [5, 2, 12]], 3) == 6.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 6, 5], [7, 7, 2], [11, 4, 13]], 3) == 7.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 6, 1], [10, 1, 3], [3, 8, 12]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [12, 4, 6], [13, 2, 14]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 6, 7], [3, 7, 9], [9, 8, 7]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 1, 1], [4, 7, 3], [6, 7, 9]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 3], [6, 4, 4], [7, 3, 14]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 9], [12, 2, 9], [4, 7, 7]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 7, 2], [5, 4, 7], [9, 5, 10]], 2) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 9, 1], [13, 5, 2], [4, 5, 11]], 2) == 6.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 2, 1], [11, 12, 9], [4, 9, 14]], 2) == 9.666666666666666", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 7, 10], [3, 9, 4], [11, 1, 7]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 9, 5], [6, 7, 3], [6, 7, 10]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 8, 3], [11, 10, 3], [11, 1, 12]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 8, 9], [5, 11, 7], [9, 4, 10]], 2) == 8.333333333333334", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 6, 8], [10, 7, 4], [10, 8, 14]], 2) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 3, 3], [8, 4, 8], [12, 1, 14]], 1) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 10], [8, 12, 2], [14, 4, 9]], 3) == 8.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 4], [12, 7, 1], [12, 7, 11]], 3) == 9.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 5, 10], [10, 10, 4], [11, 6, 8]], 1) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 8, 8], [10, 7, 5], [6, 1, 9]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 7, 4], [8, 7, 3], [11, 2, 8]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 6], [4, 2, 8], [6, 6, 10]], 2) == 2.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 5], [3, 2, 5], [4, 3, 15]], 2) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 8, 4], [9, 5, 11], [11, 8, 14]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 9, 2], [13, 3, 2], [9, 10, 6]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 7, 10], [8, 10, 11], [4, 3, 8]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 8], [12, 11, 4], [14, 6, 16]], 3) == 10.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 4], [12, 3, 9], [9, 7, 14]], 3) == 9.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 7, 4], [4, 4, 7], [12, 5, 11]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 8, 4], [11, 10, 8], [11, 1, 13]], 2) == 7.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 9, 9], [5, 6, 11], [14, 8, 16]], 3) == 9.8", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 10], [11, 5, 9], [11, 5, 6]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 1, 4], [6, 11, 7], [5, 8, 7]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 6, 1], [11, 11, 3], [10, 3, 8]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 8, 5], [9, 10, 3], [12, 5, 6]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 4, 5], [4, 7, 9], [4, 2, 6]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 7, 8], [9, 11, 1], [4, 7, 8]], 2) == 9.333333333333334", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 7, 8], [6, 2, 9], [8, 8, 9]], 3) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 5, 2], [13, 8, 8], [12, 2, 7]], 3) == 8.4"], "scores": [0.2647, 1.0, 0.2745, 0.2647, 1.0, 0.2647, 0.2843, 0.2647, 0.2647, 1.0], "pass_results": [false, true, false, false, true, false, false, false, false, true], "pass_test_cases_num": [27, 102, 28, 27, 102, 27, 29, 27, 27, 102], "completion": "from typing import List\n## main.py\nfrom typing import List\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    Calculate the maximum average path cost in a given N*N matrix.\n\n    Args:\n        matrix (List[List[int]]): A 2D list representing the matrix with integer values.\n        N (int): The size of the matrix (N*N).\n\n    Returns:\n        float: The maximum average path cost.\n    \"\"\"\n    if not matrix or N <= 0:\n        raise ValueError(\"Matrix must be non-empty and N must be positive.\")\n\n    # Initialize the dp table with [0, 0]\n    dp = [[[0, 0] for _ in range(N)] for _ in range(N)]\n\n    # Set the starting point\n    dp[0][0] = [matrix[0][0], 1]\n\n    # Fill the first row\n    for j in range(1, N):\n        dp[0][j] = [dp[0][j-1][0] + matrix[0][j], dp[0][j-1][1] + 1]\n\n    # Fill the first column\n    for i in range(1, N):\n        dp[i][0] = [dp[i-1][0][0] + matrix[i][0], dp[i-1][0][1] + 1]\n\n    # Fill the rest of the dp table\n    for i in range(1, N):\n        for j in range(1, N):\n            # Calculate the maximum average path cost up to the current cell\n            max_cost, num_cells = max(dp[i-1][j], dp[i][j-1], key=lambda x: x[0] / x[1])\n            dp[i][j] = [max_cost + matrix[i][j], num_cells + 1]\n\n    # The maximum average path cost is the value in the bottom-right corner\n    max_avg_cost, _ = dp[N-1][N-1]\n    return max_avg_cost / dp[N-1][N-1][1]\n\n# Example usage:\n# matrix = [[1, 2], [3, 4]]\n# N = 2\n# print(maxAverageOfPath(matrix, N))  # Output: 2.5\n", "passed": true, "pass": true, "pass_num": 3, "round": 331, "mutate_method": "expand_one2two", "parent_index": 414}
