{"source_file": "Ellen's Copy of Benchmark Questions Verification V2.ipynb", "task_id": 297, "prompt": "Write a function to flatten a given nested list structure. A nested list contains other lists as its elements, and your function should return a single-level list containing all the elements from the nested list.", "code": "def flatten_list(list1):\n    result_list = []\n    if not list1: return result_list\n    stack = [list(list1)]\n    while stack:\n        c_num = stack.pop()\n        next = c_num.pop()\n        if c_num: stack.append(c_num)\n        if isinstance(next, list):\n            if next: stack.append(list(next))\n        else: result_list.append(next)\n    result_list.reverse()\n    return result_list ", "test_imports": [], "test_list": ["assert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]", "assert flatten_list([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]])==[10, 20, 40, 30, 56, 25, 10, 20, 33, 40]", "assert flatten_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])==[1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]", "assert flatten_list([5, 15, [17, 25], 39, 49, [65, 69, 78], [86, 97, 110, 123]]) == [5, 15, 17, 25, 39, 49, 65, 69, 78, 86, 97, 110, 123]", "assert flatten_list([5, 7, [15, 33], 39, 45, [65, 75, 82], [92, 104, 115, 116]]) == [5, 7, 15, 33, 39, 45, 65, 75, 82, 92, 104, 115, 116]", "assert flatten_list([2, 9, [22, 28], 35, 52, [58, 68, 81], [87, 100, 105, 117]]) == [2, 9, 22, 28, 35, 52, 58, 68, 81, 87, 100, 105, 117]", "assert flatten_list([5, 10, [24, 29], 42, 49, [65, 72, 85], [92, 97, 105, 119]]) == [5, 10, 24, 29, 42, 49, 65, 72, 85, 92, 97, 105, 119]", "assert flatten_list([5, 15, [24, 32], 36, 50, [63, 74, 78], [85, 101, 113, 115]]) == [5, 15, 24, 32, 36, 50, 63, 74, 78, 85, 101, 113, 115]", "assert flatten_list([4, 11, [15, 25], 37, 51, [64, 74, 82], [94, 101, 110, 117]]) == [4, 11, 15, 25, 37, 51, 64, 74, 82, 94, 101, 110, 117]", "assert flatten_list([1, 10, [17, 26], 39, 49, [65, 75, 77], [87, 103, 112, 121]]) == [1, 10, 17, 26, 39, 49, 65, 75, 77, 87, 103, 112, 121]", "assert flatten_list([3, 7, [24, 25], 43, 45, [55, 69, 83], [90, 105, 108, 121]]) == [3, 7, 24, 25, 43, 45, 55, 69, 83, 90, 105, 108, 121]", "assert flatten_list([5, 15, [16, 34], 37, 49, [61, 68, 84], [95, 95, 114, 125]]) == [5, 15, 16, 34, 37, 49, 61, 68, 84, 95, 95, 114, 125]", "assert flatten_list([3, 5, [20, 29], 35, 48, [56, 71, 85], [85, 104, 108, 122]]) == [3, 5, 20, 29, 35, 48, 56, 71, 85, 85, 104, 108, 122]", "assert flatten_list([1, 11, [22, 26], 45, 53, [61, 74, 83], [90, 97, 113, 118]]) == [1, 11, 22, 26, 45, 53, 61, 74, 83, 90, 97, 113, 118]", "assert flatten_list([5, 8, [15, 32], 41, 50, [56, 75, 82], [90, 104, 114, 125]]) == [5, 8, 15, 32, 41, 50, 56, 75, 82, 90, 104, 114, 125]", "assert flatten_list([4, 8, [23, 27], 36, 55, [60, 71, 78], [85, 105, 108, 125]]) == [4, 8, 23, 27, 36, 55, 60, 71, 78, 85, 105, 108, 125]", "assert flatten_list([2, 11, [22, 34], 41, 48, [65, 68, 82], [85, 101, 108, 124]]) == [2, 11, 22, 34, 41, 48, 65, 68, 82, 85, 101, 108, 124]", "assert flatten_list([4, 11, [19, 35], 37, 55, [63, 70, 75], [95, 97, 108, 116]]) == [4, 11, 19, 35, 37, 55, 63, 70, 75, 95, 97, 108, 116]", "assert flatten_list([1, 13, [16, 28], 40, 46, [62, 72, 78], [95, 101, 109, 117]]) == [1, 13, 16, 28, 40, 46, 62, 72, 78, 95, 101, 109, 117]", "assert flatten_list([3, 9, [23, 27], 38, 53, [63, 71, 79], [93, 104, 111, 117]]) == [3, 9, 23, 27, 38, 53, 63, 71, 79, 93, 104, 111, 117]", "assert flatten_list([2, 15, [15, 35], 37, 51, [57, 68, 75], [90, 96, 112, 116]]) == [2, 15, 15, 35, 37, 51, 57, 68, 75, 90, 96, 112, 116]", "assert flatten_list([2, 6, [23, 35], 43, 52, [56, 69, 75], [86, 95, 112, 120]]) == [2, 6, 23, 35, 43, 52, 56, 69, 75, 86, 95, 112, 120]", "assert flatten_list([5, 7, [23, 33], 44, 48, [63, 71, 76], [85, 104, 114, 117]]) == [5, 7, 23, 33, 44, 48, 63, 71, 76, 85, 104, 114, 117]", "assert flatten_list([2, 12, [20, 35], 35, 48, [57, 72, 76], [85, 95, 105, 119]]) == [2, 12, 20, 35, 35, 48, 57, 72, 76, 85, 95, 105, 119]", "assert flatten_list([5, 8, [23, 25], 45, 48, [57, 75, 80], [90, 98, 108, 120]]) == [5, 8, 23, 25, 45, 48, 57, 75, 80, 90, 98, 108, 120]", "assert flatten_list([2, 13, [19, 26], 35, 51, [64, 70, 80], [92, 100, 107, 115]]) == [2, 13, 19, 26, 35, 51, 64, 70, 80, 92, 100, 107, 115]", "assert flatten_list([2, 11, [19, 29], 44, 53, [58, 71, 82], [93, 103, 111, 116]]) == [2, 11, 19, 29, 44, 53, 58, 71, 82, 93, 103, 111, 116]", "assert flatten_list([4, 14, [19, 32], 44, 45, [59, 74, 84], [93, 97, 115, 122]]) == [4, 14, 19, 32, 44, 45, 59, 74, 84, 93, 97, 115, 122]", "assert flatten_list([2, 10, [16, 35], 43, 54, [64, 75, 85], [86, 98, 106, 116]]) == [2, 10, 16, 35, 43, 54, 64, 75, 85, 86, 98, 106, 116]", "assert flatten_list([2, 8, [16, 31], 36, 49, [55, 68, 77], [94, 103, 105, 124]]) == [2, 8, 16, 31, 36, 49, 55, 68, 77, 94, 103, 105, 124]", "assert flatten_list([1, 13, [22, 26], 37, 46, [61, 73, 81], [90, 103, 107, 124]]) == [1, 13, 22, 26, 37, 46, 61, 73, 81, 90, 103, 107, 124]", "assert flatten_list([3, 14, [22, 26], 44, 45, [56, 73, 85], [89, 103, 112, 121]]) == [3, 14, 22, 26, 44, 45, 56, 73, 85, 89, 103, 112, 121]", "assert flatten_list([3, 11, [20, 26], 38, 53, [59, 65, 76], [93, 99, 114, 122]]) == [3, 11, 20, 26, 38, 53, 59, 65, 76, 93, 99, 114, 122]", "assert flatten_list([4, 6, [16, 31], 42, 48, [55, 67, 85], [86, 97, 112, 124]]) == [4, 6, 16, 31, 42, 48, 55, 67, 85, 86, 97, 112, 124]", "assert flatten_list([5, 9, [16, 26], 35, 49, [65, 74, 77], [91, 98, 109, 119]]) == [5, 9, 16, 26, 35, 49, 65, 74, 77, 91, 98, 109, 119]", "assert flatten_list([4, 5, [25, 25], 45, 55, [63, 68, 77], [91, 105, 105, 118]]) == [4, 5, 25, 25, 45, 55, 63, 68, 77, 91, 105, 105, 118]", "assert flatten_list([[11, 21], [42], [28, 57, 26], [11, 16], [36], [37]]) == [11, 21, 42, 28, 57, 26, 11, 16, 36, 37]", "assert flatten_list([[10, 23], [40], [31, 51, 25], [15, 18], [37], [43]]) == [10, 23, 40, 31, 51, 25, 15, 18, 37, 43]", "assert flatten_list([[6, 21], [37], [30, 61, 29], [7, 22], [33], [41]]) == [6, 21, 37, 30, 61, 29, 7, 22, 33, 41]", "assert flatten_list([[12, 23], [39], [33, 53, 22], [10, 22], [38], [43]]) == [12, 23, 39, 33, 53, 22, 10, 22, 38, 43]", "assert flatten_list([[11, 17], [40], [31, 57, 24], [9, 15], [30], [43]]) == [11, 17, 40, 31, 57, 24, 9, 15, 30, 43]", "assert flatten_list([[15, 20], [35], [27, 55, 28], [13, 21], [38], [39]]) == [15, 20, 35, 27, 55, 28, 13, 21, 38, 39]", "assert flatten_list([[13, 22], [35], [31, 54, 27], [15, 24], [37], [41]]) == [13, 22, 35, 31, 54, 27, 15, 24, 37, 41]", "assert flatten_list([[12, 23], [43], [32, 55, 27], [5, 18], [32], [43]]) == [12, 23, 43, 32, 55, 27, 5, 18, 32, 43]", "assert flatten_list([[8, 21], [40], [30, 61, 21], [11, 22], [33], [42]]) == [8, 21, 40, 30, 61, 21, 11, 22, 33, 42]", "assert flatten_list([[11, 20], [39], [28, 60, 27], [8, 22], [31], [42]]) == [11, 20, 39, 28, 60, 27, 8, 22, 31, 42]", "assert flatten_list([[6, 19], [39], [31, 53, 24], [8, 23], [33], [42]]) == [6, 19, 39, 31, 53, 24, 8, 23, 33, 42]", "assert flatten_list([[9, 23], [37], [29, 55, 23], [15, 18], [35], [36]]) == [9, 23, 37, 29, 55, 23, 15, 18, 35, 36]", "assert flatten_list([[13, 23], [44], [28, 52, 24], [11, 17], [29], [40]]) == [13, 23, 44, 28, 52, 24, 11, 17, 29, 40]", "assert flatten_list([[11, 21], [36], [35, 60, 24], [7, 15], [29], [39]]) == [11, 21, 36, 35, 60, 24, 7, 15, 29, 39]", "assert flatten_list([[6, 20], [35], [30, 51, 21], [13, 19], [31], [35]]) == [6, 20, 35, 30, 51, 21, 13, 19, 31, 35]", "assert flatten_list([[14, 18], [40], [26, 53, 30], [11, 24], [34], [36]]) == [14, 18, 40, 26, 53, 30, 11, 24, 34, 36]", "assert flatten_list([[15, 16], [43], [26, 60, 25], [8, 20], [28], [37]]) == [15, 16, 43, 26, 60, 25, 8, 20, 28, 37]", "assert flatten_list([[7, 25], [35], [25, 51, 26], [8, 21], [29], [45]]) == [7, 25, 35, 25, 51, 26, 8, 21, 29, 45]", "assert flatten_list([[13, 23], [44], [35, 56, 27], [12, 16], [31], [45]]) == [13, 23, 44, 35, 56, 27, 12, 16, 31, 45]", "assert flatten_list([[9, 18], [39], [30, 61, 29], [9, 20], [31], [41]]) == [9, 18, 39, 30, 61, 29, 9, 20, 31, 41]", "assert flatten_list([[12, 16], [45], [33, 54, 24], [13, 19], [38], [43]]) == [12, 16, 45, 33, 54, 24, 13, 19, 38, 43]", "assert flatten_list([[14, 23], [38], [30, 58, 24], [7, 16], [37], [43]]) == [14, 23, 38, 30, 58, 24, 7, 16, 37, 43]", "assert flatten_list([[6, 17], [45], [26, 58, 23], [8, 18], [32], [36]]) == [6, 17, 45, 26, 58, 23, 8, 18, 32, 36]", "assert flatten_list([[15, 19], [43], [26, 57, 28], [7, 22], [34], [39]]) == [15, 19, 43, 26, 57, 28, 7, 22, 34, 39]", "assert flatten_list([[6, 16], [37], [25, 61, 25], [8, 20], [36], [42]]) == [6, 16, 37, 25, 61, 25, 8, 20, 36, 42]", "assert flatten_list([[12, 15], [41], [33, 60, 24], [10, 18], [33], [38]]) == [12, 15, 41, 33, 60, 24, 10, 18, 33, 38]", "assert flatten_list([[13, 18], [35], [26, 51, 22], [13, 19], [31], [45]]) == [13, 18, 35, 26, 51, 22, 13, 19, 31, 45]", "assert flatten_list([[15, 22], [39], [29, 53, 20], [9, 22], [29], [36]]) == [15, 22, 39, 29, 53, 20, 9, 22, 29, 36]", "assert flatten_list([[8, 15], [40], [25, 52, 23], [7, 18], [33], [35]]) == [8, 15, 40, 25, 52, 23, 7, 18, 33, 35]", "assert flatten_list([[11, 24], [39], [34, 53, 29], [5, 17], [33], [35]]) == [11, 24, 39, 34, 53, 29, 5, 17, 33, 35]", "assert flatten_list([[14, 24], [43], [27, 58, 20], [9, 16], [35], [40]]) == [14, 24, 43, 27, 58, 20, 9, 16, 35, 40]", "assert flatten_list([[9, 21], [44], [32, 54, 21], [10, 15], [36], [36]]) == [9, 21, 44, 32, 54, 21, 10, 15, 36, 36]", "assert flatten_list([[6, 18], [35], [32, 54, 25], [11, 23], [30], [42]]) == [6, 18, 35, 32, 54, 25, 11, 23, 30, 42]", "assert flatten_list([[3, 4, 4], [9, 7, 8], [10, 15, 16], [11, 4, 12]]) == [3, 4, 4, 9, 7, 8, 10, 15, 16, 11, 4, 12]", "assert flatten_list([[4, 1, 4], [3, 1, 5], [13, 11, 8], [10, 3, 4]]) == [4, 1, 4, 3, 1, 5, 13, 11, 8, 10, 3, 4]", "assert flatten_list([[3, 1, 3], [1, 6, 4], [13, 6, 16], [11, 12, 10]]) == [3, 1, 3, 1, 6, 4, 13, 6, 16, 11, 12, 10]", "assert flatten_list([[3, 2, 7], [7, 9, 8], [14, 8, 7], [5, 6, 8]]) == [3, 2, 7, 7, 9, 8, 14, 8, 7, 5, 6, 8]", "assert flatten_list([[4, 1, 2], [9, 6, 2], [9, 15, 17], [9, 5, 13]]) == [4, 1, 2, 9, 6, 2, 9, 15, 17, 9, 5, 13]", "assert flatten_list([[1, 2, 2], [8, 1, 7], [10, 14, 12], [11, 11, 10]]) == [1, 2, 2, 8, 1, 7, 10, 14, 12, 11, 11, 10]", "assert flatten_list([[2, 7, 2], [8, 4, 3], [10, 10, 13], [3, 3, 5]]) == [2, 7, 2, 8, 4, 3, 10, 10, 13, 3, 3, 5]", "assert flatten_list([[3, 6, 5], [2, 1, 8], [6, 16, 16], [4, 13, 7]]) == [3, 6, 5, 2, 1, 8, 6, 16, 16, 4, 13, 7]", "assert flatten_list([[2, 3, 1], [8, 9, 2], [15, 16, 8], [7, 9, 6]]) == [2, 3, 1, 8, 9, 2, 15, 16, 8, 7, 9, 6]", "assert flatten_list([[3, 3, 8], [6, 6, 11], [15, 6, 10], [8, 4, 13]]) == [3, 3, 8, 6, 6, 11, 15, 6, 10, 8, 4, 13]", "assert flatten_list([[2, 2, 2], [5, 4, 4], [14, 8, 11], [3, 11, 13]]) == [2, 2, 2, 5, 4, 4, 14, 8, 11, 3, 11, 13]", "assert flatten_list([[2, 2, 8], [7, 9, 6], [8, 6, 17], [9, 9, 12]]) == [2, 2, 8, 7, 9, 6, 8, 6, 17, 9, 9, 12]", "assert flatten_list([[2, 4, 3], [1, 4, 10], [10, 8, 14], [10, 8, 4]]) == [2, 4, 3, 1, 4, 10, 10, 8, 14, 10, 8, 4]", "assert flatten_list([[1, 1, 1], [5, 5, 1], [12, 12, 9], [4, 4, 10]]) == [1, 1, 1, 5, 5, 1, 12, 12, 9, 4, 4, 10]", "assert flatten_list([[5, 1, 5], [6, 5, 10], [8, 14, 12], [10, 9, 14]]) == [5, 1, 5, 6, 5, 10, 8, 14, 12, 10, 9, 14]", "assert flatten_list([[1, 2, 2], [5, 4, 11], [14, 11, 16], [6, 12, 9]]) == [1, 2, 2, 5, 4, 11, 14, 11, 16, 6, 12, 9]", "assert flatten_list([[3, 2, 3], [2, 8, 11], [13, 16, 9], [2, 7, 13]]) == [3, 2, 3, 2, 8, 11, 13, 16, 9, 2, 7, 13]", "assert flatten_list([[2, 6, 6], [1, 4, 5], [5, 11, 10], [3, 12, 6]]) == [2, 6, 6, 1, 4, 5, 5, 11, 10, 3, 12, 6]", "assert flatten_list([[5, 6, 8], [6, 4, 8], [5, 11, 10], [8, 8, 4]]) == [5, 6, 8, 6, 4, 8, 5, 11, 10, 8, 8, 4]", "assert flatten_list([[2, 4, 7], [8, 1, 1], [8, 16, 8], [7, 13, 9]]) == [2, 4, 7, 8, 1, 1, 8, 16, 8, 7, 13, 9]", "assert flatten_list([[1, 2, 3], [9, 3, 8], [10, 7, 13], [10, 8, 13]]) == [1, 2, 3, 9, 3, 8, 10, 7, 13, 10, 8, 13]", "assert flatten_list([[1, 5, 8], [1, 9, 5], [5, 7, 9], [12, 11, 6]]) == [1, 5, 8, 1, 9, 5, 5, 7, 9, 12, 11, 6]", "assert flatten_list([[1, 3, 2], [3, 9, 10], [5, 11, 16], [11, 5, 5]]) == [1, 3, 2, 3, 9, 10, 5, 11, 16, 11, 5, 5]", "assert flatten_list([[3, 5, 4], [8, 6, 6], [9, 7, 16], [6, 7, 9]]) == [3, 5, 4, 8, 6, 6, 9, 7, 16, 6, 7, 9]", "assert flatten_list([[1, 1, 1], [2, 3, 7], [9, 13, 12], [9, 13, 7]]) == [1, 1, 1, 2, 3, 7, 9, 13, 12, 9, 13, 7]", "assert flatten_list([[4, 5, 3], [8, 4, 1], [8, 16, 11], [7, 11, 6]]) == [4, 5, 3, 8, 4, 1, 8, 16, 11, 7, 11, 6]", "assert flatten_list([[3, 2, 8], [4, 9, 4], [10, 7, 13], [2, 7, 13]]) == [3, 2, 8, 4, 9, 4, 10, 7, 13, 2, 7, 13]", "assert flatten_list([[4, 7, 5], [6, 5, 5], [12, 11, 12], [3, 13, 5]]) == [4, 7, 5, 6, 5, 5, 12, 11, 12, 3, 13, 5]", "assert flatten_list([[1, 1, 4], [6, 7, 8], [10, 16, 9], [3, 6, 10]]) == [1, 1, 4, 6, 7, 8, 10, 16, 9, 3, 6, 10]", "assert flatten_list([[6, 1, 7], [4, 5, 11], [8, 14, 11], [9, 8, 12]]) == [6, 1, 7, 4, 5, 11, 8, 14, 11, 9, 8, 12]", "assert flatten_list([[3, 4, 4], [8, 9, 6], [10, 6, 16], [8, 4, 11]]) == [3, 4, 4, 8, 9, 6, 10, 6, 16, 8, 4, 11]", "assert flatten_list([[2, 4, 8], [8, 10, 6], [5, 13, 8], [6, 3, 14]]) == [2, 4, 8, 8, 10, 6, 5, 13, 8, 6, 3, 14]", "assert flatten_list([[3, 7, 8], [8, 10, 4], [9, 9, 9], [9, 13, 7]]) == [3, 7, 8, 8, 10, 4, 9, 9, 9, 9, 13, 7]"], "entry_point": "flatten_list", "repair_prompt": ["Write a function flatten_list to flatten a given nested list structure. A nested list contains other lists as its elements, and your function should return a single-level list containing all the elements from the nested list.\nflatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n", " Write a function flatten_list to convert a given nested list into a single-level list. A nested list contains other lists as its elements, and your function should return a single-level list that includes all the elements from the nested list.\nflatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n", " Write a function flatten_list to flatten a given nested list structure. A nested list contains other lists as its elements, and your function should return a single-level list containing all the elements from the nested list.\nflatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n"], "completions": ["from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Flattens a nested list.\n\n    Args:\n        nested_list (list): A list that may contain nested lists.\n\n    Returns:\n        list: A flattened list with no nested lists.\n    \"\"\"\n    def is_list(element):\n        \"\"\"\n        Checks if an element is a list.\n\n        Args:\n            element: The element to check.\n\n        Returns:\n            bool: True if the element is a list, False otherwise.\n        \"\"\"\n        return isinstance(element, list)\n\n    def flatten(element):\n        \"\"\"\n        Recursively flattens a list.\n\n        Args:\n            element: The element to flatten.\n\n        Returns:\n            list: A flattened list.\n        \"\"\"\n        result = []\n        for item in element:\n            if is_list(item):\n                result.extend(flatten(item))\n            else:\n                result.append(item)\n        return result\n\n    return flatten(nested_list)\n\n# Example usage:\n# print(flatten_list([[], [1, 2], [3, [4, 5]]]))  # Output: [1, 2, 3, 4, 5]\n", "from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Flattens a nested list of any depth.\n\n    Args:\n        nested_list (list): The list to be flattened.\n\n    Returns:\n        list: A flattened list.\n    \"\"\"\n    result = []\n\n    def _flatten(sublist):\n        for item in sublist:\n            if isinstance(item, list):\n                _flatten(item)\n            else:\n                result.append(item)\n\n    _flatten(nested_list)\n    return result\n\n# Example usage:\n# flattened_list = flatten_list([[], [1, 2], [3, [4, 5]]])\n# print(flattened_list)  # Output: [1, 2, 3, 4, 5]\n", "from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Flattens a nested list into a single-level list.\n\n    Args:\n        nested_list (list): A list that may contain other lists as elements.\n\n    Returns:\n        list: A single-level list containing all elements from the nested list.\n    \"\"\"\n    flattened = []\n    \n    for element in nested_list:\n        if isinstance(element, list):\n            flattened.extend(flatten_list(element))\n        else:\n            flattened.append(element)\n    \n    return flattened\n", "from typing import List\n## main.py\n\nfrom typing import List, Union\n\ndef flatten_list(nested_list: List[Union[int, List[int]]]) -> List[int]:\n    \"\"\"\n    Flattens a nested list into a single-level list.\n\n    Args:\n        nested_list (List[Union[int, List[int]]]): A list that may contain sublists.\n\n    Returns:\n        List[int]: A flattened list with no nested sublists.\n    \"\"\"\n    result = []\n\n    def _flatten(sublist: List[Union[int, List[int]]]):\n        for item in sublist:\n            if isinstance(item, list):\n                _flatten(item)\n            else:\n                result.append(item)\n\n    _flatten(nested_list)\n    return result\n", "from typing import List\n## main.py\n\nimport itertools\nfrom typing import List, Union\n\ndef flatten_list(nested_list: List[Union[int, List[int]]]) -> List[int]:\n    \"\"\"\n    Flattens a nested list into a single-level list.\n    \n    Args:\n        nested_list (List[Union[int, List[int]]]): A list that may contain nested lists.\n        \n    Returns:\n        List[int]: A single-level list containing all elements from the nested list.\n    \"\"\"\n    def flatten(element):\n        if isinstance(element, list):\n            for sub_element in element:\n                yield from flatten(sub_element)\n        else:\n            yield element\n\n    return list(flatten(nested_list))\n\n# Example usage:\nif __name__ == \"__main__\":\n    nested_list = [0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]\n    print(flatten_list(nested_list))  # Output: [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n", "from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Flattens a nested list into a single-level list.\n\n    Args:\n        nested_list (list): The list to be flattened.\n\n    Returns:\n        list: A flattened list.\n    \"\"\"\n    result = []\n\n    def _flatten(sublist):\n        for item in sublist:\n            if isinstance(item, list):\n                _flatten(item)\n            else:\n                result.append(item)\n\n    _flatten(nested_list)\n    return result\n", "from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Flattens a nested list structure into a single-level list.\n\n    Args:\n        nested_list (list): The list to be flattened.\n\n    Returns:\n        list: A single-level list containing all elements from the nested list.\n    \"\"\"\n    result = []\n\n    def _flatten(sublist):\n        for item in sublist:\n            if isinstance(item, list):\n                _flatten(item)\n            else:\n                result.append(item)\n\n    _flatten(nested_list)\n    return result\n", "from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Flattens a nested list structure into a single-level list.\n\n    Args:\n        nested_list (list): A list that may contain other lists as elements.\n\n    Returns:\n        list: A flattened list containing all elements from the nested list.\n    \"\"\"\n    result = []\n\n    def _flatten(sublist):\n        for item in sublist:\n            if isinstance(item, list):\n                _flatten(item)\n            else:\n                result.append(item)\n\n    _flatten(nested_list)\n    return result\n", "from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Flattens a nested list into a single-level list.\n\n    Args:\n        nested_list (list): The list to be flattened.\n\n    Returns:\n        list: A flattened list.\n    \"\"\"\n    result = []\n\n    def _flatten(sublist):\n        for item in sublist:\n            if isinstance(item, list):\n                _flatten(item)\n            else:\n                result.append(item)\n\n    _flatten(nested_list)\n    return result\n", "from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Flattens a nested list.\n\n    Args:\n        nested_list (list): A list that may contain other lists as elements.\n\n    Returns:\n        list: A flattened list with no nested lists.\n    \"\"\"\n    result = []\n\n    def _flatten(sublist):\n        for item in sublist:\n            if isinstance(item, list):\n                _flatten(item)\n            else:\n                result.append(item)\n\n    _flatten(nested_list)\n    return result\n"], "plans": ["requirement analysis:\nThe requirement is clear and straightforward. The function needs to handle various levels of nested lists, from simple to deeply nested structures. The output should be a single-level list containing all elements from the input.\nrequirement pool:\n- The main code should handle all types of nested lists efficiently.\n- The function should be easy to understand and use.\n- The UI should be clean and intuitive.\nTo implement the `flatten_list` function efficiently, we will use a recursive approach to handle nested lists. This method will ensure that the function can handle deep nested structures without limitations. The function will iterate through each element in the input list, and if an element is a list, the function will recursively flatten it. Otherwise, the element will be added to the result list. This approach ensures that the function is both efficient and easy to understand.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': A list that contains other lists as its elements.\n    Explanation: In the requirement, we are dealing with a list structure where some of the elements are themselves lists. The goal is to flatten this structure into a single-level list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests a recursive approach to handle nested lists. The function will iterate through each element, and if it encounters a list, it will recursively flatten it. This ensures that all levels of nesting are handled.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists and nested lists. The function should handle these cases by recursively flattening each sublist. The expected output is a single-level list containing all elements from the nested structure.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach in the plan is sufficient to handle cases with empty lists and multiple levels of nesting.\n\n# [core concept]\n    'recursive': A programming technique where a function calls itself in order to solve a problem by breaking it down into smaller instances of the same problem.\n    Explanation: In the requirement, the plan suggests using a recursive approach to handle nested lists. This means that the function will call itself to process each sublist until all nested lists are flattened into a single-level list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests a recursive approach to handle nested lists. The function will iterate through each element, and if it encounters a list, it will recursively flatten it. This ensures that all levels of nesting are handled.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists and nested lists. The function should handle these cases by recursively flattening each sublist. The expected output is a single-level list containing all elements from the nested structure.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach in the plan is sufficient to handle cases with empty lists and multiple levels of nesting.\n", "requirement analysis:\nThe requirement is to create a function that can flatten any nested list structure into a single-level list. The function should handle various levels of nesting and ensure that all elements are included in the final list. The solution should be efficient and compatible with different types of nested lists.\nrequirement pool:\n- Implement a recursive function to handle nested lists of any depth.\n- Ensure the function can handle lists of varying data types.\n- Optimize the function for performance to handle large nested lists efficiently.\n- Include error handling to manage non-list elements within the nested structure.\n- Provide clear documentation and examples to assist users in understanding and using the function.\nTo implement the `flatten_list` function, we will use a recursive approach to handle nested lists of any depth. The function will iterate through each element in the input list, and if an element is a list, the function will recursively call itself on that element. Otherwise, the element will be added to the result list. Additionally, we will include error handling to manage non-list elements within the nested structure, ensuring that the function can handle lists of varying data types.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': a list that contains other lists as its elements.\n    Explanation: In the requirement, the function needs to handle lists that can contain other lists inside them, which is a core concept of the problem.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests a recursive approach to handle nested lists. The steps include:\n    1. Iterate through each element in the input list.\n    2. If an element is a list, recursively call the function on that element.\n    3. If an element is not a list, add it to the result list.\n    4. Return the flattened list.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists, single-level lists, and a nested list. The function should handle these cases by recursively flattening the nested lists and returning a single-level list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach in the plan is sufficient to handle empty lists and nested lists of varying depths.\n", "requirement analysis:\nThe requirement is to create a function that can flatten any nested list structure into a single-level list. This involves handling different depths of nesting and ensuring that all elements are included in the final list. The function should be efficient and able to handle various types of nested lists.\nrequirement pool:\n- The main code should be clear and concise, using Pythonic practices.\n- The function should handle lists of varying depths of nesting.\n- Implement error handling for non-list elements within the nested structure.\n- Optimize the function for performance, especially for large nested lists.\n- Include optional parameters for controlling the flattening process, such as depth limit.\nTo implement the `flatten_list` function, we will use Python's built-in `itertools.chain` function, which is efficient and handles chaining iterables. This approach will be simple and leverage Python's standard library to ensure compatibility and ease of use. We will also handle potential non-list elements within the nested structure by checking each element before flattening.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': A list that contains other lists as its elements.\n    Explanation: In the requirement, we are dealing with a list structure where some of its elements are also lists. Our task is to flatten this structure into a single-level list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the `flatten_list` function, we will use a recursive approach to handle nested lists. Here's a step-by-step breakdown:\n    1. Define the function `flatten_list` that takes a list as an argument.\n    2. Initialize an empty list to store the flattened elements.\n    3. Iterate through each element in the input list.\n    4. If an element is a list, recursively call `flatten_list` on that element and extend the result to the flattened list.\n    5. If an element is not a list, append it directly to the flattened list.\n    6. Return the flattened list.\n\n# [edge case] \n    flatten_list([[], [1, 2, 3], [4, [5, 6]]]) = [1, 2, 3, 4, 5, 6]\n    Explanation: The input list contains empty lists and nested lists. The function should handle these cases by recursively flattening each nested list and ignoring empty lists.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach in the code logic inherently handles cases where elements are empty lists or deeply nested lists.\n\n# [code logic]\n```python\ndef flatten_list(nested_list):\n    flattened = []\n    for element in nested_list:\n        if isinstance(element, list):\n            flattened.extend(flatten_list(element))\n        else:\n            flattened.append(element)\n    return flattened\n```\n", "requirement analysis:\nThe requirement is to create a function that can flatten any nested list into a single-level list. This involves handling various levels of nesting and ensuring that all elements are included in the final list. The function should be efficient and able to handle different structures of nested lists.\nrequirement pool:\n- The main code should be simple and easy to understand.\n- The function should handle all types of nested lists correctly.\n- Ensure the function works efficiently even with deeply nested lists.\n- Include options for customization if needed.\n- Provide clear documentation and examples for users.\nTo create a function that can flatten any nested list into a single-level list, we will use Python's built-in `itertools.chain` function. This function is efficient and flexible, making it suitable for handling various levels of nesting. We will also ensure that the function is simple and easy to understand, adhering to the principle of P0: 'The main code should be simple and easy to understand.'\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': A list that contains other lists as its elements.\n    Explanation: In the requirement, we are dealing with a list that can contain sublists, and our task is to flatten this nested structure into a single-level list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the function `flatten_list`, we will use a recursive approach to handle the nested lists. We will iterate through each element in the input list. If an element is a list, we will recursively call the function on that sublist. Otherwise, we will add the element to our result list.\n\n    Here's a step-by-step breakdown of the logic:\n    1. Define the function `flatten_list` with one parameter `lst`.\n    2. Initialize an empty list `result` to store the flattened elements.\n    3. Iterate through each element in `lst`.\n    4. If an element is a list, call `flatten_list` recursively on that element and extend `result` with the returned flattened list.\n    5. If an element is not a list, append it to `result`.\n    6. Return the `result` list.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists and nested lists. The function should handle these cases by recursively flattening each sublist and ignoring empty lists.\n    flatten_list([1, [2, [3, [4, 5]]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list has a single nested list. The function should recursively flatten this nested list to produce a single-level list.\n    flatten_list([1, 2, 3, 4, 5]) = [1, 2, 3, 4, 5]\n    Explanation: The input list is already a single-level list, so the function should return it as is.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The recursive approach we have chosen naturally handles cases where the input list contains empty lists or multiple levels of nesting.\n", "requirement analysis:\nThe requirement is to create a function that can flatten any nested list into a single-level list. This involves understanding how to traverse through nested lists and collect all elements into a single list. The function should handle various levels of nesting and ensure that all elements are included in the final output.\nrequirement pool:\n- The main code should be efficient and handle all types of nested lists.\n- The function should be able to flatten lists of varying depths.\n- Implement error handling for non-list elements within the nested list.\n- Ensure the function can be easily integrated into existing projects.\n- Optimize the function for performance, especially for very large nested lists.\nTo create a function that can flatten any nested list into a single-level list, we will use Python's built-in `itertools.chain` function. This function is efficient and well-suited for this task as it can flatten any iterable, including nested lists. We will also handle potential errors by checking if elements are lists and recursively flattening them if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': a list that contains other lists as its elements.\n    'single-level list': a list that does not contain any other lists as its elements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To flatten a nested list, we can use a recursive approach or the `itertools.chain` function. Here's a detailed plan:\n    1. Define the `flatten_list` function.\n    2. Use a helper function that takes an element as input.\n    3. If the element is not a list, add it to the result.\n    4. If the element is a list, recursively call the helper function on each element of the list.\n    5. Use `list(itertools.chain(*input_list))` to flatten the list in one line.\n\n# [edge case] \n    flatten_list([[1, 2], [3, 4], [5, 6]]) = [1, 2, 3, 4, 5, 6]\n    Explanation: The input is a nested list with two sublists, each containing two elements. The function should return a single-level list containing all elements.\n    flatten_list([1, [2, [3, [4, 5]]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input is a nested list with multiple levels of nesting. The function should flatten all levels and return a single-level list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic using `itertools.chain` can handle any level of nesting.\n", "requirement analysis:\nThe requirement is to create a function that can flatten a nested list into a single-level list. This function should be able to handle various levels of nesting and should be efficient in terms of both time and space complexity. The function should be compatible with different types of nested lists and should be easy to integrate into existing projects.\nrequirement pool:\n- The main code should be simple and easy to understand.\n- The function should handle lists of varying depths of nesting.\n- The function should be optimized for performance.\n- The function should be tested for edge cases and potential errors.\n- The function should be documented and include examples of usage.\nTo create a function that can flatten a nested list into a single-level list, we will use a recursive approach. This method will be efficient and easy to understand. The function will iterate through each element in the list, and if an element is a list itself, the function will recursively flatten it. Otherwise, the element will be added to the result list. This approach ensures that the function can handle lists of varying depths of nesting and is optimized for performance.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': A list that contains other lists as its elements.\n    Explanation: In the requirement, we are dealing with a list that can contain sublists, and our task is to flatten this nested structure into a single-level list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (1) Define the function `flatten_list` with one parameter `nested_list`.\n    (2) Initialize an empty list called `result` to store the flattened elements.\n    (3) Iterate through each element in `nested_list`.\n    (4) If the element is a list, recursively call `flatten_list` on this element and extend the `result` list with the returned flattened list.\n    (5) If the element is not a list, append it to the `result` list.\n    (6) Return the `result` list after the iteration is complete.\n\n# [edge case] \n    flatten_list([[], [1, 2, 3], [4, [5, 6]]]) = [1, 2, 3, 4, 5, 6]\n    Explanation: The input list contains empty lists and nested lists. The function should handle these cases by skipping empty lists and recursively flattening nested lists.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach in the plan is sufficient to handle empty lists and nested lists.\n\n# [code logic]\n(1) Define the function `flatten_list` with one parameter `nested_list`.\n(2) Initialize an empty list called `result` to store the flattened elements.\n(3) Iterate through each element in `nested_list`.\n(4) If the element is a list, recursively call `flatten_list` on this element and extend the `result` list with the returned flattened list.\n(5) If the element is not a list, append it to the `result` list.\n(6) Return the `result` list after the iteration is complete.\n", "requirement analysis:\nThe requirement is to create a function that can flatten any nested list structure into a single-level list. This function should be efficient and handle various levels of nesting. The function should be compatible with Python's standard library and should perform well even with large nested lists.\nrequirement pool:\n- The main code should be simple and easy to understand.\n- The function should handle any level of nesting.\n- The function should be optimized for performance.\n- The function should be compatible with Python's standard library.\n- The function should include error handling for non-list elements.\nTo create a function that can flatten any nested list structure into a single-level list, we will use Python's built-in itertools.chain function. This function is efficient and handles the chaining of iterables, which is suitable for our purpose. We will also ensure that the function is optimized for performance and can handle various levels of nesting. Additionally, we will include error handling to manage non-list elements.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': A list that contains other lists as its elements.\n    Explanation: In the requirement, we are dealing with a list structure where some of its elements are also lists. Our task is to flatten this structure into a single-level list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the function `flatten_list`, we will use a recursive approach to handle nested lists. Here's a step-by-step breakdown:\n    1. Define the function `flatten_list` with one parameter `nested_list`.\n    2. Initialize an empty list `result` to store the flattened elements.\n    3. Iterate through each element in `nested_list`.\n    4. If an element is a list, recursively call `flatten_list` on that element and extend the `result` list with the returned flattened list.\n    5. If an element is not a list, append it directly to the `result` list.\n    6. Return the `result` list after processing all elements.\n\n# [edge case] \n    flatten_list([[1, 2], [3, 4]]) = [1, 2, 3, 4]\n    Explanation: The input is a nested list with two sublists. The function will flatten these sublists into a single-level list containing all elements.\n    flatten_list([1, [2, [3, 4], 5]]) = [1, 2, 3, 4, 5]\n    Explanation: The input contains a nested structure with multiple levels of nesting. The function will recursively flatten all levels to produce a single-level list.\n    flatten_list([[], [1, 2], []]) = [1, 2]\n    Explanation: The input contains empty lists which should be ignored. The function will only include non-empty lists in the final result.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The recursive approach in the code logic will naturally handle cases with empty lists by skipping them.\n", "requirement analysis:\nThe requirement is to create a function that can flatten any nested list structure into a single-level list. This function should handle various depths of nesting and ensure that all elements are included in the final list. The function should be efficient and able to handle large and complex nested lists.\nrequirement pool:\n- The main code should be written in Python.\n- The function should recursively flatten nested lists.\n- The function should handle lists of varying depths of nesting.\n- The function should be optimized for performance.\n- The function should include error handling for non-list elements.\nTo create a function that can flatten any nested list structure into a single-level list, we will use a recursive approach. This method will traverse through each element of the list, and if an element is a list itself, it will recursively flatten that sublist. We will ensure that all elements, regardless of their depth in the nested structure, are included in the final list. The function will also include error handling to manage non-list elements.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': A list that contains other lists as its elements.\n    Explanation: In the requirement, we are dealing with a list structure where some elements are themselves lists. The goal is to flatten this structure into a single-level list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests a recursive approach to handle the nested structure. The steps include:\n    1. Traverse each element in the list.\n    2. If an element is a list, recursively flatten it.\n    3. Append all elements (whether they are single elements or the result of a recursive call) to the result list.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists and nested lists. The function should handle these cases by skipping empty lists and recursively flattening nested lists.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach in the plan naturally handles empty lists by skipping them.\n\n# [core concept]\n    'recursive approach': A method of solving a problem by breaking it down into smaller, similar problems.\n    Explanation: The plan suggests using a recursive approach to handle the nested structure, which means the function will call itself with a smaller or simpler version of the problem until it reaches a base case.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests a recursive approach to handle the nested structure. The steps include:\n    1. Traverse each element in the list.\n    2. If an element is a list, recursively flatten it.\n    3. Append all elements (whether they are single elements or the result of a recursive call) to the result list.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists and nested lists. The function should handle these cases by skipping empty lists and recursively flattening nested lists.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach in the plan naturally handles empty lists by skipping them.\n", "requirement analysis:\nThe requirement is to create a function that can flatten any nested list structure into a single-level list. This function should be efficient and handle various levels of nesting. The function should be easy to use and understand, making it accessible for both beginners and experienced users.\nrequirement pool:\n- The main code should be efficient in handling nested lists of any depth.\n- The function should return a single-level list containing all elements from the nested list.\n- The function should be easy to understand and use, with clear documentation and examples.\n- The function should handle edge cases, such as empty lists or lists with non-list elements.\n- The function should be optimized for performance, ensuring it can handle large nested lists efficiently.\nTo create a function that can flatten any nested list structure into a single-level list efficiently, we will use a recursive approach. This method will traverse through each element in the nested list, and if an element is a list, it will recursively flatten it. Otherwise, it will add the element to the result list. This approach ensures that the function can handle lists of any depth and is efficient in terms of performance.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': A list that contains other lists as its elements.\n    Explanation: In the requirement, we are dealing with a list structure where some of the elements are themselves lists. Our task is to flatten this structure into a single-level list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the flattening of a nested list, we can use a recursive approach. We will iterate through each element in the list. If the element is a list, we recursively call the flattening function on it. Otherwise, we add the element to our result list. This ensures that we handle lists of any depth.\n\n# [edge case] \n    flatten_list([[], [1, 2, 3], [4, [5, 6]]]) = [1, 2, 3, 4, 5, 6]\n    Explanation: The input list contains empty lists and nested lists. The function should correctly flatten these into a single-level list, ignoring the empty lists and including all elements from the nested lists.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach we outlined will naturally handle cases with empty lists and nested lists without needing additional code.\n", "requirement analysis:\nThe requirement is clear and straightforward. The function needs to handle nested lists and flatten them into a single-level list. The challenge lies in ensuring the function is efficient and can handle deep nested structures without excessive memory usage or performance issues.\nrequirement pool:\n- The main code should be efficient in handling nested lists of varying depths.\n- The function should be easy to understand and use, with clear documentation.\n- Ensure the function can handle large nested lists without performance degradation.\n- Include tests to verify the function's correctness and robustness.\nTo implement the `flatten_list` function efficiently, we will use a recursive approach to handle nested lists. This method will ensure that the function can handle deep nested structures without excessive memory usage or performance issues. We will also use Python's built-in functions and libraries to keep the implementation simple and readable.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': A list that contains other lists as its elements.\n    Explanation: In the requirement, the function is expected to handle lists that can contain other lists within them, and the goal is to flatten this structure into a single-level list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests a recursive approach to handle nested lists. The steps include:\n    1. Define the function `flatten_list`.\n    2. Use a loop to iterate through each element in the input list.\n    3. Check if an element is a list. If it is, recursively call `flatten_list` on that element.\n    4. If an element is not a list, append it to a result list.\n    5. Return the result list after all elements have been processed.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists and nested lists. The function should handle these cases by recursively flattening each nested list and ignoring empty lists.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach in the plan already accounts for empty lists and nested lists.\n\n# [core concept]\n    'recursive approach': A method where a function calls itself to solve a problem by breaking it down into smaller instances of the same problem.\n    Explanation: The plan suggests using a recursive approach to handle nested lists, which means the function will call itself to process each nested list until all elements are flattened.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests a recursive approach to handle nested lists. The steps include:\n    1. Define the function `flatten_list`.\n    2. Use a loop to iterate through each element in the input list.\n    3. Check if an element is a list. If it is, recursively call `flatten_list` on that element.\n    4. If an element is not a list, append it to a result list.\n    5. Return the result list after all elements have been processed.\n\n# [edge case] \n    flatten_list([[], [1, 2], [3, [4, 5]]]) = [1, 2, 3, 4, 5]\n    Explanation: The input list contains empty lists and nested lists. The function should handle these cases by recursively flattening each nested list and ignoring empty lists.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The recursive approach in the plan already accounts for empty lists and nested lists.\n"], "test": ["def check(flatten_list):\n\tassert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]", "def check(flatten_list):\n\tassert flatten_list([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]])==[10, 20, 40, 30, 56, 25, 10, 20, 33, 40]", "def check(flatten_list):\n\tassert flatten_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])==[1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]", "def check(flatten_list):\n\tassert flatten_list([5, 15, [17, 25], 39, 49, [65, 69, 78], [86, 97, 110, 123]]) == [5, 15, 17, 25, 39, 49, 65, 69, 78, 86, 97, 110, 123]", "def check(flatten_list):\n\tassert flatten_list([5, 7, [15, 33], 39, 45, [65, 75, 82], [92, 104, 115, 116]]) == [5, 7, 15, 33, 39, 45, 65, 75, 82, 92, 104, 115, 116]", "def check(flatten_list):\n\tassert flatten_list([2, 9, [22, 28], 35, 52, [58, 68, 81], [87, 100, 105, 117]]) == [2, 9, 22, 28, 35, 52, 58, 68, 81, 87, 100, 105, 117]", "def check(flatten_list):\n\tassert flatten_list([5, 10, [24, 29], 42, 49, [65, 72, 85], [92, 97, 105, 119]]) == [5, 10, 24, 29, 42, 49, 65, 72, 85, 92, 97, 105, 119]", "def check(flatten_list):\n\tassert flatten_list([5, 15, [24, 32], 36, 50, [63, 74, 78], [85, 101, 113, 115]]) == [5, 15, 24, 32, 36, 50, 63, 74, 78, 85, 101, 113, 115]", "def check(flatten_list):\n\tassert flatten_list([4, 11, [15, 25], 37, 51, [64, 74, 82], [94, 101, 110, 117]]) == [4, 11, 15, 25, 37, 51, 64, 74, 82, 94, 101, 110, 117]", "def check(flatten_list):\n\tassert flatten_list([1, 10, [17, 26], 39, 49, [65, 75, 77], [87, 103, 112, 121]]) == [1, 10, 17, 26, 39, 49, 65, 75, 77, 87, 103, 112, 121]", "def check(flatten_list):\n\tassert flatten_list([3, 7, [24, 25], 43, 45, [55, 69, 83], [90, 105, 108, 121]]) == [3, 7, 24, 25, 43, 45, 55, 69, 83, 90, 105, 108, 121]", "def check(flatten_list):\n\tassert flatten_list([5, 15, [16, 34], 37, 49, [61, 68, 84], [95, 95, 114, 125]]) == [5, 15, 16, 34, 37, 49, 61, 68, 84, 95, 95, 114, 125]", "def check(flatten_list):\n\tassert flatten_list([3, 5, [20, 29], 35, 48, [56, 71, 85], [85, 104, 108, 122]]) == [3, 5, 20, 29, 35, 48, 56, 71, 85, 85, 104, 108, 122]", "def check(flatten_list):\n\tassert flatten_list([1, 11, [22, 26], 45, 53, [61, 74, 83], [90, 97, 113, 118]]) == [1, 11, 22, 26, 45, 53, 61, 74, 83, 90, 97, 113, 118]", "def check(flatten_list):\n\tassert flatten_list([5, 8, [15, 32], 41, 50, [56, 75, 82], [90, 104, 114, 125]]) == [5, 8, 15, 32, 41, 50, 56, 75, 82, 90, 104, 114, 125]", "def check(flatten_list):\n\tassert flatten_list([4, 8, [23, 27], 36, 55, [60, 71, 78], [85, 105, 108, 125]]) == [4, 8, 23, 27, 36, 55, 60, 71, 78, 85, 105, 108, 125]", "def check(flatten_list):\n\tassert flatten_list([2, 11, [22, 34], 41, 48, [65, 68, 82], [85, 101, 108, 124]]) == [2, 11, 22, 34, 41, 48, 65, 68, 82, 85, 101, 108, 124]", "def check(flatten_list):\n\tassert flatten_list([4, 11, [19, 35], 37, 55, [63, 70, 75], [95, 97, 108, 116]]) == [4, 11, 19, 35, 37, 55, 63, 70, 75, 95, 97, 108, 116]", "def check(flatten_list):\n\tassert flatten_list([1, 13, [16, 28], 40, 46, [62, 72, 78], [95, 101, 109, 117]]) == [1, 13, 16, 28, 40, 46, 62, 72, 78, 95, 101, 109, 117]", "def check(flatten_list):\n\tassert flatten_list([3, 9, [23, 27], 38, 53, [63, 71, 79], [93, 104, 111, 117]]) == [3, 9, 23, 27, 38, 53, 63, 71, 79, 93, 104, 111, 117]", "def check(flatten_list):\n\tassert flatten_list([2, 15, [15, 35], 37, 51, [57, 68, 75], [90, 96, 112, 116]]) == [2, 15, 15, 35, 37, 51, 57, 68, 75, 90, 96, 112, 116]", "def check(flatten_list):\n\tassert flatten_list([2, 6, [23, 35], 43, 52, [56, 69, 75], [86, 95, 112, 120]]) == [2, 6, 23, 35, 43, 52, 56, 69, 75, 86, 95, 112, 120]", "def check(flatten_list):\n\tassert flatten_list([5, 7, [23, 33], 44, 48, [63, 71, 76], [85, 104, 114, 117]]) == [5, 7, 23, 33, 44, 48, 63, 71, 76, 85, 104, 114, 117]", "def check(flatten_list):\n\tassert flatten_list([2, 12, [20, 35], 35, 48, [57, 72, 76], [85, 95, 105, 119]]) == [2, 12, 20, 35, 35, 48, 57, 72, 76, 85, 95, 105, 119]", "def check(flatten_list):\n\tassert flatten_list([5, 8, [23, 25], 45, 48, [57, 75, 80], [90, 98, 108, 120]]) == [5, 8, 23, 25, 45, 48, 57, 75, 80, 90, 98, 108, 120]", "def check(flatten_list):\n\tassert flatten_list([2, 13, [19, 26], 35, 51, [64, 70, 80], [92, 100, 107, 115]]) == [2, 13, 19, 26, 35, 51, 64, 70, 80, 92, 100, 107, 115]", "def check(flatten_list):\n\tassert flatten_list([2, 11, [19, 29], 44, 53, [58, 71, 82], [93, 103, 111, 116]]) == [2, 11, 19, 29, 44, 53, 58, 71, 82, 93, 103, 111, 116]", "def check(flatten_list):\n\tassert flatten_list([4, 14, [19, 32], 44, 45, [59, 74, 84], [93, 97, 115, 122]]) == [4, 14, 19, 32, 44, 45, 59, 74, 84, 93, 97, 115, 122]", "def check(flatten_list):\n\tassert flatten_list([2, 10, [16, 35], 43, 54, [64, 75, 85], [86, 98, 106, 116]]) == [2, 10, 16, 35, 43, 54, 64, 75, 85, 86, 98, 106, 116]", "def check(flatten_list):\n\tassert flatten_list([2, 8, [16, 31], 36, 49, [55, 68, 77], [94, 103, 105, 124]]) == [2, 8, 16, 31, 36, 49, 55, 68, 77, 94, 103, 105, 124]", "def check(flatten_list):\n\tassert flatten_list([1, 13, [22, 26], 37, 46, [61, 73, 81], [90, 103, 107, 124]]) == [1, 13, 22, 26, 37, 46, 61, 73, 81, 90, 103, 107, 124]", "def check(flatten_list):\n\tassert flatten_list([3, 14, [22, 26], 44, 45, [56, 73, 85], [89, 103, 112, 121]]) == [3, 14, 22, 26, 44, 45, 56, 73, 85, 89, 103, 112, 121]", "def check(flatten_list):\n\tassert flatten_list([3, 11, [20, 26], 38, 53, [59, 65, 76], [93, 99, 114, 122]]) == [3, 11, 20, 26, 38, 53, 59, 65, 76, 93, 99, 114, 122]", "def check(flatten_list):\n\tassert flatten_list([4, 6, [16, 31], 42, 48, [55, 67, 85], [86, 97, 112, 124]]) == [4, 6, 16, 31, 42, 48, 55, 67, 85, 86, 97, 112, 124]", "def check(flatten_list):\n\tassert flatten_list([5, 9, [16, 26], 35, 49, [65, 74, 77], [91, 98, 109, 119]]) == [5, 9, 16, 26, 35, 49, 65, 74, 77, 91, 98, 109, 119]", "def check(flatten_list):\n\tassert flatten_list([4, 5, [25, 25], 45, 55, [63, 68, 77], [91, 105, 105, 118]]) == [4, 5, 25, 25, 45, 55, 63, 68, 77, 91, 105, 105, 118]", "def check(flatten_list):\n\tassert flatten_list([[11, 21], [42], [28, 57, 26], [11, 16], [36], [37]]) == [11, 21, 42, 28, 57, 26, 11, 16, 36, 37]", "def check(flatten_list):\n\tassert flatten_list([[10, 23], [40], [31, 51, 25], [15, 18], [37], [43]]) == [10, 23, 40, 31, 51, 25, 15, 18, 37, 43]", "def check(flatten_list):\n\tassert flatten_list([[6, 21], [37], [30, 61, 29], [7, 22], [33], [41]]) == [6, 21, 37, 30, 61, 29, 7, 22, 33, 41]", "def check(flatten_list):\n\tassert flatten_list([[12, 23], [39], [33, 53, 22], [10, 22], [38], [43]]) == [12, 23, 39, 33, 53, 22, 10, 22, 38, 43]", "def check(flatten_list):\n\tassert flatten_list([[11, 17], [40], [31, 57, 24], [9, 15], [30], [43]]) == [11, 17, 40, 31, 57, 24, 9, 15, 30, 43]", "def check(flatten_list):\n\tassert flatten_list([[15, 20], [35], [27, 55, 28], [13, 21], [38], [39]]) == [15, 20, 35, 27, 55, 28, 13, 21, 38, 39]", "def check(flatten_list):\n\tassert flatten_list([[13, 22], [35], [31, 54, 27], [15, 24], [37], [41]]) == [13, 22, 35, 31, 54, 27, 15, 24, 37, 41]", "def check(flatten_list):\n\tassert flatten_list([[12, 23], [43], [32, 55, 27], [5, 18], [32], [43]]) == [12, 23, 43, 32, 55, 27, 5, 18, 32, 43]", "def check(flatten_list):\n\tassert flatten_list([[8, 21], [40], [30, 61, 21], [11, 22], [33], [42]]) == [8, 21, 40, 30, 61, 21, 11, 22, 33, 42]", "def check(flatten_list):\n\tassert flatten_list([[11, 20], [39], [28, 60, 27], [8, 22], [31], [42]]) == [11, 20, 39, 28, 60, 27, 8, 22, 31, 42]", "def check(flatten_list):\n\tassert flatten_list([[6, 19], [39], [31, 53, 24], [8, 23], [33], [42]]) == [6, 19, 39, 31, 53, 24, 8, 23, 33, 42]", "def check(flatten_list):\n\tassert flatten_list([[9, 23], [37], [29, 55, 23], [15, 18], [35], [36]]) == [9, 23, 37, 29, 55, 23, 15, 18, 35, 36]", "def check(flatten_list):\n\tassert flatten_list([[13, 23], [44], [28, 52, 24], [11, 17], [29], [40]]) == [13, 23, 44, 28, 52, 24, 11, 17, 29, 40]", "def check(flatten_list):\n\tassert flatten_list([[11, 21], [36], [35, 60, 24], [7, 15], [29], [39]]) == [11, 21, 36, 35, 60, 24, 7, 15, 29, 39]", "def check(flatten_list):\n\tassert flatten_list([[6, 20], [35], [30, 51, 21], [13, 19], [31], [35]]) == [6, 20, 35, 30, 51, 21, 13, 19, 31, 35]", "def check(flatten_list):\n\tassert flatten_list([[14, 18], [40], [26, 53, 30], [11, 24], [34], [36]]) == [14, 18, 40, 26, 53, 30, 11, 24, 34, 36]", "def check(flatten_list):\n\tassert flatten_list([[15, 16], [43], [26, 60, 25], [8, 20], [28], [37]]) == [15, 16, 43, 26, 60, 25, 8, 20, 28, 37]", "def check(flatten_list):\n\tassert flatten_list([[7, 25], [35], [25, 51, 26], [8, 21], [29], [45]]) == [7, 25, 35, 25, 51, 26, 8, 21, 29, 45]", "def check(flatten_list):\n\tassert flatten_list([[13, 23], [44], [35, 56, 27], [12, 16], [31], [45]]) == [13, 23, 44, 35, 56, 27, 12, 16, 31, 45]", "def check(flatten_list):\n\tassert flatten_list([[9, 18], [39], [30, 61, 29], [9, 20], [31], [41]]) == [9, 18, 39, 30, 61, 29, 9, 20, 31, 41]", "def check(flatten_list):\n\tassert flatten_list([[12, 16], [45], [33, 54, 24], [13, 19], [38], [43]]) == [12, 16, 45, 33, 54, 24, 13, 19, 38, 43]", "def check(flatten_list):\n\tassert flatten_list([[14, 23], [38], [30, 58, 24], [7, 16], [37], [43]]) == [14, 23, 38, 30, 58, 24, 7, 16, 37, 43]", "def check(flatten_list):\n\tassert flatten_list([[6, 17], [45], [26, 58, 23], [8, 18], [32], [36]]) == [6, 17, 45, 26, 58, 23, 8, 18, 32, 36]", "def check(flatten_list):\n\tassert flatten_list([[15, 19], [43], [26, 57, 28], [7, 22], [34], [39]]) == [15, 19, 43, 26, 57, 28, 7, 22, 34, 39]", "def check(flatten_list):\n\tassert flatten_list([[6, 16], [37], [25, 61, 25], [8, 20], [36], [42]]) == [6, 16, 37, 25, 61, 25, 8, 20, 36, 42]", "def check(flatten_list):\n\tassert flatten_list([[12, 15], [41], [33, 60, 24], [10, 18], [33], [38]]) == [12, 15, 41, 33, 60, 24, 10, 18, 33, 38]", "def check(flatten_list):\n\tassert flatten_list([[13, 18], [35], [26, 51, 22], [13, 19], [31], [45]]) == [13, 18, 35, 26, 51, 22, 13, 19, 31, 45]", "def check(flatten_list):\n\tassert flatten_list([[15, 22], [39], [29, 53, 20], [9, 22], [29], [36]]) == [15, 22, 39, 29, 53, 20, 9, 22, 29, 36]", "def check(flatten_list):\n\tassert flatten_list([[8, 15], [40], [25, 52, 23], [7, 18], [33], [35]]) == [8, 15, 40, 25, 52, 23, 7, 18, 33, 35]", "def check(flatten_list):\n\tassert flatten_list([[11, 24], [39], [34, 53, 29], [5, 17], [33], [35]]) == [11, 24, 39, 34, 53, 29, 5, 17, 33, 35]", "def check(flatten_list):\n\tassert flatten_list([[14, 24], [43], [27, 58, 20], [9, 16], [35], [40]]) == [14, 24, 43, 27, 58, 20, 9, 16, 35, 40]", "def check(flatten_list):\n\tassert flatten_list([[9, 21], [44], [32, 54, 21], [10, 15], [36], [36]]) == [9, 21, 44, 32, 54, 21, 10, 15, 36, 36]", "def check(flatten_list):\n\tassert flatten_list([[6, 18], [35], [32, 54, 25], [11, 23], [30], [42]]) == [6, 18, 35, 32, 54, 25, 11, 23, 30, 42]", "def check(flatten_list):\n\tassert flatten_list([[3, 4, 4], [9, 7, 8], [10, 15, 16], [11, 4, 12]]) == [3, 4, 4, 9, 7, 8, 10, 15, 16, 11, 4, 12]", "def check(flatten_list):\n\tassert flatten_list([[4, 1, 4], [3, 1, 5], [13, 11, 8], [10, 3, 4]]) == [4, 1, 4, 3, 1, 5, 13, 11, 8, 10, 3, 4]", "def check(flatten_list):\n\tassert flatten_list([[3, 1, 3], [1, 6, 4], [13, 6, 16], [11, 12, 10]]) == [3, 1, 3, 1, 6, 4, 13, 6, 16, 11, 12, 10]", "def check(flatten_list):\n\tassert flatten_list([[3, 2, 7], [7, 9, 8], [14, 8, 7], [5, 6, 8]]) == [3, 2, 7, 7, 9, 8, 14, 8, 7, 5, 6, 8]", "def check(flatten_list):\n\tassert flatten_list([[4, 1, 2], [9, 6, 2], [9, 15, 17], [9, 5, 13]]) == [4, 1, 2, 9, 6, 2, 9, 15, 17, 9, 5, 13]", "def check(flatten_list):\n\tassert flatten_list([[1, 2, 2], [8, 1, 7], [10, 14, 12], [11, 11, 10]]) == [1, 2, 2, 8, 1, 7, 10, 14, 12, 11, 11, 10]", "def check(flatten_list):\n\tassert flatten_list([[2, 7, 2], [8, 4, 3], [10, 10, 13], [3, 3, 5]]) == [2, 7, 2, 8, 4, 3, 10, 10, 13, 3, 3, 5]", "def check(flatten_list):\n\tassert flatten_list([[3, 6, 5], [2, 1, 8], [6, 16, 16], [4, 13, 7]]) == [3, 6, 5, 2, 1, 8, 6, 16, 16, 4, 13, 7]", "def check(flatten_list):\n\tassert flatten_list([[2, 3, 1], [8, 9, 2], [15, 16, 8], [7, 9, 6]]) == [2, 3, 1, 8, 9, 2, 15, 16, 8, 7, 9, 6]", "def check(flatten_list):\n\tassert flatten_list([[3, 3, 8], [6, 6, 11], [15, 6, 10], [8, 4, 13]]) == [3, 3, 8, 6, 6, 11, 15, 6, 10, 8, 4, 13]", "def check(flatten_list):\n\tassert flatten_list([[2, 2, 2], [5, 4, 4], [14, 8, 11], [3, 11, 13]]) == [2, 2, 2, 5, 4, 4, 14, 8, 11, 3, 11, 13]", "def check(flatten_list):\n\tassert flatten_list([[2, 2, 8], [7, 9, 6], [8, 6, 17], [9, 9, 12]]) == [2, 2, 8, 7, 9, 6, 8, 6, 17, 9, 9, 12]", "def check(flatten_list):\n\tassert flatten_list([[2, 4, 3], [1, 4, 10], [10, 8, 14], [10, 8, 4]]) == [2, 4, 3, 1, 4, 10, 10, 8, 14, 10, 8, 4]", "def check(flatten_list):\n\tassert flatten_list([[1, 1, 1], [5, 5, 1], [12, 12, 9], [4, 4, 10]]) == [1, 1, 1, 5, 5, 1, 12, 12, 9, 4, 4, 10]", "def check(flatten_list):\n\tassert flatten_list([[5, 1, 5], [6, 5, 10], [8, 14, 12], [10, 9, 14]]) == [5, 1, 5, 6, 5, 10, 8, 14, 12, 10, 9, 14]", "def check(flatten_list):\n\tassert flatten_list([[1, 2, 2], [5, 4, 11], [14, 11, 16], [6, 12, 9]]) == [1, 2, 2, 5, 4, 11, 14, 11, 16, 6, 12, 9]", "def check(flatten_list):\n\tassert flatten_list([[3, 2, 3], [2, 8, 11], [13, 16, 9], [2, 7, 13]]) == [3, 2, 3, 2, 8, 11, 13, 16, 9, 2, 7, 13]", "def check(flatten_list):\n\tassert flatten_list([[2, 6, 6], [1, 4, 5], [5, 11, 10], [3, 12, 6]]) == [2, 6, 6, 1, 4, 5, 5, 11, 10, 3, 12, 6]", "def check(flatten_list):\n\tassert flatten_list([[5, 6, 8], [6, 4, 8], [5, 11, 10], [8, 8, 4]]) == [5, 6, 8, 6, 4, 8, 5, 11, 10, 8, 8, 4]", "def check(flatten_list):\n\tassert flatten_list([[2, 4, 7], [8, 1, 1], [8, 16, 8], [7, 13, 9]]) == [2, 4, 7, 8, 1, 1, 8, 16, 8, 7, 13, 9]", "def check(flatten_list):\n\tassert flatten_list([[1, 2, 3], [9, 3, 8], [10, 7, 13], [10, 8, 13]]) == [1, 2, 3, 9, 3, 8, 10, 7, 13, 10, 8, 13]", "def check(flatten_list):\n\tassert flatten_list([[1, 5, 8], [1, 9, 5], [5, 7, 9], [12, 11, 6]]) == [1, 5, 8, 1, 9, 5, 5, 7, 9, 12, 11, 6]", "def check(flatten_list):\n\tassert flatten_list([[1, 3, 2], [3, 9, 10], [5, 11, 16], [11, 5, 5]]) == [1, 3, 2, 3, 9, 10, 5, 11, 16, 11, 5, 5]", "def check(flatten_list):\n\tassert flatten_list([[3, 5, 4], [8, 6, 6], [9, 7, 16], [6, 7, 9]]) == [3, 5, 4, 8, 6, 6, 9, 7, 16, 6, 7, 9]", "def check(flatten_list):\n\tassert flatten_list([[1, 1, 1], [2, 3, 7], [9, 13, 12], [9, 13, 7]]) == [1, 1, 1, 2, 3, 7, 9, 13, 12, 9, 13, 7]", "def check(flatten_list):\n\tassert flatten_list([[4, 5, 3], [8, 4, 1], [8, 16, 11], [7, 11, 6]]) == [4, 5, 3, 8, 4, 1, 8, 16, 11, 7, 11, 6]", "def check(flatten_list):\n\tassert flatten_list([[3, 2, 8], [4, 9, 4], [10, 7, 13], [2, 7, 13]]) == [3, 2, 8, 4, 9, 4, 10, 7, 13, 2, 7, 13]", "def check(flatten_list):\n\tassert flatten_list([[4, 7, 5], [6, 5, 5], [12, 11, 12], [3, 13, 5]]) == [4, 7, 5, 6, 5, 5, 12, 11, 12, 3, 13, 5]", "def check(flatten_list):\n\tassert flatten_list([[1, 1, 4], [6, 7, 8], [10, 16, 9], [3, 6, 10]]) == [1, 1, 4, 6, 7, 8, 10, 16, 9, 3, 6, 10]", "def check(flatten_list):\n\tassert flatten_list([[6, 1, 7], [4, 5, 11], [8, 14, 11], [9, 8, 12]]) == [6, 1, 7, 4, 5, 11, 8, 14, 11, 9, 8, 12]", "def check(flatten_list):\n\tassert flatten_list([[3, 4, 4], [8, 9, 6], [10, 6, 16], [8, 4, 11]]) == [3, 4, 4, 8, 9, 6, 10, 6, 16, 8, 4, 11]", "def check(flatten_list):\n\tassert flatten_list([[2, 4, 8], [8, 10, 6], [5, 13, 8], [6, 3, 14]]) == [2, 4, 8, 8, 10, 6, 5, 13, 8, 6, 3, 14]", "def check(flatten_list):\n\tassert flatten_list([[3, 7, 8], [8, 10, 4], [9, 9, 9], [9, 13, 7]]) == [3, 7, 8, 8, 10, 4, 9, 9, 9, 9, 13, 7]"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [102, 102, 102, 102, 102, 102, 102, 102, 102, 102], "completion": "from typing import List\n## main.py\n\ndef flatten_list(nested_list: list) -> list:\n    \"\"\"\n    Flattens a nested list.\n\n    Args:\n        nested_list (list): A list that may contain other lists as elements.\n\n    Returns:\n        list: A flattened list with no nested lists.\n    \"\"\"\n    result = []\n\n    def _flatten(sublist):\n        for item in sublist:\n            if isinstance(item, list):\n                _flatten(item)\n            else:\n                result.append(item)\n\n    _flatten(nested_list)\n    return result\n", "passed": true, "pass": true, "pass_num": 10, "round": 751, "mutate_method": "condense_two2one", "parent_index": 602}
