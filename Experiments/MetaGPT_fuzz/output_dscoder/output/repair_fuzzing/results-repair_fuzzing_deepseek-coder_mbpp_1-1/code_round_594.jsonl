{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 4, "prompt": "Develop a function to determine the n largest numbers from a given list of numbers, returned in descending order.", "code": "import heapq as hq\ndef heap_queue_largest(nums,n):\n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "test_imports": [], "test_list": ["assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65] ", "assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],2)==[85, 75] ", "assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],5)==[85, 75, 65, 58, 35]", "assert heap_queue_largest([29, 39, 20, 87, 19, 64, 72, 27, 61], 4) == [87, 72, 64, 61]", "assert heap_queue_largest([23, 39, 18, 83, 14, 65, 71, 20, 62], 1) == [83]", "assert heap_queue_largest([28, 34, 25, 89, 12, 66, 77, 27, 56], 5) == [89, 77, 66, 56, 34]", "assert heap_queue_largest([21, 36, 22, 84, 13, 67, 78, 25, 54], 3) == [84, 78, 67]", "assert heap_queue_largest([28, 38, 20, 85, 11, 68, 72, 18, 59], 6) == [85, 72, 68, 59, 38, 28]", "assert heap_queue_largest([26, 30, 20, 81, 9, 61, 73, 19, 53], 6) == [81, 73, 61, 53, 30, 26]", "assert heap_queue_largest([25, 32, 23, 86, 14, 60, 73, 23, 54], 6) == [86, 73, 60, 54, 32, 25]", "assert heap_queue_largest([22, 33, 22, 80, 19, 64, 77, 24, 53], 3) == [80, 77, 64]", "assert heap_queue_largest([28, 39, 25, 84, 17, 61, 77, 19, 53], 5) == [84, 77, 61, 53, 39]", "assert heap_queue_largest([30, 38, 17, 89, 18, 62, 80, 23, 60], 7) == [89, 80, 62, 60, 38, 30, 23]", "assert heap_queue_largest([27, 40, 27, 86, 16, 66, 79, 24, 59], 7) == [86, 79, 66, 59, 40, 27, 27]", "assert heap_queue_largest([30, 36, 27, 81, 19, 66, 78, 23, 59], 8) == [81, 78, 66, 59, 36, 30, 27, 23]", "assert heap_queue_largest([23, 37, 20, 83, 18, 61, 75, 21, 55], 8) == [83, 75, 61, 55, 37, 23, 21, 20]", "assert heap_queue_largest([29, 36, 17, 83, 13, 65, 78, 23, 59], 5) == [83, 78, 65, 59, 36]", "assert heap_queue_largest([27, 31, 23, 85, 10, 67, 77, 21, 57], 5) == [85, 77, 67, 57, 31]", "assert heap_queue_largest([25, 39, 22, 83, 15, 68, 75, 25, 53], 3) == [83, 75, 68]", "assert heap_queue_largest([30, 37, 22, 85, 11, 68, 77, 19, 62], 8) == [85, 77, 68, 62, 37, 30, 22, 19]", "assert heap_queue_largest([22, 31, 24, 89, 9, 63, 70, 27, 57], 5) == [89, 70, 63, 57, 31]", "assert heap_queue_largest([24, 40, 26, 88, 16, 68, 79, 20, 63], 4) == [88, 79, 68, 63]", "assert heap_queue_largest([22, 40, 23, 89, 15, 65, 74, 20, 62], 5) == [89, 74, 65, 62, 40]", "assert heap_queue_largest([23, 31, 21, 90, 14, 63, 78, 22, 59], 2) == [90, 78]", "assert heap_queue_largest([23, 30, 20, 85, 19, 69, 73, 18, 55], 8) == [85, 73, 69, 55, 30, 23, 20, 19]", "assert heap_queue_largest([20, 37, 21, 81, 11, 64, 79, 17, 59], 3) == [81, 79, 64]", "assert heap_queue_largest([25, 40, 21, 84, 11, 68, 71, 27, 56], 4) == [84, 71, 68, 56]", "assert heap_queue_largest([25, 31, 19, 90, 15, 64, 79, 26, 57], 1) == [90]", "assert heap_queue_largest([21, 31, 17, 80, 19, 69, 77, 27, 63], 1) == [80]", "assert heap_queue_largest([30, 36, 20, 87, 12, 69, 80, 27, 60], 4) == [87, 80, 69, 60]", "assert heap_queue_largest([28, 30, 22, 80, 12, 60, 70, 27, 58], 7) == [80, 70, 60, 58, 30, 28, 27]", "assert heap_queue_largest([30, 30, 26, 87, 12, 66, 78, 19, 55], 4) == [87, 78, 66, 55]", "assert heap_queue_largest([26, 39, 21, 82, 12, 60, 78, 24, 57], 7) == [82, 78, 60, 57, 39, 26, 24]", "assert heap_queue_largest([24, 34, 23, 87, 14, 61, 70, 19, 55], 7) == [87, 70, 61, 55, 34, 24, 23]", "assert heap_queue_largest([30, 35, 21, 86, 14, 63, 76, 21, 54], 7) == [86, 76, 63, 54, 35, 30, 21]", "assert heap_queue_largest([29, 30, 25, 80, 15, 66, 72, 21, 63], 3) == [80, 72, 66]", "assert heap_queue_largest([23, 32, 23, 88, 12, 65, 70, 26, 60], 3) == [88, 70, 65]", "assert heap_queue_largest([29, 37, 19, 85, 11, 67, 73, 23, 62], 3) == [85, 73, 67]", "assert heap_queue_largest([28, 38, 22, 88, 19, 68, 70, 18, 61], 2) == [88, 70]", "assert heap_queue_largest([30, 32, 25, 89, 11, 67, 74, 25, 54], 7) == [89, 74, 67, 54, 32, 30, 25]", "assert heap_queue_largest([23, 35, 24, 89, 15, 69, 70, 24, 60], 2) == [89, 70]", "assert heap_queue_largest([21, 36, 24, 84, 10, 61, 71, 24, 63], 7) == [84, 71, 63, 61, 36, 24, 24]", "assert heap_queue_largest([23, 39, 27, 84, 13, 67, 71, 20, 62], 1) == [84]", "assert heap_queue_largest([21, 36, 27, 85, 10, 65, 79, 21, 54], 2) == [85, 79]", "assert heap_queue_largest([23, 40, 19, 84, 16, 68, 80, 27, 63], 3) == [84, 80, 68]", "assert heap_queue_largest([22, 40, 17, 80, 11, 60, 76, 19, 53], 6) == [80, 76, 60, 53, 40, 22]", "assert heap_queue_largest([30, 40, 19, 87, 17, 70, 77, 24, 55], 1) == [87]", "assert heap_queue_largest([30, 36, 19, 87, 12, 62, 74, 17, 62], 1) == [87]", "assert heap_queue_largest([26, 33, 21, 86, 13, 64, 74, 19, 58], 4) == [86, 74, 64, 58]", "assert heap_queue_largest([29, 33, 22, 90, 11, 69, 76, 25, 54], 5) == [90, 76, 69, 54, 33]", "assert heap_queue_largest([26, 37, 23, 83, 11, 63, 70, 22, 53], 3) == [83, 70, 63]", "assert heap_queue_largest([23, 30, 20, 87, 18, 62, 72, 19, 62], 1) == [87]", "assert heap_queue_largest([28, 38, 25, 87, 18, 62, 78, 24, 63], 5) == [87, 78, 63, 62, 38]", "assert heap_queue_largest([23, 40, 27, 82, 9, 66, 80, 23, 55], 1) == [82]", "assert heap_queue_largest([23, 40, 18, 83, 13, 61, 75, 24, 55], 5) == [83, 75, 61, 55, 40]", "assert heap_queue_largest([28, 39, 26, 81, 15, 67, 80, 27, 60], 7) == [81, 80, 67, 60, 39, 28, 27]", "assert heap_queue_largest([22, 40, 23, 86, 15, 70, 78, 27, 63], 1) == [86]", "assert heap_queue_largest([24, 40, 18, 84, 19, 61, 71, 25, 62], 2) == [84, 71]", "assert heap_queue_largest([21, 30, 20, 87, 19, 61, 71, 26, 53], 7) == [87, 71, 61, 53, 30, 26, 21]", "assert heap_queue_largest([30, 40, 20, 90, 9, 70, 77, 21, 62], 2) == [90, 77]", "assert heap_queue_largest([22, 33, 18, 81, 12, 67, 71, 25, 58], 6) == [81, 71, 67, 58, 33, 25]", "assert heap_queue_largest([21, 36, 24, 86, 13, 66, 79, 21, 56], 2) == [86, 79]", "assert heap_queue_largest([30, 34, 17, 85, 9, 60, 74, 25, 63], 4) == [85, 74, 63, 60]", "assert heap_queue_largest([29, 37, 22, 90, 19, 67, 72, 19, 60], 7) == [90, 72, 67, 60, 37, 29, 22]", "assert heap_queue_largest([25, 36, 21, 86, 12, 66, 78, 26, 54], 1) == [86]", "assert heap_queue_largest([24, 33, 27, 82, 10, 60, 76, 26, 55], 2) == [82, 76]", "assert heap_queue_largest([27, 34, 23, 83, 18, 65, 80, 25, 58], 6) == [83, 80, 65, 58, 34, 27]", "assert heap_queue_largest([23, 40, 19, 85, 11, 62, 73, 25, 53], 4) == [85, 73, 62, 53]", "assert heap_queue_largest([20, 32, 17, 89, 10, 62, 77, 21, 53], 7) == [89, 77, 62, 53, 32, 21, 20]", "assert heap_queue_largest([23, 31, 17, 80, 13, 64, 72, 17, 55], 2) == [80, 72]", "assert heap_queue_largest([25, 40, 17, 83, 11, 69, 77, 26, 61], 3) == [83, 77, 69]", "assert heap_queue_largest([22, 39, 17, 89, 16, 65, 70, 23, 60], 6) == [89, 70, 65, 60, 39, 23]", "assert heap_queue_largest([30, 40, 20, 80, 12, 69, 75, 27, 58], 7) == [80, 75, 69, 58, 40, 30, 27]", "assert heap_queue_largest([23, 33, 19, 90, 13, 67, 70, 17, 59], 1) == [90]", "assert heap_queue_largest([29, 38, 27, 86, 15, 63, 80, 23, 63], 9) == [86, 80, 63, 63, 38, 29, 27, 23, 15]", "assert heap_queue_largest([30, 38, 24, 84, 13, 68, 75, 23, 61], 3) == [84, 75, 68]", "assert heap_queue_largest([22, 35, 18, 84, 12, 70, 76, 19, 60], 2) == [84, 76]", "assert heap_queue_largest([20, 35, 20, 86, 14, 63, 80, 22, 56], 4) == [86, 80, 63, 56]", "assert heap_queue_largest([29, 32, 18, 87, 15, 65, 70, 26, 59], 9) == [87, 70, 65, 59, 32, 29, 26, 18, 15]", "assert heap_queue_largest([30, 40, 24, 81, 10, 64, 71, 23, 55], 8) == [81, 71, 64, 55, 40, 30, 24, 23]", "assert heap_queue_largest([29, 33, 20, 87, 10, 61, 80, 21, 57], 10) == [87, 80, 61, 57, 33, 29, 21, 20, 10]", "assert heap_queue_largest([28, 31, 27, 88, 9, 70, 79, 25, 59], 8) == [88, 79, 70, 59, 31, 28, 27, 25]", "assert heap_queue_largest([29, 39, 20, 84, 15, 65, 72, 21, 63], 5) == [84, 72, 65, 63, 39]", "assert heap_queue_largest([20, 37, 17, 86, 13, 67, 80, 24, 63], 5) == [86, 80, 67, 63, 37]", "assert heap_queue_largest([21, 37, 17, 83, 18, 65, 74, 20, 61], 4) == [83, 74, 65, 61]", "assert heap_queue_largest([30, 38, 26, 82, 10, 67, 79, 25, 55], 10) == [82, 79, 67, 55, 38, 30, 26, 25, 10]", "assert heap_queue_largest([24, 39, 24, 83, 11, 62, 71, 17, 59], 9) == [83, 71, 62, 59, 39, 24, 24, 17, 11]", "assert heap_queue_largest([28, 30, 20, 80, 17, 66, 78, 25, 62], 10) == [80, 78, 66, 62, 30, 28, 25, 20, 17]", "assert heap_queue_largest([24, 40, 26, 89, 17, 62, 70, 24, 61], 5) == [89, 70, 62, 61, 40]", "assert heap_queue_largest([20, 34, 26, 87, 18, 68, 76, 21, 61], 10) == [87, 76, 68, 61, 34, 26, 21, 20, 18]", "assert heap_queue_largest([26, 31, 19, 80, 19, 70, 78, 21, 58], 4) == [80, 78, 70, 58]", "assert heap_queue_largest([29, 30, 18, 82, 16, 67, 73, 22, 53], 1) == [82]", "assert heap_queue_largest([30, 37, 20, 83, 19, 69, 77, 19, 60], 5) == [83, 77, 69, 60, 37]", "assert heap_queue_largest([29, 31, 17, 81, 13, 67, 77, 21, 62], 4) == [81, 77, 67, 62]", "assert heap_queue_largest([30, 32, 20, 89, 11, 62, 78, 27, 54], 1) == [89]", "assert heap_queue_largest([25, 35, 17, 89, 15, 67, 71, 22, 56], 8) == [89, 71, 67, 56, 35, 25, 22, 17]", "assert heap_queue_largest([27, 33, 24, 88, 19, 62, 73, 25, 61], 7) == [88, 73, 62, 61, 33, 27, 25]", "assert heap_queue_largest([30, 38, 25, 89, 11, 68, 72, 21, 56], 9) == [89, 72, 68, 56, 38, 30, 25, 21, 11]", "assert heap_queue_largest([20, 36, 17, 82, 15, 61, 78, 17, 55], 4) == [82, 78, 61, 55]", "assert heap_queue_largest([27, 33, 23, 85, 11, 62, 73, 26, 61], 7) == [85, 73, 62, 61, 33, 27, 26]", "assert heap_queue_largest([26, 40, 22, 84, 16, 65, 77, 17, 57], 8) == [84, 77, 65, 57, 40, 26, 22, 17]", "assert heap_queue_largest([23, 33, 24, 84, 17, 70, 79, 21, 53], 5) == [84, 79, 70, 53, 33]"], "entry_point": "heap_queue_largest", "repair_prompt": ["Develop a function heap_queue_largest to determine the n largest numbers from a given list of numbers, returned in descending order.\nheap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65] \n", " Develop a function heap_queue_largest to find the n largest numbers from a given list of numbers, ensuring they are returned in descending order.\nheap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65] \n", " Develop a function heap_queue_largest to find the n largest numbers from a given list of numbers, sorted in descending order.\nheap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65] \n"], "completions": ["from typing import List\nimport heapq\nfrom typing import List\n\ndef heap_queue_largest(numbers: List[int], n: int) -> List[int]:\n    \"\"\"\n    Returns a list of the n largest numbers from the input list in descending order.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n        n (int): The number of largest elements to return.\n    \n    Returns:\n        List[int]: A list of the n largest numbers in descending order.\n    \"\"\"\n    if n == 0 or not numbers:\n        return []\n    \n    largest_numbers = heapq.nlargest(n, numbers)\n    return sorted(largest_numbers, reverse=True)\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport heapq\n\ndef heap_queue_largest(numbers: List[int], n: int) -> List[int]:\n    \"\"\"\n    This function returns the n largest numbers from a given list of numbers.\n    \n    Args:\n        numbers (List[int]): A list of integers from which to find the n largest numbers.\n        n (int): The number of largest numbers to return.\n    \n    Returns:\n        List[int]: A list of the n largest numbers in descending order.\n    \"\"\"\n    if n == 0 or not numbers:\n        return []\n    \n    # Use heapq.nlargest to find the n largest numbers\n    largest_numbers = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    largest_numbers.sort(reverse=True)\n    \n    return largest_numbers\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport heapq\n\ndef heap_queue_largest(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Returns the n largest numbers in descending order from the given list.\n    \n    Args:\n        nums (List[int]): The list of integers from which to find the largest numbers.\n        n (int): The number of largest numbers to return.\n    \n    Returns:\n        List[int]: The n largest numbers in descending order.\n    \"\"\"\n    if n == 0 or not nums:\n        return []\n    \n    # Use heapq.nlargest to get the n largest elements\n    largest_nums = heapq.nlargest(n, nums)\n    \n    # Return the result in descending order\n    return largest_nums[::-1]\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport heapq\n\ndef heap_queue_largest(numbers: List[int], n: int) -> List[int]:\n    \"\"\"\n    This function takes a list of integers and an integer n, and returns the n largest numbers from the list in descending order.\n    \n    Args:\n        numbers (List[int]): A list of integers from which to find the n largest numbers.\n        n (int): The number of largest numbers to return.\n    \n    Returns:\n        List[int]: A list of the n largest numbers in descending order.\n    \"\"\"\n    if n > len(numbers):\n        return sorted(numbers, reverse=True)\n    \n    largest_numbers = heapq.nlargest(n, numbers)\n    return sorted(largest_numbers, reverse=True)\n", "from typing import List\nfrom typing import List\nimport heapq\n\ndef heap_queue_largest(numbers: List[int], n: int) -> List[int]:\n    \"\"\"\n    Returns the n largest elements from the given list of numbers in descending order.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n        n (int): The number of largest elements to return.\n    \n    Returns:\n        List[int]: A list of the n largest elements in descending order.\n    \"\"\"\n    if n <= 0 or not numbers:\n        return []\n    \n    # Find the n largest elements\n    largest_elements = heapq.nlargest(n, numbers)\n    \n    # Sort the largest elements in descending order\n    largest_elements.sort(reverse=True)\n    \n    return largest_elements\n", "from typing import List\nimport heapq\n\ndef heap_queue_largest(numbers: list[int], n: int) -> list[int]:\n    \"\"\"\n    Returns the n largest numbers from the given list in descending order.\n    \n    Args:\n        numbers (list[int]): A list of integers.\n        n (int): The number of largest elements to return.\n    \n    Returns:\n        list[int]: A list of the n largest numbers in descending order.\n    \"\"\"\n    if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\n        raise ValueError(\"Input 'numbers' must be a list of integers.\")\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input 'n' must be a non-negative integer.\")\n    \n    if n == 0:\n        return []\n    \n    largest_numbers = heapq.nlargest(n, numbers)\n    return sorted(largest_numbers, reverse=True)\n", "from typing import List\nfrom typing import List\nimport heapq\n\ndef heap_queue_largest(numbers: List[int], n: int) -> List[int]:\n    \"\"\"\n    This function returns the n largest numbers from the given list in descending order.\n    \n    Args:\n        numbers (List[int]): The list of numbers to search for the largest elements.\n        n (int): The number of largest elements to return.\n    \n    Returns:\n        List[int]: A list of the n largest numbers in descending order.\n    \"\"\"\n    if n == 0 or not numbers:\n        return []\n    \n    # Find the n largest elements\n    largest_numbers = heapq.nlargest(n, numbers)\n    \n    # Return the sorted list in descending order\n    return sorted(largest_numbers, reverse=True)\n", "from typing import List\nfrom typing import List\nimport heapq\n\ndef heap_queue_largest(numbers: List[int], n: int) -> List[int]:\n    \"\"\"\n    Function to find the n largest numbers from a list and return them in descending order.\n    \n    Args:\n        numbers (List[int]): The list of numbers to search for the n largest numbers.\n        n (int): The number of largest numbers to retrieve.\n    \n    Returns:\n        List[int]: A list of the n largest numbers in descending order.\n    \"\"\"\n    if n == 0 or not numbers:\n        return []\n    \n    # Use heapq.nlargest to find the n largest numbers\n    largest_numbers = heapq.nlargest(n, numbers)\n    \n    # Return the largest numbers in descending order\n    return sorted(largest_numbers, reverse=True)\n", "from typing import List\nimport heapq\nfrom typing import List\n\ndef heap_queue_largest(numbers: List[int], n: int) -> List[int]:\n    \"\"\"\n    Find the n largest numbers from a list and return them in descending order.\n    \n    Args:\n        numbers (List[int]): The list of numbers to search for the n largest numbers.\n        n (int): The number of largest numbers to retrieve.\n    \n    Returns:\n        List[int]: A list of the n largest numbers in descending order.\n    \"\"\"\n    if n == 0 or not numbers:\n        return []\n    \n    # Find the n largest numbers using heapq.nlargest\n    largest_numbers = heapq.nlargest(n, numbers)\n    \n    # Sort the largest numbers in descending order\n    largest_numbers.sort(reverse=True)\n    \n    return largest_numbers\n", "from typing import List\n## main.py\n\nimport heapq\nfrom typing import List\n\ndef heap_queue_largest(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    This function returns the n largest numbers from the given list in descending order.\n    \n    Args:\n        nums (List[int]): The list of numbers to search for the largest n numbers.\n        n (int): The number of largest elements to return.\n    \n    Returns:\n        List[int]: A list of the n largest numbers in descending order.\n    \"\"\"\n    if n == 0 or not nums:\n        return []\n    \n    largest_numbers = heapq.nlargest(n, nums)\n    return largest_numbers\n"], "plans": ["requirement analysis:\nThe primary requirement is to develop a function that can efficiently find the n largest numbers from a list and return them in descending order. This function should be robust against different types of input data and should handle large datasets effectively. The function should be easy to integrate and use, making it accessible for users with varying levels of programming expertise.\nrequirement pool:\n- Develop a function to find the n largest numbers in a list.\n- Ensure the function returns the numbers in descending order.\n- Make the function scalable and efficient for large datasets.\n- Include error handling for different types of input data.\n- Optimize the function for quick retrieval of the largest numbers.\nTo develop the function heap_queue_largest, we will utilize the heapq module in Python, which is known for its efficient heap operations. This module provides an efficient way to find the n largest elements from a list. We will use the nlargest function from heapq to achieve this. The function will take a list of numbers and an integer n as input, and it will return a list of the n largest numbers in descending order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'heap operations': This refers to the efficient way to find the largest elements in a collection, which is crucial for our function to return the n largest numbers in descending order.\n    Explanation: The heapq module in Python provides functions to create a heap from an iterable and to efficiently find the largest elements. By using these functions, we can efficiently retrieve the n largest elements from a list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the function `heap_queue_largest`, we will follow these steps:\n    1. Import the `heapq` module.\n    2. Use the `heapq.nlargest` function to find the n largest elements in the list.\n    3. Return the result in descending order.\n\n# [edge case] \n    heap_queue_largest([1, 2, 3, 4, 5], 0) = []\n    Explanation: If n is 0, the function should return an empty list since no elements are requested.\n    heap_queue_largest([], 3) = []\n    Explanation: If the input list is empty, the function should return an empty list since there are no elements to process.\n    heap_queue_largest([1, 2, 3, 4, 5], 10) = [5, 4, 3, 2, 1]\n    Explanation: If n is greater than the length of the list, the function should return the entire list in descending order since it is the largest possible subset.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The `heapq.nlargest` function already handles cases where n is greater than the length of the list or where the list is empty.\n", "requirement analysis:\nThe function should be designed to handle a list of numbers and return the n largest numbers in descending order. The solution should be efficient and scalable, suitable for both small and large datasets. The function should be easy to integrate and use, providing a seamless user experience.\nrequirement pool:\n- The main code should be efficient in determining the n largest numbers\n- The function should return the numbers in descending order\n- The function should be easy to integrate into existing projects\n- The function should handle large datasets efficiently\n- The function should be well-documented and have clear examples of usage\nTo create an efficient and user-friendly function that determines the n largest numbers from a given list of numbers, we will utilize Python's built-in 'heapq' module. This module provides an efficient way to handle heaps, which is crucial for performance. We will use the 'nlargest' function from 'heapq' to find the n largest elements in the list. This approach ensures scalability and can handle large datasets efficiently. The function will return these numbers in descending order, which is a straightforward operation after retrieving the largest numbers.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'heapq module': This module provides an efficient way to handle heaps, which is crucial for performance when dealing with large datasets.\n    'nlargest': This function from 'heapq' is used to find the n largest elements in the list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The function will utilize Python's built-in 'heapq' module to find the n largest numbers from a given list of numbers. Here's the detailed logic:\n    1. Import the 'heapq' module.\n    2. Define the function `heap_queue_largest` that takes a list of numbers and an integer `n` as arguments.\n    3. Use the `heapq.nlargest` function to find the n largest numbers in the list.\n    4. Sort these numbers in descending order.\n    5. Return the sorted list of the n largest numbers.\n\n# [edge case] \n    heap_queue_largest([1, 2, 3, 4, 5], 0) = []\n    Explanation: If n is 0, the function should return an empty list since no elements are requested.\n    heap_queue_largest([], 3) = []\n    Explanation: If the input list is empty, the function should return an empty list regardless of the value of n.\n    heap_queue_largest([1, 1, 1, 1], 5) = [1, 1, 1, 1]\n    Explanation: If n is greater than the number of unique elements in the list, the function should return the list of elements as is.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already covers the edge cases by returning an empty list when n is 0 or when the input list is empty.\n", "requirement analysis:\nThe primary requirement is to develop a function that can efficiently find the n largest numbers from a list. The function should be able to handle large datasets and return results quickly. The function should be easy to integrate and use, providing a seamless user experience.\nrequirement pool:\n- Develop a function that can find the n largest numbers from a list.\n- Ensure the function can handle large datasets efficiently.\n- Optimize the function for quick retrieval of the largest numbers.\n- Make the function easy to integrate into existing projects.\n- Ensure the function provides a seamless user experience.\nTo develop the function heap_queue_largest efficiently, we will utilize the heapq module in Python, which is known for its efficient heap operations. The function will use a max-heap by pushing negative values of the numbers into the heap, allowing us to retrieve the largest numbers in descending order. This approach ensures scalability and performance for handling large datasets.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'largest numbers': means the top n numbers in descending order from a given list.\n    'descending order': means the numbers are sorted from the largest to the smallest.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the function `heap_queue_largest`, we will follow these steps:\n    1. Import the `heapq` module.\n    2. Use a max-heap by pushing negative values of the numbers into the heap.\n    3. Use `heapq.nlargest` to get the n largest numbers.\n    4. Return the numbers in descending order by reversing the list of the largest numbers.\n\n# [edge case] \n    heap_queue_largest([1, 2, 3, 4, 5], 0) = []\n    Explanation: If n is 0, the function should return an empty list since no numbers are requested.\n    heap_queue_largest([], 3) = []\n    Explanation: If the input list is empty, the function should return an empty list regardless of the value of n.\n    heap_queue_largest([1, 1, 1, 1], 5) = [1, 1, 1, 1]\n    Explanation: If n is greater than the number of unique elements in the list, the function should return the list of all elements since it cannot return more numbers than exist in the list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle cases where n is 0 or the input list is empty. For the case where n is greater than the number of unique elements, the function will naturally return the list of all elements.\n", "requirement analysis:\nThe function should efficiently find the n largest numbers from a list and return them in descending order. The solution should be robust and handle various sizes of input data effectively. The implementation should be clear and easy to understand, suitable for integration into different projects.\nrequirement pool:\n- The function should find the n largest numbers from a list\n- The function should return the numbers in descending order\n- The function should handle large datasets efficiently\n- The function should be easy to integrate into other projects\n- The function should be clearly documented and easy to understand\nTo efficiently find the n largest numbers from a list and return them in descending order, we will utilize the 'heapq' module in Python, which is specifically designed for heap operations. This module provides an efficient way to handle the priority queue functionality required for this task. We will use the 'nlargest' function from the 'heapq' module to retrieve the n largest elements from the list and then sort them in descending order using Python's built-in 'sorted' function with a reverse parameter.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'heapq module': This module provides an efficient way to handle heap operations, which is crucial for efficiently finding the n largest elements from a list.\n    'nlargest function': This function is part of the 'heapq' module and is specifically designed to retrieve the n largest elements from a list.\n    'descending order': This means that the elements should be sorted in a way that the largest element comes first, followed by the second largest, and so on.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the function `heap_queue_largest`, we will follow these steps:\n    1. Import the 'heapq' module.\n    2. Use the 'nlargest' function from the 'heapq' module to find the n largest elements in the given list.\n    3. Sort the retrieved elements in descending order using Python's built-in 'sorted' function with the 'reverse=True' parameter.\n    4. Return the sorted list of the n largest elements.\n\n# [edge case] \n    heap_queue_largest([1, 2, 3, 4, 5], 3) = [5, 4, 3]\n    Explanation: The function should return the 3 largest numbers in descending order from the list [1, 2, 3, 4, 5], which are 5, 4, and 3.\n    heap_queue_largest([10, 20, 30, 40, 50], 2) = [50, 40]\n    Explanation: The function should return the 2 largest numbers in descending order from the list [10, 20, 30, 40, 50], which are 50 and 40.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The 'nlargest' function from the 'heapq' module will automatically handle cases where n is greater than the length of the list by returning the entire list, and the 'sorted' function will handle the descending order.\n", "requirement analysis:\nThe primary requirement is to find the n largest numbers from a list and return them in descending order. This involves both sorting and selection operations. The function should be efficient and handle large lists without performance issues. The solution should be simple and easy to understand, suitable for users with varying levels of programming expertise.\nrequirement pool:\n- Implement the function heap_queue_largest to find the n largest numbers\n- Ensure the results are sorted in descending order\n- Optimize the function for large lists\n- Include user-friendly input handling\n- Provide clear documentation and examples\nTo implement the function heap_queue_largest efficiently, we will utilize Python's built-in 'heapq' library, which provides an efficient way to handle heaps. The 'heapq.nlargest' function will be used to find the n largest elements from the list, and then these elements will be sorted in descending order before being returned.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'heap' and 'queue'\n    In the context of this requirement, 'heap' refers to a specialized tree-based structure where the parent nodes have a greater value than their child nodes (for max-heap), and 'queue' typically refers to a collection where elements are added and removed in a specific order. Here, we are specifically using the concept of a max-heap to efficiently find the largest elements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests using the 'heapq.nlargest' function to find the n largest elements. After obtaining these elements, we need to sort them in descending order before returning.\n\n# [edge case] \n    heap_queue_largest([1], 1) = [1]\n    Explanation: With a single element list, the largest element is the element itself, and since we are returning in descending order, the result is [1].\n    heap_queue_largest([], 3) = []\n    Explanation: An empty list should return an empty list, as there are no elements to find.\n    heap_queue_largest([10, 20, 30, 40, 50], 0) = []\n    Explanation: If n is 0, the function should return an empty list, as no elements are requested.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The 'heapq.nlargest' function inherently handles cases where n is greater than the length of the list or where the list is empty. The function will simply return an empty list in such cases.\n", "requirement analysis:\nThe primary requirement is to find the n largest numbers in a list and return them in descending order. The function should be efficient and handle large datasets without significant performance degradation. The user experience should be smooth and the function should be easy to integrate into existing projects.\nrequirement pool:\n- Implement the function using Python's heapq module for efficient heap operations.\n- Ensure the function can handle lists of varying sizes efficiently.\n- Implement error handling for non-integer or non-list inputs.\n- Include documentation and examples in the function's usage.\n- Optimize the function for real-time applications by reducing latency.\nTo implement the function heap_queue_largest efficiently, we will utilize Python's built-in heapq module, which provides an efficient way to handle heap operations. The heapq module offers a method called nlargest that can directly find the n largest elements from a list. We will ensure that the function can handle lists of varying sizes efficiently and includes error handling for non-integer or non-list inputs. The function will return the n largest numbers in descending order, which is a direct output of the nlargest method from the heapq module.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'heap' and 'queue'\n    In the context of the requirement, 'heap' refers to a specialized tree-based structure where the parent nodes are compared to their children according to a specific order (usually max-heap or min-heap). 'Queue' is a collection used to hold elements prior to processing, often in a first-in, first-out (FIFO) manner.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The function `heap_queue_largest` will utilize the `heapq.nlargest` method from Python's heapq module. This method will be used to find the n largest elements in the list. The results will then be sorted in descending order before being returned.\n\n# [edge case] \n    heap_queue_largest([], 3) = []\n    Explanation: Since the input list is empty, there are no numbers to find the largest from. The expected output is an empty list.\n    heap_queue_largest([1, 2, 3], 4) = [3, 2, 1]\n    Explanation: The function is asked to find 4 largest numbers, but there are only 3 numbers in the list. The function will return all numbers in descending order.\n    heap_queue_largest([1, 2, 3], 0) = []\n    Explanation: The function is asked to find 0 largest numbers, which means no numbers should be returned. The expected output is an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The `heapq.nlargest` method already handles cases where n is greater than the number of elements in the list or when the list is empty. The results will be sorted in descending order as required.\n", "requirement analysis:\nThe function needs to efficiently find the n largest numbers from a list, sorted in descending order. The solution should be robust, handling various types of input data and scaling well with larger datasets. The implementation should be straightforward and easy to integrate into other projects.\nrequirement pool:\n- The main code should be efficient in finding the n largest numbers.\n- The function should handle various types of input data without errors.\n- The implementation should be easy to integrate into other projects.\n- The function should scale well with larger datasets.\n- The user interface should be simple and intuitive.\nTo efficiently find the n largest numbers from a list and return them sorted in descending order, we will utilize Python's built-in 'heapq' module, which provides an efficient way to handle heap operations. This module will help us quickly identify the largest elements and maintain the order efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'heapq module': This module provides an implementation of the heap queue algorithm, also known as the priority queue algorithm. In Python, it is available as a separate module called `heapq`. The module provides an array-based heap. The interesting property of a heap is that the smallest element is always the first element (index 0).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the function `heap_queue_largest`, we will follow these steps:\n    1. Import the `heapq` module.\n    2. Use the `nlargest` function from `heapq` to find the n largest elements in the list.\n    3. Return the sorted list of these n largest elements in descending order.\n\n# [edge case] \n    heap_queue_largest([1, 2, 3, 4, 5], 0) = []\n    Explanation: If n is 0, the function should return an empty list since no elements are requested.\n    heap_queue_largest([], 3) = []\n    Explanation: If the input list is empty, the function should return an empty list regardless of the value of n.\n    heap_queue_largest([1, 2, 3, 4, 5], 10) = [5, 4, 3, 2, 1]\n    Explanation: If n is greater than the length of the list, the function should return the entire list sorted in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The `nlargest` function from `heapq` already handles cases where n is greater than the length of the list by returning the entire list, and it returns an empty list if n is 0.\n", "requirement analysis:\nThe primary requirement is to develop a function that can efficiently find the n largest numbers from a list and return them in descending order. This function should be capable of handling various sizes of input data and should be optimized for performance. The function should also be easy to integrate and use, with clear documentation and examples provided.\nrequirement pool:\n- The main code should be optimized for performance and scalability.\n- The function should handle edge cases and errors gracefully.\n- The documentation should be clear and comprehensive.\n- The function should be tested for various types of input data.\n- The user interface should be simple and intuitive.\nTo efficiently find the n largest numbers from a list and return them in descending order, we will utilize Python's built-in 'heapq' module, which is specifically optimized for heap-related operations. This module provides an efficient way to handle the priority queue functionalities, which are crucial for our task. We will use the 'nlargest' function from the 'heapq' module, which is designed to retrieve the n largest elements from the provided iterable.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'heapq module': This module provides an efficient way to handle priority queue functionalities, which are crucial for our task of finding the n largest numbers from a list.\n    Explanation: The 'heapq' module in Python offers functions to create heaps and perform operations on them, such as pushing elements into the heap, popping the smallest element, and finding the n largest elements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To efficiently find the n largest numbers from a list and return them in descending order, we will utilize Python's built-in 'heapq' module. Specifically, we will use the 'nlargest' function from the 'heapq' module, which is designed to retrieve the n largest elements from the provided iterable.\n\n# [edge case] \n    heap_queue_largest([1, 2, 3, 4, 5], 0) = []\n    Explanation: If n is 0, the function should return an empty list since no elements are requested.\n    heap_queue_largest([], 3) = []\n    Explanation: If the input list is empty, the function should return an empty list regardless of the value of n.\n    heap_queue_largest([10, 20, 30, 40, 50], 6) = [50, 40, 30, 20, 10]\n    Explanation: If n is greater than the length of the list, the function should return the entire list sorted in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The 'nlargest' function from the 'heapq' module already handles cases where n is 0 or greater than the length of the list by returning an empty list or the entire list, respectively.\n", "requirement analysis:\nThe function should efficiently find the n largest numbers from a list and return them in descending order. The solution should be easy to understand and implement, leveraging Python's built-in libraries where possible for efficiency.\nrequirement pool:\n- The main code should be efficient in finding the n largest numbers\n- The function should return the numbers in descending order\n- The function should be easy to integrate into other projects\n- The function should handle large datasets efficiently\n- The function should be clearly documented and include examples of use\nTo efficiently find the n largest numbers from a list and return them in descending order, we will utilize Python's built-in 'heapq' module, which is specifically designed for such tasks. The 'heapq.nlargest' function will be used to retrieve the n largest elements from the list, and these elements will be sorted in descending order before returning.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'n largest numbers': means the top 'n' numbers in a list when sorted in descending order.\n    'heapq.nlargest': means using Python's heapq module to find the n largest elements efficiently.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan provided outlines the steps to be taken:\n    1. Use the 'heapq.nlargest' function to find the n largest numbers.\n    2. Sort these numbers in descending order.\n    3. Return the sorted list.\n\n# [edge case] \n    heap_queue_largest([10, 20, 30, 40, 50], 0) = []\n    Explanation: If n is 0, the function should return an empty list since no elements are requested.\n    heap_queue_largest([], 3) = []\n    Explanation: If the input list is empty, the function should return an empty list regardless of the value of n.\n    heap_queue_largest([1, 2, 3, 4, 5], 6) = [5, 4, 3, 2, 1]\n    Explanation: If n is greater than the length of the list, the function should return the entire list sorted in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic already covers the edge cases by returning an empty list when n is 0 or the input list is empty, and by returning the entire list sorted in descending order when n is greater than the length of the list.\n", "requirement analysis:\nThe primary requirement is to develop a function that can efficiently find the n largest numbers from a list and return them in descending order. This function should be robust, scalable, and easy to integrate. The function should handle large datasets efficiently and be compatible with Python's standard library.\nrequirement pool:\n- The main code should be efficient and optimized for quick retrieval of the largest numbers.\n- The function should handle large datasets without significant performance degradation.\n- The function should be easy to integrate into Python projects without additional dependencies.\n- The function should be clearly documented and include examples of usage.\n- The function should be tested for edge cases such as empty lists or lists with negative numbers.\nTo efficiently find the n largest numbers from a list and return them in descending order, we will utilize Python's built-in 'heapq' library, which provides an efficient way to handle heap operations. This approach ensures both performance and scalability, making it suitable for handling large datasets.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'heapq': This is a Python library used for heap operations. It provides an efficient way to handle heap operations, which are essential for finding the n largest numbers in a list.\n    Explanation: The 'heapq' library in Python provides functions to create a heap from an iterable and to push and pop elements from the heap. This is particularly useful for finding the n largest elements in a list, as it ensures both performance and scalability.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the function `heap_queue_largest`, we will follow these steps:\n    1. Import the `heapq` library.\n    2. Use the `heapq.nlargest` function to find the n largest elements in the list.\n    3. Return the result in descending order.\n\n# [edge case] \n    heap_queue_largest([1, 2, 3, 4, 5], 0) = []\n    Explanation: If n is 0, the function should return an empty list since no elements are requested.\n    heap_queue_largest([], 3) = []\n    Explanation: If the input list is empty, the function should return an empty list since there are no elements to process.\n    heap_queue_largest([1, 2, 3, 4, 5], 10) = [5, 4, 3, 2, 1]\n    Explanation: If n is greater than the length of the list, the function should return the entire list in descending order since all elements are the largest.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The `heapq.nlargest` function already handles cases where n is greater than the length of the list by returning the entire list.\n\n# [code logic]\n    ```python\n    import heapq\n\n    def heap_queue_largest(numbers, n):\n        if n == 0 or not numbers:\n            return []\n        largest_numbers = heapq.nlargest(n, numbers)\n        return largest_numbers\n    ```\n"], "test": ["def check(heap_queue_largest):\n\tassert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65] ", "def check(heap_queue_largest):\n\tassert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],2)==[85, 75] ", "def check(heap_queue_largest):\n\tassert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],5)==[85, 75, 65, 58, 35]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 39, 20, 87, 19, 64, 72, 27, 61], 4) == [87, 72, 64, 61]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 39, 18, 83, 14, 65, 71, 20, 62], 1) == [83]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([28, 34, 25, 89, 12, 66, 77, 27, 56], 5) == [89, 77, 66, 56, 34]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([21, 36, 22, 84, 13, 67, 78, 25, 54], 3) == [84, 78, 67]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([28, 38, 20, 85, 11, 68, 72, 18, 59], 6) == [85, 72, 68, 59, 38, 28]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([26, 30, 20, 81, 9, 61, 73, 19, 53], 6) == [81, 73, 61, 53, 30, 26]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([25, 32, 23, 86, 14, 60, 73, 23, 54], 6) == [86, 73, 60, 54, 32, 25]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([22, 33, 22, 80, 19, 64, 77, 24, 53], 3) == [80, 77, 64]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([28, 39, 25, 84, 17, 61, 77, 19, 53], 5) == [84, 77, 61, 53, 39]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 38, 17, 89, 18, 62, 80, 23, 60], 7) == [89, 80, 62, 60, 38, 30, 23]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([27, 40, 27, 86, 16, 66, 79, 24, 59], 7) == [86, 79, 66, 59, 40, 27, 27]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 36, 27, 81, 19, 66, 78, 23, 59], 8) == [81, 78, 66, 59, 36, 30, 27, 23]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 37, 20, 83, 18, 61, 75, 21, 55], 8) == [83, 75, 61, 55, 37, 23, 21, 20]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 36, 17, 83, 13, 65, 78, 23, 59], 5) == [83, 78, 65, 59, 36]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([27, 31, 23, 85, 10, 67, 77, 21, 57], 5) == [85, 77, 67, 57, 31]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([25, 39, 22, 83, 15, 68, 75, 25, 53], 3) == [83, 75, 68]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 37, 22, 85, 11, 68, 77, 19, 62], 8) == [85, 77, 68, 62, 37, 30, 22, 19]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([22, 31, 24, 89, 9, 63, 70, 27, 57], 5) == [89, 70, 63, 57, 31]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([24, 40, 26, 88, 16, 68, 79, 20, 63], 4) == [88, 79, 68, 63]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([22, 40, 23, 89, 15, 65, 74, 20, 62], 5) == [89, 74, 65, 62, 40]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 31, 21, 90, 14, 63, 78, 22, 59], 2) == [90, 78]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 30, 20, 85, 19, 69, 73, 18, 55], 8) == [85, 73, 69, 55, 30, 23, 20, 19]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([20, 37, 21, 81, 11, 64, 79, 17, 59], 3) == [81, 79, 64]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([25, 40, 21, 84, 11, 68, 71, 27, 56], 4) == [84, 71, 68, 56]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([25, 31, 19, 90, 15, 64, 79, 26, 57], 1) == [90]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([21, 31, 17, 80, 19, 69, 77, 27, 63], 1) == [80]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 36, 20, 87, 12, 69, 80, 27, 60], 4) == [87, 80, 69, 60]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([28, 30, 22, 80, 12, 60, 70, 27, 58], 7) == [80, 70, 60, 58, 30, 28, 27]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 30, 26, 87, 12, 66, 78, 19, 55], 4) == [87, 78, 66, 55]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([26, 39, 21, 82, 12, 60, 78, 24, 57], 7) == [82, 78, 60, 57, 39, 26, 24]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([24, 34, 23, 87, 14, 61, 70, 19, 55], 7) == [87, 70, 61, 55, 34, 24, 23]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 35, 21, 86, 14, 63, 76, 21, 54], 7) == [86, 76, 63, 54, 35, 30, 21]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 30, 25, 80, 15, 66, 72, 21, 63], 3) == [80, 72, 66]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 32, 23, 88, 12, 65, 70, 26, 60], 3) == [88, 70, 65]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 37, 19, 85, 11, 67, 73, 23, 62], 3) == [85, 73, 67]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([28, 38, 22, 88, 19, 68, 70, 18, 61], 2) == [88, 70]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 32, 25, 89, 11, 67, 74, 25, 54], 7) == [89, 74, 67, 54, 32, 30, 25]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 35, 24, 89, 15, 69, 70, 24, 60], 2) == [89, 70]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([21, 36, 24, 84, 10, 61, 71, 24, 63], 7) == [84, 71, 63, 61, 36, 24, 24]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 39, 27, 84, 13, 67, 71, 20, 62], 1) == [84]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([21, 36, 27, 85, 10, 65, 79, 21, 54], 2) == [85, 79]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 40, 19, 84, 16, 68, 80, 27, 63], 3) == [84, 80, 68]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([22, 40, 17, 80, 11, 60, 76, 19, 53], 6) == [80, 76, 60, 53, 40, 22]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 40, 19, 87, 17, 70, 77, 24, 55], 1) == [87]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 36, 19, 87, 12, 62, 74, 17, 62], 1) == [87]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([26, 33, 21, 86, 13, 64, 74, 19, 58], 4) == [86, 74, 64, 58]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 33, 22, 90, 11, 69, 76, 25, 54], 5) == [90, 76, 69, 54, 33]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([26, 37, 23, 83, 11, 63, 70, 22, 53], 3) == [83, 70, 63]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 30, 20, 87, 18, 62, 72, 19, 62], 1) == [87]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([28, 38, 25, 87, 18, 62, 78, 24, 63], 5) == [87, 78, 63, 62, 38]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 40, 27, 82, 9, 66, 80, 23, 55], 1) == [82]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 40, 18, 83, 13, 61, 75, 24, 55], 5) == [83, 75, 61, 55, 40]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([28, 39, 26, 81, 15, 67, 80, 27, 60], 7) == [81, 80, 67, 60, 39, 28, 27]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([22, 40, 23, 86, 15, 70, 78, 27, 63], 1) == [86]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([24, 40, 18, 84, 19, 61, 71, 25, 62], 2) == [84, 71]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([21, 30, 20, 87, 19, 61, 71, 26, 53], 7) == [87, 71, 61, 53, 30, 26, 21]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 40, 20, 90, 9, 70, 77, 21, 62], 2) == [90, 77]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([22, 33, 18, 81, 12, 67, 71, 25, 58], 6) == [81, 71, 67, 58, 33, 25]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([21, 36, 24, 86, 13, 66, 79, 21, 56], 2) == [86, 79]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 34, 17, 85, 9, 60, 74, 25, 63], 4) == [85, 74, 63, 60]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 37, 22, 90, 19, 67, 72, 19, 60], 7) == [90, 72, 67, 60, 37, 29, 22]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([25, 36, 21, 86, 12, 66, 78, 26, 54], 1) == [86]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([24, 33, 27, 82, 10, 60, 76, 26, 55], 2) == [82, 76]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([27, 34, 23, 83, 18, 65, 80, 25, 58], 6) == [83, 80, 65, 58, 34, 27]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 40, 19, 85, 11, 62, 73, 25, 53], 4) == [85, 73, 62, 53]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([20, 32, 17, 89, 10, 62, 77, 21, 53], 7) == [89, 77, 62, 53, 32, 21, 20]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 31, 17, 80, 13, 64, 72, 17, 55], 2) == [80, 72]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([25, 40, 17, 83, 11, 69, 77, 26, 61], 3) == [83, 77, 69]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([22, 39, 17, 89, 16, 65, 70, 23, 60], 6) == [89, 70, 65, 60, 39, 23]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 40, 20, 80, 12, 69, 75, 27, 58], 7) == [80, 75, 69, 58, 40, 30, 27]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 33, 19, 90, 13, 67, 70, 17, 59], 1) == [90]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 38, 27, 86, 15, 63, 80, 23, 63], 9) == [86, 80, 63, 63, 38, 29, 27, 23, 15]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 38, 24, 84, 13, 68, 75, 23, 61], 3) == [84, 75, 68]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([22, 35, 18, 84, 12, 70, 76, 19, 60], 2) == [84, 76]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([20, 35, 20, 86, 14, 63, 80, 22, 56], 4) == [86, 80, 63, 56]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 32, 18, 87, 15, 65, 70, 26, 59], 9) == [87, 70, 65, 59, 32, 29, 26, 18, 15]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 40, 24, 81, 10, 64, 71, 23, 55], 8) == [81, 71, 64, 55, 40, 30, 24, 23]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 33, 20, 87, 10, 61, 80, 21, 57], 10) == [87, 80, 61, 57, 33, 29, 21, 20, 10]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([28, 31, 27, 88, 9, 70, 79, 25, 59], 8) == [88, 79, 70, 59, 31, 28, 27, 25]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 39, 20, 84, 15, 65, 72, 21, 63], 5) == [84, 72, 65, 63, 39]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([20, 37, 17, 86, 13, 67, 80, 24, 63], 5) == [86, 80, 67, 63, 37]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([21, 37, 17, 83, 18, 65, 74, 20, 61], 4) == [83, 74, 65, 61]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 38, 26, 82, 10, 67, 79, 25, 55], 10) == [82, 79, 67, 55, 38, 30, 26, 25, 10]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([24, 39, 24, 83, 11, 62, 71, 17, 59], 9) == [83, 71, 62, 59, 39, 24, 24, 17, 11]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([28, 30, 20, 80, 17, 66, 78, 25, 62], 10) == [80, 78, 66, 62, 30, 28, 25, 20, 17]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([24, 40, 26, 89, 17, 62, 70, 24, 61], 5) == [89, 70, 62, 61, 40]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([20, 34, 26, 87, 18, 68, 76, 21, 61], 10) == [87, 76, 68, 61, 34, 26, 21, 20, 18]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([26, 31, 19, 80, 19, 70, 78, 21, 58], 4) == [80, 78, 70, 58]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 30, 18, 82, 16, 67, 73, 22, 53], 1) == [82]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 37, 20, 83, 19, 69, 77, 19, 60], 5) == [83, 77, 69, 60, 37]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 31, 17, 81, 13, 67, 77, 21, 62], 4) == [81, 77, 67, 62]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 32, 20, 89, 11, 62, 78, 27, 54], 1) == [89]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([25, 35, 17, 89, 15, 67, 71, 22, 56], 8) == [89, 71, 67, 56, 35, 25, 22, 17]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([27, 33, 24, 88, 19, 62, 73, 25, 61], 7) == [88, 73, 62, 61, 33, 27, 25]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 38, 25, 89, 11, 68, 72, 21, 56], 9) == [89, 72, 68, 56, 38, 30, 25, 21, 11]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([20, 36, 17, 82, 15, 61, 78, 17, 55], 4) == [82, 78, 61, 55]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([27, 33, 23, 85, 11, 62, 73, 26, 61], 7) == [85, 73, 62, 61, 33, 27, 26]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([26, 40, 22, 84, 16, 65, 77, 17, 57], 8) == [84, 77, 65, 57, 40, 26, 22, 17]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 33, 24, 84, 17, 70, 79, 21, 53], 5) == [84, 79, 70, 53, 33]"], "scores": [1.0, 1.0, 0.1275, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, false, true, true, true, true, true, true, true], "pass_test_cases_num": [102, 102, 13, 102, 102, 102, 102, 102, 102, 102], "completion": "from typing import List\n## main.py\n\nimport heapq\nfrom typing import List\n\ndef heap_queue_largest(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    This function returns the n largest numbers from the given list in descending order.\n    \n    Args:\n        nums (List[int]): The list of numbers to search for the largest n numbers.\n        n (int): The number of largest elements to return.\n    \n    Returns:\n        List[int]: A list of the n largest numbers in descending order.\n    \"\"\"\n    if n == 0 or not nums:\n        return []\n    \n    largest_numbers = heapq.nlargest(n, nums)\n    return largest_numbers\n", "passed": true, "pass": true, "pass_num": 9, "round": 594, "mutate_method": "rephrase_one", "parent_index": 536}
