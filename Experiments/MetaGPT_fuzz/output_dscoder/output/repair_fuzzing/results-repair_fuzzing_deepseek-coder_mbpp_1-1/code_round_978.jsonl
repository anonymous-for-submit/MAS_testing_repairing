{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 4, "prompt": "Create a function to find the n largest numbers from a given list, returned in descending order.", "code": "import heapq as hq\ndef heap_queue_largest(nums,n):\n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "test_imports": [], "test_list": ["assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65] ", "assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],2)==[85, 75] ", "assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],5)==[85, 75, 65, 58, 35]", "assert heap_queue_largest([29, 39, 20, 87, 19, 64, 72, 27, 61], 4) == [87, 72, 64, 61]", "assert heap_queue_largest([23, 39, 18, 83, 14, 65, 71, 20, 62], 1) == [83]", "assert heap_queue_largest([28, 34, 25, 89, 12, 66, 77, 27, 56], 5) == [89, 77, 66, 56, 34]", "assert heap_queue_largest([21, 36, 22, 84, 13, 67, 78, 25, 54], 3) == [84, 78, 67]", "assert heap_queue_largest([28, 38, 20, 85, 11, 68, 72, 18, 59], 6) == [85, 72, 68, 59, 38, 28]", "assert heap_queue_largest([26, 30, 20, 81, 9, 61, 73, 19, 53], 6) == [81, 73, 61, 53, 30, 26]", "assert heap_queue_largest([25, 32, 23, 86, 14, 60, 73, 23, 54], 6) == [86, 73, 60, 54, 32, 25]", "assert heap_queue_largest([22, 33, 22, 80, 19, 64, 77, 24, 53], 3) == [80, 77, 64]", "assert heap_queue_largest([28, 39, 25, 84, 17, 61, 77, 19, 53], 5) == [84, 77, 61, 53, 39]", "assert heap_queue_largest([30, 38, 17, 89, 18, 62, 80, 23, 60], 7) == [89, 80, 62, 60, 38, 30, 23]", "assert heap_queue_largest([27, 40, 27, 86, 16, 66, 79, 24, 59], 7) == [86, 79, 66, 59, 40, 27, 27]", "assert heap_queue_largest([30, 36, 27, 81, 19, 66, 78, 23, 59], 8) == [81, 78, 66, 59, 36, 30, 27, 23]", "assert heap_queue_largest([23, 37, 20, 83, 18, 61, 75, 21, 55], 8) == [83, 75, 61, 55, 37, 23, 21, 20]", "assert heap_queue_largest([29, 36, 17, 83, 13, 65, 78, 23, 59], 5) == [83, 78, 65, 59, 36]", "assert heap_queue_largest([27, 31, 23, 85, 10, 67, 77, 21, 57], 5) == [85, 77, 67, 57, 31]", "assert heap_queue_largest([25, 39, 22, 83, 15, 68, 75, 25, 53], 3) == [83, 75, 68]", "assert heap_queue_largest([30, 37, 22, 85, 11, 68, 77, 19, 62], 8) == [85, 77, 68, 62, 37, 30, 22, 19]", "assert heap_queue_largest([22, 31, 24, 89, 9, 63, 70, 27, 57], 5) == [89, 70, 63, 57, 31]", "assert heap_queue_largest([24, 40, 26, 88, 16, 68, 79, 20, 63], 4) == [88, 79, 68, 63]", "assert heap_queue_largest([22, 40, 23, 89, 15, 65, 74, 20, 62], 5) == [89, 74, 65, 62, 40]", "assert heap_queue_largest([23, 31, 21, 90, 14, 63, 78, 22, 59], 2) == [90, 78]", "assert heap_queue_largest([23, 30, 20, 85, 19, 69, 73, 18, 55], 8) == [85, 73, 69, 55, 30, 23, 20, 19]", "assert heap_queue_largest([20, 37, 21, 81, 11, 64, 79, 17, 59], 3) == [81, 79, 64]", "assert heap_queue_largest([25, 40, 21, 84, 11, 68, 71, 27, 56], 4) == [84, 71, 68, 56]", "assert heap_queue_largest([25, 31, 19, 90, 15, 64, 79, 26, 57], 1) == [90]", "assert heap_queue_largest([21, 31, 17, 80, 19, 69, 77, 27, 63], 1) == [80]", "assert heap_queue_largest([30, 36, 20, 87, 12, 69, 80, 27, 60], 4) == [87, 80, 69, 60]", "assert heap_queue_largest([28, 30, 22, 80, 12, 60, 70, 27, 58], 7) == [80, 70, 60, 58, 30, 28, 27]", "assert heap_queue_largest([30, 30, 26, 87, 12, 66, 78, 19, 55], 4) == [87, 78, 66, 55]", "assert heap_queue_largest([26, 39, 21, 82, 12, 60, 78, 24, 57], 7) == [82, 78, 60, 57, 39, 26, 24]", "assert heap_queue_largest([24, 34, 23, 87, 14, 61, 70, 19, 55], 7) == [87, 70, 61, 55, 34, 24, 23]", "assert heap_queue_largest([30, 35, 21, 86, 14, 63, 76, 21, 54], 7) == [86, 76, 63, 54, 35, 30, 21]", "assert heap_queue_largest([29, 30, 25, 80, 15, 66, 72, 21, 63], 3) == [80, 72, 66]", "assert heap_queue_largest([23, 32, 23, 88, 12, 65, 70, 26, 60], 3) == [88, 70, 65]", "assert heap_queue_largest([29, 37, 19, 85, 11, 67, 73, 23, 62], 3) == [85, 73, 67]", "assert heap_queue_largest([28, 38, 22, 88, 19, 68, 70, 18, 61], 2) == [88, 70]", "assert heap_queue_largest([30, 32, 25, 89, 11, 67, 74, 25, 54], 7) == [89, 74, 67, 54, 32, 30, 25]", "assert heap_queue_largest([23, 35, 24, 89, 15, 69, 70, 24, 60], 2) == [89, 70]", "assert heap_queue_largest([21, 36, 24, 84, 10, 61, 71, 24, 63], 7) == [84, 71, 63, 61, 36, 24, 24]", "assert heap_queue_largest([23, 39, 27, 84, 13, 67, 71, 20, 62], 1) == [84]", "assert heap_queue_largest([21, 36, 27, 85, 10, 65, 79, 21, 54], 2) == [85, 79]", "assert heap_queue_largest([23, 40, 19, 84, 16, 68, 80, 27, 63], 3) == [84, 80, 68]", "assert heap_queue_largest([22, 40, 17, 80, 11, 60, 76, 19, 53], 6) == [80, 76, 60, 53, 40, 22]", "assert heap_queue_largest([30, 40, 19, 87, 17, 70, 77, 24, 55], 1) == [87]", "assert heap_queue_largest([30, 36, 19, 87, 12, 62, 74, 17, 62], 1) == [87]", "assert heap_queue_largest([26, 33, 21, 86, 13, 64, 74, 19, 58], 4) == [86, 74, 64, 58]", "assert heap_queue_largest([29, 33, 22, 90, 11, 69, 76, 25, 54], 5) == [90, 76, 69, 54, 33]", "assert heap_queue_largest([26, 37, 23, 83, 11, 63, 70, 22, 53], 3) == [83, 70, 63]", "assert heap_queue_largest([23, 30, 20, 87, 18, 62, 72, 19, 62], 1) == [87]", "assert heap_queue_largest([28, 38, 25, 87, 18, 62, 78, 24, 63], 5) == [87, 78, 63, 62, 38]", "assert heap_queue_largest([23, 40, 27, 82, 9, 66, 80, 23, 55], 1) == [82]", "assert heap_queue_largest([23, 40, 18, 83, 13, 61, 75, 24, 55], 5) == [83, 75, 61, 55, 40]", "assert heap_queue_largest([28, 39, 26, 81, 15, 67, 80, 27, 60], 7) == [81, 80, 67, 60, 39, 28, 27]", "assert heap_queue_largest([22, 40, 23, 86, 15, 70, 78, 27, 63], 1) == [86]", "assert heap_queue_largest([24, 40, 18, 84, 19, 61, 71, 25, 62], 2) == [84, 71]", "assert heap_queue_largest([21, 30, 20, 87, 19, 61, 71, 26, 53], 7) == [87, 71, 61, 53, 30, 26, 21]", "assert heap_queue_largest([30, 40, 20, 90, 9, 70, 77, 21, 62], 2) == [90, 77]", "assert heap_queue_largest([22, 33, 18, 81, 12, 67, 71, 25, 58], 6) == [81, 71, 67, 58, 33, 25]", "assert heap_queue_largest([21, 36, 24, 86, 13, 66, 79, 21, 56], 2) == [86, 79]", "assert heap_queue_largest([30, 34, 17, 85, 9, 60, 74, 25, 63], 4) == [85, 74, 63, 60]", "assert heap_queue_largest([29, 37, 22, 90, 19, 67, 72, 19, 60], 7) == [90, 72, 67, 60, 37, 29, 22]", "assert heap_queue_largest([25, 36, 21, 86, 12, 66, 78, 26, 54], 1) == [86]", "assert heap_queue_largest([24, 33, 27, 82, 10, 60, 76, 26, 55], 2) == [82, 76]", "assert heap_queue_largest([27, 34, 23, 83, 18, 65, 80, 25, 58], 6) == [83, 80, 65, 58, 34, 27]", "assert heap_queue_largest([23, 40, 19, 85, 11, 62, 73, 25, 53], 4) == [85, 73, 62, 53]", "assert heap_queue_largest([20, 32, 17, 89, 10, 62, 77, 21, 53], 7) == [89, 77, 62, 53, 32, 21, 20]", "assert heap_queue_largest([23, 31, 17, 80, 13, 64, 72, 17, 55], 2) == [80, 72]", "assert heap_queue_largest([25, 40, 17, 83, 11, 69, 77, 26, 61], 3) == [83, 77, 69]", "assert heap_queue_largest([22, 39, 17, 89, 16, 65, 70, 23, 60], 6) == [89, 70, 65, 60, 39, 23]", "assert heap_queue_largest([30, 40, 20, 80, 12, 69, 75, 27, 58], 7) == [80, 75, 69, 58, 40, 30, 27]", "assert heap_queue_largest([23, 33, 19, 90, 13, 67, 70, 17, 59], 1) == [90]", "assert heap_queue_largest([29, 38, 27, 86, 15, 63, 80, 23, 63], 9) == [86, 80, 63, 63, 38, 29, 27, 23, 15]", "assert heap_queue_largest([30, 38, 24, 84, 13, 68, 75, 23, 61], 3) == [84, 75, 68]", "assert heap_queue_largest([22, 35, 18, 84, 12, 70, 76, 19, 60], 2) == [84, 76]", "assert heap_queue_largest([20, 35, 20, 86, 14, 63, 80, 22, 56], 4) == [86, 80, 63, 56]", "assert heap_queue_largest([29, 32, 18, 87, 15, 65, 70, 26, 59], 9) == [87, 70, 65, 59, 32, 29, 26, 18, 15]", "assert heap_queue_largest([30, 40, 24, 81, 10, 64, 71, 23, 55], 8) == [81, 71, 64, 55, 40, 30, 24, 23]", "assert heap_queue_largest([29, 33, 20, 87, 10, 61, 80, 21, 57], 10) == [87, 80, 61, 57, 33, 29, 21, 20, 10]", "assert heap_queue_largest([28, 31, 27, 88, 9, 70, 79, 25, 59], 8) == [88, 79, 70, 59, 31, 28, 27, 25]", "assert heap_queue_largest([29, 39, 20, 84, 15, 65, 72, 21, 63], 5) == [84, 72, 65, 63, 39]", "assert heap_queue_largest([20, 37, 17, 86, 13, 67, 80, 24, 63], 5) == [86, 80, 67, 63, 37]", "assert heap_queue_largest([21, 37, 17, 83, 18, 65, 74, 20, 61], 4) == [83, 74, 65, 61]", "assert heap_queue_largest([30, 38, 26, 82, 10, 67, 79, 25, 55], 10) == [82, 79, 67, 55, 38, 30, 26, 25, 10]", "assert heap_queue_largest([24, 39, 24, 83, 11, 62, 71, 17, 59], 9) == [83, 71, 62, 59, 39, 24, 24, 17, 11]", "assert heap_queue_largest([28, 30, 20, 80, 17, 66, 78, 25, 62], 10) == [80, 78, 66, 62, 30, 28, 25, 20, 17]", "assert heap_queue_largest([24, 40, 26, 89, 17, 62, 70, 24, 61], 5) == [89, 70, 62, 61, 40]", "assert heap_queue_largest([20, 34, 26, 87, 18, 68, 76, 21, 61], 10) == [87, 76, 68, 61, 34, 26, 21, 20, 18]", "assert heap_queue_largest([26, 31, 19, 80, 19, 70, 78, 21, 58], 4) == [80, 78, 70, 58]", "assert heap_queue_largest([29, 30, 18, 82, 16, 67, 73, 22, 53], 1) == [82]", "assert heap_queue_largest([30, 37, 20, 83, 19, 69, 77, 19, 60], 5) == [83, 77, 69, 60, 37]", "assert heap_queue_largest([29, 31, 17, 81, 13, 67, 77, 21, 62], 4) == [81, 77, 67, 62]", "assert heap_queue_largest([30, 32, 20, 89, 11, 62, 78, 27, 54], 1) == [89]", "assert heap_queue_largest([25, 35, 17, 89, 15, 67, 71, 22, 56], 8) == [89, 71, 67, 56, 35, 25, 22, 17]", "assert heap_queue_largest([27, 33, 24, 88, 19, 62, 73, 25, 61], 7) == [88, 73, 62, 61, 33, 27, 25]", "assert heap_queue_largest([30, 38, 25, 89, 11, 68, 72, 21, 56], 9) == [89, 72, 68, 56, 38, 30, 25, 21, 11]", "assert heap_queue_largest([20, 36, 17, 82, 15, 61, 78, 17, 55], 4) == [82, 78, 61, 55]", "assert heap_queue_largest([27, 33, 23, 85, 11, 62, 73, 26, 61], 7) == [85, 73, 62, 61, 33, 27, 26]", "assert heap_queue_largest([26, 40, 22, 84, 16, 65, 77, 17, 57], 8) == [84, 77, 65, 57, 40, 26, 22, 17]", "assert heap_queue_largest([23, 33, 24, 84, 17, 70, 79, 21, 53], 5) == [84, 79, 70, 53, 33]"], "entry_point": "heap_queue_largest", "repair_prompt": ["Create a function heap_queue_largest to find the n largest numbers from a given list, returned in descending order.\nheap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65] \n", " Create a function heap_queue_largest to find the n largest numbers from a given list, returned in descending order.\nheap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65] \n", " Create a function heap_queue_largest that finds the n largest numbers from a given list, sorted in descending order.\nheap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65] \n"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\nimport heapq\n\ndef heap_queue_largest(numbers: List[int], n: int) -> List[int]:\n    \"\"\"\n    Returns the n largest numbers from the given list in descending order.\n    \n    Args:\n        numbers (List[int]): The list of numbers to search for the largest elements.\n        n (int): The number of largest elements to return.\n    \n    Returns:\n        List[int]: A list of the n largest numbers in descending order.\n    \"\"\"\n    if n == 0 or not numbers:\n        return []\n    \n    # Use heapq.nlargest to find the n largest elements\n    largest_numbers = heapq.nlargest(n, numbers)\n    \n    # Return the result in descending order\n    return largest_numbers[::-1]\n", "from typing import List\nfrom typing import List\nimport heapq\n\ndef heap_queue_largest(numbers: List[int], n: int) -> List[int]:\n    \"\"\"\n    Finds the n largest numbers from a given list and returns them in descending order.\n    \n    Args:\n        numbers (List[int]): The list of integers from which to find the largest numbers.\n        n (int): The number of largest numbers to return.\n    \n    Returns:\n        List[int]: A list of the n largest numbers in descending order.\n    \"\"\"\n    if n == 0 or not numbers:\n        return []\n    \n    # Find the n largest numbers using heapq.nlargest\n    largest_numbers = heapq.nlargest(n, numbers)\n    \n    # Return the result in descending order\n    return sorted(largest_numbers, reverse=True)\n", "from typing import List\nimport heapq\n\ndef heap_queue_largest(numbers: list[int], n: int) -> list[int]:\n    \"\"\"\n    Finds the n largest numbers from a given list and returns them in descending order.\n    \n    Args:\n        numbers (list[int]): The list of integers to search for the n largest numbers.\n        n (int): The number of largest elements to return.\n    \n    Returns:\n        list[int]: A list of the n largest integers in descending order.\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    largest_n = heapq.nlargest(n, numbers)\n    return sorted(largest_n, reverse=True)\n", "from typing import List\nfrom typing import List\nimport heapq\n\ndef heap_queue_largest(numbers: List[int], n: int) -> List[int]:\n    \"\"\"\n    Finds the n largest numbers from a given list and returns them in descending order.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n        n (int): The number of largest elements to find.\n    \n    Returns:\n        List[int]: A list of the n largest numbers in descending order.\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    # Use heapq.nlargest to find the n largest elements\n    largest_numbers = heapq.nlargest(n, numbers)\n    \n    # Return the result in descending order\n    return largest_numbers[::-1]\n", "from typing import List\nimport heapq\n\ndef heap_queue_largest(nums: list[int], n: int) -> list[int]:\n    \"\"\"\n    Returns the n largest numbers from the given list in descending order.\n    \n    Args:\n        nums (list[int]): The list of integers to search for the largest numbers.\n        n (int): The number of largest elements to return.\n    \n    Returns:\n        list[int]: A list of the n largest numbers in descending order.\n    \"\"\"\n    if n == 0 or not nums:\n        return []\n    \n    # Convert the list into a heap\n    heapq.heapify(nums)\n    \n    # Get the n largest elements from the heap\n    largest_elements = heapq.nlargest(n, nums)\n    \n    # Return the largest elements in descending order\n    return sorted(largest_elements, reverse=True)\n", "from typing import List\nfrom typing import List\nimport heapq\n\ndef heap_queue_largest(numbers: List[int], n: int) -> List[int]:\n    \"\"\"\n    Finds the n largest numbers from the given list and returns them in descending order.\n    \n    Args:\n        numbers (List[int]): A list of integers from which to find the largest numbers.\n        n (int): The number of largest elements to find.\n        \n    Returns:\n        List[int]: A list of the n largest numbers in descending order.\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    # Find the n largest numbers\n    largest_numbers = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    largest_numbers.sort(reverse=True)\n    \n    return largest_numbers\n", "from typing import List\nimport heapq\n\ndef heap_queue_largest(numbers: list[int], n: int) -> list[int]:\n    \"\"\"\n    This function takes a list of integers and an integer n, returns a list of the n largest numbers in descending order.\n    \n    Args:\n        numbers (list[int]): A list of integers.\n        n (int): The number of largest elements to return.\n    \n    Returns:\n        list[int]: A list of the n largest numbers in descending order.\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    # Find the n largest elements\n    largest_elements = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    return sorted(largest_elements, reverse=True)\n\n# Example usage:\n# print(heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3))  # Output: [85, 75, 65]\n", "from typing import List\nimport heapq\nfrom typing import List\n\ndef heap_queue_largest(numbers: List[int], n: int) -> List[int]:\n    if n <= 0:\n        return []\n    largest_n = heapq.nlargest(n, numbers)\n    return sorted(largest_n, reverse=True)\n", "from typing import List\nimport heapq\n\ndef heap_queue_largest(numbers: list[int], n: int) -> list[int]:\n    if n <= 0:\n        return []\n    largest_numbers = heapq.nlargest(n, numbers)\n    return sorted(largest_numbers, reverse=True)\n", "from typing import List\nfrom typing import List\nimport heapq\n\ndef heap_queue_largest(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Finds the n largest numbers from a given list and returns them in descending order.\n    \n    Args:\n        nums (List[int]): The input list of numbers.\n        n (int): The number of largest elements to find.\n        \n    Returns:\n        List[int]: The n largest elements in descending order.\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    # Use heapq.nlargest to find the n largest elements\n    largest_nums = heapq.nlargest(n, nums)\n    \n    # Return the n largest elements in descending order\n    return largest_nums[::-1]\n\n# Example usage:\n# print(heap_queue_largest([1, 2, 3, 4, 5], 3))  # Output: [5, 4, 3]\n"], "plans": ["requirement analysis:\nThe requirement is to create a function that finds the n largest numbers from a given list and returns them in descending order. This is a common problem in data processing and requires an efficient solution. The function should be able to handle various sizes of lists and provide accurate results.\nrequirement pool:\n- The main code should be efficient and fast.\n- The function should return the numbers in descending order.\n- The function should be able to handle large lists.\n- The function should be easy to use and understand.\n- The function should be compatible with different programming languages.\nTo create a function that finds the n largest numbers from a given list and returns them in descending order, we will utilize Python's built-in 'heapq' library, which provides an efficient way to handle heap operations. This approach ensures both efficiency and ease of implementation.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'heap' and 'queue'\n    In the requirement, it refers to the use of a heap data structure to efficiently find the largest elements, which is a common application of heap operations.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests using the `heapq.nlargest` function from the Python `heapq` library to find the n largest elements in the list. This function returns a list of the n largest elements from the provided iterable in descending order.\n\n# [edge case] \n    heap_queue_largest([1, 2, 3, 4, 5], 0) = []\n    Explanation: If n is 0, the function should return an empty list since no elements are requested.\n    heap_queue_largest([], 3) = []\n    Explanation: If the input list is empty, the function should return an empty list regardless of the value of n.\n    heap_queue_largest([1, 2, 3, 4, 5], 10) = [5, 4, 3, 2, 1]\n    Explanation: If n is greater than the length of the list, the function should return the entire list sorted in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The `heapq.nlargest` function already handles cases where n is 0 or greater than the list size by returning appropriate results.\n", "requirement analysis:\nThe requirement is to create a function that finds the n largest numbers from a given list and returns them in descending order. This is a common task in data processing and should be efficiently implemented. The function should be able to handle various sizes of lists and provide a good user experience.\nrequirement pool:\n- The main code should efficiently find the n largest numbers from a given list.\n- The function should return the numbers in descending order.\n- The function should be able to handle lists of different sizes.\n- The function should provide a user-friendly interface.\n- The function should be optimized for performance.\nTo create a function that efficiently finds the n largest numbers from a given list and returns them in descending order, we will utilize Python's built-in 'heapq' library, which provides an efficient way to handle heap operations. This approach ensures both performance and ease of implementation.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'heapq': This is a Python library that provides an implementation of the heap queue algorithm, also known as the priority queue algorithm.\n    Explanation: The heapq library provides an efficient way to handle heap operations, which is crucial for finding the n largest numbers efficiently.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the function `heap_queue_largest`, we will follow these steps:\n    1. Import the `heapq` library.\n    2. Use the `heapq.nlargest` function to find the n largest elements in the list.\n    3. Return the result in descending order.\n\n# [edge case] \n    heap_queue_largest([1, 2, 3, 4, 5], 0) = []\n    Explanation: If n is 0, the function should return an empty list since there are no elements to return.\n    heap_queue_largest([], 3) = []\n    Explanation: If the input list is empty, the function should return an empty list since there are no numbers to find the largest from.\n    heap_queue_largest([1, 2, 3, 4, 5], 10) = [5, 4, 3, 2, 1]\n    Explanation: If n is greater than the length of the list, the function should return the entire list in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The `heapq.nlargest` function already handles cases where n is greater than the length of the list by returning the entire list.\n", "requirement analysis:\nThe primary requirement is to create a function that efficiently finds the n largest numbers from a given list and returns them in descending order. This requires a balance between performance and user experience. The function should be able to handle large datasets and provide a clear, user-friendly interface for specifying the number of largest elements to find.\nrequirement pool:\n- The main code should be efficient and use Python's built-in libraries where possible to ensure performance.\n- The user interface should be simple and intuitive, allowing users to easily input their list and specify the number of largest elements.\n- The function should handle edge cases, such as empty lists or lists with non-numeric values.\n- The results should be returned in descending order to provide the most immediate value to the user.\n- The product should be tested thoroughly to ensure it meets all requirements and performs well under various conditions.\nTo create a function that efficiently finds the n largest numbers from a given list and returns them in descending order, we will utilize Python's built-in 'heapq' library. This library provides an efficient way to handle heaps, which is crucial for our performance requirements. The 'heapq.nlargest' function will be used to find the n largest elements from the list, and then these elements will be sorted in descending order before being returned.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'heapq.nlargest': This function is used to find the n largest elements from a list.\n    'descending order': This means the elements are sorted in a way that the largest comes first and the smallest comes last.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    import heapq\n\n    def heap_queue_largest(nums, n):\n        if n <= 0:\n            return []\n        largest_n = heapq.nlargest(n, nums)\n        return sorted(largest_n, reverse=True)\n\n# [edge case] \n    heap_queue_largest([], 3) = []\n    Explanation: Since the list is empty, there are no numbers to find, so the expected output is an empty list.\n    heap_queue_largest([1, 2, 3], 0) = []\n    Explanation: Since n is 0, we are asked to find 0 largest numbers, which is not possible. The expected output is an empty list.\n    heap_queue_largest([5, 5, 5, 5], 5) = [5, 5, 5, 5]\n    Explanation: Since n is equal to the number of elements in the list, all elements are the largest. The expected output is the list itself in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic already covers cases where the list is empty or n is 0.\n", "requirement analysis:\nThe primary requirement is to create a function that can efficiently find the n largest numbers from a given list and return them in descending order. This function should be versatile, capable of handling various types of input data, including lists with negative numbers and duplicates. The solution should be user-friendly and provide clear, concise results. The product should also be designed with scalability in mind, ensuring it can handle large datasets without performance degradation.\nrequirement pool:\n- The main code should be efficient and optimized for performance.\n- The function should handle all types of input data correctly.\n- The user interface should be simple and intuitive.\n- The product should be able to handle large datasets without significant slowdowns.\n- The results should be returned in descending order, making it easy for users to identify the largest numbers.\nTo create an efficient and user-friendly function for finding the n largest numbers from a given list and returning them in descending order, we will utilize Python's built-in 'heapq' module, which provides an efficient way to handle heap operations. This module will help us efficiently find the largest elements and maintain the order without the need to manually implement complex heap algorithms.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'heap operations': This refers to the efficient way to handle priority queues, which are commonly implemented using heaps. In Python, the `heapq` module provides an efficient way to handle heap operations.\n    Explanation: The core concept here is using the `heapq` module to efficiently find the largest elements in a list and return them in descending order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the function `heap_queue_largest`, we will follow these steps:\n    1. Import the `heapq` module.\n    2. Use the `heapq.nlargest` function to find the n largest elements in the list.\n    3. Return the result in descending order.\n\n# [edge case] \n    heap_queue_largest([1], 1) = [1]\n    Explanation: When the list contains only one element and we are asked to find the largest element (n=1), the function should return the element itself.\n    heap_queue_largest([], 3) = []\n    Explanation: When the list is empty and we are asked to find the largest elements (n=3), the function should return an empty list since there are no elements to consider.\n    heap_queue_largest([5, 5, 5, 5], 2) = [5, 5]\n    Explanation: When all elements in the list are the same and we are asked to find the two largest elements, the function should return the element repeated twice.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The `heapq.nlargest` function already takes care of returning an empty list when the input list is empty or when n is greater than the length of the list.\n", "requirement analysis:\nThe primary requirement is to create a function that can efficiently find the n largest numbers from a given list and return them in descending order. This requires understanding of data structures and algorithms, specifically heap operations. The function should be robust enough to handle various edge cases and should be implemented in a way that is easy to use and understand.\nrequirement pool:\n- Implement the heap_queue_largest function using Python's heapq module for efficient heap operations.\n- Ensure the function returns the n largest numbers in descending order.\n- Include error handling for empty lists and lists with negative numbers.\n- Provide clear documentation and examples of how to use the function.\n- Optimize the function for performance, especially for large datasets.\nTo implement the heap_queue_largest function efficiently, we will utilize Python's built-in heapq module, which provides efficient heap operations. The function will first convert the input list into a heap, then extract the n largest elements from it, and finally return these elements in descending order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'heap' and 'priority queue'\n    In the requirement, it refers to the use of a heap data structure to efficiently find the largest elements in a list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'largest'\n    The requirement specifies that we need to find the n largest numbers, emphasizing the importance of identifying the largest elements.\n\n# [code logic]\n    To implement the `heap_queue_largest` function, we will follow these steps:\n    1. Import the `heapq` module.\n    2. Convert the input list into a heap.\n    3. Use `heapq.nlargest` to find the n largest elements from the heap.\n    4. Return these elements in descending order.\n\n# [edge case] \n    heap_queue_largest([1, 2, 3, 4, 5], 0) = []\n    Explanation: If n is 0, the function should return an empty list since no elements are requested.\n    heap_queue_largest([], 3) = []\n    Explanation: If the input list is empty, the function should return an empty list regardless of the value of n.\n    heap_queue_largest([1, 2, 3, 4, 5], 10) = [5, 4, 3, 2, 1]\n    Explanation: If n is greater than the length of the list, the function should return all elements in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic can handle cases where n is 0 or greater than the length of the list by returning appropriate empty lists.\n", "requirement analysis:\nThe requirement is to create a function that finds the n largest numbers from a given list and returns them in descending order. This is a specific task that can be efficiently handled using Python's heapq module, which provides a heap queue algorithm. The function should be user-friendly, efficient, and capable of handling large datasets.\nrequirement pool:\n- The main code should efficiently find the n largest numbers using Python's heapq module.\n- The function should return the results in descending order.\n- The product should be easy to use and understand.\n- The function should handle large datasets efficiently without significant performance issues.\n- The product should be compatible with Python's standard library and not require additional dependencies.\nTo create a function that efficiently finds the n largest numbers from a given list and returns them in descending order, we will utilize Python's built-in heapq module. This module provides an efficient way to handle heaps, which is perfect for our needs. We will use the `nlargest` function from heapq to find the largest numbers and then sort them in descending order before returning.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'heap' and 'queue': These concepts are related to data structures where elements are added and removed based on priority. In this case, we are using the heapq module to efficiently find the largest elements.\n\n    'largest numbers': We need to identify and return the top n largest numbers from a given list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the function `heap_queue_largest`, we will follow these steps:\n    1. Import the `nlargest` function from the `heapq` module.\n    2. Use `nlargest` to find the n largest numbers in the given list.\n    3. Sort the result in descending order.\n    4. Return the sorted list.\n\n# [edge case] \n    heap_queue_largest([], 3) = []\n    Explanation: Since the list is empty, there are no numbers to find, so the expected output is an empty list.\n    heap_queue_largest([1, 2, 3], 4) = [3, 2, 1]\n    Explanation: We are asking for 4 largest numbers, but there are only 3 numbers in the list. The function will return all numbers in descending order.\n    heap_queue_largest([5, 5, 5, 5], 2) = [5, 5]\n    Explanation: All numbers in the list are the same, so the 2 largest numbers are both 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case where the list is empty. The function will return an empty list as expected.\n", "requirement analysis:\nThe function should efficiently find the n largest numbers from a list, ensuring it handles various data sizes and types. The output should be sorted in descending order, which aligns with typical expectations for such a function. The function should be optimized for performance and usability.\nrequirement pool:\n- Implement heap_queue_largest function\n- Ensure function returns n largest numbers in descending order\n- Optimize for handling large datasets\n- Include error handling for non-list inputs\n- Provide documentation and examples for user guidance\nTo create the `heap_queue_largest` function efficiently, we will utilize Python's built-in `heapq` module, which provides an efficient way to handle heaps. This module offers functionalities like `nlargest` which directly addresses the requirement of finding the n largest elements. We will ensure that the output is sorted in descending order by leveraging the `sorted` function on the result of `nlargest`. This approach combines the performance benefits of heap operations with the simplicity of Python's standard library.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'n largest numbers': means to find the top n elements from a list that are the largest\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan provided suggests using Python's `heapq` module to find the n largest elements. The steps include:\n    1. Import the `heapq` module.\n    2. Use the `nlargest` function from `heapq` to find the n largest elements.\n    3. Sort the result in descending order using the `sorted` function with a reverse argument.\n\n# [edge case] \n    heap_queue_largest([1], 1) = [1]\n    Explanation: Since the list contains only one element, the largest (and only) element is 1.\n    heap_queue_largest([], 3) = []\n    Explanation: An empty list should return an empty list, as there are no elements to find.\n    heap_queue_largest([1, 2, 3, 4, 5], 10) = [5, 4, 3, 2, 1]\n    Explanation: The list contains fewer elements than requested, so all elements are returned in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The `nlargest` function from `heapq` will handle cases where n is greater than the length of the list or the list is empty by returning an empty list or the largest single element, respectively.\n", "requirement analysis:\nThe function should efficiently find the n largest numbers from a list, ensuring it handles various data sizes and types. The output should be sorted in descending order, which is a common requirement for such functions. The function should be robust and handle edge cases like empty lists or lists with non-numeric values.\nrequirement pool:\n- The main code should be optimized for performance\n- The function should handle lists of different sizes and types\n- The output should be sorted in descending order\n- The function should handle edge cases gracefully\n- The function should be easy to integrate and use\nTo create a function that efficiently finds the n largest numbers from a list and returns them sorted in descending order, we will utilize Python's built-in 'heapq' module. This module provides an efficient way to handle heap operations, which is crucial for performance. We will use the 'nlargest' function from 'heapq' to find the largest elements and then sort them manually to ensure the output is in descending order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'heapq module': This module provides an efficient way to handle heap operations, which is crucial for performance when dealing with large datasets.\n    'nlargest': This function from the 'heapq' module is used to find the n largest elements in an iterable.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    import heapq\n    def heap_queue_largest(lst, n):\n        if n <= 0:\n            return []\n        largest_n = heapq.nlargest(n, lst)\n        return sorted(largest_n, reverse=True)\n\n# [edge case] \n    heap_queue_largest([], 3) = []\n    Explanation: Since the list is empty, there are no numbers to find, so the expected output is an empty list.\n    heap_queue_largest([1, 2, 3], 4) = [3, 2, 1]\n    Explanation: We want to find 4 largest numbers, but there are only 3 in the list. The function will return all numbers in descending order.\n    heap_queue_largest([5, 5, 5, 5], 2) = [5, 5]\n    Explanation: All numbers are the same, so the 2 largest numbers are both 5, returned in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The function already handles cases where the list is empty or where n is greater than the length of the list by returning appropriate outputs.\n", "requirement analysis:\nThe function should efficiently find the n largest numbers from a list, ensuring it handles various data sizes and types. The output should be sorted in descending order for easy readability and interpretation. The function should be compatible with Python's standard library and be easy to integrate into existing projects.\nrequirement pool:\n- The main code should be optimized for performance\n- The function should handle lists of varying sizes and types\n- The output should be sorted in descending order\n- The function should be easy to integrate into other Python projects\n- The function should be documented and include examples of usage\nTo create a function that efficiently finds the n largest numbers from a given list and returns them sorted in descending order, we will utilize Python's built-in 'heapq' module. This module provides an efficient way to handle heap operations, which is crucial for performance. We will use the 'nlargest' function from 'heapq' to find the largest elements and then sort them manually to ensure the order is strictly descending.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'heapq module': This module provides an efficient way to handle heap operations, which is crucial for performance when dealing with large datasets.\n    'nlargest': This function from 'heapq' is used to find the largest elements in a list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    import heapq\n\n    def heap_queue_largest(numbers, n):\n        if n <= 0:\n            return []\n        largest_numbers = heapq.nlargest(n, numbers)\n        return sorted(largest_numbers, reverse=True)\n\n# [edge case] \n    heap_queue_largest([], 3) = []\n    Explanation: Since the list is empty, there are no numbers to find, so the expected output is an empty list.\n    heap_queue_largest([1, 2, 3], 0) = []\n    Explanation: Since n is 0, we are asked to find 0 largest numbers, which is not possible. The expected output is an empty list.\n    heap_queue_largest([5, 5, 5, 5], 5) = [5, 5, 5, 5]\n    Explanation: Since n is equal to the length of the list, we are asked to find all the numbers, and they are all the same. The expected output is the list itself, sorted in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic already covers cases where the list is empty or n is 0.\n", "requirement analysis:\nThe requirement is to create a function that can find the n largest numbers from a given list and return them in descending order. This is a common task in data processing and should be efficiently implemented. The function should be able to handle various sizes of lists and provide a good user experience.\nrequirement pool:\n- The main code should be efficient and use Python's built-in functions where possible.\n- The function should be able to handle large datasets efficiently.\n- The user interface should be simple and intuitive.\n- The function should return results in descending order.\n- The product should be tested for various edge cases.\nTo create an efficient and user-friendly function for finding the n largest numbers from a given list, we will utilize Python's built-in 'heapq' library, which provides efficient heap queue algorithms. This approach ensures that the function is scalable and can handle large datasets efficiently. The function will use a max heap to find the largest numbers, which is a common and effective method for such tasks. The results will be returned in descending order, providing a straightforward and intuitive user experience.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'heap queue'\n    In the context of this requirement, 'heap queue' refers to the use of a heap data structure to efficiently find the largest elements in a collection.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the function `heap_queue_largest`, we will follow these steps:\n    1. Import the `nlargest` function from the `heapq` module.\n    2. Use the `nlargest` function to find the n largest elements in the given list.\n    3. Return the n largest elements in descending order.\n\n# [edge case] \n    heap_queue_largest([1], 1) = [1]\n    Explanation: Since the list contains only one element, the largest element is the element itself.\n    heap_queue_largest([], 3) = []\n    Explanation: An empty list should return an empty list, as there are no elements to find.\n    heap_queue_largest([1, 2, 3, 4, 5], 10) = [5, 4, 3, 2, 1]\n    Explanation: The list contains fewer elements than requested, so we return all elements in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The `nlargest` function in the `heapq` module already handles cases where n is greater than the length of the list or the list is empty.\n"], "test": ["def check(heap_queue_largest):\n\tassert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65] ", "def check(heap_queue_largest):\n\tassert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],2)==[85, 75] ", "def check(heap_queue_largest):\n\tassert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],5)==[85, 75, 65, 58, 35]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 39, 20, 87, 19, 64, 72, 27, 61], 4) == [87, 72, 64, 61]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 39, 18, 83, 14, 65, 71, 20, 62], 1) == [83]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([28, 34, 25, 89, 12, 66, 77, 27, 56], 5) == [89, 77, 66, 56, 34]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([21, 36, 22, 84, 13, 67, 78, 25, 54], 3) == [84, 78, 67]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([28, 38, 20, 85, 11, 68, 72, 18, 59], 6) == [85, 72, 68, 59, 38, 28]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([26, 30, 20, 81, 9, 61, 73, 19, 53], 6) == [81, 73, 61, 53, 30, 26]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([25, 32, 23, 86, 14, 60, 73, 23, 54], 6) == [86, 73, 60, 54, 32, 25]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([22, 33, 22, 80, 19, 64, 77, 24, 53], 3) == [80, 77, 64]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([28, 39, 25, 84, 17, 61, 77, 19, 53], 5) == [84, 77, 61, 53, 39]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 38, 17, 89, 18, 62, 80, 23, 60], 7) == [89, 80, 62, 60, 38, 30, 23]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([27, 40, 27, 86, 16, 66, 79, 24, 59], 7) == [86, 79, 66, 59, 40, 27, 27]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 36, 27, 81, 19, 66, 78, 23, 59], 8) == [81, 78, 66, 59, 36, 30, 27, 23]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 37, 20, 83, 18, 61, 75, 21, 55], 8) == [83, 75, 61, 55, 37, 23, 21, 20]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 36, 17, 83, 13, 65, 78, 23, 59], 5) == [83, 78, 65, 59, 36]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([27, 31, 23, 85, 10, 67, 77, 21, 57], 5) == [85, 77, 67, 57, 31]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([25, 39, 22, 83, 15, 68, 75, 25, 53], 3) == [83, 75, 68]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 37, 22, 85, 11, 68, 77, 19, 62], 8) == [85, 77, 68, 62, 37, 30, 22, 19]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([22, 31, 24, 89, 9, 63, 70, 27, 57], 5) == [89, 70, 63, 57, 31]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([24, 40, 26, 88, 16, 68, 79, 20, 63], 4) == [88, 79, 68, 63]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([22, 40, 23, 89, 15, 65, 74, 20, 62], 5) == [89, 74, 65, 62, 40]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 31, 21, 90, 14, 63, 78, 22, 59], 2) == [90, 78]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 30, 20, 85, 19, 69, 73, 18, 55], 8) == [85, 73, 69, 55, 30, 23, 20, 19]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([20, 37, 21, 81, 11, 64, 79, 17, 59], 3) == [81, 79, 64]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([25, 40, 21, 84, 11, 68, 71, 27, 56], 4) == [84, 71, 68, 56]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([25, 31, 19, 90, 15, 64, 79, 26, 57], 1) == [90]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([21, 31, 17, 80, 19, 69, 77, 27, 63], 1) == [80]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 36, 20, 87, 12, 69, 80, 27, 60], 4) == [87, 80, 69, 60]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([28, 30, 22, 80, 12, 60, 70, 27, 58], 7) == [80, 70, 60, 58, 30, 28, 27]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 30, 26, 87, 12, 66, 78, 19, 55], 4) == [87, 78, 66, 55]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([26, 39, 21, 82, 12, 60, 78, 24, 57], 7) == [82, 78, 60, 57, 39, 26, 24]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([24, 34, 23, 87, 14, 61, 70, 19, 55], 7) == [87, 70, 61, 55, 34, 24, 23]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 35, 21, 86, 14, 63, 76, 21, 54], 7) == [86, 76, 63, 54, 35, 30, 21]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 30, 25, 80, 15, 66, 72, 21, 63], 3) == [80, 72, 66]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 32, 23, 88, 12, 65, 70, 26, 60], 3) == [88, 70, 65]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 37, 19, 85, 11, 67, 73, 23, 62], 3) == [85, 73, 67]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([28, 38, 22, 88, 19, 68, 70, 18, 61], 2) == [88, 70]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 32, 25, 89, 11, 67, 74, 25, 54], 7) == [89, 74, 67, 54, 32, 30, 25]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 35, 24, 89, 15, 69, 70, 24, 60], 2) == [89, 70]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([21, 36, 24, 84, 10, 61, 71, 24, 63], 7) == [84, 71, 63, 61, 36, 24, 24]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 39, 27, 84, 13, 67, 71, 20, 62], 1) == [84]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([21, 36, 27, 85, 10, 65, 79, 21, 54], 2) == [85, 79]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 40, 19, 84, 16, 68, 80, 27, 63], 3) == [84, 80, 68]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([22, 40, 17, 80, 11, 60, 76, 19, 53], 6) == [80, 76, 60, 53, 40, 22]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 40, 19, 87, 17, 70, 77, 24, 55], 1) == [87]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 36, 19, 87, 12, 62, 74, 17, 62], 1) == [87]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([26, 33, 21, 86, 13, 64, 74, 19, 58], 4) == [86, 74, 64, 58]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 33, 22, 90, 11, 69, 76, 25, 54], 5) == [90, 76, 69, 54, 33]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([26, 37, 23, 83, 11, 63, 70, 22, 53], 3) == [83, 70, 63]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 30, 20, 87, 18, 62, 72, 19, 62], 1) == [87]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([28, 38, 25, 87, 18, 62, 78, 24, 63], 5) == [87, 78, 63, 62, 38]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 40, 27, 82, 9, 66, 80, 23, 55], 1) == [82]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 40, 18, 83, 13, 61, 75, 24, 55], 5) == [83, 75, 61, 55, 40]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([28, 39, 26, 81, 15, 67, 80, 27, 60], 7) == [81, 80, 67, 60, 39, 28, 27]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([22, 40, 23, 86, 15, 70, 78, 27, 63], 1) == [86]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([24, 40, 18, 84, 19, 61, 71, 25, 62], 2) == [84, 71]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([21, 30, 20, 87, 19, 61, 71, 26, 53], 7) == [87, 71, 61, 53, 30, 26, 21]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 40, 20, 90, 9, 70, 77, 21, 62], 2) == [90, 77]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([22, 33, 18, 81, 12, 67, 71, 25, 58], 6) == [81, 71, 67, 58, 33, 25]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([21, 36, 24, 86, 13, 66, 79, 21, 56], 2) == [86, 79]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 34, 17, 85, 9, 60, 74, 25, 63], 4) == [85, 74, 63, 60]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 37, 22, 90, 19, 67, 72, 19, 60], 7) == [90, 72, 67, 60, 37, 29, 22]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([25, 36, 21, 86, 12, 66, 78, 26, 54], 1) == [86]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([24, 33, 27, 82, 10, 60, 76, 26, 55], 2) == [82, 76]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([27, 34, 23, 83, 18, 65, 80, 25, 58], 6) == [83, 80, 65, 58, 34, 27]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 40, 19, 85, 11, 62, 73, 25, 53], 4) == [85, 73, 62, 53]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([20, 32, 17, 89, 10, 62, 77, 21, 53], 7) == [89, 77, 62, 53, 32, 21, 20]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 31, 17, 80, 13, 64, 72, 17, 55], 2) == [80, 72]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([25, 40, 17, 83, 11, 69, 77, 26, 61], 3) == [83, 77, 69]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([22, 39, 17, 89, 16, 65, 70, 23, 60], 6) == [89, 70, 65, 60, 39, 23]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 40, 20, 80, 12, 69, 75, 27, 58], 7) == [80, 75, 69, 58, 40, 30, 27]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 33, 19, 90, 13, 67, 70, 17, 59], 1) == [90]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 38, 27, 86, 15, 63, 80, 23, 63], 9) == [86, 80, 63, 63, 38, 29, 27, 23, 15]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 38, 24, 84, 13, 68, 75, 23, 61], 3) == [84, 75, 68]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([22, 35, 18, 84, 12, 70, 76, 19, 60], 2) == [84, 76]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([20, 35, 20, 86, 14, 63, 80, 22, 56], 4) == [86, 80, 63, 56]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 32, 18, 87, 15, 65, 70, 26, 59], 9) == [87, 70, 65, 59, 32, 29, 26, 18, 15]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 40, 24, 81, 10, 64, 71, 23, 55], 8) == [81, 71, 64, 55, 40, 30, 24, 23]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 33, 20, 87, 10, 61, 80, 21, 57], 10) == [87, 80, 61, 57, 33, 29, 21, 20, 10]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([28, 31, 27, 88, 9, 70, 79, 25, 59], 8) == [88, 79, 70, 59, 31, 28, 27, 25]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 39, 20, 84, 15, 65, 72, 21, 63], 5) == [84, 72, 65, 63, 39]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([20, 37, 17, 86, 13, 67, 80, 24, 63], 5) == [86, 80, 67, 63, 37]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([21, 37, 17, 83, 18, 65, 74, 20, 61], 4) == [83, 74, 65, 61]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 38, 26, 82, 10, 67, 79, 25, 55], 10) == [82, 79, 67, 55, 38, 30, 26, 25, 10]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([24, 39, 24, 83, 11, 62, 71, 17, 59], 9) == [83, 71, 62, 59, 39, 24, 24, 17, 11]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([28, 30, 20, 80, 17, 66, 78, 25, 62], 10) == [80, 78, 66, 62, 30, 28, 25, 20, 17]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([24, 40, 26, 89, 17, 62, 70, 24, 61], 5) == [89, 70, 62, 61, 40]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([20, 34, 26, 87, 18, 68, 76, 21, 61], 10) == [87, 76, 68, 61, 34, 26, 21, 20, 18]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([26, 31, 19, 80, 19, 70, 78, 21, 58], 4) == [80, 78, 70, 58]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 30, 18, 82, 16, 67, 73, 22, 53], 1) == [82]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 37, 20, 83, 19, 69, 77, 19, 60], 5) == [83, 77, 69, 60, 37]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([29, 31, 17, 81, 13, 67, 77, 21, 62], 4) == [81, 77, 67, 62]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 32, 20, 89, 11, 62, 78, 27, 54], 1) == [89]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([25, 35, 17, 89, 15, 67, 71, 22, 56], 8) == [89, 71, 67, 56, 35, 25, 22, 17]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([27, 33, 24, 88, 19, 62, 73, 25, 61], 7) == [88, 73, 62, 61, 33, 27, 25]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([30, 38, 25, 89, 11, 68, 72, 21, 56], 9) == [89, 72, 68, 56, 38, 30, 25, 21, 11]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([20, 36, 17, 82, 15, 61, 78, 17, 55], 4) == [82, 78, 61, 55]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([27, 33, 23, 85, 11, 62, 73, 26, 61], 7) == [85, 73, 62, 61, 33, 27, 26]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([26, 40, 22, 84, 16, 65, 77, 17, 57], 8) == [84, 77, 65, 57, 40, 26, 22, 17]", "def check(heap_queue_largest):\n\tassert heap_queue_largest([23, 33, 24, 84, 17, 70, 79, 21, 53], 5) == [84, 79, 70, 53, 33]"], "scores": [0.1275, 1.0, 1.0, 0.1275, 1.0, 1.0, 1.0, 1.0, 1.0, 0.1275], "pass_results": [false, true, true, false, true, true, true, true, true, false], "pass_test_cases_num": [13, 102, 102, 13, 102, 102, 102, 102, 102, 13], "completion": "from typing import List\nimport heapq\n\ndef heap_queue_largest(numbers: list[int], n: int) -> list[int]:\n    if n <= 0:\n        return []\n    largest_numbers = heapq.nlargest(n, numbers)\n    return sorted(largest_numbers, reverse=True)\n", "passed": true, "pass": true, "pass_num": 7, "round": 978, "mutate_method": "rephrase_one", "parent_index": 295}
