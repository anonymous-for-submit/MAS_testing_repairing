{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "prompt": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon. Determine how Monocarp can achieve slaying the dragon efficiently.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "repair_prompt": ["Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon. Determine how Monocarp can achieve slaying the dragon efficiently.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].\nWrite a main() function and use input() function to read input from stdin", " Monocarp is engaged in a\u6fc0\u70c8\u7684\u7535\u5b50\u6e38\u620f\u6218\u6597\uff0c\u4ed6\u7684\u89d2\u8272\u9700\u8981\u6740\u6b7b\u4e00\u6761\u9f99\u3002\u8fd9\u573a\u4e0e\u9f99\u7684\u6218\u6597\u6301\u7eed\u4e86100^{500}\u79d2\uff0cMonocarp \u7528\u4e00\u628a\u5e26\u6bd2\u7684\u5315\u9996\u8fdb\u884c\u653b\u51fb\u3002\u6bcf\u6b21\u653b\u51fb\u5728\u6218\u6597\u5f00\u59cb\u540e\u7684 a_i \u79d2\u8fdb\u884c\u3002\u6bd2\u5315\u9996\u672c\u8eab\u4e0d\u9020\u6210\u4f24\u5bb3\uff0c\u4f46\u5b83\u4f1a\u5728\u9f99\u88ab\u523a\u4e2d\u65f6\u65bd\u52a0\u6bd2\u6548\u679c\uff0c\u6301\u7eed k \u79d2\uff0c\u671f\u95f4\u6bcf\u79d2\u9020\u6210 1 \u70b9\u4f24\u5bb3\u3002\u5982\u679c\u9f99\u5df2\u7ecf\u88ab\u6bd2\u6548\u679c\u5f71\u54cd\uff0c\u90a3\u4e48\u6bd2\u6548\u679c\u4f1a\u88ab\u66f4\u65b0\uff0c\u8986\u76d6\u4e4b\u524d\u7684\u6bd2\u6548\u679c\u3002\n\n\u4f8b\u5982\uff0c\u5047\u8bbe k = 4\uff0cMon\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].\nWrite a main() function and use input() function to read input from stdin", " Monocarp needs to determine the minimum value of k such that his poisoned dagger deals at least h damage to the dragon within the 100^{500}-second battle, given that he attacks the dragon at the beginning of the a_i-th second, and the poison effect deals 1 damage during each of the next k seconds starting with the same second.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef find_min_k(attacks: List[int], h: int) -> int:\n    attacks.sort()\n    \n    def total_damage(k: int) -> int:\n        damage = 0\n        time = 0\n        i = 0\n        while i < len(attacks):\n            if time < attacks[i]:\n                damage += 1\n                time += k\n            else:\n                i += 1\n        return damage\n    \n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if total_damage(mid) < h:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Provide input interface using input(), DO NOT use stdin\nn = int(input())\nfor _ in range(n):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n\n# Provide output interface using print()\nfor _ in range(n):\n    result = find_min_k(attacks, h)\n    print(result)\n", "from typing import List\ndef find_min_k(attacks, h):\n    \"\"\"\n    Finds the minimum value of k such that the total damage dealt by Monocarp's attacks is at least h.\n    \n    Args:\n        attacks (list of int): List of attack times in seconds.\n        h (int): The required damage the dragon must be dealt.\n    \n    Returns:\n        int: The minimum value of k.\n    \"\"\"\n    def calculate_damage(k):\n        \"\"\"\n        Calculates the total damage dealt by Monocarp's attacks for a given value of k.\n        \n        Args:\n            k (int): The duration of the poison effect in seconds.\n        \n        Returns:\n            int: The total damage dealt.\n        \"\"\"\n        damage = 0\n        last_attack_time = 0\n        for attack_time in attacks:\n            if attack_time > last_attack_time:\n                damage += (min(k, attack_time - last_attack_time))\n                last_attack_time = attack_time\n        return damage\n\n    left, right = 1, 10**9\n    while left < right:\n        mid = (left + right) // 2\n        if calculate_damage(mid) < h:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Read input and output results\nt = int(input())\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(attacks, h)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_k(attacks: List[int], h: int) -> int:\n    def can_deal_damage(k: int) -> bool:\n        total_damage = 0\n        last_poison_end = 0\n        \n        for attack_time in attacks:\n            if attack_time > last_poison_end:\n                total_damage += k\n                last_poison_end = attack_time + k - 1\n            else:\n                total_damage += k - (last_poison_end - attack_time + 1)\n                last_poison_end = attack_time + k - 1\n            \n            if total_damage >= h:\n                return True\n        \n        return total_damage >= h\n    \n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if can_deal_damage(mid):\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Provide input interface using input(), DO NOT use stdin\nn = int(input())\nfor _ in range(n):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n\n# Provide output interface using print()\nfor _ in range(n):\n    result = find_min_k(attacks, h)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_k(n: int, h: int, attacks: List[int]) -> int:\n    def can_deal_damage(k: int) -> bool:\n        total_damage = 0\n        last_attack_time = 0\n        for attack_time in attacks:\n            if attack_time - last_attack_time <= k:\n                total_damage += attack_time - last_attack_time\n            else:\n                total_damage += k\n            last_attack_time = attack_time\n        return total_damage >= h\n\n    # Edge case: if the difference between the first two attack times is greater than h, Monocarp can only cause damage in bursts of 1 second.\n    if attacks[1] - attacks[0] > h:\n        return 1\n\n    # Binary search to find the minimum k\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if can_deal_damage(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(n, h, attacks)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_k(n: int, h: int, attacks: List[int]) -> int:\n    def can_deal_damage(k: int) -> bool:\n        damage = 0\n        last_effect_end = 0\n        for attack_time in attacks:\n            if attack_time > last_effect_end:\n                damage += k\n                last_effect_end = attack_time + k - 1\n            else:\n                damage += k - (last_effect_end - attack_time + 1)\n                last_effect_end = attack_time + k - 1\n        return damage >= h\n\n    # Binary search to find the minimum k\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        if can_deal_damage(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(n, h, attacks)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_k(n: int, h: int, attacks: List[int]) -> int:\n    def can_achieve_damage(k: int) -> bool:\n        total_damage = 0\n        last_attack_time = 0\n        for attack_time in attacks:\n            if attack_time - last_attack_time <= k:\n                total_damage += attack_time - last_attack_time\n            else:\n                total_damage += k\n            last_attack_time = attack_time\n        total_damage += k\n        return total_damage >= h\n\n    if h == 0:\n        return 1\n\n    left, right = 1, max(attacks)\n    while left < right:\n        mid = (left + right) // 2\n        if can_achieve_damage(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Read input\nn = int(input())\nfor _ in range(n):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(n, h, attacks)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_k(attacks: List[int], h: int) -> int:\n    def can_deal_damage(k: int) -> bool:\n        total_damage = 0\n        for i in range(len(attacks) - 1):\n            damage_dealt = attacks[i + 1] - attacks[i]\n            if k >= damage_dealt:\n                total_damage += damage_dealt\n            else:\n                total_damage += k\n        total_damage += k\n        return total_damage >= h\n\n    left, right = 1, 10**18\n    result = -1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_deal_damage(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return result\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(attacks, h)\n    print(result)\n", "from typing import List\n## main.py\n\ndef find_min_k(attacks, h):\n    \"\"\"\n    This function uses binary search to find the minimum value of k such that the total damage dealt by Monocarp's attacks,\n    considering the poison effect, is at least h.\n    \n    Args:\n        attacks (list of int): A list of integers representing the seconds when Monocarp attacks.\n        h (int): The total damage required to be dealt.\n    \n    Returns:\n        int: The minimum value of k such that the total damage is at least h.\n    \"\"\"\n    left, right = 1, 10**18  # Set initial bounds for binary search\n    \n    def can_deal_damage(k):\n        \"\"\"\n        Helper function to check if Monocarp can deal at least h damage with a given k.\n        \n        Args:\n            k (int): The number of seconds the poison effect lasts.\n        \n        Returns:\n            bool: True if Monocarp can deal at least h damage, False otherwise.\n        \"\"\"\n        total_damage = 0\n        last_attack_time = 0\n        \n        for attack_time in attacks:\n            poison_damage = min(k, attack_time - last_attack_time)\n            total_damage += poison_damage\n            last_attack_time = attack_time\n        \n        return total_damage >= h\n    \n    # Binary search to find the minimum k\n    while left < right:\n        mid = (left + right) // 2\n        if can_deal_damage(mid):\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Read input and process each test case\nt = int(input().strip())\nfor _ in range(t):\n    n, h = map(int, input().strip().split())\n    attacks = list(map(int, input().strip().split()))\n    result = find_min_k(attacks, h)\n    print(result)\n", "from typing import List\n## main.py\n\nimport bisect\n\ndef find_min_k(attacks, h):\n    \"\"\"\n    Finds the minimum value of k such that Monocarp's poisoned dagger deals at least h damage to the dragon.\n    \n    Args:\n        attacks (list of int): List of attack times.\n        h (int): Required damage.\n    \n    Returns:\n        int: Minimum value of k.\n    \"\"\"\n    attacks.sort()\n    n = len(attacks)\n    \n    def total_damage(k):\n        \"\"\"\n        Calculates the total damage dealt by Monocarp's poisoned dagger for a given k.\n        \n        Args:\n            k (int): Number of seconds the poison effect lasts.\n        \n        Returns:\n            int: Total damage dealt.\n        \"\"\"\n        damage = 0\n        prev_time = 0\n        for i in range(n):\n            next_time = attacks[i]\n            duration = next_time - prev_time\n            poison_damage = (k + 1) * duration - k\n            damage += poison_damage\n            prev_time = next_time\n        return damage\n    \n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if total_damage(mid) < h:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Input interface\nt = int(input())\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(attacks, h)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_k(attacks: List[int], h: int) -> int:\n    # Sort the list of attack times\n    attacks.sort()\n    \n    # Define a function to calculate the total damage for a given k\n    def total_damage(k: int) -> int:\n        damage = 0\n        n = len(attacks)\n        for i in range(n - 1):\n            damage += min(k, attacks[i + 1] - attacks[i])\n        damage += k  # Add the damage from the last attack\n        return damage\n    \n    # Use binary search to find the minimum k such that the total damage is at least h\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if total_damage(mid) < h:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(attacks, h)\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirements specify the need for a game where the player must determine the minimum poison effect duration to deal a specified amount of damage to a dragon. The game involves timing attacks to maximize the poison effect. The challenge lies in calculating the minimum k such that the total damage dealt is at least h. The input consists of multiple test cases, each with a different number of attacks and required damage.\nrequirement pool:\n- Implement a function to calculate the minimum k for each test case.\n- Ensure the game interface is user-friendly and responsive.\n- Develop a scoring system to track player progress.\n- Include difficulty settings to cater to different skill levels.\n- Add a restart feature to allow players to retry after a loss.\nTo solve this problem, we will use a binary search approach to find the minimum value of k. The binary search will help us efficiently determine the smallest k that ensures Monocarp deals at least h damage to the dragon. We will sort the attack times and then use a function to calculate the total damage dealt by the poison effect for a given k. This approach will ensure we efficiently find the minimum k without having to manually check each possible value of k.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a technique used to find the minimum value of k efficiently by repeatedly dividing the search interval in half.\n    'poison effect': The dagger applies a poison effect that deals 1 damage during each of the next k seconds, starting with the same second when the dragon was stabbed by the dagger.\n\n# [phrase showing quantity relationship]\n    'at least': Indicates that the total damage dealt must be at least h.\n\n# [degree adverb] \n    'minimum possible': The goal is to find the smallest value of k that ensures at least h damage is dealt.\n\n# [code logic]\n    To implement the solution, we will:\n    1. Sort the attack times.\n    2. Use binary search to find the minimum k.\n    3. For each potential k, calculate the total damage dealt by the poison effect.\n    4. Return the minimum k that ensures at least h damage is dealt.\n\n# [edge case] \n    test_cases = 1\n    n = 3\n    h = 10\n    attacks = [1, 2, 3]\n    expected_output = 4\n    Explanation:\n    The attacks are at seconds 1, 2, and 3. For k = 4, the poison effect would be applied at the start of the 1st second and deal damage during the 1st, 2nd, 3rd, and 4th seconds. This would deal 4 damage, which is enough to slay the dragon.\n\n# [extra code for edge case]\n    We do not need extra code to handle this edge case as the binary search approach inherently handles cases where the solution is found within the given range.\n", "requirement analysis:\nThe problem requires finding the minimum value of k such that Monocarp's attacks with the poisoned dagger deal at least h damage to the dragon. The attacks are given at specific times, and the poison effect lasts for k seconds. The poison effect can be updated at each attack, and the damage is cumulative. The solution needs to consider the timing of attacks and the duration of the poison effect to determine the minimum k.\nrequirement pool:\n- Implement a function to calculate the minimum k required to deal at least h damage.\n- Ensure the solution is efficient enough to handle up to 1000 test cases.\n- Optimize the algorithm to minimize the number of calculations for each test case.\nTo solve this problem, we will use a binary search approach to find the minimum value of k. This approach will be efficient and suitable for handling the large number of test cases specified in the problem. We will calculate the total damage dealt by Monocarp's attacks based on a given value of k and use binary search to find the minimum k that ensures the dragon is dealt at least h damage.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a technique used to find the minimum value of k efficiently by repeatedly dividing the search interval in half.\n    'damage calculation': This involves summing up the damage dealt by each attack considering the poison effect duration k.\n\n# [phrase showing quantity relationship]\n    'at least': This indicates that the required damage must be met or exceeded.\n\n# [degree adverb] \n    'minimum possible': This suggests that we need to find the smallest value of k that still meets the requirement.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. For each test case, read the number of attacks (n) and the required damage (h).\n    2. Read the attack times (a_i) into a list.\n    3. Use binary search to find the minimum k:\n        - Initialize a search range from 1 to 10^9.\n        - In each iteration, calculate the total damage for the midpoint value of k.\n        - Adjust the search range based on whether the total damage is sufficient or insufficient.\n    4. Output the minimum k found for each test case.\n\n# [edge case]\n    test_cases = 1\n    n = 3\n    h = 10\n    attacks = [1, 2, 3]\n    edge_case1 = (test_cases, n, h, attacks)\n    expected_output1 = 3\n    Explanation: The minimum k that ensures at least 10 damage is 3, as the poison effect will apply at the start of the 1st, 2nd, and 3rd seconds, dealing 1 damage each during the following 3 seconds.\n\n# [extra code for edge case]\n    No extra code is needed for this edge case as the binary search approach inherently handles the scenario where the attacks are sequential and the poison effect perfectly overlaps.\n", "requirement analysis:\nThe requirements for this project are clear and focused on creating a game where the player has to strategically attack a dragon to deal damage over time. The game should be engaging, accessible, and visually appealing. The competitive analysis shows that there is a market for games with similar features, but there is also room for improvement in terms of user interface and accessibility.\nrequirement pool:\n- The main code should handle the game logic, including attack scheduling and poison effect application.\n- The game should allow players to choose difficulty levels.\n- The UI should be clean and visually appealing, with a focus on responsiveness.\n- The game should track and display player scores.\n- The game should provide a restart button after a loss.\nTo tackle the problem of determining the minimum value of k such that Monocarp can deal at least h damage to the dragon, we can approach this by simulating the poison effects and calculating the total damage dealt. Given the constraints, we can use a binary search approach to efficiently find the minimum k. This approach will involve simulating the attacks and updating the poison effects to find the smallest k that ensures the dragon is dealt at least h damage.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'poison effect': The effect of the dagger that deals damage over a period of k seconds starting from the second it is applied.\n    Explanation: Monocarp's character uses a poisoned dagger to deal damage to the dragon over a certain number of seconds (k). The poison deals 1 damage each second during the k-second period, and if the dragon is already poisoned, the effect is updated.\n\n# [phrase showing quantity relationship]\n    'at least as many times': means the number of times the poison effect is applied should be at least the value of k.\n\n# [degree adverb] \n    'minimum possible value': We need to find the smallest k that ensures the dragon is dealt at least h damage.\n\n# [code logic]\n    To implement the solution, we can use a binary search approach to find the minimum k. We will simulate the attacks and update the poison effects to calculate the total damage. The binary search will help in efficiently finding the minimum k.\n\n# [edge case] \n    Monocarp attacks at the start of the seconds [1, 2, 3, ..., n].\n    Expected output: n\n    Explanation: If Monocarp attacks at every second from 1 to n, the poison effect will be applied every second, and the total damage will be n, which is the minimum k needed to deal at least h damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle this edge case, as the logic provided in the plan can handle it directly. The binary search will naturally find the correct minimum k for this scenario.\n", "requirement analysis:\nThe problem requires finding the minimum value of k such that the total damage caused by Monocarp's attacks, with the given attack times and the duration of the poison effect, is at least h. This involves determining the intervals between attacks and ensuring that the poison effect overlaps with these intervals to cause the required damage.\nrequirement pool:\n- The main code must calculate the minimum k for each test case.\n- The code must handle large inputs efficiently.\n- Ensure the output format matches the given example.\n- The code must be able to handle up to 1000 test cases.\n- Implement a binary search approach to find the minimum k efficiently.\nTo solve this problem, we will use a binary search approach to efficiently find the minimum value of k for each test case. The binary search will help us narrow down the possible values of k by leveraging the fact that the damage caused by the poison effect increases monotonically with k. We will iterate over possible values of k, checking if the total damage caused by Monocarp's attacks with the given poison effect duration is sufficient to deal at least h damage to the dragon.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a technique used to find the minimum or maximum value that satisfies a certain condition. It works by repeatedly dividing the search interval in half and checking the condition at the midpoint.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the value we are looking for must be greater than a certain threshold.\n\n# [degree adverb] \n    'minimum': Indicates that we are looking for the smallest value that satisfies the condition.\n\n# [code logic]\n    To implement the solution, we will use a binary search to find the minimum value of k. The binary search will be performed over a range of possible values for k, starting from 1 to a large number that is guaranteed to be greater than any possible value of k. For each midpoint in the binary search, we will check if the total damage caused by Monocarp's attacks with the given poison effect duration is sufficient to deal at least h damage to the dragon.\n\n# [edge case] \n    search([1, 2, 4, 5, 7], 3) = 1\n    Explanation: The attacks are at seconds [1, 2, 4, 5, 7]. For k=1, the poison effect will cover the attacks, causing damage in seconds [1, 2, 4, 5, 7]. The total damage is 3, which is less than h=3.\n    search([1, 2, 4, 5, 7], 10) = 4\n    Explanation: The attacks are at seconds [1, 2, 4, 5, 7]. For k=4, the poison effect will cover the attacks, causing damage in seconds [1, 2, 4, 5, 7]. The total damage is 4, which is less than h=10.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the attacks are so close together that no matter the value of k, the total damage will not be sufficient. This can be checked by verifying if the difference between the first two attack times is greater than h. If so, the answer is 1, as Monocarp can only cause damage in bursts of 1 second.\n        if a[1] - a[0] > h:\n            return 1\n        (other code)\n", "requirement analysis:\nThe problem requires finding the minimum value of k such that the total damage caused by Monocarp's attacks with a poison effect lasting k seconds exceeds or equals the required damage h. This involves calculating the intervals between attacks and determining the minimum k that covers the total required damage.\nrequirement pool:\n- The main code should calculate the minimum k for each test case.\n- The game algorithm should handle the attack timings and poison effect durations.\nTo solve this problem, we need to determine the minimum value of k such that the total damage caused by Monocarp's attacks with a poison effect lasting k seconds exceeds or equals the required damage h. This involves calculating the intervals between attacks and determining the minimum k that covers the total required damage. We will use a binary search approach to efficiently find the minimum k.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    '\u6bd2\u6548\u679c': \u6bcf\u6b21\u653b\u51fb\u5728\u6218\u6597\u5f00\u59cb\u540e\u7684 a_i \u79d2\u8fdb\u884c\uff0c\u6bd2\u5315\u9996\u672c\u8eab\u4e0d\u9020\u6210\u4f24\u5bb3\uff0c\u4f46\u5b83\u4f1a\u5728\u9f99\u88ab\u523a\u4e2d\u65f6\u65bd\u52a0\u6bd2\u6548\u679c\uff0c\u6301\u7eed k \u79d2\uff0c\u671f\u95f4\u6bcf\u79d2\u9020\u6210 1 \u70b9\u4f24\u5bb3\u3002\u5982\u679c\u9f99\u5df2\u7ecf\u88ab\u6bd2\u6548\u679c\u5f71\u54cd\uff0c\u90a3\u4e48\u6bd2\u6548\u679c\u4f1a\u88ab\u66f4\u65b0\uff0c\u8986\u76d6\u4e4b\u524d\u7684\u6bd2\u6548\u679c\u3002\n\n    Explanation: \u6bd2\u6548\u679c\u662f\u6307\u5728\u7279\u5b9a\u65f6\u95f4\u70b9\u5bf9\u9f99\u8fdb\u884c\u653b\u51fb\uff0c\u4f7f\u5f97\u9f99\u5728\u63a5\u4e0b\u6765\u7684 k \u79d2\u5185\u6bcf\u79d2\u53d7\u5230 1 \u70b9\u4f24\u5bb3\u3002\u6211\u4eec\u9700\u8981\u627e\u5230\u6700\u5c0f\u7684 k\uff0c\u4f7f\u5f97\u603b\u4f24\u5bb3\u8fbe\u5230\u6216\u8d85\u8fc7 h\u3002\n\n# [phrase showing quantity relationship]\n    'more than': \u8868\u793a\u9700\u8981\u8d85\u8fc7\u67d0\u4e2a\u6570\u91cf\u6216\u503c\u3002\n    'at least as many times': \u8868\u793a\u81f3\u5c11\u8fbe\u5230\u67d0\u4e2a\u6570\u91cf\u6216\u503c\u3002\n\n# [degree adverb] \n    '\u6fc0\u70c8': \u8868\u793a\u6218\u6597\u975e\u5e38\u6fc0\u70c8\uff0c\u53ef\u80fd\u610f\u5473\u7740\u653b\u51fb\u9891\u7387\u5f88\u9ad8\u6216\u4f24\u5bb3\u503c\u5f88\u5927\u3002\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the intervals between attacks.\n    2. Determine the minimum k that covers the total required damage using binary search.\n    3. Sum the damage caused by each attack considering the poison effect duration k.\n\n# [edge case] \n    Edge case 1: Monocarp \u7684\u653b\u51fb\u65f6\u95f4\u70b9\u5b8c\u5168\u8986\u76d6\u4e86\u6240\u9700\u7684\u6bd2\u6548\u679c\u65f6\u95f4\u3002\n    search([1, 2, 3, 4, 5], 5, 5) = 1\n    Explanation: \u7531\u4e8e\u653b\u51fb\u65f6\u95f4\u70b9\u5b8c\u5168\u8986\u76d6\u4e86 5 \u79d2\u7684\u6bd2\u6548\u679c\u65f6\u95f4\uff0c\u56e0\u6b64 k \u81f3\u5c11\u4e3a 1\u3002\n\n    Edge case 2: Monocarp \u7684\u653b\u51fb\u65f6\u95f4\u70b9\u65e0\u6cd5\u8986\u76d6\u6240\u9700\u7684\u6bd2\u6548\u679c\u65f6\u95f4\u3002\n    search([1, 3, 5], 7, 5) = 3\n    Explanation: \u653b\u51fb\u65f6\u95f4\u70b9\u4e3a 1, 3, 5 \u79d2\uff0c\u65e0\u6cd5\u5728 2 \u79d2\u5185\u8986\u76d6 7 \u79d2\u7684\u6bd2\u6548\u679c\u65f6\u95f4\uff0c\u56e0\u6b64 k \u81f3\u5c11\u4e3a 3\u3002\n\n    Edge case 3: Monocarp \u7684\u653b\u51fb\u65f6\u95f4\u70b9\u975e\u5e38\u5206\u6563\uff0c\u65e0\u6cd5\u5728\u77ed\u65f6\u95f4\u5185\u8986\u76d6\u6240\u9700\u7684\u6bd2\u6548\u679c\u65f6\u95f4\u3002\n    search([1, 100, 200], 1000, 5) = 100\n    Explanation: \u653b\u51fb\u65f6\u95f4\u70b9\u975e\u5e38\u5206\u6563\uff0c\u65e0\u6cd5\u5728\u77ed\u65f6\u95f4\u5185\u8986\u76d6 1000 \u79d2\u7684\u6bd2\u6548\u679c\u65f6\u95f4\uff0c\u56e0\u6b64 k \u81f3\u5c11\u4e3a 100\u3002\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the attack times are very spread out and cannot cover the required damage within a reasonable k value.\n    Example code:\n    if max(attacks) - min(attacks) + 1 < h:\n        return max(attacks) - min(attacks) + 1\n    (other code)\n", "requirement analysis:\nThe problem requires finding the minimum value of k such that the total damage caused by Monocarp's attacks, with the given attack times and the duration of the poison effect, is at least h. This involves determining the intervals between attacks and the poison effect, and finding the smallest k that covers the total required damage.\nrequirement pool:\n- The main code must read input from standard input\n- The main code must output the minimum value of k for each test case\n- The code must handle up to 1000 test cases efficiently\n- The code must be able to handle large values of n and h\nTo solve this problem, we will use a binary search approach to find the minimum value of k. The binary search will help us efficiently find the smallest k that ensures Monocarp's attacks deal at least h damage to the dragon. We will iterate through possible values of k, checking if the total damage within the poison effect duration is sufficient to meet the required damage h. The binary search will narrow down the range of possible k values until we find the minimum k that satisfies the condition.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a technique used to find the minimum or maximum value that satisfies a certain condition. It works by repeatedly dividing the search interval in half and checking the condition at the midpoint.\n\n# [phrase showing quantity relationship]\n    'at least': This phrase indicates that the value must be at the minimum level required.\n\n# [degree adverb] \n    'minimum': This adverb indicates that we are looking for the smallest possible value that meets the condition.\n\n# [code logic]\n    To implement the solution, we will use a binary search to find the minimum value of k. The binary search will be performed on the range of possible values for k, which is from 1 to the maximum possible value of a_i (the time of the last attack). For each midpoint value in the binary search, we will calculate the total damage dealt within the poison effect duration and check if it is at least h. If it is, we adjust the upper or lower bound of the search interval accordingly.\n\n# [edge case] \n    search([1, 2, 4, 5, 7], 3) = 1\n    Explanation: The maximum damage within any 1-second poison effect is 3, which is less than the required 10 damage. Therefore, the minimum k must be greater than 1.\n    search([1, 2, 4, 5, 7], 1) = 1\n    Explanation: The maximum damage within any 1-second poison effect is 1, which is less than the required 10 damage. Therefore, the minimum k must be greater than 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the required damage h is zero. In this case, the minimum k should be 1, as no damage is needed.\n        if h == 0:\n            return 1\n        (other code)\n", "requirement analysis:\nThe primary requirement is to determine the minimum value of k such that Monocarp's poisoned dagger deals at least h damage to the dragon. This involves calculating the intervals between attacks and the poison effect duration. The solution must be efficient to handle up to 1000 test cases, each with up to 100 attacks and a maximum damage value of 10^18.\nrequirement pool:\n- Implement a function to calculate the minimum k for each test case.\n- Ensure the solution is optimized for handling large inputs efficiently.\n- Design a user-friendly interface for input and output.\n- Conduct thorough testing to verify the accuracy and performance of the solution.\nTo solve the problem of determining the minimum value of k such that Monocarp's poisoned dagger deals at least h damage to the dragon, we will use a binary search approach. This method will efficiently find the minimum k by testing possible values in a logarithmic number of steps. We will calculate the total damage dealt by Monocarp's attacks considering the poison effect and compare it with the required damage h. The binary search will help us minimize the number of iterations needed to find the correct k.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a technique used to find the minimum or maximum value that satisfies a certain condition. It works by repeatedly dividing the search interval in half and checking the middle value.\n\n# [phrase showing quantity relationship]\n    'at least': This phrase indicates that the value must be at the minimum the specified amount.\n\n# [degree adverb] \n    'minimum': This adverb indicates that we are looking for the smallest possible value that meets the condition.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the number of test cases.\n    2. For each test case:\n        a. Read the number of attacks and the required damage.\n        b. Read the attack times.\n        c. Use binary search to find the minimum k such that the total damage is at least h.\n        d. Output the result for each test case.\n\n# [edge case] \n    search([1, 2, 4, 5, 7], 3) = 1\n    explanation: For k=1, the damage is dealt in seconds [1, 2, 4, 5, 7]. The total damage is 1 + 1 + 1 + 1 + 1 = 5, which is less than 3.\n    search([1, 5], 5) = 1\n    explanation: For k=1, the damage is dealt in seconds [1, 5]. The total damage is 1 + 1 = 2, which is less than 5.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the total damage is less than h even for the smallest possible k.\n        if total_damage < h:\n            return -1  # This means it's impossible to deal at least h damage\n\n    This code will ensure that we don't return a k value that doesn't satisfy the condition.\n", "requirement analysis:\nThe primary requirement is to determine the minimum value of k such that the total damage dealt by Monocarp's attacks, considering the poison effect, is at least h. The attacks are given in a sequence, and the poison effect starts immediately after each attack. The challenge is to find k for each test case efficiently, especially given the large possible values of h.\nrequirement pool:\n- Implement a function to calculate the minimum k for each test case.\n- Ensure the solution is optimized for handling large inputs and time constraints.\n- Develop a clear and efficient algorithm to compute the result.\n- Test the solution against multiple test cases to ensure accuracy and robustness.\n- Implement input/output handling to match the specified format.\nTo solve this problem, we will use a binary search approach to efficiently find the minimum value of k for each test case. The binary search will be used to determine the smallest k such that the total damage dealt by Monocarp's attacks, considering the poison effect, is at least h. We will implement this in Python, leveraging the efficiency of Python's built-in functions and libraries.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a technique used to find the minimum or maximum value that satisfies a given condition. In this case, we are looking for the minimum value of k such that the total damage dealt is at least h.\n\n    'damage calculation': We need to calculate the total damage dealt by Monocarp's attacks, considering the poison effect. This involves summing up the damage for each attack over the next k seconds.\n\n# [phrase showing quantity relationship]\n    'at least': This phrase indicates that the value we are looking for must be at least as large as the specified value. In this case, we need to find the smallest k such that the total damage is at least h.\n\n# [degree adverb] \n    'minimum': This adverb indicates that we are looking for the smallest value that satisfies the condition. In this case, we are looking for the minimum value of k.\n\n# [code logic]\n    To implement the solution, we will follow these steps for each test case:\n    1. Read the input values for n and h.\n    2. Read the sequence of attack times a_i.\n    3. Use binary search to find the minimum k such that the total damage is at least h.\n    4. For each potential k, calculate the total damage dealt and check if it is at least h.\n    5. Return the minimum k that satisfies the condition.\n\n# [edge case] \n    Edge case 1:\n    Input: 1 1\n           1\n    Output: 1\n    Explanation: There is only one attack, and it occurs at the first second. Since the required damage is 1, the minimum k is 1, as the poison effect will only last for 1 second.\n\n    Edge case 2:\n    Input: 2 3\n           1 3\n    Output: 2\n    Explanation: There are two attacks, one at the first second and the other at the third second. The total damage required is 3. The minimum k is 2 because the poison effect will deal 1 damage during the first second and the next second, totaling 2 damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles cases with a single attack or cases where the attacks are close together.\n", "requirement analysis:\nThe primary requirement is to determine the minimum value of k such that Monocarp's poisoned dagger deals at least h damage to the dragon. The solution must be efficient and capable of handling large inputs within the given constraints. The algorithm should be optimized to minimize computation time.\nrequirement pool:\n- Implement a function to calculate the minimum k for each test case.\n- Ensure the solution can handle up to 1000 test cases efficiently.\n- Optimize the algorithm to handle large values of h up to 10^18.\n- Add input validation to ensure the program handles invalid inputs gracefully.\n- Include detailed comments and documentation for easier understanding and maintenance.\nTo solve the problem of determining the minimum value of k such that Monocarp's poisoned dagger deals at least h damage to the dragon, we will use a binary search approach. This method will be efficient in finding the minimum k without having to iterate through all possible values of k. We will also need to consider the time points at which Monocarp attacks the dragon and the effect of the poison. The solution will be implemented in Python, leveraging the power of binary search to optimize the computation.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a technique used to find the minimum value of k efficiently by repeatedly dividing the search interval in half.\n\n# [phrase showing quantity relationship]\n    'at least': This phrase indicates that the value we are looking for must be at least as large as the specified value.\n\n# [degree adverb] \n    'minimum': This adverb indicates that we are looking for the smallest possible value of k that satisfies the condition.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. For each test case, read the number of attacks (n) and the required damage (h).\n    2. Read the attack times into a list.\n    3. Use binary search to find the minimum k such that the total damage dealt is at least h.\n    4. For each possible k, calculate the total damage dealt and check if it meets or exceeds h.\n    5. Return the minimum k that satisfies the condition.\n\n# [edge case] \n    Edge case 1:\n    Input: 1 1\n           1\n    Expected Output: 1\n    Explanation: There is only one attack, and the required damage is 1. The minimum k is 1 because the attack is instant.\n\n    Edge case 2:\n    Input: 2 3\n           1 3\n    Expected Output: 2\n    Explanation: There are two attacks, one at the 1st second and another at the 3rd second. The minimum k is 2 because the poison effect lasts for 2 seconds starting from each attack.\n\n    Edge case 3:\n    Input: 3 10\n           1 2 4\n    Expected Output: 4\n    Explanation: The attacks are at the 1st, 2nd, and 4th seconds. The minimum k is 4 because the poison effect must last for at least 4 seconds to ensure the dragon receives at least 10 damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the binary search approach inherently handles cases with a single attack or small numbers of attacks. However, for larger numbers of attacks, the binary search will efficiently find the minimum k.\n", "requirement analysis:\nThe problem requires finding the minimum value of k such that Monocarp's attacks with the poisoned dagger deal at least h damage to the dragon. The attacks are given at specific times, and the poison effect lasts for k seconds. The poison effect can be updated at each attack, and the goal is to find the smallest k that ensures the dragon receives at least h damage.\nrequirement pool:\n- Implement a function to calculate the minimum k required to deal h damage.\n- Ensure the solution is efficient enough to handle up to 1000 test cases.\n- Optimize the algorithm to minimize the number of calculations for each test case.\nTo solve this problem, we will use a binary search approach to find the minimum value of k. This approach will be efficient and suitable for handling up to 1000 test cases. The binary search will help us minimize the number of calculations for each test case by narrowing down the possible values of k efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a method to find the minimum value of k efficiently by repeatedly dividing the search interval in half.\n    Explanation: In this problem, we need to find the smallest k such that the total poison damage inflicted on the dragon is at least h. Using binary search, we can efficiently determine this minimum k without having to test every possible value of k.\n\n# [phrase showing quantity relationship]\n    'at least': This phrase indicates that the total damage must be equal to or greater than h.\n    Explanation: We need to ensure that the total poison damage dealt to the dragon is at least h. This means we need to find the smallest k such that the sum of the poison effects from all attacks is at least h.\n\n# [degree adverb] \n    'minimum possible': This indicates that we are looking for the smallest value of k that satisfies the condition.\n    Explanation: We need to find the smallest k to ensure that the dragon is dealt at least h damage. This means we need to minimize the duration of the poison effect.\n\n# [code logic]\n    To implement the solution, we will use a binary search to find the minimum k. The steps are as follows:\n    1. Sort the list of attack times.\n    2. Define a function to calculate the total damage for a given k.\n    3. Use binary search to find the minimum k such that the total damage is at least h.\n\n# [edge case] \n    Edge case 1: Monocarp attacks only once at the beginning of the battle.\n    expected output: k = a_1 - 1\n    Explanation: If Monocarp attacks only once, the poison effect will last for k = a_1 - 1 seconds.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where Monocarp attacks only once.\n        if n == 1:\n            return a_1 - 1\n        (other code)\n\n    This ensures that we handle the scenario where there is only one attack and the poison effect lasts for the entire battle duration minus one second.\n"], "scores": [], "pass_results": [false, true, false, false, true, false, false, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 15, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "add_1_sentence_at_end", "parent_index": 15}
