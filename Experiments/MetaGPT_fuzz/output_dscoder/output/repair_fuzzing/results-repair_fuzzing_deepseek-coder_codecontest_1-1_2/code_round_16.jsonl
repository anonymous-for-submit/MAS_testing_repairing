{"name": "1615_A. Closing The Gap", "description": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\n\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "tags": ["greedy", "math"], "difficulty": 7, "id": 1615, "sample_io": [{"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}], "test_list": [{"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n1 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 3 -1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 0\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 1 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 10 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 5 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 0\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 4\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 0 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 0\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n1 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n24 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 -1 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n24 9 15\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n0 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n36 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 1\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n41 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 10 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 5\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 0 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 9\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n4 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n3 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n1 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n0 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n15 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 0 1 2\n5\n0 2 3 1 0\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 2 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 5 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n4 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 17 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 0 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n4 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 -1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 10\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n13 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 31 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n15 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 0 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n6 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 0 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n1 3 6 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 15\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 2 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 16\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 -1 3\n5\n0 3 6 1 5\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n11 12 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 2 4\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 2\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 0 6 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 1\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 14 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 2 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 14\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n1 3 10 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 19\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n0 0 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n-1 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 1\n5\n0 2 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 7\n", "output": ["0\n1\n0\n"]}], "task_id": "codecontest/119", "prompt": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible, and in a single day, you can perform the following operation: \n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1.\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "repair_prompt": ["There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible, and in a single day, you can perform the following operation: \n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1.\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\nWrite a main() function and use input() function to read input from stdin", " There are n block towers arranged in a row, each with a specific height denoted as a_i. As part of a construction team, your goal is to enhance the appearance of these towers by making them as aesthetically pleasing as possible within a single day. You can perform the following operation:\n\n  * Select two distinct indices i and j (where 1 \u2264 i, j \u2264 n and i \u2260 j), and transfer a block from tower i to tower j. This operation involves decreasing the height of tower i by 1 and increasing the height of tower j by 1.\n\nThe objective is to\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\nWrite a main() function and use input() function to read input from stdin", " There are n block towers in a row, where tower i has a height of a_i. You can move a block from tower i to tower j (1 \u2264 i, j \u2264 n; i \u2260 j) to decrease a_i by 1 and increase a_j by 1, aiming to achieve the minimum possible ugliness, defined as max(a)-min(a).\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\nfrom typing import List\n\ndef find_minimum_ugliness(n: int, heights: List[int]) -> int:\n    total_height = sum(heights)\n    average_height = total_height // n\n    excess_blocks = total_height - average_height * n\n\n    # Adjust heights to balance the towers\n    new_heights = [average_height] * n\n    for i in range(excess_blocks):\n        new_heights[i] += 1\n\n    # Calculate the minimum possible ugliness\n    return max(new_heights) - min(new_heights)\n\n# Read input from stdin\nn = int(input())\nheights = list(map(int, input().split()))\n\n# Call the function and print the result\nresult = find_minimum_ugliness(n, heights)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_minimum_ugliness(n: int, heights: List[int]) -> int:\n    # Calculate the average height of all towers\n    total_height = sum(heights)\n    average_height = total_height / n\n    \n    # Calculate the number of blocks to be moved to achieve the average height\n    blocks_to_move = [height - average_height for height in heights]\n    \n    # The minimum possible ugliness is the sum of the absolute values of the differences\n    min_ugliness = sum(abs(block) for block in blocks_to_move)\n    \n    return int(min_ugliness)\n\n# Interface for the program\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    heights = list(map(int, input().split()))\n    result = calculate_minimum_ugliness(n, heights)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_min_ugliness(n: int, heights: List[int]) -> int:\n    # Find the maximum and minimum heights in the list\n    max_height = max(heights)\n    min_height = min(heights)\n    \n    # The minimum possible ugliness is the difference between the maximum and minimum heights\n    return max_height - min_height\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of buildings\n    n = int(input())\n    \n    # Read the heights of the buildings\n    heights = list(map(int, input().split()))\n    \n    # Calculate and print the minimum possible ugliness\n    result = calculate_min_ugliness(n, heights)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_min_ugliness(n: int, heights: List[int]) -> int:\n    # Find the minimum and maximum heights in the list\n    min_height = min(heights)\n    max_height = max(heights)\n    \n    # Calculate the initial ugliness\n    initial_ugliness = max_height - min_height\n    \n    # The minimum possible ugliness is achieved when the heights are balanced\n    # This can be done by transferring blocks from the tallest tower to the shortest tower until they are equal\n    while max_height != min_height:\n        # Find the index of the tallest and shortest tower\n        max_index = heights.index(max_height)\n        min_index = heights.index(min_height)\n        \n        # Transfer a block from the tallest tower to the shortest tower\n        heights[max_index] -= 1\n        heights[min_index] += 1\n        \n        # Recalculate the minimum and maximum heights\n        min_height = min(heights)\n        max_height = max(heights)\n        \n        # Recalculate the ugliness\n        initial_ugliness = max_height - min_height\n    \n    return initial_ugliness\n\n# Read the number of test cases\nt = int(input())\n\n# Iterate over each test case\nfor _ in range(t):\n    # Read the number of buildings\n    n = int(input())\n    \n    # Read the heights of the buildings\n    heights = list(map(int, input().split()))\n    \n    # Calculate and print the minimum possible ugliness\n    result = calculate_min_ugliness(n, heights)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_min_ugliness(n: int, heights: List[int]) -> int:\n    \"\"\"\n    Calculate the minimum possible ugliness of the buildings by transferring blocks between towers.\n    \n    Args:\n        n (int): The number of towers.\n        heights (List[int]): A list of integers representing the heights of the towers.\n    \n    Returns:\n        int: The minimum possible ugliness after transferring blocks.\n    \"\"\"\n    # Calculate the initial ugliness\n    max_height = max(heights)\n    min_height = min(heights)\n    initial_ugliness = max_height - min_height\n    \n    # If the initial ugliness is already 0, return immediately\n    if initial_ugliness == 0:\n        return 0\n    \n    # Transfer blocks to minimize the ugliness\n    while max_height != min_height:\n        # Find the tallest and shortest towers\n        max_index = heights.index(max_height)\n        min_index = heights.index(min_height)\n        \n        # Transfer one block from the tallest tower to the shortest tower\n        heights[max_index] -= 1\n        heights[min_index] += 1\n        \n        # Recalculate the max and min heights\n        max_height = max(heights)\n        min_height = min(heights)\n        \n        # Recalculate the ugliness\n        current_ugliness = max_height - min_height\n        \n        # If the current ugliness is less than the initial ugliness, update it\n        if current_ugliness < initial_ugliness:\n            initial_ugliness = current_ugliness\n    \n    return initial_ugliness\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of towers and their heights\n    n = int(input())\n    heights = list(map(int, input().split()))\n    \n    # Calculate and print the minimum possible ugliness\n    result = calculate_min_ugliness(n, heights)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_min_ugliness(n: int, heights: List[int]) -> int:\n    # Initialize the minimum possible ugliness to a large number\n    min_ugliness = float('inf')\n    \n    # Iterate through all possible pairs of towers\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the ugliness before transferring a block\n            initial_ugliness = max(heights) - min(heights)\n            \n            # Transfer a block from tower i to tower j\n            heights[i] -= 1\n            heights[j] += 1\n            \n            # Calculate the ugliness after transferring a block\n            new_ugliness = max(heights) - min(heights)\n            \n            # Update the minimum ugliness if a better configuration is found\n            min_ugliness = min(min_ugliness, new_ugliness)\n            \n            # Transfer a block back to restore the original state\n            heights[i] += 1\n            heights[j] -= 1\n    \n    return min_ugliness\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of towers and their heights\n    n = int(input())\n    heights = list(map(int, input().split()))\n    \n    # Calculate and print the minimum possible ugliness\n    result = calculate_min_ugliness(n, heights)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_min_ugliness(n: int, heights: List[int]) -> int:\n    # Sort the heights of the towers\n    heights.sort()\n    \n    # Calculate the initial ugliness\n    initial_ugliness = heights[-1] - heights[0]\n    \n    # Use a greedy algorithm to minimize the ugliness\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Move a block from tower i to tower j\n            heights[i] -= 1\n            heights[j] += 1\n            # Recalculate the ugliness\n            current_ugliness = max(heights) - min(heights)\n            # Update the initial ugliness if the current ugliness is smaller\n            initial_ugliness = min(initial_ugliness, current_ugliness)\n            # Move the block back to restore the original state\n            heights[i] += 1\n            heights[j] -= 1\n    \n    return initial_ugliness\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of towers and their heights\n    n = int(input())\n    heights = list(map(int, input().split()))\n    \n    # Calculate and print the minimum possible ugliness\n    result = calculate_min_ugliness(n, heights)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_min_ugliness(tower_heights: List[int]) -> int:\n    # Sort the tower heights to easily find the tallest and shortest towers\n    sorted_heights = sorted(tower_heights)\n    \n    # The minimum possible ugliness is the difference between the tallest and shortest towers\n    # after balancing the heights as much as possible\n    return sorted_heights[-1] - sorted_heights[0]\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of towers\n    n = int(input())\n    \n    # Read the heights of the towers\n    tower_heights = list(map(int, input().split()))\n    \n    # Calculate and print the minimum possible ugliness\n    result = calculate_min_ugliness(tower_heights)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_min_ugliness(n: int, heights: List[int]) -> int:\n    # Calculate the initial ugliness\n    min_height = min(heights)\n    max_height = max(heights)\n    initial_ugliness = max_height - min_height\n    \n    # If the initial ugliness is already zero, return it\n    if initial_ugliness == 0:\n        return initial_ugliness\n    \n    # Iterate through each possible block movement to find a more optimal distribution\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                # Move a block from tower i to tower j\n                heights[i] -= 1\n                heights[j] += 1\n                \n                # Recalculate the ugliness\n                new_min_height = min(heights)\n                new_max_height = max(heights)\n                new_ugliness = new_max_height - new_min_height\n                \n                # Update the minimum possible ugliness\n                initial_ugliness = min(initial_ugliness, new_ugliness)\n                \n                # Move the block back to its original position\n                heights[i] += 1\n                heights[j] -= 1\n    \n    return initial_ugliness\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of towers and their heights\n    n = int(input())\n    heights = list(map(int, input().split()))\n    \n    # Calculate and print the minimum possible ugliness\n    result = calculate_min_ugliness(n, heights)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_min_ugliness(n: int, heights: List[int]) -> int:\n    # Calculate the initial height difference\n    min_height = min(heights)\n    max_height = max(heights)\n    initial_ugliness = max_height - min_height\n    \n    # If the initial ugliness is already 0, return immediately\n    if initial_ugliness == 0:\n        return 0\n    \n    # Continue moving blocks until the ugliness cannot be reduced further\n    while True:\n        # Find the index of the tallest and shortest towers\n        tallest_index = heights.index(max(heights))\n        shortest_index = heights.index(min(heights))\n        \n        # Move a block from the tallest tower to the shortest tower\n        heights[tallest_index] -= 1\n        heights[shortest_index] += 1\n        \n        # Recalculate the new height difference\n        new_min_height = min(heights)\n        new_max_height = max(heights)\n        new_ugliness = new_max_height - new_min_height\n        \n        # If the ugliness did not change, break the loop\n        if new_ugliness == initial_ugliness:\n            break\n        \n        # Update the initial ugliness\n        initial_ugliness = new_ugliness\n    \n    return initial_ugliness\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    heights = list(map(int, input().split()))\n    result = calculate_min_ugliness(n, heights)\n    print(result)\n"], "plans": ["requirement analysis:\nThe primary requirement is to find the minimum possible ugliness of the buildings by moving blocks between towers. This involves understanding the concept of balancing the heights to minimize the difference between the maximum and minimum heights. The solution should be efficient and capable of handling up to 100 buildings, which is a reasonable size for city planning scenarios.\nrequirement pool:\n- Implement an algorithm to calculate the minimum possible ugliness.\n- Ensure the solution is scalable to handle up to 100 buildings.\n- Develop a user-friendly interface for input and output.\n- Include error handling for invalid inputs.\n- Provide detailed documentation and examples for users.\nTo achieve the goal of minimizing the height difference between the tallest and shortest buildings, we can use a simple strategy. The key idea is to balance the heights of the towers by moving blocks from the taller towers to the shorter ones. The minimum possible ugliness can be achieved when all towers have the same height, which is the average height of the towers. This can be done by moving blocks from the towers that are taller than the average to the towers that are shorter than the average. The minimum possible ugliness is then the difference between the maximum and minimum heights after balancing.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'balancing blocks': The process of moving blocks from taller towers to shorter ones to equalize their heights.\n    Explanation: The goal is to minimize the height difference between the tallest and shortest buildings by redistributing blocks. This can be achieved by calculating the average height of all towers and then adjusting the heights to match this average.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that a value must be greater than another value.\n    'at least as many times': Indicates that a value must appear at least as frequently as another value.\n\n# [degree adverb] \n    'largest': Indicates the maximum value in a set.\n    'smallest': Indicates the minimum value in a set.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    For each test case:\n    1. Calculate the average height of all towers.\n    2. Determine the difference between the maximum and minimum heights after balancing.\n    3. Output the minimum possible ugliness.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, heights = [4, 2, 7]\n    Explanation: The average height is (4 + 2 + 7) / 3 = 4.33. After balancing, the heights could be [4, 3, 6] or similar, with the minimum possible ugliness being 6 - 4 = 2.\n    Edge case 2:\n    Input: n = 2, heights = [10, 10]\n    Explanation: Since all towers are already of the same height, the minimum possible ugliness is 0.\n    Edge case 3:\n    Input: n = 4, heights = [1, 5, 3, 2]\n    Explanation: The average height is (1 + 5 + 3 + 2) / 4 = 2.75. After balancing, the heights could be [2, 4, 3, 3] or similar, with the minimum possible ugliness being 4 - 2 = 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to solve the problem.\n", "requirement analysis:\nThe primary requirement is to find the minimum possible ugliness of the buildings by moving blocks between towers. This involves understanding the height difference and strategically moving blocks to reduce this difference. The solution should be efficient and able to handle up to 100 test cases within the given constraints.\nrequirement pool:\n- Implement a function to calculate the minimum ugliness after any number of days.\n- Ensure the solution is scalable to handle up to 100 test cases.\n- Optimize the process to achieve the minimum possible ugliness efficiently.\nTo achieve the goal of minimizing the height difference between the tallest and shortest buildings, we can use a simple strategy. The key idea is to balance the heights of the towers by moving blocks from the taller towers to the shorter ones. The minimum possible ugliness can be achieved by ensuring that all towers have the same height, which is the average height of the towers. This can be done by calculating the average height and then determining the number of blocks that need to be moved to achieve this uniformity. The number of blocks to be moved will be the difference between the height of each tower and the average height, summed up for all towers. The minimum possible ugliness is then zero, which can be achieved by making all towers equal in height.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'balancing blocks': The process of moving blocks from taller towers to shorter ones to equalize their heights.\n    Explanation: The goal is to minimize the height difference between the tallest and shortest buildings by redistributing blocks. This can be achieved by making all towers the same height, which is the average height of the towers.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that one value is greater than another.\n    'at least as many times': Indicates that a value appears a certain number of times or more.\n\n# [degree adverb] \n    'largest': Indicates the maximum value in a set.\n    'smallest': Indicates the minimum value in a set.\n\n# [code logic]\n    To achieve the minimum possible ugliness, we can follow these steps:\n    1. Calculate the average height of all towers.\n    2. Determine the number of blocks that need to be moved to achieve the average height.\n    3. The minimum possible ugliness is zero, which can be achieved by making all towers equal in height.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [4, 2, 7]\n    Explanation: The average height is (4 + 2 + 7) / 3 = 4.67. The number of blocks to be moved to achieve uniformity is [(4-4.67), (2-4.67), (7-4.67)] = [-0.67, -2.67, 2.33]. The sum of the absolute values of these differences is 5.67, which is the minimum possible ugliness.\n\n    Edge case 2:\n    Input: n = 2, a = [10, 10]\n    Explanation: The average height is (10 + 10) / 2 = 10. Since all towers are already of the same height, no blocks need to be moved, and the minimum possible ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle cases where all towers are already of the same height.\n", "requirement analysis:\nThe problem requires finding the minimum possible ugliness of the buildings after performing any number of operations. The ugliness is defined as the difference between the maximum and minimum heights of the buildings. The optimal strategy is to make all the buildings heights equal, which can be achieved by moving blocks from the tallest to the shortest until they are all the same height. This will result in a minimum ugliness of 0.\nrequirement pool:\n- Implement a function to calculate the minimum ugliness after any number of operations.\n- Ensure the program can handle multiple test cases efficiently.\n- Develop a user interface for input and output.\n- Optimize the algorithm for large inputs to ensure performance.\nTo solve the problem of finding the minimum possible ugliness of the buildings, we can use a straightforward approach. The key idea is to balance the heights of all towers by moving blocks from the tallest to the shortest until all towers have the same height. This will minimize the ugliness, which is defined as the difference between the maximum and minimum heights of the buildings. We will implement a function that calculates this minimum ugliness for each test case efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'balancing blocks': The core concept is to equalize the heights of all towers by moving blocks from the tallest to the shortest tower.\n    Explanation: By doing this, the difference between the maximum and minimum heights of the buildings will be minimized.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    For each test case, we need to:\n    1. Find the maximum and minimum heights of the buildings.\n    2. Calculate the current ugliness as the difference between the maximum and minimum heights.\n    3. Since the goal is to minimize the ugliness, we can achieve this by balancing the heights of all towers.\n    4. The minimum possible ugliness is achieved when all towers have the same height, which is the average height of the buildings.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, heights = [4, 2, 7]\n    Explanation: The maximum height is 7 and the minimum height is 2. The current ugliness is 7 - 2 = 5. By moving a block from the tower with height 7 to the tower with height 2, we can balance the heights to 4, 3, and 4. The ugliness is now 4 - 4 = 0.\n    Edge case 2:\n    Input: n = 2, heights = [10, 10]\n    Explanation: The maximum height is 10 and the minimum height is 10. The current ugliness is 10 - 10 = 0. Since all towers already have the same height, the minimum possible ugliness is 0.\n    Edge case 3:\n    Input: n = 4, heights = [1, 5, 3, 2]\n    Explanation: The maximum height is 5 and the minimum height is 1. The current ugliness is 5 - 1 = 4. By moving blocks to balance the heights, we can achieve a configuration where all towers have a height of 3. The ugliness is now 3 - 3 = 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to solve the problem for any valid input.\n", "requirement analysis:\nThe problem requires finding the minimum possible ugliness of the buildings after performing the allowed operations. The ugliness is defined as the maximum height of the buildings minus the minimum height of the buildings. The allowed operation is to transfer a block from one tower to another, which changes the heights of the towers accordingly.\nrequirement pool:\n- Implement the ability to read input for multiple test cases\n- Calculate the minimum possible ugliness after performing the allowed operations\n- Ensure the solution is efficient enough to handle up to 1000 test cases with n up to 100\n- Optimize the solution to ensure it runs within reasonable time limits for large inputs\nTo solve this problem, we will use a simple and efficient approach that involves calculating the minimum and maximum heights of the towers and then determining the minimum possible ugliness by transferring blocks between towers. We will iterate through each test case, apply the allowed operations, and calculate the ugliness for each case.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block transfer': the process of moving blocks from one tower to another to balance their heights.\n    Explanation: In this problem, the goal is to minimize the difference in height between the tallest and shortest towers by strategically transferring blocks.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find the minimum and maximum heights in the list of tower heights.\n    Explanation: For each test case, we need to identify the smallest and largest values in the list of tower heights to determine the range of heights.\n\n# [degree adverb] \n    'smallest': refers to the minimum possible ugliness, which is achieved when the heights of the towers are as balanced as possible.\n    Explanation: The smallest possible ugliness is determined by minimizing the difference between the maximum and minimum heights of the towers after any number of block transfers.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    For each test case:\n    1. Identify the minimum and maximum heights from the list of tower heights.\n    2. Calculate the initial ugliness as the difference between the maximum and minimum heights.\n    3. Since we can transfer blocks between any two towers, the minimum possible ugliness is achieved when the heights are balanced. This can be done by transferring blocks from the tallest tower to the shortest tower until they are equal.\n    4. The final ugliness is 0 since the heights are balanced.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, heights = [1, 5, 3]\n    Explanation: The initial ugliness is 4 (5 - 1). By transferring 2 blocks from the tower with height 5 to the tower with height 1, the heights become [3, 5, 3], and the ugliness is reduced to 2. Further transfers can further reduce the ugliness, but the minimum possible ugliness is 2.\n    Expected output: 2\n\n    Edge case 2:\n    Input: n = 2, heights = [10, 10]\n    Explanation: The initial ugliness is 0 since all towers have the same height. No transfers are needed.\n    Expected output: 0\n\n    Edge case 3:\n    Input: n = 4, heights = [7, 2, 3, 10]\n    Explanation: The initial ugliness is 8 (10 - 2). By transferring blocks to balance the heights, the minimum possible ugliness is achieved when the heights are [5, 5, 5, 5], and the ugliness is 0.\n    Expected output: 0\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle all cases, including the edge cases, by balancing the heights to achieve the minimum possible ugliness.\n", "requirement analysis:\nThe requirement analysis involves understanding the objective of minimizing the ugliness of the buildings by transferring blocks between towers. The ugliness is defined as the maximum height minus the minimum height of the towers. The goal is to find the minimum possible ugliness by performing the allowed operations.\nrequirement pool:\n- Implement the ability to read input for multiple test cases\n- Calculate the minimum possible ugliness for each test case\n- Output the minimum possible ugliness for each test case\nTo solve the problem of minimizing the ugliness of the buildings by transferring blocks between towers, we will use a simple Python function that reads input for multiple test cases, calculates the minimum possible ugliness for each test case, and outputs the result. The ugliness is defined as the maximum height minus the minimum height of the towers after performing the allowed operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block transfer': means decreasing the height of one tower and increasing the height of another tower by one unit.\n    Explanation: The goal is to balance the heights of the towers to make them as aesthetically pleasing as possible. This involves strategically transferring blocks between towers to equalize their heights.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    For each test case:\n    1. Read the number of towers (n) and their heights.\n    2. Calculate the initial ugliness as the difference between the maximum and minimum heights.\n    3. To minimize the ugliness, transfer blocks from the tallest tower to the shortest tower until the heights are balanced.\n    4. Output the minimum possible ugliness for each test case.\n\n# [edge case] \n    Test case: [4, 4, 4, 4]\n    Expected output: 0\n    Explanation: All towers already have the same height, so no blocks need to be transferred. The ugliness is 0.\n\n    Test case: [1, 5, 5, 5]\n    Expected output: 4\n    Explanation: The shortest tower is 1 unit tall, and the tallest tower is 5 units tall. By transferring 4 blocks from the tallest tower to the shortest tower, all towers will be 5 units tall. The ugliness is minimized to 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle cases where all towers are already balanced.\n\n    However, for robustness, we could add a check to ensure that the input is valid (e.g., n is within the specified range, heights are within the specified range) before proceeding with the logic.\n", "requirement analysis:\nThe requirement involves calculating the minimum possible ugliness of block towers after performing the allowed operation. The ugliness is defined as the maximum height minus the minimum height among all towers. The goal is to minimize this ugliness by transferring blocks between towers.\nrequirement pool:\n- Implement the function to calculate the minimum ugliness\n- Ensure the function works efficiently for up to 1000 test cases\n- Provide a user-friendly interface for input and output\n- Optimize the algorithm to handle the maximum possible input size\nTo solve the problem of minimizing the ugliness of block towers, we will use a straightforward approach that involves calculating the difference between the maximum and minimum heights of the towers after performing the allowed block transfer operations. The key steps include reading the input, processing each test case to find the minimum ugliness, and outputting the result. We will use Python for this implementation due to its simplicity and readability.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block transfer': the process of moving blocks from one tower to another to balance their heights.\n    Explanation: In this problem, we are allowed to transfer blocks between two towers to make their heights more uniform. The goal is to minimize the difference between the maximum and minimum heights of the towers.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to compare the heights of the towers and decide which ones to transfer blocks between.\n    'at least as many times': means that the number of blocks we transfer from one tower to another should be such that the target tower's height increases by at least the value of the source tower's height.\n\n# [degree adverb] \n    'minimum possible': suggests that we need to find the smallest possible difference between the maximum and minimum heights after performing the block transfers.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    For each test case:\n    1. Read the number of towers (n) and their heights.\n    2. Initialize a variable to keep track of the minimum possible ugliness.\n    3. Iterate through all possible pairs of towers and calculate the ugliness after transferring a block from one to another.\n    4. Update the minimum ugliness if a better configuration is found.\n    5. Return the minimum ugliness for the current test case.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, heights = [1, 5, 3]\n    Explanation: The initial ugliness is 4 (5 - 1). By transferring a block from tower 2 to tower 1, we get [2, 4, 3], reducing the ugliness to 3.\n    Expected output: 3\n\n    Edge case 2:\n    Input: n = 2, heights = [10, 10]\n    Explanation: Since there are only two towers and their heights are the same, no transfer is needed. The ugliness is 0.\n    Expected output: 0\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic already covers the scenarios where the number of towers is 2 or where the heights are already balanced.\n", "requirement analysis:\nThe primary requirement is to calculate the minimum possible ugliness of block towers. This involves finding the optimal distribution of block heights to minimize the difference between the maximum and minimum heights. The solution should be efficient enough to handle up to 100 test cases, each with up to 100 buildings.\nrequirement pool:\n- Implement an algorithm to calculate the minimum ugliness efficiently.\n- Ensure the solution can handle up to 100 test cases and 100 buildings per test case.\n- Optimize the algorithm for performance to handle large inputs quickly.\n- Provide clear and accurate output for the minimum possible ugliness.\nTo efficiently calculate the minimum possible ugliness of block towers, we will use a simple yet effective approach. The main idea is to balance the heights of the towers by moving blocks from the tallest tower to the shortest one. This can be achieved by sorting the towers based on their heights and then iteratively moving blocks from the tallest to the shortest until the difference between the maximum and minimum heights is minimized.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block tower balancing': \n    The process of moving blocks from one tower to another to equalize or nearly equalize their heights to minimize the difference between the maximum and minimum heights.\n\n# [phrase showing quantity relationship]\n    'more than': \n    Indicates that one value is greater than another. In this context, it refers to the comparison between the heights of the towers.\n\n# [degree adverb] \n    'minimum': \n    Indicates the goal is to achieve the smallest possible difference between the maximum and minimum heights.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    For each test case:\n    1. Read the number of towers (n) and their heights (a_i).\n    2. Sort the heights of the towers.\n    3. Calculate the initial ugliness as the difference between the maximum and minimum heights.\n    4. Iterate through the sorted heights and simulate moving blocks from the tallest tower to the shortest until the ugliness is minimized.\n    5. Return the minimized ugliness.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, a = [3, 1, 2]\n    Explanation:\n    - Initial heights: [3, 1, 2]\n    - Sorted heights: [1, 2, 3]\n    - Initial ugliness: 3 - 1 = 2\n    - Move block from tower 3 to tower 1: [4, 0, 2] (not valid as blocks cannot be negative)\n    - Move block from tower 3 to tower 2: [4, 2, 1] (not valid as blocks cannot be negative)\n    - Correct approach: Move block from tower 3 to tower 1: [4, 0, 2] -> [3, 1, 3] -> [2, 2, 4]\n    - Final ugliness: 4 - 2 = 2\n    Expected output: 2\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where moving blocks results in negative heights.\n        (code for handling the edge case)\n    if min(a) < 0:\n        return \"Invalid input: negative tower height\"\n\n    # Continue with the rest of the logic...\n", "requirement analysis:\nThe primary requirement is to calculate the minimum possible ugliness of block towers. This involves finding the optimal distribution of heights such that the difference between the maximum and minimum heights is minimized. The solution should be able to handle multiple test cases efficiently.\nrequirement pool:\n- Implement a function to calculate the minimum ugliness for a given set of tower heights.\n- Ensure the solution can handle up to 100 test cases efficiently.\n- Optimize the algorithm for performance, especially for large inputs.\n- Provide clear and accurate output for each test case.\nTo achieve the goal of minimizing the ugliness of block towers, we will use a simple and efficient approach. The main idea is to balance the heights of the towers by moving blocks from the tallest tower to the shortest tower. This can be efficiently implemented using Python's built-in functions and data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block tower balancing':\n    The core concept involves adjusting the heights of towers by moving blocks between them to minimize the difference between the tallest and shortest towers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To achieve the goal of minimizing the ugliness of block towers, we will use a simple and efficient approach. The main idea is to balance the heights of the towers by moving blocks from the tallest tower to the shortest tower. This can be efficiently implemented using Python's built-in functions and data structures.\n\n# [edge case] \n    Edge Case 1:\n    Input: n = 3, towers = [3, 1, 2]\n    Explanation: The initial ugliness is max(3, 1, 2) - min(3, 1, 2) = 3 - 1 = 2. By moving a block from tower 1 to tower 3, the heights become [4, 1, 1]. The ugliness is now max(4, 1, 1) - min(4, 1, 1) = 4 - 1 = 3. However, if we move a block from tower 1 to tower 2, the heights become [3, 2, 2], and the ugliness is now max(3, 2, 2) - min(3, 2, 2) = 3 - 2 = 1. This is the minimum possible ugliness.\n    Expected Output: 1\n\n    Edge Case 2:\n    Input: n = 2, towers = [10, 10]\n    Explanation: Since there are only two towers with the same height, no moves are needed to reduce the ugliness. The ugliness is already 0.\n    Expected Output: 0\n\n    Edge Case 3:\n    Input: n = 4, towers = [7, 3, 5, 1]\n    Explanation: The initial ugliness is max(7, 3, 5, 1) - min(7, 3, 5, 1) = 7 - 1 = 6. By moving blocks optimally, the minimum possible ugliness is achieved when the heights become [6, 4, 5, 2]. The ugliness is now max(6, 4, 5, 2) - min(6, 4, 5, 2) = 6 - 2 = 4.\n    Expected Output: 4\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic already ensures that we find the minimum possible ugliness for each test case.\n", "requirement analysis:\nThe requirement is to minimize the ugliness of the block towers by moving blocks between towers. The ugliness is defined as the difference between the maximum and minimum heights of the towers. The solution should be efficient and handle up to 1000 test cases with up to 100 towers each, where each tower height is between 1 and 10^7.\nrequirement pool:\n- Implement a function to calculate the minimum ugliness\n- Ensure the solution is optimized for performance\n- Handle edge cases and large inputs\n- Provide clear and concise output for each test case\nTo solve the problem of minimizing the ugliness of block towers, we will use a straightforward approach that involves calculating the optimal distribution of blocks to achieve the minimum possible difference between the maximum and minimum tower heights. The key steps include iterating through each test case, calculating the initial ugliness, and then determining the optimal block movements to reduce this ugliness.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block towers': means individual structures made of blocks\n    'ugliness': the difference between the tallest and shortest tower\n\n# [phrase showing quantity relationship]\n    'more than': used to compare the heights of towers\n    'at least as many times': indicates the minimum frequency a number must appear\n\n# [degree adverb] \n    'minimum possible': means the smallest difference between the maximum and minimum tower heights\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    For each test case:\n    1. Calculate the initial ugliness as the difference between the maximum and minimum tower heights.\n    2. Iterate through each possible block movement to find a more optimal distribution.\n    3. Return the minimum possible ugliness after all possible movements.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 2, 3]\n    Explanation: The initial ugliness is 3 - 1 = 2. No block movements are needed as the towers are already balanced.\n    Expected output: 2\n\n    Edge case 2:\n    Input: [10, 1, 10]\n    Explanation: The initial ugliness is 10 - 1 = 9. Moving one block from the tallest tower to the shortest tower reduces the ugliness to 10 - 1 = 9.\n    Expected output: 9\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to solve the problem.\n", "requirement analysis:\nThe primary requirement is to minimize the ugliness of the buildings by redistributing blocks between towers. This involves calculating the maximum and minimum heights and then reducing their difference. The solution should be efficient enough to handle up to 100 buildings within a reasonable time frame.\nrequirement pool:\n- Implement a function to calculate the minimum possible ugliness.\n- Ensure the solution is scalable to handle up to 100 buildings.\n- Optimize the ugliness calculation for each test case.\n- Handle up to 1000 test cases efficiently.\nTo achieve the goal of minimizing the ugliness of the buildings, we will use Python's built-in data structures and simple arithmetic operations. The key idea is to balance the heights of the towers by moving blocks from the tallest to the shortest tower, iteratively reducing the height difference until it reaches its minimum possible value.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'balancing blocks': The core concept is to balance the heights of the towers by moving blocks from the tallest to the shortest tower, which will reduce the height difference between the tallest and shortest buildings.\n\n    Explanation: By moving blocks from the tallest tower to the shortest tower, we are effectively evening out the heights of the towers, thus minimizing the height difference between the tallest and shortest buildings.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To achieve the minimum possible ugliness, we can follow these steps:\n    1. Calculate the initial height difference between the tallest and shortest buildings.\n    2. Move blocks from the tallest tower to the shortest tower iteratively until the height difference cannot be reduced further.\n    3. The minimum possible ugliness is the height difference after all possible block movements.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, heights = [1, 5, 3]\n    Explanation: Initially, the tallest building is 5 and the shortest is 1. Moving a block from the tower with height 5 to the tower with height 3 will make both towers have a height of 4, resulting in a minimum possible ugliness of 1.\n    Expected output: 1\n\n    Edge case 2:\n    Input: n = 4, heights = [10, 10, 10, 10]\n    Explanation: All towers are already of the same height, so the ugliness is 0.\n    Expected output: 0\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem for all cases.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 16, "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "mutate_method": "condense_two2one", "parent_index": 16}
