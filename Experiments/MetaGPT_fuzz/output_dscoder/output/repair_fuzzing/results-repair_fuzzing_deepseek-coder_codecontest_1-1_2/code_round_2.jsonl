{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n. There are n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. The maze has this ability to change the rates in order to confuse or mislead potential thieves. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n. There are n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. The maze has this ability to change the rates in order to confuse or mislead potential thieves. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\nWrite a main() function and use input() function to read input from stdin", " \nChanek Jones has returned to assist his distant relative, Indiana Jones, in searching for a hidden treasure within a maze buried beneath a desert landscape filled with deceptive appearances.\n\nThe labyrinth's map is structured as a tree, composed of n rooms, each numbered from 1 to n, and connected by n - 1 tunnels, allowing travel between any two rooms through these pathways.\n\nEach room i (1 \u2264 i \u2264 n) has an associated illusion rate, denoted as a_i. The energy required to move from room x to room y is determined by the formula max(|a_x +\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\nWrite a main() function and use input() function to read input from stdin", " Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n. There are n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels. The i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple, Dict\nimport sys\n\n# Assuming a graph representation using adjacency list\nGraph = List[List[int]]\n\n# Function to build the tree using the given edges\ndef build_tree(n: int, edges: List[Tuple[int, int]]) -> Graph:\n    tree = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    return tree\n\n# Function to update the illusion rate of a room\ndef update_illusion_rate(room: int, new_rate: int) -> None:\n    illusion_rates[room] = new_rate\n\n# Function to calculate the minimum energy required to travel between two rooms using DFS\ndef calculate_energy(start_room: int, end_room: int, tree: Graph, illusion_rates: List[int]) -> int:\n    stack = [(start_room, -1, 0)]  # (current_room, parent, current_energy)\n    visited = set()\n\n    while stack:\n        current_room, parent, current_energy = stack.pop()\n        if current_room == end_room:\n            return current_energy\n        visited.add(current_room)\n        for neighbor in tree[current_room]:\n            if neighbor != parent and neighbor not in visited:\n                next_energy = current_energy + max(abs(illusion_rates[current_room] + illusion_rates[neighbor]), abs(illusion_rates[current_room] - illusion_rates[neighbor]))\n                stack.append((neighbor, current_room, next_energy))\n    return -1  # If no path is found, which should not happen as per the problem statement\n\n# Read input\nn, q = map(int, sys.stdin.readline().split())\nillusion_rates = [0] + list(map(int, sys.stdin.readline().split()))\nedges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n - 1)]\n\n# Build the tree\ntree = build_tree(n, edges)\n\n# Process queries\nfor _ in range(q):\n    query = list(map(int, sys.stdin.readline().split()))\n    if query[0] == 1:\n        update_illusion_rate(query[1], query[2])\n    elif query[0] == 2:\n        result = calculate_energy(query[1], query[2], tree, illusion_rates)\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Dict\nimport sys\n\n# Define the tree structure and its properties\nclass TreeNode:\n    def __init__(self, room_index: int, illusion_rate: int):\n        self.room_index = room_index\n        self.illusion_rate = illusion_rate\n        self.children: List[TreeNode] = []\n\n# Function to build the tree structure from the given edges\ndef build_tree(n: int, edges: List[Tuple[int, int]], illusion_rates: List[int]) -> List[TreeNode]:\n    nodes = [TreeNode(i, illusion_rates[i - 1]) for i in range(1, n + 1)]\n    for s, t in edges:\n        nodes[s - 1].children.append(nodes[t - 1])\n        nodes[t - 1].children.append(nodes[s - 1])\n    return nodes\n\n# Function to pre-process the tree to calculate the minimum energy required for each pair of rooms\ndef preprocess_tree(nodes: List[TreeNode]):\n    n = len(nodes)\n    # Initialize the energy matrix with infinity\n    energy_matrix = [[sys.maxsize] * n for _ in range(n)]\n    \n    # Helper function to calculate energy between two rooms using DFS\n    def dfs(node: TreeNode, parent: TreeNode, room_index: int, energy_matrix: List[List[int]]):\n        energy_matrix[room_index][room_index] = 0\n        for child in node.children:\n            if child != parent:\n                dfs(child, node, room_index, energy_matrix)\n                for i in range(n):\n                    energy_matrix[room_index][i] = min(energy_matrix[room_index][i], energy_matrix[child.room_index][i] + abs(node.illusion_rate - child.illusion_rate))\n    \n    # Calculate energy for each room\n    for i in range(n):\n        dfs(nodes[i], None, i, energy_matrix)\n    \n    return energy_matrix\n\n# Function to handle dynamic updates to the illusion rates of rooms\ndef update_illusion_rate(nodes: List[TreeNode], room_index: int, new_rate: int):\n    nodes[room_index - 1].illusion_rate = new_rate\n\n# Function to respond to queries by calculating the minimum energy based on the current state of the tree\ndef calculate_minimum_energy(energy_matrix: List[List[int]], start_room: int, end_room: int) -> int:\n    return energy_matrix[start_room - 1][end_room - 1]\n\n# Main function to handle input and output\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    illusion_rates = list(map(int, sys.stdin.readline().split()))\n    edges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n - 1)]\n    \n    nodes = build_tree(n, edges, illusion_rates)\n    energy_matrix = preprocess_tree(nodes)\n    \n    for _ in range(q):\n        query = list(map(int, sys.stdin.readline().split()))\n        if query[0] == 1:\n            u, c = query[1], query[2]\n            update_illusion_rate(nodes, u, c)\n            # Recompute the energy matrix after updating the illusion rate\n            energy_matrix = preprocess_tree(nodes)\n        elif query[0] == 2:\n            u, v = query[1], query[2]\n            result = calculate_minimum_energy(energy_matrix, u, v)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport sys\n\n# Assuming a simple graph representation using adjacency list\nGraph = List[List[int]]\n\n# Function to update the illusion rate of a room\ndef update_illusion_rate(room: int, new_rate: int) -> None:\n    # Implementation to update the illusion rate of the specified room\n    pass\n\n# Function to calculate the minimum energy to reach a room\ndef min_energy_to_reach(start: int, end: int, tree: Graph, illusion_rates: List[int]) -> int:\n    stack = [(start, sys.maxsize)]\n    visited = set()\n    \n    while stack:\n        node, min_energy = stack.pop()\n        if node == end:\n            return min_energy\n        if node not in visited:\n            visited.add(node)\n            for neighbor in tree[node]:\n                energy = max(abs(illusion_rates[node - 1] + illusion_rates[neighbor - 1]), abs(illusion_rates[node - 1] - illusion_rates[neighbor - 1]))\n                stack.append((neighbor, min(min_energy, energy)))\n    return sys.maxsize  # Return the maximum possible energy if no path is found\n\n# Function to represent the maze as a tree using an adjacency list\ndef build_tree(n: int, edges: List[Tuple[int, int]]) -> Graph:\n    tree = [[] for _ in range(n + 1)]\n    for s, t in edges:\n        tree[s].append(t)\n        tree[t].append(s)\n    return tree\n\n# Main function to handle queries\ndef handle_queries(n: int, q: int, a: List[int], edges: List[Tuple[int, int]], queries: List[List[int]]) -> None:\n    tree = build_tree(n, edges)\n    illusion_rates = a\n    \n    for query in queries:\n        query_type = query[0]\n        if query_type == 1:\n            room, new_rate = query[1], query[2]\n            update_illusion_rate(room, new_rate)\n        elif query_type == 2:\n            start, end = query[1], query[2]\n            result = min_energy_to_reach(start, end, tree, illusion_rates)\n            print(result)\n\n# Example usage\nif __name__ == \"__main__\":\n    # Reading input\n    n, q = map(int, input().split())\n    a = list(map(int, input().split()))\n    edges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [list(map(int, input().split())) for _ in range(q)]\n    \n    # Processing queries\n    handle_queries(n, q, a, edges, queries)\n", "from typing import List\nfrom typing import List\n\ndef calculate_energy(n: int, rooms: List[int], edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n    # Initialize the graph as an adjacency list\n    graph = [[] for _ in range(n + 1)]\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n    \n    # Function to calculate the energy between two rooms\n    def calculate_energy_between(x: int, y: int) -> int:\n        a_x = rooms[x - 1]\n        a_y = rooms[y - 1]\n        return max(abs(a_x + a_y), abs(a_x - a_y))\n    \n    # Initialize the result list for queries\n    results = []\n    \n    # Process each query\n    for query in queries:\n        room_index = query[0]\n        new_illusion_rate = query[1]\n        \n        # Update the illusion rate of the specified room\n        rooms[room_index - 1] = new_illusion_rate\n        \n        # Recalculate the energy for the query\n        energy = 0\n        for edge in edges:\n            energy += calculate_energy_between(edge[0], edge[1])\n        results.append(energy)\n    \n    return results\n\n# Read input\nn = int(input())\nrooms = list(map(int, input().split()))\nedges = [list(map(int, input().split())) for _ in range(n - 1)]\nqueries = [list(map(int, input().split())) for _ in range(int(input()))]\n\n# Calculate and print the results\nresult = calculate_energy(n, rooms, edges, queries)\nfor r in result:\n    print(r)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\nclass Maze:\n    def __init__(self, rooms: List[int], tunnels: List[List[int]]):\n        self.rooms = rooms\n        self.tunnels = tunnels\n        self.graph = self._build_graph()\n\n    def _build_graph(self):\n        graph = {i: [] for i in range(1, len(self.rooms) + 1)}\n        for tunnel in self.tunnels:\n            room1, room2 = tunnel\n            graph[room1].append(room2)\n            graph[room2].append(room1)\n        return graph\n\n    def dfs(self, start: int, end: int) -> int:\n        stack = [(start, float('inf'))]\n        visited = set()\n        while stack:\n            node, max_illusion = stack.pop()\n            if node == end:\n                return max_illusion\n            if node not in visited:\n                visited.add(node)\n                for neighbor in self.graph[node]:\n                    stack.append((neighbor, min(max_illusion, self.rooms[node - 1])))\n        return float('inf')\n\ndef calculate_energy(rooms: List[int], queries: List[List[int]]) -> List[int]:\n    \"\"\"\n    Calculate the minimum energy required to move between rooms in a maze based on illusion rates.\n\n    Args:\n        rooms (List[int]): List of illusion rates for each room.\n        queries (List[List[int]]): List of queries, each containing a start and end room number.\n\n    Returns:\n        List[int]: List of minimum energy required for each query.\n    \"\"\"\n    n = len(rooms)\n    tunnels = []\n    for i in range(1, n):\n        tunnels.append([i, i + 1])\n\n    maze = Maze(rooms, tunnels)\n    results = []\n\n    for query in queries:\n        start, end = query\n        energy = maze.dfs(start, end)\n        results.append(energy)\n\n    return results\n\n# Read input from stdin\nn, q = map(int, input().split())\na_i = list(map(int, input().split()))\nqueries = [list(map(int, input().split())) for _ in range(q)]\n\n# Call the calculate_energy function and print the results\nresult = calculate_energy(a_i, queries)\nfor r in result:\n    print(r)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef read_input() -> Tuple[int, int, List[int], List[Tuple[int, int]]]:\n    n, q = map(int, input().split())\n    rooms = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    return n, q, rooms, tunnels, queries\n\ndef calculate_energy(n: int, rooms: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]:\n    # Create adjacency list for the tree\n    adj_list = [[] for _ in range(n + 1)]\n    for s, t in tunnels:\n        adj_list[s].append(t)\n        adj_list[t].append(s)\n\n    # Initialize energy array\n    energy = [0] * (n + 1)\n\n    # Function to perform DFS and calculate energy\n    def dfs(node: int, parent: int):\n        for child in adj_list[node]:\n            if child != parent:\n                energy[child] = max(abs(rooms[child - 1] + rooms[node - 1]), abs(rooms[child - 1] - rooms[node - 1]))\n                dfs(child, node)\n\n    # Start DFS from room 1\n    dfs(1, -1)\n\n    # Process queries\n    results = []\n    for query in queries:\n        query_type = query[0]\n        if query_type == 1:\n            room_idx, new_illusion_rate = query[1], query[2]\n            rooms[room_idx - 1] = new_illusion_rate\n            # Re-calculate energy for affected paths\n            def re_calculate_energy(node: int, parent: int):\n                for child in adj_list[node]:\n                    if child != parent:\n                        energy[child] = max(abs(rooms[child - 1] + rooms[node - 1]), abs(rooms[child - 1] - rooms[node - 1]))\n                        re_calculate_energy(child, node)\n            re_calculate_energy(1, -1)\n        elif query_type == 2:\n            start, end = query[1], query[2]\n            # Calculate energy for the path from start to end\n            total_energy = 0\n            current = start\n            for next_node in adj_list[current]:\n                if next_node != end:\n                    total_energy += energy[next_node]\n                    current = next_node\n            results.append(total_energy + energy[end])\n    return results\n\n# Main function to read input, calculate energy, and print results\ndef main():\n    n, q, rooms, tunnels, queries = read_input()\n    results = calculate_energy(n, rooms, tunnels, queries)\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\nfrom typing import List\nimport sys\n\n# Function to calculate the minimum energy required to traverse the tree-like maze\ndef calculate_min_energy(n: int, rooms: List[int], tunnels: List[List[int]], queries: List[List[int]]) -> List[int]:\n    # Initialize the adjacency list to represent the tree\n    adj_list = [[] for _ in range(n + 1)]\n    \n    # Build the tree structure from the given tunnels\n    for s, t in tunnels:\n        adj_list[s].append(t)\n        adj_list[t].append(s)\n    \n    # Function to perform depth-first search to calculate the minimum energy\n    def dfs(node: int, parent: int):\n        # Initialize the energy array for this node\n        energy = [0] * (n + 1)\n        # Traverse the children of this node\n        for child in adj_list[node]:\n            if child != parent:\n                # Recursively calculate the energy for the child\n                child_energy = dfs(child, node)\n                # Update the energy for the current node\n                for i in range(1, n + 1):\n                    for j in range(1, n + 1):\n                        if i != j:\n                            energy[i] = max(energy[i], abs(rooms[i - 1] - rooms[j - 1]) + abs(rooms[i - 1] + rooms[j - 1]))\n        return energy\n    \n    # Perform a depth-first search starting from room 1\n    result = dfs(1, -1)\n    \n    # Process the queries to find the minimum energy required for each query\n    results = []\n    for query in queries:\n        x, y = query[1], query[2]\n        results.append(result[x] + result[y])\n    \n    return results\n\n# Read input from stdin\nn = int(input().strip())\nrooms = list(map(int, input().strip().split()))\ntunnels = [list(map(int, input().strip().split())) for _ in range(n - 1)]\nqueries = [list(map(int, input().strip().split())) for _ in range(int(input().strip()))]\n\n# Calculate the minimum energy required for each query\nresult = calculate_min_energy(n, rooms, tunnels, queries)\n\n# Print the results\nfor res in result:\n    print(res)\n", "from typing import List\nfrom typing import List, Tuple\n\ndef calculate_min_energy(n: int, rooms: List[int], tunnels: List[Tuple[int, int]], queries: List[List[int]]) -> List[int]:\n    # Initialize the graph as an adjacency list\n    graph = [[] for _ in range(n + 1)]\n    \n    # Build the graph from the tunnels\n    for s, t in tunnels:\n        graph[s].append(t)\n        graph[t].append(s)\n    \n    # Helper function to calculate the energy between two rooms\n    def calculate_energy(room1: int, room2: int) -> int:\n        return max(abs(rooms[room1 - 1] - rooms[room2 - 1]), abs(rooms[room1 - 1] + rooms[room2 - 1]))\n    \n    # Function to calculate the minimum energy to traverse the tree\n    def calculate_tree_energy(root: int) -> int:\n        stack = [root]\n        visited = set([root])\n        energy = 0\n        \n        while stack:\n            node = stack.pop()\n            energy += rooms[node - 1]\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    stack.append(neighbor)\n        \n        return energy\n    \n    # Process queries\n    results = []\n    for query in queries:\n        query_type = query[0]\n        if query_type == 1:\n            room_index = query[1]\n            new_illusion_rate = query[2]\n            rooms[room_index - 1] = new_illusion_rate\n        elif query_type == 2:\n            results.append(calculate_tree_energy(1))\n    \n    return results\n\n# Read input from stdin\nn = int(input())\nrooms = list(map(int, input().split()))\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [list(map(int, input().split())) for _ in range(int(input()))]\n\n# Calculate and print the results\nresult = calculate_min_energy(n, rooms, tunnels, queries)\nfor r in result:\n    print(r)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport sys\n\n# Function to build the tree structure from the given tunnels\ndef build_tree(n: int, tunnels: List[Tuple[int, int]]) -> List[List[int]]:\n    tree = [[] for _ in range(n + 1)]\n    for s, t in tunnels:\n        tree[s].append(t)\n        tree[t].append(s)\n    return tree\n\n# Function to calculate the minimum energy required for a given query using DFS\ndef calculate_energy_dfs(room: int, parent: int, rooms: List[int], tree: List[List[int]]) -> int:\n    energy = rooms[room - 1]\n    for child in tree[room]:\n        if child != parent:\n            child_energy = calculate_energy_dfs(child, room, rooms, tree)\n            energy = max(energy, rooms[room - 1] + child_energy)\n            energy = max(energy, abs(rooms[room - 1] - child_energy))\n    return energy\n\n# Main function to calculate the minimum energy required for each query\ndef calculate_energy(rooms: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    n = len(rooms)\n    tree = build_tree(n, tunnels)\n    results = []\n    for query in queries:\n        room1, room2, room3 = query\n        # Calculate the minimum energy for the given query\n        # Assuming room1 is the starting room and room2 is the target room\n        # room3 is ignored as it is not used in the current implementation\n        # The actual logic should be implemented here based on the query\n        # For now, let's assume we are calculating the energy for a path\n        # This is a placeholder for the actual logic\n        energy = calculate_energy_dfs(room1, -1, rooms, tree)\n        results.append(energy)\n    return results\n\n# Read input from stdin\nn, q = map(int, sys.stdin.readline().split())\nrooms = list(map(int, sys.stdin.readline().split()))\ntunnels = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, sys.stdin.readline().split())) for _ in range(q)]\n\n# Calculate the energy and print the results\nresults = calculate_energy(rooms, tunnels, queries)\nfor res in results:\n    print(res)\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict, Tuple\nimport sys\n\n# Initialize the tree as an adjacency list\ntree: Dict[int, List[int]] = {}\n# Store the illusion rates for each room\nillusion_rates: List[int] = []\n\ndef update_illusion_rate(room: int, new_rate: int) -> None:\n    \"\"\"\n    Update the illusion rate of the specified room.\n    \n    Args:\n        room (int): The room number to update.\n        new_rate (int): The new illusion rate.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_minimum_energy(start: int, end: int) -> int:\n    \"\"\"\n    Calculate the minimum energy required to travel from the start room to the end room.\n    \n    Args:\n        start (int): The starting room number.\n        end (int): The ending room number.\n    \n    Returns:\n        int: The minimum energy required to travel from the start room to the end room.\n    \"\"\"\n    def dfs(room: int, parent: int) -> Tuple[int, int]:\n        \"\"\"\n        Depth-first search to calculate the minimum energy and maximum illusion rate along the path.\n        \n        Args:\n            room (int): The current room number.\n            parent (int): The parent room number.\n        \n        Returns:\n            Tuple[int, int]: A tuple containing the minimum energy and the maximum illusion rate along the path.\n        \"\"\"\n        min_energy = float('inf')\n        max_illusion = illusion_rates[room - 1]\n        \n        for child in tree[room]:\n            if child != parent:\n                energy, max_child_illusion = dfs(child, room)\n                min_energy = min(min_energy, energy)\n                max_illusion = max(max_illusion, max_child_illusion)\n        \n        if start != room and end != room:\n            min_energy = min(min_energy, max(abs(illusion_rates[start - 1] + illusion_rates[room - 1]), abs(illusion_rates[start - 1] - illusion_rates[room - 1])))\n            min_energy = min(min_energy, max(abs(illusion_rates[end - 1] + illusion_rates[room - 1]), abs(illusion_rates[end - 1] - illusion_rates[room - 1])))\n        else:\n            for child in tree[room]:\n                if child != parent:\n                    min_energy = min(min_energy, max(abs(illusion_rates[start - 1] + illusion_rates[child - 1]), abs(illusion_rates[start - 1] - illusion_rates[child - 1])))\n                    min_energy = min(min_energy, max(abs(illusion_rates[end - 1] + illusion_rates[child - 1]), abs(illusion_rates[end - 1] - illusion_rates[child - 1])))\n        \n        return min_energy, max_illusion\n    \n    min_energy, _ = dfs(start, -1)\n    return min_energy\n\n# Read input\nn, q = map(int, sys.stdin.readline().split())\nillusion_rates = list(map(int, sys.stdin.readline().split()))\n\n# Build the tree as an adjacency list\nfor _ in range(n - 1):\n    s, t = map(int, sys.stdin.readline().split())\n    if s not in tree:\n        tree[s] = []\n    if t not in tree:\n        tree[t] = []\n    tree[s].append(t)\n    tree[t].append(s)\n\n# Process queries\nfor _ in range(q):\n    query = list(map(int, sys.stdin.readline().split()))\n    if query[0] == 1:\n        update_illusion_rate(query[1], query[2])\n    elif query[0] == 2:\n        result = calculate_minimum_energy(query[1], query[2])\n        print(result)\n"], "plans": ["requirement analysis:\nThe project requires a system to handle a tree structure representing the maze, where each node has an associated value representing the illusion rate. Queries involve updating the illusion rate of a room and calculating the minimum energy required to travel between two rooms. The solution must be efficient enough to handle up to 10^5 rooms and 10^5 queries.\nrequirement pool:\n- Implement a tree data structure to represent the maze.\n- Handle queries to update illusion rates and calculate energy consumption.\n- Ensure the system is responsive and can handle large inputs efficiently.\n- Design a user-friendly interface for updating illusion rates and querying energy consumption.\nTo tackle the problem, we will use a combination of a tree data structure and graph traversal algorithms. The tree structure will represent the maze, and each node will have an associated value representing the illusion rate. We will use a depth-first search (DFS) algorithm to calculate the minimum energy required to travel between two rooms. The system will be designed to handle up to 10^5 rooms and 10^5 queries efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree data structure': represents the maze as a graph with nodes and edges, where nodes are rooms and edges are tunnels.\n    'illusion rate': the value associated with each room that affects the energy required to travel between rooms.\n    'DFS (Depth-First Search)': a graph traversal algorithm used to explore nodes and edges of the tree to find the minimum energy required for travel.\n\n# [phrase showing quantity relationship]\n    'more than': used to indicate that the energy required to travel between rooms depends on the absolute values of the sum or difference of the illusion rates of the rooms.\n\n# [degree adverb] \n    'minimum': indicates that we need to find the smallest amount of energy required for travel between rooms.\n\n# [code logic]\n    To implement the solution, we will:\n    1. Build the tree using the given edges.\n    2. Store the illusion rates for each room.\n    3. For each query of type 2, use DFS to find the minimum energy path between the two rooms.\n    4. Calculate the energy using the formula max(|a_x + a_y|, |a_x - a_y|).\n\n# [edge case] \n    Edge case 1:\n    Query: 2 1 2\n    Explanation: There is a direct tunnel between room 1 and room 2 with illusion rates a_1 and a_2. The minimum energy required to travel is max(|a_1 + a_2|, |a_1 - a_2|).\n    Expected output: max(|a_1 + a_2|, |a_1 - a_2|)\n\n    Edge case 2:\n    Query: 2 3 5\n    Explanation: There is no direct tunnel between room 3 and room 5. We need to find the path with the minimum energy. For example, if the path is 3 -> 1 -> 5, the energy would be max(|a_3 + a_1|, |a_3 - a_1|) + max(|a_1 + a_5|, |a_1 - a_5|).\n    Expected output: The actual minimum energy calculated by DFS traversal.\n\n    Edge case 3:\n    Query: 1 4 10\n    Explanation: The illusion rate of room 4 is changed to 10. This affects all paths that pass through room 4, potentially increasing the energy required for some paths.\n    Expected output: The actual minimum energy after changing the illusion rate, recalculated using DFS.\n\n# [extra code for edge case]\n    We may need to handle the case where the tree structure changes due to room illusion rate changes, which could affect the paths and energy calculations. This would require re-running DFS or updating the tree structure to maintain efficiency.\n", "requirement analysis:\nThe project requires a system to handle a tree structure representing the maze, where each node has an associated value representing the illusion rate. Queries involve updating the illusion rate of a room and calculating the minimum energy required to travel from one room to another. The solution should be efficient enough to handle up to 10^5 rooms and 10^5 queries.\nrequirement pool:\n- Implement a tree data structure to represent the maze.\n- Handle queries to update the illusion rate of a room and calculate the minimum energy required to travel between rooms.\n- Ensure the solution is efficient enough to handle the constraints of the problem.\n- Design a user-friendly interface for interacting with the system.\nTo tackle the problem, we will utilize a tree data structure to represent the maze, where each node holds information about its illusion rate. We will handle queries efficiently by pre-processing the tree to compute the minimum energy required for each pair of rooms. This will involve using a depth-first search (DFS) to traverse the tree and calculate the energy costs. We will also implement a function to update the illusion rates of rooms dynamically.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree data structure': represents the maze as a graph with nodes and edges, where nodes are rooms and edges are tunnels.\n    'illusion rate': the value associated with each room that affects the energy required to travel through it.\n    'DFS (Depth-First Search)': a method for traversing or searching tree or graph data structures. It starts at the root (or an arbitrary node) and explores as far as possible along each branch before backtracking.\n\n# [phrase showing quantity relationship]\n    'more than': used to compare the illusion rates of rooms to determine energy costs.\n    'at least as many times': not directly applicable in this context, but the concept of frequency is used to find the maximum illusion rate that appears at least as many times as its value.\n\n# [degree adverb] \n    'largest': used to find the maximum illusion rate that meets the condition of appearing at least as many times as its value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan involves:\n    1. Building the tree structure from the given edges.\n    2. Pre-processing the tree to calculate the minimum energy required for each pair of rooms.\n    3. Handling dynamic updates to the illusion rates of rooms.\n    4. Responding to queries by calculating the minimum energy based on the current state of the tree.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if not lst:\n            return -1\n        freq = {}\n        for num in lst:\n            freq[num] = freq.get(num, 0) + 1\n        for num, count in freq.items():\n            if num >= count:\n                return num\n        return -1\n", "requirement analysis:\nThe project requires a system to handle a tree structure representing the maze, where each node has an associated value representing the illusion rate. Queries involve updating the illusion rate of a room and calculating the minimum energy required to travel from one room to another. The solution must be efficient to handle the constraints of n and q being up to 10^5.\nrequirement pool:\n- Implement a tree data structure to represent the maze.\n- Handle queries to update illusion rates and calculate energy.\n- Ensure the solution is optimized for large inputs.\n- Improve user interface for better user experience.\n- Add mobile compatibility for on-the-go gameplay.\nTo tackle the problem, we will use a tree data structure to represent the maze, where each node holds information about its illusion rate. We will employ a graph traversal algorithm, such as Depth-First Search (DFS), to calculate the minimum energy required to travel between rooms. For efficient updates, we will use a Fenwick tree or a Segment tree to manage the illusion rates and quickly compute the energy cost for any given path.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree data structure': represents the maze as a graph with nodes and edges, where nodes are rooms and edges are tunnels.\n    'illusion rate': the effect on energy required to travel between rooms.\n    'graph traversal algorithm': used to find the minimum energy path between rooms.\n    'Fenwick tree or Segment tree': data structure for efficient updates and queries on the illusion rates.\n\n# [phrase showing quantity relationship]\n    'more than': used to compare the illusion rates for determining energy cost.\n    'at least as many times': not directly applicable in this context, but the concept of frequency is important for understanding the queries.\n\n# [degree adverb] \n    'largest': not directly applicable in this context, but the idea of maximizing or minimizing energy is important for the queries.\n\n# [code logic]\n    The plan involves:\n    1. Representing the maze as a tree.\n    2. Storing the illusion rates for each room.\n    3. Using DFS to traverse the tree and calculate the minimum energy for each query.\n    4. Handling updates to the illusion rates using a suitable data structure.\n\n# [edge case] \n    Query type 2 with rooms u=1 and v=n in a small tree with only 3 rooms:\n        Edge case 1: 1 1 3\n        Explanation: The tree has only 3 rooms, and the direct path from room 1 to room 3 is the only possible path. The energy cost is max(|a_1 + a_3|, |a_1 - a_3|).\n        Expected output: The actual energy cost based on the illusion rates.\n\n    Edge case 2: 1 2 0\n        Explanation: The illusion rate of room 2 is changed to 0. This could potentially reduce the energy cost for paths involving room 2.\n        Expected output: The updated minimum energy for any path from room 1 to room n after the change.\n\n    Edge case 3: 2 1 3\n        Explanation: Chanek and Indiana ask for the minimum energy to reach the secret treasure in room 3 starting from room 1. This could involve multiple paths, and the minimum energy should be calculated considering all possible routes.\n        Expected output: The actual minimum energy required to reach room 3 from room 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the query involves a direct path between two rooms without intermediate nodes, as the tree structure might not be immediately apparent.\n    Example code:\n        if u == v:\n            return 0  # No energy is needed if starting and ending in the same room.\n        # Implement DFS or BFS to find the minimum energy path between u and v.\n        # Use the illusion rates to calculate the energy cost for each edge in the path.\n", "requirement analysis:\nThe project requires a program to calculate the minimum energy required to traverse a tree-structured maze based on the illusion rates of the rooms. The program must handle queries to update the illusion rates and calculate the energy for given room pairs. The input is structured with the number of rooms and queries, followed by the initial illusion rates and the tree structure of the maze. The output should provide the minimum energy for each query.\nrequirement pool:\n- Implement a function to calculate the energy required to move between rooms based on the illusion rates.\n- Allow for updates to the illusion rates and recalculate the energy accordingly.\n- Ensure the program can handle large inputs efficiently.\n- Design a user-friendly interface for input and output.\n- Optimize the algorithm for handling large trees efficiently.\nTo solve this problem, we will use a graph data structure to represent the tree-structured maze. We will employ a depth-first search (DFS) algorithm to efficiently calculate the energy required to traverse between rooms. The program will handle updates to the illusion rates and recalculate the energy accordingly. We will ensure the program can handle large inputs efficiently by optimizing the algorithm and using appropriate data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': represents the maze as a graph with n rooms and n-1 tunnels, allowing traversal between any two rooms.\n    'illusion rate': a value associated with each room, affecting the energy required to move between rooms.\n    'energy calculation': based on the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of rooms x and y.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    No edge cases provided in the prompt\n\n# [extra code for edge case]\n    No extra code needed for edge cases as the logic provided should handle the general case.\n\nPlease provide the specific coding plan and requirement from the analyst for a detailed analysis.\n", "requirement analysis:\nThe project requires a tree structure for the maze, handling queries to calculate energy based on illusion rates, and providing a user-friendly interface for navigating the maze. The requirements involve understanding tree traversal, handling large inputs efficiently, and ensuring the game is engaging and visually appealing.\nrequirement pool:\n- Implement a tree structure for the maze with n rooms and n-1 tunnels\n- Handle queries to calculate the minimum energy required to move between rooms\n- Provide a user-friendly interface for navigating the maze\n- Optimize the algorithm for handling large inputs efficiently\n- Design an aesthetically pleasing user interface\nTo tackle the challenge of creating a game where players navigate through a maze with varying illusion rates and calculate the minimum energy required to move between rooms, we will use Python due to its efficiency and ease of use with data structures. We will implement a tree structure to represent the maze, where each node represents a room and edges represent tunnels between rooms. To handle queries efficiently, we will use a depth-first search (DFS) algorithm to calculate the minimum energy required for each query. The user interface will be designed to be simple and intuitive, with visual indicators for room numbers and energy requirements.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': represents the maze with rooms and tunnels\n    'illusion rate': value associated with each room that affects energy calculations\n    'energy calculation': formula to determine energy needed to move between rooms based on illusion rates\n\n# [phrase showing quantity relationship]\n    'more than': used to compare illusion rates and energy requirements\n    'at least as many times': not explicitly mentioned in the requirement\n\n# [degree adverb] \n    'largest': used to describe the maximum illusion rate in the context of energy calculations\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Build the tree structure from the given rooms and tunnels\n    - Calculate the illusion rates for each room\n    - Process each query to determine the minimum energy required for travel between rooms\n\n# [edge case] \n    Edge case 1: Query with a single room (n=1, q=1)\n    expected output: 0\n    Explanation: Since there's only one room, no energy is required to move anywhere.\n\n    Edge case 2: Query with a large number of rooms and queries\n    expected output: (depends on the specific values of rooms and queries)\n    Explanation: This edge case checks the efficiency of the algorithm when dealing with a large dataset.\n\n    Edge case 3: Query with rooms having extreme illusion rates\n    expected output: (depends on the specific values of the rooms and queries)\n    Explanation: This edge case checks how the algorithm handles rooms with very high or very low illusion rates.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Ensure the tree structure is correctly built even if the input order is not perfect.\n        - Optimize the energy calculation for large datasets to ensure efficiency.\n        - Handle potential overflow or underflow in the illusion rate calculations.\n", "requirement analysis:\nThe project requires a program to calculate the minimum energy required to traverse a tree-structured maze based on the illusion rates of the rooms. The program should handle two types of queries: updating the illusion rate of a room and calculating the minimum energy for a given path.\nrequirement pool:\n- Implement a tree data structure to represent the maze.\n- Handle queries to update the illusion rate of a room and calculate the minimum energy for a given path.\n- Ensure the program is efficient enough to handle up to 10^5 rooms and 10^5 queries.\n- Design a user-friendly interface for input and output.\nTo solve this problem, we will use a tree data structure to represent the maze and handle the queries efficiently. We will use a depth-first search (DFS) algorithm to calculate the minimum energy required for a given path. The program will be designed to handle up to 10^5 rooms and 10^5 queries efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree data structure': represents the maze as a graph with nodes (rooms) and edges (tunnels)\n    'DFS (Depth-First Search)': algorithm to traverse and search through the tree to calculate the minimum energy required for a path\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    Edge case 1: Single room and no queries\n    Expected output: 0\n    Explanation: If there is only one room and no queries, the energy required to stay in the room is 0.\n\n    Edge case 2: Large number of rooms and queries\n    Expected output: The minimum sum of energy needed for Chanek and Indiana to take the secret treasure based on the given queries.\n    Explanation: This edge case tests the program's ability to handle a large number of rooms and queries efficiently.\n\n    Edge case 3: Changing the illusion rate of a room\n    Expected output: The updated minimum sum of energy needed after changing the illusion rate of a room.\n    Explanation: This edge case tests the program's ability to handle dynamic changes in the maze's structure and illusion rates.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The given plan should be sufficient to handle the queries and changes in the maze's structure.\n", "requirement analysis:\nThe project requires a program to calculate the minimum energy required to traverse a tree-like maze with dynamic illusion rates. The program must handle both querying the current minimum energy and updating the illusion rates of rooms. The solution should be efficient enough to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to calculate the minimum energy required to traverse between two rooms based on their illusion rates.\n- Allow for dynamic updates to the illusion rates of rooms.\n- Ensure the program can handle queries efficiently, even with the potential for large inputs.\n- Design a user-friendly interface for input and output, suitable for both novice and experienced users.\nTo solve this problem, we will use a combination of graph theory and dynamic programming to efficiently calculate the minimum energy required to traverse the tree-like maze. We will leverage the properties of trees and the specific requirements of the problem to develop an optimal solution.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': The maze is represented as a tree with n rooms and n-1 tunnels, allowing traversal between rooms.\n    'illusion rate': The value associated with each room, which affects the energy required to traverse between rooms.\n    'max(|a_x - a_y|, |a_x + a_y|)': The formula used to calculate the energy required for traversal between two rooms based on their illusion rates.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To solve this problem, we need to:\n    1. Build the tree structure from the given tunnels.\n    2. Preprocess the tree to efficiently answer queries about the minimum energy required for traversal between any two rooms.\n    3. Use dynamic programming to calculate the minimum energy for each query.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    n = 3, q = 1\n    a = [1, 2, 3]\n    tunnels = [(1, 2), (1, 3)]\n    query = [(2, 1, 3)]\n    Explanation:\n    The tree structure is a path with three rooms. The minimum energy to travel from room 1 to room 3 is max(|1 - 3|, |1 + 3|) = max(2, 4) = 4.\n    Expected output: 4\n\n    Edge case 2:\n    Input:\n    n = 4, q = 2\n    a = [0, 5, 8, 3]\n    tunnels = [(1, 2), (1, 3), (1, 4)]\n    query = [(2, 2, 3), (2, 3, 4)]\n    Explanation:\n    The tree structure is a star-shaped graph with room 1 at the center.\n    - For the query (2, 2, 3), the minimum energy to travel from room 2 to room 3 is max(|5 - 8|, |5 + 8|) = max(3, 13) = 13.\n    - For the query (2, 3, 4), the minimum energy to travel from room 3 to room 4 is max(|8 - 3|, |8 + 3|) = max(5, 11) = 11.\n    Expected output: 13, 11\n\n    Edge case 3:\n    Input:\n    n = 2, q = 1\n    a = [10, -5]\n    tunnels = [(1, 2)]\n    query = [(2, 1, 2)]\n    Explanation:\n    The tree structure consists of only two rooms connected by one tunnel. The minimum energy to travel from room 1 to room 2 is max(|10 - (-5)|, |10 + (-5)|) = max(15, 5) = 15.\n    Expected output: 15\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The given logic can handle the edge cases directly.\n", "requirement analysis:\nThe project requires a program to calculate the minimum energy required to traverse a tree-like maze based on the illusion rates of the rooms. The program must handle both querying the current minimum energy for a given path and updating the illusion rate of a specific room. The solution should be efficient enough to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to calculate the minimum energy required to traverse the tree-like maze.\n- Allow for updating the illusion rate of a specific room.\n- Ensure the program can handle multiple queries efficiently.\n- Design a user-friendly interface for input and output.\n- Optimize the algorithm to handle large inputs within reasonable time limits.\nTo solve this problem, we will use a graph data structure to represent the maze, where each room is a node and each tunnel is an edge. We will use a tree structure since the maze forms a tree with n rooms and n - 1 tunnels. We will implement a function to calculate the minimum energy required to traverse the tree-like maze, allowing for updating the illusion rate of a specific room and handling multiple queries efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': represents the maze as a graph with nodes (rooms) and edges (tunnels) forming a tree.\n    'illusion rate': the value associated with each room that affects the energy required to traverse the maze.\n    'minimum energy': the sum of energies required to traverse the tree-like maze, considering the illusion rates and the tunnels between rooms.\n\n# [phrase showing quantity relationship]\n    'more than': used to indicate that the energy required to traverse a tunnel is dependent on the absolute difference or sum of the illusion rates of the two connected rooms.\n\n# [degree adverb] \n    'minimum': indicates that we need to find the smallest possible energy required to traverse the maze, considering the given illusion rates and tunnels.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Build the tree structure from the given tunnels.\n    2. Calculate the minimum energy required to traverse the tree for each query.\n    3. Update the illusion rate of a specific room if a query requires it.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, q = 2, a = [1, 2, 3], tunnels = [(1, 2), (2, 3)], queries = [type1, type2]\n    Explanation: The tree structure is a path with rooms 1-2-3. The illusion rates are [1, 2, 3]. There are two queries, both of type 2. The minimum energy required to traverse the tree is the sum of the illusion rates of the rooms, which is 1+2+3 = 6.\n    Expected output: 6\n\n    Edge case 2:\n    Input: n = 4, q = 3, a = [0, 5, 8, 3], tunnels = [(1, 2), (1, 3), (1, 4)], queries = [type1, type2, type2]\n    Explanation: The tree structure is a star-like graph with room 1 at the center and rooms 2, 3, 4 as leaves. The illusion rates are [0, 5, 8, 3]. The first query is of type 1, updating the illusion rate of room 2 to 10. The second and third queries are of type 2, asking for the minimum energy required to traverse the tree after the update and before the update, respectively. The minimum energy before the update is the sum of the illusion rates of the rooms, which is 0+5+8+3 = 16. After the update, the minimum energy is 0+10+8+3 = 21.\n    Expected output: 21, 16\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        For edge case 1, the code is straightforward as it involves calculating the sum of the illusion rates of all rooms.\n        For edge case 2, we need to implement a function to update the illusion rate of a specific room and recalculate the minimum energy required to traverse the tree after each update.\n", "requirement analysis:\nThe project requires a program to calculate the minimum energy required to traverse a tree-like maze with dynamic illusion rates. The program must handle both querying the minimum energy for a given path and updating the illusion rate of a specific room. The solution should be efficient enough to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to calculate the energy required for a given path.\n- Implement a function to update the illusion rate of a room.\n- Ensure the program can handle the input and output format as specified.\n- Optimize the solution to ensure it performs well within the given constraints.\nTo solve this problem, we will use a combination of graph theory and dynamic programming to efficiently calculate the minimum energy required to traverse the tree-like maze. We will use a depth-first search (DFS) approach to handle the queries and updates efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': The maze is represented as a tree with rooms and tunnels connecting them.\n    'illusion rate': The effect on energy required to traverse a tunnel based on the difference or sum of the illusion rates of the rooms it connects.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that a value must be greater than a certain threshold.\n    'at least as many times': Indicates that a value must appear a minimum number of times.\n\n# [degree adverb] \n    'largest': Indicates that the maximum value should be found.\n\n# [code logic]\n    To solve the problem, we need to:\n    1. Build the tree structure from the given tunnels.\n    2. Calculate the minimum energy required for each query.\n    3. Use DFS to traverse the tree and compute the energy efficiently.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, q = 1, a = [1, 2, 3], tunnels = [(1, 2), (2, 3)], query = (2, 1, 3)\n    Explanation: The tree structure is a path from room 1 to room 3. The minimum energy to traverse from room 1 to room 3 is max(|1 - 2|, |1 + 2|) = 3.\n    Expected output: 3\n\n    Edge case 2:\n    Input: n = 4, q = 2, a = [0, 5, 5, 4], tunnels = [(1, 2), (2, 3), (3, 4)], queries = [(2, 1, 4), (2, 2, 4)]\n    Explanation: The tree structure is a path from room 1 to room 4. The minimum energy to traverse from room 1 to room 4 is max(|0 - 5|, |0 + 5|) = 5. For the second query, the minimum energy to traverse from room 2 to room 4 is max(|5 - 4|, |5 + 4|) = 9.\n    Expected output: 5, 9\n\n# [extra code for edge case]\n    No extra code is needed for the given edge cases as the logic provided in the plan should handle them correctly.\n", "requirement analysis:\nThe project requires a system to handle a tree structure representing the maze, where each node has an associated value representing the illusion rate. Queries involve updating the illusion rate of a room and calculating the minimum energy required to travel between two rooms. The solution must be efficient enough to handle up to 10^5 rooms and 10^5 queries.\nrequirement pool:\n- Implement a tree data structure to represent the maze.\n- Handle queries to update illusion rates and calculate energy consumption.\n- Ensure the system is efficient and can handle large inputs.\n- Design a user-friendly interface for interacting with the system.\nTo tackle the problem, we will utilize a tree data structure to represent the maze, where each node holds the illusion rate of the corresponding room. We will implement a function to handle queries for updating the illusion rates and calculating the minimum energy required to travel between two rooms. Given the constraints, we will optimize the solution to ensure it can handle up to 10^5 rooms and 10^5 queries efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree data structure': A tree is a non-linear data structure that simulates a hierarchical tree structure with a set of linked nodes. Each node has a value and can have zero or more child nodes. Trees are used to represent hierarchical relationships between elements.\n\n    'illusion rate': The intensity of the illusion effect in a room, which affects the energy required to travel between rooms.\n\n    'energy calculation': The formula to calculate the energy required to travel between two rooms is max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms x and y, respectively.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the value must be greater than a certain threshold.\n\n# [degree adverb] \n    'minimum': Indicates the smallest possible value of something.\n\n# [code logic]\n    To implement the solution, we need to:\n    1. Represent the maze as a tree using an adjacency list.\n    2. Store the illusion rates for each room.\n    3. Handle two types of queries:\n        - Update the illusion rate of a room.\n        - Calculate the minimum energy required to travel from one room to another.\n    4. Use a depth-first search (DFS) to traverse the tree and calculate the minimum energy.\n\n# [edge case] \n    Edge case 1: Query type 2 with rooms u and v where u is the root of the tree.\n    Expected output: The minimum energy is max(|a_u + a_v|, |a_u - a_v|).\n    Explanation: Since u is the root, there's a direct path from u to v with no other rooms in between. The energy calculation is straightforward.\n\n    Edge case 2: Query type 2 with rooms u and v where v is a leaf node.\n    Expected output: The minimum energy is max(|a_u + a_v|, |a_u - a_v|).\n    Explanation: Since v is a leaf node, the path from u to v goes through all other rooms in the tree. The energy calculation remains straightforward.\n\n    Edge case 3: Query type 2 with rooms u and v where u and v are not directly connected.\n    Expected output: The minimum energy is calculated considering the maximum illusion rate encountered along the path from u to v.\n    Explanation: The path from u to v may involve multiple rooms and tunnels. The energy calculation must account for the maximum illusion rate encountered.\n\n# [extra code for edge case]\n    We need extra code to handle the case where u and v are not directly connected. This can be done using a modified DFS that keeps track of the maximum illusion rate encountered along the path.\n\n    def dfs(room, parent, max_illusion_rate):\n        current_max = max(max_illusion_rate, a[room - 1])\n        min_energy = float('inf')\n        for child in tree[room]:\n            if child != parent:\n                energy = max(abs(a[room - 1] + a[child - 1]), abs(a[room - 1] - a[child - 1]))\n                min_energy = min(min_energy, energy + dfs(child, room, current_max))\n        return min_energy\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 2, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "expand_one2two", "parent_index": 2}
