{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones has returned to aid his distant relative, Indiana Jones, in discovering a hidden treasure within a labyrinth situated beneath a desert filled with illusions.\n\nThe labyrinth's map resembles a tree comprising n rooms numbered from 1 to n. There are n - 1 tunnels linking them, ensuring that every pair of rooms can be reached via various tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) possesses an illusion rate a_i. In order to move from the x-th room to the y-th room, there needs to be a tunnel connecting x and y, and traversing it requires max(|a_x + a_y|, |a_x - a_y|) energy. |z| signifies the absolute value of z.\n\nTo deter potential looters, the labyrinth can alter the illusion rate of any room within it. The labyrinth possesses the capability to adjust these rates to deceive or misguide potential robbers. Chanek and Indiana will present q inquiries.\n\nThe queries to be processed are of two sorts:\n\n  * 1\\ u\\ c \u2014 The illusion level of the x-th room is altered to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the least sum of energy required to retrieve the hidden treasure located in room v if they commence from room u (1 \u2264 u, v \u2264 n).\n\nAssist them, and you can earn a share of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones has returned to aid his distant relative, Indiana Jones, in discovering a hidden treasure within a labyrinth situated beneath a desert filled with illusions.\n\nThe labyrinth's map resembles a tree comprising n rooms numbered from 1 to n. There are n - 1 tunnels linking them, ensuring that every pair of rooms can be reached via various tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) possesses an illusion rate a_i. In order to move from the x-th room to the y-th room, there needs to be a tunnel connecting x and y, and traversing it requires max(|a_x + a_y|, |a_x - a_y|) energy. |z| signifies the absolute value of z.\n\nTo deter potential looters, the labyrinth can alter the illusion rate of any room within it. The labyrinth possesses the capability to adjust these rates to deceive or misguide potential robbers. Chanek and Indiana will present q inquiries.\n\nThe queries to be processed are of two sorts:\n\n  * 1\\ u\\ c \u2014 The illusion level of the x-th room is altered to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the least sum of energy required to retrieve the hidden treasure located in room v if they commence from room u (1 \u2264 u, v \u2264 n).\n\nAssist them, and you can earn a share of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\nWrite a main() function and use input() function to read input from stdin", " \nChanek Jones has returned to help his distant relative, Indiana Jones, in finding a secret treasure inside a maze beneath a desert that has many tricks. The maze's map looks like a tree with rooms numbered from 1 to n, and there are tunnels connecting some rooms to others. Each room has a special number called the \"illusion rate.\" To move from one room to another, you need to go through a tunnel, and it takes a lot of energy, which is the biggest number between the two rooms' rates or the difference between them.\n\nThe maze can change the rates of any room to trick people trying\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\nWrite a main() function and use input() function to read input from stdin", " Chanek Jones has returned to aid his distant relative, Indiana Jones, in discovering a hidden treasure within a labyrinth situated beneath a desert filled with illusions. The labyrinth's map resembles a tree comprising n rooms numbered from 1 to n. There are n - 1 tunnels linking them, ensuring that every pair of rooms can be reached via various tunnels. The i-th room possesses an illusion rate a_i. In order to move from the x-th room to the y-th room, there needs to be a tunnel connecting x and y, and traversing it requires max(|a_x + a_y|, |a\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple, Dict\nimport sys\n\n# Define the tree structure and illusion rates\nclass TreeNode:\n    def __init__(self, room_id: int, illusion_rate: int):\n        self.room_id = room_id\n        self.illusion_rate = illusion_rate\n        self.children: List[TreeNode] = []\n\n    def add_child(self, child: 'TreeNode'):\n        self.children.append(child)\n\n# Function to update the illusion rate of a room\ndef update_illusion_rate(room_id: int, new_rate: int) -> None:\n    current_node = room_id_to_node[room_id]\n    current_node.illusion_rate = new_rate\n\n# Function to calculate the minimum energy required to travel between two rooms\ndef calculate_minimum_energy(start_room: int, end_room: int) -> int:\n    def dfs(node: TreeNode, target: int, path: List[TreeNode], visited: Dict[int, bool]) -> Tuple[List[TreeNode], int]:\n        if node.room_id == target:\n            return path, 0\n        visited[node.room_id] = True\n        min_energy = sys.maxsize\n        min_path = []\n        for child in node.children:\n            if not visited.get(child.room_id, False):\n                new_path, energy = dfs(child, target, path + [child], visited)\n                if energy != -1:\n                    current_energy = max(abs(node.illusion_rate + child.illusion_rate), abs(node.illusion_rate - child.illusion_rate))\n                    if current_energy < min_energy:\n                        min_energy = current_energy\n                        min_path = new_path\n        if min_energy != sys.maxsize:\n            return min_path, min_energy\n        return [], -1\n\n    start_node = room_id_to_node[start_room]\n    end_node = room_id_to_node[end_room]\n    _, energy = dfs(start_node, end_node.room_id, [start_node], {})\n    return energy\n\n# Read input and build the tree\nn, q = map(int, sys.stdin.readline().split())\na_values = list(map(int, sys.stdin.readline().split()))\ntunnels = [list(map(int, sys.stdin.readline().split())) for _ in range(n - 1)]\n\n# Create tree nodes and map room IDs to nodes\nroom_id_to_node = {}\nfor i in range(1, n + 1):\n    room_id_to_node[i] = TreeNode(i, a_values[i - 1])\n\n# Connect nodes based on tunnels\nfor s, t in tunnels:\n    room_id_to_node[s].add_child(room_id_to_node[t])\n    room_id_to_node[t].add_child(room_id_to_node[s])\n\n# Process queries\nfor _ in range(q):\n    query = list(map(int, sys.stdin.readline().split()))\n    if query[0] == 1:\n        update_illusion_rate(query[1], query[2])\n    elif query[0] == 2:\n        result = calculate_minimum_energy(query[1], query[2])\n        print(result)\n", "from typing import List\nimport sys\nfrom typing import List, Tuple\n\n# Assuming we are using a graph library like networkx for tree representation\n# import networkx as nx\n# from networkx import Graph\n\n# Global variables to store the tree and illusion rates\n# graph = Graph()\nillusion_rates = []\n\n# Function to update the illusion rate of a room\ndef update_illusion_rate(room: int, new_rate: int) -> None:\n    global illusion_rates\n    illusion_rates[room - 1] = new_rate\n\n# Function to calculate the minimum energy required to travel from one room to another\ndef calculate_energy(start_room: int, end_room: int) -> int:\n    global illusion_rates\n    \n    # If all rooms have the same illusion rate, return that rate\n    if all(a_i == illusion_rates[0] for a_i in illusion_rates):\n        return illusion_rates[0]\n    \n    # Implementing a simple DFS for energy calculation\n    def dfs(node: int, target: int, current_energy: int, min_energy: int) -> int:\n        if node == target:\n            return min(min_energy, current_energy)\n        \n        for neighbor in graph[node]:\n            new_energy = max(abs(illusion_rates[node - 1] + illusion_rates[neighbor - 1]), abs(illusion_rates[node - 1] - illusion_rates[neighbor - 1]))\n            min_energy = dfs(neighbor, target, current_energy + new_energy, min_energy)\n        \n        return min_energy\n    \n    return dfs(start_room, end_room, 0, sys.maxsize)\n\n# Reading input and setting up the graph\nn, q = map(int, sys.stdin.readline().split())\nillusion_rates = list(map(int, sys.stdin.readline().split()))\ntunnels = [list(map(int, sys.stdin.readline().split())) for _ in range(n - 1)]\n\n# Setting up the graph (tree) representation\n# for s, t in tunnels:\n#     graph.add_edge(s, t)\n\n# Processing queries\nfor _ in range(q):\n    query = list(map(int, sys.stdin.readline().split()))\n    if query[0] == 1:\n        update_illusion_rate(query[1], query[2])\n    elif query[0] == 2:\n        result = calculate_energy(query[1], query[2])\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict, Tuple\nimport sys\n\n# Define the tree as an adjacency list\nTree = Dict[int, List[int]]\n\n# Initialize the tree and illusion rates\ndef initialize_tree(n: int, tunnels: List[Tuple[int, int]], a_values: List[int]) -> Tuple[Tree, Dict[int, int]]:\n    tree: Tree = {i: [] for i in range(1, n + 1)}\n    illusion_rates: Dict[int, int] = {}\n\n    for s, t in tunnels:\n        tree[s].append(t)\n        tree[t].append(s)\n\n    for i, rate in enumerate(a_values, start=1):\n        illusion_rates[i] = rate\n\n    return tree, illusion_rates\n\n# Calculate the energy required to traverse between two rooms\ndef calculate_energy(a_x: int, a_y: int) -> int:\n    return max(abs(a_x + a_y), abs(a_x - a_y))\n\n# Update the illusion rate of a room\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: Dict[int, int]) -> None:\n    illusion_rates[room] = new_rate\n\n# Find the minimum energy required to travel between two rooms\ndef min_energy_required(start_room: int, end_room: int, tree: Tree, illusion_rates: Dict[int, int]) -> int:\n    if start_room == end_room:\n        return 0\n\n    visited = set()\n    stack = [(start_room, 0)]\n    min_energy = sys.maxsize\n\n    while stack:\n        current_room, current_energy = stack.pop()\n        if current_room in visited:\n            continue\n        visited.add(current_room)\n\n        current_rate = illusion_rates[current_room]\n        for neighbor in tree[current_room]:\n            if neighbor not in visited:\n                neighbor_rate = illusion_rates[neighbor]\n                energy = calculate_energy(current_rate, neighbor_rate) + current_energy\n                if neighbor == end_room:\n                    min_energy = min(min_energy, energy)\n                else:\n                    stack.append((neighbor, energy))\n\n    return min_energy\n\n# Main function to process queries\ndef process_queries(n: int, q: int, a_values: List[int], tunnels: List[Tuple[int, int]]) -> None:\n    tree, illusion_rates = initialize_tree(n, tunnels, a_values)\n\n    for _ in range(q):\n        query = list(map(int, sys.stdin.readline().split()))\n        if query[0] == 1:\n            update_illusion_rate(query[1], query[2], illusion_rates)\n        elif query[0] == 2:\n            result = min_energy_required(query[1], query[2], tree, illusion_rates)\n            print(result)\n\n# Read input and process queries\nn, q = map(int, sys.stdin.readline().split())\na_values = list(map(int, sys.stdin.readline().split()))\ntunnels = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n - 1)]\n\nprocess_queries(n, q, a_values, tunnels)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_energy(n: int, rooms: List[int], tunnels: List[List[int]], queries: List[List[int]]) -> List[int]:\n    # Initialize the adjacency list to represent the tree\n    tree = [[] for _ in range(n + 1)]\n    \n    # Build the tree using the tunnels\n    for u, v in tunnels:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Function to calculate the minimum energy required to traverse from one room to another\n    def calculate_energy(room1: int, room2: int) -> int:\n        return max(abs(rooms[room1 - 1]), abs(rooms[room2 - 1]), abs(rooms[room1 - 1] - rooms[room2 - 1]))\n    \n    # Process the queries\n    results = []\n    for query in queries:\n        room1, room2 = query\n        results.append(calculate_energy(room1, room2))\n    \n    return results\n\n# Interface to read input and call the function\nn = int(input())\nrooms = list(map(int, input().split()))\ntunnels = [list(map(int, input().split())) for _ in range(n - 1)]\nqueries = [list(map(int, input().split())) for _ in range(int(input()))]\n\nresult = calculate_minimum_energy(n, rooms, tunnels, queries)\nfor r in result:\n    print(r)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_energy(n: int, rooms: List[int], tunnels: List[List[int]], queries: List[List[int]]) -> List[int]:\n    # Initialize the energy matrix with infinity\n    energy = [[float('inf') for _ in range(n + 1)] for _ in range(n + 1)]\n    \n    # Create adjacency list for the tree\n    adj_list = [[] for _ in range(n + 1)]\n    for u, v in tunnels:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Function to calculate the energy between two rooms\n    def calculate_energy_between(room1: int, room2: int) -> int:\n        return max(abs(rooms[room1 - 1]), abs(rooms[room2 - 1]), abs(rooms[room1 - 1] - rooms[room2 - 1]))\n    \n    # Function to perform DFS and fill the energy matrix\n    def dfs(node: int, parent: int):\n        for child in adj_list[node]:\n            if child != parent:\n                dfs(child, node)\n                for i in range(1, n + 1):\n                    for j in range(1, n + 1):\n                        energy[node][j] = min(energy[node][j], energy[node][i] + energy[child][j] + calculate_energy_between(i - 1, j - 1))\n                        energy[j][node] = energy[node][j]  # Symmetric\n    \n    # Initialize the energy matrix with direct tunnel energies\n    for i in range(1, n + 1):\n        energy[i][i] = 0\n        for j in adj_list[i]:\n            energy[i][j] = calculate_energy_between(i - 1, j - 1)\n            energy[j][i] = energy[i][j]\n    \n    # Perform DFS to update the energy matrix\n    dfs(1, -1)\n    \n    # Process queries\n    results = []\n    for query in queries:\n        room, new_illusion_rate = query\n        rooms[room - 1] = new_illusion_rate\n        dfs(1, -1)  # Re-run DFS to update energies after changing a room's illusion rate\n        results.append(energy[1][n])  # Assuming the result is the energy from room 1 to room n\n    \n    return results\n\n# Read input\nn = int(input())\nrooms = list(map(int, input().split()))\ntunnels = [list(map(int, input().split())) for _ in range(n - 1)]\nqueries = [list(map(int, input().split())) for _ in range(int(input()))]\n\n# Calculate and print results\nresult = calculate_energy(n, rooms, tunnels, queries)\nfor r in result:\n    print(r)\n", "from typing import List\nfrom typing import List\n\ndef calculate_minimum_energy(n: int, rooms: List[int], tunnels: List[List[int]], queries: List[List[int]]) -> List[int]:\n    # Initialize the adjacency list to represent the tree\n    adj_list = [[] for _ in range(n + 1)]\n    \n    # Build the tree representation from the given edges\n    for u, v in tunnels:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Function to calculate the minimum energy required to traverse from one room to another\n    def calculate_energy(u, v):\n        return max(abs(rooms[u - 1]), abs(rooms[v - 1]), abs(rooms[u - 1] - rooms[v - 1]))\n    \n    # Process each query\n    results = []\n    for query in queries:\n        room1, room2 = query[0], query[1]\n        if query[2] != 0:\n            # Update the illusion rate of the specified room\n            rooms[room1 - 1] = query[2]\n        \n        # Calculate the minimum energy required for the given rooms\n        min_energy = calculate_energy(room1 - 1, room2 - 1)\n        results.append(min_energy)\n    \n    return results\n\n# Read input from stdin\nn, q = map(int, input().split())\nrooms = list(map(int, input().split()))\ntunnels = [list(map(int, input().split())) for _ in range(n - 1)]\nqueries = [list(map(int, input().split())) for _ in range(q)]\n\n# Call the function and print the results\nresult = calculate_minimum_energy(n, rooms, tunnels, queries)\nfor res in result:\n    print(res)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport sys\n\n# Read input from stdin\ndef read_input() -> (int, int, List[int], List[Tuple[int, int]], List[Tuple[int, int]]):\n    n, q = map(int, sys.stdin.readline().split())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    tunnels = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n - 1)]\n    queries = [tuple(map(int, sys.stdin.readline().split())) for _ in range(q)]\n    return n, q, a_i, tunnels, queries\n\n# Calculate minimum energy required for each query\ndef calculate_min_energy(n: int, rooms: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]:\n    # Represent the tree using adjacency list\n    tree = [[] for _ in range(n)]\n    for s, t in tunnels:\n        tree[s - 1].append(t - 1)\n        tree[t - 1].append(s - 1)\n    \n    # Precompute the minimum energy required for each path using DFS\n    def dfs(node: int, parent: int):\n        energy[node] = rooms[node]\n        for child in tree[node]:\n            if child == parent:\n                continue\n            dfs(child, node)\n            energy[node] = max(energy[node], energy[child] + abs(rooms[node] - rooms[child]))\n    \n    energy = [0] * n\n    dfs(0, -1)\n    \n    # Answer queries regarding the minimum energy required for each path\n    results = []\n    for query in queries:\n        room_index, new_rate = query\n        # Update the illusion rate of the room\n        rooms[room_index - 1] = new_rate\n        # Recompute the energy for the entire tree\n        energy = [0] * n\n        dfs(0, -1)\n        # Append the result for the query\n        results.append(energy[0])\n    \n    return results\n\n# Update the illusion rate of a room\ndef update_illusion_rate(rooms: List[int], room_index: int, new_rate: int):\n    rooms[room_index] = new_rate\n\n# Main function to execute the program\ndef main():\n    n, q, a_i, tunnels, queries = read_input()\n    results = calculate_min_energy(n, a_i, tunnels, queries)\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef read_input() -> (int, int, List[int], List[Tuple[int, int]]):\n    # Read the number of rooms (n) and queries (q)\n    n, q = map(int, input().split())\n    # Read the initial illusion rates of each room\n    a = list(map(int, input().split()))\n    # Read the tree structure (edges)\n    edges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    return n, q, a, edges\n\ndef calculate_energy(a: List[int], s: int, t: int) -> int:\n    # Calculate the energy required to traverse from room s to room t\n    return max(abs(a[s - 1] + a[t - 1]), abs(a[s - 1] - a[t - 1]))\n\ndef update_illusion_rate(a: List[int], room: int, new_rate: int):\n    # Update the illusion rate of the specified room\n    a[room - 1] = new_rate\n\n# Provide the Interface \nn, q, a, edges = read_input()\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        # Update the illusion rate of a room\n        update_illusion_rate(a, query[1], query[2])\n    elif query[0] == 2:\n        # Calculate the minimum energy required to traverse a path\n        s, t = query[1], query[2]\n        energy = calculate_energy(a, s, t)\n        print(energy)\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef calculate_minimum_energy(n: int, rooms: List[int], tunnels: List[List[int]], queries: List[List[int]]) -> List[int]:\n    # Initialize the adjacency list to represent the tree\n    adj_list = [[] for _ in range(n)]\n    \n    # Build the tree using the tunnels\n    for s, t in tunnels:\n        adj_list[s - 1].append(t - 1)\n        adj_list[t - 1].append(s - 1)\n    \n    # Function to calculate the minimum energy using DFS\n    def dfs(node: int, parent: int) -> Tuple[int, int]:\n        # Initialize the minimum energy for this node and the count of rooms with the same illusion rate\n        min_energy = float('inf')\n        count = 0\n        \n        # Iterate over the children of the current node\n        for child in adj_list[node]:\n            if child == parent:\n                continue\n            child_energy, child_count = dfs(child, node)\n            min_energy = min(min_energy, child_energy)\n            count += child_count\n        \n        # If no child, it means this is a leaf node\n        if count == 0:\n            count = 1\n            min_energy = 0\n        \n        # Calculate the minimum energy for the current node\n        for child in adj_list[node]:\n            if child == parent:\n                continue\n            energy = abs(rooms[node] - rooms[child])\n            min_energy = min(min_energy, energy)\n        \n        return min_energy, count\n    \n    # Process the queries\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            # Update the illusion rate of a specific room\n            room_index = query[1] - 1\n            new_rate = query[2]\n            rooms[room_index] = new_rate\n        elif query[0] == 2:\n            # Query the minimum energy for a given path\n            start = query[1] - 1\n            end = query[2] - 1\n            _, count = dfs(start, -1)\n            results.append(count)\n    \n    return results\n\n# Read input from stdin\nn = int(input())\nrooms = list(map(int, input().split()))\ntunnels = [list(map(int, input().split())) for _ in range(n - 1)]\nqueries = [list(map(int, input().split())) for _ in range(int(input()))]\n\n# Calculate the minimum energy and print the results\nresult = calculate_minimum_energy(n, rooms, tunnels, queries)\nfor res in result:\n    print(res)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport sys\n\n# Assuming the graph is represented as an adjacency list\nGraph = List[List[int]]\n\n# Function to build the graph from the given tree structure\ndef build_graph(n: int, edges: List[Tuple[int, int]]) -> Graph:\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    return graph\n\n# Function to update the illusion rate of a room\ndef update_illusion_rate(room: int, new_rate: int) -> None:\n    illusion_rates[room - 1] = new_rate\n\n# Function to calculate the minimum energy required for traversal between two rooms\ndef calculate_energy(start: int, end: int) -> int:\n    return abs(illusion_rates[start - 1] - illusion_rates[end - 1])\n\n# Read input\nn, q = map(int, sys.stdin.readline().split())\nillusion_rates = list(map(int, sys.stdin.readline().split()))\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, sys.stdin.readline().split())\n    edges.append((u, v))\n\n# Build the graph\ngraph = build_graph(n, edges)\n\n# Process queries\nfor _ in range(q):\n    query = list(map(int, sys.stdin.readline().split()))\n    if query[0] == 1:\n        update_illusion_rate(query[1], query[2])\n    elif query[0] == 2:\n        result = calculate_energy(query[1], query[2])\n        print(result)\n"], "plans": ["requirement analysis:\nThe project requires a system to handle tree-based queries, where each room in the labyrinth is a node, and tunnels are edges. The system must be able to handle updates to the illusion rates of rooms and calculate the minimum energy required to travel between rooms. The solution should be efficient enough to handle up to 10^5 rooms and 10^5 queries.\nrequirement pool:\n- Implement a tree data structure to represent the labyrinth.\n- Provide functionality to update the illusion rate of any room.\n- Calculate the minimum energy required to travel between two rooms.\n- Ensure the system is efficient enough to handle up to 10^5 rooms and 10^5 queries.\n- Design a user-friendly interface for inputting and displaying results.\nTo tackle the problem of calculating the minimum energy required to travel between rooms in a labyrinth represented as a tree, we will use a combination of a tree data structure and efficient algorithms. The system will need to handle updates to the illusion rates of rooms and calculate the minimum energy required to travel between rooms efficiently. We will use Python, leveraging its powerful standard library and external libraries for tree manipulation and graph traversal.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': A tree is a non-linear data structure that simulates a hierarchical tree structure, with a set of connected nodes. The topmost node is called the root, and each node can have zero or more child nodes and at most one parent node.\n\n    'illusion rate': The value assigned to each room to represent the level of illusion or difficulty in that room.\n\n    'energy calculation': The formula to calculate the energy required to traverse a tunnel between two rooms, which is max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the two rooms.\n\n    Explanation: In the context of the labyrinth, the illusion rates determine the energy required to traverse the tunnels between rooms. The energy calculation ensures that the adventurers take the path with the least energy expenditure, considering the illusion rates of the rooms they pass through.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the value of the illusion rate can be greater than a certain threshold.\n\n# [degree adverb] \n    'least': Indicates that the goal is to find the minimum sum of energy required, which is the optimal path with the least energy expenditure.\n\n# [code logic]\n    The plan involves:\n    1. Building a tree data structure from the given tunnels.\n    2. Storing the illusion rates for each room.\n    3. Handling queries of two types:\n        - Type 1: Update the illusion rate of a room.\n        - Type 2: Calculate the minimum energy required to travel from one room to another.\n    4. For Type 2 queries, use a depth-first search (DFS) to find the minimum energy path between the two rooms.\n\n# [edge case] \n    Edge case 1: Query type 2 with rooms u and v being directly connected by a single tunnel.\n    Expected output: max(|a_u + a_v|, |a_u - a_v|)\n    Explanation: Since there's only one tunnel between the two rooms, the energy required is simply the maximum of the absolute sums of the illusion rates.\n\n    Edge case 2: Query type 2 with rooms u and v being the root and a leaf node, respectively.\n    Expected output: max(|a_root + a_leaf|, |a_root - a_leaf|)\n    Explanation: The path from the root to the leaf will involve traversing the longest path in the tree, thus requiring the maximum energy calculation.\n\n    Edge case 3: Query type 1 updating the illusion rate of a room that is not on the path between any two rooms queried in a type 2 query.\n    Expected output: No change in energy required for type 2 queries.\n    Explanation: Since the update does not affect the path between any two rooms queried in a type 2 query, the energy required remains unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle these scenarios.\n", "requirement analysis:\nThe project requires a system to handle tree-based queries, where each room in the labyrinth is a node, and tunnels are edges. The system needs to handle two types of queries: updating the illusion rate of a room and calculating the minimum energy required to travel from one room to another. The solution should be efficient enough to handle up to 10^5 rooms and 10^5 queries.\nrequirement pool:\n- Implement a tree data structure to represent the labyrinth.\n- Handle queries to update the illusion rate of a room.\n- Calculate the minimum energy required to travel from one room to another.\n- Ensure the system is efficient and can handle up to 10^5 rooms and 10^5 queries.\n- Provide a user-friendly interface for updating illusion rates and querying energy requirements.\nTo tackle the problem, we will use a tree data structure to represent the labyrinth, where each room is a node and each tunnel is an edge. We will handle queries to update the illusion rate of a room and calculate the minimum energy required to travel from one room to another. Given the constraints, we will employ a library like `networkx` to manage the tree structure and handle the queries efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree data structure': A tree is a connected graph with no cycles. In this context, it represents the labyrinth with rooms and tunnels.\n    'illusion rate': The effect on energy required to traverse a tunnel, based on the rooms' illusion rates.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates the requirement for a condition to be met, such as the illusion rate being greater than a certain value.\n    'at least as many times': Refers to the minimum frequency a number must appear in the list to meet a condition.\n\n# [degree adverb] \n    'largest': Indicates the need to find the maximum value that meets a condition.\n\n# [code logic]\n    To implement the solution, we need to:\n    1. Build a tree representation of the labyrinth using the given tunnels.\n    2. Handle queries to update the illusion rate of a room.\n    3. Calculate the minimum energy required to travel from one room to another using the tree structure and current illusion rates.\n\n# [edge case] \n    search([1, 1, 1, 1]) = 1\n    Explanation: All rooms have the same illusion rate, so any room can be used to start the journey, and the energy required is the same for any path.\n    search([1, 2, 3, 4]) = 1\n    Explanation: The smallest illusion rate is 1, so the minimum energy required to travel between any rooms is determined by this rate.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all rooms have the same illusion rate.\n        if all(a_i == a[0] for a_i in a):\n            return a[0]  # Return the common illusion rate as the minimum energy.\n        (other code)\n\n# [code logic continued]\n    To calculate the minimum energy:\n    1. Use a depth-first search (DFS) to traverse the tree and calculate the energy required for each path.\n    2. Update the illusion rate of the room being visited.\n    3. Continue the DFS until the target room is reached.\n    4. Return the minimum energy found.\n", "requirement analysis:\nThe project requires a system to handle tree-based queries, where each room in the labyrinth is a node, and tunnels are edges. The system must be able to handle updates to the illusion rates of rooms and calculate the minimum energy required to traverse the tree from one room to another. The solution should be efficient enough to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a tree data structure to represent the labyrinth with nodes representing rooms and edges representing tunnels.\n- Create a function to calculate the energy required to traverse between two rooms based on their illusion rates.\n- Develop a mechanism to handle queries for updating the illusion rate of a room and querying the minimum energy required to travel between two rooms.\n- Ensure the system is optimized to handle the upper limits of the input constraints efficiently.\n- Design a user-friendly interface for easy interaction with the system.\nTo tackle the problem, we will use a tree data structure to represent the labyrinth, where each node represents a room and each edge represents a tunnel. We will implement a function to calculate the energy required to traverse between two rooms based on their illusion rates. The system will handle queries for updating the illusion rate of a room and querying the minimum energy required to travel between two rooms efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree data structure': A tree is a non-linear data structure that simulates a hierarchical tree structure with a set of linked nodes. Each node in the tree can have zero or more child nodes and at most one parent node. Trees are used to represent hierarchical relationships between objects.\n\n    'illusion rate': The intensity of the illusion effect in a room, which affects the energy required to traverse the room.\n\n    'energy calculation': The formula max(|a_x + a_y|, |a_x - a_y|) is used to calculate the energy required to traverse from room x to room y, where |z| represents the absolute value of z.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates a comparison where one value is greater than another.\n\n# [degree adverb] \n    'least': Indicates the smallest or minimum amount or degree.\n\n# [code logic]\n    To implement the solution, we will:\n    1. Represent the labyrinth as a tree using an adjacency list.\n    2. Store the illusion rates for each room.\n    3. Implement a function to calculate the energy required to traverse between two rooms.\n    4. Process queries to either update the illusion rate of a room or to find the minimum energy required to travel between two rooms.\n\n# [edge case] \n    Edge case 1:\n    Query: 2 1 2\n    Explanation: The tree structure is such that room 1 is directly connected to room 2. Since there is only one tunnel, the energy required to travel from room 1 to room 2 is max(|a_1 + a_2|, |a_1 - a_2|).\n    Expected output: max(|a_1 + a_2|, |a_1 - a_2|)\n\n    Edge case 2:\n    Query: 2 3 5\n    Explanation: This query involves a deeper traversal in the tree structure. The energy calculation would depend on the illusion rates of rooms 3 and 5 and their relationship in the tree.\n    Expected output: max(|a_3 + a_5|, |a_3 - a_5|)\n\n    Edge case 3:\n    Query: 1 4 10\n    Explanation: This query involves updating the illusion rate of room 4 to 10. The energy calculations that depend on room 4's new illusion rate will need to be re-evaluated.\n    Expected output: Update the illusion rate of room 4 to 10 and recalculate affected energy values.\n\n# [extra code for edge case]\n    We may need extra code to handle the case where a room's illusion rate is updated, especially if it affects the energy calculations for multiple paths in the tree. This could involve re-calculating energy values for all affected paths.\n", "requirement analysis:\nThe project requires a program to calculate the minimum energy required to traverse a tree-like maze with dynamically changing room rates. The program must handle both querying the current minimum energy and updating room rates based on user queries. The solution should be efficient enough to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to calculate the minimum energy required to traverse the maze between two rooms.\n- Allow the user to update the illusion rates of specific rooms.\n- Ensure the program can handle multiple queries efficiently.\n- Design a user-friendly interface for easy interaction.\n- Optimize the code to handle large inputs within reasonable time limits.\nTo solve this problem, we will use a combination of data structures and algorithms to efficiently handle the maze traversal and rate updates. We will represent the maze as a tree using an adjacency list, where each node will store its illusion rate. For each query, we will calculate the minimum energy required to traverse from one room to another, considering the maximum of the illusion rates or their absolute differences. We will also provide functionality to update the illusion rates of specific rooms dynamically.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree representation': The maze is represented as a tree, where each room is a node and tunnels are edges.\n    'illusion rate': Each room has a special number that affects the energy required to traverse the maze.\n    'energy calculation': The energy required to move from one room to another is the maximum of the illusion rates of the two rooms or the absolute difference between them.\n\n# [phrase showing quantity relationship]\n    'more than': Used to compare the illusion rates of rooms.\n    'absolute difference': Used to calculate the energy based on the difference between the illusion rates of two rooms.\n\n# [degree adverb] \n    'largest': Used to determine the maximum value between the illusion rates of two rooms or their absolute difference.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Represent the maze as a tree using an adjacency list.\n    2. Store the illusion rates for each room.\n    3. Calculate the minimum energy required to traverse from one room to another.\n    4. Update the illusion rates dynamically based on queries.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 5\n    Explanation: The largest integer that appears at least as many times as itself is 5, which appears once.\n    search([1, 1, 2, 2, 3]) = 2\n    Explanation: The largest integer that appears at least as many times as itself is 2, which appears twice.\n    search([5, 5, 5, 5, 5]) = 5\n    Explanation: The largest integer that appears at least as many times as itself is 5, which appears five times.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the list is empty or contains only one element.\n        if not lst:\n            return -1\n        elif len(lst) == 1:\n            return lst[0]\n", "requirement analysis:\nThe project requires a program to simulate a maze with rooms and tunnels, where the energy required to move between rooms depends on the illusion rates and the connectivity of the rooms. The program must handle queries to change the illusion rates and calculate the minimum energy required to traverse the maze from one room to another.\nrequirement pool:\n- Implement a tree structure to represent the maze with rooms and tunnels.\n- Calculate the energy required to move between rooms based on the illusion rates.\n- Handle queries to change the illusion rates of rooms.\n- Output the minimum sum of energy needed for a given query.\n- Ensure the program is efficient enough to handle large inputs within the constraints.\nTo implement the solution, we will use a Python program that models the maze as a tree structure, where each node represents a room and edges represent tunnels between rooms. We will calculate the energy required to move between rooms based on the illusion rates of the rooms. The program will handle queries to change the illusion rates and calculate the minimum energy required to traverse the maze from one room to another.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': represents the maze as a graph with rooms and tunnels, where each room is a node and each tunnel is an edge.\n    'illusion rate': a special number associated with each room that affects the energy required to move through it.\n    'energy calculation': involves finding the maximum of the illusion rates of two rooms or the absolute difference between them.\n\n# [phrase showing quantity relationship]\n    'more than': used to compare the illusion rates of rooms to determine the energy required for movement.\n    'at least as many times': not explicitly mentioned in the requirement, but implied in the context of comparing rates.\n\n# [degree adverb] \n    'largest': used to describe the maximum of two values (illusion rates or their difference) when calculating energy.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan involves:\n    1. Building the tree structure from the given tunnels.\n    2. Calculating the energy required for each query type.\n    3. Handling queries to change illusion rates and recalculate the minimum energy.\n\n# [edge case] \n    Edge case 1:\n    Input: 6 4\n            10 -9 2 -1 4 -6\n            1 5\n            5 4\n            5 6\n            6 2\n            6 3\n            2 1 2\n            1 1 -3\n            2 1 2\n            2 3 3\n    Output: 39\n    Explanation: The initial illusion rates and tunnels form a tree. The first query changes the rate of room 1 to -3, affecting the energy calculations. The subsequent queries calculate the minimum energy needed to traverse the maze.\n\n    Edge case 2:\n    Input: 2 1\n            1 2\n            1 2\n            1 1 1\n    Output: 0\n    Explanation: With only two rooms and one tunnel, the energy needed is zero regardless of the query.\n\n    Edge case 3:\n    Input: 3 1\n            10 -20 30\n            1 2\n            2 3\n            2 1 2\n    Output: 50\n    Explanation: The initial setup has high illusion rates that can be adjusted, but the minimum energy calculation still considers the highest rates.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the provided logic should be sufficient for the given constraints. The tree structure and queries are designed to handle edge cases naturally.\n", "requirement analysis:\nThe project requires a program to calculate the minimum energy required to traverse a tree-like maze with dynamically changing room rates. The program must handle both querying the current minimum energy and updating room rates based on user input. The solution should be efficient enough to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to calculate the minimum energy required to traverse the maze between two rooms.\n- Allow the user to update the illusion rates of specific rooms.\n- Ensure the program can handle queries efficiently under the given constraints.\n- Design a user-friendly interface for input and output.\n- Optimize the algorithm for handling large inputs and frequent updates.\nTo solve this problem, we will use a combination of data structures and algorithms to efficiently handle the maze traversal and rate updates. We will represent the maze as a tree using an adjacency list, where each node will store its illusion rate. For each query, we will calculate the minimum energy required to traverse from one room to another, considering the current rates of the rooms. We will also implement a function to update the illusion rates of specific rooms dynamically.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree representation': The maze is represented as a tree, where each room is a node and tunnels are edges connecting the nodes.\n    'illusion rate': Each room has a special number that affects the energy required to traverse through it.\n    'energy calculation': The energy required to move from one room to another is the maximum of the illusion rates of the two rooms or the absolute difference between them.\n\n# [phrase showing quantity relationship]\n    'more than': Used to compare the illusion rates of rooms.\n    'at least as many times': Not explicitly mentioned in the requirement, but implied in the context of finding the minimum energy required.\n\n# [degree adverb] \n    'largest': Used to describe the maximum of the illusion rates between two rooms.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Build the tree representation from the given edges.\n    2. Calculate the minimum energy required for each query.\n    3. Update the illusion rates dynamically for each query.\n\n# [edge case] \n    Edge case 1:\n    Input: 6 4\n            10 -9 2 -1 4 -6\n            1 5\n            5 4\n            5 6\n            6 2\n            6 3\n            2 1 2\n            1 1 -3\n            2 1 2\n            2 3 3\n    Explanation:\n        - The tree structure is built with the given edges.\n        - The initial illusion rates are [10, -9, 2, -1, 4, -6].\n        - The first query updates the rate of room 1 to -3.\n        - The second query calculates the minimum energy for rooms 1 and 2.\n        - The third query calculates the minimum energy for room 3.\n    Expected Output:\n        39\n        32\n        0\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic should be sufficient to handle the given constraints and queries.\n", "requirement analysis:\nThe project requires a program to calculate the minimum energy required to traverse a tree-like labyrinth with dynamic illusion rates. The program must handle both querying the minimum energy for a given path and updating the illusion rate of a specific room. The solution should be efficient enough to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to read input and parse the tree structure and queries.\n- Develop a method to calculate the minimum energy required for a given path.\n- Create a function to update the illusion rate of a room.\n- Ensure the program is optimized to handle large inputs within reasonable time limits.\n- Design a user-friendly interface for input and output.\nTo solve this problem, we will use a combination of graph theory and dynamic programming to efficiently handle the tree structure and queries. We will use an adjacency list to represent the tree and precompute the minimum energy required for each path using a depth-first search (DFS) approach. For updating the illusion rate of a room, we will use a segment tree or a binary indexed tree (BIT) to efficiently update and query the minimum energy.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': The labyrinth's map resembles a tree, which is a connected graph without cycles. Each room is a node, and each tunnel is an edge connecting two nodes.\n    'illusion rate': The value associated with each room that affects the energy required to traverse the tunnels.\n    'minimum energy required': The energy needed to traverse a tunnel from one room to another, calculated as the maximum of the absolute sums or differences of the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'more than': Used to compare the illusion rates of rooms to determine the energy required for traversal.\n    'at least as many times': Not directly applicable in this context, but the concept of comparing frequencies of values might be implied in the context of dynamic programming or segment trees.\n\n# [degree adverb] \n    'largest': Indicates the need to find the maximum value among possible energies, which is crucial for determining the minimum energy required.\n\n# [code logic]\n    To implement the solution, we need to:\n    1. Represent the tree using an adjacency list.\n    2. Use DFS to precompute the minimum energy required for each path.\n    3. Update the illusion rate of a room efficiently using a data structure like a segment tree or binary indexed tree.\n    4. Answer queries regarding the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, q = 2, a = [1, 2, 3], tunnels = [(1, 2), (2, 3)], queries = [2, 1, 3]\n    Explanation: The tree structure is a path with rooms 1-2-3. The illusion rates are [1, 2, 3]. The queries are to find the minimum energy to traverse from room 1 to room 3. The energy required is max(|1+3|, |1-3|) = 4.\n    Edge case 2:\n    Input: n = 4, q = 1, a = [0, 5, 5, 5], tunnels = [(1, 2), (1, 3), (1, 4)], queries = [2, 2, 3, 4]\n    Explanation: The tree structure is a star-like graph with room 1 at the center. The illusion rates are [0, 5, 5, 5]. The query is to find the minimum energy to traverse from room 2 to room 4. The energy required is max(|5-0|, |5-0|) = 5.\n    Edge case 3:\n    Input: n = 5, q = 3, a = [1, 2, 3, 4, 5], tunnels = [(1, 2), (1, 3), (2, 4), (2, 5)], queries = [2, 1, 2, 3, 4, 5]\n    Explanation: The tree structure is a more complex tree. The illusion rates are [1, 2, 3, 4, 5]. The queries involve finding the minimum energy for various paths, including traversing from room 1 to room 5, which requires max(|1+5|, |1-5|) = 6.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, especially when dealing with the smallest or largest values in the tree structure. This might involve initializing data structures with appropriate values or handling special cases in the DFS traversal.\n\n    For example, in the segment tree implementation, we might need to initialize the tree with large values to handle cases where the illusion rates are very high or low, ensuring that the minimum energy calculation is accurate.\n", "requirement analysis:\nThe project requires a program to calculate the minimum energy required to traverse a tree-like labyrinth with dynamic illusion rates. The program must handle both querying the minimum energy for a given path and updating the illusion rate of a specific room. The solution should be efficient enough to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to read input and parse the tree structure and queries.\n- Develop a method to calculate the minimum energy required to traverse between two rooms.\n- Create a mechanism to update the illusion rate of a room and recalculate affected paths.\n- Ensure the program is optimized to handle large inputs within reasonable time limits.\n- Design a user-friendly interface for input and output, including error handling.\nTo solve this problem, we will use a combination of graph theory and dynamic programming to efficiently handle the tree structure and queries. We will use an adjacency list to represent the tree and precompute the minimum energy required to traverse each path. For updating the illusion rates, we will use a segment tree or a binary indexed tree to efficiently update and query the affected paths.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': The labyrinth's map resembles a tree, which is a connected graph without cycles. Each room is a node, and each tunnel is an edge connecting two nodes.\n    'illusion rate': The value associated with each room that affects the energy needed to traverse the tunnels.\n    'minimum energy needed': The sum of the maximum of the absolute values of the sum or difference of the illusion rates of the two rooms connected by a tunnel.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates the number of rooms and tunnels in the maze.\n    'at least as many times': Refers to the number of queries regarding the minimum energy needed for traversal.\n\n# [degree adverb] \n    'largest': Indicates the maximum value of the absolute sum or difference of the illusion rates.\n\n# [code logic]\n    To solve this problem, we need to:\n    1. Represent the tree using an adjacency list.\n    2. Precompute the minimum energy required to traverse each path using dynamic programming.\n    3. Update the illusion rates efficiently using a data structure like a segment tree or binary indexed tree.\n    4. Answer each query regarding the minimum energy needed for traversal.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    n = 3, q = 2\n    a = [1, 2, 3]\n    tunnels = [(1, 2), (2, 3)]\n    queries = [2, 1]\n    \n    Explanation:\n    The tree structure is a path with rooms 1-2-3. The illusion rates are [1, 2, 3]. The queries are for the minimum energy needed to traverse the path.\n    Query 1: The minimum energy needed to traverse the path is the maximum of the absolute values of the sum or difference of the illusion rates of adjacent rooms. So, it's max(|1+2|, |1-2|) = 2.\n    Query 2: Update the illusion rate of room 2 to 4. The new minimum energy needed to traverse the path is max(|1+4|, |1-4|) = 4.\n    \n    Expected Output:\n    2\n    4\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the tree is a path. In this case, we can iterate through the path to compute the minimum energy needed for each query. For updating the illusion rates, we can simply update the corresponding room's illusion rate and recompute the minimum energy needed for the path.\n\n    Example code for handling the edge case:\n    ```python\n    def compute_min_energy(a, tunnels):\n        min_energy = float('inf')\n        for s, t in tunnels:\n            min_energy = min(min_energy, max(abs(a[s-1] + a[t-1]), abs(a[s-1] - a[t-1])))\n        return min_energy\n\n    def update_illusion_rate(a, room, new_rate):\n        a[room-1] = new_rate\n\n    # Example usage\n    n, q = 3, 2\n    a = [1, 2, 3]\n    tunnels = [(1, 2), (2, 3)]\n    queries = [2, 1]\n\n    # Process queries\n    for query in queries:\n        if query == 1:\n            room, new_rate = map(int, input().split())\n            update_illusion_rate(a, room, new_rate)\n        elif query == 2:\n            print(compute_min_energy(a, tunnels))\n    ```\n", "requirement analysis:\nThe project requires a program to calculate the minimum energy required to traverse a tree-like labyrinth with dynamic illusion rates. The program must handle both querying the minimum energy for a given path and updating the illusion rate of a specific room. The solution should be efficient enough to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to calculate the minimum energy required to traverse the labyrinth.\n- Allow for dynamic updates to the illusion rates of rooms.\n- Ensure the program can handle the input and output format as specified.\n- Optimize the algorithm to handle the upper limits of the input constraints efficiently.\n- Design a user-friendly interface for input and output.\nTo solve this problem, we will use a combination of graph theory and dynamic programming to efficiently calculate the minimum energy required to traverse the labyrinth. We will represent the labyrinth as a tree and use a depth-first search (DFS) algorithm to calculate the minimum energy for each query. The program will handle both querying the minimum energy for a given path and updating the illusion rate of a specific room.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': The labyrinth is represented as a tree, where each room is a node and each tunnel is an edge.\n    'illusion rate': The value associated with each room that affects the energy required to traverse the tunnel.\n    'minimum energy': The energy required to traverse a path, which is determined by the maximum of the absolute sums or differences of the illusion rates of the connected rooms.\n\n# [phrase showing quantity relationship]\n    'more than': Used to indicate that the energy required to traverse a tunnel is dependent on the illusion rates of the connected rooms.\n    'at least as many times': Not directly applicable in this context, but the concept of traversing multiple tunnels to reach a destination is implied.\n\n# [degree adverb] \n    'largest': Indicates that the energy calculation involves finding the maximum value between two absolute sums or differences.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Build the tree structure from the given tunnels.\n    2. Use DFS to calculate the minimum energy required for each query.\n    3. Handle both querying and updating the illusion rates.\n\n# [edge case] \n    Edge case 1: Querying the minimum energy for a path with the minimum possible energy.\n    search([4, 1, 2, 2, 3, 1]) = 2\n    Explanation: The smallest illusion rate is 1, and it appears twice, so the minimum energy is 2.\n\n    Edge case 2: Querying the minimum energy for a path with the maximum possible energy.\n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    Explanation: The smallest illusion rate is 1, but it appears only once. The next smallest is 2, which appears twice, so the minimum energy is 3.\n\n    Edge case 3: Querying the minimum energy for a path with no room having an illusion rate that matches its count.\n    search([5, 5, 4, 4, 4]) = -1\n    Explanation: The smallest illusion rate is 4, but it appears only three times, so no room has an illusion rate that matches its count. The function returns -1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if not lst:\n            return -1\n        min_illusion_rate = min(lst)\n        if lst.count(min_illusion_rate) >= min_illusion_rate:\n            return min_illusion_rate\n        else:\n            return -1\n\n    This code checks if the list is empty or if no room has an illusion rate that matches its count, returning -1 in such cases.\n", "requirement analysis:\nThe project requires a system to handle tree-based queries for labyrinth navigation, including dynamic updates to room illusion rates and energy calculation for path traversal. The system must be efficient to handle up to 10^5 rooms and 10^5 queries, ensuring optimal performance.\nrequirement pool:\n- Implement a tree structure to represent the labyrinth and its tunnels.\n- Handle queries for energy calculation between two rooms.\n- Allow dynamic updates to the illusion rates of rooms.\n- Ensure the system is optimized for handling large inputs efficiently.\n- Design a user-friendly interface for easy interaction.\nTo tackle the problem of navigating a labyrinth with dynamic illusion rates and calculating energy costs for traversal, we will use a tree data structure. The tree will represent the labyrinth's rooms and tunnels. We will employ a graph traversal algorithm to calculate the minimum energy required for traversal between any two rooms. For dynamic updates, we will ensure the tree structure can be modified efficiently. The system will be designed to handle up to 10^5 rooms and 10^5 queries efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree data structure': A tree is a non-linear data structure that simulates a hierarchical tree structure, with a set of connected nodes. Each node in the tree can have zero or more child nodes and at most one parent node. The topmost node is called the root. Trees are used to represent hierarchies or nested sets of data.\n\n    Explanation: In the context of the labyrinth, the tree represents the rooms and tunnels connecting them. Each room is a node, and each tunnel is an edge connecting two nodes. This structure allows for efficient traversal and querying of the labyrinth.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that there is a relationship where one value must be greater than another.\n    'at least as many times': Indicates that one value must appear a minimum number of times compared to another.\n\n# [degree adverb] \n    'least': Indicates the smallest or minimum amount or degree of something.\n\n# [code logic]\n    To implement the solution, we will:\n    1. Build a graph representing the labyrinth using the given tree structure.\n    2. Use a graph traversal algorithm (like Depth-First Search or Breadth-First Search) to calculate the minimum energy required for traversal between any two rooms.\n    3. For dynamic updates, modify the graph structure to reflect the changed illusion rate of a room.\n    4. Process each query by either updating the illusion rate or calculating the minimum energy required for traversal between two rooms.\n\n# [edge case] \n    Edge case 1: Query type 2 with rooms u and v where u is the root and v is a leaf node.\n    Expected output: The minimum sum of energy needed to reach v from u is simply the absolute difference in illusion rates between u and v.\n    Explanation: Since u is the root, there's a direct path from u to v with energy cost max(|a_u + a_v|, |a_u - a_v|).\n\n    Edge case 2: Query type 1 with room u and new illusion rate c, where c is the same as the current illusion rate of u.\n    Expected output: No change in the labyrinth's structure or energy requirements.\n    Explanation: If the new illusion rate is the same as the current one, there's no need to update the labyrinth's structure or recalculate energy costs.\n\n    Edge case 3: Query type 2 with rooms u and v where u and v are siblings in the tree.\n    Expected output: The minimum sum of energy needed to reach v from u is the absolute difference in illusion rates between u and v.\n    Explanation: Since u and v are siblings, the energy cost to reach v from u is max(|a_u + a_v|, |a_u - a_v|).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases described above, as the core logic provided in the plan can handle these scenarios without modification. The tree structure and traversal algorithms inherently support these edge cases.\n"], "scores": [], "pass_results": [false, false, false, false, false, true, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 34, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "rephrase_one", "parent_index": 27}
