{"name": "1594_B. Special Numbers", "description": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "tags": ["bitmasks", "math"], "difficulty": 8, "id": 1594, "sample_io": [{"input": "3\n3 4\n2 12\n105 564\n", "output": ["9\n12\n3595374\n"]}], "test_list": [{"input": "3\n3 4\n2 6\n105 564\n", "output": ["9\n6\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 564\n", "output": ["1\n6\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 564\n", "output": ["0\n6\n3595374\n"]}, {"input": "3\n0 8\n0 6\n105 564\n", "output": ["0\n0\n3595374\n"]}, {"input": "3\n1 8\n0 6\n105 564\n", "output": ["1\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 564\n", "output": ["3\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 984\n", "output": ["3\n0\n713307087\n"]}, {"input": "3\n1 10\n0 6\n105 984\n", "output": ["2\n0\n713307087\n"]}, {"input": "3\n6 4\n2 12\n105 564\n", "output": ["36\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n105 564\n", "output": ["9\n1\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 571\n", "output": ["1\n6\n4742080\n"]}, {"input": "3\n0 4\n2 6\n39 564\n", "output": ["0\n6\n452236824\n"]}, {"input": "3\n0 8\n2 6\n105 713\n", "output": ["0\n6\n257287716\n"]}, {"input": "3\n0 8\n0 6\n105 46\n", "output": ["0\n0\n763984296\n"]}, {"input": "3\n1 8\n0 6\n105 868\n", "output": ["1\n0\n312144741\n"]}, {"input": "3\n1 7\n0 6\n35 564\n", "output": ["3\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 564\n", "output": ["43\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n110 564\n", "output": ["9\n1\n745888270\n"]}, {"input": "3\n1 4\n3 6\n105 571\n", "output": ["1\n12\n4742080\n"]}, {"input": "3\n0 4\n0 6\n39 564\n", "output": ["0\n0\n452236824\n"]}, {"input": "3\n0 8\n2 12\n105 713\n", "output": ["0\n12\n257287716\n"]}, {"input": "3\n1 8\n1 6\n105 868\n", "output": ["1\n2\n312144741\n"]}, {"input": "3\n1 4\n0 6\n35 564\n", "output": ["1\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 276\n", "output": ["43\n12\n456030397\n"]}, {"input": "3\n1 4\n2 6\n105 211\n", "output": ["1\n6\n258462631\n"]}, {"input": "3\n0 8\n2 12\n103 713\n", "output": ["0\n12\n134894835\n"]}, {"input": "3\n0 12\n0 6\n105 28\n", "output": ["0\n0\n122719275\n"]}, {"input": "3\n1 8\n1 6\n105 238\n", "output": ["1\n2\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 984\n", "output": ["18\n0\n713307087\n"]}, {"input": "3\n2 26\n0 10\n105 984\n", "output": ["26\n0\n713307087\n"]}, {"input": "3\n6 7\n2 20\n105 276\n", "output": ["43\n20\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 211\n", "output": ["2\n6\n258462631\n"]}, {"input": "3\n1 8\n2 12\n103 713\n", "output": ["1\n12\n134894835\n"]}, {"input": "3\n1 8\n2 6\n105 238\n", "output": ["1\n6\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 735\n", "output": ["18\n0\n378849471\n"]}, {"input": "3\n6 7\n2 6\n105 276\n", "output": ["43\n6\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 274\n", "output": ["2\n6\n456019477\n"]}, {"input": "3\n1 10\n2 12\n103 713\n", "output": ["2\n12\n134894835\n"]}, {"input": "3\n6 7\n2 6\n105 255\n", "output": ["43\n6\n22446815\n"]}, {"input": "3\n1 7\n2 6\n105 274\n", "output": ["3\n6\n456019477\n"]}, {"input": "3\n1 4\n3 6\n105 238\n", "output": ["1\n12\n900896196\n"]}, {"input": "3\n6 7\n2 1\n105 255\n", "output": ["43\n1\n22446815\n"]}, {"input": "3\n1 20\n2 4\n103 713\n", "output": ["2\n4\n134894835\n"]}, {"input": "3\n1 4\n4 6\n105 238\n", "output": ["1\n20\n900896196\n"]}, {"input": "3\n1 4\n5 6\n105 238\n", "output": ["1\n30\n900896196\n"]}, {"input": "3\n1 3\n2 4\n165 713\n", "output": ["2\n4\n58081920\n"]}, {"input": "3\n1 3\n2 7\n165 713\n", "output": ["2\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n105 433\n", "output": ["1\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 433\n", "output": ["0\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 443\n", "output": ["0\n6\n261273292\n"]}, {"input": "3\n0 2\n2 6\n105 583\n", "output": ["0\n6\n214860566\n"]}, {"input": "3\n0 2\n2 7\n105 583\n", "output": ["0\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 583\n", "output": ["0\n12\n214860566\n"]}, {"input": "3\n0 2\n2 12\n23 583\n", "output": ["0\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 583\n", "output": ["1\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 476\n", "output": ["1\n12\n864138587\n"]}, {"input": "3\n1 2\n3 12\n23 476\n", "output": ["1\n36\n864138587\n"]}, {"input": "3\n1 2\n3 12\n15 476\n", "output": ["1\n36\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 714\n", "output": ["1\n36\n625612499\n"]}, {"input": "3\n1 2\n3 12\n15 657\n", "output": ["1\n36\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 657\n", "output": ["1\n27\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 224\n", "output": ["1\n27\n183009375\n"]}, {"input": "3\n1 3\n3 8\n15 224\n", "output": ["2\n27\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 224\n", "output": ["2\n1\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 250\n", "output": ["2\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 564\n", "output": ["9\n17\n3595374\n"]}, {"input": "3\n3 4\n2 6\n88 564\n", "output": ["9\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n105 564\n", "output": ["1\n12\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 549\n", "output": ["0\n6\n882044757\n"]}, {"input": "3\n0 8\n1 6\n105 564\n", "output": ["0\n2\n3595374\n"]}, {"input": "3\n1 5\n0 6\n105 564\n", "output": ["2\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n16 564\n", "output": ["3\n0\n720590628\n"]}, {"input": "3\n1 7\n0 6\n109 984\n", "output": ["3\n0\n669833413\n"]}, {"input": "3\n1 10\n0 10\n137 984\n", "output": ["2\n0\n172328490\n"]}, {"input": "3\n6 4\n2 12\n151 564\n", "output": ["36\n12\n532389654\n"]}, {"input": "3\n3 4\n2 1\n89 564\n", "output": ["9\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 290\n", "output": ["1\n6\n97284386\n"]}, {"input": "3\n0 4\n2 6\n39 1030\n", "output": ["0\n6\n28210319\n"]}, {"input": "3\n0 8\n0 6\n105 75\n", "output": ["0\n0\n96788976\n"]}, {"input": "3\n0 10\n0 2\n105 984\n", "output": ["0\n0\n713307087\n"]}, {"input": "3\n6 7\n2 22\n105 564\n", "output": ["43\n22\n3595374\n"]}, {"input": "3\n1 8\n2 12\n105 713\n", "output": ["1\n12\n257287716\n"]}, {"input": "3\n0 12\n0 6\n209 46\n", "output": ["0\n0\n787390482\n"]}, {"input": "3\n1 8\n1 6\n80 868\n", "output": ["1\n2\n69536402\n"]}, {"input": "3\n1 6\n0 6\n35 564\n", "output": ["2\n0\n692143895\n"]}, {"input": "3\n1 26\n0 10\n105 1003\n", "output": ["3\n0\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 276\n", "output": ["43\n17\n456030397\n"]}, {"input": "3\n3 3\n4 1\n110 564\n", "output": ["4\n1\n745888270\n"]}, {"input": "3\n0 8\n2 16\n103 713\n", "output": ["0\n16\n134894835\n"]}, {"input": "3\n1 8\n1 6\n201 238\n", "output": ["1\n2\n436757470\n"]}, {"input": "3\n2 18\n1 2\n105 984\n", "output": ["18\n1\n713307087\n"]}, {"input": "3\n2 26\n1 10\n105 984\n", "output": ["26\n2\n713307087\n"]}, {"input": "3\n6 7\n4 20\n105 276\n", "output": ["43\n272\n456030397\n"]}, {"input": "3\n1 15\n2 12\n103 713\n", "output": ["4\n12\n134894835\n"]}, {"input": "3\n1 8\n2 4\n105 238\n", "output": ["1\n4\n900896196\n"]}, {"input": "3\n6 7\n0 6\n105 276\n", "output": ["43\n0\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 176\n", "output": ["2\n6\n925646821\n"]}, {"input": "3\n1 10\n2 12\n50 713\n", "output": ["2\n12\n861447554\n"]}, {"input": "3\n1 4\n2 6\n60 238\n", "output": ["1\n6\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 255\n", "output": ["43\n6\n5380840\n"]}, {"input": "3\n1 7\n2 6\n93 274\n", "output": ["3\n6\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 713\n", "output": ["2\n12\n320033969\n"]}, {"input": "3\n2 4\n3 6\n105 238\n", "output": ["4\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 713\n", "output": ["2\n1\n134894835\n"]}, {"input": "3\n1 7\n4 6\n105 238\n", "output": ["3\n20\n900896196\n"]}, {"input": "3\n6 7\n3 1\n105 389\n", "output": ["43\n1\n375760428\n"]}, {"input": "3\n1 3\n2 4\n103 863\n", "output": ["2\n4\n586977111\n"]}, {"input": "3\n1 3\n2 4\n165 330\n", "output": ["2\n4\n846108753\n"]}, {"input": "3\n2 3\n2 7\n165 713\n", "output": ["3\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n192 238\n", "output": ["1\n6\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 433\n", "output": ["1\n6\n6607553\n"]}, {"input": "3\n0 2\n2 6\n134 433\n", "output": ["0\n6\n333298828\n"]}, {"input": "3\n1 2\n2 6\n105 583\n", "output": ["1\n6\n214860566\n"]}, {"input": "3\n1 2\n2 7\n105 583\n", "output": ["1\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 433\n", "output": ["0\n12\n260115562\n"]}, {"input": "3\n1 2\n2 12\n39 583\n", "output": ["1\n12\n878442964\n"]}, {"input": "3\n1 2\n4 12\n23 476\n", "output": ["1\n80\n864138587\n"]}, {"input": "3\n2 2\n3 12\n23 476\n", "output": ["2\n36\n864138587\n"]}, {"input": "3\n1 2\n4 12\n15 476\n", "output": ["1\n80\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 156\n", "output": ["1\n36\n170913600\n"]}, {"input": "3\n1 2\n3 16\n15 657\n", "output": ["1\n81\n614269110\n"]}, {"input": "3\n1 2\n5 8\n15 657\n", "output": ["1\n125\n614269110\n"]}, {"input": "3\n1 3\n3 8\n15 216\n", "output": ["2\n27\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 224\n", "output": ["2\n8\n183009375\n"]}, {"input": "3\n1 1\n1 8\n15 250\n", "output": ["1\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 515\n", "output": ["9\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 564\n", "output": ["3\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n27 564\n", "output": ["1\n12\n612312689\n"]}, {"input": "3\n0 4\n3 6\n105 549\n", "output": ["0\n12\n882044757\n"]}, {"input": "3\n0 8\n1 6\n110 564\n", "output": ["0\n2\n745888270\n"]}, {"input": "3\n0 2\n0 6\n105 68\n", "output": ["0\n0\n95642270\n"]}, {"input": "3\n1 5\n0 6\n105 1004\n", "output": ["2\n0\n354583021\n"]}, {"input": "3\n1 7\n0 6\n21 564\n", "output": ["3\n0\n284320046\n"]}, {"input": "3\n1 10\n0 8\n105 1410\n", "output": ["2\n0\n893659373\n"]}, {"input": "3\n6 4\n2 12\n244 564\n", "output": ["36\n12\n472775977\n"]}, {"input": "3\n3 2\n2 1\n89 564\n", "output": ["3\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 385\n", "output": ["1\n6\n375749403\n"]}, {"input": "3\n0 8\n3 8\n105 713\n", "output": ["0\n27\n257287716\n"]}, {"input": "3\n0 18\n1 10\n105 984\n", "output": ["0\n2\n713307087\n"]}, {"input": "3\n6 4\n2 22\n105 564\n", "output": ["36\n22\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 923\n", "output": ["9\n1\n300692073\n"]}, {"input": "3\n1 2\n6 6\n105 571\n", "output": ["1\n42\n4742080\n"]}, {"input": "3\n1 8\n2 15\n105 713\n", "output": ["1\n15\n257287716\n"]}, {"input": "3\n1 8\n1 6\n80 798\n", "output": ["1\n2\n690210344\n"]}, {"input": "3\n0 18\n0 2\n136 984\n", "output": ["0\n0\n313996483\n"]}, {"input": "3\n1 26\n1 10\n105 1003\n", "output": ["3\n2\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 194\n", "output": ["43\n17\n136912005\n"]}, {"input": "3\n1 1\n2 6\n105 81\n", "output": ["1\n6\n217181871\n"]}, {"input": "3\n0 8\n2 16\n103 658\n", "output": ["0\n16\n194064920\n"]}, {"input": "3\n1 8\n1 6\n201 445\n", "output": ["1\n2\n708509974\n"]}, {"input": "3\n2 18\n1 3\n105 984\n", "output": ["18\n2\n713307087\n"]}, {"input": "3\n6 10\n4 20\n105 276\n", "output": ["222\n272\n456030397\n"]}, {"input": "3\n1 9\n2 6\n74 211\n", "output": ["2\n6\n516663646\n"]}, {"input": "3\n1 19\n2 12\n103 713\n", "output": ["3\n12\n134894835\n"]}, {"input": "3\n1 8\n4 4\n105 238\n", "output": ["1\n16\n900896196\n"]}, {"input": "3\n9 7\n0 6\n105 276\n", "output": ["91\n0\n456030397\n"]}, {"input": "3\n1 6\n2 2\n105 176\n", "output": ["2\n2\n925646821\n"]}, {"input": "3\n1 10\n0 12\n50 713\n", "output": ["2\n0\n861447554\n"]}, {"input": "3\n1 4\n2 3\n60 238\n", "output": ["1\n3\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 205\n", "output": ["43\n6\n5315221\n"]}, {"input": "3\n1 7\n3 6\n93 274\n", "output": ["3\n12\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 818\n", "output": ["2\n12\n838210136\n"]}, {"input": "3\n4 4\n3 6\n105 238\n", "output": ["16\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 372\n", "output": ["2\n1\n482792581\n"]}, {"input": "3\n1 7\n4 6\n105 182\n", "output": ["3\n20\n925657951\n"]}, {"input": "3\n1 3\n2 2\n165 330\n", "output": ["2\n2\n846108753\n"]}, {"input": "3\n1 1\n5 6\n198 238\n", "output": ["1\n30\n423451933\n"]}, {"input": "3\n2 3\n3 7\n165 713\n", "output": ["3\n13\n58081920\n"]}, {"input": "3\n1 2\n1 6\n192 238\n", "output": ["1\n2\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 749\n", "output": ["1\n6\n41311999\n"]}, {"input": "3\n0 2\n2 6\n268 433\n", "output": ["0\n6\n974641\n"]}, {"input": "3\n1 2\n2 6\n192 583\n", "output": ["1\n6\n590294341\n"]}, {"input": "3\n1 2\n2 7\n114 583\n", "output": ["1\n7\n365619380\n"]}, {"input": "3\n1 2\n1 12\n39 583\n", "output": ["1\n2\n878442964\n"]}, {"input": "3\n2 2\n3 4\n23 476\n", "output": ["2\n9\n864138587\n"]}, {"input": "3\n1 2\n4 12\n16 476\n", "output": ["1\n80\n580249828\n"]}, {"input": "3\n1 2\n2 12\n15 156\n", "output": ["1\n12\n170913600\n"]}, {"input": "3\n1 2\n3 16\n6 657\n", "output": ["1\n81\n10358929\n"]}, {"input": "3\n1 2\n5 11\n15 657\n", "output": ["1\n131\n614269110\n"]}, {"input": "3\n0 4\n3 8\n15 224\n", "output": ["0\n27\n183009375\n"]}, {"input": "3\n1 3\n6 8\n15 216\n", "output": ["2\n216\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 378\n", "output": ["2\n8\n575094626\n"]}, {"input": "3\n3 7\n2 17\n105 515\n", "output": ["13\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 962\n", "output": ["3\n6\n799832816\n"]}, {"input": "3\n1 4\n3 6\n27 107\n", "output": ["1\n12\n401789107\n"]}, {"input": "3\n0 4\n4 6\n105 549\n", "output": ["0\n20\n882044757\n"]}, {"input": "3\n1 2\n0 6\n105 68\n", "output": ["1\n0\n95642270\n"]}, {"input": "3\n2 5\n0 6\n105 1004\n", "output": ["5\n0\n354583021\n"]}, {"input": "3\n4 4\n2 12\n244 564\n", "output": ["16\n12\n472775977\n"]}, {"input": "3\n1 4\n2 4\n105 385\n", "output": ["1\n4\n375749403\n"]}, {"input": "3\n0 2\n0 6\n39 1030\n", "output": ["0\n0\n28210319\n"]}, {"input": "3\n0 8\n3 8\n105 437\n", "output": ["0\n27\n260126587\n"]}, {"input": "3\n1 4\n0 2\n105 984\n", "output": ["1\n0\n713307087\n"]}, {"input": "3\n6 4\n0 22\n105 564\n", "output": ["36\n0\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 1290\n", "output": ["9\n1\n331570536\n"]}, {"input": "3\n1 2\n10 6\n105 571\n", "output": ["1\n110\n4742080\n"]}, {"input": "3\n1 14\n2 15\n105 713\n", "output": ["3\n15\n257287716\n"]}, {"input": "3\n1 26\n1 10\n129 1003\n", "output": ["3\n2\n286863200\n"]}, {"input": "3\n6 11\n2 17\n105 194\n", "output": ["223\n17\n136912005\n"]}, {"input": "3\n1 1\n0 6\n105 81\n", "output": ["1\n0\n217181871\n"]}], "task_id": "codecontest/52", "prompt": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because 17 can be expressed as the sum of 4^0 and 4^2. Here, 4^0 equals 1 and 4^2 equals 16, so the sum 1 + 16 equals 17, but 9 is not. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "repair_prompt": ["Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because 17 can be expressed as the sum of 4^0 and 4^2. Here, 4^0 equals 1 and 4^2 equals 16, so the sum 1 + 16 equals 17, but 9 is not. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]\nWrite a main() function and use input() function to read input from stdin", " Theofanis is fascinated by sequences of positive integers, so his teacher, Yeltsa Kcir, assigned him a task involving a sequence composed only of special numbers. A number is considered special if it can be represented as the sum of distinct non-negative powers of a given integer \\( n \\). For instance, for \\( n = 4 \\), the number 17 is special because it can be expressed as \\( 4^0 + 4^2 \\), where \\( 4^0 = 1 \\) and \\( 4^2 = 16 \\), and their sum is 17. Conversely\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]\nWrite a main() function and use input() function to read input from stdin", " Theofanis needs help with finding the k-th special number in a sequence consisting of numbers that can be written as sums of different non-negative powers of n, modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    def is_special_number(x, base):\n        power = 1\n        while power <= x:\n            if x & power:\n                x -= power\n            power *= base\n        return x == 0\n\n    special_numbers = []\n    x = 1\n    while len(special_numbers) < k:\n        if is_special_number(x, n):\n            special_numbers.append(x)\n        x += 1\n\n    return special_numbers[-1] % MOD\n\n# Import necessary pre-dependencies\nimport sys\ninput = sys.stdin.readline\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    special_numbers = []\n    power = 0\n    while k > 0:\n        if k % 2 == 1:\n            special_numbers.append((n ** power) % MOD)\n        k //= 2\n        power += 1\n    result = sum(special_numbers) % MOD\n    return result\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    if k == 1:\n        return 1\n    \n    special_numbers = []\n    power = 0\n    \n    while len(special_numbers) < k:\n        current_power = n ** power\n        for _ in range(power):\n            for num in special_numbers[:]:\n                new_num = num + current_power\n                if new_num not in special_numbers:\n                    special_numbers.append(new_num)\n        if current_power not in special_numbers:\n            special_numbers.append(current_power)\n        power += 1\n    \n    return special_numbers[k - 1] % MOD\n\n# Interface\nimport sys\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\ndef generate_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Generates the k-th special number based on the given n.\n    \n    Args:\n        n (int): The base integer.\n        k (int): The position of the special number in the sequence.\n        \n    Returns:\n        int: The k-th special number.\n    \"\"\"\n    # Initialize the result\n    result = 0\n    \n    # Convert k to binary and iterate through each bit\n    while k > 0:\n        # Check if the current bit is set\n        if k % 2 == 1:\n            result += n ** (bin(k).count('1') - 1)\n        k //= 2\n    \n    # Return the result modulo 10^9+7\n    return result % (10**9 + 7)\n\n# Read the number of test cases\nt = int(input().strip())\n\n# Process each test case\nfor _ in range(t):\n    n, k = map(int, input().strip().split())\n    result = generate_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\n\nMOD = 10**9 + 7\n\ndef read_ints():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef generate_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Generates the k-th special number for a given integer n.\n    \n    A special number is defined as a number that can be represented as a sum of distinct non-negative powers of n.\n    \n    Args:\n        n (int): The base number.\n        k (int): The position of the special number in the sequence, starting from 1.\n    \n    Returns:\n        int: The k-th special number.\n    \"\"\"\n    result = 0\n    binary_k = bin(k)[2:]\n    \n    for i, bit in enumerate(reversed(binary_k)):\n        if bit == '1':\n            result = (result + (n ** i)) % MOD\n    \n    return result\n\nt = int(sys.stdin.readline().strip())\nfor _ in range(t):\n    n, k = read_ints()\n    result = generate_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nMOD = 10**9 + 7\n\ndef generate_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Generates the k-th special number based on powers of n.\n    \n    Args:\n        n (int): The base number.\n        k (int): The position of the special number.\n        \n    Returns:\n        int: The k-th special number modulo 10^9+7.\n    \"\"\"\n    result = 0\n    power = 1\n    \n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n    \n    return result\n\n# Interface for the function\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, k = map(int, input().split())\n        result = generate_special_number(n, k)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    sequence = set()\n    current = 0\n    \n    while len(sequence) < k:\n        current += 1\n        value = current\n        power_sum = 0\n        \n        while value > 0:\n            power_sum += (value % n) ** n\n            value //= n\n        \n        sequence.add(power_sum % MOD)\n    \n    if k > len(sequence):\n        return -1\n    \n    sequence_list = list(sequence)\n    sequence_list.sort()\n    \n    return sequence_list[k - 1]\n\n# Interface\nimport sys\ninput = sys.stdin.read\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    result = 0\n    power = 1\n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n    return result\n\n# Read the number of test cases\nt = int(input().strip())\n\n# Process each test case\nfor _ in range(t):\n    n, k = map(int, input().strip().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\ndef find_kth_special_number(n: int, k: int) -> int:\n    MOD = 10**9 + 7\n    special_numbers = []\n    power = 0\n    while len(special_numbers) < k:\n        current_power = n ** power\n        for i in range(len(special_numbers) + 1):\n            current_sum = sum(special_numbers[i:] + [current_power])\n            if current_sum not in special_numbers:\n                special_numbers.append(current_sum)\n        power += 1\n    return special_numbers[k - 1] % MOD\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n", "from typing import List\n## main.py\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"\n    Finds the k-th special number for a given base number n, modulo 10^9+7.\n    \n    Args:\n        n (int): The base number.\n        k (int): The position in the sequence of special numbers.\n        \n    Returns:\n        int: The k-th special number modulo 10^9+7.\n    \"\"\"\n    if k == 1:\n        return 1\n    \n    # Generate the k-th special number\n    special_numbers = []\n    power = 0\n    while True:\n        current_power = n ** power\n        if current_power > k:\n            break\n        special_numbers.append(current_power)\n        power += 1\n    \n    # If k is larger than the number of special numbers generated, return -1\n    if k > len(special_numbers):\n        return -1\n    \n    # Sum the first k special numbers\n    result = sum(special_numbers[:k]) % MOD\n    return result\n\n# Read input and process test cases\nt = int(input().strip())\nfor _ in range(t):\n    n, k = map(int, input().strip().split())\n    result = find_kth_special_number(n, k)\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirements involve understanding the concept of special numbers that can be expressed as sums of different non-negative powers of a given number n. The user needs to input the number of test cases and the values of n and k for each test case. The application should output the k-th special number in increasing order modulo 10^9+7. The application must be efficient to handle large inputs and values of n and k.\nrequirement pool:\n- Implement the logic to determine if a number is special.\n- Ensure the application can handle multiple test cases efficiently.\n- Implement the modulo operation to handle large numbers.\n- Provide a user-friendly interface for input and output.\n- Optimize the application for performance, especially with large inputs.\nTo solve this problem, we will use a mathematical approach to determine if a number is special and then generate the sequence of special numbers. We will use the modulo operation to handle large numbers efficiently. The application will be designed to handle multiple test cases efficiently, ensuring it can handle large inputs and values of n and k.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': A number that can be expressed as a sum of different non-negative powers of a given base (n).\n    Explanation: In the context of the problem, a special number is one that can be represented as the sum of distinct powers of the base n. For example, for n = 4, the number 17 is special because it can be expressed as 4^0 + 4^2 (1 + 16 = 17).\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number must be greater than zero.\n    Explanation: The requirement specifies that the numbers must be positive, so we need to ensure that the sum of powers of n results in a positive number.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest special number.\n    Explanation: The requirement asks for the k-th special number in increasing order, but it does not specify the need to find the largest one. However, since the sequence is infinite and the base n can be large, the largest special number might be relevant if k is large.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To generate the sequence of special numbers, we need to:\n    1. Check if a number is special by expressing it as a sum of different non-negative powers of n.\n    2. Generate the sequence of special numbers in increasing order.\n    3. Output the k-th special number modulo 10^9+7.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among those that meet the condition.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, and number 4 appears three times. None of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [core concept]\n    'special number': A number that can be expressed as a sum of different non-negative powers of a given base (n).\n    Explanation: In the context of the problem, a special number is one that can be represented as the sum of distinct powers of the base n. For example, for n = 4, the number 17 is special because it can be expressed as 4^0 + 4^2 (1 + 16 = 17).\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number must be greater than zero.\n    Explanation: The requirement specifies that the numbers must be positive, so we need to ensure that the sum of powers of n results in a positive number.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest special number.\n    Explanation: The requirement asks for the k-th special number in increasing order, but it does not specify the need to find the largest one. However, since the sequence is infinite and the base n can be large, the largest special number might be relevant if k is large.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To generate the sequence of special numbers, we need to:\n    1. Check if a number is special by expressing it as a sum of different non-negative powers of n.\n    2. Generate the sequence of special numbers in increasing order.\n    3. Output the k-th special number modulo 10^9+7.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among those that meet the condition.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, and number 4 appears three times. None of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the need.\n", "requirement analysis:\nThe requirements involve generating a sequence of special numbers based on the sum of different non-negative powers of a given base number n. The sequence should be sorted in increasing order and the k-th special number should be output modulo 10^9+7. The application must handle multiple test cases efficiently.\nrequirement pool:\n- Implement a function to generate the sequence of special numbers.\n- Ensure the sequence is sorted in increasing order.\n- Output the k-th special number modulo 10^9+7.\n- Handle multiple test cases efficiently.\n- Ensure the application is user-friendly and handles large inputs.\nTo solve this problem, we will use a mathematical approach to generate the sequence of special numbers. We will leverage the properties of binary representation to generate the sequence efficiently. Each special number can be represented as a sum of different non-negative powers of n, which can be mapped to binary numbers where each bit represents whether a particular power of n is included in the sum. We will use this approach to generate the sequence and then find the k-th special number. The result will be output modulo 10^9+7 to handle large numbers.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of different non-negative powers of a given base (n).\n    Explanation: In the context of this problem, a special number is one that can be represented as the sum of distinct powers of n, where n is a positive integer. For example, for n = 4, the number 17 is special because it can be expressed as 4^0 + 4^2 (1 + 16 = 17).\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find numbers greater than zero.\n    'at least as many times': means that the frequency of the number in the sequence should be at least equal to the number itself.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n\n# [code logic]\n    To implement the solution, we need to:\n    1. Iterate through the list to count the frequency of each integer.\n    2. Check if any integer appears at least as many times as itself.\n    3. Return the largest integer that meets this condition, or -1 if no such integer exists.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to themselves, but 3 is the largest number among them.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, and number 4 appears three times. None of them appear at least as many times as themselves, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.\n\n# [core concept]\n    'sum of different non-negative powers': means that each power of n is used only once in the sum.\n    Explanation: This is crucial because it defines the uniqueness of the powers used in forming the special number.\n\n# [phrase showing quantity relationship]\n    'sum of': means that we are looking at the total value obtained by adding the results of raising n to various powers.\n    'different non-negative powers': means that each power of n is unique and not repeated in the sum.\n\n# [degree adverb] \n    'increasing order': means that the special numbers are listed in ascending numerical order.\n\n# [code logic]\n    To generate the sequence of special numbers:\n    1. Start with the smallest power of n (0).\n    2. Incrementally add the next power of n to the sum, ensuring each power is used only once.\n    3. Continue this process until the desired number of special numbers is reached.\n    4. Output the k-th special number modulo 10^9+7.\n\n# [edge case] \n    search([1, 2, 4, 8, 16]) = 1\n    Explanation: The sequence includes numbers that are powers of 2. The smallest number in the sequence is 1, which is the first special number.\n    search([5, 25, 125, 625]) = 5\n    Explanation: The sequence includes numbers that are powers of 5. The smallest number in the sequence is 5, which is the first special number.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The sequence generation logic inherently starts with the smallest special number and proceeds to the next in increasing order.\n", "requirement analysis:\nThe requirements involve understanding the concept of special numbers that can be expressed as sums of different non-negative powers of a given number n. The user needs to input the values of n and k, and the application should output the k-th special number in increasing order modulo 10^9+7. The application must handle multiple test cases efficiently.\nrequirement pool:\n- Implement a function to find special numbers based on given n and k.\n- Handle multiple test cases efficiently.\n- Ensure the output is given modulo 10^9+7.\n- Develop a user-friendly interface for easy input.\n- Optimize the algorithm to handle large inputs without crashing.\nTo solve the problem of finding the k-th special number based on the given n, we will use a mathematical approach to generate the sequence of special numbers. We will leverage the fact that any special number can be represented as a sum of different non-negative powers of n. Given the constraints, we will use a brute-force approach to generate the sequence up to the k-th special number and then return the result modulo 10^9+7. The application will be efficient enough to handle the input constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be expressed as a sum of different non-negative powers of a given base (n)\n    'modulo operation': the operation of finding the remainder when one number is divided by another\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of terms in the sequence is greater than a certain value\n    'at least as many times': means that the frequency of a number in the sequence is at least as much as its value\n\n# [degree adverb] \n    'largest': indicates that the number sought is the biggest in the sequence\n\n# [code logic]\n    To generate the sequence of special numbers, we can use a brute-force approach by iterating through the powers of n and summing them up. We will keep track of the sums and ensure they are unique. Once we have generated enough special numbers, we can return the k-th one modulo 10^9+7.\n\n# [edge case] \n    k = 1, n = 2\n    expected output: 1\n    Explanation: For n = 2, the sequence starts with [1, 2, 4, 8, ...], so the 1st special number is 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where k is 1. This is because the sequence starts with 1 for any n, and we need to ensure that this is correctly returned.\n        if k == 1:\n            return 1\n        (other code)\n\n# [core concept]\n    'modulo operation': the operation of finding the remainder when one number is divided by another\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of terms in the sequence is greater than a certain value\n    'at least as many times': means that the frequency of a number in the sequence is at least as much as its value\n\n# [degree adverb] \n    'largest': indicates that the number sought is the biggest in the sequence\n\n# [code logic]\n    To generate the sequence of special numbers, we can use a brute-force approach by iterating through the powers of n and summing them up. We will keep track of the sums and ensure they are unique. Once we have generated enough special numbers, we can return the k-th one modulo 10^9+7.\n\n# [edge case] \n    k = 1, n = 2\n    expected output: 1\n    Explanation: For n = 2, the sequence starts with [1, 2, 4, 8, ...], so the 1st special number is 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where k is 1. This is because the sequence starts with 1 for any n, and we need to ensure that this is correctly returned.\n        if k == 1:\n            return 1\n        (other code)\n", "requirement analysis:\nThe requirements involve creating a program that can generate the k-th special number in a sequence defined by powers of a given integer n. The program should handle multiple test cases efficiently and output the results in a user-friendly manner. The performance and scalability of the program are crucial, especially for large values of n and k.\nrequirement pool:\n- Implement a function to generate special numbers based on the given n and k.\n- Ensure the program can handle multiple test cases efficiently.\n- Provide a user-friendly interface for inputting values of n and k.\n- Implement error handling for invalid inputs.\n- Optimize the program for large values of n and k to ensure it runs efficiently.\nTo implement the function for generating special numbers based on the given n and k, we will use Python due to its simplicity and efficiency. The function will use a mathematical approach to determine if a number can be represented as the sum of distinct non-negative powers of n. We will optimize the function to handle large values of n and k efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be represented as the sum of distinct non-negative powers of a given integer n.\n    Explanation: In this context, a special number is a result of adding up different powers of a base number n, where the powers are non-negative integers.\n\n# [phrase showing quantity relationship]\n    'distinct non-negative powers': means that each power of n used in the sum must be unique and non-negative.\n\n# [degree adverb] \n    'increasing order': means that the special numbers should be listed in ascending order.\n\n# [code logic]\n    To generate the k-th special number for a given n, we can use a mathematical approach to find the binary representation of k. Each bit in the binary representation corresponds to a power of n. For example, if k is 5, its binary representation is 101, which means the special number is n^2 + n^0. We can iterate through the bits of k, and for each bit that is set, we add the corresponding power of n to the sum.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if not lst:\n            return -1\n        freq = {}\n        for num in lst:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        result = -1\n        for num, count in freq.items():\n            if num <= count:\n                result = max(result, num)\n        return result\n", "requirement analysis:\nThe primary requirement is to generate the k-th special number for a given integer n. The application should handle multiple test cases efficiently. The output should be the k-th special number in increasing order modulo 10^9+7. The user should be able to input the values for n and k, and the application should provide a clear and intuitive interface for interaction.\nrequirement pool:\n- Implement a function to generate the k-th special number for a given n.\n- Ensure the application can handle multiple test cases efficiently.\n- Provide a user interface for inputting values of n and k.\n- Ensure the application is optimized for performance, especially for large values of n and k.\n- Include a clear and concise output format for the results.\nTo implement the function that generates the k-th special number for a given integer n, we will use a mathematical approach to determine the representation of the number as a sum of distinct non-negative powers of n. Given the constraints, we will use Python due to its efficient handling of large integers and the availability of libraries for mathematical operations. The function will be designed to handle multiple test cases efficiently, ensuring that the application can handle large inputs within reasonable time limits.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'sum of distinct non-negative powers': means that the number can be represented as a sum of different powers of a base number, where the exponent is a non-negative integer.\n    Explanation: In this case, the base number is 'n', and the powers are non-negative integers. The sum of these powers gives us a special number.\n\n# [phrase showing quantity relationship]\n    'distinct': means that each power of 'n' used in the sum must be unique.\n    Explanation: For example, if n=4, the number 17 can be represented as 4^0 + 4^2, but not as 4^0 + 4^1 + 4^1, because the second term is not distinct.\n\n# [degree adverb] \n    'increasing order': means that the special numbers should be listed in ascending order.\n    Explanation: This is important because we need to find the k-th special number in this order.\n\n# [code logic]\n    To generate the k-th special number for a given integer n, we can use a mathematical approach to determine the representation of the number as a sum of distinct non-negative powers of n. This involves finding the binary representation of k and using it to select the appropriate powers of n.\n\n# [edge case] \n    Test case: n = 2, k = 5\n    Expected output: 32\n    Explanation: The special numbers for n=2 are 1, 2, 4, 8, 16, ..., which are powers of 2. The 5th special number is 2^5 = 32.\n\n# [extra code for edge case]\n    We do not need extra code to handle this edge case. The mathematical approach we outlined will work for any valid input within the given constraints.\n", "requirement analysis:\nThe primary requirement is to generate the k-th special number for a given base n. The application must handle a large number of test cases efficiently. The output should be the k-th special number in increasing order modulo 10^9+7. The user interface should be intuitive and the application should be robust against large inputs.\nrequirement pool:\n- Implement a function to generate special numbers based on powers of n.\n- Ensure the application can handle multiple test cases efficiently.\n- Develop a user-friendly interface for input and output.\n- Optimize the algorithm to handle large inputs and ensure performance.\nTo implement the function for generating special numbers based on powers of n, we will use Python due to its efficiency and ease of handling large numbers. The function will take an integer n and a position k, and it will compute the k-th special number by summing distinct non-negative powers of n. We will use modular arithmetic to ensure the results are within the required range modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': a number that can be represented as the sum of distinct non-negative powers of a given integer.\n    Explanation: In this context, a special number is composed of sums of powers of a base number n, where the powers are non-negative integers and distinct.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the number of times a special number appears must be greater than its value.\n    Explanation: For example, in the requirement, we need to find numbers that can be represented as sums of distinct non-negative powers of n, and these numbers must appear more than or equal to their value.\n\n# [degree adverb] \n    'largest': suggests that we need to find the largest integer that meets the condition.\n    Explanation: In the requirement, we need to find the largest integer that appears more than or equal to its value.\n\n# [code logic]\n    To generate the k-th special number, we need to:\n    1. Understand that a special number can be represented as a sum of distinct non-negative powers of n.\n    2. Use a loop to find the k-th special number by summing distinct powers of n.\n    3. Use modular arithmetic to ensure the result is within the range of 10^9+7.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    Explanation: In this case, the number 3 appears more than or equal to its value (3 times), which is the largest number that meets the condition.\n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their values, but 3 is the largest number.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the condition.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if not lst:\n            return -1\n        freq = {}\n        for num in lst:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        result = -1\n        for num, count in freq.items():\n            if count >= num:\n                result = max(result, num)\n        return result\n", "requirement analysis:\nThe requirements involve finding the k-th special number in a sequence generated by summing different non-negative powers of n, modulo 10^9+7. This requires a deep understanding of number theory and efficient algorithms to handle large inputs. The solution must be robust, scalable, and accurate.\nrequirement pool:\n- Implement an efficient algorithm to generate the sequence of special numbers.\n- Ensure the solution handles large values of n and k efficiently.\n- Provide outputs modulo 10^9+7 as specified.\n- Develop a user-friendly interface for easy input and output.\n- Conduct thorough testing to ensure accuracy and reliability.\nTo solve the problem of finding the k-th special number in a sequence consisting of numbers that can be written as sums of different non-negative powers of n, modulo 10^9+7, we will use Python due to its powerful standard library and ability to handle large numbers efficiently. The approach involves understanding the mathematical properties of the sequence and implementing an algorithm that can generate the sequence and find the k-th element efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'sums of different non-negative powers': means that each number in the sequence is a unique combination of powers of n, and the sum of these powers is taken modulo 10^9+7.\n    Explanation: This concept involves understanding how to generate numbers that can be expressed as sums of different non-negative powers of a base number n, and then finding the k-th such number in a sequence.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To solve this problem, we need to generate the sequence of numbers that can be written as sums of different non-negative powers of n, modulo 10^9+7. This can be achieved by using a mathematical approach to represent numbers in base n and then summing the powers.\n\n# [edge case] \n    search([1, 2, 3, 4, 5], 3) = 3\n    Explanation: In this case, the sequence is [1, 2, 3, 4, 5], and the 3rd special number is 3.\n    search([1, 2, 3, 4, 5], 6) = -1\n    Explanation: The sequence is [1, 2, 3, 4, 5], and there is no 6th special number in this sequence.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where k is greater than the number of special numbers in the sequence.\n        if k > len(sequence):\n            return -1\n        (other code)\n", "requirement analysis:\nThe requirements involve generating a sequence of numbers that are sums of different non-negative powers of a given integer n, and finding the k-th number in this sequence. The output should be the k-th special number modulo 10^9+7. The challenge lies in efficiently computing this for large values of n and k, while ensuring the results are accurate and within the given constraints.\nrequirement pool:\n- Implement a function to generate the sequence of numbers as sums of different non-negative powers of n.\n- Develop a method to find the k-th number in the sequence efficiently.\n- Ensure the results are computed modulo 10^9+7 to meet the requirements.\n- Optimize the algorithm for large inputs to ensure performance.\n- Provide clear and user-friendly input/output handling.\nTo solve the problem of finding the k-th special number in a sequence consisting of numbers that can be written as sums of different non-negative powers of n, modulo 10^9+7, we will use a mathematical approach. The sequence can be generated using the concept of the binary representation of numbers, where each bit represents whether a particular power of n is included in the sum. This approach allows us to efficiently generate the sequence and find the k-th number without explicitly storing the entire sequence, which is crucial for handling large values of k. The modulo operation ensures that the results stay within the required range.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'sums of different non-negative powers of n': This means that each number in the sequence can be represented as a sum of unique powers of n, similar to how binary numbers are sums of powers of 2.\n    Explanation: For example, if n = 3, then the sequence would include numbers like 1 (3^0), 3 (3^1), 9 (3^2), etc.\n\n# [phrase showing quantity relationship]\n    'different non-negative powers': This indicates that each power of n used in the sum must be unique.\n    Explanation: For instance, in the sequence for n = 2, the number 8 (2^3) is included because it is 2^3, not because it uses the same power more than once.\n\n# [degree adverb] \n    'increasing order': This means that the numbers in the sequence should be sorted from smallest to largest.\n    Explanation: For example, the sequence for n = 2 starts with 1, 2, 4, 8, etc., and these numbers are in increasing order.\n\n# [code logic]\n    To generate the k-th special number, we can use a loop to find the binary representation of k, then convert each bit to the corresponding power of n, and sum these powers. This approach avoids generating the entire sequence, making it efficient for large values of k.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    Explanation: In this case, the list is [1, 2, 2, 3, 3, 3, 4, 4, 4]. The number 3 appears 3 times, which is more than or equal to its value. Since 3 is the largest number with this property, it is the correct output.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to find the largest integer that appears at least as many times as itself in the list.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: The list is [2, 2, 3, 3, 3]. The number 3 appears 3 times, which is more than or equal to its value. Since 3 is the largest number with this property, it is the correct output.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to find the largest integer that appears at least as many times as itself in the list.\n", "requirement analysis:\nThe requirements involve generating a sequence of numbers that are sums of different non-negative powers of a given integer n, and finding the k-th number in this sequence. The output should be the k-th special number in increasing order modulo 10^9+7. The challenge lies in efficiently handling large inputs and ensuring the results are accurate and formatted correctly.\nrequirement pool:\n- Implement a function to generate the sequence of special numbers.\n- Ensure the function can handle large values of n and k.\n- Implement the modulo operation to keep the results within the specified range.\n- Optimize the performance to handle large inputs efficiently.\n- Ensure the output format matches the required specifications.\nTo solve the problem of finding the k-th special number in a sequence consisting of numbers that can be written as sums of different non-negative powers of n, modulo 10^9+7, we will use Python due to its efficiency and ease of handling large numbers. The approach involves generating the sequence of special numbers by summing different powers of n and then finding the k-th number in this sequence. We will ensure the results are accurate and formatted correctly by using the modulo operation.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'sum of different non-negative powers of n': means that each special number is a sum of unique powers of n, where n is a positive integer.\n    'modulo 10^9+7': means that all results should be taken modulo 10^9+7 to prevent overflow and to match the given output format.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To generate the k-th special number, we need to:\n    1. Understand that each special number is a sum of unique powers of n.\n    2. Use a loop to generate these sums until we reach the k-th special number.\n    3. Use the modulo operation to ensure the results are within the specified range.\n\n# [edge case] \n    search([1, 2, 4, 8, 16], 3) = 9\n    explanation: The sequence of special numbers generated from powers of 2 is [1, 2, 4, 8, 16, ...]. The 3rd special number is 9.\n    search([1, 2, 4, 8, 16], 10) = 31\n    explanation: The sequence continues to grow, and the 10th special number is 31.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where k is larger than the number of possible special numbers. This can be done by dynamically generating the sequence until we reach the k-th special number or exceed it. If k exceeds the number of possible special numbers, we return an error or a message indicating the limit has been exceeded.\n\n    def find_kth_special_number(n, k):\n        special_numbers = []\n        power = 0\n        while len(special_numbers) < k:\n            current_power = n ** power\n            for i in range(len(special_numbers) + 1):\n                current_sum = sum(special_numbers[i:] + [current_power])\n                if current_sum not in special_numbers:\n                    special_numbers.append(current_sum)\n            power += 1\n        return special_numbers[k - 1] % (10**9 + 7)\n", "requirement analysis:\nThe requirements involve understanding the concept of special numbers that can be expressed as sums of different non-negative powers of a given number n. The user needs to input the values of n and k, and the application should output the k-th special number in increasing order modulo 10^9+7. The application must be efficient to handle large inputs and provide accurate results.\nrequirement pool:\n- Implement the logic to find special numbers based on the given n and k.\n- Ensure the application can handle large values of n and k efficiently.\n- Provide the output in the required format, including modulo 10^9+7.\n- Develop a user-friendly interface for easy input and output.\n- Test the application with various test cases to ensure accuracy and robustness.\nTo solve the problem of finding the k-th special number based on the given n, we will use a mathematical approach to generate the sequence of special numbers. Since the sequence grows exponentially, we will leverage Python's ability to handle large integers efficiently. We will implement a function that calculates the k-th special number modulo 10^9+7. The function will be designed to handle multiple test cases efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'special number': A number that can be expressed as a sum of different non-negative powers of a base number n.\n    Explanation: In the context of the problem, a special number is one that can be represented as the sum of distinct powers of n, where n is a positive integer. For example, for n = 4, the number 17 is special because it can be expressed as 4^0 + 4^2 (1 + 16 = 17).\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number must be greater than zero.\n    Explanation: The requirement specifies that the numbers must be positive, so we need to ensure that the sum of powers of n is greater than zero.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest integer that meets the condition.\n    Explanation: In the context of the problem, finding the largest special number means identifying the highest value that can be expressed as a sum of different non-negative powers of n.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To generate the k-th special number, we need to consider the sequence of numbers that can be expressed as sums of different non-negative powers of n. This sequence grows exponentially, so we need to handle large numbers efficiently. We will use a mathematical approach to generate these numbers and ensure that the result is modulo 10^9+7 to handle large values.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among them.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [core concept]\n    'special number': A number that can be expressed as a sum of different non-negative powers of a base number n.\n    Explanation: In the context of the problem, a special number is one that can be represented as the sum of distinct powers of n, where n is a positive integer. For example, for n = 4, the number 17 is special because it can be expressed as 4^0 + 4^2 (1 + 16 = 17).\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number must be greater than zero.\n    Explanation: The requirement specifies that the numbers must be positive, so we need to ensure that the sum of powers of n is greater than zero.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest integer that meets the condition.\n    Explanation: In the context of the problem, finding the largest special number means identifying the highest value that can be expressed as a sum of different non-negative powers of n.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To generate the k-th special number, we need to consider the sequence of numbers that can be expressed as sums of different non-negative powers of n. This sequence grows exponentially, so we need to handle large numbers efficiently. We will use a mathematical approach to generate these numbers and ensure that the result is modulo 10^9+7 to handle large values.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number among them.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the need.\n"], "scores": [], "pass_results": [false, true, false, true, true, false, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 62, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "mutate_method": "expand_one2two", "parent_index": 68}
