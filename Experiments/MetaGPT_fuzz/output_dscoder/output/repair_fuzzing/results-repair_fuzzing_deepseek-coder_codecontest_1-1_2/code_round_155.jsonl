{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp possesses an array a made up of n integers. Let's denote k as the arithmetic mean of these elements. It's important to note that it's possible that k is not an integer. \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Consider edge cases where the array is too small or all elements are identical. Make sure to handle arrays with fewer than three elements gracefully. Ensure to check for scenarios where deleting any pairing might disrupt the intended mean.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp possesses an array a made up of n integers. Let's denote k as the arithmetic mean of these elements. It's important to note that it's possible that k is not an integer. \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Consider edge cases where the array is too small or all elements are identical. Make sure to handle arrays with fewer than three elements gracefully. Ensure to check for scenarios where deleting any pairing might disrupt the intended mean.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a consisting of n integers. The arithmetic mean of these elements is denoted as k. The arithmetic mean of an array is calculated by dividing the sum of its elements by the number of elements (i.e., sum divided by n).\n\nMonocarp wants to remove exactly two elements from this array a so that the arithmetic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to determine the number of pairs of positions [i, j] (where i < j) such that if the elements at these positions are removed, the arithmetic mean of\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin", " Monocarp has an array a of n integers, and the arithmetic mean k of these elements remains unchanged after deleting exactly two elements, ensuring the mean of the remaining (n - 2) elements equals k. Your task is to find the number of pairs [i, j] (i < j) whose deletion maintains the arithmetic mean k, considering edge cases with fewer than three elements or identical elements.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs(arr: List[int], mean_value: float) -> int:\n    n = len(arr)\n    if n < 3:\n        return 0\n    if all(x == arr[0] for x in arr):\n        return n * (n - 1) // 2\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if sum(new_arr) / (n - 2) == mean_value:\n                count += 1\n    return count\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    mean_value = sum(arr) / n\n    result = calculate_pairs(arr, mean_value)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    if n < 3:\n        return 0\n    \n    original_mean = sum(arr) / n\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if sum(new_arr) / (n - 2) == original_mean:\n                count += 1\n    \n    return count\n\n# Handle edge cases\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        arr = list(map(int, data[index+1:index+n+1]))\n        index += n + 1\n        result = calculate_pairs(n, arr)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef calculate_pairs(arr: List[int], mean_value: float) -> int:\n    n = len(arr)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            temp_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if sum(temp_arr) / (n - 2) == mean_value:\n                count += 1\n    return count\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\nmean_value = sum(arr) / n\n\n# Calculate and print the result\nresult = calculate_pairs(arr, mean_value)\nprint(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef count_pairs_to_remove(n, arr):\n    total_sum = sum(arr)\n    mean_value = total_sum / n\n\n    pairs_to_remove = 0\n\n    # Create a dictionary to count the frequency of each element\n    element_count = {}\n    for num in arr:\n        element_count[num] = element_count.get(num, 0) + 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements after removing arr[i] and arr[j]\n            remaining_sum = total_sum - arr[i] - arr[j]\n            remaining_count = n - 2\n\n            # Check if the new mean is equal to the original mean\n            if remaining_sum / remaining_count == mean_value:\n                pairs_to_remove += 1\n\n    return pairs_to_remove\n\n# Provide the Interface\nt = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    arr = list(map(int, input().strip().split()))\n    result = count_pairs_to_remove(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Iterate through all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the array without the elements at positions i and j\n            new_sum = total_sum - arr[i] - arr[j]\n            # Calculate the new mean\n            new_mean = new_sum / (n - 2)\n            # Check if the new mean is equal to the original mean\n            if new_mean == mean:\n                count += 1\n    \n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_pairs(n: int, arr: List[int]) -> int:\n    # Calculate the arithmetic mean of the array\n    total_sum = sum(arr)\n    k = total_sum / n\n    \n    # If all elements are the same, any pair can be removed\n    if all(x == arr[0] for x in arr):\n        return n * (n - 1) // 2\n    \n    # Initialize the count of valid pairs\n    count = 0\n    \n    # Iterate through all possible pairs of indices (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the new sum after removing elements at indices i and j\n            new_sum = total_sum - arr[i] - arr[j]\n            # Check if the new arithmetic mean is still equal to k\n            if new_sum / (n - 2) == k:\n                count += 1\n    \n    return count\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the array elements\n    arr = list(map(int, input().split()))\n    # Call the function and print the result\n    result = find_pairs(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    if n < 3:\n        return -1\n    original_mean = sum(arr) / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = sum(arr[:i]) + sum(arr[i+1:j]) + sum(arr[j+1:])\n            new_len = n - 2\n            new_mean = new_sum / new_len\n            if abs(new_mean - original_mean) < 1e-9:\n                count += 1\n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs_to_maintain_mean(n: int, arr: List[int]) -> int:\n    if n < 3:\n        return -1\n    \n    mean = sum(arr) / n\n    \n    if all(x == arr[0] for x in arr):\n        return n * (n - 1) // 2\n    \n    pairs_counter = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n            if sum(new_arr) / (n - 2) == mean:\n                pairs_counter += 1\n    \n    return pairs_counter\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs_to_maintain_mean(n, arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_pairs(n: int, arr: List[int]) -> int:\n    if n < 3:\n        return 0\n    \n    total_sum = sum(arr)\n    k = total_sum / n\n    \n    if all(x == arr[0] for x in arr):\n        return n * (n - 1) // 2\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_n = n - 2\n            if new_n > 0 and new_sum / new_n == k:\n                count += 1\n    return count\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_pairs(n, arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_pairs(arr: List[int], mean_value: float) -> int:\n    n = len(arr)\n    if n < 3:\n        return 0\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (sum(arr[:i] + arr[i+1:j] + arr[j+1:]) / (n - 2)) == mean_value:\n                count += 1\n    return count\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nmean_value = sum(arr) / n\nresult = calculate_pairs(arr, mean_value)\nprint(result)\n"], "plans": ["requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions maintains the arithmetic mean of the array. The solution must handle edge cases and ensure efficiency for large inputs. The array elements can be any integer within the range [0, 10^9], and the number of test cases and elements can be up to 10^4 and 2*10^5 respectively.\nrequirement pool:\n- Implement a function to calculate the arithmetic mean of the array.\n- Develop a method to find pairs of positions [i, j] to delete.\n- Ensure the solution handles edge cases and large inputs efficiently.\n- Optimize the algorithm for performance.\n- Add support for handling large inputs within the given constraints.\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The approach involves calculating the arithmetic mean of the array and then finding pairs of indices whose deletion maintains this mean. We will use a brute-force method initially to ensure correctness and then optimize it for better performance.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The average of a set of numbers. In this case, it's the mean of the entire array and also the target mean we want to maintain after deleting two elements.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The plan suggests a brute-force approach initially, which involves:\n    1. Calculating the arithmetic mean of the array.\n    2. Iterating through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, checking if the deletion of elements at these indices maintains the arithmetic mean.\n    4. Counting the number of such pairs.\n\n# [edge case] \n    Edge cases to consider:\n    - Array with fewer than three elements: In such cases, it's impossible to delete two elements to maintain the mean, so the result should be 0.\n    - All elements are identical: In this scenario, any pair of deletions will disrupt the mean, so the result should be 0.\n    - Large arrays: The problem statement guarantees a maximum of 2 * 10^5 elements, which might require optimization.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the array has fewer than three elements or all elements are identical.\n    ```python\n    if n < 3:\n        return 0\n    ```\n\n    Additionally, we should handle the case where all elements are the same:\n    ```python\n    if all(x == a[0] for x in a):\n        return n * (n - 1) // 2\n    ```\n\n    These checks ensure that the function gracefully handles edge cases without unnecessary computations.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the remaining elements having the same arithmetic mean as the original array. The solution must handle edge cases, such as arrays with fewer than three elements, and must be efficient enough to handle large datasets within the given constraints.\nrequirement pool:\n- Implement a function to calculate the arithmetic mean of the array\n- Create a function to find pairs of positions [i, j] for deletion\n- Ensure the solution handles edge cases and large datasets efficiently\n- Develop a user-friendly interface for input and output\n- Optimize the algorithm for better performance\nTo solve this problem, we will use Python due to its simplicity and efficiency. The main challenge is to efficiently calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the remaining elements having the same arithmetic mean as the original array. We will use a brute-force approach initially to ensure correctness, and then optimize it if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The average of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of elements in the array such that after their removal, the mean of the remaining elements is the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number of times an element appears should be greater than or equal to the element itself.\n    Explanation: For example, if an element is 3, it must appear at least 3 times in the array for it to be considered.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest element that meets the condition.\n    Explanation: We need to find the largest integer that appears at least as many times as itself in the array.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we will follow these steps:\n    1. Calculate the arithmetic mean of the entire array.\n    2. Iterate through all possible pairs of elements in the array.\n    3. For each pair, calculate the new mean of the remaining elements.\n    4. Check if the new mean is equal to the original mean.\n    5. Count the number of such pairs.\n\n# [edge case] \n    Edge case 1: Array with fewer than three elements.\n    Expected output: 0\n    Explanation: If the array has fewer than three elements, it's impossible to delete any two elements and still have a mean.\n\n    Edge case 2: All elements in the array are identical.\n    Expected output: The number of pairs, which is calculated by the formula (n * (n - 1)) / 2.\n    Explanation: If all elements are the same, deleting any two elements will not change the mean.\n\n    Edge case 3: No element can be deleted to achieve the original mean.\n    Expected output: 0\n    Explanation: If no pair of elements can be deleted to achieve the original mean, the result should be 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array has fewer than three elements or all elements are identical.\n    def count_pairs(arr):\n        n = len(arr)\n        if n < 3:\n            return 0\n        original_mean = sum(arr) / n\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n                if sum(new_arr) / (n - 2) == original_mean:\n                    count += 1\n        return count\n\n    # Handle edge cases\n    if n < 3:\n        return 0\n    if all(x == arr[0] for x in arr):\n        return (n * (n - 1)) // 2\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the remaining elements having the same arithmetic mean as the original array. The solution must handle edge cases and ensure efficiency, especially for large datasets.\nrequirement pool:\n- Implement a function to calculate the arithmetic mean of the array\n- Create a function to find pairs [i, j] where deleting elements at these positions maintains the mean\n- Handle edge cases where the array has fewer than three elements\n- Ensure the solution is efficient and can handle up to 2 * 10^5 elements\n- Provide a user-friendly interface for input and output\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The approach involves calculating the arithmetic mean of the array and then finding pairs of indices [i, j] such that deleting the elements at these positions maintains the mean. We will use a brute-force approach initially to ensure correctness and then optimize it if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The average of a set of numbers calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of indices [i, j] such that deleting the elements at these positions keeps the mean of the remaining elements equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that we need to find pairs where the sum of elements at the positions is greater than the mean.\n    Explanation: We need to ensure that the sum of the elements at positions [i, j] is greater than the arithmetic mean of the entire array.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest pairs that maintain the mean.\n    Explanation: We need to find the pairs that, when removed, do not change the mean significantly.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Provide detailed logic to implement the code\n\n# [edge case] \n    Edge case 1: Array with all elements identical\n    search([5, 5, 5]) = 1\n    Explanation: There is only one pair [0, 1] that can be removed to maintain the mean.\n\n    Edge case 2: Array with fewer than three elements\n    search([1]) = 0\n    Explanation: With fewer than three elements, it's impossible to remove any pair to maintain the mean.\n\n    Edge case 3: Array where no pair can be removed to maintain the mean\n    search([1, 2, 3]) = 0\n    Explanation: No pair can be removed to maintain the mean because the mean of the entire array is not an integer.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n < 3:\n            return 0\n        if all(x == a[0] for x in a):\n            return n * (n - 1) // 2\n\n    (other code)\n", "requirement analysis:\nThe problem requires calculating the arithmetic mean of the array and then finding pairs of indices whose removal will not change the mean. The constraints are high, requiring the solution to be efficient and handle up to 2 * 10^5 elements. The solution should be clear and concise, using standard input/output methods.\nrequirement pool:\n- Implement a function to calculate the arithmetic mean of the array.\n- Create a function to find pairs of indices whose removal will not change the mean.\n- Ensure the solution is efficient and can handle up to 2 * 10^5 elements.\n- Provide clear and accurate output as specified in the problem statement.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations. The main challenge is to find pairs of indices whose removal will not change the arithmetic mean of the array. We will calculate the mean of the array and then iterate through all possible pairs of indices to check if their removal maintains the mean. This approach will be efficient due to the use of Python's optimized list operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The average value of a set of numbers. It is calculated by dividing the sum of the numbers by the count of the numbers.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that a value must be greater than a specified amount.\n\n# [degree adverb] \n    'largest': Indicates the greatest value in a set.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    No specific edge cases are provided in the requirement.\n\n# [extra code for edge case]\n    No extra code is needed for edge cases as the provided logic should handle normal cases.\n\nPlease provide the coding plan and requirement for further analysis.\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that removing the elements at these positions keeps the arithmetic mean unchanged. This involves summing the elements, calculating the mean, and then checking all possible pairs to see if removing them changes the mean. The solution must be efficient to handle the upper limits of input size.\nrequirement pool:\n- Implement a function to calculate the arithmetic mean of the array.\n- Create a function to iterate through all pairs [i, j] and check if removing them changes the mean.\n- Ensure the solution is optimized to handle the upper limits of input size.\n- Add user input handling to allow for multiple test cases.\n- Implement error handling for invalid inputs.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to calculate the arithmetic mean and iterate through pairs of positions. We will first calculate the mean of the array and then check each pair of positions to see if removing them changes the mean. The solution will be optimized to handle the upper limits of input size by using efficient algorithms and data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The average value of a set of numbers. It is calculated by dividing the sum of the numbers by the count of the numbers.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that a value must be greater than a specified amount.\n\n# [degree adverb] \n    'largest': Indicates the greatest value in a set.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 0\n    explanation: No matter which two elements are removed, the arithmetic mean of the remaining elements will change.\n    search([1, 1, 1, 1, 1]) = 10\n    explanation: Any two elements can be removed, and the arithmetic mean of the remaining elements will still be 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case.\n        if n < 3:\n            return 0\n        (other code)\n", "requirement analysis:\nThe problem requires calculating the arithmetic mean of the array and then finding pairs of indices whose removal maintains the same mean. This involves a straightforward calculation and a nested loop to check all pairs. The constraints are high, requiring the solution to be efficient to handle up to 2 * 10^5 elements.\nrequirement pool:\n- Implement the calculation of the arithmetic mean\n- Find all pairs of indices\n- Check if removing the elements at these indices maintains the mean\n- Optimize the algorithm for large inputs\n- Add user input handling for multiple test cases\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the input and output, and iterate through the array to find all possible pairs of indices whose removal maintains the arithmetic mean. We will optimize the solution by avoiding unnecessary computations and leveraging Python's capabilities for handling large datasets.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The average value of a set of numbers. It is calculated by dividing the sum of the numbers by the count of the numbers.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that a value must be greater than a specified amount.\n\n# [degree adverb] \n    'largest': Indicates the maximum value in a set.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Calculate the arithmetic mean (k) of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new sum of the array after removing the elements at indices i and j.\n    4. Check if the new arithmetic mean of the remaining elements is still equal to k.\n    5. Count the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 0\n    Explanation: In this case, there are no pairs of elements that can be removed to maintain the arithmetic mean.\n    search([2, 2, 2, 2, 2]) = 10\n    Explanation: All elements are the same, so any pair can be removed to maintain the arithmetic mean. There are 10 possible pairs (0-1, 0-2, ..., 3-4).\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same. In such a case, any pair can be removed to maintain the arithmetic mean.\n        if all elements are the same:\n            return n * (n - 1) // 2\n\nPlease note that the edge case analysis and extra code handling are based on the assumption that the core logic and code implementation are provided elsewhere. The above response focuses on the structure and format required for the analysis.\n", "requirement analysis:\nThe problem requires finding pairs of elements in an array whose deletion maintains the arithmetic mean. This involves calculating the mean of the entire array and then checking if the mean of the remaining elements after deleting two specific elements is still equal to the original mean. The constraints are high, with up to 2 * 10^5 elements across multiple test cases, which makes the solution need to be optimized for performance.\nrequirement pool:\n- Implement a function to calculate the mean of the array.\n- Create a function to find pairs of indices whose deletion maintains the mean.\n- Ensure the solution is efficient and can handle large inputs.\n- Handle edge cases where the array has fewer than three elements or all elements are identical.\n- Optimize the algorithm for performance to handle up to 2 * 10^5 elements.\nTo solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through all possible pairs of indices to check if their deletion maintains the mean. We will use a brute-force method initially and optimize it later if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The sum of all elements divided by the number of elements.\n    Explanation: The arithmetic mean (average) of a set of numbers is calculated by adding all the numbers together and then dividing by the count of numbers. In this problem, we need to ensure that the mean of the remaining elements after deleting two is equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that we need to find pairs of indices whose deletion does not change the mean significantly.\n    Explanation: For example, if we have a list [1, 2, 3, 4], the mean is (1+2+3+4)/4 = 2.5. Deleting the elements at indices 1 and 3 (i.e., 2 and 4) leaves [1, 3], and the mean is (1+3)/2 = 2, which is the same as the original mean.\n\n# [degree adverb] \n    'exactly': Indicates that we need to find pairs of indices where exactly two elements are deleted.\n    Explanation: For instance, in the list [1, 2, 3, 4], deleting the elements at indices 1 and 3 (i.e., 2 and 4) results in [1, 3], and the mean remains unchanged.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement this, we need to:\n    1. Calculate the original mean of the array.\n    2. Iterate through all possible pairs of indices (i, j) where i < j.\n    3. For each pair, calculate the new mean after deleting the elements at indices i and j.\n    4. Count the number of pairs whose deletion maintains the original mean.\n\n# [edge case] \n    Edge case 1: Array with fewer than three elements.\n    Edge case 1 = -1\n    Explanation: If the array has fewer than three elements, it's impossible to delete exactly two elements and maintain the mean. Therefore, the expected output is -1.\n\n    Edge case 2: Array with all identical elements.\n    Edge case 2 = 0\n    Explanation: If all elements are the same, deleting any two elements will change the mean. Thus, the expected output is 0.\n\n    Edge case 3: Array with elements that sum to zero.\n    Edge case 3 = 0\n    Explanation: If the sum of all elements is zero, deleting any two elements will change the mean. Thus, the expected output is 0.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the array has fewer than three elements or all elements are identical.\n    Example code:\n    if n < 3:\n        return -1\n    if all(x == a[0] for x in a):\n        return 0\n    (other code)\n", "requirement analysis:\nThe primary requirement is to find pairs of indices in an array such that the deletion of the elements at these indices maintains the arithmetic mean unchanged. This involves calculating the mean of the entire array and then checking pairs of elements to see if their deletion does not alter the mean. The challenge lies in efficiently handling large inputs and ensuring the solution is robust against edge cases.\nrequirement pool:\n- Implement an algorithm to find pairs of indices whose deletion maintains the arithmetic mean.\n- Ensure the solution can handle large inputs efficiently.\n- Handle edge cases where the array has fewer than three elements or contains identical elements.\n- Optimize the algorithm for performance to handle the upper limits of input size.\n- Provide clear and concise output for user understanding.\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The approach involves calculating the arithmetic mean of the array and then iterating through all possible pairs of indices to check if their deletion maintains the mean. We will use a brute-force method initially to ensure correctness and then optimize if necessary.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The sum of all elements divided by the number of elements. It represents the average value of the dataset.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that a certain condition must be met in terms of the frequency of elements.\n\n# [degree adverb] \n    'largest': Indicates that the sought-after value is the biggest in the dataset.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan involves:\n    1. Calculating the arithmetic mean of the array.\n    2. Iterating through all possible pairs of indices to check if their deletion maintains the mean.\n    3. Counting the number of such pairs.\n\n# [edge case] \n    search([1, 2, 3]) = -1\n    explanation: With only three elements, it's impossible to delete two elements and maintain the mean. The expected output is -1.\n    search([2, 2, 2]) = 1\n    explanation: All elements are the same, so deleting any two elements will maintain the mean. The only pair is [0, 1], so the expected output is 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has fewer than three elements.\n        if n < 3:\n            return -1\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has identical elements.\n        if all(x == a[0] for x in a):\n            return n * (n - 1) // 2\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has zero values, which could affect the mean calculation.\n        if 0 in a:\n            return 0\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs [i, j] whose deletion maintains the arithmetic mean k. This involves summing the elements, calculating the mean, and then checking if removing two specific elements results in the same mean. The solution must handle edge cases such as arrays with fewer than three elements or identical elements efficiently.\nrequirement pool:\n- Implement a function to calculate the arithmetic mean of the array.\n- Create a function to find pairs [i, j] whose deletion maintains the mean.\n- Ensure the solution is optimized for large inputs.\n- Handle edge cases such as arrays with fewer than three elements or identical elements.\n- Provide clear and accurate output for each test case.\nTo solve this problem efficiently, we will use Python's built-in functions and libraries to handle the array operations. The main challenge is to find pairs [i, j] such that deleting them maintains the arithmetic mean k. We will iterate through the array, calculate the mean, and check the condition for each pair. The solution will be optimized to handle large inputs within the given constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': the sum of all elements divided by the number of elements.\n    'deleting elements': removing elements from the array to maintain the mean.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': means we need to remove two specific elements from the array.\n    'remaining elements': means the elements left after removing two specific elements.\n\n# [degree adverb] \n    'exactly': means we need to find pairs that, when removed, result in the mean of the remaining elements being equal to k.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    For each test case:\n    1. Calculate the arithmetic mean k of the array.\n    2. Iterate through all possible pairs [i, j] (i < j) in the array.\n    3. For each pair, calculate the new mean of the remaining elements after deletion.\n    4. Check if the new mean is equal to k.\n    5. Count the number of such pairs.\n    6. Return the count.\n\n# [edge case] \n    search([1, 1, 1]) = 0\n    explanation: With only three elements, there are no pairs to delete, so the expected output is 0.\n    search([2, 2, 2, 2]) = 6\n    explanation: All pairs of elements can be deleted, resulting in a mean of 2 for the remaining elements, so the expected output is 6.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array has fewer than three elements.\n        if n < 3:\n            return 0\n        (other code)\n\n# [edge case] \n    search([1, 1, 1, 1]) = 3\n    explanation: With four elements, we can delete any two of the elements, resulting in a mean of 1 for the remaining elements, so the expected output is 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are identical.\n        if all(x == a[0] for x in a):\n            return n * (n - 1) // 2\n        (other code)\n", "requirement analysis:\nThe primary requirement is to calculate the number of pairs of positions [i, j] such that deleting the elements at these positions results in the arithmetic mean of the remaining elements being equal to the original arithmetic mean. The solution must handle edge cases, such as arrays with fewer than three elements, and must be efficient enough to handle large datasets within the given constraints.\nrequirement pool:\n- Implement a function to calculate the arithmetic mean of the array.\n- Create a function to find all pairs [i, j] where i < j.\n- Ensure the function can handle edge cases and large datasets.\n- Add user interface elements to display the results clearly.\n- Optimize the algorithm for better performance on large inputs.\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The approach involves calculating the arithmetic mean of the array and then finding all pairs [i, j] where i < j such that deleting the elements at these positions results in the arithmetic mean of the remaining elements being equal to the original arithmetic mean. We will optimize the algorithm to handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'arithmetic mean': The average of a set of numbers, calculated by dividing the sum of the numbers by the count of the numbers.\n    Explanation: In this problem, we need to find pairs of elements in the array such that after their removal, the mean of the remaining elements is still equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that we need to find pairs where the sum of the elements at these positions is greater than the sum of the elements at other positions.\n    Explanation: This phrase is not directly used in the requirement, but it's implied in the need to find pairs that, when removed, do not change the mean of the array.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest possible pairs that, when removed, do not change the mean.\n    Explanation: This phrase is not directly used in the requirement, but it's implied in the need to find the most significant pairs for removal.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement this, we need to:\n    1. Calculate the arithmetic mean of the array.\n    2. Iterate through all possible pairs [i, j] where i < j.\n    3. Check if removing the elements at positions i and j results in the mean of the remaining elements being equal to the original mean.\n    4. Count such pairs.\n\n# [edge case] \n    Edge case 1: Array with fewer than three elements.\n    Expected output: 0\n    Explanation: If the array has fewer than three elements, it's impossible to remove any two elements and still have a mean.\n\n    Edge case 2: All elements in the array are identical.\n    Expected output: The number of pairs, which is n choose 2 (nC2).\n    Explanation: If all elements are the same, removing any two elements will not change the mean.\n\n    Edge case 3: Array where removing any two elements changes the mean.\n    Expected output: The number of pairs that, when removed, do not change the mean.\n    Explanation: This case checks for scenarios where the removal of any two elements disrupts the intended mean.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the array has fewer than three elements or all elements are identical.\n    Example code for handling edge case 1:\n        if n < 3:\n            return 0\n\n    Example code for handling edge case 2:\n        if all(x == a[0] for x in a):\n            return n * (n - 1) // 2\n\n    Example code for handling edge case 3:\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (sum(a[:i] + a[i+1:j] + a[j+1:]) / (n - 2)) == mean:\n                    count += 1\n        return count\n"], "scores": [], "pass_results": [true, true, false, true, false, false, true, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 155, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "rephrase_one", "parent_index": 153}
