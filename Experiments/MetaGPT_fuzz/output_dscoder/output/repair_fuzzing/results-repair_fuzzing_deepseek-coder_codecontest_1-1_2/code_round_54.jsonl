{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones has returned to aid his distant relative, Indiana Jones, in discovering a hidden treasure within a labyrinth situated beneath a desert filled with illusions.\n\nThe labyrinth's map resembles a tree comprising n rooms numbered from 1 to n. There are n - 1 tunnels linking them, ensuring that every pair of rooms can be reached via various tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) possesses an illusion rate a_i. In order to move from the x-th room to the y-th room, there needs to be a tunnel connecting x and y, and traversing it requires max(|a_x + a_y|, |a_x - a_y|) energy. |z| signifies the absolute value of z.\n\nTo deter potential looters, the labyrinth can alter the illusion rate of any room within it. The labyrinth possesses the capability to adjust these rates to deceive or misguide potential robbers. Chanek and Indiana will present q inquiries.\n\nThe queries to be processed are of two sorts:\n\n  * 1\\ u\\ c \u2014 The illusion level of the x-th room is altered to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the least sum of energy required to retrieve the hidden treasure located in room v if they commence from room u (1 \u2264 u, v \u2264 n).\n\nAssist them, and you can earn a share of the treasure! Your solution should efficiently handle adjustments to illusion rates and compute minimal energy paths within the labyrinth.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones has returned to aid his distant relative, Indiana Jones, in discovering a hidden treasure within a labyrinth situated beneath a desert filled with illusions.\n\nThe labyrinth's map resembles a tree comprising n rooms numbered from 1 to n. There are n - 1 tunnels linking them, ensuring that every pair of rooms can be reached via various tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) possesses an illusion rate a_i. In order to move from the x-th room to the y-th room, there needs to be a tunnel connecting x and y, and traversing it requires max(|a_x + a_y|, |a_x - a_y|) energy. |z| signifies the absolute value of z.\n\nTo deter potential looters, the labyrinth can alter the illusion rate of any room within it. The labyrinth possesses the capability to adjust these rates to deceive or misguide potential robbers. Chanek and Indiana will present q inquiries.\n\nThe queries to be processed are of two sorts:\n\n  * 1\\ u\\ c \u2014 The illusion level of the x-th room is altered to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the least sum of energy required to retrieve the hidden treasure located in room v if they commence from room u (1 \u2264 u, v \u2264 n).\n\nAssist them, and you can earn a share of the treasure! Your solution should efficiently handle adjustments to illusion rates and compute minimal energy paths within the labyrinth.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\nWrite a main() function and use input() function to read input from stdin", " \nChanek Jones has returned to help his distant relative, Indiana Jones, in finding a secret treasure inside a maze located under a desert that has many tricks.\n\nThe maze's map looks like a tree with n rooms, which are numbered from 1 to n. There are n - 1 paths connecting these rooms, so you can go from any room to any other room using these paths.\n\nEach room has an \"illusion rate\" a_i, which tells how confusing it is. To move from room x to room y, you need a path between them, and it will take you max(|a\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\nWrite a main() function and use input() function to read input from stdin", " Chanek Jones has returned to aid his distant relative, Indiana Jones, in discovering a hidden treasure within a labyrinth situated beneath a desert filled with illusions. The labyrinth's map resembles a tree comprising n rooms numbered from 1 to n. There are n - 1 tunnels linking them, ensuring that every pair of rooms can be reached via various tunnels. The i-th room possesses an illusion rate a_i. In order to move from the x-th room to the y-th room, there needs to be a tunnel connecting x and y, and traversing it requires max(|a_x + a_y|, |a\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\nimport sys\nfrom typing import List, Tuple, Dict\nimport networkx as nx\n\n# Initialize the graph\nG = nx.Graph()\n\n# Function to update the illusion rate of a room\ndef update_illusion_rate(room: int, new_rate: int) -> None:\n    G.nodes[room]['illusion_rate'] = new_rate\n\n# Function to calculate the minimum energy required to travel between two rooms\ndef min_energy_required(start_room: int, end_room: int) -> int:\n    # Use DFS to find the path with the minimum energy\n    def dfs(node: int, target: int, path: List[int], visited: List[bool]) -> Tuple[List[int], int]:\n        if node == target:\n            return path, 0\n        \n        min_energy = sys.maxsize\n        for neighbor in G.neighbors(node):\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                new_path = path + [neighbor]\n                energy = max(abs(G.nodes[node]['illusion_rate'] + G.nodes[neighbor]['illusion_rate']), \n                             abs(G.nodes[node]['illusion_rate'] - G.nodes[neighbor]['illusion_rate']))\n                new_path_energy, _ = dfs(neighbor, target, new_path, visited)\n                if new_path_energy:\n                    current_energy = energy\n                    for i in range(len(new_path) - 1):\n                        current_energy = max(current_energy, \n                                             max(abs(G.nodes[new_path[i]]['illusion_rate'] + G.nodes[new_path[i+1]]['illusion_rate']), \n                                                 abs(G.nodes[new_path[i]]['illusion_rate'] - G.nodes[new_path[i+1]]['illusion_rate'])))\n                    if current_energy < min_energy:\n                        min_energy = current_energy\n                        path = new_path\n        return path, min_energy\n    \n    visited = {node: False for node in G.nodes()}\n    visited[start_room] = True\n    _, min_energy = dfs(start_room, end_room, [start_room], visited)\n    return min_energy\n\n# Read input\nn, q = map(int, input().split())\na_i = list(map(int, input().split()))\ntunnels = [list(map(int, input().split())) for _ in range(n - 1)]\n\n# Initialize the graph with illusion rates\nfor i in range(n):\n    G.add_node(i + 1, illusion_rate=a_i[i])\n\nfor s_i, t_i in tunnels:\n    G.add_edge(s_i, t_i)\n\n# Process queries\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        update_illusion_rate(query[1], query[2])\n    elif query[0] == 2:\n        result = min_energy_required(query[1], query[2])\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport sys\n\n# Function to process queries\ndef process_queries(n: int, q: int, room_illusions: List[int], tunnels: List[List[int]], queries: List[List[int]]) -> None:\n    # Initialize the graph as an adjacency list\n    graph = [[] for _ in range(n + 1)]\n    \n    # Build the graph from the tunnels\n    for s, t in tunnels:\n        graph[s].append(t)\n        graph[t].append(s)\n    \n    # Function to calculate the energy required to traverse the path\n    def calculate_energy(path: List[int]) -> int:\n        max_abs_value = 0\n        for i in range(len(path) - 1):\n            room1 = path[i]\n            room2 = path[i + 1]\n            max_abs_value = max(max_abs_value, abs(room_illusions[room1 - 1] + room_illusions[room2 - 1]), abs(room_illusions[room1 - 1] - room_illusions[room2 - 1]))\n        return max_abs_value\n    \n    # Process each query\n    for query in queries:\n        query_type = query[0]\n        if query_type == 1:\n            room_index = query[1]\n            new_illusion_rate = query[2]\n            room_illusions[room_index - 1] = new_illusion_rate\n        elif query_type == 2:\n            start_room = query[1]\n            end_room = query[2]\n            # Use BFS to find the shortest path\n            visited = [False] * (n + 1)\n            queue = [(start_room, [start_room])]\n            min_energy = sys.maxsize\n            \n            while queue:\n                current_room, path = queue.pop(0)\n                if current_room == end_room:\n                    min_energy = min(min_energy, calculate_energy(path))\n                visited[current_room] = True\n                for neighbor in graph[current_room]:\n                    if not visited[neighbor]:\n                        queue.append((neighbor, path + [neighbor]))\n            print(min_energy)\n\n# Read input from stdin\nn = int(input().strip())\nq = int(input().strip())\nroom_illusions = list(map(int, input().strip().split()))\ntunnels = [list(map(int, input().strip().split())) for _ in range(n - 1)]\nqueries = [list(map(int, input().strip().split())) for _ in range(q)]\n\n# Process queries\nprocess_queries(n, q, room_illusions, tunnels, queries)\n", "from typing import List\nimport networkx as nx\nimport numpy as np\nfrom typing import List, Tuple\n\n# Initialize the graph\ngraph = nx.Graph()\n\n# Function to update the illusion rate of a room\ndef update_illusion_rate(room: int, new_rate: int) -> None:\n    graph.nodes[room]['illusion_rate'] = new_rate\n\n# Function to calculate the minimum energy required for traversal between two rooms\ndef calculate_energy(start: int, end: int) -> int:\n    # Use DFS to find the path with the least sum of energy\n    def dfs(node, target, path, visited):\n        if node == target:\n            return path\n        visited.add(node)\n        min_energy = float('inf')\n        for neighbor in graph.neighbors(node):\n            if neighbor not in visited:\n                energy = max(abs(graph.nodes[node]['illusion_rate'] + graph.nodes[neighbor]['illusion_rate']), \n                             abs(graph.nodes[node]['illusion_rate'] - graph.nodes[neighbor]['illusion_rate']))\n                result = dfs(neighbor, target, path + [energy], visited)\n                if result:\n                    min_energy = min(min_energy, sum(result))\n        visited.remove(node)\n        return min_energy if min_energy != float('inf') else None\n    \n    visited = set()\n    path = dfs(start, end, [], visited)\n    return path if path else -1  # Return -1 if no path is found\n\n# Read the input\nn, q = map(int, input().split())\na_i = list(map(int, input().split()))\n\n# Build the graph\nfor _ in range(n - 1):\n    s_i, t_i = map(int, input().split())\n    graph.add_edge(s_i, t_i)\n    graph.nodes[s_i]['illusion_rate'] = a_i[s_i - 1]\n    graph.nodes[t_i]['illusion_rate'] = a_i[t_i - 1]\n\n# Process each query\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        update_illusion_rate(query[1], query[2])\n    elif query[0] == 2:\n        result = calculate_energy(query[1], query[2])\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\n# Function to update the confusion value for a specific room\ndef update_confusion(room: int, new_value: int) -> None:\n    confusion_values[room] = new_value\n\n# Function to calculate the minimum energy required to traverse between two rooms\ndef calculate_min_energy(start: int, end: int) -> int:\n    def dfs(node, parent):\n        energy = [abs(confusion_values[node] - confusion_values[child]) for child in tree[node] if child != parent]\n        if not energy:\n            return 0\n        min_energy = float('inf')\n        for e in energy:\n            min_energy = min(min_energy, max(e, dfs(child, node)))\n        return min_energy\n    return dfs(start, -1)\n\n# Function to get the path between two rooms\ndef get_path(start: int, end: int) -> List[int]:\n    path = []\n    current = end\n    while current != start:\n        path.append(current)\n        for neighbor in tree[current]:\n            if neighbor in path:\n                current = neighbor\n                break\n    path.append(start)\n    path.reverse()\n    return path\n\n# Read the input values\nn, q = map(int, input().split())\na_values = list(map(int, input().split()))\nconfusion_values = {i + 1: a_values[i] for i in range(n)}\n\n# Read the tree structure\ntree = {i + 1: [] for i in range(n)}\nfor _ in range(n - 1):\n    s, t = map(int, input().split())\n    tree[s].append(t)\n    tree[t].append(s)\n\n# Process queries\nfor _ in range(q):\n    query_type, *args = map(int, input().split())\n    if query_type == 1:\n        room, new_value = args\n        update_confusion(room, new_value)\n    elif query_type == 2:\n        start, end = args\n        result = calculate_min_energy(start, end)\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef search(lst: List[int]) -> int:\n    \"\"\"\n    This function finds the largest integer in the list that appears at least as many times as itself.\n    \n    Args:\n        lst (List[int]): A list of positive integers.\n    \n    Returns:\n        int: The largest integer that appears at least as many times as itself, or -1 if no such integer exists.\n    \"\"\"\n    from collections import Counter\n    \n    # Step 1: Create a dictionary to store the frequency of each integer in the list.\n    freq = Counter(lst)\n    result = -1\n    \n    # Step 2: Iterate through the dictionary to find the largest integer that appears at least as many times as itself.\n    for num, count in freq.items():\n        if count >= num:\n            result = max(result, num)\n    \n    # Step 3: Return the result or -1 if no such integer exists.\n    return result\n\n# Example usage:\n# print(search([2, 2, 3, 3, 3]))  # Output: 3\n# print(search([3, 3, 2, 4, 4, 4]))  # Output: -1\n", "from typing import List\nfrom typing import List, Tuple\nimport networkx as nx\nimport numpy as np\n\ndef func(n: int, q: int, illusion_rates: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    # Construct the tree using the edges\n    tree = nx.Graph()\n    tree.add_nodes_from(range(1, n + 1))\n    tree.add_edges_from(edges)\n    \n    # Function to calculate the minimum energy for a given query\n    def calculate_energy(room1: int, room2: int) -> int:\n        return max(abs(illusion_rates[room1 - 1] + illusion_rates[room2 - 1]), abs(illusion_rates[room1 - 1] - illusion_rates[room2 - 1]))\n    \n    # Process each query\n    results = []\n    for query in queries:\n        room1, room2, query_type = query\n        if query_type == 1:\n            # Update the illusion rate of a room\n            illusion_rates[room1 - 1] = room2\n        elif query_type == 2:\n            # Calculate the minimum energy for traversal between two rooms\n            energy = calculate_energy(room1 - 1, room2 - 1)\n            results.append(energy)\n    \n    return results\n\n# Read input from stdin\nn = int(input())\nq = int(input())\nillusion_rates = list(map(int, input().split()))\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Call the function and print the results\nresult = func(n, q, illusion_rates, edges, queries)\nfor res in result:\n    print(res)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport sys\n\n# Function to read input from stdin\ndef read_input() -> (int, int, List[int], List[Tuple[int, int]], List[Tuple[int, int]]):\n    n, q = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    tunnels = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n - 1)]\n    queries = [tuple(map(int, sys.stdin.readline().split())) for _ in range(q)]\n    return n, q, a, tunnels, queries\n\n# Function to calculate the minimum energy required to traverse a path\ndef calculate_min_energy(n: int, rooms: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> None:\n    # Represent the tree using an adjacency list\n    tree = [[] for _ in range(n)]\n    for s, t in tunnels:\n        tree[s - 1].append(t - 1)\n        tree[t - 1].append(s - 1)\n\n    # Precompute the minimum energy required to traverse each path\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            dp[i][j] = max(abs(rooms[i] - rooms[j]), abs(rooms[i] + rooms[j]))\n\n    # Handle queries\n    for query in queries:\n        query_type = query[0]\n        if query_type == 1:\n            room_index = query[1] - 1\n            new_illusion_rate = query[2]\n            rooms[room_index] = new_illusion_rate\n        elif query_type == 2:\n            start_room = query[1] - 1\n            end_room = query[2] - 1\n            print(dp[start_room][end_room])\n\n# Main function to execute the program\ndef main():\n    n, q, rooms, tunnels, queries = read_input()\n    calculate_min_energy(n, rooms, tunnels, queries)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport sys\n\n# Read input function\ndef read_input() -> (int, int, List[int], List[Tuple[int, int]]):\n    n, q = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    tunnels = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n - 1)]\n    queries = [list(map(int, sys.stdin.readline().split())) for _ in range(q)]\n    return n, q, a, tunnels, queries\n\n# Calculate minimum energy for each path\ndef calculate_min_energy(n: int, rooms: List[int], tunnels: List[Tuple[int, int]], queries: List[List[int]]) -> List[int]:\n    # Create adjacency list for the tree\n    adj_list = [[] for _ in range(n)]\n    for s, t in tunnels:\n        adj_list[s - 1].append(t - 1)\n        adj_list[t - 1].append(s - 1)\n\n    # Precompute the minimum energy required for each path\n    min_energy = [[0] * n for _ in range(n)]\n    \n    def dfs(node: int, parent: int, depth: int):\n        for child in adj_list[node]:\n            if child != parent:\n                dfs(child, node, depth + 1)\n                for i in range(depth + 1):\n                    for j in range(depth + 1):\n                        if i != j:\n                            min_energy[node][child] = max(min_energy[node][child], min_energy[child][j] + abs(rooms[node] + rooms[child]))\n                            min_energy[node][child] = max(min_energy[node][child], min_energy[child][j] + abs(rooms[node] - rooms[child]))\n\n    dfs(0, -1, 0)\n\n    # Handle queries\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            room, new_rate = query[1] - 1, query[2]\n            rooms[room] = new_rate\n        elif query[0] == 2:\n            start, end = query[1] - 1, query[2] - 1\n            results.append(max(min_energy[start][child] + min_energy[end][child] for child in range(n)))\n\n    return results\n\n# Main function to execute the program\ndef main():\n    n, q, a, tunnels, queries = read_input()\n    results = calculate_min_energy(n, a, tunnels, queries)\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Union\n\ndef read_input() -> Tuple[int, int, List[int], List[Tuple[int, int]]]:\n    n, q = map(int, input().split())\n    a = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [tuple(input().split()) for _ in range(q)]\n    return n, q, a, tunnels, queries\n\ndef calculate_min_energy(n: int, rooms: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[str, int, int]]) -> List[int]:\n    # Create adjacency list for the tree\n    tree = [[] for _ in range(n + 1)]\n    for s, t in tunnels:\n        tree[s].append(t)\n        tree[t].append(s)\n\n    # Precompute the minimum energy required for each path\n    energy = [[0] * (n + 1) for _ in range(n + 1)]\n    def dfs(node: int, parent: int):\n        for child in tree[node]:\n            if child != parent:\n                dfs(child, node)\n                for i in range(1, n + 1):\n                    for j in range(1, n + 1):\n                        if i != j:\n                            energy[node][j] = max(energy[node][j], max(abs(rooms[i - 1] + rooms[j - 1]), abs(rooms[i - 1] - rooms[j - 1])))\n\n    dfs(1, -1)\n\n    # Handle queries\n    results = []\n    for query in queries:\n        if query[0] == \"update\":\n            room, rate = query[1], query[2]\n            rooms[room - 1] = rate\n            dfs(1, -1)  # Recompute energy after update\n        elif query[0] == \"query\":\n            start, end = query[1], query[2]\n            results.append(energy[start][end])\n    return results\n\n# Interface\nn, q = map(int, input().split())\na = list(map(int, input().split()))\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(input().split()) for _ in range(q)]\n\nresult = calculate_min_energy(n, a, tunnels, queries)\nfor res in result:\n    print(res)\n", "from typing import List\n## main.py\nimport networkx as nx\nfrom typing import List\n\n# Define the update_illusion_rate function\ndef update_illusion_rate(room: int, new_rate: int) -> None:\n    illusion_rates[room - 1] = new_rate\n\n# Define the calculate_energy function\ndef calculate_energy(start: int, end: int) -> int:\n    G = nx.Graph()\n    for s, t in tunnels:\n        G.add_edge(s, t)\n    \n    # Use DFS to calculate the energy for each path\n    def dfs(node, target):\n        if node == target:\n            return 0\n        min_energy = float('inf')\n        for neighbor in G[node]:\n            energy = max(abs(illusion_rates[node - 1] + illusion_rates[neighbor - 1]), abs(illusion_rates[node - 1] - illusion_rates[neighbor - 1]))\n            min_energy = min(min_energy, energy + dfs(neighbor, target))\n        return min_energy\n    \n    return dfs(start, end)\n\n# Read input data\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntunnels = []\nfor _ in range(n - 1):\n    s, t = map(int, input().split())\n    tunnels.append((s, t))\n\n# Process queries\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        update_illusion_rate(query[1], query[2])\n    elif query[0] == 2:\n        result = calculate_energy(query[1], query[2])\n        print(result)\n"], "plans": ["requirement analysis:\nThe project requires handling a tree structure with nodes representing rooms and edges representing tunnels. Each room has an illusion rate that can be adjusted, and the task is to compute the minimum energy required to travel between rooms based on the illusion rates. The queries involve updating the illusion rates and finding the minimum energy path between two rooms.\nrequirement pool:\n- Implement a function to handle tree structure and queries efficiently\n- Develop a mechanism to update illusion rates and compute energy efficiently\n- Ensure the system can handle large inputs within performance constraints\n- Design a user-friendly interface for adjusting illusion rates and viewing results\n- Optimize the algorithm for pathfinding and rate adjustments for scalability\nTo tackle the problem of computing the minimum energy required to travel between rooms in a labyrinth, we will leverage the properties of a tree structure and utilize efficient algorithms for pathfinding and data manipulation. We will use Python, a versatile language with robust libraries for handling tree-like data structures and graph algorithms. Specifically, we will employ the 'networkx' library to manage the tree structure and 'math' library for handling mathematical operations related to energy calculations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': a graph with n nodes and n-1 edges, where any two nodes are connected by a unique path.\n    'illusion rate': a value associated with each room that affects the energy required to traverse the path between rooms.\n    'energy calculation': the energy required to traverse a path between two rooms is determined by the maximum of the absolute sums or differences of the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'more than': used to indicate a condition where a value must be greater than a specified amount.\n    'at least as many times': used to indicate a condition where a value must appear at least a specified number of times.\n\n# [degree adverb] \n    'largest': used to indicate the maximum value in a set of values.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Parse the input to set up the tree structure and initialize the illusion rates.\n    2. Process each query:\n        - For type 1 query (update the illusion rate of a room), update the illusion rate in the data structure.\n        - For type 2 query (calculate the minimum energy required to travel between two rooms), use a depth-first search (DFS) to find the path with the minimum energy.\n    3. Use DFS to traverse the tree and calculate the energy for each path, updating the minimum energy required for the given query.\n\n# [edge case] \n    Edge case 1:\n    Query: 2 1 2\n    Explanation: The tree structure is a simple path with rooms 1 and 2 directly connected. The illusion rates are the same, so the energy required to travel between them is 0.\n    Edge case 2:\n    Query: 2 1 3\n    Explanation: The tree structure is a path with rooms 1, 2, and 3. If the illusion rates are a_1 = 0 and a_2 = 10, a_3 = 0, the energy required to travel from room 1 to room 3 is max(|0 + 0|, |0 - 10|) = 10.\n    Edge case 3:\n    Query: 2 2 4\n    Explanation: The tree structure is a more complex tree with multiple branches. If the illusion rates are a_2 = 5 and a_4 = 7, and the paths to room 4 involve rooms with illusion rates of 3, 2, and 8, the minimum energy required to travel from room 2 to room 4 is max(|5 + 7|, |5 - 7|) = 12.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases, as the logic provided in the plan can handle the edge cases directly. The DFS algorithm will naturally handle cases with direct connections or more complex paths.\n", "requirement analysis:\nThe project requires a robust system to handle tree-based labyrinth navigation with dynamic illusion rate adjustments. The system must efficiently compute the minimum energy required for pathfinding between rooms, which involves calculating the absolute value of the sum or difference of illusion rates. The solution should be scalable to handle up to 10^5 rooms and queries.\nrequirement pool:\n- Implement a tree data structure to represent the labyrinth\n- Develop a function to compute the minimum energy required for pathfinding\n- Allow dynamic updates to the illusion rates of rooms\n- Ensure the system can handle up to 10^5 rooms and queries efficiently\nTo tackle the challenge of creating an efficient solution for navigating a labyrinth with dynamic illusion rate adjustments, we will leverage Python's capabilities along with the 'networkx' library for handling the tree structure and 'numpy' for efficient array operations. The system will be designed to handle up to 10^5 rooms and queries efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': a graph with n nodes and n-1 edges, where any two nodes are connected by a unique path.\n    'illusion rate': a value associated with each room that affects the energy required to traverse the labyrinth.\n    'dynamic adjustment': the ability to change the illusion rate of any room at any time.\n\n# [phrase showing quantity relationship]\n    'more than': used to compare the illusion rates between rooms.\n    'at least as many times': used to compare the frequency of an illusion rate with its value.\n\n# [degree adverb] \n    'least': indicates the minimum sum of energy required to reach the treasure.\n\n# [code logic]\n    To implement the solution, we will:\n    1. Use a graph to represent the labyrinth, where each room is a node and each tunnel is an edge.\n    2. Store the illusion rates in an array.\n    3. For each query of type 2, find the shortest path between the two rooms using a breadth-first search (BFS) or depth-first search (DFS).\n    4. Calculate the energy required to traverse the path based on the maximum of the absolute values of the illusion rates at the start and end rooms.\n    5. If the illusion rate of any room is changed (query of type 1), update the corresponding value in the array.\n\n# [edge case] \n    Edge case 1:\n    Query: 2 1 2\n    Explanation: There is a direct tunnel between room 1 and room 2 with an illusion rate of a_1. The energy required to move from room 1 to room 2 is max(|a_1 + a_2|, |a_1 - a_2|).\n    Expected output: max(|a_1 + a_2|, |a_1 - a_2|)\n\n    Edge case 2:\n    Query: 2 3 5\n    Explanation: There is no direct tunnel between room 3 and room 5. The path would go through room 1 and room 2, and then to room 5. The energy required is the sum of the maximum absolute values of the illusion rates along the path.\n    Expected output: max(max(|a_3 + a_1|, |a_3 + a_2|), |a_2 + a_5|, |a_1 + a_5|)\n\n    Edge case 3:\n    Query: 1 4 0\n    Explanation: The illusion rate of room 4 is changed to 0. This could potentially reduce the energy required for some paths, especially if room 4 is on the path between the start and end rooms.\n    Expected output: The minimum sum of energy needed to reach room v from room u after the change.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where there are no direct tunnels between the start and end rooms. This can be done using a depth-first search (DFS) or breadth-first search (BFS) to find the shortest path between two rooms in the tree structure.\n", "requirement analysis:\nThe project requires handling tree structures, dynamic updates to node values, and efficient pathfinding algorithms to calculate the minimum energy required for traversal. The user interface should be intuitive, allowing users to easily adjust illusion rates and query the labyrinth's requirements.\nrequirement pool:\n- Implement a tree structure to represent the labyrinth.\n- Develop a function to update the illusion rates of rooms.\n- Create an algorithm to calculate the minimum energy required for traversal between rooms.\n- Design an intuitive user interface for adjusting illusion rates and querying the labyrinth.\n- Ensure real-time updates and efficient performance across all operations.\nTo tackle the challenge of representing the labyrinth as a tree structure, updating illusion rates dynamically, and calculating the minimum energy required for traversal, we will leverage Python's capabilities along with the `networkx` library for managing the tree structure and `numpy` for efficient array operations. The tree will be represented using a graph where rooms are nodes and tunnels are edges. The illusion rates will be stored in an array that can be updated on-the-fly. For pathfinding, we will use a depth-first search (DFS) algorithm to compute the minimum energy required between any two rooms.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': a graph where rooms are nodes and tunnels are edges, ensuring every pair of rooms can be reached via various tunnels.\n    'dynamic update': the ability to alter the illusion rates of rooms to deceive or misguide potential robbers.\n    'minimum energy required': the sum of energy needed to traverse from one room to another, calculated as max(|a_x + a_y|, |a_x - a_y|).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will:\n    1. Build the tree using the given tunnels.\n    2. Store the initial illusion rates in an array.\n    3. Process each query:\n        - For type 1 query (update illusion rate), modify the array at the specified room index.\n        - For type 2 query (calculate minimum energy), use DFS to find the path with the least sum of energy between the specified rooms.\n\n# [edge case] \n    Edge case 1:\n    Query: 2 1 2\n    Explanation: The tree structure is a simple path from room 1 to room 2. The illusion rates are the same as the initial values. The minimum energy required to travel from room 1 to room 2 is the absolute difference between the illusion rates of the two rooms.\n\n    Edge case 2:\n    Query: 2 1 3\n    Explanation: The tree structure is a path with three rooms. The illusion rates are the same as the initial values. The minimum energy required to travel from room 1 to room 3 involves the maximum of the absolute sums or differences of the illusion rates at each step.\n\n    Edge case 3:\n    Query: 2 2 4\n    Explanation: The tree structure involves a more complex arrangement of rooms and tunnels. The illusion rates are the same as the initial values. The minimum energy required to travel from room 2 to room 4 involves considering the absolute sums or differences at each step along the path.\n\n# [extra code for edge case]\n    We may need to handle cases where the tree structure is such that the shortest path is not immediately obvious, especially if the tree is not a simple linear path. In such cases, a more sophisticated pathfinding algorithm or additional data structures may be required to efficiently compute the minimum energy.\n", "requirement analysis:\nThe project requires a program to handle a tree structure representing a maze, where each node (room) has an associated value representing confusion. The program must be able to process queries to update the confusion values and calculate the minimum energy required to traverse between two rooms. The solution must be efficient enough to handle the upper limits of the input size.\nrequirement pool:\n- Implement a tree structure to represent the maze\n- Handle queries to update room confusion values\n- Calculate the minimum energy required to traverse between two rooms\n- Ensure the program is efficient and can handle large inputs\n- Design a user-friendly interface for input and output\nTo tackle the problem of calculating the minimum energy required to traverse between two rooms in a maze represented as a tree, we will use a depth-first search (DFS) algorithm to efficiently traverse the tree and calculate the required values. We will also use a tree data structure to represent the maze and update the confusion values as needed. The program will be designed to handle large inputs efficiently, ensuring it can process up to 10^5 rooms and 10^5 queries.\nPlease read and understand the following inteperation before coding\n It appears that the plan provided for the second prompt is incomplete and does not address the specific requirements of the problem statement. Let's focus on analyzing the requirement and plan for the second prompt to ensure a thorough understanding and implementation.\n\n# [core concept]\n    'positive integers': The requirement specifies that the list provided must contain only positive integers.\n    'largest integer': This refers to finding the greatest value in the list that meets certain conditions.\n    'at least as many times': This implies that the frequency of the integer must be at least as much as its value.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find integers that are greater than zero.\n    'at least as many times': This phrase means that the frequency of the integer must be at least as much as its value.\n\n# [degree adverb]\n    'largest': This adverb indicates that we need to find the largest integer that satisfies the conditions.\n\n# [code logic]\n    To implement this, we can follow these steps:\n    1. Create a dictionary to store the frequency of each integer in the list.\n    2. Iterate through the list and update the frequency in the dictionary.\n    3. Iterate through the dictionary to find the largest integer that meets the condition.\n    4. Return the result or -1 if no such integer exists.\n\n# [edge case]\n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their values, but 3 is the largest number.\n\n    search([3, 3, 2, 4, 4, 4]) = -1\n    Explanation: Number 2 appears once, number 3 appears twice, and number 4 appears three times. None of them appear more than or equal to their values, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.\n\nThis analysis and plan should help the programmer to correctly implement the function based on the given requirements.\n", "requirement analysis:\nThe project requires a program to handle a tree structure representing a maze, where each node (room) has an associated value representing confusion. The program must be able to process queries to update the confusion values and calculate the minimum energy required to traverse between two rooms. The solution should be efficient enough to handle the upper limits of the input size.\nrequirement pool:\n- Implement a tree structure to represent the maze\n- Handle queries to update room confusion values\n- Calculate the minimum energy required to traverse between two rooms\n- Ensure the program is efficient and can handle large inputs\n- Design a user-friendly interface for input and output\nTo tackle the problem of calculating the minimum energy required to traverse between two rooms in a maze represented as a tree, we will use a depth-first search (DFS) algorithm to efficiently traverse the tree and calculate the required values. We will also use a tree data structure to represent the maze and update the confusion values as needed. The program will be designed to handle large inputs efficiently, ensuring it can process up to 10^5 rooms and 10^5 queries.\nPlease read and understand the following inteperation before coding\n It appears that the plan provided for the second prompt is incomplete and does not address the specific requirements of the problem statement. Let's focus on analyzing the requirement and plan for the second prompt to ensure a thorough understanding and implementation.\n\n# [core concept]\n    'positive integers': The requirement specifies that the list provided must contain only positive integers.\n    'largest integer': This refers to finding the greatest value that meets a specific condition within the list.\n    'at least as many times': This indicates that the frequency of an integer in the list must be at least as much as its value.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase implies that we are looking for integers greater than a certain value, in this case, greater than zero.\n    'at least as many times': This phrase requires that the frequency of an integer in the list is at least equal to its value.\n\n# [degree adverb]\n    'largest': This degree adverb tells us to find the largest integer that satisfies the given conditions.\n\n# [code logic]\n    To implement the solution, we can follow these steps:\n    1. Create a dictionary to store the frequency of each integer in the list.\n    2. Iterate through the list and update the frequency in the dictionary.\n    3. Iterate through the dictionary to find the largest integer that appears at least as many times as itself.\n    4. Return the result or -1 if no such integer exists.\n\n# [edge case]\n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their values, but 3 is the largest number.\n\n    search([3, 3, 2, 4, 4, 4]) = -1\n    Explanation: Number 2 appears once, number 3 appears twice, and number 4 appears three times. None of them appear at least as many times as their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.\n\n# [code logic continued]\n    Here is a more detailed implementation of the code logic:\n    ```python\n    def search(lst):\n        from collections import Counter\n        \n        freq = Counter(lst)\n        result = -1\n        \n        for num, count in freq.items():\n            if count >= num:\n                result = max(result, num)\n        \n        return result\n    ```\n\nThis implementation ensures that we correctly handle the edge cases and efficiently find the largest integer that appears at least as many times as itself.\n", "requirement analysis:\nThe project requires a program to handle a tree structure representing a maze, where each node has an associated value representing confusion. Users can query the minimum energy required to move from one room to another, and also update the illusion rate of a room. The program must be efficient due to the potential size of the input data.\nrequirement pool:\n- Implement a tree structure to represent the maze\n- Handle queries to calculate energy based on illusion rates\n- Allow updates to illusion rates\n- Ensure the program is efficient and can handle large inputs\n- Design a user-friendly interface for easy interaction\nTo tackle the problem of representing a maze as a tree structure and handling queries efficiently, we will utilize Python's capabilities along with the 'networkx' library for managing the tree and 'numpy' for mathematical operations. The tree will be constructed from the given edges, and each node will store its illusion rate. Queries will be processed to calculate the minimum energy required for traversal, considering the maximum of the absolute sum or difference of the illusion rates of the two rooms involved in the traversal.\nPlease read and understand the following inteperation before coding\n It appears that the plan provided for the third requirement is incomplete and does not include specific details on how to implement the queries or handle the tree structure. Therefore, I will focus on analyzing the core concepts, phrases showing quantity relationships, degree adverbs, and edge cases for the given requirement.\n\n# [core concept]\n    'tree structure': A tree is a connected graph with no cycles. In this context, the maze can be represented as a tree where rooms are nodes and paths are edges.\n    'illusion rate': This refers to the confusion level of each room, which affects the energy needed to traverse between rooms.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase is not directly applicable in the given requirement as it does not specify a comparison of values.\n    'at least as many times': This phrase is not applicable in the given context as it does not relate to the repetition of a number's appearance in the list.\n\n# [degree adverb] \n    'largest': This adverb is relevant as it refers to finding the room with the highest illusion rate, which will dictate the minimum energy needed for traversal.\n\n# [code logic]\n    To implement the solution, we need to:\n    1. Construct a tree from the given edges.\n    2. Store the illusion rates for each room.\n    3. For each query, determine the minimum energy required to traverse from one room to another, which is the maximum of the absolute sum or difference of the illusion rates of the two rooms.\n\n# [edge case] \n    Edge case 1:\n    Query: What is the minimum energy to travel from room 1 to room 5 in a maze with rooms having illusion rates [2, 4, 6, 8, 10]?\n    Explanation: The path from room 1 to room 5 involves rooms with illusion rates 2 and 10. The energy needed is max(|2 + 10|, |2 - 10|) = max(12, 8) = 12.\n\n    Edge case 2:\n    Query: What is the minimum energy to travel from room 3 to room 4 in a maze with rooms having illusion rates [1, 3, 5, 7, 9]?\n    Explanation: The path from room 3 to room 4 involves rooms with illusion rates 5 and 7. The energy needed is max(|5 + 7|, |5 - 7|) = max(12, 2) = 12.\n\n    Edge case 3:\n    Query: What is the minimum energy to travel from room 2 to room 2 in a maze with rooms having illusion rates [1, 1, 1, 1, 1]?\n    Explanation: Since the rooms are the same, the energy needed is 0.\n\n# [extra code for edge case]\n    No extra code is needed for handling the edge cases as the logic for calculating the minimum energy is already included in the main code logic.\n", "requirement analysis:\nThe project requires a program to calculate the minimum energy required to traverse a tree-like labyrinth with dynamic illusion rates. The program must handle both querying the minimum energy for a given path and updating the illusion rate of a specific room. The solution should be efficient enough to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to read input from stdin\n- Implement a function to calculate the minimum energy for a given path\n- Implement a function to update the illusion rate of a room\n- Ensure the program is efficient and can handle the upper limits of the input constraints\n- Design a user-friendly interface for input and output\nTo solve this problem, we will use a combination of graph theory and dynamic programming to efficiently handle the tree structure and queries. We will use an adjacency list to represent the tree and precompute the minimum energy required to traverse each path. For each query, we will either update the illusion rate of a room or compute the minimum energy for a given path.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': The labyrinth's map resembles a tree, which is a connected graph with no cycles.\n    'illusion rate': The value associated with each room that affects the energy required to traverse the path between rooms.\n    'minimum energy required': The energy needed to traverse a path between two rooms, calculated as the maximum of the absolute sums or differences of the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'more than': Used to indicate that the energy required to traverse a path is dependent on the illusion rates of the rooms involved.\n\n# [degree adverb] \n    'largest': Indicates that the energy required to traverse a path is determined by the maximum of two values: the sum or difference of the illusion rates.\n\n# [code logic]\n    To implement the solution, we need to:\n    1. Represent the tree using an adjacency list.\n    2. Precompute the minimum energy required to traverse each path using dynamic programming.\n    3. Handle queries to either update the illusion rate of a room or compute the minimum energy for a given path.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    n = 3, q = 2\n    a = [1, 2, 3]\n    tunnels = [(1, 2), (2, 3)]\n    queries = [2, 1, 2, 3]\n    Explanation:\n    The tree structure is a path with rooms 1-2-3. The initial illusion rates are [1, 2, 3]. The queries are to update the illusion rate of room 1 to 4 and then compute the minimum energy to traverse the path from room 2 to room 3.\n    Expected output:\n    -1 (since no such integer exists that appears greater than or equal to its value)\n\n    Edge case 2:\n    Input:\n    n = 4, q = 3\n    a = [0, 5, 5, 4]\n    tunnels = [(1, 2), (1, 3), (1, 4)]\n    queries = [1, 1, 2, 3, 4]\n    Explanation:\n    The tree structure is a star-shaped graph with room 1 at the center and rooms 2, 3, and 4 as leaves. The initial illusion rates are [0, 5, 5, 4]. The first query updates the illusion rate of room 1 to 0. The next two queries compute the minimum energy to traverse the paths from room 2 to room 3 and from room 2 to room 4.\n    Expected output:\n    5 (for the path 2-3)\n    5 (for the path 2-4)\n\n    Edge case 3:\n    Input:\n    n = 5, q = 1\n    a = [1, 2, 3, 4, 5]\n    tunnels = [(1, 2), (1, 3), (2, 4), (2, 5)]\n    queries = [2, 1, 3, 5]\n    Explanation:\n    The tree structure is a path with rooms 1-2-4-5 and a branch from room 2 to room 3. The initial illusion rates are [1, 2, 3, 4, 5]. The query is to update the illusion rate of room 3 to 0.\n    Expected output:\n    -1 (since no such integer exists that appears greater than or equal to its value)\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where no integer exists that appears greater than or equal to its value. This can be done by iterating through the dictionary of frequencies and checking if any integer meets the condition. If not, return -1.\n", "requirement analysis:\nThe project requires a program to calculate the minimum energy required to traverse a tree-like labyrinth with dynamic illusion rates. The program must handle both querying the minimum energy for a given path and updating the illusion rate of a specific room. The solution should be efficient enough to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to read input from stdin\n- Implement a function to calculate the minimum energy for a given path\n- Implement a function to update the illusion rate of a room\n- Ensure the program is efficient and can handle the upper limits of the input constraints\n- Design a user-friendly interface for input and output\nTo solve this problem, we will use a combination of graph theory and dynamic programming to efficiently handle the tree structure and queries. We will use an adjacency list to represent the tree and precompute the minimum energy required to traverse each path. For each query, we will either update the illusion rate of a room or compute the minimum energy for a given path.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': The labyrinth's map resembles a tree, which is a connected graph with no cycles.\n    'illusion rate': The rate at which a room presents illusions, affecting the energy needed to traverse a tunnel.\n    'minimum energy required': The energy needed to traverse a tunnel between two rooms, calculated as the maximum of the absolute sums or differences of the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates the presence of a tunnel between two rooms.\n    'at least as many times': Not directly applicable in this context, as it typically refers to frequency.\n\n# [degree adverb] \n    'largest': Indicates the need to find the maximum energy required for a given path.\n\n# [code logic]\n    To solve this problem, we need to:\n    1. Represent the tree using an adjacency list.\n    2. Precompute the minimum energy required for each path using dynamic programming.\n    3. Handle queries to either update the illusion rate of a room or compute the minimum energy for a given path.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    n = 3, q = 2\n    a = [1, 2, 3]\n    tunnels = [(1, 2), (2, 3)]\n    queries = [2, 1, 3]\n    Explanation:\n    The tree structure is a path from room 1 to room 3. The minimum energy required to traverse the path is max(|1+2|, |1-2|) = 2.\n    Edge case 2:\n    Input:\n    n = 4, q = 3\n    a = [0, 5, 5, 5]\n    tunnels = [(1, 2), (2, 3), (3, 4)]\n    queries = [1, 2, 3, 4]\n    Explanation:\n    The tree structure is a path from room 1 to room 4. The minimum energy required to traverse the path is max(|0+5|, |0-5|) = 5.\n    Edge case 3:\n    Input:\n    n = 5, q = 1\n    a = [1, 2, 3, 4, 5]\n    tunnels = [(1, 2), (1, 3), (2, 4), (3, 5)]\n    queries = [2]\n    Explanation:\n    The tree structure is a more complex tree. The minimum energy required to traverse any path would depend on the specific structure and illusion rates.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases by considering the specific structure and illusion rates of the tree. This may involve more complex dynamic programming or shortest path algorithms to find the minimum energy required for each path.\n", "requirement analysis:\nThe project requires a program to calculate the minimum energy required to traverse a tree-like labyrinth with dynamic illusion rates. The program must handle both querying the minimum energy for a given path and updating the illusion rate of a specific room. The solution should be efficient enough to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement a function to read input from stdin\n- Implement a function to calculate the minimum energy for a given path\n- Implement a function to update the illusion rate of a room\n- Ensure the program is efficient and can handle the upper limits of the input constraints\n- Design a user-friendly interface for input and output\nTo solve this problem, we will use a combination of graph theory and dynamic programming to efficiently handle the tree structure and queries. We will use an adjacency list to represent the tree and precompute the minimum energy required to traverse each path. For each query, we will either update the illusion rate of a room or compute the minimum energy for a given path.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': The labyrinth's map resembles a tree, which is a connected graph with no cycles.\n    'illusion rate': The rate at which a room presents illusions, affecting the energy needed to traverse a tunnel.\n    'minimum energy required': The energy needed to traverse a tunnel between two rooms, calculated as the maximum of the absolute sums or differences of the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates the presence of a tunnel between two rooms.\n    'at least as many times': Not directly applicable in this context, as it typically refers to frequency.\n\n# [degree adverb] \n    'largest': Indicates the maximum value to be considered in the energy calculation.\n    'greatest': Not directly applicable in this context, as it typically refers to the highest degree of a polynomial.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to:\n    1. Represent the tree using an adjacency list.\n    2. Precompute the minimum energy required for each path using dynamic programming.\n    3. Handle queries to either update the illusion rate of a room or compute the minimum energy for a given path.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, q = 2, a = [1, 2, 3], tunnels = [(1, 2), (2, 3)], queries = [(\"update\", 1, 4), (\"query\", 1, 3)]\n    Explanation:\n    - The tree is a path with rooms 1-2-3.\n    - The initial illusion rates are [1, 2, 3].\n    - The first query is an update to room 1's illusion rate, changing it to 4.\n    - The second query asks for the minimum energy to travel from room 1 to room 3.\n    Expected output:\n    - After update, the illusion rates are [4, 2, 3].\n    - The minimum energy to travel from room 1 to room 3 is max(|4 + 3|, |4 - 3|) = 7.\n\n    Edge case 2:\n    Input: n = 5, q = 1, a = [0, -1, 2, -3, 4], tunnels = [(1, 2), (1, 3), (3, 4), (3, 5)], queries = [(\"query\", 2, 5)]\n    Explanation:\n    - The tree structure is a star-like graph with room 1 at the center.\n    - The initial illusion rates are [0, -1, 2, -3, 4].\n    - The query asks for the minimum energy to travel from room 2 to room 5.\n    Expected output:\n    - The minimum energy to travel from room 2 to room 5 is max(|2 + 4|, |2 - 4|) = 6.\n\n    Edge case 3:\n    Input: n = 2, q = 2, a = [5, -5], tunnels = [(1, 2)], queries = [(\"update\", 2, 0), (\"query\", 1, 2)]\n    Explanation:\n    - The tree consists of only two rooms connected by a single tunnel.\n    - The initial illusion rates are [5, -5].\n    - The first query is an update to room 2's illusion rate, changing it to 0.\n    - The second query asks for the minimum energy to travel from room 1 to room 2.\n    Expected output:\n    - After update, the illusion rates are [5, 0].\n    - The minimum energy to travel from room 1 to room 2 is max(|5 + 0|, |5 - 0|) = 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle the edge cases directly.\n", "requirement analysis:\nThe project requires handling a tree structure for the labyrinth, dynamic updates to illusion rates, and efficient energy calculation for path traversal. The user queries need to be processed quickly, especially for larger mazes and more frequent updates.\nrequirement pool:\n- Implement a tree structure for the labyrinth with n rooms and n-1 tunnels.\n- Allow dynamic updates to the illusion rates of any room.\n- Calculate the minimum energy required to traverse the labyrinth from room u to room v.\n- Ensure real-time updates and efficient response times for user queries.\n- Provide a user-friendly interface for adjusting illusion rates and viewing energy requirements.\nTo tackle the challenge of creating an efficient application for exploring the labyrinth, we will utilize Python's capabilities along with the 'networkx' library to model the tree structure of the labyrinth. This library will help in managing and querying the tree efficiently. For dynamic updates to the illusion rates and real-time calculation of energy requirements, we will use a combination of Python's data structures and efficient algorithms. The application will handle both types of queries (update and query) effectively, ensuring real-time responsiveness.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree structure': a graph with n nodes and n-1 edges, where any two nodes are connected by a unique path.\n    'illusion rate': a value associated with each room that affects the energy required to traverse the tunnels.\n    'energy calculation': the energy required to traverse a tunnel between two rooms is determined by the maximum of the absolute sums or differences of their illusion rates.\n\n# [phrase showing quantity relationship]\n    'more than': used to indicate the number of rooms and tunnels in the labyrinth.\n    'at least as many times': not explicitly mentioned in the requirement, but implied in the context of the tree structure and queries.\n\n# [degree adverb] \n    'least': indicates the minimum sum of energy required to reach the treasure.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To handle the queries efficiently, we need to:\n    1. Model the labyrinth as a tree using the given tunnels.\n    2. Store the illusion rates for each room.\n    3. Process update queries to modify the illusion rates.\n    4. Process query 2 to calculate the minimum sum of energy required to reach the treasure from a given room.\n\n# [edge case] \n    Edge case 1: Query type 2 with u = 1 and v = n (starting from the entrance and ending at the deepest room).\n    Expected output: The minimum sum of energy needed to reach the treasure.\n    Explanation: This edge case tests the traversal from the entrance to the deepest room, ensuring the algorithm can handle long paths.\n\n    Edge case 2: Query type 1 with u = n (changing the illusion rate of the deepest room).\n    Expected output: The updated labyrinth configuration with the new illusion rate.\n    Explanation: This edge case tests the dynamic update capability, ensuring the system can handle changes in labyrinth conditions.\n\n    Edge case 3: Query type 2 with u = v (starting and ending in the same room).\n    Expected output: 0\n    Explanation: This edge case ensures the algorithm correctly handles the scenario where no energy is required to traverse a path of length zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic can handle these scenarios by considering the unique paths and dynamic updates.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 54, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "add_1_sentence_at_end", "parent_index": 57}
