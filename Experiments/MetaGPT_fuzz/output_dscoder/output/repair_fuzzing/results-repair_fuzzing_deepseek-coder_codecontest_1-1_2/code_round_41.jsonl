{"name": "1575_M. Managing Telephone Poles", "description": "Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "tags": ["data structures", "geometry"], "difficulty": 20, "id": 1575, "sample_io": [{"input": "2 2\n101\n000\n000\n", "output": ["18\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n00100\n00010\n", "output": ["36\n"]}], "test_list": [{"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["182\n"]}, {"input": "0 0\n1\n", "output": ["0\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["181\n"]}, {"input": "2 2\n101\n010\n000\n", "output": ["8\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n00100\n00110\n", "output": ["33\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["183\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n10100\n00110\n", "output": ["25\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["187\n"]}, {"input": "5 4\n10010\n00000\n00000\n00001\n10100\n00110\n", "output": ["38\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001011000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["188\n"]}, {"input": "5 4\n10010\n00000\n00000\n01001\n10100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n10010\n00100\n00000\n01001\n10100\n00110\n", "output": ["24\n"]}, {"input": "5 4\n00010\n00101\n00000\n01001\n10100\n00110\n", "output": ["31\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10110\n00111\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00101\n00100\n01001\n10110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01000\n10101\n00100\n01001\n10110\n00111\n", "output": ["18\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n10110\n00111\n", "output": ["16\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n10110\n01111\n", "output": ["15\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n00110\n01111\n", "output": ["17\n"]}, {"input": "0 4\n10010\n00000\n01000\n00001\n00100\n00010\n", "output": ["3\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["152\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["149\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["163\n"]}, {"input": "5 4\n10010\n00001\n00000\n00001\n10100\n00110\n", "output": ["36\n"]}, {"input": "5 9\n0000110000\n0001001000\n0001000000\n0001011000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["193\n"]}, {"input": "5 4\n00010\n00100\n00000\n01001\n10110\n00110\n", "output": ["32\n"]}, {"input": "5 4\n00010\n00101\n00000\n01001\n10100\n01110\n", "output": ["30\n"]}, {"input": "5 4\n00000\n00101\n00000\n01001\n10100\n00010\n", "output": ["35\n"]}, {"input": "5 4\n01000\n00101\n00000\n00001\n10100\n00111\n", "output": ["29\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n11110\n00111\n", "output": ["22\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["148\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["146\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["164\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n10100\n00010\n", "output": ["40\n"]}, {"input": "5 4\n01100\n11101\n00100\n01001\n00110\n00111\n", "output": ["20\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["158\n"]}, {"input": "9 9\n0000110010\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["109\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["147\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["173\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n01110\n", "output": ["27\n"]}, {"input": "4 4\n00010\n00101\n00000\n01011\n10100\n01110\n", "output": ["26\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n10101\n00010\n", "output": ["39\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["157\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["106\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["171\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["107\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["129\n"]}, {"input": "2 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["101\n"]}, {"input": "4 4\n01100\n11111\n00100\n01101\n00100\n01111\n", "output": ["14\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["103\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["128\n"]}, {"input": "3 4\n01100\n11111\n00100\n01101\n00100\n01111\n", "output": ["9\n"]}, {"input": "9 9\n0100100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001000011\n0011111110\n", "output": ["133\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["90\n"]}, {"input": "2 9\n0000110000\n0001001100\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001001\n0011111110\n", "output": ["74\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["89\n"]}, {"input": "1 4\n01001\n00101\n00100\n00001\n10100\n10100\n", "output": ["7\n"]}, {"input": "9 9\n0000110011\n0001011000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["88\n"]}, {"input": "9 9\n0000110011\n0001011010\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["84\n"]}, {"input": "4 4\n10010\n10100\n01011\n00010\n00101\n10111\n", "output": ["19\n"]}, {"input": "3 4\n01100\n11101\n00100\n01101\n10110\n01110\n", "output": ["10\n"]}, {"input": "9 9\n0000110011\n0001011010\n1001000000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["85\n"]}, {"input": "1 4\n01100\n11101\n00100\n00101\n11110\n01110\n", "output": ["4\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["184\n"]}, {"input": "2 2\n101\n000\n010\n", "output": ["6\n"]}, {"input": "9 9\n0001110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["177\n"]}, {"input": "2 2\n101\n000\n110\n", "output": ["5\n"]}, {"input": "5 4\n10000\n00000\n00000\n00001\n10100\n00110\n", "output": ["67\n"]}, {"input": "5 4\n00000\n00100\n00000\n01001\n10100\n00010\n", "output": ["43\n"]}, {"input": "0 4\n10110\n00000\n01000\n00001\n00100\n00010\n", "output": ["2\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111101110\n", "output": ["153\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1001111000\n0001000000\n0001001000\n0110100110\n1000000001\n1001001011\n0111111110\n", "output": ["145\n"]}, {"input": "5 4\n00010\n00100\n00000\n00001\n10110\n00110\n", "output": ["37\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["180\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000000\n1001001001\n0111111110\n", "output": ["159\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00010\n", "output": ["52\n"]}, {"input": "9 9\n0000100000\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["137\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n0101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["175\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n1001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["99\n"]}, {"input": "5 4\n01000\n00111\n10100\n01101\n11111\n00111\n", "output": ["13\n"]}, {"input": "9 9\n0100100001\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["113\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110100110\n1000000011\n1001001011\n0110111110\n", "output": ["124\n"]}, {"input": "9 9\n0100010000\n0001001000\n0001001000\n1101111100\n0001000001\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["98\n"]}, {"input": "9 9\n1100010000\n0001001000\n0001001100\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["97\n"]}, {"input": "2 9\n0000110000\n0001000100\n0001000000\n0001110000\n1101000000\n0001001000\n0110001110\n1000000001\n1001001001\n0011111110\n", "output": ["78\n"]}, {"input": "9 9\n0000110011\n0001111000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["87\n"]}, {"input": "9 9\n0001110000\n0001001000\n0001001000\n1001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["144\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n0001000000\n0001001000\n0110000010\n1000000001\n1001001011\n0011111110\n", "output": ["190\n"]}, {"input": "5 4\n10000\n00000\n00000\n00001\n10101\n00110\n", "output": ["66\n"]}, {"input": "9 9\n0000110000\n0001011000\n0001000000\n0001011000\n0001000010\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["162\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["136\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1101111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["115\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0101111000\n1001000100\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["139\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n0001110000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["121\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00011\n", "output": ["51\n"]}, {"input": "4 9\n0000100000\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["111\n"]}, {"input": "5 4\n11010\n00000\n00000\n00001\n10100\n00111\n", "output": ["34\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001001\n0011111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0110111110\n", "output": ["86\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0100100110\n1000000011\n1001001011\n0110111110\n", "output": ["126\n"]}, {"input": "9 9\n1100010000\n1001001000\n0001001100\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["96\n"]}, {"input": "9 9\n0000110011\n1001111000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["79\n"]}, {"input": "9 9\n0000110000\n0001011000\n0001000000\n0001011000\n0001010010\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["161\n"]}, {"input": "9 9\n0000110000\n0001001000\n1001001000\n0000111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["143\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["135\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1100111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["116\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0101111000\n1001000100\n0011001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["138\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n0001110000\n1000000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["123\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00111\n", "output": ["48\n"]}, {"input": "4 9\n0000100000\n0101001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["73\n"]}, {"input": "3 4\n10010\n11101\n01000\n00011\n00100\n00110\n", "output": ["12\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001100\n0001111000\n1001001001\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["76\n"]}, {"input": "2 4\n00010\n10100\n01001\n00011\n00100\n10111\n", "output": ["11\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["127\n"]}, {"input": "2 9\n0000110000\n0001001100\n0011000000\n0001110010\n1101000000\n0001001000\n0110000110\n1000000001\n1001000001\n0011111110\n", "output": ["57\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001000\n0110000110\n0000010001\n1001000011\n0111111111\n", "output": ["77\n"]}, {"input": "9 9\n0000110011\n1001111000\n1001000000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["80\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001111000\n0001000000\n0101001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["142\n"]}, {"input": "5 4\n10001\n00000\n00000\n00001\n10101\n10110\n", "output": ["42\n"]}, {"input": "0 4\n11110\n01000\n01000\n00001\n00110\n00010\n", "output": ["1\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["131\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1100111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111100\n", "output": ["117\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n1001110000\n1000000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["118\n"]}, {"input": "9 9\n0000110000\n0001001100\n0001000000\n0001110100\n0101000100\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["125\n"]}, {"input": "9 9\n0000110011\n0101001000\n1001001001\n0001111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0110111110\n", "output": ["82\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111101\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["110\n"]}, {"input": "2 9\n0000010000\n0001001100\n0001000000\n0001110000\n1101000000\n0001101000\n0110001110\n1000000000\n1001001001\n0011111110\n", "output": ["75\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001111000\n0001000000\n0101001000\n0110001110\n1000000001\n1001001001\n0111111110\n", "output": ["140\n"]}, {"input": "9 9\n0000010010\n0001000001\n0001001100\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["132\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001100\n1101111101\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["105\n"]}, {"input": "9 9\n1100010000\n1001001000\n0101001100\n1101111000\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111010\n", "output": ["102\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001011000\n0001000000\n0101001000\n0110001110\n1000000001\n1001001001\n0111111110\n", "output": ["141\n"]}, {"input": "7 9\n0000110000\n0001000000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000111\n0000000001\n1001001011\n0111111110\n", "output": ["189\n"]}, {"input": "2 9\n0000110000\n0000001100\n0011000000\n1001110010\n1101000000\n0001001000\n0110000110\n1000000011\n1001000001\n0011111110\n", "output": ["60\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001100\n0110000111\n0010010001\n1001000011\n0111111111\n", "output": ["72\n"]}, {"input": "9 9\n0000110000\n0001011001\n0101000000\n0001011000\n0101010010\n0101001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["83\n"]}, {"input": "5 4\n10000\n00001\n00000\n00001\n01110\n00111\n", "output": ["41\n"]}, {"input": "9 9\n0000010010\n0001000001\n0001001100\n0001111000\n0001011000\n0001001000\n0110000110\n1000010001\n1101101011\n0111111110\n", "output": ["130\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001000100\n0001111010\n0001001000\n0001001000\n0011000110\n1100000000\n1001000001\n1111111110\n", "output": ["155\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001100\n1101111101\n0001000000\n0001001000\n0100100110\n1000100011\n1001001001\n0110101110\n", "output": ["104\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001100\n0110000111\n1010010001\n1001000011\n0111111111\n", "output": ["71\n"]}, {"input": "7 9\n0000100000\n0001000000\n0001000000\n0001111000\n1001000000\n0001001001\n0110000111\n0000000001\n1001001011\n0111111110\n", "output": ["195\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001000100\n0011111010\n0001001000\n0001001000\n0011000110\n1100000000\n1001000001\n1111111110\n", "output": ["134\n"]}, {"input": "5 4\n00010\n00100\n00000\n01001\n10100\n00110\n", "output": ["33\n"]}, {"input": "5 4\n00000\n00101\n00000\n01001\n10100\n00110\n", "output": ["33\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10100\n00110\n", "output": ["25\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10100\n00111\n", "output": ["24\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["183\n"]}, {"input": "5 4\n10010\n00000\n01000\n00011\n00100\n00110\n", "output": ["31\n"]}, {"input": "5 4\n11010\n00000\n01000\n00001\n10100\n00110\n", "output": ["24\n"]}, {"input": "5 4\n11010\n00100\n00000\n01001\n10100\n00110\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00101\n00100\n01000\n10110\n00111\n", "output": ["23\n"]}, {"input": "5 4\n01000\n10101\n00100\n01101\n10110\n00111\n", "output": ["17\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n00110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01100\n10101\n00100\n01000\n10110\n01111\n", "output": ["17\n"]}, {"input": "4 4\n01100\n10101\n00100\n01001\n00110\n01111\n", "output": ["16\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["181\n"]}, {"input": "5 4\n10010\n00100\n01000\n00011\n00100\n00110\n", "output": ["29\n"]}, {"input": "5 4\n11010\n00000\n01000\n00001\n10100\n00111\n", "output": ["23\n"]}, {"input": "5 4\n10011\n00001\n00000\n00001\n10100\n00110\n", "output": ["35\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n00010\n00101\n00000\n01011\n10100\n01110\n", "output": ["28\n"]}, {"input": "5 4\n01000\n00101\n00000\n00001\n10100\n00110\n", "output": ["30\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n11111\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01000\n00101\n00100\n01010\n10110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01100\n10101\n00100\n01000\n10111\n01111\n", "output": ["15\n"]}, {"input": "4 4\n01100\n10101\n00100\n01001\n00100\n01111\n", "output": ["17\n"]}, {"input": "5 4\n10010\n10100\n01000\n00011\n00100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n01000\n00101\n00100\n00001\n10100\n00110\n", "output": ["27\n"]}, {"input": "5 4\n01000\n00101\n10000\n01001\n11111\n00111\n", "output": ["18\n"]}, {"input": "5 4\n01000\n00101\n00100\n01011\n10110\n00111\n", "output": ["20\n"]}, {"input": "4 4\n01100\n10101\n00100\n01101\n00100\n01111\n", "output": ["16\n"]}, {"input": "5 4\n10010\n10100\n01001\n00011\n00100\n00110\n", "output": ["26\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["148\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n01111\n", "output": ["26\n"]}, {"input": "5 4\n00000\n00101\n00100\n00001\n10101\n00010\n", "output": ["36\n"]}, {"input": "5 4\n01000\n00101\n00100\n00001\n10100\n00100\n", "output": ["31\n"]}, {"input": "5 4\n01000\n00101\n10000\n01101\n11111\n00111\n", "output": ["17\n"]}, {"input": "5 4\n01000\n00101\n00100\n00011\n10110\n00111\n", "output": ["24\n"]}, {"input": "4 4\n01100\n11101\n00100\n01101\n00100\n01111\n", "output": ["15\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["158\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n00110\n", "output": ["20\n"]}, {"input": "5 4\n11010\n00100\n00000\n00011\n10100\n01111\n", "output": ["24\n"]}, {"input": "5 4\n00000\n00101\n00100\n00001\n10101\n00011\n", "output": ["35\n"]}, {"input": "3 4\n01000\n00101\n00100\n00001\n10100\n00100\n", "output": ["25\n"]}, {"input": "5 4\n01000\n00101\n10100\n01101\n11111\n00111\n", "output": ["15\n"]}, {"input": "9 9\n0100100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["129\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n00111\n", "output": ["20\n"]}, {"input": "2 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001001\n0011111110\n", "output": ["101\n"]}, {"input": "5 4\n11010\n00110\n00000\n00011\n10100\n01111\n", "output": ["22\n"]}, {"input": "5 4\n00000\n00101\n00100\n10001\n10101\n00011\n", "output": ["30\n"]}, {"input": "3 4\n01001\n00101\n00100\n00001\n10100\n00100\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00100\n10100\n01101\n11111\n00111\n", "output": ["23\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n10111\n", "output": ["20\n"]}, {"input": "9 9\n0100010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["109\n"]}, {"input": "5 4\n11000\n00110\n00000\n00011\n10100\n01111\n", "output": ["24\n"]}, {"input": "5 4\n00000\n00111\n00100\n10001\n10101\n00011\n", "output": ["28\n"]}, {"input": "3 4\n01001\n00101\n00100\n00001\n10100\n10100\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00100\n10100\n01101\n01111\n00111\n", "output": ["25\n"]}, {"input": "3 4\n01100\n11111\n00100\n01101\n10100\n01111\n", "output": ["9\n"]}, {"input": "4 4\n10010\n10100\n01001\n00010\n00100\n10111\n", "output": ["22\n"]}, {"input": "9 9\n1100010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["107\n"]}, {"input": "2 9\n0000110000\n0001001100\n0001000000\n0001110000\n1101000000\n0001001000\n0110001110\n1000000001\n1001001001\n0011111110\n", "output": ["74\n"]}], "task_id": "codecontest/12", "prompt": "Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}. Consider edge cases where there are no telephone poles on the plane.\n\nMake sure to verify the input constraints and handle large grids efficiently.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "repair_prompt": ["Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}. Consider edge cases where there are no telephone poles on the plane.\n\nMake sure to verify the input constraints and handle large grids efficiently.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nWrite a main() function and use input() function to read input from stdin", " Mr. Chanek's city is represented as a plane, and he plans to construct a housing complex there. There are several telephone poles scattered across the plane, which are indicated by a grid of size (n + 1) \u00d7 (m + 1). Specifically, a telephone pole is located at the point (x, y) if the value of a_{x, y} is 1.\n\nFor every point (x, y) in the grid, S(x, y) is defined as the square of the Euclidean distance between the nearest telephone pole and (x, y). The Euclidean distance between two\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nWrite a main() function and use input() function to read input from stdin", " Mr. Chanek's city is represented as a plane, and he plans to build a housing complex. There are telephone poles on the plane, represented by a grid of size (n + 1) \u00d7 (m + 1). A telephone pole is at (x, y) if a_{x, y} = 1. For each point (x, y), S(x, y) is the square of the Euclidean distance to the nearest pole. The project supervisor asks for the sum of all S(x, y) for 0 \u2264 x \u2264 n and 0 \u2264 y \u2264\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_squares(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    \n    # Find all positions of telephone poles\n    poles = []\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                poles.append((i, j))\n    \n    # Initialize a distance grid to store the minimum distance to the nearest pole for each point in the grid\n    distance_grid = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Function to perform BFS and fill the distance grid\n    def bfs(start):\n        queue = deque([start])\n        distance_grid[start[0]][start[1]] = 0\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx <= n and 0 <= ny <= m and distance_grid[nx][ny] == float('inf'):\n                    distance_grid[nx][ny] = distance_grid[x][y] + 1\n                    queue.append((nx, ny))\n    \n    # Perform BFS from each telephone pole position\n    for pole in poles:\n        bfs(pole)\n    \n    # Compute the sum of the squares of the distances in the distance grid\n    result = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            result += distance_grid[i][j] ** 2\n    \n    return result\n\n# Read the grid size and the grid itself from the input\nn, m = map(int, input().split())\ngrid = [list(map(int, list(input()))) for _ in range(n + 1)]\n\n# Calculate the sum of squares of distances\nresult = calculate_sum_of_squares(grid)\n\n# Output the result\nprint(result)\n", "from typing import List\nfrom collections import deque\nfrom typing import List\n\ndef calculate_sum_of_distances(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    \n    # Initialize the minimum distance squared grid\n    min_dist_sq = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # BFS to find the nearest pole for each point\n    queue = deque()\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                queue.append((i, j))\n                min_dist_sq[i][j] = 0\n    \n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx <= n and 0 <= ny <= m and min_dist_sq[nx][ny] > min_dist_sq[x][y] + 1:\n                min_dist_sq[nx][ny] = min_dist_sq[x][y] + 1\n                queue.append((nx, ny))\n    \n    # Calculate the sum of all S(x, y)\n    total_sum = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            total_sum += min_dist_sq[x][y] ** 2\n    \n    return total_sum\n\n# Read the grid size and the grid itself from the input\nn, m = map(int, input().split())\ngrid = [[0] * (m + 1) for _ in range(n + 1)]\n\n# Read the grid and store pole positions\nfor i in range(n + 1):\n    row = input().split()\n    for j in range(m + 1):\n        grid[i][j] = int(row[j])\n\n# Calculate the sum of all S(x, y)\nresult = calculate_sum_of_distances(grid)\nprint(result)\n", "from typing import List\nfrom typing import List\nimport sys\n\ndef calculate_sum_of_squares(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    \n    # Find all poles positions\n    poles = []\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                poles.append((i, j))\n    \n    # If there is only one pole, return the total number of points\n    if len(poles) == 1:\n        return n * m\n    \n    # Initialize the distance matrix with infinity\n    INF = sys.maxsize\n    dist = [[INF] * (m + 1) for _ in range(n + 1)]\n    \n    # BFS to find the nearest pole for each point\n    from collections import deque\n    queue = deque()\n    \n    for pole in poles:\n        queue.append(pole)\n        dist[pole[0]][pole[1]] = 0\n    \n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx <= n and 0 <= ny <= m and dist[nx][ny] == INF:\n                dist[nx][ny] = dist[x][y] + 1\n                queue.append((nx, ny))\n    \n    # Calculate the sum of squares of distances\n    sum_of_squares = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            sum_of_squares += dist[i][j] ** 2\n    \n    return sum_of_squares\n\n# Read input\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n + 1)]\n\n# Calculate and print the result\nresult = calculate_sum_of_squares(grid)\nprint(result)\n", "from typing import List\nfrom typing import List, Tuple\nimport math\n\n## Calculate the Euclidean distance between two points\ndef calculate_distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> float:\n    x1, y1 = point1\n    x2, y2 = point2\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\n## Find the nearest telephone pole for a given point in the grid\ndef find_nearest_pole(grid: List[List[int]], point: Tuple[int, int]) -> Tuple[int, int]:\n    n = len(grid)\n    m = len(grid[0])\n    nearest_pole = None\n    min_distance = float('inf')\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                distance = calculate_distance(point, (i, j))\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_pole = (i, j)\n    \n    return nearest_pole\n\n## Compute the sum of squares of distances for the entire grid\ndef compute_sum_of_squares(n: int, m: int, grid: List[List[int]]) -> int:\n    sum_of_squares = 0\n    \n    for i in range(n):\n        for j in range(m):\n            point = (i, j)\n            nearest_pole = find_nearest_pole(grid, point)\n            distance_squared = calculate_distance(point, nearest_pole) ** 2\n            sum_of_squares += distance_squared\n    \n    return sum_of_squares\n\n# Read the grid size and the grid itself from the input\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n + 1)]\n\n# Compute the result and print it\nresult = compute_sum_of_squares(n, m, grid)\nprint(result)\n", "from typing import List\nimport numpy as np\n\ndef calculate_distance_sum(grid: np.ndarray) -> int:\n    n, m = grid.shape\n    sum_of_squares = 0\n\n    for x in range(n):\n        for y in range(m):\n            if grid[x, y] == 1:\n                nearest_pole = (x, y)\n            else:\n                nearest_pole = None\n\n            min_distance_squared = float('inf')\n            for i in range(n):\n                for j in range(m):\n                    if grid[i, j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n                            nearest_pole = (i, j)\n\n            sum_of_squares += min_distance_squared\n\n    return sum_of_squares\n\n# Interface\nn, m = map(int, input().split())\ngrid = np.zeros((n + 1, m + 1), dtype=int)\nfor i in range(n + 1):\n    grid[i] = list(map(int, input().split()))\n\nresult = calculate_distance_sum(grid)\nprint(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef calculate_distance_sum(grid: np.ndarray) -> int:\n    n, m = grid.shape\n    sum_of_squares = 0\n\n    # Create a distance matrix with initial values of infinity\n    distances = np.full((n, m), np.inf)\n\n    # Use a flood fill algorithm to compute the distance to the nearest telephone pole\n    from scipy.ndimage import distance_transform_edt\n    distances = distance_transform_edt(grid == 0)\n\n    # Sum the squares of the distances\n    sum_of_squares = np.sum(distances ** 2)\n    return int(sum_of_squares)\n\n# Read input\nn, m = map(int, input().split())\ngrid = np.zeros((n + 1, m + 1), dtype=int)\nfor i in range(n + 1):\n    grid[i] = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = calculate_distance_sum(grid)\nprint(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef calculate_distance_sum(grid: np.ndarray) -> int:\n    n, m = grid.shape\n    sum_of_squares = 0\n\n    # Create a grid of distances to the nearest pole\n    distances = np.zeros((n, m), dtype=int)\n    for x in range(n):\n        for y in range(m):\n            if grid[x, y] == 1:\n                distances[x, y] = 0\n            else:\n                distances[x, y] = np.min(np.sum((np.ogrid[0:n] - x)**2 + (np.ogrid[0:m] - y)**2, axis=0))\n    \n    sum_of_squares = np.sum(distances**2)\n    return sum_of_squares\n\n# Interface\nn, m = map(int, input().split())\ngrid = np.zeros((n + 1, m + 1), dtype=int)\nfor i in range(n + 1):\n    grid[i] = list(map(int, input().split()))\n\nresult = calculate_distance_sum(grid)\nprint(result)\n", "from typing import List\n## main.py\n\nimport math\nfrom typing import List\n\ndef calculate_distance_sum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the sum of the squares of the Euclidean distances to the nearest pole for each point in the grid.\n    \n    Args:\n        grid (List[List[int]]): A 2D list representing the grid where each element is either 0 or 1.\n    \n    Returns:\n        int: The sum of the squares of the Euclidean distances to the nearest pole for each point in the grid.\n    \"\"\"\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    total_sum = 0\n\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            total_sum += min_distance_squared\n\n    return total_sum\n\n# Read input\nn, m = map(int, input().split())\ngrid = []\nfor _ in range(n + 1):\n    row = list(map(int, input().split()))\n    grid.append(row)\n\n# Calculate and print the result\nresult = calculate_distance_sum(grid)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_squares(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    \n    # Directions for BFS (right, down, left, up)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Initialize the sum of squares\n    sum_of_squares = 0\n    \n    # BFS to find the distance to the nearest pole for each point\n    def bfs(start_x, start_y):\n        visited = [[False] * (m + 1) for _ in range(n + 1)]\n        queue = deque([(start_x, start_y, 0)])  # (x, y, distance)\n        visited[start_x][start_y] = True\n        \n        while queue:\n            x, y, dist = queue.popleft()\n            if grid[x][y] == 1:\n                return dist\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx <= n and 0 <= ny <= m and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny, dist + 1))\n        return float('inf')\n    \n    # Calculate the sum of squares for each point in the grid\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 0:\n                distance = bfs(i, j)\n                sum_of_squares += distance ** 2\n    \n    return sum_of_squares\n\n# Read input\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n + 1)]\n\n# Calculate and print the result\nresult = calculate_sum_of_squares(grid)\nprint(result)\n", "from typing import List\n## main.py\n\nimport sys\nfrom typing import List\n\ndef calculate_sum_of_distances(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    sum_of_distances = 0\n\n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            sum_of_distances += min_distance_squared\n\n    return sum_of_distances\n\ndef main():\n    # Read input from stdin\n    n, m = map(int, sys.stdin.readline().split())\n    grid = []\n    for _ in range(n + 1):\n        row = list(map(int, sys.stdin.readline().split()))\n        grid.append(row)\n\n    # Calculate the sum of distances\n    result = calculate_sum_of_distances(grid)\n\n    # Output the result\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe problem requires calculating the sum of squares of distances to the nearest telephone pole for each point in a grid. The grid size can be up to 2000x2000, and there must be at least one telephone pole. The solution should be efficient and handle large grids without excessive memory usage or runtime.\nrequirement pool:\n- Implement an efficient algorithm to calculate the sum of squares of distances to nearest poles.\n- Ensure the solution can handle grids up to 2000x2000.\n- Provide a clear and accurate output for the given problem.\n- Test the solution for edge cases where there are no telephone poles.\n- Optimize the solution for performance and scalability.\nTo solve this problem efficiently, we will use a Breadth-First Search (BFS) approach to calculate the distance to the nearest telephone pole for each point in the grid. This method ensures that we can handle large grids up to 2000x2000 without excessive memory usage or runtime. We will preprocess the grid to identify all positions of telephone poles and then use BFS to compute the distances from each point to the nearest pole. Finally, we will sum up the squares of these distances to get the desired result.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem.\n    'Breadth-First Search (BFS)': A graph traversal algorithm that explores all vertices at the present depth prior to moving on to the vertices at the next depth level.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the grid size and the grid itself from the input.\n    2. Identify the positions of all telephone poles.\n    3. Initialize a distance grid to store the minimum distance to the nearest pole for each point in the grid.\n    4. Use BFS to fill the distance grid, starting from each telephone pole position.\n    5. Compute the sum of the squares of the distances in the distance grid.\n    6. Output the result.\n\n# [edge case]\n    Edge case 1: Small grid with no telephone poles.\n    Input: 0 0\n           (No telephone poles)\n    Expected output: 0\n    Explanation: Since there are no telephone poles, the distance to the nearest pole for every point is considered infinite, and thus the sum of squares of distances is 0.\n\n    Edge case 2: Large grid with telephone poles only on the border.\n    Input: 3 3\n           00000\n           00100\n           00000\n           00000\n    Expected output: 8\n    Explanation: The nearest pole to the center (1,1) is at (1,2), and the distance is 1. The sum of squares of distances is 1^2 + 1^2 + 1^2 + 1^2 = 4. The same logic applies to the other points on the border.\n\n    Edge case 3: Grid with telephone poles only in one row.\n    Input: 2 2\n           0000\n           1111\n           0000\n    Expected output: 16\n    Explanation: The nearest pole to any point in the grid is directly below or above the point, depending on its position. The sum of squares of distances is 1^2 + 1^2 + 1^2 + 1^2 for each row, and there are 4 rows.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles cases where there are no telephone poles or where poles are isolated, as it will simply not explore non-existent poles.\n", "requirement analysis:\nThe primary requirement is to calculate the sum of squares of distances to the nearest telephone poles in a given grid. The grid size can be up to 2000x2000, and there must be at least one pole in the grid. The solution should be efficient and handle large grids without performance issues. The output should be an integer representing the sum of all S(x, y) values.\nrequirement pool:\n- Implement a function to calculate the square of Euclidean distance between two points.\n- Create a method to find the nearest pole for each point in the grid.\n- Develop a function to sum up all S(x, y) values for the given grid.\n- Optimize the algorithm to handle large grids efficiently.\n- Ensure the solution is robust and handles edge cases, such as no poles in the grid.\nTo solve this problem efficiently, we will use a combination of breadth-first search (BFS) and dynamic programming. The BFS will be used to find the nearest pole for each point, and dynamic programming will help in optimizing the calculation of the sum of squares of distances. We will leverage the Python standard library to handle the grid input and the BFS operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem, where the distance is the square root of the sum of the squares of the differences in the coordinates.\n\n# [phrase showing quantity relationship]\n    'square of the Euclidean distance': This refers to the squared distance between two points, calculated as (x2 - x1)^2 + (y2 - y1)^2.\n\n# [degree adverb] \n    'nearest': Indicates the closest telephone pole to a given point.\n\n# [code logic]\n    To solve this problem, we will follow these steps:\n    1. Read the grid size and the grid itself from the input.\n    2. Initialize a 2D list to store the minimum distance squared (S(x, y)) for each point.\n    3. Use BFS to find the nearest pole for each point, updating the minimum distance squared.\n    4. Sum up all the S(x, y) values for the entire grid.\n    5. Output the sum.\n\n# [edge case] \n    Input: 1 1\n          1\n          0\n    Output: 1\n    Explanation: There is only one point with a pole, and the nearest pole to itself is itself. Thus, S(0, 0) = 0, S(0, 1) = 1, S(1, 0) = 1, S(1, 1) = 0. The sum is 1 + 1 + 0 + 0 = 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan will work for a single pole as well.\n\n# [code logic] implementation:\n```python\nfrom collections import deque\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [[0] * (m + 1) for _ in range(n + 1)]\n    poles = []\n    \n    # Read the grid and store pole positions\n    for i in range(n + 1):\n        row = input().split()\n        for j in range(m + 1):\n            grid[i][j] = int(row[j])\n            if grid[i][j] == 1:\n                poles.append((i, j))\n    \n    # Initialize the minimum distance squared grid\n    min_dist_sq = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # BFS to find the nearest pole for each point\n    queue = deque(poles)\n    for x, y in poles:\n        min_dist_sq[x][y] = 0\n    \n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx <= n and 0 <= ny <= m and min_dist_sq[nx][ny] > min_dist_sq[x][y] + 1:\n                min_dist_sq[nx][ny] = min_dist_sq[x][y] + 1\n                queue.append((nx, ny))\n    \n    # Calculate the sum of all S(x, y)\n    total_sum = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            total_sum += min_dist_sq[x][y] ** 2\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()\n```\n", "requirement analysis:\nThe requirements specify the need to calculate the sum of squares of distances to the nearest telephone pole for each point in a grid. The grid size can be up to 2000x2000, and there must be at least one pole in the grid. The solution must be efficient and handle large grids without performance issues. The output should be an integer representing the sum of all S(x, y) values.\nrequirement pool:\n- Implement a function to calculate the square of Euclidean distance between two points.\n- Create a function to find the nearest pole for each point in the grid.\n- Develop a main function to compute the sum of all S(x, y) values.\nTo solve this problem efficiently, we will use a combination of breadth-first search (BFS) and dynamic programming. The BFS will be used to find the nearest pole for each point, and dynamic programming will help in avoiding redundant calculations for points that share the same nearest pole. This approach ensures that the solution is scalable and can handle large grids efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem.\n    'Sum of squares': The sum of the squares of the distances from each point to the nearest telephone pole.\n\n# [phrase showing quantity relationship]\n    'square of the Euclidean distance': The distance between two points (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\n# [degree adverb] \n    'nearest': The closest telephone pole to a given point.\n\n# [code logic]\n    To solve this problem, we will use a BFS approach to find the nearest pole for each point. We will initialize a distance matrix with a large value (infinity) and update the distance for each pole found. Then, we will iterate through the grid, summing the squares of the distances from each point to the nearest pole.\n\n# [edge case] \n    Input: 1 1\n          10\n          01\n    Output: 2\n    Explanation: The nearest pole for both points (0,0) and (1,1) is at (0,0) or (1,1). Thus, the sum of squares is (0 + 1) + (1 + 0) = 2.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where there is only one pole. In such a case, the distance to the pole is zero, and the sum of squares is simply the number of points in the grid.\n\n    if total_poles == 1:\n        return n * m\n\n    (other code)\n", "requirement analysis:\nThe primary requirement is to calculate the sum of squares of distances to the nearest telephone pole for each point in the grid. This involves finding the Euclidean distance between each point and the nearest pole, then squaring that distance. The application should be able to handle grids up to 2000x2000, which requires efficient algorithms to avoid performance issues.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance between two points.\n- Create a function to find the nearest telephone pole for each point in the grid.\n- Develop a main function to compute the sum of squares of distances.\n- Ensure the application can handle large grids efficiently.\n- Design a user-friendly interface for easy input and output.\nTo address the requirements, we will use Python, leveraging its efficient handling of numerical computations and data structures. We will implement a function to calculate the Euclidean distance between two points, find the nearest telephone pole for each point in the grid, and develop a main function to compute the sum of squares of distances. We will ensure the application can handle large grids efficiently by optimizing the distance calculation.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the formula sqrt((x1 - x2)^2 + (y1 - y2)^2).\n    'Square of Euclidean distance': The distance squared between two points, used for computational simplicity in some cases.\n    'Nearest telephone pole': The telephone pole closest to a given point in the grid.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates a comparison where one quantity is greater than another.\n    'at least as many times': Indicates a comparison where one quantity is greater than or equal to another.\n\n# [degree adverb] \n    'largest': Indicates the greatest value in a set of values.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the grid size and the grid itself from the input.\n    2. Initialize a variable to store the sum of squares of distances.\n    3. Iterate over each point in the grid.\n    4. For each point, find the nearest telephone pole.\n    5. Calculate the square of the Euclidean distance between the point and the nearest telephone pole.\n    6. Add the calculated distance to the sum.\n    7. Return the final sum after iterating through all points.\n\n# [edge case] \n    Edge case 1: Small grid with one telephone pole\n    Input: \n    1 1\n    1\n    1\n    Output: \n    2\n    Explanation: There is only one point in the grid, and the nearest telephone pole is at the same location, so the distance is 0, and its square is 0. The sum is 0 + 0 = 0, but since the grid is 1x1, the point is (0,0), and the nearest pole is at (0,0), the distance is 0, and its square is 0. The sum is 0 + 0 = 0.\n\n    Edge case 2: Grid with multiple telephone poles\n    Input: \n    2 2\n    101\n    000\n    000\n    Output: \n    18\n    Explanation: The nearest telephone pole for each point is at (0, 0). The distances are (0, 1, 4) for points (0,0), (1,0), and (2,0), and (1, 2, 5) for points (0,1), (1,1), and (2,1). The sum of squares of distances is 18.\n\n    Edge case 3: Large grid with multiple telephone poles\n    Input: \n    5 4\n    10010\n    00000\n    01000\n    00001\n    00100\n    00010\n    Output: \n    36\n    Explanation: The nearest telephone pole for each point is calculated considering all poles. The sum of squares of distances is 36.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic can handle all cases efficiently.\n", "requirement analysis:\nThe primary requirement is to calculate the sum of squares of distances to the nearest pole for each point in the grid. This involves finding the Euclidean distance between each point and the nearest telephone pole, then squaring that distance. The application should be able to handle grids up to 2000x2000, which requires efficient algorithms to avoid performance issues.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance between two points.\n- Develop a function to find the nearest telephone pole for each point in the grid.\n- Create a function to compute the sum of squares of distances to the nearest pole for each point in the grid.\n- Ensure the application can handle large grids without performance issues.\n- Design a user-friendly interface for easy interaction and understanding.\nTo implement the solution, we will use Python due to its simplicity and efficiency. We will leverage the NumPy library to handle the grid and array operations efficiently. The main steps involve reading the grid, finding the nearest pole for each point, and calculating the sum of squares of distances. We will also ensure the application is scalable by optimizing the distance calculation and using efficient data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem, where the distance is the square root of the sum of the squares of the differences in the coordinates.\n\n# [phrase showing quantity relationship]\n    'square of the Euclidean distance': This means that the distance calculated should be squared before being added to the sum.\n\n# [degree adverb] \n    'nearest': This indicates that we need to find the closest telephone pole to a given point.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Read the grid size and the grid itself from the input.\n    2. Initialize a variable to store the sum of squares of distances.\n    3. Iterate over each point in the grid.\n    4. For each point, find the nearest telephone pole.\n    5. Calculate the square of the Euclidean distance between the point and the nearest telephone pole.\n    6. Add the squared distance to the sum.\n    7. Return the final sum after iterating through all points.\n\n# [edge case] \n    Input: 1 1\\n1\\n0\\n\n    Output: 1\n    Explanation: There is only one point (0,0) and one telephone pole at (0,0). The distance is 0, and its square is 0.\n\n    Input: 1 1\\n0\\n1\\n\n    Output: 1\n    Explanation: There is only one point (0,0) and one telephone pole at (1,0). The distance is 1, and its square is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the edge case where there is only one point and one telephone pole.\n", "requirement analysis:\nThe primary requirement is to calculate the sum of squares of distances from each point in the grid to the nearest telephone pole. This involves finding the Euclidean distance for each point and then squaring it. The application should be able to handle grids up to 2000x2000, which requires efficient algorithms to avoid performance issues.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance between two points.\n- Develop a function to find the nearest telephone pole for each point in the grid.\n- Create a function to compute the sum of squares of distances from each point to the nearest pole.\n- Ensure the application can handle large grids efficiently.\n- Design a user-friendly interface for easy input and output.\nTo implement the solution, we will use Python due to its simplicity and efficiency. We will leverage the NumPy library to handle the grid efficiently and calculate the Euclidean distances. The main function will compute the sum of squares of distances from each point to the nearest telephone pole.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem, where the distance is the square root of the sum of the squares of the differences in the coordinates.\n    'Sum of squares': The sum of the squares of the distances from each point to the nearest telephone pole.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the distance from a point to a telephone pole must be greater than zero.\n    'at least as many times': Indicates that the distance from a point to a telephone pole must be at least as much as the value of the telephone pole itself.\n\n# [degree adverb] \n    'largest': Indicates that the distance from a point to the nearest telephone pole should be the largest possible distance.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the input grid representing the city and the positions of telephone poles.\n    2. Initialize a variable to store the sum of squares of distances.\n    3. Iterate over each point in the grid and calculate the Euclidean distance to the nearest telephone pole.\n    4. Add the square of the distance to the sum.\n    5. Return the final sum after iterating through all points.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    1 1\n    1\n    1\n    Output:\n    4\n    Explanation: There is only one point (0,0) and one telephone pole at (0,0). The distance is 0, and the square of the distance is 0. However, since there is only one point and one telephone pole, the sum of squares of distances is 4 (0^2 + 0^2).\n\n    Edge case 2:\n    Input:\n    2 2\n    000\n    000\n    000\n    Output:\n    0\n    Explanation: There are no telephone poles in the grid, so the distance to the nearest telephone pole is infinite. The sum of squares of distances is 0.\n\n    Edge case 3:\n    Input:\n    3 3\n    100\n    000\n    001\n    Output:\n    14\n    Explanation: The nearest telephone pole for the points (0,0) and (2,2) is at (0,0) and (2,2) respectively. The nearest telephone pole for the points (1,0), (1,1), and (1,2) is at (0,0). The sum of squares of distances is (1 + 4 + 1) + (1 + 2 + 1) + (1 + 4 + 1) = 14.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic can handle cases with no telephone poles or a single point and pole.\n", "requirement analysis:\nThe primary requirement is to calculate the sum of the squares of the Euclidean distances from each point in the grid to the nearest telephone pole. The grid size can be up to 2000x2000, and there must be at least one pole in the grid. The solution should be efficient and handle large grids without performance issues.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance between two points.\n- Create a function to find the nearest pole for each point in the grid.\n- Develop a main function to sum the squares of the distances to the nearest poles.\n- Optimize the code for large grid sizes to ensure performance.\n- Ensure the user interface is simple and intuitive for easy input and output.\nTo solve this problem, we will use Python, leveraging its powerful libraries for handling large grids efficiently. We will use the NumPy library to handle the grid data structure and calculate the Euclidean distances. The approach involves iterating over each point in the grid, finding the nearest pole, and then summing the squares of these distances.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem, where the distance is the square root of the sum of the squares of the differences in the coordinates.\n    'Sum of squares': The sum of the squares of the distances from each point to the nearest pole.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the grid size and the grid itself from the input.\n    2. Initialize a variable to store the sum of squares of distances.\n    3. Iterate over each point in the grid.\n    4. For each point, calculate the Euclidean distance to the nearest pole.\n    5. Square the distance and add it to the sum.\n    6. Return the final sum after iterating through all points.\n\n# [edge case] \n    Edge Case 1: Small Grid\n    Input: 1 1\n           10\n           01\n    Expected Output: 4\n    Explanation: The nearest pole for both points (0,0) and (1,1) is at (0,0). The sum of squares is (0 + 1) + (1 + 0) = 2.\n\n    Edge Case 2: Grid with No Adjacent Poles\n    Input: 2 2\n           0000\n           0000\n           0000\n    Expected Output: 0\n    Explanation: There are no poles adjacent to each other, so the distance to the nearest pole is 0 for all points.\n\n    Edge Case 3: Large Grid with Poles\n    Input: 1000 1000\n           (1s and 0s representing poles)\n    Expected Output: (a large number representing the sum of squares)\n    Explanation: This edge case tests the efficiency of the solution for a large grid. The solution should handle this efficiently without excessive computation time.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic should be sufficient for the given constraints. However, if the grid size were to increase significantly, optimizations such as using a more efficient distance calculation method or parallel processing might be necessary.\n", "requirement analysis:\nThe requirements specify the need to calculate the square of the Euclidean distance to the nearest pole for each point in the grid. The input includes the grid size and the positions of the telephone poles. The output is the sum of all S(x, y) values. The product must be able to handle large grids efficiently, which requires careful consideration of algorithmic complexity and optimization.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance to the nearest pole for each point in the grid.\n- Develop a user interface to input the grid size and pole positions.\n- Ensure the product can handle large grids without performance issues.\n- Provide a clear and user-friendly output displaying the sum of all S(x, y) values.\n- Include error handling to manage invalid inputs gracefully.\nTo implement the solution, we will use Python due to its simplicity and efficiency. The main challenge is to calculate the Euclidean distance to the nearest pole for each point in the grid efficiently, especially for large grids. We will leverage the Python Imaging Library (PIL) to handle the grid input and numpy for efficient numerical operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane is the length of the line segment connecting them. The Euclidean distance between two points (x1, y1) and (x2, y2) is given by the formula: \u221a((x2 - x1)^2 + (y2 - y1)^2).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the input grid size and the grid itself.\n    2. Initialize a sum variable to accumulate the sum of all S(x, y).\n    3. Iterate through each point (x, y) in the grid.\n    4. For each point, calculate the Euclidean distance to the nearest pole.\n    5. Square the distance and add it to the sum.\n    6. Return the final sum after iterating through all points.\n\n# [edge case] \n    Edge case 1: Small grid\n    Input: 1 1\n           10\n           01\n    Expected output: 4\n    Explanation: The nearest pole for (0,0) and (1,1) is at (0,0), and for (0,1) and (1,0) is at (1,1). The sum of squares of distances is 1^2 + 1^2 + 1^2 + 1^2 = 4.\n\n    Edge case 2: Grid with one row or column\n    Input: 3 0\n           1\n           0\n           1\n    Expected output: 2\n    Explanation: The grid is a single row. The nearest pole for (0,0) and (1,0) is at (0,0), and for (2,0) is at (0,0). The sum of squares of distances is 1^2 + 1^2 = 2.\n\n    Edge case 3: Large grid with no poles\n    Input: 1000 1000\n           0000000000\n           0000000000\n           ...\n           0000000000\n    Expected output: 0\n    Explanation: The grid is entirely empty. There are no poles, so the sum of squares of distances is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle grids of any size, including the edge cases mentioned.\n", "requirement analysis:\nThe primary requirement is to calculate the sum of squares of distances to the nearest pole for each point in the grid. The grid size can be up to 2000x2000, and there must be at least one pole in the grid. The output should be an integer representing the total sum of S(x, y) for all points in the grid.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance between two points.\n- Create a loop to iterate through each point in the grid and find the nearest pole.\n- Develop a method to sum the squares of these distances.\n- Optimize the algorithm to handle large grids efficiently.\n- Design a user-friendly interface for easy input and output.\nTo solve this problem, we will use Python due to its robust standard library and ease of use. The main challenge is to efficiently calculate the Euclidean distance to the nearest pole for each point in the grid. We will leverage the fact that the grid size is not excessively large (up to 2000x2000) and use a breadth-first search (BFS) approach to find the nearest pole. This method is efficient and suitable for handling large grids.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem, where d = sqrt((x2 - x1)^2 + (y2 - y1)^2).\n\n    'telephone poles on a grid': Represented by a_{x, y} = 1, where (x, y) is the position of the pole on the grid.\n\n    'sum of all S(x, y)': The sum of the squares of the Euclidean distances from each point (x, y) to the nearest telephone pole.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the grid size and the grid itself from the input.\n    2. Initialize a 2D list to store the sum of distances for each point (x, y).\n    3. Use a BFS approach to calculate the distance from each point to the nearest pole.\n    4. Sum up all the distances to get the final result.\n\n# [edge case] \n    Edge Case 1: Small grid with one pole\n    Input: 1 1\n           1\n    Expected Output: 1\n    Explanation: The grid is 2x2 with one pole at (0, 0). The distance to the pole at (0, 0) for all points is 1.\n\n    Edge Case 2: Large grid with multiple poles\n    Input: 3 3\n           10010\n           00000\n           00001\n    Expected Output: 72\n    Explanation: The grid is 4x4 with poles at (0, 0), (3, 3), and (3, 4). The distances are calculated considering the nearest poles, and the sum is 72.\n\n    Edge Case 3: Grid with poles only at the edges\n    Input: 2 2\n           1000\n           0000\n           0001\n    Expected Output: 10\n    Explanation: The grid is 3x3 with poles at (0, 0) and (2, 3). The distances are calculated considering the nearest poles, and the sum is 10.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles edge cases by considering the nearest poles efficiently.\n", "requirement analysis:\nThe problem requires calculating the sum of squares of distances to the nearest telephone pole for each point in a grid. The grid size can be up to 2000x2000, and there must be at least one telephone pole in the grid. The solution should be efficient and handle edge cases, such as no telephone poles in the grid.\nrequirement pool:\n- Implement a function to calculate the distance to the nearest pole for each point in the grid.\n- Optimize the function to handle large grids efficiently.\n- Ensure the solution can handle edge cases, such as no telephone poles in the grid.\n- Provide a clear and concise output for the given problem.\n- Test the solution against multiple test cases to ensure robustness.\nTo solve this problem efficiently, we will use a pre-computed distance map approach. This method involves creating a grid that stores the minimum distance to the nearest telephone pole for each cell in the grid. We will iterate over each cell in the grid, and for each cell, we will calculate the Euclidean distance to all telephone poles and keep track of the minimum distance. This approach ensures that we can handle large grids efficiently without recalculating distances for each cell multiple times. We will use Python's built-in data structures and libraries to implement this solution.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane is the length of the line segment connecting them. The Euclidean distance between two points (x1, y1) and (x2, y2) is given by the formula \u221a((x2 - x1)^2 + (y2 - y1)^2).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To solve this problem efficiently, we will use a pre-computed distance map approach. This method involves creating a grid that stores the minimum distance to the nearest telephone pole for each cell in the grid. We will iterate over each cell in the grid, and for each cell, we will calculate the Euclidean distance to all telephone poles and keep track of the minimum distance.\n\n# [edge case] \n    Input: 1 1\n          1\n          0\n    Output: 2\n    Explanation: There is only one telephone pole at (0, 0) and one cell in the grid at (1, 1). The Euclidean distance between (1, 1) and (0, 0) is \u221a((1-0)^2 + (1-0)^2) = \u221a2. Since we are considering the square of the Euclidean distance, the result is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the case where there is only one telephone pole and one cell in the grid.\n\n# [code logic]\n    Here's a detailed implementation of the plan:\n\n    ```python\n    import sys\n\n    def main():\n        # Read input from stdin\n        n, m = map(int, input().split())\n        grid = []\n        for _ in range(n + 1):\n            row = list(map(int, input().split()))\n            grid.append(row)\n\n        # Initialize the sum of distances\n        sum_of_distances = 0\n\n        # Iterate over each cell in the grid\n        for x in range(n + 1):\n            for y in range(m + 1):\n                min_distance_squared = float('inf')\n                # Calculate the minimum distance squared to any telephone pole\n                for i in range(n + 1):\n                    for j in range(m + 1):\n                        if grid[i][j] == 1:\n                            distance_squared = (x - i) ** 2 + (y - j) ** 2\n                            if distance_squared < min_distance_squared:\n                                min_distance_squared = distance_squared\n                # Add the minimum distance squared to the sum\n                sum_of_distances += min_distance_squared\n\n        # Output the result\n        print(sum_of_distances)\n\n    if __name__ == \"__main__\":\n        main()\n    ```\n\nThis code reads the grid from standard input, calculates the sum of the square of the Euclidean distances for each cell to the nearest telephone pole, and outputs the result.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 41, "examples": "\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "mutate_method": "add_1_sentence_at_end", "parent_index": 29}
