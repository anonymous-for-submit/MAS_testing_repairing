{"name": "1575_M. Managing Telephone Poles", "description": "Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "tags": ["data structures", "geometry"], "difficulty": 20, "id": 1575, "sample_io": [{"input": "2 2\n101\n000\n000\n", "output": ["18\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n00100\n00010\n", "output": ["36\n"]}], "test_list": [{"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["182\n"]}, {"input": "0 0\n1\n", "output": ["0\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["181\n"]}, {"input": "2 2\n101\n010\n000\n", "output": ["8\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n00100\n00110\n", "output": ["33\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["183\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n10100\n00110\n", "output": ["25\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["187\n"]}, {"input": "5 4\n10010\n00000\n00000\n00001\n10100\n00110\n", "output": ["38\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001011000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["188\n"]}, {"input": "5 4\n10010\n00000\n00000\n01001\n10100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n10010\n00100\n00000\n01001\n10100\n00110\n", "output": ["24\n"]}, {"input": "5 4\n00010\n00101\n00000\n01001\n10100\n00110\n", "output": ["31\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10110\n00111\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00101\n00100\n01001\n10110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01000\n10101\n00100\n01001\n10110\n00111\n", "output": ["18\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n10110\n00111\n", "output": ["16\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n10110\n01111\n", "output": ["15\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n00110\n01111\n", "output": ["17\n"]}, {"input": "0 4\n10010\n00000\n01000\n00001\n00100\n00010\n", "output": ["3\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["152\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["149\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["163\n"]}, {"input": "5 4\n10010\n00001\n00000\n00001\n10100\n00110\n", "output": ["36\n"]}, {"input": "5 9\n0000110000\n0001001000\n0001000000\n0001011000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["193\n"]}, {"input": "5 4\n00010\n00100\n00000\n01001\n10110\n00110\n", "output": ["32\n"]}, {"input": "5 4\n00010\n00101\n00000\n01001\n10100\n01110\n", "output": ["30\n"]}, {"input": "5 4\n00000\n00101\n00000\n01001\n10100\n00010\n", "output": ["35\n"]}, {"input": "5 4\n01000\n00101\n00000\n00001\n10100\n00111\n", "output": ["29\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n11110\n00111\n", "output": ["22\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["148\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["146\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["164\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n10100\n00010\n", "output": ["40\n"]}, {"input": "5 4\n01100\n11101\n00100\n01001\n00110\n00111\n", "output": ["20\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["158\n"]}, {"input": "9 9\n0000110010\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["109\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["147\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["173\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n01110\n", "output": ["27\n"]}, {"input": "4 4\n00010\n00101\n00000\n01011\n10100\n01110\n", "output": ["26\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n10101\n00010\n", "output": ["39\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["157\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["106\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["171\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["107\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["129\n"]}, {"input": "2 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["101\n"]}, {"input": "4 4\n01100\n11111\n00100\n01101\n00100\n01111\n", "output": ["14\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["103\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["128\n"]}, {"input": "3 4\n01100\n11111\n00100\n01101\n00100\n01111\n", "output": ["9\n"]}, {"input": "9 9\n0100100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001000011\n0011111110\n", "output": ["133\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["90\n"]}, {"input": "2 9\n0000110000\n0001001100\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001001\n0011111110\n", "output": ["74\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["89\n"]}, {"input": "1 4\n01001\n00101\n00100\n00001\n10100\n10100\n", "output": ["7\n"]}, {"input": "9 9\n0000110011\n0001011000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["88\n"]}, {"input": "9 9\n0000110011\n0001011010\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["84\n"]}, {"input": "4 4\n10010\n10100\n01011\n00010\n00101\n10111\n", "output": ["19\n"]}, {"input": "3 4\n01100\n11101\n00100\n01101\n10110\n01110\n", "output": ["10\n"]}, {"input": "9 9\n0000110011\n0001011010\n1001000000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["85\n"]}, {"input": "1 4\n01100\n11101\n00100\n00101\n11110\n01110\n", "output": ["4\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["184\n"]}, {"input": "2 2\n101\n000\n010\n", "output": ["6\n"]}, {"input": "9 9\n0001110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["177\n"]}, {"input": "2 2\n101\n000\n110\n", "output": ["5\n"]}, {"input": "5 4\n10000\n00000\n00000\n00001\n10100\n00110\n", "output": ["67\n"]}, {"input": "5 4\n00000\n00100\n00000\n01001\n10100\n00010\n", "output": ["43\n"]}, {"input": "0 4\n10110\n00000\n01000\n00001\n00100\n00010\n", "output": ["2\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111101110\n", "output": ["153\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1001111000\n0001000000\n0001001000\n0110100110\n1000000001\n1001001011\n0111111110\n", "output": ["145\n"]}, {"input": "5 4\n00010\n00100\n00000\n00001\n10110\n00110\n", "output": ["37\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["180\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000000\n1001001001\n0111111110\n", "output": ["159\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00010\n", "output": ["52\n"]}, {"input": "9 9\n0000100000\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["137\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n0101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["175\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n1001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["99\n"]}, {"input": "5 4\n01000\n00111\n10100\n01101\n11111\n00111\n", "output": ["13\n"]}, {"input": "9 9\n0100100001\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["113\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110100110\n1000000011\n1001001011\n0110111110\n", "output": ["124\n"]}, {"input": "9 9\n0100010000\n0001001000\n0001001000\n1101111100\n0001000001\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["98\n"]}, {"input": "9 9\n1100010000\n0001001000\n0001001100\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["97\n"]}, {"input": "2 9\n0000110000\n0001000100\n0001000000\n0001110000\n1101000000\n0001001000\n0110001110\n1000000001\n1001001001\n0011111110\n", "output": ["78\n"]}, {"input": "9 9\n0000110011\n0001111000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["87\n"]}, {"input": "9 9\n0001110000\n0001001000\n0001001000\n1001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["144\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n0001000000\n0001001000\n0110000010\n1000000001\n1001001011\n0011111110\n", "output": ["190\n"]}, {"input": "5 4\n10000\n00000\n00000\n00001\n10101\n00110\n", "output": ["66\n"]}, {"input": "9 9\n0000110000\n0001011000\n0001000000\n0001011000\n0001000010\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["162\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["136\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1101111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["115\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0101111000\n1001000100\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["139\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n0001110000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["121\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00011\n", "output": ["51\n"]}, {"input": "4 9\n0000100000\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["111\n"]}, {"input": "5 4\n11010\n00000\n00000\n00001\n10100\n00111\n", "output": ["34\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001001\n0011111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0110111110\n", "output": ["86\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0100100110\n1000000011\n1001001011\n0110111110\n", "output": ["126\n"]}, {"input": "9 9\n1100010000\n1001001000\n0001001100\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["96\n"]}, {"input": "9 9\n0000110011\n1001111000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["79\n"]}, {"input": "9 9\n0000110000\n0001011000\n0001000000\n0001011000\n0001010010\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["161\n"]}, {"input": "9 9\n0000110000\n0001001000\n1001001000\n0000111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["143\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["135\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1100111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["116\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0101111000\n1001000100\n0011001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["138\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n0001110000\n1000000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["123\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00111\n", "output": ["48\n"]}, {"input": "4 9\n0000100000\n0101001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["73\n"]}, {"input": "3 4\n10010\n11101\n01000\n00011\n00100\n00110\n", "output": ["12\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001100\n0001111000\n1001001001\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["76\n"]}, {"input": "2 4\n00010\n10100\n01001\n00011\n00100\n10111\n", "output": ["11\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["127\n"]}, {"input": "2 9\n0000110000\n0001001100\n0011000000\n0001110010\n1101000000\n0001001000\n0110000110\n1000000001\n1001000001\n0011111110\n", "output": ["57\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001000\n0110000110\n0000010001\n1001000011\n0111111111\n", "output": ["77\n"]}, {"input": "9 9\n0000110011\n1001111000\n1001000000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["80\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001111000\n0001000000\n0101001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["142\n"]}, {"input": "5 4\n10001\n00000\n00000\n00001\n10101\n10110\n", "output": ["42\n"]}, {"input": "0 4\n11110\n01000\n01000\n00001\n00110\n00010\n", "output": ["1\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["131\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1100111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111100\n", "output": ["117\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n1001110000\n1000000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["118\n"]}, {"input": "9 9\n0000110000\n0001001100\n0001000000\n0001110100\n0101000100\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["125\n"]}, {"input": "9 9\n0000110011\n0101001000\n1001001001\n0001111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0110111110\n", "output": ["82\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111101\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["110\n"]}, {"input": "2 9\n0000010000\n0001001100\n0001000000\n0001110000\n1101000000\n0001101000\n0110001110\n1000000000\n1001001001\n0011111110\n", "output": ["75\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001111000\n0001000000\n0101001000\n0110001110\n1000000001\n1001001001\n0111111110\n", "output": ["140\n"]}, {"input": "9 9\n0000010010\n0001000001\n0001001100\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["132\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001100\n1101111101\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["105\n"]}, {"input": "9 9\n1100010000\n1001001000\n0101001100\n1101111000\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111010\n", "output": ["102\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001011000\n0001000000\n0101001000\n0110001110\n1000000001\n1001001001\n0111111110\n", "output": ["141\n"]}, {"input": "7 9\n0000110000\n0001000000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000111\n0000000001\n1001001011\n0111111110\n", "output": ["189\n"]}, {"input": "2 9\n0000110000\n0000001100\n0011000000\n1001110010\n1101000000\n0001001000\n0110000110\n1000000011\n1001000001\n0011111110\n", "output": ["60\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001100\n0110000111\n0010010001\n1001000011\n0111111111\n", "output": ["72\n"]}, {"input": "9 9\n0000110000\n0001011001\n0101000000\n0001011000\n0101010010\n0101001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["83\n"]}, {"input": "5 4\n10000\n00001\n00000\n00001\n01110\n00111\n", "output": ["41\n"]}, {"input": "9 9\n0000010010\n0001000001\n0001001100\n0001111000\n0001011000\n0001001000\n0110000110\n1000010001\n1101101011\n0111111110\n", "output": ["130\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001000100\n0001111010\n0001001000\n0001001000\n0011000110\n1100000000\n1001000001\n1111111110\n", "output": ["155\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001100\n1101111101\n0001000000\n0001001000\n0100100110\n1000100011\n1001001001\n0110101110\n", "output": ["104\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001100\n0110000111\n1010010001\n1001000011\n0111111111\n", "output": ["71\n"]}, {"input": "7 9\n0000100000\n0001000000\n0001000000\n0001111000\n1001000000\n0001001001\n0110000111\n0000000001\n1001001011\n0111111110\n", "output": ["195\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001000100\n0011111010\n0001001000\n0001001000\n0011000110\n1100000000\n1001000001\n1111111110\n", "output": ["134\n"]}, {"input": "5 4\n00010\n00100\n00000\n01001\n10100\n00110\n", "output": ["33\n"]}, {"input": "5 4\n00000\n00101\n00000\n01001\n10100\n00110\n", "output": ["33\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10100\n00110\n", "output": ["25\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10100\n00111\n", "output": ["24\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["183\n"]}, {"input": "5 4\n10010\n00000\n01000\n00011\n00100\n00110\n", "output": ["31\n"]}, {"input": "5 4\n11010\n00000\n01000\n00001\n10100\n00110\n", "output": ["24\n"]}, {"input": "5 4\n11010\n00100\n00000\n01001\n10100\n00110\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00101\n00100\n01000\n10110\n00111\n", "output": ["23\n"]}, {"input": "5 4\n01000\n10101\n00100\n01101\n10110\n00111\n", "output": ["17\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n00110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01100\n10101\n00100\n01000\n10110\n01111\n", "output": ["17\n"]}, {"input": "4 4\n01100\n10101\n00100\n01001\n00110\n01111\n", "output": ["16\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["181\n"]}, {"input": "5 4\n10010\n00100\n01000\n00011\n00100\n00110\n", "output": ["29\n"]}, {"input": "5 4\n11010\n00000\n01000\n00001\n10100\n00111\n", "output": ["23\n"]}, {"input": "5 4\n10011\n00001\n00000\n00001\n10100\n00110\n", "output": ["35\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n00010\n00101\n00000\n01011\n10100\n01110\n", "output": ["28\n"]}, {"input": "5 4\n01000\n00101\n00000\n00001\n10100\n00110\n", "output": ["30\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n11111\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01000\n00101\n00100\n01010\n10110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01100\n10101\n00100\n01000\n10111\n01111\n", "output": ["15\n"]}, {"input": "4 4\n01100\n10101\n00100\n01001\n00100\n01111\n", "output": ["17\n"]}, {"input": "5 4\n10010\n10100\n01000\n00011\n00100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n01000\n00101\n00100\n00001\n10100\n00110\n", "output": ["27\n"]}, {"input": "5 4\n01000\n00101\n10000\n01001\n11111\n00111\n", "output": ["18\n"]}, {"input": "5 4\n01000\n00101\n00100\n01011\n10110\n00111\n", "output": ["20\n"]}, {"input": "4 4\n01100\n10101\n00100\n01101\n00100\n01111\n", "output": ["16\n"]}, {"input": "5 4\n10010\n10100\n01001\n00011\n00100\n00110\n", "output": ["26\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["148\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n01111\n", "output": ["26\n"]}, {"input": "5 4\n00000\n00101\n00100\n00001\n10101\n00010\n", "output": ["36\n"]}, {"input": "5 4\n01000\n00101\n00100\n00001\n10100\n00100\n", "output": ["31\n"]}, {"input": "5 4\n01000\n00101\n10000\n01101\n11111\n00111\n", "output": ["17\n"]}, {"input": "5 4\n01000\n00101\n00100\n00011\n10110\n00111\n", "output": ["24\n"]}, {"input": "4 4\n01100\n11101\n00100\n01101\n00100\n01111\n", "output": ["15\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["158\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n00110\n", "output": ["20\n"]}, {"input": "5 4\n11010\n00100\n00000\n00011\n10100\n01111\n", "output": ["24\n"]}, {"input": "5 4\n00000\n00101\n00100\n00001\n10101\n00011\n", "output": ["35\n"]}, {"input": "3 4\n01000\n00101\n00100\n00001\n10100\n00100\n", "output": ["25\n"]}, {"input": "5 4\n01000\n00101\n10100\n01101\n11111\n00111\n", "output": ["15\n"]}, {"input": "9 9\n0100100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["129\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n00111\n", "output": ["20\n"]}, {"input": "2 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001001\n0011111110\n", "output": ["101\n"]}, {"input": "5 4\n11010\n00110\n00000\n00011\n10100\n01111\n", "output": ["22\n"]}, {"input": "5 4\n00000\n00101\n00100\n10001\n10101\n00011\n", "output": ["30\n"]}, {"input": "3 4\n01001\n00101\n00100\n00001\n10100\n00100\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00100\n10100\n01101\n11111\n00111\n", "output": ["23\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n10111\n", "output": ["20\n"]}, {"input": "9 9\n0100010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["109\n"]}, {"input": "5 4\n11000\n00110\n00000\n00011\n10100\n01111\n", "output": ["24\n"]}, {"input": "5 4\n00000\n00111\n00100\n10001\n10101\n00011\n", "output": ["28\n"]}, {"input": "3 4\n01001\n00101\n00100\n00001\n10100\n10100\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00100\n10100\n01101\n01111\n00111\n", "output": ["25\n"]}, {"input": "3 4\n01100\n11111\n00100\n01101\n10100\n01111\n", "output": ["9\n"]}, {"input": "4 4\n10010\n10100\n01001\n00010\n00100\n10111\n", "output": ["22\n"]}, {"input": "9 9\n1100010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["107\n"]}, {"input": "2 9\n0000110000\n0001001100\n0001000000\n0001110000\n1101000000\n0001001000\n0110001110\n1000000001\n1001001001\n0011111110\n", "output": ["74\n"]}], "task_id": "codecontest/12", "prompt": "Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}. Consider edge cases where there are no telephone poles on the plane.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "repair_prompt": ["Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}. Consider edge cases where there are no telephone poles on the plane.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nWrite a main() function and use input() function to read input from stdin", " Mr. Chanek's city is represented as a plane, which is a grid of size (n + 1) \u00d7 (m + 1). In this grid, there are telephone poles indicated by 1s in the grid. For each point (x, y) in the grid, the value S(x, y) is defined as the square of the Euclidean distance to the nearest telephone pole. The Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is calculated as (x_2 - x_1)^2 + (y_2 -\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nWrite a main() function and use input() function to read input from stdin", " Mr. Chanek's city is represented as a plane with a grid of size (n + 1) \u00d7 (m + 1). There are telephone poles at points where a_{x, y} = 1. Define S(x, y) as the square of the Euclidean distance to the nearest pole. The project supervisor needs the sum of all S(x, y) for 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help by calculating \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nimport numpy as np\nfrom scipy.ndimage import distance_transform_edt\n\ndef calculate_sum_of_distances(grid: np.ndarray) -> int:\n    if not np.any(grid):\n        return 0\n    \n    # Create a binary mask where telephone poles are 1 and others are 0\n    telephone_poles = (grid == 1)\n    \n    # Compute the distance transform of the binary mask\n    distances = distance_transform_edt(telephone_poles)\n    \n    # Square the distances to get S(x, y)\n    squared_distances = np.square(distances)\n    \n    # Sum all S(x, y) values in the grid\n    sum_of_distances = np.sum(squared_distances)\n    \n    return int(sum_of_distances)\n\n# Read input\nn, m = map(int, input().split())\ngrid = np.zeros((n + 1, m + 1), dtype=int)\nfor i in range(n + 1):\n    grid[i] = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = calculate_sum_of_distances(grid)\nprint(result)\n", "from typing import List\nfrom typing import List\nimport sys\n\ndef calculate_sum_of_distances(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    \n    # Initialize the distances array with a large number\n    distances = [[sys.maxsize] * (m + 1) for _ in range(n + 1)]\n    \n    # Precompute the minimum distance to the nearest pole for each point\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                distances[i][j] = 0\n            elif i > 0:\n                distances[i][j] = min(distances[i][j], distances[i - 1][j] + 1)\n            if j > 0:\n                distances[i][j] = min(distances[i][j], distances[i][j - 1] + 1)\n    \n    # Update distances from the bottom and right\n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n            if i < n:\n                distances[i][j] = min(distances[i][j], distances[i + 1][j] + 1)\n            if j < m:\n                distances[i][j] = min(distances[i][j], distances[i][j + 1] + 1)\n    \n    # Calculate the sum of the squares of the Euclidean distances\n    sum_of_distances = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            sum_of_distances += distances[i][j] ** 2\n    \n    return sum_of_distances\n\n# Read input\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n + 1)]\n\n# Calculate and print the result\nresult = calculate_sum_of_distances(grid)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef calculate_sum_of_distances(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    \n    if all(0 in row for row in grid):\n        return 0\n    \n    # Precompute the nearest pole distances\n    nearest_pole_dist = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                nearest_pole_dist[i][j] = 0\n            elif i > 0:\n                nearest_pole_dist[i][j] = min(nearest_pole_dist[i][j], nearest_pole_dist[i - 1][j] + 1)\n            if j > 0:\n                nearest_pole_dist[i][j] = min(nearest_pole_dist[i][j], nearest_pole_dist[i][j - 1] + 1)\n    \n    for i in range(n, -1, -1):\n        for j in range(m, -1, -1):\n            if i < n:\n                nearest_pole_dist[i][j] = min(nearest_pole_dist[i][j], nearest_pole_dist[i + 1][j] + 1)\n            if j < m:\n                nearest_pole_dist[i][j] = min(nearest_pole_dist[i][j], nearest_pole_dist[i][j + 1] + 1)\n    \n    # Calculate the sum of squares of Euclidean distances\n    total_sum = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            total_sum += nearest_pole_dist[i][j] ** 2\n    \n    return total_sum\n\n# Interface\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n + 1)]\nresult = calculate_sum_of_distances(grid)\nprint(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\nfrom scipy.spatial import KDTree\n\ndef calculate_distance(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the Euclidean distance between two points (x1, y1) and (x2, y2).\n    \n    Args:\n        x1 (int): The x-coordinate of the first point.\n        y1 (int): The y-coordinate of the first point.\n        x2 (int): The x-coordinate of the second point.\n        y2 (int): The y-coordinate of the second point.\n    \n    Returns:\n        float: The Euclidean distance between the two points.\n    \"\"\"\n    return np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef find_nearest_pole(grid, n, m):\n    \"\"\"\n    Find the nearest telephone pole for each point in the grid using a KDTree for efficient search.\n    \n    Args:\n        grid (list of list of int): The grid representing the city with telephone poles.\n        n (int): The number of rows in the grid.\n        m (int): The number of columns in the grid.\n    \n    Returns:\n        list of tuple: A list of tuples where each tuple contains the coordinates of a point and its nearest telephone pole's coordinates.\n    \"\"\"\n    poles = []\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                poles.append((i, j))\n    \n    tree = KDTree(poles)\n    nearest_poles = []\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 0:\n                dist, idx = tree.query((i, j))\n                nearest_pole = poles[idx]\n                nearest_poles.append(((i, j), nearest_pole))\n    return nearest_poles\n\ndef compute_sum_of_squares(grid, n, m):\n    \"\"\"\n    Compute the sum of squares of the distances from each point in the grid to the nearest telephone pole using a KDTree for efficient search.\n    \n    Args:\n        grid (list of list of int): The grid representing the city with telephone poles.\n        n (int): The number of rows in the grid.\n        m (int): The number of columns in the grid.\n    \n    Returns:\n        int: The sum of squares of the distances from each point in the grid to the nearest telephone pole.\n    \"\"\"\n    nearest_poles = find_nearest_pole(grid, n, m)\n    sum_of_squares = 0\n    for point, nearest_pole in nearest_poles:\n        distance_squared = calculate_distance(point[0], point[1], nearest_pole[0], nearest_pole[1]) ** 2\n        sum_of_squares += distance_squared\n    return sum_of_squares\n\n# Read input\nn, m = map(int, input().split())\ngrid = []\nfor _ in range(n + 1):\n    row = list(map(int, input().split()))\n    grid.append(row)\n\n# Compute and output the result\nresult = compute_sum_of_squares(grid, n, m)\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import deque\n\ndef calculate_distance_sum(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    \n    # Directions for BFS (right, down, left, up)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Initialize the BFS queue with all telephone poles\n    queue = deque()\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                queue.append((i, j))\n    \n    # Initialize the distance grid with a large number\n    distance_grid = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Perform BFS to find the nearest telephone pole for each point\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx <= n and 0 <= ny <= m and grid[nx][ny] == 0 and distance_grid[nx][ny] > distance_grid[x][y] + 1:\n                distance_grid[nx][ny] = distance_grid[x][y] + 1\n                queue.append((nx, ny))\n    \n    # Compute the sum of squares of distances for each point in the grid\n    sum_of_squares = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 0:\n                sum_of_squares += distance_grid[i][j] ** 2\n    \n    return sum_of_squares\n\n# Provide input interface\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n + 1)]\n\n# Provide output interface\nresult = calculate_distance_sum(grid)\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import deque\n\ndef calculate_distance_sum(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    \n    # Initialize the distance grid with a large number\n    distance_grid = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Queue for BFS\n    queue = deque()\n    \n    # Collect all the telephone poles\n    telephone_poles = []\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                distance_grid[i][j] = 0\n                queue.append((i, j))\n                telephone_poles.append((i, j))\n    \n    # Directions for BFS\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # BFS to find the nearest telephone pole\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx <= n and 0 <= ny <= m and distance_grid[nx][ny] > distance_grid[x][y] + 1:\n                distance_grid[nx][ny] = distance_grid[x][y] + 1\n                queue.append((nx, ny))\n    \n    # Calculate the sum of squares of distances\n    sum_of_squares = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            sum_of_squares += distance_grid[i][j] ** 2\n    \n    return sum_of_squares\n\n# Read input\nn = int(input())\nm = int(input())\ngrid = []\nfor _ in range(n + 1):\n    row = list(map(int, input().split()))\n    grid.append(row)\n\n# Calculate and print the result\nresult = calculate_distance_sum(grid)\nprint(result)\n", "from typing import List\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_distances(n: int, m: int, grid: List[List[int]]) -> int:\n    # Directions for BFS (right, down, left, up)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Initialize the distance grid with -1 (unvisited)\n    distance_grid = [[-1] * (m + 1) for _ in range(n + 1)]\n    \n    # Queue for BFS, starting with all pole positions\n    queue = deque()\n    \n    # Preprocess poles and initialize BFS queue\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                queue.append((i, j))\n                distance_grid[i][j] = 0\n    \n    # BFS to calculate distances\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx <= n and 0 <= ny <= m and distance_grid[nx][ny] == -1:\n                distance_grid[nx][ny] = distance_grid[x][y] + 1\n                queue.append((nx, ny))\n    \n    # Calculate the sum of squared distances\n    sum_of_distances = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 0:\n                sum_of_distances += distance_grid[i][j] ** 2\n    \n    return sum_of_distances\n\n# Read input\nn, m = map(int, input().split())\ngrid = [list(map(int, input().strip())) for _ in range(n + 1)]\n\n# Calculate and print the result\nresult = calculate_sum_of_distances(n, m, grid)\nprint(result)\n", "from typing import List\n## main.py\n\nimport sys\nfrom typing import List\n\ndef calculate_sum_of_squares(n: int, m: int, grid: List[List[int]]) -> int:\n    sum_of_squares = 0\n    \n    for x in range(n + 1):\n        for y in range(m + 1):\n            min_distance_squared = float('inf')\n            for i in range(n + 1):\n                for j in range(m + 1):\n                    if grid[i][j] == 1:\n                        distance_squared = (x - i) ** 2 + (y - j) ** 2\n                        if distance_squared < min_distance_squared:\n                            min_distance_squared = distance_squared\n            sum_of_squares += min_distance_squared\n    \n    return sum_of_squares\n\n# Read input from stdin\nn, m = map(int, sys.stdin.readline().split())\ngrid = [list(map(int, list(sys.stdin.readline().strip()))) for _ in range(n + 1)]\n\n# Calculate and print the result\nresult = calculate_sum_of_squares(n, m, grid)\nprint(result)\n", "from typing import List\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_squares(grid: List[List[int]]) -> int:\n    n = len(grid) - 1\n    m = len(grid[0]) - 1\n    \n    # Directions for BFS (right, down, left, up)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Initialize distances grid with large values\n    distances = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Queue for BFS, starting with all pole positions\n    queue = deque()\n    \n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                distances[i][j] = 0\n                queue.append((i, j))\n    \n    # BFS to calculate distances\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx <= n and 0 <= ny <= m and distances[nx][ny] > distances[x][y] + 1:\n                distances[nx][ny] = distances[x][y] + 1\n                queue.append((nx, ny))\n    \n    # Calculate the sum of squares of distances\n    sum_of_squares = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            sum_of_squares += distances[i][j] ** 2\n    \n    return sum_of_squares\n\n# Read input\nn, m = map(int, input().split())\ngrid = [list(map(int, list(input()))) for _ in range(n + 1)]\n\n# Calculate and print the result\nresult = calculate_sum_of_squares(grid)\nprint(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef calculate_distance(x, y, poles):\n    min_distance_squared = float('inf')\n    for pole in poles:\n        distance_squared = (pole[0] - x) ** 2 + (pole[1] - y) ** 2\n        if distance_squared < min_distance_squared:\n            min_distance_squared = distance_squared\n    return min_distance_squared\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    poles = []\n    for _ in range(n + 1):\n        row = list(map(int, sys.stdin.readline().split()))\n        for j in range(m + 1):\n            if row[j] == 1:\n                poles.append((_, j))\n    \n    total_sum = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            S_xy = calculate_distance(x, y, poles)\n            total_sum += S_xy\n    \n    return total_sum\n\n# Read input from stdin\nn, m = map(int, sys.stdin.readline().split())\npoles = []\nfor _ in range(n + 1):\n    row = list(map(int, sys.stdin.readline().split()))\n    for j in range(m + 1):\n        if row[j] == 1:\n            poles.append((_, j))\n\nresult = main()\nprint(result)\n"], "plans": ["requirement analysis:\nThe primary requirement is to calculate the sum of squares of Euclidean distances from each point in the grid to the nearest telephone pole. This involves identifying the nearest pole for each point and computing the distance, then summing these distances. The solution must handle edge cases, such as when there are no telephone poles, and ensure efficiency for large grids.\nrequirement pool:\n- Implement a function to calculate the distance from each point to the nearest telephone pole.\n- Develop a method to efficiently compute the sum of these distances over the entire grid.\n- Ensure the solution can handle edge cases where there are no telephone poles.\n- Optimize the algorithm for large grids to ensure performance.\n- Design a user-friendly interface for input and output.\nTo solve this problem, we will use Python due to its efficiency and ease of handling mathematical operations. We will leverage the NumPy library to handle the grid efficiently. The approach involves iterating through each point in the grid, finding the nearest telephone pole, and calculating the square of the Euclidean distance. We will optimize the solution by using a distance transform method from the SciPy library, which is specifically designed for such tasks.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem, where the distance is the square root of the sum of the squares of the differences in the coordinates.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the input to get the size of the grid and the positions of the telephone poles.\n    2. Initialize a variable to store the sum of all S(x, y).\n    3. Iterate through each point (x, y) in the grid.\n    4. For each point, find the nearest telephone pole using the Euclidean distance formula.\n    5. Calculate the square of the Euclidean distance and add it to the sum.\n    6. Return the final sum.\n\n# [edge case] \n    edge_case1 = 0\n    Explanation: If the grid is empty or has no telephone poles, the sum of all S(x, y) will be 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where there are no telephone poles.\n        if not any(pole for row in grid for pole in row):\n            return 0\n        (other code)\n\nPlease note that the code logic and edge case handling will depend on the specific implementation details and the libraries used. The provided plan and edge case are based on the assumption that the grid will be provided as input and that the nearest pole will be found by iterating through all poles.\n", "requirement analysis:\nThe problem requires calculating the sum of the squares of the Euclidean distances from each point in the grid to the nearest telephone pole. This involves finding the nearest pole for each point, which can be efficiently done using a precomputation approach to avoid recalculating distances for each point.\nrequirement pool:\n- Implement a function to calculate the distance to the nearest pole for each point.\n- Optimize the calculation to handle large grids efficiently.\n- Ensure the code handles edge cases, such as no poles in the grid.\n- Provide clear and concise output as specified.\n- Test the solution with various inputs to ensure accuracy and robustness.\nTo solve this problem efficiently, we will use a precomputation approach to find the nearest telephone pole for each point in the grid. This will involve creating a 2D array to store the minimum distance to the nearest pole for each point. We will then iterate over each point in the grid to calculate the sum of the squares of the Euclidean distances to the nearest pole.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem, where the distance is the square root of the sum of the squares of the differences in the coordinates.\n\n# [phrase showing quantity relationship]\n    'square of the Euclidean distance': This refers to the squared distance between two points, calculated as (x2 - x1)^2 + (y2 - y1)^2.\n\n# [degree adverb] \n    'nearest': Indicates the closest telephone pole to a given point.\n\n# [code logic]\n    To solve this problem, we can use a precomputation approach to find the nearest telephone pole for each point in the grid. This involves creating a 2D array to store the minimum distance to the nearest pole for each point. We will then iterate over each point in the grid to calculate the sum of the squares of the Euclidean distances to the nearest pole.\n\n# [edge case] \n    Input: 1 1\n          1\n          0\n    Output: 1\n    Explanation: There is only one telephone pole at (0, 0) and no other poles. The nearest pole to (0, 0) and (1, 0) is at (0, 0), and the nearest pole to (0, 1) and (1, 1) is also at (0, 0). Thus, the sum of all S(x, y) is 1 + 1 + 1 + 1 = 4.\n\n# [extra code for edge case]\n    We do not need extra code to handle this edge case as the logic provided can handle a single pole scenario correctly.\n", "requirement analysis:\nThe problem requires calculating the sum of the squares of the Euclidean distances from each point in the grid to the nearest telephone pole. This involves finding the nearest pole for each point, which can be efficiently done using a precomputation approach to avoid recalculating distances for each point.\nrequirement pool:\n- Implement a function to calculate the distance to the nearest pole for each point.\n- Optimize the calculation to handle large grids efficiently.\n- Ensure the code handles edge cases where there are no telephone poles.\n- Provide clear and concise documentation for the code.\n- Test the code with various inputs to ensure accuracy and robustness.\nTo solve this problem efficiently, we will use a precomputation approach to find the nearest telephone pole for each point in the grid. This will involve creating a 2D array to store the minimum distance to the nearest pole for each point. We will then iterate over each point in the grid to calculate the sum of the squares of the Euclidean distances to the nearest pole.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem, where the distance is the square root of the sum of the squares of the differences in the coordinates.\n\n# [phrase showing quantity relationship]\n    'square of the Euclidean distance': This refers to the squared distance between two points, calculated as (x2 - x1)^2 + (y2 - y1)^2.\n\n# [degree adverb] \n    'nearest': Indicates the closest telephone pole to a given point.\n\n# [code logic]\n    To solve this problem, we can use a precomputation approach to find the nearest telephone pole for each point in the grid. This involves creating a 2D array to store the minimum distance to the nearest pole for each point. We will then iterate over each point in the grid to calculate the sum of the squares of the Euclidean distances to the nearest pole.\n\n# [edge case] \n    Input: 1 1\n          1\n          0\n    Output: 1\n    Explanation: There is only one telephone pole at (0, 0) and no poles at (1, 0), (0, 1), or (1, 1). The nearest pole to all points is at (0, 0), so the sum of distances is 1 for each point, totaling 4.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where there are no telephone poles on the plane. In this case, we should return 0 immediately since there are no poles to calculate distances from.\n\n    def main():\n        n, m = map(int, input().split())\n        grid = [list(map(int, input().split())) for _ in range(n + 1)]\n        \n        if all(0 in row for row in grid):\n            print(0)\n            return\n        \n        # Precompute the nearest pole distances\n        nearest_pole_dist = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            for j in range(m + 1):\n                if grid[i][j] == 1:\n                    nearest_pole_dist[i][j] = 0\n                elif i > 0:\n                    nearest_pole_dist[i][j] = min(nearest_pole_dist[i][j], nearest_pole_dist[i - 1][j] + 1)\n                if j > 0:\n                    nearest_pole_dist[i][j] = min(nearest_pole_dist[i][j], nearest_pole_dist[i][j - 1] + 1)\n        \n        for i in range(n, -1, -1):\n            for j in range(m, -1, -1):\n                if i < n:\n                    nearest_pole_dist[i][j] = min(nearest_pole_dist[i][j], nearest_pole_dist[i + 1][j] + 1)\n                if j < m:\n                    nearest_pole_dist[i][j] = min(nearest_pole_dist[i][j], nearest_pole_dist[i][j + 1] + 1)\n        \n        # Calculate the sum of squares of Euclidean distances\n        total_sum = 0\n        for i in range(n + 1):\n            for j in range(m + 1):\n                total_sum += nearest_pole_dist[i][j] ** 2\n        \n        print(total_sum)\n", "requirement analysis:\nThe requirements specify the need for a program to calculate the sum of squares of distances to the nearest telephone pole in a grid. The grid size can be up to 2000x2000, and the input grid contains 0s and 1s where 1 indicates the presence of a telephone pole. The output is the sum of S(x, y) for all points in the grid.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance between two points.\n- Create a function to find the nearest telephone pole for each point in the grid.\n- Develop a function to compute the sum of squares of distances to the nearest telephone pole.\n- Ensure the program can handle large grids efficiently.\n- Design a user-friendly interface for input and output.\nTo implement the solution, we will use Python due to its simplicity and efficiency. We will leverage the numpy library for handling arrays and mathematical operations efficiently. The approach involves creating a function to calculate the Euclidean distance between two points, finding the nearest telephone pole for each point in the grid, and then computing the sum of squares of these distances.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated as the square root of the sum of the squares of the differences in their coordinates.\n    'sum of squares': The sum of the squares of the distances from each point in the grid to the nearest telephone pole.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that we need to find the nearest telephone pole for each point in the grid.\n    'square of the Euclidean distance': Indicates that we need to calculate the square of the distance from each point to the nearest telephone pole.\n\n# [degree adverb] \n    'nearest': Indicates that we need to find the closest telephone pole for each point in the grid.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Read the input to get the size of the grid and the grid itself.\n    2. Initialize a variable to store the sum of squares of distances.\n    3. Iterate over each point in the grid.\n    4. For each point, find the nearest telephone pole using the Euclidean distance formula.\n    5. Calculate the square of the Euclidean distance and add it to the sum.\n    6. Return the final sum after iterating through all points.\n\n# [edge case] \n    Edge case 1: Small grid with one telephone pole\n    Input: 1 1, 1, 0\n    Output: 1\n    Explanation: There is only one point in the grid, and the nearest telephone pole is at the same point. The distance is 0, and its square is 0.\n\n    Edge case 2: Large grid with multiple telephone poles\n    Input: 1000 1000, 1s and 0s representing telephone poles\n    Output: Sum of squares of distances for all points in the grid\n    Explanation: This edge case checks the performance of the algorithm with a large grid. The expected output is the sum of squares of distances for all points in the grid.\n\n    Edge case 3: Grid with telephone poles at the corners\n    Input: 2 2, 100, 000, 000, 000, 1\n    Output: 18\n    Explanation: The nearest telephone pole for each point in the grid is at the corner. The distances are calculated accordingly, and the sum of squares is 18.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic can handle the edge cases by considering the smallest and largest possible grids and different distributions of telephone poles.\n", "requirement analysis:\nThe problem requires calculating the sum of squares of distances to the nearest telephone pole for each point in a grid. The grid size can be up to 2000x2000, and there must be at least one telephone pole in the grid. The solution should be efficient and handle large grids without performance issues.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance between two points.\n- Create a function to find the nearest telephone pole for each point in the grid.\n- Develop a function to compute the sum of squares of distances to the nearest telephone pole.\n- Optimize the solution for large grids by using efficient algorithms.\n- Ensure the output is accurate and matches the given examples.\nTo solve this problem, we will use a combination of Breadth-First Search (BFS) and a distance transform approach. BFS will be used to find the nearest telephone pole for each point, and the distance transform will compute the sum of squares of distances. We will optimize the solution by leveraging the properties of BFS to handle large grids efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated as the square root of the sum of the squares of the differences in their coordinates.\n    'Square of Euclidean distance': The distance squared between two points, calculated as (x_2 - x_1)^2 + (y_2 - y_1)^2.\n    'Breadth-First Search (BFS)': A graph traversal algorithm that explores all the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.\n    'Distance transform': A technique used in image processing to find the distance from each pixel to the nearest zero pixel.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the grid size and the grid itself from the input.\n    2. Initialize a BFS queue with all the positions of the telephone poles.\n    3. Perform BFS to find the nearest telephone pole for each point in the grid.\n    4. Compute the sum of squares of distances for each point in the grid.\n    5. Sum up the values of S(x, y) for all points in the grid.\n\n# [edge case] \n    Edge case 1: Small grid with one telephone pole\n    Input: \n    1 1\n    1\n    1\n    Output: \n    0\n    Explanation: Since there's only one point and it's a telephone pole, the distance to itself is 0.\n\n    Edge case 2: Large grid with multiple telephone poles\n    Input: \n    1000 1000\n    1s (1000 * 1000 times)\n    Output: \n    A large number, since the grid is large and the telephone poles are densely packed.\n    Explanation: The distance transform will compute the distance from each point to the nearest telephone pole, and the sum of these distances will be a large number.\n\n    Edge case 3: Grid with no empty spaces\n    Input: \n    2 2\n    1111\n    1111\n    1111\n    Output: \n    0\n    Explanation: Since there are no empty spaces, every point is a telephone pole, and the distance to itself is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided BFS approach will work for all cases, including the edge cases mentioned.\n", "requirement analysis:\nThe primary requirement is to calculate the sum of squares of distances to the nearest telephone pole in a grid. This involves understanding the grid, identifying the positions of telephone poles, and computing the Euclidean distance for each point in the grid. The solution should be optimized for large grids up to 2000x2000, ensuring efficiency and accuracy.\nrequirement pool:\n- Implement a function to calculate the Euclidean distance between two points in the grid.\n- Develop a method to find the nearest telephone pole for each point in the grid.\n- Create a function to compute the sum of squares of distances to the nearest telephone pole.\n- Optimize the algorithm for large grids up to 2000x2000.\n- Ensure the user interface is simple and intuitive for easy input and output.\nTo solve this problem, we will use a combination of Breadth-First Search (BFS) and a distance transform approach. BFS will be used to find the nearest telephone pole for each point in the grid, and the distance transform will compute the square of the Euclidean distance. This approach ensures efficiency even for large grids up to 2000x2000.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated as the square root of the sum of the squares of the differences in their coordinates.\n    'Square of Euclidean distance': The distance squared between two points, calculated as (x_2 - x_1)^2 + (y_2 - y_1)^2.\n    'Breadth-First Search (BFS)': A graph traversal algorithm that explores all the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.\n    'Distance transform': A technique used in image processing to find the distance from each pixel to the nearest zero pixel.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the grid size and the grid itself from the input.\n    2. Initialize a distance grid to store the minimum distance to the nearest telephone pole for each point.\n    3. Use BFS to find the nearest telephone pole for each point in the grid.\n    4. Compute the square of the Euclidean distance for each point and sum them up.\n    5. Output the sum.\n\n# [edge case] \n    Edge case 1: Small grid with one telephone pole\n    Input:\n    1 1\n    1\n    1\n    Expected output: 0\n    Explanation: Since there's only one point and it's a telephone pole, the distance to itself is 0.\n\n    Edge case 2: Large grid with multiple telephone poles\n    Input:\n    1000 1000\n    1s (1000 * 1000 times)\n    Expected output: 0\n    Explanation: Since all points are telephone poles, the distance to the nearest pole is 0 for all points.\n\n    Edge case 3: Grid with telephone poles at the corners\n    Input:\n    2 2\n    100\n    000\n    000\n    Expected output: 18\n    Explanation: The nearest telephone pole for each point is at (0, 0), and the sum of the squares of the distances is (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic will correctly compute the sum for all edge cases.\n", "requirement analysis:\nThe primary requirement is to calculate the sum of the squares of the Euclidean distances to the nearest pole for all points in the grid. The grid size can be up to 2000x2000, and there must be at least one pole in the grid. The solution should be efficient and handle large grids without performance issues.\nrequirement pool:\n- Implement a function to calculate the distance to the nearest pole for each point in the grid\n- Optimize the algorithm to handle large grids efficiently\n- Ensure the output is accurate and matches the expected result\n- Add error handling for invalid inputs\n- Include comments and documentation for easier understanding and maintenance\nTo solve this problem efficiently, we will use a Breadth-First Search (BFS) approach to find the nearest pole for each point in the grid. BFS is suitable for this problem because it explores all points level by level, ensuring that we find the shortest path to a pole. We will preprocess the grid to identify the positions of all poles and then use BFS to calculate the distance to the nearest pole for each point. The sum of these distances will be our final result.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane is the length of the line segment connecting them. The Euclidean distance between two points (x1, y1) and (x2, y2) is given by the formula: \u221a((x2 - x1)^2 + (y2 - y1)^2).\n\n    'sum of distances': The sum of all distances from each point in the grid to the nearest pole.\n\n# [phrase showing quantity relationship]\n    'square of the Euclidean distance': The distance between two points in a plane is squared.\n\n# [degree adverb] \n    'nearest': The closest pole to a given point in the grid.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the input to get the size of the grid and the positions of the telephone poles.\n    2. Create a grid to store the distances to the nearest pole for each point.\n    3. Use BFS to calculate the distance from each point to the nearest pole.\n    4. Sum up all the distances to get the final result.\n\n# [edge case] \n    Input:\n    1 1\n    1\n    1\n\n    Output:\n    2\n\n    Explanation:\n    There is only one pole at (0, 0) and one point at (1, 1). The distance to the nearest pole is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle this edge case as it is a simple scenario with only one pole and one point. The BFS will naturally handle this case without additional processing.\n", "requirement analysis:\nThe problem requires calculating the sum of squares of distances to the nearest pole for each point in a grid. This involves checking each point's distance to all poles and summing these distances. The solution should be efficient enough to handle large grids up to 2000x2000.\nrequirement pool:\n- Implement a function to read input grid\n- Calculate the distance to the nearest pole for each point\n- Sum the squares of these distances\n- Optimize the distance calculation for efficiency\n- Add user input validation\nTo solve this problem efficiently, we will use a Python script that reads the grid size and pole positions from standard input, calculates the sum of squares of distances to the nearest pole for each point in the grid, and outputs the result to standard output. We will employ a brute-force approach to find the nearest pole for each point, which is acceptable given the constraint of the grid size being less than 2000.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane is the length of the line segment connecting them. The Euclidean distance between two points (x1, y1) and (x2, y2) is given by the formula: sqrt((x2 - x1)^2 + (y2 - y1)^2).\n\n    'Square of the Euclidean distance': The square of the Euclidean distance is the distance squared. For two points (x1, y1) and (x2, y2), the square of the Euclidean distance is (x2 - x1)^2 + (y2 - y1)^2.\n\n    'Sum of squares of distances': The sum of all S(x, y) for 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m is the sum of the squares of the distances from each point in the grid to the nearest telephone pole.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the grid size and pole positions from standard input.\n    2. Initialize a variable to store the sum of squares of distances.\n    3. Iterate over each point in the grid.\n    4. For each point, find the nearest pole by calculating the Euclidean distance to all poles and keeping the minimum.\n    5. Square the minimum distance and add it to the sum.\n    6. After iterating through all points, output the sum.\n\n# [edge case] \n    Edge case 1: Small grid with one pole\n    Input:\n    1 1\n    1\n    1\n    Expected Output: 1\n    Explanation: There is only one point in the grid, and it is a pole. The distance to the pole is 0, and its square is 0.\n\n    Edge case 2: Large grid with multiple poles\n    Input:\n    1000 1000\n    (1000 lines of 1000 zeros followed by a single 1)\n    Expected Output: A large number, as the nearest pole to any point in the grid will be at the edge.\n    Explanation: The grid is large, and the nearest pole to any point will be at the edge, resulting in large distances and squares.\n\n    Edge case 3: Grid with poles only at the corners\n    Input:\n    2 2\n    1000\n    000\n    000\n    Expected Output: 18\n    Explanation: The nearest pole to any point will be at one of the corners, resulting in distances of 1, 2, 1, 2, etc.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The brute-force approach will work efficiently for the given constraints.\n", "requirement analysis:\nThe problem requires a solution that can handle a grid of up to 2000x2000, which means a brute force approach would be inefficient. The solution should be optimized to handle large grids efficiently. The input is a grid with telephone poles marked by 1s, and the output is the sum of the squares of the Euclidean distances from each point in the grid to the nearest pole. The solution should be able to read the input from standard input and output the result to standard output.\nrequirement pool:\n- Implement an efficient algorithm to calculate the distance to the nearest pole for each point in the grid.\n- Ensure the solution can handle grids up to 2000x2000.\n- Provide clear and concise output for the given problem.\n- Optimize the algorithm for performance on large grids.\n- Add support for reading input from standard input and outputting results to standard output.\nTo solve this problem efficiently, we will use a Breadth-First Search (BFS) approach to calculate the distance to the nearest pole for each point in the grid. BFS is suitable for this problem because it explores all points level by level, ensuring that we find the shortest path to a pole for each point. Given the constraints of the grid size (up to 2000x2000), we need to ensure our solution is optimized for performance. We will also use Python's built-in data structures and libraries to simplify the implementation.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane is the length of the line segment connecting them. The Euclidean distance between two points (x1, y1) and (x2, y2) is given by the formula: \u221a((x2 - x1)^2 + (y2 - y1)^2).\n\n    'telephone poles': Points in the grid where a_{x, y} = 1.\n\n    'sum of squares': The sum of the squares of the distances to the nearest pole for all points in the grid.\n\n# [phrase showing quantity relationship]\n    'sum': The total sum of squares of distances for all points in the grid.\n\n# [degree adverb] \n    'nearest': Indicates the smallest distance to a telephone pole.\n\n# [code logic]\n    To implement the solution, we will use a Breadth-First Search (BFS) algorithm to calculate the distance to the nearest pole for each point in the grid. We will initialize a queue with all the positions of the telephone poles and perform BFS to fill a distance matrix where each cell contains the distance to the nearest pole. Finally, we will sum up the squares of these distances to get the desired result.\n\n# [edge case] \n    Input:\n    1 1\n    1\n    1\n\n    Output:\n    2\n\n    Explanation:\n    There is only one pole at (0, 0) and one point at (1, 1). The distance to the nearest pole is 1, and the sum of squares of distances is 1^2 = 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle this edge case as it is a simple scenario with only one pole and one point. The logic provided in the plan will work without modification.\n", "requirement analysis:\nThe primary requirement is to calculate the sum of squares of Euclidean distances from each point in the grid to the nearest telephone pole. This involves identifying the positions of telephone poles and computing distances efficiently. The solution should handle edge cases, such as when there are no telephone poles, ensuring the output is accurate and efficient.\nrequirement pool:\n- Implement a function to calculate the distance from each point to the nearest telephone pole.\n- Ensure the function can handle large grids efficiently.\n- Handle edge cases where there are no telephone poles.\n- Optimize the code for performance and readability.\n- Provide clear and accurate output as per the given requirements.\nTo solve this problem, we will use Python due to its efficiency and ease of handling mathematical operations. We will employ a brute-force approach to calculate the distance from each point to the nearest telephone pole. This method will involve iterating through each point in the grid and checking the distance to all telephone poles, updating the minimum distance found. We will use a nested loop to iterate through each point and a separate function to calculate the Euclidean distance. The sum of all S(x, y) values will be computed by summing up the results of the distance function for each point in the grid.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Euclidean distance': The distance between two points in a plane, calculated using the Pythagorean theorem, where the distance is the square root of the sum of the squares of the differences in the coordinates.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To solve this problem, we will follow these steps:\n    1. Read the input to get the size of the grid and the positions of the telephone poles.\n    2. Initialize a variable to store the sum of all S(x, y) values.\n    3. Iterate through each point (x, y) in the grid.\n    4. For each point, find the nearest telephone pole by checking the distance to all telephone poles and keeping track of the minimum distance.\n    5. Calculate S(x, y) as the square of the minimum distance found.\n    6. Add the value of S(x, y) to the sum.\n    7. After iterating through all points, return the sum.\n\n# [edge case]\n    Edge case 1: When the grid is very small, e.g., n = 0, m = 0.\n    Expected output: 1\n    Explanation: There is only one point (0, 0) and one telephone pole at (0, 0). The distance is 0, and S(0, 0) = 0^2 = 0. However, since there is at least one telephone pole, the sum should be 1.\n\n    Edge case 2: When there are no telephone poles, which is not mentioned in the problem but could occur in some edge cases.\n    Expected output: 0\n    Explanation: If there are no telephone poles, the sum of S(x, y) for all points will be 0 because the distance to the nearest pole is infinite.\n\n    Edge case 3: When the grid is large, e.g., n = 1999, m = 1999.\n    Expected output: A large number, as the distance calculations will be extensive.\n    Explanation: This edge case checks the efficiency of the algorithm when dealing with the maximum possible grid size.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic will work for all cases, including the edge cases mentioned.\n"], "scores": [], "pass_results": [false, false, false, true, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 4, "examples": "\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "mutate_method": "add_1_sentence_at_end", "parent_index": 4}
