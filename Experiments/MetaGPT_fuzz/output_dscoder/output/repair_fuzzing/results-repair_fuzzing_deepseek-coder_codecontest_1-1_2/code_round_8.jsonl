{"name": "1591_B. Array Eversion", "description": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "tags": ["greedy"], "difficulty": 8, "id": 1591, "sample_io": [{"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}], "test_list": [{"input": "2\n1\n998244353\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 1 1\n", "output": ["1\n3\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 1\n", "output": ["0\n2\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 8 2\n2\n1 1 1 1\n", "output": ["1\n1\n0\n"]}, {"input": "3\n5\n2 8 1 4 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["2\n2\n0\n"]}, {"input": "3\n5\n2 1 1 5 6\n5\n5 3 4 4 1\n2\n0 1 1 1\n", "output": ["0\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n802364611\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 4 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n4 2 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 3 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 1 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n4 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 3 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n68829976\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 3 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 2 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 3 0 2\n", "output": ["0\n2\n"]}, {"input": "2\n1\n998244353\n4\n1 1 0 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 2 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 0 1\n", "output": ["1\n3\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n56749180\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1528037704\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n0 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n37862951\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 4 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n134212618\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n13173955\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n314070686\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n802364611\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n4 1 4 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 1 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 1 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n7 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 3 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n41454457\n4\n4 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 0 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n4 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n176445854\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n381715760\n4\n0 2 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 4\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 4 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n993551853\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n2 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1981447801\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 2 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n3 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 6 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 5 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 0 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 7 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n134212618\n4\n4 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n626625781\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n6643808\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 6 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 0 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 4 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 1 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 7 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n316067198\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 2\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n993551853\n4\n3 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1258355607\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1961051652\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 5 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n75994590\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 0 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n533265820\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n627592454\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n4 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 4 6 6\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n1 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 5 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n134212618\n4\n1 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n7874846\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n3\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 12 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n7680692\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n3713787\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n316067198\n4\n-1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n711911604\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n39720822\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 0 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1258355607\n4\n6 0 2 4\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n6 1 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 0 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n112473576\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 0 3\n", "output": ["0\n0\n"]}], "task_id": "codecontest/46", "prompt": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n, and then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "repair_prompt": ["You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n, and then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin", " You are given an array a of length n. Let's define the eversion operation. Let x = a_n, and then the array a is divided into two parts: the left part contains elements not greater than x (\u2264 x), and the right part contains elements strictly greater than x (> x). The order of elements in each part remains the same as before the operation, i.e., the partition is stable. The array is then replaced with the concatenation of the left and right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin", " You are given an array a of length n. Let's define the eversion operation. Let x = a_n, and then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, \n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef func(n: int, a: List[int]) -> int:\n    def is_stable(arr: List[int]) -> bool:\n        return arr == sorted(arr)\n\n    def eversion(arr: List[int]) -> List[int]:\n        pivot = max(arr)\n        left = [x for x in arr if x <= pivot]\n        right = [x for x in arr if x > pivot]\n        return left + right\n\n    count = 0\n    while not is_stable(a):\n        a = eversion(a)\n        count += 1\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    result = func(n, a)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_eversions(arr: List[int]) -> int:\n    def eversion(arr: List[int]) -> List[int]:\n        pivot = arr[-1]\n        left = [x for x in arr if x <= pivot]\n        right = [x for x in arr if x > pivot]\n        return left + right\n\n    count = 0\n    while True:\n        original_arr = arr.copy()\n        arr = eversion(arr)\n        if arr == original_arr:\n            break\n        count += 1\n    return count\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    arr = list(map(int, input().split()))\n    result = find_min_eversions(arr)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\nfrom collections import Counter\n\ndef find_stable_eversions(arr: List[int]) -> int:\n    def eversion_operation(array: List[int]) -> List[int]:\n        if not array:\n            return array\n        pivot = array[-1]\n        left = [x for x in array if x <= pivot]\n        right = [x for x in array if x > pivot]\n        return left + right\n\n    def is_stable(array: List[int]) -> bool:\n        counts = Counter(array)\n        return all(count >= value for value, count in counts.items())\n\n    eversion_count = 0\n    while not is_stable(arr):\n        arr = eversion_operation(arr)\n        eversion_count += 1\n    return eversion_count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_stable_eversions(arr)\n    print(result)\n", "from typing import List\ndef eversion_operation(arr: list) -> list:\n    \"\"\"\n    Performs the eversion operation on the input array.\n    \n    Args:\n        arr (list): The input array to be everted.\n        \n    Returns:\n        list: The array after the eversion operation.\n    \"\"\"\n    if not arr:\n        return arr\n    \n    pivot = arr[-1]\n    left_part = [x for x in arr if x <= pivot]\n    right_part = [x for x in arr if x > pivot]\n    return left_part + right_part\n\ndef count_eversions(arr: list) -> int:\n    \"\"\"\n    Counts the number of eversions required for the array to reach a stable state.\n    \n    Args:\n        arr (list): The input array to be everted.\n        \n    Returns:\n        int: The number of eversions required for the array to stop changing.\n    \"\"\"\n    previous_arr = []\n    count = 0\n    \n    while arr != previous_arr:\n        previous_arr = arr\n        arr = eversion_operation(arr)\n        count += 1\n    \n    return count - 1  # Subtract 1 because the last iteration does not change the array\n\n# Interface for the program\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        result = count_eversions(a)\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef eversion_operation(arr: List[int]) -> int:\n    \"\"\"\n    Perform the eversion operation on the given array.\n    \n    The eversion operation involves partitioning the array based on a pivot element and then concatenating the parts back together.\n    The order of elements in each part remains the same.\n    \n    Args:\n        arr (List[int]): The input array to be everted.\n        \n    Returns:\n        int: The pivot element that satisfies the eversion condition, or -1 if no such element exists.\n    \"\"\"\n    def partition(arr: List[int], pivot: int) -> List[int]:\n        \"\"\"\n        Partition the array based on the pivot element.\n        \n        Args:\n            arr (List[int]): The input array.\n            pivot (int): The pivot element.\n            \n        Returns:\n            List[int]: The partitioned array.\n        \"\"\"\n        left = []\n        right = []\n        for num in arr:\n            if num <= pivot:\n                left.append(num)\n            else:\n                right.append(num)\n        return left + right\n\n    def find_largest_element_more_than_its_value(arr: List[int]) -> int:\n        \"\"\"\n        Find the largest integer in the array that appears more than its value.\n        \n        Args:\n            arr (List[int]): The input array.\n            \n        Returns:\n            int: The largest integer that appears more than its value, or -1 if no such element exists.\n        \"\"\"\n        count = {}\n        for num in arr:\n            count[num] = count.get(num, 0) + 1\n        \n        for num, cnt in count.items():\n            if cnt > num:\n                return num\n        return -1\n\n    if not arr:\n        return -1\n\n    pivot = arr[len(arr) // 2]\n    partitioned_arr = partition(arr, pivot)\n\n    while arr != partitioned_arr:\n        arr = partitioned_arr\n        pivot = arr[len(arr) // 2]\n        partitioned_arr = partition(arr, pivot)\n\n    return find_largest_element_more_than_its_value(arr)\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    _ = input()  # Read the number of elements (not used in this implementation)\n    arr = list(map(int, input().split()))\n    result = eversion_operation(arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef eversion_operation(arr: list) -> list:\n    \"\"\"\n    Performs the eversion operation on the input array.\n    \n    Args:\n        arr (list): The input list to be everted.\n        \n    Returns:\n        list: The everted list.\n    \"\"\"\n    pivot = arr[0]\n    left = [x for x in arr if x <= pivot]\n    right = [x for x in arr if x > pivot]\n    return left + right\n\ndef count_eversions(arr: list) -> int:\n    \"\"\"\n    Counts the number of eversions required for the array to reach a stable state.\n    \n    Args:\n        arr (list): The input list to be everted.\n        \n    Returns:\n        int: The number of eversions required.\n    \"\"\"\n    iterations = 0\n    while True:\n        original_arr = arr.copy()\n        arr = eversion_operation(arr)\n        iterations += 1\n        if arr == original_arr:\n            break\n    return iterations - 1  # Subtract 1 because the last iteration did not change the array\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    arr_length = int(input())\n    arr = list(map(int, input().split()))\n    result = count_eversions(arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef eversion_operation(arr: list) -> list:\n    \"\"\"\n    Performs the eversion operation on the given array.\n    \n    Args:\n        arr (list): The input array to perform the eversion operation on.\n        \n    Returns:\n        list: The array after the eversion operation.\n    \"\"\"\n    if not arr:\n        return arr\n    \n    pivot = arr[-1]\n    left = [x for x in arr if x <= pivot]\n    right = [x for x in arr if x > pivot]\n    \n    return left + right\n\ndef main():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        \n        k = 1\n        result = eversion_operation(a)\n        \n        while a != result:\n            a = result\n            result = eversion_operation(a)\n            k += 1\n        \n        print(k)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef eversion_operation(arr: list) -> list:\n    \"\"\"\n    Perform the eversion operation on the given array.\n    \n    The eversion operation involves partitioning the array based on a pivot element\n    and then concatenating the partitions while maintaining their order.\n    \n    Args:\n        arr (list): The input array to perform the eversion operation on.\n        \n    Returns:\n        list: The array after performing the eversion operation.\n    \"\"\"\n    if not arr:\n        return arr\n    \n    pivot = arr[-1]\n    left = [x for x in arr if x <= pivot]\n    right = [x for x in arr if x > pivot]\n    \n    return left + right\n\n# Read the number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    # Read the length of the array and the array elements\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    # Initialize the number of eversions\n    eversion_count = 0\n    \n    # Perform the eversion operation until the array stops changing\n    while True:\n        original_arr = arr.copy()\n        arr = eversion_operation(arr)\n        eversion_count += 1\n        \n        # Check if the array has stopped changing\n        if arr == original_arr:\n            break\n    \n    # Output the number of eversions\n    print(eversion_count)\n", "from typing import List\n## main.py\n\ndef eversion_operation(arr: list) -> int:\n    \"\"\"\n    Perform the eversion operation on the array and return the number of iterations until the array stops changing.\n    \n    Args:\n        arr (list): The input array to perform the eversion operation on.\n        \n    Returns:\n        int: The number of iterations (eversions) required to stabilize the array.\n    \"\"\"\n    def partition(arr, pivot):\n        \"\"\"\n        Partition the array based on the pivot element.\n        \n        Args:\n            arr (list): The input array.\n            pivot (int): The pivot element.\n            \n        Returns:\n            tuple: A tuple containing two lists, the left partition and the right partition.\n        \"\"\"\n        left = []\n        right = []\n        for num in arr:\n            if num <= pivot:\n                left.append(num)\n            else:\n                right.append(num)\n        return left, right\n\n    def is_stable(arr, new_arr):\n        \"\"\"\n        Check if the array has stabilized.\n        \n        Args:\n            arr (list): The original array.\n            new_arr (list): The array after performing the eversion operation.\n            \n        Returns:\n            bool: True if the array has stabilized, False otherwise.\n        \"\"\"\n        return arr == new_arr\n\n    iterations = 0\n    while True:\n        pivot = arr[-1]\n        left, right = partition(arr[:-1], pivot)\n        new_arr = left + [pivot] + right\n        iterations += 1\n        if is_stable(arr, new_arr):\n            break\n        arr = new_arr\n    return iterations\n\n# Read input from stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = eversion_operation(arr)\n    print(result)\n", "from typing import List\ndef eversion_count(arr: list) -> int:\n    k = 0\n    while True:\n        pivot = max(arr)\n        left = [x for x in arr if x <= pivot]\n        right = [x for x in arr if x > pivot]\n        if arr == left + right:\n            break\n        arr = left + right\n        k += 1\n    return k\n\n# Read input from stdin\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        result = eversion_count(arr)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirement involves understanding the eversion operation on an array and determining the minimum number of operations required for the array to stop changing. The input consists of multiple test cases, each with a specific array length and elements. The output should provide the minimum number of eversions for each test case. The challenge lies in efficiently handling large inputs and ensuring the solution is scalable.\nrequirement pool:\n- Implement the eversion operation on the array\n- Determine the minimum number of eversions for the array to stop changing\n- Handle large inputs efficiently\n- Ensure the solution is scalable for large arrays\n- Optimize the number of operations for large arrays\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The eversion operation can be efficiently implemented using a stable partition function, which will help us split the array into two parts based on the pivot element. We will iterate through the array, performing eversions until the array no longer changes. To optimize the process, we will use a function to check if the array has stabilized between eversions. This approach ensures that we handle large inputs efficiently and provide an accurate count of the minimum number of eversions required for the array to stop changing.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element and then concatenating the partitioned parts. The operation is repeated until the array no longer changes.\n    Explanation: The eversion operation splits the array into two parts: one with elements less than or equal to the pivot and the other with elements greater than the pivot. This process is repeated iteratively until the array configuration no longer changes.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find elements greater than the pivot.\n    Explanation: For example, in the array [2, 4, 1, 5, 3], the pivot is 3. The elements more than 3 are [4, 5], which form the right part of the partition.\n\n# [degree adverb] \n    'largest': This adverb suggests that we need to find the largest element in the array to use as the pivot.\n    Explanation: In the array [2, 4, 1, 5, 3], the largest element is 5, which is used as the pivot for the first eversion.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation, we need to:\n    1. Find the largest element in the array to use as the pivot.\n    2. Partition the array into two parts based on the pivot.\n    3. Concatenate the two parts and repeat the process until the array no longer changes.\n\n# [edge case] \n    Edge case 1: [1, 1, 1, 1] = 0\n    Explanation: The array already stops changing after the first eversion since all elements are the same.\n    Edge case 2: [5, 4, 3, 2, 1] = 1\n    Explanation: The array stops changing after the first eversion because the largest element 5 is used as the pivot, resulting in [4, 3, 2, 1] and [5], which does not change further.\n    Edge case 3: [2, 2, 3, 3, 3] = 2\n    Explanation: The array stops changing after the second eversion. In the first eversion, the pivot is 3, resulting in [2, 2] and [3, 3], which then stabilizes to [2, 2, 3, 3] and [].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to check if the array has stabilized between eversions is already part of the main implementation.\n", "requirement analysis:\nThe primary requirement is to determine the minimum number of eversions required to stabilize an array. This involves repeatedly partitioning the array based on a pivot element and checking if the array stabilizes. The algorithm should be efficient enough to handle large inputs within reasonable time constraints.\nrequirement pool:\n- Implement the eversion operation and check for array stabilization.\n- Ensure the solution is optimized for handling large arrays.\n- Provide clear and concise output for the number of eversions.\n- Improve the user interface for better usability.\n- Optimize the algorithm for faster computation.\nTo solve the problem of determining the minimum number of eversions required to stabilize an array, we will use a simple and efficient approach. The eversion operation involves partitioning the array based on a pivot element and then concatenating the left and right parts. We will implement a function that repeatedly performs eversions until the array stops changing. To optimize the solution for large inputs, we will use Python's built-in list operations and avoid unnecessary data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element and then concatenating the left and right parts. The order of elements in each part is kept the same.\n    Explanation: The eversion operation is a transformation of the array where a pivot element (x) divides the array into two parts: elements less than or equal to x (left part) and elements greater than x (right part). The array is then reconstructed by concatenating these two parts while maintaining their relative order.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find an integer that appears more than its value in the array.\n    Explanation: For example, if an integer appears 3 times in the array, it must be greater than 2 (since 2 * 2 < 3).\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the largest integer that meets the condition of appearing more than its value.\n    Explanation: For example, if the array contains integers 2, 3, and 4, the largest integer that appears more than its value is 4 (since 2 * 2 < 3 and 3 * 2 < 4).\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. For each test case, read the array.\n    2. Perform eversions until the array stops changing.\n    3. Count the number of eversions performed.\n    4. Output the count for each test case.\n\n# [edge case] \n    search([1, 1, 1, 1]) = 0\n    Explanation: Since all elements are the same, no eversion will change the array. The expected output is 0.\n    search([2, 2, 3, 3, 3]) = 2\n    Explanation: The first eversion will split the array into [2, 2] and [3, 3, 3], and the second eversion will split it into [2] and [2, 3, 3, 3]. The array stops changing after 2 eversions.\n    search([5, 5, 4, 4, 4]) = 3\n    Explanation: The first eversion will split the array into [4, 4, 4] and [5, 5], the second eversion will split it into [4] and [4, 4, 5, 5], and the third eversion will split it into [4] and [4, 4, 5, 5]. The array stops changing after 3 eversions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to solve the problem for all test cases.\n", "requirement analysis:\nThe problem requires understanding the eversion operation and implementing it efficiently. The input consists of multiple test cases, each with a varying number of elements. The output should reflect the number of eversions after which the array stops changing. The solution must handle large inputs efficiently, adhering to the constraints provided.\nrequirement pool:\n- Implement the eversion operation correctly.\n- Ensure the solution is optimized for time complexity.\n- Handle multiple test cases efficiently.\n- Include error handling for invalid inputs.\n- Provide clear and concise output for each test case.\nTo solve this problem, we will use a simple and efficient approach that involves repeatedly applying the eversion operation until the array no longer changes. We will implement this in Python, leveraging the power of list operations and a loop to repeatedly partition and check for stability. The key steps include partitioning the array, checking if the array has stabilized, and counting the number of iterations until stability.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array into two parts based on a pivot value (x), where the left part contains elements less than or equal to x, and the right part contains elements greater than x. The array is then reconstructed by concatenating these two parts. The process is repeated until the array no longer changes.\n\n    Explanation: The eversion operation helps in sorting the array by repeatedly partitioning it around a pivot value until no further changes occur, indicating that the array is sorted.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find an integer that appears more than its value in the array.\n    'at least as many times': This phrase indicates that we need to find an integer whose frequency is greater than or equal to its value.\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the largest integer that meets the condition of appearing more than its value.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the input array.\n    2. Apply the eversion operation until the array no longer changes.\n    3. Count the number of iterations (eversions) until stability.\n    4. Output the count.\n\n# [edge case] \n    search([1, 1, 1, 1]) = 0\n    Explanation: The array is already stable after 0 eversions since all elements are the same.\n    search([2, 2, 3, 3, 3]) = 0\n    Explanation: The array is already stable after 0 eversions since the counts of elements are equal to their values.\n    search([4, 3, 2, 1]) = 3\n    Explanation: The array will require 3 eversions to become stable, where each eversion reduces the array's instability.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the logic provided can handle arrays with all identical elements or already sorted arrays. The core logic will return 0 for such cases, which is the correct output.\n", "requirement analysis:\nThe requirements involve defining the eversion operation on an array, which involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining their order. The output should reflect the number of iterations required for the array to stop changing, which indicates the stable state.\nrequirement pool:\n- Implement the eversion operation as described\n- Ensure the product can handle large inputs efficiently\n- Provide a user-friendly interface for easy interaction\n- Optimize performance for large datasets\n- Allow for customization of sorting parameters\nTo implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining their order. We will iterate over the array, applying the eversion operation until the array stops changing. This will involve creating a function to perform the eversion operation and another to count the number of iterations required for the array to reach a stable state.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining their order.\n    Explanation: The eversion operation is a transformation applied to an array where a pivot element is chosen, and the array is divided into two parts: one with elements not greater than the pivot (\u2264 pivot) and the other with elements strictly greater than the pivot (> pivot). The order of elements in each part is preserved. After partitioning, the array is reconstructed by concatenating these two parts.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining their order. We will iterate over the array, applying the eversion operation until the array stops changing. This will involve creating a function to perform the eversion operation and another to count the number of iterations required for the array to reach a stable state.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 2, 3, 4, 5]\n    Explanation: The array is already sorted in ascending order. Since the pivot is the last element (5), the left part will be [1, 2, 3, 4] and the right part will be []. After the first eversion, the array becomes [1, 2, 3, 4, 5], which is the same as the original array. Therefore, the number of eversions required is 1.\n\n    Edge case 2:\n    Input: [5, 4, 3, 2, 1]\n    Explanation: The array is sorted in descending order. The pivot is the first element (5). After the first eversion, the array becomes [4, 3, 2, 1, 5], which is not the same as the original array. We need to continue applying the eversion operation until the array stops changing. After a few iterations, the array will stabilize at [1, 2, 3, 4, 5]. The number of eversions required is dependent on the specific sequence of pivot choices.\n\n    Edge case 3:\n    Input: [2, 2, 2, 2]\n    Explanation: All elements in the array are the same. Any element can be chosen as the pivot. After the first eversion, the array remains the same. Therefore, the number of eversions required is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic will work for arrays with all identical elements, as well as for arrays that stabilize after a few eversion operations.\n", "requirement analysis:\nThe requirement involves defining the eversion operation on an array, which divides the array into two parts based on a pivot element and then concatenates them back together. The goal is to determine the number of iterations required for the array to stop changing, which indicates that the eversion operation has stabilized. This requires efficient handling of large arrays and clear output of the number of iterations.\nrequirement pool:\n- Implement the eversion operation on the array\n- Ensure the array is stable after a number of eversions\n- Handle large arrays efficiently\n- Provide a clear and intuitive user interface\n- Optimize performance for large datasets\nTo implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element and then concatenating the parts back together. To handle large arrays efficiently, we will ensure that the operations are optimized for performance. The user interface will be simple, with clear instructions and feedback mechanisms.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element and then concatenating the parts back together. The order of elements in each part remains the same.\n    Explanation: The eversion operation is a transformation applied to an array where a pivot element (x) divides the array into two parts: one with elements not greater than x (\u2264 x) and the other with elements strictly greater than x (> x). The order of elements in each part is preserved.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find an integer that appears more than its value.\n    Explanation: For example, if we have an array [2, 2, 3, 3, 3], the number 3 appears more than three times, which is more than its value (3).\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the largest integer that appears more than its value.\n    Explanation: For example, in the array [3, 3, 2, 4, 4, 4], the number 3 is the largest integer that appears more than its value (3 times).\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation efficiently, we will:\n    1. Identify the pivot element (x) in the array.\n    2. Partition the array into two parts based on the pivot element.\n    3. Concatenate the two parts back together while preserving the order of elements in each part.\n    4. Repeat the process until the array stops changing.\n\n# [edge case] \n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: In this case, the number 3 appears more than three times, which is more than its value (3). The function should return 3 as the result.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    Explanation: In this case, no integer appears more than its value. The function should return -1 as the result.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then check for the presence of an integer that meets the condition.\n\n# [core concept]\n    'array partitioning': This involves dividing the array into two parts based on a pivot element and preserving the order of elements in each part.\n    Explanation: The eversion operation relies on partitioning the array to achieve a stable sort-like effect, where elements are grouped based on their relationship to the pivot.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find an integer that appears more than its value.\n    Explanation: For example, if we have an array [2, 2, 3, 3, 3], the number 3 appears more than three times, which is more than its value (3).\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the largest integer that appears more than its value.\n    Explanation: For example, in the array [3, 3, 2, 4, 4, 4], the number 3 is the largest integer that appears more than its value (3 times).\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation efficiently, we will:\n    1. Identify the pivot element (x) in the array.\n    2. Partition the array into two parts based on the pivot element.\n    3. Concatenate the two parts back together while preserving the order of elements in each part.\n    4. Repeat the process until the array stops changing.\n\n# [edge case] \n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: In this case, the number 3 appears more than three times, which is more than its value (3). The function should return 3 as the result.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    Explanation: In this case, no integer appears more than its value. The function should return -1 as the result.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then check for the presence of an integer that meets the condition.\n", "requirement analysis:\nThe requirements involve defining the eversion operation on an array, which involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining stability. The output should reflect the number of iterations required for the array to stop changing, which indicates the stable state.\nrequirement pool:\n- Implement the eversion operation as described\n- Ensure the product can handle large inputs efficiently\n- Provide a user-friendly interface for easy understanding\n- Test and validate the product with various edge cases\nTo implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining stability. We will iterate through the array, applying the eversion operation until the array stops changing. This will involve creating a function to perform the eversion operation and another to count the number of iterations required for the array to reach a stable state.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining stability.\n    Explanation: The eversion operation rearranges the array such that elements less than or equal to the pivot are on one side, and elements greater than the pivot are on the other side. This operation is applied repeatedly until the array no longer changes.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining stability. We will iterate through the array, applying the eversion operation until the array stops changing. This will involve creating a function to perform the eversion operation and another to count the number of iterations required for the array to reach a stable state.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Expected output: 0\n    Explanation: The array is already sorted, so no eversion operation is needed, and the array does not change.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 1\n    Explanation: The array is in reverse order. After one eversion operation, the array becomes [4, 5, 3, 2, 1], which is not sorted.\n\n    Edge case 3: [3, 1, 2, 4, 5]\n    Expected output: 2\n    Explanation: After the first eversion operation, the array becomes [1, 2, 3, 4, 5]. After the second eversion operation, the array stops changing.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle the edge cases by checking if the array has changed after each eversion operation.\n", "requirement analysis:\nThe primary requirement is to implement the eversion operation on an array as described. The operation involves partitioning the array based on a pivot element, which is the last element of the array. The partitioning is stable, meaning the order of elements within each partition is preserved. The output should indicate the number of eversions after which the array stops changing. This requires careful handling of the array and efficient computation to detect when the array stops changing.\nrequirement pool:\n- Implement the eversion operation on an array.\n- Ensure the partitioning is stable.\n- Track the number of eversions until the array stops changing.\n- Provide detailed output after each eversion.\n- Handle large arrays efficiently without performance issues.\nTo implement the eversion operation on an array efficiently, we will use Python's built-in data structures and functions. The eversion operation involves partitioning the array based on a pivot element, which is the last element of the array. The partitioning is stable, meaning the order of elements within each partition is preserved. We will iterate through the array, performing the eversion operation and tracking the number of iterations until the array stops changing. This will involve creating helper functions to partition the array and checking for array stability.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element, which is the last element of the array. The partitioning is stable, meaning the order of elements within each partition is preserved.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find the number of iterations until the array stops changing.\n\n# [degree adverb] \n    'largest': This adverb suggests that we need to find the largest integer that appears at least as many times as itself.\n\n# [code logic]\n    To implement the eversion operation efficiently, we will use Python's built-in data structures and functions. The main function will read input from stdin, perform the eversion operation iteratively, and track the number of iterations until the array stops changing. We will create helper functions to partition the array and check for array stability.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Expected output: 1\n    Explanation: The array does not change after the first eversion operation since all elements are already in ascending order.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 5\n    Explanation: The array will need to undergo 5 eversion operations to reach a stable state where the array does not change.\n\n    Edge case 3: [2, 2, 2, 2, 2]\n    Expected output: 1\n    Explanation: The array does not change after the first eversion operation since all elements are the same.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should be sufficient to handle these cases.\n", "requirement analysis:\nThe requirements specify the need to implement the eversion operation on an array, which involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining their order. The output should reflect the number of iterations required for the array to stop changing, which indicates the stable state.\nrequirement pool:\n- Implement the eversion operation on an array\n- Ensure the array partitioning is stable\n- Optimize the algorithm for large input sizes\n- Enhance user interface for better usability\nTo implement the eversion operation on an array efficiently, we will use Python's built-in data structures and list operations. The eversion operation involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining their order. We will iterate through the array, performing the eversion operation until the array stops changing. This approach will ensure that the algorithm is both efficient and easy to understand.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining their order.\n\n# [phrase showing quantity relationship]\n    'more than': This indicates that we need to find integers greater than the pivot element.\n    'at least as many times': This means the integer's frequency in the array should be at least as much as the integer itself.\n\n# [degree adverb] \n    'largest': This suggests that we need to find the largest integer that meets the above conditions.\n\n# [code logic]\n    To implement the eversion operation efficiently, we can follow these steps:\n    1. Read the input for each test case.\n    2. For each test case, perform the eversion operation until the array stops changing.\n    3. Count the number of eversions performed.\n    4. Output the count for each test case.\n\n# [edge case] \n    Edge case 1: [1, 1, 1]\n    Expected output: 1\n    Explanation: The array already stops changing after the first eversion since all elements are the same.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 1\n    Explanation: The array will evert to [1, 2, 3, 4, 5] in the first eversion and then stop changing since the array is sorted in descending order.\n\n    Edge case 3: [2, 7, 4, 1, 5, 3]\n    Expected output: 2\n    Explanation: The first eversion will result in [1, 2, 4, 5, 3], and the second eversion will result in [1, 2, 3, 4, 5], stopping the changes.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the logic provided in the plan can handle these cases correctly. The eversion operation will stop changing the array after a certain number of iterations, and we can count these iterations to get the desired output.\n", "requirement analysis:\nThe requirement involves understanding the eversion operation on an array and determining the number of iterations required for the array to stop changing. The input is structured to handle multiple test cases, and the output should reflect the number of iterations for each case.\nrequirement pool:\n- Implement the eversion operation on the array\n- Handle multiple test cases efficiently\n- Ensure the application is user-friendly\n- Optimize performance for large datasets\n- Include detailed error handling\nTo implement the eversion operation on an array efficiently, we will use Python's built-in data structures and list operations. The eversion operation involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining the order of elements. We will iterate through the array, performing the eversion operation until the array no longer changes. This approach ensures that we handle multiple test cases efficiently and optimize performance for large datasets.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining the order of elements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the eversion operation efficiently, we will use Python's built-in data structures and list operations. The steps include:\n    1. Reading the input for each test case.\n    2. Performing the eversion operation iteratively until the array no longer changes.\n    3. Counting the number of iterations (eversions) required to stabilize the array.\n    4. Outputting the count for each test case.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 2, 3, 4, 5]\n    Explanation: The array is already sorted in ascending order. The first eversion operation will partition the array into [1, 2, 3] and [4, 5], and then concatenate them, resulting in the same array. The array stops changing after the first eversion, so the output is 1.\n    Edge case 2:\n    Input: [5, 4, 3, 2, 1]\n    Explanation: The array is sorted in descending order. The first eversion operation will partition the array into [5, 4, 3] and [2, 1], and then concatenate them. The array will continue to change with each subsequent eversion, so the output will be greater than 1.\n    Edge case 3:\n    Input: [2, 2, 2, 2, 2]\n    Explanation: All elements in the array are the same. The first eversion operation will partition the array into [2, 2, 2] and [2, 2], and then concatenate them, resulting in the same array. The array stops changing after the first eversion, so the output is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle these cases by checking the stability of the array after each eversion operation.\n", "requirement analysis:\nThe problem requires understanding the eversion operation and its effect on the array. The solution should be able to handle multiple test cases efficiently, and the algorithm should be scalable. The input size can be large, so optimization is crucial. The output should be the minimum number of eversions after which the array stops changing.\nrequirement pool:\n- Implement the eversion operation and ensure it is stable\n- Develop an algorithm to determine the minimum number of eversions for stability\n- Ensure the code can handle large inputs efficiently\n- Optimize the code for performance and scalability\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The eversion operation involves partitioning the array based on a pivot element, which can be efficiently managed using Python's list operations. We will implement a function that performs the eversion operation iteratively until the array no longer changes, counting the number of iterations as the result. This approach leverages Python's built-in functions and data structures to ensure simplicity and performance.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element, which can be efficiently managed using Python's list operations. The operation involves splitting the array into two parts based on the pivot and then concatenating them back together.\n\n    Explanation: The eversion operation is a transformation applied to an array where a pivot element is chosen, and the array is split into two parts: one containing elements less than or equal to the pivot and the other containing elements greater than the pivot. The order of elements in each part is preserved. This process is repeated iteratively until the array no longer changes.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find the pivot element such that the number of elements greater than it is less than the value of the pivot itself.\n\n# [degree adverb] \n    'largest': This adverb suggests that we need to find the largest pivot element that can be used to perform the eversion operation.\n\n# [code logic]\n    To implement the eversion operation, we can follow these steps:\n    1. Read the input array.\n    2. Perform the eversion operation iteratively until the array no longer changes.\n    3. Count the number of iterations as the result.\n\n    Here's a Python function to perform the eversion operation:\n\n    ```python\n    def perform_eversions(arr):\n        k = 0\n        while True:\n            pivot = max(arr)\n            left = [x for x in arr if x <= pivot]\n            right = [x for x in arr if x > pivot]\n            if arr == left + right:\n                break\n            arr = left + right\n            k += 1\n        return k\n\n    # Read input from stdin\n    def main():\n        t = int(input())\n        for _ in range(t):\n            n = int(input())\n            arr = list(map(int, input().split()))\n            result = perform_eversions(arr)\n            print(result)\n\n    if __name__ == \"__main__\":\n        main()\n    ```\n\n# [edge case] \n    Edge case 1: [1, 1, 1, 1]\n    Expected output: 1\n    Explanation: The array does not change after the first eversion because all elements are equal.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 1\n    Explanation: The array becomes [1, 2, 3, 4, 5] after the first eversion, and it does not change further.\n\n    Edge case 3: [2, 2, 2, 3, 3, 3]\n    Expected output: 1\n    Explanation: The array becomes [2, 2, 2, 3, 3, 3] after the first eversion, and it does not change further.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided code already handles arrays where all elements are the same or where the array does not change after the first eversion.\n"], "scores": [], "pass_results": [false, false, true, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 8, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "mutate_method": "condense_two2one", "parent_index": 8}
