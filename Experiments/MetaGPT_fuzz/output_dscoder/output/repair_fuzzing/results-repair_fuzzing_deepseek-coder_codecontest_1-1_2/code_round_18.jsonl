{"name": "1618_A. Polycarp and Sums of Subsequences", "description": "Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.\n\nFor example, if a = \\{1, 4, 3\\}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = \\{1, 3, 4, 4, 5, 7, 8\\}.\n\nUnfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "tags": ["math", "sortings"], "difficulty": 7, "id": 1618, "sample_io": [{"input": "5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n", "output": ["1 3 4\n1 2 4\n300000000 300000000 300000000\n1 1 999999998\n1 2 2\n"]}], "test_list": [{"input": "1\n69696868 69696868 69696868 139393736 139393736 139393736 209090604\n", "output": ["69696868 69696868 69696868 \n"]}, {"input": "2\n1 1 2 69696874 69696875 69696875 69696876\n1 1 1 2 2 2 3\n", "output": ["1 1 69696874\n1 1 1\n"]}, {"input": "1\n1 1 2 69696880 69696881 69696881 69696882\n", "output": ["1 1 69696880\n"]}, {"input": "2\n1 1 2 69696967 69696968 69696968 69696969\n1 1 1 2 2 2 3\n", "output": ["1 1 69696967\n1 1 1\n"]}, {"input": "2\n1 1 2 69696868 69696869 69696869 69696870\n1 2 3 4 5 6 7\n", "output": ["1 1 69696868\n1 2 4\n"]}, {"input": "2\n1 1 2 696967 696968 696968 696969\n1 1 1 2 2 2 3\n", "output": ["1 1 696967\n1 1 1\n"]}, {"input": "2\n1 1 2 69696873 69696874 69696874 69696875\n1 1 1 2 2 2 3\n", "output": ["1 1 69696873\n1 1 1\n"]}, {"input": "2\n1 1 2 69696889 69696890 69696890 69696891\n1 1 1 2 2 2 3\n", "output": ["1 1 69696889\n1 1 1\n"]}, {"input": "1\n1 2 3 69696875 69696876 69696877 69696878\n", "output": ["1 2 69696875\n"]}, {"input": "2\n1 1 2 69696870 69696871 69696871 69696872\n1 1 1 2 2 2 3\n", "output": ["1 1 69696870\n1 1 1\n"]}, {"input": "2\n1 1 2 69696881 69696882 69696882 69696883\n1 1 1 2 2 2 3\n", "output": ["1 1 69696881\n1 1 1\n"]}, {"input": "2\n1 1 2 598989 598990 598990 598991\n1 3 4 4 5 7 8\n", "output": ["1 1 598989\n1 3 4\n"]}, {"input": "2\n1 1 2 69696875 69696876 69696876 69696877\n1 1 1 2 2 2 3\n", "output": ["1 1 69696875\n1 1 1\n"]}, {"input": "1\n1 1 2 69696884 69696885 69696885 69696886\n", "output": ["1 1 69696884\n"]}, {"input": "1\n1 1 2 69696883 69696884 69696884 69696885\n", "output": ["1 1 69696883\n"]}, {"input": "2\n1 1 2 69696885 69696886 69696886 69696887\n1 1 1 2 2 2 3\n", "output": ["1 1 69696885\n1 1 1\n"]}, {"input": "2\n1 1 2 69696879 69696880 69696880 69696881\n1 1 1 2 2 2 3\n", "output": ["1 1 69696879\n1 1 1\n"]}, {"input": "5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n", "output": ["1 3 4\n1 2 4\n300000000 300000000 300000000\n1 1 999999998\n1 2 2\n"]}, {"input": "2\n1 1 2 69696886 69696887 69696887 69696888\n1 1 1 2 2 2 3\n", "output": ["1 1 69696886\n1 1 1\n"]}, {"input": "2\n1 1 2 69696869 69696870 69696870 69696871\n1 1 1 2 2 2 3\n", "output": ["1 1 69696869\n1 1 1\n"]}, {"input": "2\n1 1 2 69696887 69696888 69696888 69696889\n1 1 1 2 2 2 3\n", "output": ["1 1 69696887\n1 1 1\n"]}, {"input": "2\n1 1 2 69696877 69696878 69696878 69696879\n1 1 1 2 2 2 3\n", "output": ["1 1 69696877\n1 1 1\n"]}, {"input": "2\n1 1 2 69696871 69696872 69696872 69696873\n1 1 1 2 2 2 3\n", "output": ["1 1 69696871\n1 1 1\n"]}, {"input": "2\n1 1 2 69696882 69696883 69696883 69696884\n1 1 1 2 2 2 3\n", "output": ["1 1 69696882\n1 1 1\n"]}, {"input": "1\n1 2 3 69696887 69696888 69696889 69696890\n", "output": ["1 2 69696887\n"]}, {"input": "2\n1 1 2 69696872 69696873 69696873 69696874\n1 1 1 2 2 2 3\n", "output": ["1 1 69696872\n1 1 1\n"]}, {"input": "2\n1 1 2 69696878 69696879 69696879 69696880\n1 1 1 2 2 2 3\n", "output": ["1 1 69696878\n1 1 1\n"]}], "task_id": "codecontest/132", "prompt": "Polycarp had an array a of 3 positive integers, wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. \n\nFor example, if a = \\{1, 4, 3\\}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8; after sorting, he got an array b = \\{1, 3, 4, 4, 5, 7, 8\\}.\n\nUnfortunately, Polycarp lost the array a and only has the array b left, so help him to restore the array a.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "repair_prompt": ["Polycarp had an array a of 3 positive integers, wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. \n\nFor example, if a = \\{1, 4, 3\\}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8; after sorting, he got an array b = \\{1, 3, 4, 4, 5, 7, 8\\}.\n\nUnfortunately, Polycarp lost the array a and only has the array b left, so help him to restore the array a.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.\nWrite a main() function and use input() function to read input from stdin", " Polycarp had an array a of 3 positive integers, wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. \n\nFor example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8; after sorting, he got an array b = {\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.\nWrite a main() function and use input() function to read input from stdin", " Polycarp had an array b of 7 integers, each representing the sums of all non-empty subsequences of the original array a of 3 positive integers, and he needs to find the original array a.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    # Sort the array to make it easier to find the smallest three elements\n    b.sort()\n    \n    # The smallest three elements are the first three elements in the sorted array\n    a_1, a_2, a_3 = b[0], b[1], b[2]\n    \n    # Verify the sums of these three elements\n    sum_of_three = a_1 + a_2 + a_3\n    \n    # Check if the sum of the smallest three elements matches the last element in b\n    if sum_of_three != b[-1]:\n        raise ValueError(\"The given sums do not match the expected sums of the smallest three elements.\")\n    \n    # The remaining elements in b are the sums of pairs of a_1, a_2, and a_3\n    remaining_sums = b[3:]\n    \n    # Check if the remaining sums match the expected pairs\n    if sorted([a_1 + a_2, a_1 + a_3, a_2 + a_3]) != remaining_sums[:3]:\n        raise ValueError(\"The given sums do not match the expected pairs of the smallest three elements.\")\n    \n    # The original array a is the smallest three elements\n    return [a_1, a_2, a_3]\n\n# Read the number of test cases\nn = int(input())\n\n# Process each test case\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef restore_array(sorted_sums: List[int]) -> List[int]:\n    # The smallest sum is the sum of the smallest two elements\n    smallest_sum = sorted_sums[0]\n    # The largest sum is the sum of all elements\n    largest_sum = sorted_sums[-1]\n    \n    # The sum of the two smallest elements is the difference between the smallest and second smallest sums\n    sum_of_two_smallest = sorted_sums[1] - smallest_sum\n    # The sum of the three elements is the difference between the largest and the second largest sums\n    sum_of_three = largest_sum - sorted_sums[-2]\n    \n    # The three elements are the sum of the two smallest elements and the sum of the three elements\n    a = [sum_of_two_smallest, smallest_sum, sum_of_three]\n    \n    return a\n\n# Read the number of test cases\nt = int(input())\nfor _ in range(t):\n    sums = list(map(int, input().split()))\n    result = restore_array(sums)\n    print(result[0], result[1], result[2])\n", "from typing import List\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    b.sort()  # Ensure b is sorted\n    a = []\n    # The smallest three sums will be the first three elements in b\n    a.append(b[0])\n    a.append(b[1])\n    a.append(b[6] - b[1])  # The largest sum minus the second smallest sum gives the third element\n    return a\n\n# Read the number of test cases\nt = int(input())\nfor _ in range(t):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef reconstruct_array(b: List[int]) -> List[int]:\n    # Sort the array to easily find the smallest elements\n    b.sort()\n    \n    # The smallest three elements in b\n    a_1, a_2, a_3 = b[0], b[1], b[2]\n    \n    # Remove the smallest three elements from b\n    b = b[3:]\n    \n    # Identify a_3 by subtracting a_1 and a_2 from the next smallest sum\n    a_3 = min(b, key=lambda x: abs(x - (a_1 + a_2))) - (a_1 + a_2)\n    \n    # Identify a_2 by subtracting a_1 from the next smallest sum\n    a_2 = min(b, key=lambda x: abs(x - a_1)) - a_1\n    \n    # The smallest element in b is a_1\n    a_1 = b[0]\n    \n    return [a_1, a_2, a_3]\n\n# Read the number of test cases\nn = int(input())\n\n# Process each test case\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = reconstruct_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef reconstruct_array(b: List[int]) -> List[int]:\n    # Sort the array b to make it easier to work with\n    b.sort()\n    \n    # The sum of all elements in the original array a\n    total_sum = sum(b)\n    \n    # The smallest sum in b is the smallest element in a\n    smallest = b[0]\n    \n    # The largest sum in b is the sum of all elements in a\n    largest = b[-1]\n    \n    # The middle element in b is the sum of the two remaining elements in a\n    middle = total_sum - smallest - largest\n    \n    # Return the reconstructed array a\n    return [smallest, middle, largest]\n\n# Read the number of test cases\nn = int(input())\n\n# Process each test case\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = reconstruct_array(b)\n    print(f\"{result[0]} {result[1]} {result[2]}\")\n", "from typing import List\nfrom typing import List\n\ndef reconstruct_array(b: List[int]) -> List[int]:\n    # The smallest sum is the smallest element of a\n    a1 = min(b)\n    # The largest sum is the sum of the three elements of a\n    a3_a2_sum = max(b)\n    # The middle sum is the sum of the remaining two elements\n    a2_a3_sum = b[6] if b[5] == a3_a2_sum else b[5]\n    \n    # Calculate a2 and a3 using the sums\n    a3 = (a3_a2_sum - a2_a3_sum) // 2\n    a2 = a3_a2_sum - a3\n    \n    # Calculate a1\n    a1 = b[0] // a1\n    \n    return [a1, a2, a3]\n\n# Read the number of test cases\nn = int(input())\n\n# Process each test case\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = reconstruct_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_original_array(b: List[int]) -> List[int]:\n    # The sum of all elements in the original array a is the sum of all elements in b divided by 2^(n-1)\n    # where n is the length of b (since each element is included in half of the subsequences).\n    n = len(b)\n    total_sum = sum(b)\n    a_sum = total_sum / (2 ** (n - 1))\n    \n    # Since a is a list of positive integers, we can assume the smallest element is 1.\n    a = [1]\n    remaining_sum = a_sum - 1\n    \n    # We need to find the other two elements of a.\n    # We can use the fact that the sum of all elements in b is the sum of all subsequences of a.\n    # Since each element of a is included in half of the subsequences, we can use combinatorial mathematics to solve for the elements of a.\n    a.append(remaining_sum)\n    a.append(remaining_sum)\n    \n    return a\n\n# Provide the Interface\nn = int(input())\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = find_original_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef find_original_array(sums: List[int]) -> List[int]:\n    # Sort the sums to make it easier to find the largest sum that is more than zero\n    sums.sort()\n    \n    # Initialize a list to store the original array\n    original_array = [0] * 3\n    \n    # The largest sum that is more than zero and appears at least as many times as the integer itself\n    largest_sum = 0\n    \n    # Iterate through the sorted sums to find the largest sum that meets the criteria\n    for i in range(len(sums)):\n        if sums[i] > 0 and sums.count(sums[i]) >= sums[i]:\n            largest_sum = sums[i]\n            break\n    \n    # The sum of the three elements in the original array\n    total_sum = sums[6]\n    \n    # Calculate the sum of the two smaller elements\n    sum_of_two_smallest = total_sum - largest_sum\n    \n    # The sum of the two smallest elements in the original array\n    smallest_sum = 0\n    \n    # Iterate through the sorted sums to find the sum of the two smallest elements\n    for i in range(len(sums)):\n        if sum_of_two_smallest - sums[i] > 0 and (sum_of_two_smallest - sums[i]) in sums:\n            smallest_sum = sums[i]\n            break\n    \n    # The third element in the original array\n    third_element = total_sum - largest_sum - smallest_sum\n    \n    # Assign the elements to the original array\n    original_array[0] = (largest_sum - third_element) // 2\n    original_array[1] = smallest_sum // 2\n    original_array[2] = third_element // 2\n    \n    return original_array\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    sums = list(map(int, input().split()))\n    result = find_original_array(sums)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef find_original_array(b: List[int]) -> List[int]:\n    # Sort the sums to make it easier to find the original elements\n    b.sort()\n    \n    # The sum of all elements in the original array a\n    S = b[-1]\n    \n    # The sum of the first three elements in the original array a\n    S123 = (b[0] + b[1] + b[2])\n    \n    # The sum of the first two elements in the original array a\n    S12 = (b[0] + b[1])\n    \n    # The sum of the first element in the original array a\n    S1 = b[0]\n    \n    # Calculate the third element in the original array a\n    a3 = (S123 - S12) // 2\n    \n    # Calculate the second element in the original array a\n    a2 = (S12 - S1) - a3\n    \n    # Calculate the first element in the original array a\n    a1 = S1 - a2 - a3\n    \n    return [a1, a2, a3]\n\n# Read the number of test cases\nn = int(input())\n\n# Process each test case\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = find_original_array(b)\n    print(' '.join(map(str, result)))\n", "from typing import List\nfrom typing import List\n\ndef restore_array(b: List[int]) -> List[int]:\n    # Sort the input array b to make it easier to find the smallest three numbers\n    b.sort()\n    \n    # The smallest three numbers in b should be the sum of the smallest three numbers in a\n    a = [b[0], b[1], b[6] - b[0] - b[1]]\n    \n    # Ensure the result is sorted in non-decreasing order\n    a.sort()\n    \n    return a\n\n# Read the number of test cases\nn = int(input())\n\n# Process each test case\nfor _ in range(n):\n    b = list(map(int, input().split()))\n    result = restore_array(b)\n    print(' '.join(map(str, result)))\n"], "plans": ["requirement analysis:\nThe primary requirement is to restore the original array a from the given sums in array b. The solution must handle multiple test cases efficiently. The algorithm should be robust and capable of handling large inputs. The user interface should be simple and easy to use.\nrequirement pool:\n- Implement an algorithm to restore the original array a from the given sums in array b.\n- Ensure the solution can handle multiple test cases efficiently.\n- Optimize the algorithm to minimize computational complexity.\n- Create a user-friendly interface for easy interaction.\n- Test and validate the solution with various inputs to ensure accuracy and robustness.\nTo restore the original array a from the given sums in array b, we can use a combinatorial approach. Given that the sums are sorted and there are 7 elements in b, we can deduce that the smallest three elements of b are a_1, a_2, and a_3. The next four elements in b are the sums of pairs of these three elements. The last element is the sum of all three elements. We can use this information to reverse the process and find the original array a.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'non-empty subsequences': means all possible combinations of the elements in the array, including single elements and multiple elements combined.\n    'sorted in non-decreasing order': means the sums are arranged from smallest to largest, without any duplicates.\n\n# [phrase showing quantity relationship]\n    'all non-empty subsequences': means we need to consider all possible combinations of the elements in the array.\n    'sorted in non-decreasing order': means we need to arrange the sums from smallest to largest.\n\n# [degree adverb] \n    'non-decreasing': means the order of the sums is increasing, but it can be equal to the previous value.\n\n# [code logic]\n    To restore the array a from the given sums in array b, we can follow these steps:\n    1. Identify the smallest three elements of b, which are a_1, a_2, and a_3.\n    2. Calculate the sums of these three elements to verify the sequence.\n    3. Use the remaining elements in b to find the pairs and the sum of all three elements.\n    4. Reconstruct the original array a by identifying the remaining elements.\n\n# [edge case] \n    Edge case 1:\n    b = [1, 3, 4, 4, 5, 7, 8]\n    Explanation:\n    The smallest three elements are 1, 3, and 4. The sum of these elements is 8, which matches the last element in b. The remaining sums (5, 7) are the sums of the pairs (1+4 and 3+4). This matches the given b array, so the original array a could be [1, 3, 4].\n\n    Edge case 2:\n    b = [2, 5, 7, 9, 12, 14, 16]\n    Explanation:\n    The smallest three elements are 2, 5, and 7. The sum of these elements is 14, which matches the last element in b. The remaining sums (9, 12) are the sums of the pairs (2+7 and 5+7). This matches the given b array, so the original array a could be [2, 5, 7].\n\n    Edge case 3:\n    b = [1, 2, 3, 5, 6, 8, 11]\n    Explanation:\n    The smallest three elements are 1, 2, and 3. The sum of these elements is 6, which matches the last element in b. The remaining sums (5, 8) are the sums of the pairs (1+3 and 2+3). This matches the given b array, so the original array a could be [1, 2, 3].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The given logic is sufficient to restore the original array a from the given sums in array b.\n", "requirement analysis:\nThe problem requires the ability to reverse-engineer the original array from its sorted sums. This involves understanding the combinatorial nature of the sums and how they relate to the original elements. The solution must be able to handle multiple test cases efficiently, making it suitable for large inputs.\nrequirement pool:\n- Implement a function to restore the original array from the sorted sums.\n- Ensure the solution can handle multiple test cases.\n- Optimize the algorithm for performance to handle large inputs.\n- Add error handling to manage unexpected inputs.\n- Include user documentation for better understanding and usage.\nTo restore the original array from the sorted sums, we will use a combinatorial approach that leverages the properties of the sums to deduce the original elements. The key steps involve identifying the smallest and largest sums, which will help in isolating the individual elements of the original array. We will use Python's built-in functions and libraries to ensure efficiency and robustness.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'non-empty subsequences': means all possible combinations of the array elements excluding the empty set\n    'sorted in non-decreasing order': means the sums are arranged from smallest to largest without any duplicates\n\n# [phrase showing quantity relationship]\n    'all non-empty subsequences': means we need to consider all combinations of the array elements\n    'sorted in non-decreasing order': means we need to arrange the sums in ascending order\n\n# [degree adverb] \n    'non-decreasing': means the order of the sums is increasing but can be equal\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    b = [1, 2, 3, 4, 5, 6, 7]\n    explanation: The smallest sum is 1 (single element), the largest sum is 7 (all elements), and the remaining sums are intermediate values. This can be the result of the array a being [1, 2, 3] or [2, 2, 3], etc.\n    b = [1, 3, 5, 7, 9, 11, 13]\n    explanation: Similar to the previous edge case, but with all sums being odd numbers. This can be the result of the array a being [1, 3, 5] or [2, 3, 4], etc.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to restore the array a from the sorted sums is robust and can handle these cases directly.\n", "requirement analysis:\nThe problem requires the ability to reverse-engineer the original array from its sorted sums. This involves understanding the combinatorial nature of the sums and how they relate to the original elements. The solution must be able to handle multiple test cases efficiently, making it suitable for large inputs.\nrequirement pool:\n- Implement a function to restore the original array from the sorted sums.\n- Ensure the solution can handle up to 5000 test cases.\n- Optimize the algorithm for performance to handle large inputs.\n- Provide clear and concise output for each test case.\nTo restore the original array from the sorted sums, we need to reverse-engineer the process of generating all possible sums and sorting them. Given that the sums are generated from all non-empty subsequences of the original array, we can deduce the original elements by identifying the smallest three sums and their corresponding elements. We will use Python's built-in functions and libraries to efficiently handle the task.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'non-empty subsequences': means all possible combinations of the array elements excluding the empty set\n\n    'sorted in non-decreasing order': means the sums are arranged from smallest to largest\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To restore the array a, we need to:\n    1. Identify the smallest three sums from the array b.\n    2. Determine the original elements a_1, a_2, and a_3 based on the smallest sums.\n    3. Sort the identified elements to form the original array a.\n\n# [edge case] \n    For a given array b, there is always at least one array a that can yield this b. This is a fundamental property of the problem as stated.\n\n# [extra code for edge case]\n    No extra code is needed for edge cases as the problem guarantees the existence of at least one array a for each b.\n\n# [code logic]\n    Here's a detailed Python function to restore the array a from the array b:\n\n    ```python\n    def restore_array(b):\n        b.sort()  # Ensure b is sorted\n        a = []\n        # The smallest three sums will be the first three elements in b\n        a.append(b[0])\n        a.append(b[1])\n        a.append(b[6] - b[1])  # The largest sum minus the second smallest sum gives the third element\n        return a\n\n    # Example usage:\n    b = [1, 3, 4, 4, 5, 7, 8]\n    restored_a = restore_array(b)\n    print(restored_a)  # Output should be [1, 3, 4] or any permutation of {1, 3, 4}\n    ```\n\n    Explanation:\n    - The smallest three sums are identified as the first three elements of b.\n    - The third element is deduced by subtracting the second smallest sum from the largest sum in b.\n    - This approach ensures that the restored array a contains the original elements that could have produced the given sorted sums in b.\n", "requirement analysis:\nThe problem requires reconstructing the original array a from the sorted sums array b. This involves identifying the three integers that, when summed, produce the given sequence. The input consists of multiple test cases, each with a unique sorted sequence of sums. The solution must be able to handle up to 5000 test cases efficiently.\nrequirement pool:\n- Implement a function to reconstruct the original array from the given sums.\n- Ensure the solution can handle up to 5000 test cases.\n- Optimize the algorithm for performance to handle large inputs.\n- Provide a user-friendly interface for easy interaction.\nTo reconstruct the original array a from the given sums array b, we can use a combination of set operations and mathematical properties. The key insight is that the sums array b contains all possible sums of the three integers in a, including their individual values and all combinations of two or three of them. By identifying the smallest three elements in b, we can deduce the original array a.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'non-empty subsequences': means all possible combinations of the elements in the array, including individual elements and combinations of two or more elements.\n    'sorted in non-decreasing order': means the array is sorted from smallest to largest.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To reconstruct the original array a from the given sums array b, we can follow these steps:\n    1. Identify the smallest three elements in b, which will be a_1, a_2, and a_3.\n    2. Remove these smallest elements from b to get the remaining sums.\n    3. Use the remaining sums to identify the third element of a (a_3) by subtracting a_1 and a_2 from the next smallest sum.\n    4. Use the remaining sums to identify the second element of a (a_2) by subtracting a_1 from the next smallest sum.\n    5. The smallest element in b is a_1.\n\n# [edge case]\n    Edge case 1:\n    b = [1, 3, 4, 5, 7, 8, 10]\n    Explanation:\n    The smallest three elements are 1, 3, and 4. These are a_1, a_2, and a_3. The remaining sums are [5, 7, 8, 10]. Subtracting a_1 (1) from the next smallest sum (3) gives a_2 (2), and subtracting a_1 (1) from the next smallest sum (4) gives a_3 (3).\n    a = [1, 2, 3]\n\n    Edge case 2:\n    b = [2, 4, 6, 8, 10, 12, 14]\n    Explanation:\n    The smallest three elements are 2, 4, and 6. These are a_1, a_2, and a_3. The remaining sums are [8, 10, 12, 14]. Subtracting a_1 (2) from the next smallest sum (4) gives a_2 (2), and subtracting a_1 (2) from the next smallest sum (6) gives a_3 (4).\n    a = [2, 2, 4]\n\n    Edge case 3:\n    b = [1, 2, 3, 5, 7, 11, 13]\n    Explanation:\n    The smallest three elements are 1, 2, and 3. These are a_1, a_2, and a_3. The remaining sums are [5, 7, 11, 13]. Subtracting a_1 (1) from the next smallest sum (2) gives a_2 (1), and subtracting a_1 (1) from the next smallest sum (3) gives a_3 (2).\n    a = [1, 1, 2]\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to reconstruct the original array a from the given sums array b.\n", "requirement analysis:\nThe problem requires reconstructing the original array a from the sorted sums b. The input consists of multiple test cases, each with a unique array b. The solution must be able to handle up to 5000 test cases efficiently. The output should be the original array a that yields the given array b when all non-empty subsequences are summed and sorted.\nrequirement pool:\n- Implement a function to reconstruct the original array a from the given array b.\n- Ensure the solution can handle up to 5000 test cases efficiently.\n- Optimize the algorithm to minimize the time complexity.\n- Provide a user-friendly interface for easy interaction.\nTo reconstruct the original array a from the given array b, we can use a systematic approach to identify the individual elements of a. Given that b is a sorted array of sums of all non-empty subsequences of a, we can deduce the individual elements by leveraging the properties of sums and the sorted nature of b. The key steps involve identifying the smallest and largest elements of a, and then finding the middle element by subtracting the sum of the smallest and largest elements from the sum of all elements in b.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'non-empty subsequences': means all possible combinations of the array elements excluding the empty set\n    'sorted in non-decreasing order': means the array is in ascending order\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To reconstruct the original array a from the given array b, we can use a systematic approach to identify the individual elements of a. Given that b is a sorted array of sums of all non-empty subsequences of a, we can deduce the individual elements by leveraging the properties of sums and the sorted nature of b. The key steps involve identifying the smallest and largest elements of a, and then finding the middle element by subtracting the sum of the smallest and largest elements from the sum of all elements in b.\n\n# [edge case] \n    b = [1, 3, 4, 5, 7, 8]\n    explanation: This array b corresponds to the sums of all non-empty subsequences of the array a = [1, 3, 4]. The sums are 1, 3, 4, 5 (1+4), 4 (1+3), 7 (3+4), and 8 (1+3+4). Sorting these sums gives us b = [1, 3, 4, 5, 7, 8].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to reconstruct the original array a from the given array b.\n", "requirement analysis:\nThe problem requires reconstructing the original array of three positive integers from the sorted sums of all non-empty subsequences. The input consists of multiple test cases, each with a unique array b. The solution must be efficient and handle up to 5000 test cases. The output should be clear and include the original array elements.\nrequirement pool:\n- Implement a function to reconstruct the original array from the given sums.\n- Ensure the solution can handle up to 5000 test cases efficiently.\n- Provide clear and easy-to-understand output.\n- Optimize the algorithm for large inputs.\n- Add detailed explanations for the output.\nTo reconstruct the original array of three positive integers from the given sums, we can leverage the properties of sums of subsequences. Given the sorted sums array b, we can deduce the original array a by identifying the smallest and largest sums and the middle sum. The smallest sum will be the smallest element of a, the largest sum will be the sum of the three elements, and the middle sum will be the sum of the remaining two elements. We can then solve for the individual elements of a.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'non-empty subsequences': means all possible combinations of the array elements excluding the empty set\n    'sorted in non-decreasing order': means the sums are arranged from smallest to largest\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To reconstruct the original array, we need to:\n    1. Identify the smallest and largest sums in the array b.\n    2. Determine the sum of the three elements of the original array a.\n    3. Use the sums to deduce the individual elements of a.\n\n# [edge case] \n    Edge case 1:\n    b = [1, 3, 4, 5, 7, 8, 9]\n    Explanation:\n    The smallest sum is 1 (a_1), the largest sum is 9 (a_1 + a_2 + a_3), and the sum of the remaining elements is 8 (a_2 + a_3). We can deduce a_2 and a_3 by solving the system of equations.\n    Edge case 2:\n    b = [2, 5, 7, 9, 12, 14, 16]\n    Explanation:\n    The smallest sum is 2 (a_1), the largest sum is 16 (a_1 + a_2 + a_3), and the sum of the remaining elements is 14 (a_2 + a_3). We can deduce a_2 and a_3 by solving the system of equations.\n    Edge case 3:\n    b = [3, 6, 8, 10, 13, 15, 17]\n    Explanation:\n    The smallest sum is 3 (a_1), the largest sum is 17 (a_1 + a_2 + a_3), and the sum of the remaining elements is 15 (a_2 + a_3). We can deduce a_2 and a_3 by solving the system of equations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can be used to deduce the original array a from the given sums array b.\n", "requirement analysis:\nThe problem requires finding the original array a from the given sums of all non-empty subsequences. The solution must be efficient and handle multiple test cases. The output should be accurate and easy to understand. The solution should be robust and handle edge cases effectively.\nrequirement pool:\n- Implement a solution that can find the original array a from the given sums.\n- Ensure the solution is efficient and can handle multiple test cases.\n- Provide a clear and concise output format.\n- Verify the solution with a brute-force approach.\n- Evaluate the solution's ability to handle edge cases and large inputs.\nTo solve the problem of finding the original array a from the given sums of all non-empty subsequences, we will use combinatorial mathematics. The key insight is that each element of the original array a will be included in exactly half of the non-empty subsequences of the array b. This allows us to derive the elements of a by using properties of binomial coefficients and solving a system of linear equations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'subsequences': A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n    Explanation: In this problem, Polycarp is given the sums of all non-empty subsequences of an original array a of 3 positive integers. By understanding the concept of subsequences, we can deduce the individual elements of array a.\n\n# [phrase showing quantity relationship]\n    'sums of all non-empty subsequences': This phrase indicates that each element of array a is included in multiple subsequences, and we need to sum these subsequences to get the elements of array b.\n\n# [degree adverb] \n    'non-empty': This adverb indicates that we are only considering subsequences that have at least one element.\n\n# [code logic]\n    To solve this problem, we need to:\n    1. Understand that each element of array a will be included in exactly half of the non-empty subsequences of array b.\n    2. Use combinatorial mathematics to derive the elements of array a from the given sums in array b.\n    3. Implement a method to calculate the individual elements of array a based on the sums provided in array b.\n\n# [edge case] \n    Edge case 1:\n    Input: b = [3, 3, 4, 4, 5, 5, 6]\n    Explanation: This input represents the sums of all non-empty subsequences of the original array a = [1, 1, 2]. The sums are calculated as follows:\n    - Subsequences of [1, 1, 2]: 1, 1, 2, 1+1, 1+2, 1+1+2 = 3\n    The given sums are [3, 3, 4, 4, 5, 5, 6], which match the calculated sums.\n    Expected output: [1, 1, 2]\n\n    Edge case 2:\n    Input: b = [2, 2, 3, 3, 4, 4, 5]\n    Explanation: This input represents the sums of all non-empty subsequences of the original array a = [1, 2, 1]. The sums are calculated as follows:\n    - Subsequences of [1, 2, 1]: 1, 2, 1, 1+2, 2+1, 1+2+1 = 2\n    The given sums are [2, 2, 3, 3, 4, 4, 5], which match the calculated sums.\n    Expected output: [1, 2, 1]\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The given sums and the constraints ensure that there is always a unique solution for array a.\n", "requirement analysis:\nThe problem requires finding the original array a from the given sums of all non-empty subsequences. The sums are provided in a sorted order, which simplifies the process of identifying the individual elements of the array a. The solution must be efficient and capable of handling multiple test cases.\nrequirement pool:\n- Implement a function to find the original array a from the given sums.\n- Ensure the solution can handle multiple test cases efficiently.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for better performance.\n- Add error handling to manage unexpected inputs.\nTo solve the problem of finding the original array a from the given sums, we will use a mathematical approach that leverages the properties of sums of subsequences. Given that each element of the array a is a positive integer, we can deduce the individual elements by considering the sums provided. The sums are the sums of all non-empty subsequences of a, which means each sum is a combination of the three elements of a. By analyzing the sums, we can identify the individual elements.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'sum of subsequences': The sums of all non-empty subsequences of an array, which are combinations of its elements.\n    Explanation: In this problem, Polycarp is given the sums of all possible subsequences of an original array of 3 positive integers. By summing all possible combinations of 3 elements, we can deduce the individual elements of the array.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the sum of a subsequence is greater than a certain value.\n    Explanation: In the context of the problem, 'more than' is used to describe the sums of subsequences that are greater than a specific value, helping us identify the individual elements of the array.\n\n# [degree adverb] \n    'largest': Indicates that we need to find the largest integer that meets a certain condition.\n    Explanation: In the requirement, 'largest' is used to specify that we need to find the largest integer in the original array a that appears at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve the problem, we need to:\n    1. Identify the largest sum that is more than zero and appears at least as many times as the integer itself.\n    2. Use this information to deduce the individual elements of the original array a.\n\n# [edge case] \n    search([1, 2, 3, 4, 5, 6, 7]) = -1\n    Explanation: This edge case is not applicable to the given problem as it does not follow the constraints of the problem. The problem guarantees that there exists at least one array a which yields the given array b.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The problem guarantees that there exists at least one array a which yields the given array b, so we can directly proceed with the logic provided in the plan.\n", "requirement analysis:\nThe problem requires finding three integers a_1, a_2, and a_3 such that their sums of all non-empty subsequences match the given array b. The constraints ensure that there is at least one valid solution, which simplifies the problem. The solution should be efficient enough to handle up to 5000 test cases.\nrequirement pool:\n- Implement a function to find the original array a from the given sums.\n- Ensure the solution can handle up to 5000 test cases efficiently.\n- Provide a clear and concise output format.\n- Optimize the algorithm to handle large inputs effectively.\n- Add error handling to manage unexpected inputs.\nTo solve this problem, we will use a mathematical approach to deduce the original array a from the given sums in array b. The key insight is that each element in array a will be part of multiple subsequences in array b, and by leveraging this, we can derive the values of a_1, a_2, and a_3.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'subsequences': A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n    Explanation: In this problem, Polycarp has the sums of all non-empty subsequences of the original array a. By summing all possible combinations of a_1, a_2, and a_3, we can deduce the values of these elements.\n\n# [phrase showing quantity relationship]\n    'sums of all non-empty subsequences': This phrase indicates that each element in array a contributes to multiple sums in array b.\n    Explanation: For example, if a = [a1, a2, a3], then the sums of all non-empty subsequences include a1, a2, a3, a1+a2, a1+a3, a2+a3, and a1+a2+a3.\n\n# [degree adverb] \n    'non-empty': This adverb indicates that we need to consider all possible subsequences, including single elements and combinations.\n    Explanation: By considering all non-empty subsequences, we ensure that we capture all contributions of each element in array a to the sums in array b.\n\n# [code logic]\n    To solve this problem, we need to:\n    1. Sum all possible combinations of a_1, a_2, and a_3 to match the sums in array b.\n    2. Use the sums to deduce the values of a_1, a_2, and a_3.\n    3. Output the values of a_1, a_2, and a_3 for each test case.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 3, 4, 5, 6]\n    Expected output: 1 2 3\n    Explanation: This is a simple case where the sums directly correspond to the elements of the original array a.\n    Edge case 2: [2, 3, 5, 7, 8, 10, 15]\n    Expected output: 1 2 3\n    Explanation: This case involves larger numbers and demonstrates that the approach can handle larger inputs.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the mathematical approach inherently covers all possible combinations and ensures that the solution is found.\n", "requirement analysis:\nThe primary requirement is to restore the original array a from the sorted sums array b. This involves identifying the three integers that could have been summed to produce each of the seven integers in b. The solution must handle multiple test cases efficiently, and the algorithm should be robust enough to handle large inputs.\nrequirement pool:\n- Implement an algorithm to restore the original array a from the sorted sums array b.\n- Ensure the solution can handle multiple test cases efficiently.\n- Optimize the algorithm for performance to handle large inputs.\n- Design a user-friendly interface for input and output.\nTo restore the original array a from the sorted sums array b, we need to identify the three integers that could have been summed to produce each of the seven integers in b. This involves a combination of mathematical analysis and algorithmic manipulation. We will use Python due to its efficiency and ease of handling large datasets.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'non-empty subsequences': means combinations of elements from the array without removing any elements\n    'sorted in non-decreasing order': means the array is in ascending order\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To restore the array a, we need to identify the three integers that could have been summed to produce each of the seven integers in b. This involves a combination of mathematical analysis and algorithmic manipulation.\n\n# [edge case] \n    Edge case 1: b = [1, 2, 3, 4, 5, 6, 7]\n    Expected output: [1, 2, 3]\n    Explanation: The smallest 3 numbers sum up to the smallest 7 numbers in b.\n\n    Edge case 2: b = [2, 4, 6, 8, 10, 12, 14]\n    Expected output: [2, 4, 6]\n    Explanation: The smallest 3 even numbers sum up to the smallest 7 even numbers in b.\n\n    Edge case 3: b = [1, 3, 5, 7, 9, 11, 13]\n    Expected output: [1, 3, 5]\n    Explanation: The smallest 3 odd numbers sum up to the smallest 7 odd numbers in b.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the original logic should be sufficient to identify the smallest three numbers that sum up to the smallest seven numbers in b.\n"], "scores": [], "pass_results": [false, false, false, false, true, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 18, "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 5000) \u2014 the number of test cases.\n\nEach test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 \u2264 b_i \u2264 10^9; b_i \u2264 b_{i+1}). \n\nAdditional constraint on the input: there exists at least one array a which yields this array b as described in the statement.\n\nOutput\n\nFor each test case, print 3 integers \u2014 a_1, a_2 and a_3. If there can be several answers, print any of them.\n\nExample\n\nInput\n\n\n5\n1 3 4 4 5 7 8\n1 2 3 4 5 6 7\n300000000 300000000 300000000 600000000 600000000 600000000 900000000\n1 1 2 999999998 999999999 999999999 1000000000\n1 2 2 3 3 4 5\n\n\nOutput\n\n\n1 4 3\n4 1 2\n300000000 300000000 300000000\n999999998 1 1\n1 2 2\n\nNote\n\nThe subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.\n\nTwo subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.", "mutate_method": "condense_two2one", "parent_index": 18}
