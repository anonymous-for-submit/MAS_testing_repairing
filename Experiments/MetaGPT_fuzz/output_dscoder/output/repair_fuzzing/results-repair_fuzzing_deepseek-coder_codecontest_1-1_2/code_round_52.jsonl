{"name": "1591_B. Array Eversion", "description": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "tags": ["greedy"], "difficulty": 8, "id": 1591, "sample_io": [{"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}], "test_list": [{"input": "2\n1\n998244353\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 1 1\n", "output": ["1\n3\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 1\n", "output": ["0\n2\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 8 2\n2\n1 1 1 1\n", "output": ["1\n1\n0\n"]}, {"input": "3\n5\n2 8 1 4 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["2\n2\n0\n"]}, {"input": "3\n5\n2 1 1 5 6\n5\n5 3 4 4 1\n2\n0 1 1 1\n", "output": ["0\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n802364611\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 4 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n4 2 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 3 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 1 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n4 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 3 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n68829976\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 3 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 2 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 3 0 2\n", "output": ["0\n2\n"]}, {"input": "2\n1\n998244353\n4\n1 1 0 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 2 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 0 1\n", "output": ["1\n3\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n56749180\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1528037704\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n0 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n37862951\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 4 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n134212618\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n13173955\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n314070686\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n802364611\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n4 1 4 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 1 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 1 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n7 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 3 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n41454457\n4\n4 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 0 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n4 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n176445854\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n381715760\n4\n0 2 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 4\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 4 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n993551853\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n2 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1981447801\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 2 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n3 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 6 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 5 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 0 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 7 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n134212618\n4\n4 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n626625781\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n6643808\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 6 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 0 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 4 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 1 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 7 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n316067198\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 2\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n993551853\n4\n3 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1258355607\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1961051652\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 5 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n75994590\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 0 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n533265820\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n627592454\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n4 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 4 6 6\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n1 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 5 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n134212618\n4\n1 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n7874846\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n3\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 12 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n7680692\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n3713787\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n316067198\n4\n-1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n711911604\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n39720822\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 0 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1258355607\n4\n6 0 2 4\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n6 1 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 0 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n112473576\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 0 3\n", "output": ["0\n0\n"]}], "task_id": "codecontest/46", "prompt": "You are provided with an array a having a length of n.\n\nLet's define the eversion operation where x = a_n and then the array a is partitioned into two parts: left and right, with the left part containing elements of a that are not greater than x (\u2264 x) and the right part containing elements of a that are strictly greater than x (> x). The sequence of elements within each part remains unchanged as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor instance, if the array a is [2, 4, 1, 5, 3], the eversion proceeds as follows: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe begin with the array a and carry out eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "repair_prompt": ["You are provided with an array a having a length of n.\n\nLet's define the eversion operation where x = a_n and then the array a is partitioned into two parts: left and right, with the left part containing elements of a that are not greater than x (\u2264 x) and the right part containing elements of a that are strictly greater than x (> x). The sequence of elements within each part remains unchanged as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor instance, if the array a is [2, 4, 1, 5, 3], the eversion proceeds as follows: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe begin with the array a and carry out eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin", " You are given an array a with n elements. The eversion operation is defined such that you select the last element x = a_n of the array, then partition the array into two parts: left and right, where the left part contains elements not greater than x (\u2264 x) and the right part contains elements strictly greater than x (> x). The sequence of elements within each part remains unchanged. After partitioning, the array is replaced by the concatenation of the left and right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion proceeds as\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin", " You are given an array a of length n. Define the eversion operation where x = a_n, then partition the array into two parts: left (\u2264 x) and right (> x), and concatenate them. Repeat this process until the array stops changing. Output the number of eversions required for the array to stop changing.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef func(n: int, a: List[int]) -> int:\n    def is_stable(arr: List[int]) -> bool:\n        count = {}\n        for num in arr:\n            count[num] = count.get(num, 0) + 1\n        for num, cnt in count.items():\n            if cnt > num:\n                return False\n        return True\n\n    def eversion_operation(arr: List[int]) -> List[int]:\n        pivot = arr[len(arr) // 2]\n        left = [x for x in arr if x <= pivot]\n        right = [x for x in arr if x > pivot]\n        return left + right\n\n    eversion_count = 0\n    while not is_stable(a):\n        a = eversion_operation(a)\n        eversion_count += 1\n        if eversion_count > 1000:  # To prevent infinite loop in case of no stable state\n            break\n\n    if is_stable(a):\n        return eversion_count\n    else:\n        return -1\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    result = func(n, a)\n    print(result)\n", "from typing import List\n## main.py\n\ndef eversion_count(arr: list) -> int:\n    def eversion(sub_arr):\n        pivot = sorted(sub_arr)[len(sub_arr) // 2]\n        left = [x for x in sub_arr if x <= pivot]\n        right = [x for x in sub_arr if x > pivot]\n        return left + right\n\n    original_arr = arr[:]\n    count = 0\n    while True:\n        arr = eversion(arr)\n        count += 1\n        if arr == original_arr:\n            break\n    return count\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = eversion_count(arr)\n    print(result)\n", "from typing import List\n## main.py\n\nimport sys\ninput = sys.stdin.readline\n\ndef eversion_operation(arr: list) -> int:\n    def stable_partition(arr, pivot):\n        left = [num for num in arr if num <= pivot]\n        right = [num for num in arr if num > pivot]\n        return left + right\n\n    count = 0\n    while True:\n        original_arr = arr.copy()\n        arr = stable_partition(arr, arr[-1])\n        count += 1\n        if arr == original_arr:\n            break\n    return count\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    arr = list(map(int, input().split()))\n    result = eversion_operation(arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef eversion_operation(arr: List[int]) -> List[int]:\n    def partition(arr: List[int], pivot: int) -> List[int]:\n        left = [x for x in arr if x <= pivot]\n        right = [x for x in arr if x > pivot]\n        return left + right\n\n    def is_sorted(arr: List[int]) -> bool:\n        return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))\n\n    pivot = arr[0]\n    while not is_sorted(arr):\n        arr = partition(arr, pivot)\n    return arr\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = eversion_operation(arr)\n    print(len(result))\n", "from typing import List\n## main.py\n\ndef eversion_operation(arr: list) -> list:\n    \"\"\"\n    Implements the eversion operation on an array.\n    \n    The eversion operation involves partitioning the array based on a pivot element,\n    which is the last element of the array. The left part contains elements not greater\n    than the pivot, and the right part contains elements strictly greater than the pivot.\n    The sequence of elements within each part remains unchanged.\n    \n    Args:\n        arr (list): The input list to be everted.\n        \n    Returns:\n        list: The list after one eversion operation.\n    \"\"\"\n    if not arr:\n        return arr\n    \n    pivot = arr[-1]\n    left = [x for x in arr[:-1] if x <= pivot]\n    right = [x for x in arr[:-1] if x > pivot]\n    \n    return left + [pivot] + right\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    _ = input()  # Read the number of elements (not used in this implementation)\n    arr = list(map(int, input().split()))\n    result = eversion_operation(arr)\n    print(len(result) - len(arr))\n", "from typing import List\n## main.py\n\ndef eversion_count(arr: list) -> int:\n    def eversion(arr):\n        pivot = arr[-1]\n        left = [x for x in arr[:-1] if x <= pivot]\n        right = [x for x in arr[:-1] if x > pivot]\n        return left + [pivot] + right\n\n    count = 0\n    while True:\n        new_arr = eversion(arr)\n        if new_arr == arr:\n            break\n        arr = new_arr\n        count += 1\n    return count\n\n# Read input\nn = int(input())\nfor _ in range(n):\n    arr_size = int(input())\n    arr = list(map(int, input().split()))\n    result = eversion_count(arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef eversion_operation(arr: List[int]) -> List[int]:\n    \"\"\"\n    Perform the eversion operation on the given array.\n    \n    The eversion operation involves partitioning the array into two parts based on a pivot element\n    and then concatenating those parts. This process is repeated until the array no longer changes.\n    \n    Args:\n        arr (List[int]): The input array to perform the eversion operation on.\n        \n    Returns:\n        List[int]: The array after the eversion operation has been performed.\n    \"\"\"\n    while True:\n        # Perform the eversion operation\n        pivot = arr[-1]\n        left = [x for x in arr if x <= pivot]\n        right = [x for x in arr if x > pivot]\n        new_arr = left + right\n        \n        # Check if the array has stabilized\n        if new_arr == arr:\n            break\n        \n        # Update the array for the next iteration\n        arr = new_arr\n    \n    return arr\n\n# Interface for the program\nn = int(input())\nfor _ in range(n):\n    _ = input()  # Skip the length of the array\n    arr = list(map(int, input().split()))\n    result = eversion_operation(arr)\n    print(len(result) - 1)  # Output the number of eversions\n", "from typing import List\ndef eversion_operation(arr: list) -> int:\n    def partition(arr):\n        pivot = arr[-1]\n        left = [x for x in arr if x <= pivot]\n        right = [x for x in arr if x > pivot]\n        return left, right\n\n    def is_stable(arr, prev_arr):\n        return arr == prev_arr\n\n    count = 0\n    prev_arr = arr[:]\n\n    while True:\n        left, right = partition(prev_arr)\n        new_arr = left + right\n        if is_stable(new_arr, prev_arr):\n            break\n        prev_arr = new_arr\n        count += 1\n\n    return count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = eversion_operation(arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef eversion_operation(arr: List[int]) -> List[int]:\n    \"\"\"\n    Perform the eversion operation on the given array.\n    \n    The eversion operation involves partitioning the array based on a pivot and recursively applying the same operation\n    until the array stops changing.\n    \n    Args:\n        arr (List[int]): The input array to perform the eversion operation on.\n        \n    Returns:\n        List[int]: The array after the eversion operation has been applied.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    pivot = max(arr)\n    left = [x for x in arr if x <= pivot]\n    right = [x for x in arr if x > pivot]\n    \n    return left + right\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    _ = input()  # Skip the length of the array\n    arr = list(map(int, input().split()))\n    result = arr\n    eversion_count = 0\n    \n    while True:\n        new_result = eversion_operation(result)\n        eversion_count += 1\n        if new_result == result:\n            break\n        result = new_result\n    \n    print(eversion_count - 1)  # Output the number of eversions\n", "from typing import List\nfrom typing import List\n\ndef eversion_count(arr: List[int]) -> int:\n    def stable_partition(arr: List[int], pivot: int) -> List[int]:\n        left = []\n        right = []\n        for num in arr:\n            if num <= pivot:\n                left.append(num)\n            else:\n                right.append(num)\n        return left + right\n\n    count = 0\n    while True:\n        original_arr = arr.copy()\n        pivot = max(arr)\n        arr = stable_partition(arr, pivot)\n        count += 1\n        if arr == original_arr:\n            break\n    return count\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    arr = list(map(int, input().split()))\n    result = eversion_count(arr)\n    print(result)\n"], "plans": ["requirement analysis:\nThe problem requires understanding the eversion operation and how it affects the array. The goal is to determine the minimum number of eversions after which the array stops changing. This involves repeatedly partitioning the array based on a pivot element and checking if the array has stabilized. The solution should be efficient enough to handle large inputs within the given constraints.\nrequirement pool:\n- Implement the eversion operation and check for array stabilization.\n- Optimize the algorithm for large inputs to ensure performance.\n- Ensure the solution provides the correct output for each test case.\n- Test the solution with various test cases to verify its correctness.\n- Document the code and provide clear instructions for usage.\nTo solve this problem, we will use Python due to its simplicity and efficiency. The main challenge is to implement the eversion operation and check for array stabilization. We will use a loop to repeatedly apply the eversion operation until the array stops changing. To optimize the algorithm for large inputs, we will use efficient data structures and avoid unnecessary computations. We will also ensure that the solution provides the correct output for each test case.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element and then concatenating the partitioned parts back together. The partitioning is stable, meaning the order of elements within each part remains unchanged.\n    Explanation: The eversion operation helps in sorting-like transformations of the array by repeatedly partitioning it based on a pivot until the array stops changing.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find an element in the array that appears more times than its value.\n    Explanation: For example, in the array [5, 5, 4, 4, 4], the number 4 appears three times, which is more than its value, while 5 appears two times, which is not more than its value.\n\n# [degree adverb] \n    'largest': This adverb suggests that we need to find the largest integer that meets the condition of appearing more times than its value.\n    Explanation: For instance, in the array [2, 2, 3, 3, 3], the number 3 appears three times, which is more than its value, and it is the largest number meeting this condition.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the input for each test case.\n    2. For each test case, apply the eversion operation iteratively until the array stops changing.\n    3. Count the number of eversions performed to reach the stable state.\n    4. Output the count for each test case.\n\n# [edge case] \n    search([1, 1, 1, 1]) = 0\n    Explanation: The array is already stable as all elements are the same. No eversions are needed, so the output is 0.\n    search([2, 2, 1, 1]) = -1\n    Explanation: The array is not stable because both 2 and 1 appear more than once, but there is no single number that appears more times than its value. Therefore, the output is -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the logic provided in the plan can handle arrays with all identical elements or those without a number appearing more times than its value. The solution will naturally output 0 or -1 for these edge cases.\n", "requirement analysis:\nThe problem requires an efficient way to determine the number of eversions for a given array. The eversion operation involves partitioning the array based on a pivot element and then concatenating the partitions while maintaining stability. The goal is to find the minimum number of eversions after which the array stops changing. The solution should be scalable and handle large inputs efficiently.\nrequirement pool:\n- Implement the eversion operation and ensure the array stops changing after a minimum number of eversions.\n- Ensure the solution is scalable and can handle large inputs within the given constraints.\n- Optimize the solution to minimize computational overhead.\nTo solve this problem, we will implement a function that simulates the eversion operation on an array and counts the number of iterations until the array stops changing. We will use Python's built-in data structures and list operations to efficiently manage the array and its partitions. The function will repeatedly apply the eversion operation until the array no longer changes, and then return the count of iterations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array into two parts based on a pivot element (x), where the left part contains elements less than or equal to x, and the right part contains elements greater than x. The array is then reconstructed by concatenating these two parts.\n    Explanation: The eversion operation is a way to rearrange the array based on a chosen pivot element, ensuring that the relative order of elements within each partition is preserved.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find an element in the array that appears more times than its value.\n    Explanation: For example, in the array [5, 5, 4, 4, 4], the number 4 appears three times, which is more than its value (3), so 4 is the desired output.\n\n# [degree adverb] \n    'largest': This adverb suggests that we need to find the largest integer that meets the condition of appearing more times than its value.\n    Explanation: For instance, in the array [4, 1, 2, 2, 3, 1], the number 2 appears twice, which is more than its value (2), making it the largest integer that meets the condition.\n\n# [code logic]\n    To implement the solution, we can follow these steps:\n    1. Iterate through the array to count the frequency of each element.\n    2. Check each element to see if it appears more times than its value.\n    3. Track the largest element that meets this condition.\n    4. Return the largest element found or -1 if no such element exists.\n\n# [edge case] \n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: In this case, the number 3 appears three times, which is more than its value (3), making it the largest integer that meets the condition.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    Explanation: Here, the number 2 appears two times, which is not more than its value (2), and similarly, no other number appears more times than its value. Therefore, the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to determine the correct output for edge cases.\n", "requirement analysis:\nThe primary requirement is to implement the eversion operation on an array and determine the minimum number of eversions required for the array to stabilize. The array is to be partitioned based on a pivot element, and the partitioning should be stable. The challenge lies in efficiently determining when the array stops changing, which requires comparing the array before and after each eversion operation.\nrequirement pool:\n- Implement the eversion operation on an array.\n- Ensure the partitioning is stable.\n- Determine the minimum number of eversions required for the array to stabilize.\n- Optimize the algorithm for handling large arrays efficiently.\n- Provide a user-friendly interface for easy interaction.\nTo implement the eversion operation and determine the minimum number of eversions required for the array to stabilize, we will use Python's built-in data structures and simple iterative logic. The eversion operation involves partitioning the array based on a pivot element, which will be the last element of the array for simplicity. We will use a stable partition function to ensure the array remains sorted relative to the pivot. We will iterate through the eversion process until the array no longer changes, counting the number of iterations as the required minimum number of eversions.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element, which is the last element of the array. The array is split into two parts: elements less than or equal to the pivot and elements greater than the pivot, maintaining the order within each part.\n    Explanation: The eversion operation helps in stabilizing the array by repeatedly partitioning it based on the last element until no further changes occur.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find elements greater than the pivot.\n    Explanation: In the eversion operation, the pivot is the last element of the array. We need to find elements that are strictly greater than this pivot to perform the partition.\n\n# [degree adverb] \n    'largest': This adverb suggests that we are looking for the maximum number of eversions required for the array to stabilize.\n    Explanation: The degree adverb \"largest\" implies that we need to determine the maximum number of eversions that could be performed before the array stops changing, which is the goal of the eversion operation.\n\n# [code logic]\n    To implement the eversion operation, we will follow these steps:\n    1. Iterate through the array, performing the eversion operation each time.\n    2. Use a stable partition function to split the array into two parts based on the pivot (last element of the array).\n    3. Continue the process until the array no longer changes.\n    4. Count the number of iterations as the minimum number of eversions required for the array to stabilize.\n\n# [edge case] \n    Edge case 1: [1, 1, 1, 1] = 0\n    Explanation: The array already contains all identical elements, so no eversions are needed, and the array does not change.\n    Edge case 2: [5, 4, 3, 2, 1] = 4\n    Explanation: The array is in descending order, so after each eversion, the array will be one element closer to being sorted. The array will stabilize after 4 eversions.\n    Edge case 3: [2, 1, 3, 3, 3] = 1\n    Explanation: The array will stabilize after the first eversion, as the pivot (3) will be the largest element, and the array will be split into [2, 1] and [3, 3, 3], with no further changes.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle these cases by checking if the array is already sorted or contains identical elements.\n", "requirement analysis:\nThe requirements involve implementing the eversion operation on an array, which requires understanding the partitioning logic and the conditions for the array to stop changing. The input is structured to handle multiple test cases, ensuring the product can handle large datasets efficiently. The output should provide clear and concise information about the number of eversions after which the array stops changing.\nrequirement pool:\n- Implement the eversion operation on the array\n- Handle multiple test cases efficiently\n- Ensure the array stops changing after a certain number of eversions\n- Provide clear and concise output for each test case\nTo implement the eversion operation on an array efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element, which can be optimized using efficient sorting techniques. We will iterate through the array, applying the eversion operation until the array stops changing. This approach ensures scalability and handles large datasets effectively.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves selecting a pivot element and partitioning the array into two parts based on the pivot, with the left part containing elements not greater than the pivot and the right part containing elements strictly greater than the pivot. The sequence of elements within each part remains unchanged.\n    Explanation: The eversion operation is a transformation applied to an array where a pivot element is selected, and the array is split into two parts around this pivot. This operation is repeated until the array no longer changes through subsequent eversions.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find the number of eversions after which the array stops changing.\n    Explanation: The phrase \"more than\" is used to determine the number of times the eversion operation is applied until the array no longer changes.\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the number of eversions after which the array stops changing, specifically for the largest possible eversion.\n    Explanation: The degree adverb \"largest\" suggests that we are looking for the maximum number of eversions that can be applied before the array stops changing.\n\n# [code logic]\n    To implement the eversion operation efficiently, we can use a loop to repeatedly apply the partitioning until the array no longer changes. Here's a high-level approach:\n    1. Read the input array.\n    2. Apply the eversion operation to the array.\n    3. Check if the array has changed.\n    4. Repeat the process until the array stops changing.\n    5. Return the number of eversions performed.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5] = 1\n    Explanation: In this case, the array is already sorted in ascending order, so after the first eversion, the array stops changing.\n    Edge case 2: [5, 4, 3, 2, 1] = 1\n    Explanation: In this case, the array is sorted in descending order, so after the first eversion, the array stops changing.\n    Edge case 3: [3, 1, 2, 4, 5] = 2\n    Explanation: In this case, the array undergoes two eversions before it stops changing. The first eversion partitions the array into [1, 2, 3] and [4, 5], and the second eversion partitions the left part into [1, 2] and [3].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic can handle the edge cases by checking the sorted nature of the array and counting the number of eversions until the array stops changing.\n", "requirement analysis:\nThe requirement involves understanding the eversion operation on an array and determining the number of iterations after which the array stops changing. This requires implementing a loop that continues to perform the eversion operation until the array no longer changes. The challenge lies in ensuring the solution is efficient enough to handle the upper limit of input size.\nrequirement pool:\n- Implement the eversion operation on the array\n- Ensure the solution is efficient and can handle large inputs\n- Provide a clear and user-friendly output for the number of eversions\n- Include error handling for invalid inputs\nTo implement the eversion operation on an array efficiently, we will use Python's built-in list operations and avoid unnecessary data manipulations. The eversion operation involves partitioning the array based on a pivot element, which is the last element of the array. We will use a loop to repeatedly apply this operation until the array no longer changes. This approach ensures that the solution is both efficient and easy to understand.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves selecting the last element as a pivot and partitioning the array into two parts based on the pivot value. The left part contains elements not greater than the pivot, and the right part contains elements strictly greater than the pivot. The sequence of elements within each part remains unchanged.\n    Explanation: The eversion operation is a specific way to rearrange the elements of an array by using a pivot element. This operation is repeated until the array no longer changes after an eversion.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the eversion operation efficiently, we can follow these steps:\n    1. Loop through the array and apply the eversion operation until the array no longer changes.\n    2. In each iteration, select the last element as the pivot.\n    3. Partition the array into two parts based on the pivot value.\n    4. Replace the array with the concatenation of the left and right parts.\n    5. Count the number of iterations until the array stops changing.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Expected output: 1\n    Explanation: The array is already sorted in ascending order, so after the first eversion, the array stops changing.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 5\n    Explanation: The array is sorted in descending order. Each eversion operation will reverse the array until it becomes sorted.\n\n    Edge case 3: [3, 3, 3, 3, 3]\n    Expected output: 1\n    Explanation: All elements are the same, so after the first eversion, the array stops changing.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic will work correctly for these cases.\n", "requirement analysis:\nThe requirement involves understanding the eversion operation on an array and determining the number of iterations after which the array stops changing. This requires a good understanding of array manipulation and a way to check for array stability.\nrequirement pool:\n- Implement the eversion operation on the array\n- Create a function to check when the array stops changing\n- Ensure the solution is efficient and can handle large arrays\n- Provide clear and concise output for the number of eversions\nTo implement the eversion operation on an array and determine the number of iterations after which the array stops changing, we will use Python's built-in data structures and simple iterative logic. The eversion operation involves partitioning the array based on a pivot element, which is the last element of the array. We will repeatedly apply this operation until the array no longer changes.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element, which is the last element of the array. The left part contains elements not greater than the pivot, and the right part contains elements strictly greater than the pivot.\n    Explanation: The eversion operation rearranges the array by selecting the last element as the pivot and partitioning the array into two parts based on this pivot. The left part includes elements less than or equal to the pivot, and the right part includes elements greater than the pivot. This process is repeated until the array no longer changes through eversion operations.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the eversion operation, we will follow these steps:\n    1. Read the input for each test case, including the number of elements and the elements themselves.\n    2. Apply the eversion operation iteratively until the array no longer changes.\n    3. Count the number of iterations (eversions) until the array stabilizes.\n    4. Output the count for each test case.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Expected output: 1\n    Explanation: The array is already sorted in ascending order, so after the first eversion, the array does not change.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 1\n    Explanation: The array is sorted in descending order, so after the first eversion, the array is rearranged into [4, 3, 2, 1, 5], which does not stabilize further.\n\n    Edge case 3: [3, 1, 2, 4, 5]\n    Expected output: 2\n    Explanation: After the first eversion, the array becomes [1, 2, 3, 4, 5]. After the second eversion, the array stabilizes as no further changes occur.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic will correctly determine the number of eversions for each test case, including the edge cases where the array is already sorted or in reverse order.\n", "requirement analysis:\nThe requirement involves implementing an algorithm that simulates the eversion operation on an array until it stops changing. The input consists of multiple test cases, each with a specified number of elements and their values. The output should indicate the number of eversions required for the array to stabilize. The algorithm must be efficient enough to handle the upper limits of input size.\nrequirement pool:\n- Implement the eversion operation algorithm\n- Handle multiple test cases efficiently\n- Ensure the output is clear and concise\n- Optimize the algorithm for large input sizes\nTo implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The key steps involve partitioning the array, comparing elements, and repeating the process until the array stabilizes. We will use a simple while loop to repeatedly apply the eversion operation until no more changes occur.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning an array into two parts based on a pivot element and then concatenating those parts, repeating this process until the array no longer changes.\n    Explanation: The eversion operation is a process of recursively partitioning and concatenating an array based on a chosen pivot until the array reaches a stable state where no further changes occur.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find elements in the array that appear more times than their value.\n    Explanation: For example, in the requirement, \"Return the largest integer that is more than zero and appears at least as many times as the integer itself,\" the phrase 'more than' is used to specify that the integer must appear more times than its own value.\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the biggest integer that meets the condition.\n    Explanation: In the requirement, \"Return the largest integer that is more than zero and appears at least as many times as the integer itself,\" the degree adverb 'largest' specifies that we need to find the biggest integer that appears more times than its value.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The key steps involve partitioning the array, comparing elements, and repeating the process until the array stops changing. We will use a simple while loop to repeatedly apply the eversion operation until the array stabilizes.\n\n# [edge case] \n    search([1, 1, 1, 1]) = 0\n    Explanation: In this case, the array does not change after the first eversion operation since all elements are the same. Therefore, the number of eversions required for the array to stop changing is 0.\n    search([5, 4, 3, 2, 1]) = 1\n    Explanation: In this case, the array will change after the first eversion operation, with the largest element at the end. Therefore, the number of eversions required for the array to stop changing is 1.\n    search([2, 1, 3, 3, 3]) = 2\n    Explanation: In this case, the array will change after the first eversion operation, with the largest element at the end. After the second eversion operation, the array will stabilize. Therefore, the number of eversions required for the array to stop changing is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the edge case where the array consists of identical elements.\n", "requirement analysis:\nThe problem requires partitioning the array based on a pivot and recursively applying the same operation until the array no longer changes. This is a classic problem that can be solved using a simple iterative approach. The challenge lies in efficiently handling large inputs within the given constraints.\nrequirement pool:\n- Implement the eversion operation as described\n- Ensure the solution handles multiple test cases efficiently\n- Optimize the algorithm for large inputs\n- Provide clear and concise output for each test case\n- Ensure the program is user-friendly and easy to understand\nWe will implement the eversion operation using a simple iterative approach that partitions the array based on a pivot and recursively applies the same operation until the array no longer changes. To efficiently handle large inputs, we will use Python's built-in list operations and avoid deep recursion by using a while loop.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning an array into two parts based on a pivot and then concatenating those parts, repeating this process until the array no longer changes.\n    Explanation: The eversion operation is a process of repeatedly partitioning and concatenating an array based on a pivot value until the array stabilizes. The pivot value is the last element of the array in this case.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests using a simple iterative approach to implement the eversion operation. Here's a detailed logic:\n    1. For each test case, read the array length and elements.\n    2. Implement the eversion operation by partitioning the array based on the last element and concatenating the parts until the array stops changing.\n    3. Count the number of iterations (eversions) until the array stabilizes.\n    4. Output the count for each test case.\n\n# [edge case] \n    search([1, 1, 1, 1]) = 0\n    Explanation: The array is already stable as all elements are the same, so no eversions are required.\n    search([5, 4, 3, 2, 1]) = 1\n    Explanation: The array is not stable, and after one eversion (partitioning around 5 and concatenating the parts), the array becomes [4, 3, 2, 1, 5], which is still not stable.\n    search([2, 1, 3, 3, 3]) = 2\n    Explanation: The array is not stable, and after two eversions (first partitioning around 3 and then around 2), the array becomes [1, 2, 3, 3, 3], which is stable.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle arrays where all elements are the same or where the array stabilizes after a few eversions.\n", "requirement analysis:\nThe requirement involves implementing an algorithm that simulates the eversion process on an array until it stops changing. The input consists of multiple test cases, each with a specified number of elements and their values. The output should reflect the number of iterations required for the array to stabilize. The challenge lies in ensuring the solution is efficient and can handle large inputs within reasonable time limits.\nrequirement pool:\n- Implement the eversion operation and partitioning logic\n- Ensure the algorithm can handle multiple test cases\n- Optimize the algorithm for performance and memory usage\n- Add error handling for invalid inputs\n- Provide detailed documentation and comments for code readability\nTo implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot and recursively applying the same operation until the array stops changing. We will use a helper function to perform the partitioning and a loop to repeatedly apply this operation until a stable state is reached.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot and recursively applying the same operation until the array stops changing.\n    Explanation: The eversion operation splits the array into two parts (\u2264 x) and ( > x) based on a pivot x, and then concatenates these parts. This process is repeated until the array no longer changes.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to compare the elements of the array to determine the pivot for partitioning.\n    Explanation: For example, in the requirement, we need to find elements that are greater than the pivot to partition the array correctly.\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the largest integer in the array to use as the pivot for partitioning.\n    Explanation: The largest integer will help in dividing the array into two parts effectively.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot and recursively applying the same operation until the array stops changing. We will use a helper function to perform the partitioning and a loop to repeatedly apply this operation until a stable state is reached.\n\n# [edge case] \n    search([1, 1, 1, 1]) = 0\n    Explanation: Since all elements are the same, the array does not change after the first eversion operation, so the number of eversions required is 0.\n    search([5, 4, 3, 2, 1]) = 1\n    Explanation: The largest element is 5, and after the first eversion operation, the array becomes [4, 3, 2, 1, 5], which stops changing.\n    search([2, 1, 3, 3, 2]) = 2\n    Explanation: The largest element is 3, and after the first eversion operation, the array becomes [2, 1, 2, 3, 3]. After the second eversion operation, the array becomes [1, 2, 2, 3, 3], which stops changing.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic for partitioning and eversion operations naturally handles arrays with all identical elements without additional code.\n", "requirement analysis:\nThe primary requirement is to determine the minimum number of eversions after which the array stops changing. This involves repeatedly partitioning the array based on a pivot element and checking if the array remains stable after each partition. The challenge lies in efficiently handling large arrays and ensuring the solution is both accurate and performant.\nrequirement pool:\n- Implement the eversion operation to partition the array.\n- Ensure the partition is stable and the array remains unchanged.\n- Output the minimum number of eversions required for the array to stop changing.\n- Optimize the algorithm for handling large datasets.\n- Include error handling to manage edge cases and unexpected inputs.\nTo solve this problem, we will implement a function that repeatedly partitions the array based on a pivot element until the array no longer changes. We will use a stable partition algorithm to ensure the array remains unchanged after each partition. The function will count the number of partitions required to reach a stable state and return this count.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'array partitioning': The process of dividing an array into two parts based on a pivot element, where the left part contains elements less than or equal to the pivot and the right part contains elements greater than the pivot. This process is stable, meaning the relative order of elements in each part remains unchanged.\n\n    'stable partition': A partition method that ensures the relative order of elements in each part is preserved.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the pivot element must be greater than the elements in the array to partition it.\n\n# [degree adverb] \n    'largest': Indicates that the pivot element should be the largest in the array to ensure the most significant change in the array.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the input array.\n    2. Perform the eversion operation iteratively until the array no longer changes.\n    3. Count the number of iterations required to reach a stable state.\n    4. Output the count.\n\n# [edge case] \n    Edge case 1: [1, 1, 1, 1] = 0\n    Explanation: The array already consists of identical elements, so no eversion is needed.\n    Edge case 2: [2, 1, 3, 4, 5] = 1\n    Explanation: The first eversion will partition the array into [1, 2, 3, 4, 5] and [], resulting in [1, 2, 3, 4, 5]. The array stops changing after one eversion.\n    Edge case 3: [5, 4, 3, 2, 1] = 5\n    Explanation: Each eversion will only shift the largest element to the end, requiring five eversions to sort the array in ascending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the logic provided in the plan is sufficient to handle arrays with identical elements or already sorted arrays.\n"], "scores": [], "pass_results": [false, true, false, false, false, false, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 52, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "mutate_method": "condense_two2one", "parent_index": 55}
