{"name": "1619_H. Permutation and Queries", "description": "You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.\n\nThere are two types of queries:\n\n  * 1 x y \u2014 swap p_x and p_y. \n  * 2 i k \u2014 print the number that i will become if we assign i = p_i k times. \n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.", "tags": ["brute force", "data structures", "divide and conquer", "two pointers"], "difficulty": 14, "id": 1619, "sample_io": [{"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n3\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n", "output": ["4\n1\n2\n"]}], "test_list": [{"input": "1 1\n1\n2 1 1\n", "output": ["1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 6\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n8\n4\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 3\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n8\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 4\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["7\n6\n8\n9\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 83 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 6\n2 36 69\n1 100 59\n", "output": ["19\n6\n40\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 7 9\n2 9 16\n1 3 6\n", "output": ["10\n6\n8\n8\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n5\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 4\n1 1 3\n2 1 2\n", "output": ["4\n1\n2\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n59\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n4\n9\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 1 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n4\n2\n4\n3\n5\n1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 68\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n6\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n1\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n1 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n1\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 7 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n4\n8\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n1\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 2 2\n1 1 3\n2 1 2\n", "output": ["4\n4\n2\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 44 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 1\n2 36 69\n1 100 59\n", "output": ["21\n6\n40\n54\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 2\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n1\n2\n3\n3\n5\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 4\n1 1 2\n2 1 2\n", "output": ["4\n1\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 4 5\n2 5 1\n2 5 3\n2 1 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n4\n4\n2\n4\n3\n5\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n1\n5\n2\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n2\n3\n3\n1\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n1 1 3\n2 1 2\n", "output": ["4\n2\n2\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 44 22\n2 1 72\n2 65 13\n1 18 37\n1 19 89\n1 86 1\n2 36 69\n1 100 59\n", "output": ["21\n6\n57\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n7\n5\n2\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n2\n3\n5\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n7\n5\n10\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 2\n", "output": ["3\n5\n4\n2\n3\n5\n3\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n9\n5\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 7 9\n2 9 9\n1 3 6\n", "output": ["10\n6\n8\n7\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 2 72\n2 65 8\n1 18 37\n1 19 89\n1 86 3\n2 36 69\n1 100 59\n", "output": ["71\n16\n40\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n9\n8\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 1 6\n1 7 9\n2 9 16\n1 3 6\n", "output": ["10\n6\n8\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 1 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n9\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n1\n2\n3\n3\n1\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 2 2\n1 2 3\n2 1 2\n", "output": ["4\n4\n1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 44 44\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 1\n2 36 69\n1 100 59\n", "output": ["64\n6\n40\n54\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 4\n2 5 2\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n3\n1\n2\n3\n3\n5\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 0\n2 1 4\n1 1 2\n2 1 2\n", "output": ["3\n1\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["7\n6\n7\n5\n2\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 4 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n2\n3\n1\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n6\n8\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 4 9\n2 8 8\n1 3 6\n", "output": ["7\n6\n7\n8\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n1 3 6\n", "output": ["10\n3\n8\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 15\n1 3 6\n", "output": ["10\n3\n8\n6\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 83 22\n2 1 72\n2 65 10\n1 18 37\n1 19 89\n1 86 6\n2 36 69\n1 100 59\n", "output": ["19\n6\n47\n54\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n2 1 3\n2 1 2\n", "output": ["4\n1\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 1\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n4\n4\n3\n3\n1\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 2 2\n1 1 3\n2 2 2\n", "output": ["4\n4\n5\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 4 5\n2 5 1\n2 5 3\n2 1 4\n1 5 2\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n4\n4\n2\n4\n3\n1\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n6\n5\n3\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n1\n4\n2\n3\n3\n1\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 4 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n3\n3\n5\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["2\n6\n7\n5\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 5 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n9\n7\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 5 6\n1 10 6\n2 3 3\n1 1 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n9\n3\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 5 3\n2 5 8\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n1\n2\n2\n3\n1\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 0\n2 1 3\n1 1 2\n2 1 2\n", "output": ["3\n5\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n6\n2\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 10\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n1 3 6\n", "output": ["10\n3\n7\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 0\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n4\n5\n3\n3\n1\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n6\n5\n7\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 2\n2 2 7\n2 4 1\n", "output": ["3\n1\n4\n2\n3\n2\n1\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 5 6\n2 5 9\n2 8 2\n1 3 6\n", "output": ["10\n6\n9\n7\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 3\n1 6 2\n2 9 0\n1 4 6\n1 5 9\n2 9 8\n1 3 7\n", "output": ["10\n9\n9\n9\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 5 3\n2 5 8\n1 5 4\n2 5 3\n2 2 7\n2 5 2\n", "output": ["3\n5\n1\n2\n2\n3\n1\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n6\n8\n4\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 0\n2 5 3\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n4\n5\n2\n3\n1\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n7\n5\n7\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 6\n1 5 4\n2 5 2\n2 2 7\n2 4 1\n", "output": ["3\n1\n4\n2\n4\n2\n1\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 8 8\n1 4 6\n", "output": ["2\n6\n7\n6\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 3\n1 6 2\n2 9 0\n1 4 6\n2 5 9\n2 9 8\n1 3 7\n", "output": ["10\n9\n9\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n6\n8\n4\n4\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n8\n8\n8\n"]}, {"input": "5 7\n2 3 5 1 4\n2 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 6\n1 5 4\n2 5 2\n2 2 7\n2 4 1\n", "output": ["3\n1\n4\n2\n4\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 8 8\n2 4 6\n", "output": ["2\n6\n7\n6\n10\n4\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n6\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 13\n1 3 6\n", "output": ["10\n6\n8\n8\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 8 6\n2 4 6\n", "output": ["2\n6\n7\n6\n8\n4\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 5\n2 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n8\n8\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n2 5 4\n2 5 3\n2 2 5\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n2\n2\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 0\n", "output": ["4\n1\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 4\n2 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n4\n8\n7\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 1 4\n1 5 4\n2 4 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n4\n2\n4\n4\n5\n1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 3\n2 1 72\n2 65 8\n1 18 68\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["55\n6\n40\n6\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 2\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n8\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 1 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n4\n5\n2\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n2 1 3\n2 1 2\n", "output": ["4\n2\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n1 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n5\n4\n4\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 8\n1 10 6\n2 4 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n9\n4\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n2 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 8\n2 9 8\n1 3 6\n", "output": ["10\n10\n6\n9\n2\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 0\n1 1 4\n1 1 2\n2 1 2\n", "output": ["3\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 4\n2 1 3\n2 1 2\n", "output": ["4\n4\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 1 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n2\n3\n4\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n2 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n6\n8\n6\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 7 6\n2 3 3\n1 6 2\n2 5 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n5\n5\n3\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 4 3\n2 5 4\n1 5 1\n2 5 3\n2 2 12\n2 4 1\n", "output": ["3\n5\n4\n3\n3\n5\n2\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 2\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 10\n2 4 2\n", "output": ["3\n5\n1\n2\n3\n5\n3\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 1 3\n2 5 8\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n1\n5\n2\n3\n1\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 10\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 1 8\n1 3 6\n", "output": ["7\n6\n7\n5\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 9 8\n1 4 6\n", "output": ["2\n6\n7\n5\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 6\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 8 8\n1 4 6\n", "output": ["2\n3\n7\n6\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 3 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n6\n8\n8\n4\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 2 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n8\n5\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 6\n1 3 6\n2 6 9\n2 8 8\n2 4 6\n", "output": ["2\n6\n8\n6\n10\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 4\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 13\n1 3 6\n", "output": ["10\n7\n4\n5\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 0\n1 3 6\n2 6 9\n2 8 6\n2 4 6\n", "output": ["2\n6\n9\n6\n8\n4\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 5\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 4\n1 1 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n3\n4\n5\n2\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n2 1 3\n2 1 1\n", "output": ["4\n2\n5\n5\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 0\n2 5 4\n2 5 2\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 2\n", "output": ["3\n3\n1\n2\n3\n3\n5\n2\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 0\n2 5 4\n1 5 1\n2 1 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n5\n3\n4\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 9 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 10 10\n1 3 6\n", "output": ["10\n6\n1\n5\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n5\n5\n8\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n2 1 2\n2 1 1\n", "output": ["4\n2\n1\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 9 6\n2 4 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 10 10\n1 3 6\n", "output": ["10\n8\n1\n5\n8\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 0\n2 1 2\n2 1 1\n", "output": ["4\n3\n1\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 9 6\n1 4 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 10 10\n1 3 6\n", "output": ["10\n6\n5\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 5\n2 8 10\n1 3 8\n", "output": ["10\n6\n5\n2\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 6\n1 6 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n2\n8\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n1 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n", "output": ["3\n5\n4\n2\n2\n2\n4\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 13\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 1\n2 36 69\n1 100 59\n", "output": ["33\n89\n40\n94\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 1 9\n2 9 16\n1 3 6\n", "output": ["10\n6\n8\n6\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n1 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["95\n40\n32\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 5 2\n2 9 5\n1 4 6\n1 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n10\n5\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 4 5\n2 4 1\n2 5 3\n2 1 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n4\n1\n2\n4\n3\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 1\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n4\n4\n2\n3\n3\n1\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n1 2 3\n2 1 2\n", "output": ["4\n2\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 2 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n2\n4\n2\n3\n5\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 6\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["9\n6\n7\n5\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 8 8\n1 3 6\n", "output": ["10\n9\n8\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n2 7 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 8\n2 9 8\n1 3 6\n", "output": ["10\n9\n6\n9\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 1 2\n2 9 4\n1 4 6\n1 8 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n9\n2\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 3\n1 1 2\n2 1 2\n", "output": ["4\n5\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 4\n1 1 4\n2 1 2\n", "output": ["4\n4\n3\n"]}, {"input": "5 2\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 4 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n2 5 8\n2 9 8\n1 3 6\n", "output": ["10\n6\n8\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 3\n2 4 8\n1 3 6\n", "output": ["10\n6\n8\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 5\n1 7 6\n1 7 9\n2 3 1\n1 6 2\n2 9 5\n1 4 6\n2 4 9\n2 8 8\n1 5 6\n", "output": ["7\n4\n7\n8\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n2 3 6\n", "output": ["10\n3\n8\n7\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 5 6\n1 5 8\n2 4 15\n1 3 6\n", "output": ["10\n3\n8\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 3\n2 1 3\n2 1 2\n", "output": ["4\n5\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 4 5\n2 1 1\n2 5 3\n2 1 4\n1 5 2\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n4\n2\n2\n4\n3\n1\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 10\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["2\n6\n3\n5\n10\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 17\n2 4 2\n", "output": ["3\n5\n4\n2\n3\n5\n5\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n1 9 5\n1 5 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n5\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 5\n1 1 6\n1 7 10\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n1 3 6\n", "output": ["7\n3\n7\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 5\n1 6 2\n2 9 0\n1 4 6\n1 5 9\n2 9 8\n1 3 7\n", "output": ["10\n2\n9\n9\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 5 3\n2 5 8\n1 5 4\n1 5 3\n2 2 7\n2 5 2\n", "output": ["3\n5\n1\n2\n2\n3\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 1\n2 9 22\n2 3 6\n", "output": ["10\n6\n8\n4\n2\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 7 6\n1 4 6\n2 5 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n3\n8\n8\n"]}, {"input": "5 7\n2 3 5 1 4\n1 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 6\n1 5 4\n2 5 2\n2 2 7\n2 4 1\n", "output": ["5\n5\n5\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n2 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 13\n1 3 6\n", "output": ["10\n6\n9\n4\n2\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n1 5 3\n2 1 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n1\n4\n4\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 0\n2 5 4\n2 5 0\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 2\n", "output": ["3\n3\n5\n2\n3\n3\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 1\n1 6 2\n2 9 4\n2 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n4\n8\n6\n8\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 4 3\n2 5 4\n1 5 1\n2 5 3\n2 4 12\n2 4 1\n", "output": ["3\n5\n4\n3\n3\n5\n4\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 2\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 10\n2 4 3\n", "output": ["3\n5\n1\n2\n3\n5\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 9 8\n1 4 6\n", "output": ["2\n6\n7\n6\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 3 5\n1 1 6\n1 7 9\n2 9 22\n2 3 4\n", "output": ["10\n6\n8\n8\n4\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 6\n1 3 6\n2 6 7\n2 8 8\n2 4 6\n", "output": ["2\n6\n8\n4\n10\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 0\n2 5 4\n2 5 4\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 2\n", "output": ["3\n3\n3\n2\n3\n3\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 9\n2 8 10\n2 3 6\n", "output": ["10\n6\n5\n5\n8\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n2 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 9\n2 8 10\n1 3 8\n", "output": ["10\n8\n6\n9\n10\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 6\n1 6 2\n2 3 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n2\n7\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 4\n1 7 6\n1 10 6\n2 3 2\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 5\n", "output": ["7\n1\n8\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 2\n1 4 6\n1 1 9\n2 9 16\n1 3 6\n", "output": ["10\n6\n2\n6\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 5 2\n2 9 5\n1 4 6\n1 5 8\n2 8 8\n1 3 6\n", "output": ["10\n6\n10\n8\n"]}, {"input": "5 4\n5 3 4 2 1\n1 3 1\n2 2 2\n1 1 5\n2 1 2\n", "output": ["5\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 6\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 6\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["9\n6\n8\n5\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 9 9\n2 8 8\n1 3 8\n", "output": ["10\n6\n9\n9\n8\n"]}, {"input": "5 4\n5 3 4 2 1\n2 1 1\n2 1 3\n1 1 2\n2 1 2\n", "output": ["5\n5\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 2 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n2 3 6\n", "output": ["10\n10\n8\n7\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 5 3\n1 5 8\n2 4 15\n1 3 6\n", "output": ["10\n3\n8\n1\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n1 9 5\n1 5 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 9\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n1 5 6\n", "output": ["7\n6\n2\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 4 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 1\n2 9 22\n2 3 6\n", "output": ["10\n9\n6\n4\n4\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 1\n1 8 5\n1 7 6\n2 3 3\n2 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 13\n1 3 6\n", "output": ["9\n6\n9\n4\n2\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n2 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 9\n2 8 10\n2 3 6\n", "output": ["10\n7\n6\n5\n3\n2\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 11\n1 6 2\n2 3 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n7\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 2 3\n1 10 1\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n2 3 6\n", "output": ["10\n10\n6\n3\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 9\n1 7 6\n1 10 4\n2 3 3\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n1 5 6\n", "output": ["7\n8\n6\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 2 3\n1 10 1\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n2 3 8\n", "output": ["10\n10\n6\n3\n10\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 1 3\n1 6 2\n1 9 5\n1 5 6\n3 5 9\n2 8 8\n1 3 6\n", "output": ["10\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 9\n1 7 6\n1 10 4\n2 3 3\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 8 22\n1 5 6\n", "output": ["7\n8\n6\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 6 9\n2 3 3\n1 6 2\n2 9 6\n1 3 6\n2 6 12\n2 8 8\n1 4 6\n", "output": ["2\n6\n9\n6\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 2 3\n1 10 1\n2 9 4\n1 4 6\n1 5 8\n2 3 8\n2 3 8\n", "output": ["10\n10\n6\n10\n10\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 2 3\n1 6 2\n1 9 5\n1 5 6\n3 5 9\n2 8 8\n1 3 6\n", "output": ["10\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 9\n1 7 6\n1 10 4\n2 3 3\n1 6 2\n2 9 8\n1 1 6\n1 7 9\n2 8 22\n1 5 6\n", "output": ["7\n8\n4\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 4\n1 7 6\n1 10 3\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["7\n2\n4\n9\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 1 2\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n3\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 2 4\n1 1 3\n2 1 2\n", "output": ["4\n3\n2\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 37\n1 86 5\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n51\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 2 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n4\n2\n1\n3\n5\n1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 10\n1 18 68\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["71\n6\n47\n6\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 0\n", "output": ["3\n5\n4\n2\n3\n3\n1\n5\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 2\n2 5 3\n2 5 7\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n1\n2\n1\n3\n5\n1\n"]}, {"input": "5 3\n5 3 4 2 1\n2 3 1\n2 1 4\n1 1 2\n2 1 2\n", "output": ["4\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n1 3 5\n2 4 5\n2 5 1\n2 5 3\n2 1 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["1\n5\n5\n1\n3\n4\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n1 3 1\n2 3 2\n1 1 3\n2 1 2\n", "output": ["1\n1\n"]}], "task_id": "codecontest/146", "prompt": "You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once; for example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations. However, [1, 2, 4] and [4, 3, 2, 1, 2] are not considered permutations because they do not include each integer exactly once within the range. You must execute q queries. \n\nThere are two types of queries:\n\n  * 1 x y \u2014 swap p_x and p_y.\n  * 2 i k \u2014 print the number that i will become if we assign i = p_i repeatedly k times.\n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.", "repair_prompt": ["You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once; for example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations. However, [1, 2, 4] and [4, 3, 2, 1, 2] are not considered permutations because they do not include each integer exactly once within the range. You must execute q queries. \n\nThere are two types of queries:\n\n  * 1 x y \u2014 swap p_x and p_y.\n  * 2 i k \u2014 print the number that i will become if we assign i = p_i repeatedly k times.\n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nWrite a main() function and use input() function to read input from stdin", " You are provided with a sequence p consisting of n elements. This sequence is a permutation of numbers from 1 to n, meaning each number appears exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are valid permutations, while [1, 2, 4] and [4, 3, 2, 1, 2] are not. You will receive a series of queries to perform on this permutation.\n\nThe queries come in two forms:\n\n1. Swap the elements at positions x and y in\n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nWrite a main() function and use input() function to read input from stdin", " You are given a permutation p of n elements, which is an array of length n containing each integer from 1 to n exactly once. You must execute q queries, with two types: 1 x y to swap p_x and p_y, and 2 i k to print the number that i will become if we assign i = p_i repeatedly k times.\n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\n## main.py\n\nimport sys\n\ndef swap_elements(p: list[int], x: int, y: int) -> list[int]:\n    \"\"\"\n    Swaps the elements at positions x and y in the permutation list p.\n    \n    Args:\n        p (list[int]): The permutation list.\n        x (int): The index of the first element to swap.\n        y (int): The index of the second element to swap.\n    \n    Returns:\n        list[int]: The permutation list after swapping.\n    \"\"\"\n    p[x], p[y] = p[y], p[x]\n    return p\n\ndef apply_permutation(p: list[int], i: int, k: int) -> int:\n    \"\"\"\n    Applies the permutation repeatedly k times to the element at position i.\n    \n    Args:\n        p (list[int]): The permutation list.\n        i (int): The index of the element to apply the permutation to.\n        k (int): The number of times to apply the permutation.\n    \n    Returns:\n        int: The final value of the element after k applications of the permutation.\n    \"\"\"\n    current_index = i\n    for _ in range(k):\n        current_index = p[current_index] - 1  # Convert to 0-based index\n    return p[current_index]\n\n# Read input\nn, q = map(int, sys.stdin.readline().split())\np = list(map(int, sys.stdin.readline().split()))\n\n# Process queries\nfor _ in range(q):\n    query = list(map(int, sys.stdin.readline().split()))\n    if query[0] == 1:\n        x, y = query[1] - 1, query[2] - 1  # Convert to 0-based index\n        p = swap_elements(p, x, y)\n    elif query[0] == 2:\n        i, k = query[1] - 1, query[2]  # Convert to 0-based index\n        result = apply_permutation(p, i, k)\n        print(result)\n", "from typing import List\n## main.py\n\ndef swap_elements(p, x, y):\n    \"\"\"\n    Swaps the elements at positions x and y in the permutation array p.\n    \n    Args:\n        p (list): The permutation array.\n        x (int): The index of the first element to swap.\n        y (int): The index of the second element to swap.\n    \n    Returns:\n        list: The permutation array after the swap.\n    \"\"\"\n    p[x], p[y] = p[y], p[x]\n    return p\n\ndef compute_final_value(p, i, k):\n    \"\"\"\n    Computes the final value of element i after repeatedly applying the permutation k times.\n    \n    Args:\n        p (list): The permutation array.\n        i (int): The index of the element to compute the final value for.\n        k (int): The number of times to apply the permutation.\n    \n    Returns:\n        int: The final value of element i after k applications of the permutation.\n    \"\"\"\n    n = len(p)\n    for _ in range(k):\n        i = p[i] - 1  # Convert to 0-based index\n    return p[i]\n\n# Provide the Interface\nn, q = map(int, input().split())\np = list(map(int, input().split()))\n\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        x, y = query[1] - 1, query[2] - 1\n        p = swap_elements(p, x, y)\n    elif query[0] == 2:\n        i, k = query[1] - 1, query[2]\n        result = compute_final_value(p, i, k)\n        print(result)\n", "from typing import List\nfrom typing import List\n\ndef handle_queries(n: int, permutation: List[int], queries: List[List[int]]) -> List[int]:\n    results = []\n    \n    for query in queries:\n        query_type = query[0]\n        if query_type == 1:\n            x, y = query[1] - 1, query[2] - 1  # Convert to 0-based index\n            permutation[x], permutation[y] = permutation[y], permutation[x]\n        elif query_type == 2:\n            i, k = query[1] - 1, query[2]  # Convert to 0-based index\n            current = i\n            for _ in range(k):\n                current = permutation[current]\n            results.append(current + 1)  # Convert back to 1-based index\n    \n    return results\n\n# Read input\nn, q = map(int, input().split())\npermutation = list(map(int, input().split()))\nqueries = [list(map(int, input().split())) for _ in range(q)]\n\n# Process queries and output results\nresult = handle_queries(n, permutation, queries)\nfor res in result:\n    print(res)\n", "from typing import List\n## main.py\n\ndef swap_elements(p: list, x: int, y: int) -> list:\n    # Swap elements at positions x and y\n    p[x-1], p[y-1] = p[y-1], p[x-1]\n    return p\n\ndef get_element(p: list, i: int) -> int:\n    # Retrieve the value at position i\n    return p[i-1]\n\n# Read the input values for n, q, and the permutation p\nn, q = map(int, input().split())\np = list(map(int, input().split()))\n\n# Process each query\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        # For type 1 query, swap the elements at positions x and y\n        p = swap_elements(p, query[1], query[2])\n    elif query[0] == 2:\n        # For type 2 query, retrieve the k-th element starting from the i-th position\n        result = get_element(p, query[1])\n        print(result)\n", "from typing import List\n## main.py\n\ndef handle_queries(n: int, permutation: list, queries: list) -> list:\n    # Initialize the result list to store the answers for each query\n    results = []\n    \n    # Process each query\n    for query in queries:\n        t = query[0]  # Type of query\n        if t == 1:\n            # Query type 1: Swap elements at positions x and y\n            x, y = query[1] - 1, query[2] - 1  # Convert to 0-based index\n            # Swap the elements\n            permutation[x], permutation[y] = permutation[y], permutation[x]\n        elif t == 2:\n            # Query type 2: Retrieve value at position i\n            i = query[1] - 1  # Convert to 0-based index\n            # Append the value at the specified position to the results list\n            results.append(permutation[i])\n    \n    return results\n\n# Read input from stdin\nn, q = map(int, input().split())\np = list(map(int, input().split()))\nqueries = []\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    queries.append(query)\n\n# Call the function and print the results\nresult = handle_queries(n, p, queries)\nfor res in result:\n    print(res)\n", "from typing import List\nfrom typing import List\n\ndef process_queries(n: int, permutation: List[int], queries: List[List[int]]) -> List[int]:\n    results = []\n    \n    for query in queries:\n        query_type = query[0]\n        if query_type == 1:\n            x, y = query[1] - 1, query[2] - 1  # Convert to 0-based index\n            permutation[x], permutation[y] = permutation[y], permutation[x]\n        elif query_type == 2:\n            i = query[1] - 1  # Convert to 0-based index\n            results.append(permutation[i])\n    \n    return results\n\n# Interface\nn, q = map(int, input().split())\np = list(map(int, input().split()))\nqueries = [list(map(int, input().split())) for _ in range(q)]\nresult = process_queries(n, p, queries)\nfor r in result:\n    print(r)\n", "from typing import List\nfrom typing import List\n\ndef handle_queries(n: int, permutation: List[int], queries: List[List[int]]) -> List[int]:\n    def apply_permutation(perm, pos):\n        return perm[pos - 1]\n\n    def swap_elements(perm, x, y):\n        perm[x - 1], perm[y - 1] = perm[y - 1], perm[x - 1]\n        return perm\n\n    results = []\n    for query in queries:\n        query_type = query[0]\n        if query_type == 1:\n            x, y = query[1], query[2]\n            permutation = swap_elements(permutation, x, y)\n        elif query_type == 2:\n            i, k = query[1], query[2]\n            for _ in range(k):\n                i = apply_permutation(permutation, i)\n            results.append(i)\n    return results\n\n# Example usage:\n# n, q = map(int, input().split())\n# p = list(map(int, input().split()))\n# queries = [list(map(int, input().split())) for _ in range(q)]\n# result = handle_queries(n, p, queries)\n# for res in result:\n#     print(res)\n", "from typing import List\nfrom typing import List\n\ndef handle_queries(n: int, permutation: List[int], queries: List[List[int]]) -> List[int]:\n    def swap(p: List[int], x: int, y: int):\n        p[x], p[y] = p[y], p[x]\n    \n    def find_final_position(p: List[int], i: int, k: int) -> int:\n        for _ in range(k):\n            i = p[i - 1]\n        return i\n    \n    results = []\n    for query in queries:\n        query_type = query[0]\n        if query_type == 1:\n            x, y = query[1] - 1, query[2] - 1  # Convert to 0-based index\n            swap(permutation, x, y)\n        elif query_type == 2:\n            i, k = query[1] - 1, query[2]  # Convert to 0-based index\n            final_position = find_final_position(permutation, i, k)\n            results.append(final_position + 1)  # Convert back to 1-based index\n    return results\n\n# Read input\nn = int(input())\npermutation = list(map(int, input().split()))\nqueries = []\nq = int(input())\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    queries.append(query)\n\n# Process queries and output results\nresult = handle_queries(n, permutation, queries)\nfor res in result:\n    print(res)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef swap_elements(p: list[int], x: int, y: int) -> list[int]:\n    \"\"\"\n    Swaps the elements at positions x and y in the permutation list p.\n    \n    Args:\n        p (list[int]): The permutation list.\n        x (int): The position of the first element to swap.\n        y (int): The position of the second element to swap.\n    \n    Returns:\n        list[int]: The permutation list after the swap.\n    \"\"\"\n    p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n    return p\n\ndef apply_permutation(p: list[int], i: int, k: int) -> int:\n    \"\"\"\n    Applies the permutation repeatedly k times starting from element i.\n    \n    Args:\n        p (list[int]): The permutation list.\n        i (int): The starting position.\n        k (int): The number of times to apply the permutation.\n    \n    Returns:\n        int: The final position after k repetitions.\n    \"\"\"\n    original_i = i\n    for _ in range(k):\n        i = p[i - 1]\n    return i\n\n# Read the input\nn, q = map(int, sys.stdin.readline().split())\np = list(map(int, sys.stdin.readline().split()))\n\n# Process each query\nfor _ in range(q):\n    query = list(map(int, sys.stdin.readline().split()))\n    if query[0] == 1:\n        p = swap_elements(p, query[1], query[2])\n    elif query[0] == 2:\n        result = apply_permutation(p, query[1], query[2])\n        print(result)\n", "from typing import List\nfrom typing import List\n\ndef handle_queries(n: int, permutation: List[int], queries: List[List[int]]) -> List[int]:\n    results = []\n    \n    for query in queries:\n        query_type = query[0]\n        if query_type == 1:\n            x, y = query[1] - 1, query[2] - 1  # Convert to 0-based index\n            permutation[x], permutation[y] = permutation[y], permutation[x]\n        elif query_type == 2:\n            i, k = query[1] - 1, query[2]  # Convert to 0-based index\n            current_index = i\n            for _ in range(k):\n                current_index = permutation[current_index] - 1  # Convert to 0-based index\n            results.append(permutation[current_index] + 1)  # Convert to 1-based index for output\n    \n    return results\n\n# Read input\nn = int(input())\npermutation = list(map(int, input().split()))\nqueries = [list(map(int, input().split())) for _ in range(int(input()))]\n\n# Process queries and output results\nresult = handle_queries(n, permutation, queries)\nfor r in result:\n    print(r)\n"], "plans": ["requirement analysis:\nThe requirements involve handling permutations and executing queries on them. The system needs to be able to swap elements and determine the result of repeatedly applying the permutation to an element. The performance must be efficient, especially for large inputs and multiple queries.\nrequirement pool:\n- Implement a function to swap two elements in the permutation.\n- Implement a function to repeatedly apply the permutation to an element.\n- Ensure the system can handle large inputs efficiently.\n- Provide clear and accurate results for each query.\n- Develop a user-friendly interface for easy interaction.\nTo implement this system, we will use Python due to its simplicity and efficiency. We will focus on handling permutations and executing queries efficiently. We will use a list to represent the permutation and provide functions to swap elements and determine the result of repeatedly applying the permutation. We will also ensure the system can handle large inputs by optimizing the algorithms.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'permutation': a sequence of integers where each integer from 1 to n appears exactly once.\n    Explanation: A permutation is a rearrangement of a set of numbers into a sequence. For example, [1, 2, 3] is a permutation of [3, 1, 2].\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan involves handling two types of queries:\n    1. Swapping two elements in the permutation.\n    2. Determining the result of repeatedly applying the permutation to an element.\n\n    Steps:\n    1. Read the input for the permutation and the number of queries.\n    2. For each query:\n        - If the query type is 1, swap the elements at positions x and y in the permutation.\n        - If the query type is 2, determine the result of repeatedly applying the permutation to the element at position i, k times.\n    3. Output the result of each second-type query.\n\n# [edge case]\n    edge case1 = 4\n    Explanation: In the example input, the permutation is [5, 3, 4, 2, 1]. For the query 2 3 1, starting with p_3 = 4, applying p_4, p_2, p_3, p_4, p_2, ... repeatedly, we get the sequence [4, 2, 3, 1, 5], and the final value for position 3 is 4.\n\n    edge case2 = 1\n    Explanation: For the query 2 1 2, starting with p_1 = 5, applying p_5, p_1, p_5, p_1, ... repeatedly, we get the sequence [5, 1, 5, 1], and the final value for position 1 is 1.\n\n    edge case3 = 2\n    Explanation: For the query 2 1 2, starting with p_1 = 5, applying p_5, p_1, p_5, p_1, ... repeatedly, we get the sequence [5, 1, 5, 1], and the final value for position 1 is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to solve the problem.\n", "requirement analysis:\nThe project requires handling permutations and executing queries on them. The application must be able to swap elements and compute the final value of an element after a specified number of iterations. The system should be robust enough to handle large inputs efficiently.\nrequirement pool:\n- Implement a function to swap elements in the permutation.\n- Develop a function to compute the final value of an element after repeated application of the permutation.\n- Ensure the application can handle large inputs within a reasonable time frame.\n- Design a user-friendly interface for easy interaction.\n- Optimize the application for performance and scalability.\nTo implement this application, we will use Python due to its simplicity and efficiency. We will focus on handling permutations and executing queries efficiently. We will use a list to represent the permutation and provide functions to swap elements and compute the final value of an element after repeated applications. We will optimize the application for performance and scalability by using efficient data structures and algorithms.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'permutation': A sequence of integers where each integer from 1 to n appears exactly once.\n    Explanation: A permutation is a rearrangement of a set of numbers into a sequence. For example, [1, 2, 3] is a permutation of [3, 1, 2].\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan involves handling two types of queries:\n    1. Swap two elements in the permutation.\n    2. Determine the final value of an element after repeatedly applying the permutation.\n\n    Steps to implement:\n    1. Read the input values for n, q, the permutation array, and the queries.\n    2. For each query of type 1, swap the elements at positions x and y in the permutation array.\n    3. For each query of type 2, determine the final value of element i after k applications of the permutation.\n    4. Output the results for each query of type 2.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [core concept]\n    'query execution': Handling multiple types of queries efficiently.\n    Explanation: The plan involves reading and processing each query in an efficient manner to ensure the application can handle a large number of queries.\n\n# [phrase showing quantity relationship]\n    'repeatedly': Indicates that an operation should be performed multiple times.\n    Explanation: In the requirement, 'repeatedly' is used to describe the process of applying the permutation multiple times.\n\n# [degree adverb] \n    'largest': Indicates that the search should find the largest integer that meets the condition.\n    Explanation: The requirement uses 'largest' to specify that we need to find the biggest integer that appears at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan involves handling two types of queries:\n    1. Swap two elements in the permutation.\n    2. Determine the final value of an element after repeatedly applying the permutation.\n\n    Steps to implement:\n    1. Read the input values for n, q, the permutation array, and the queries.\n    2. For each query of type 1, swap the elements at positions x and y in the permutation array.\n    3. For each query of type 2, determine the final value of element i after k applications of the permutation.\n    4. Output the results for each query of type 2.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [core concept]\n    'permutation': A sequence of integers where each integer from 1 to n appears exactly once.\n    Explanation: A permutation is a rearrangement of a set of numbers into a sequence. For example, [1, 2, 3] is a permutation of [3, 1, 2].\n\n# [phrase showing quantity relationship]\n    'repeatedly': Indicates that an operation should be performed multiple times.\n    Explanation: In the requirement, 'repeatedly' is used to describe the process of applying the permutation multiple times.\n\n# [degree adverb] \n    'largest': Indicates that the search should find the largest integer that meets the condition.\n    Explanation: The requirement uses 'largest' to specify that we need to find the biggest integer that appears at least as many times as itself.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan involves handling two types of queries:\n    1. Swap two elements in the permutation.\n    2. Determine the final value of an element after repeatedly applying the permutation.\n\n    Steps to implement:\n    1. Read the input values for n, q, the permutation array, and the queries.\n    2. For each query of type 1, swap the elements at positions x and y in the permutation array.\n    3. For each query of type 2, determine the final value of element i after k applications of the permutation.\n    4. Output the results for each query of type 2.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n", "requirement analysis:\nThe project requires handling permutations and executing queries on them. The first type of query swaps two elements in the permutation, while the second type calculates the result of repeatedly applying the permutation to an element. The constraints are high, with up to 10^5 elements and queries, which necessitates efficient handling of the data.\nrequirement pool:\n- Implement the functionality to handle permutations and queries efficiently.\n- Ensure the application is responsive and handles large inputs correctly.\n- Design a user-friendly interface for easy interaction.\nTo handle the given problem efficiently, we will use a list to represent the permutation and implement two types of queries. For the first type, we will swap the elements at the given indices. For the second type, we will simulate the repeated application of the permutation to an element. Given the constraints, we will ensure that the solution is optimized to handle up to 10^5 elements and queries.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'permutation': a sequence of n distinct integers from 1 to n.\n    Explanation: A permutation is an arrangement of all the members of a set into some sequence or order. In this context, it refers to a list of integers where each integer from 1 to n appears exactly once.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To handle the queries efficiently, we need to:\n    1. Store the permutation as a list.\n    2. For the first type of query (swap), swap the elements at the given indices.\n    3. For the second type of query (repeated application of the permutation), simulate the process by repeatedly applying the permutation to the given index k times.\n\n# [edge case]\n    edge case1 = 4\n    Explanation: For the second-type query with i = 3 and k = 1, the permutation is [5, 3, 4, 2, 1]. Applying the permutation repeatedly:\n    - Initially, p_3 = 4.\n    - After one application, p_4 = 2, so p_3 = 2.\n    - After two applications, p_2 = 3, so p_3 = 3.\n    - After three applications, p_3 = 4, which is the final result.\n\n    edge case2 = 1\n    Explanation: For the second-type query with i = 1 and k = 2, the permutation is [5, 3, 4, 2, 1]. Applying the permutation repeatedly:\n    - Initially, p_1 = 5.\n    - After one application, p_5 = 1, so p_1 = 1.\n    - After two applications, p_1 = 5, which is the final result.\n\n    edge case3 = 2\n    Explanation: For the second-type query with i = 1 and k = 3, the permutation is [5, 3, 4, 2, 1]. Applying the permutation repeatedly:\n    - Initially, p_1 = 5.\n    - After one application, p_5 = 1, so p_1 = 1.\n    - After two applications, p_5 = 1, so p_1 = 1.\n    - After three applications, p_5 = 1, which is the final result.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle the edge cases directly.\n", "requirement analysis:\nThe requirements involve managing a permutation sequence and handling user queries to swap elements or retrieve values. The application must be able to handle a large number of queries and permutations efficiently. The user interface should be intuitive and the output should be clear and concise.\nrequirement pool:\n- Implement a function to swap elements in the permutation sequence.\n- Develop a function to retrieve the value at a specific position in the permutation.\n- Ensure the application can handle a large number of queries efficiently.\n- Implement a user-friendly interface for easy interaction with the permutation.\n- Ensure the application provides clear and concise output for user queries.\nTo efficiently manage permutations and handle user queries, we will use Python's built-in list data structure for storing the permutation. For handling queries, we will implement a function that can swap elements and retrieve values based on user input. We will also ensure that the application can handle a large number of queries efficiently by using efficient indexing and swapping techniques.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'permutation': a sequence of n elements where each number from 1 to n appears exactly once.\n    Explanation: A permutation is a rearrangement of the elements of a set, where each element appears exactly once. In the context of this problem, the sequence p is a permutation of numbers from 1 to n.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan involves handling two types of queries:\n    1. Swap the elements at positions x and y in the permutation.\n    2. Retrieve the k-th element in the permutation starting from the i-th position.\n\n    Steps to implement:\n    1. Read the input values for n, q, and the permutation p.\n    2. Process each query:\n        - For type 1 query, swap the elements at positions x and y.\n        - For type 2 query, retrieve the k-th element starting from the i-th position.\n    3. Output the result of each type 2 query.\n\n# [edge case] \n    Edge case 1:\n    Input:\n    5 4\n    5 3 4 2 1\n    2 3 1\n    2 1 2\n    1 1 3\n    2 1 2\n\n    Output:\n    4\n    1\n    2\n\n    Explanation:\n    - The first query (2 3 1) asks for the 1st element starting from the 3rd position, which is 4.\n    - The second query (2 1 2) asks for the 2nd element starting from the 1st position, which is 1.\n    - The third query (1 1 3) swaps the elements at positions 1 and 3, resulting in the new permutation [4, 3, 5, 2, 1].\n    - The fourth query (2 1 2) asks for the 2nd element starting from the 1st position, which is now 3.\n\n    Edge case 2:\n    Input:\n    5 9\n    2 3 5 1 4\n    2 3 5\n    2 5 5\n    2 5 1\n    2 5 3\n    2 5 4\n    1 5 4\n    2 5 3\n    2 2 5\n    2 5 1\n\n    Output:\n    3\n    5\n    4\n    2\n    3\n    3\n    3\n    1\n\n    Explanation:\n    - The first query (2 3 5) asks for the 5th element starting from the 3rd position, which is 3.\n    - The second query (2 5 5) asks for the 5th element starting from the 5th position, which is 4.\n    - The third query (2 5 1) asks for the 1st element starting from the 5th position, which is 2.\n    - The fourth query (2 5 3) asks for the 3rd element starting from the 5th position, which is 1.\n    - The fifth query (2 5 4) asks for the 4th element starting from the 5th position, which is 3.\n    - The sixth query (1 5 4) swaps the elements at positions 5 and 4, resulting in the new permutation [2, 3, 5, 4, 1].\n    - The seventh query (2 5 3) asks for the 3rd element starting from the 5th position, which is now 1.\n    - The eighth query (2 2 5) asks for the 5th element starting from the 2nd position, which is 3.\n    - The ninth query (2 5 1) asks for the 1st element starting from the 5th position, which is now 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic can handle the edge cases by directly accessing the elements in the permutation after each swap.\n", "requirement analysis:\nThe requirements involve handling permutations and performing two types of queries: swapping elements and retrieving values at specific positions. The application must be able to handle a large number of queries and permutations efficiently. The user interface should be intuitive, allowing users to perform operations without confusion.\nrequirement pool:\n- Implement a function to handle permutation swaps.\n- Develop a function to retrieve values from the permutation based on queries.\n- Ensure the application can handle large inputs within a reasonable time frame.\n- Design a user-friendly interface for easy interaction with the permutation.\n- Optimize the application for performance and scalability.\nTo efficiently handle permutations and perform queries, we will use Python's built-in list data structure for storing the permutation. For managing queries, we will use a simple list to store the queries and process them sequentially. The application will be designed to handle two types of queries: swapping elements and retrieving values at specific positions. We will ensure that the application can handle large inputs efficiently by optimizing the query processing.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'permutation': A sequence of n elements where each number from 1 to n appears exactly once.\n    Explanation: A permutation is a rearrangement of elements in a sequence, ensuring that each element appears exactly once.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - For the first-type query (swap elements at positions x and y), we need to swap the elements in the permutation list.\n    - For the second-type query (retrieve value at position i), we need to return the element at the specified position in the permutation list.\n\n# [edge case] \n    search([1, 2, 3]) = 3\n    Explanation: The permutation [1, 2, 3] has no integer that appears more than or equal to its value, so the function should return -1.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, but none of them appears more than or equal to its value. Therefore, the function should return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can directly return -1 if no such integer is found.\n\n## Prompt 3:\n[requirement]\nYou are provided with a sequence p consisting of n elements. This sequence is a permutation of numbers from 1 to n, meaning each number appears exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are valid permutations, while [1, 2, 4] and [4, 3, 2, 1, 2] are not. You will receive a series of queries to perform on this permutation. The queries come in two forms:\n\n1. Swap the elements at positions x and y in the permutation.\n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5). The second line contains n integers p_1, p_2, ..., p_n. Each of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query. It is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\nOutput\n\n4\n1\n2\n\nInput\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\nOutput\n\n3\n5\n4\n2\n3\n3\n3\n1\n\n[plan]\nTo efficiently handle permutations and perform queries, we will use Python's built-in list data structure for storing the permutation. For managing queries, we will use a simple list to store the queries and process them sequentially. The application will be designed to handle two types of queries: swapping elements and retrieving values at specific positions. We will ensure that the application can handle large inputs efficiently by optimizing the query processing.\n\n## Answer 3:\n\n# [core concept]\n    'permutation': A sequence of n elements where each number from 1 to n appears exactly once.\n    Explanation: A permutation is a rearrangement of elements in a sequence, ensuring that each element appears exactly once.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - For the first-type query (swap elements at positions x and y), we need to swap the elements in the permutation list.\n    - For the second-type query (retrieve value at position i), we need to return the element at the specified position in the permutation list.\n\n# [edge case] \n    search([1, 2, 3]) = 3\n    Explanation: The permutation [1, 2, 3] has no integer that appears more than or equal to its value, so the function should return -1.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, but none of them appears more than or equal to its value. Therefore, the function should return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can directly return -1 if no such integer is found.\n", "requirement analysis:\nThe project requires handling permutations and performing queries on them. The application must be able to swap elements and retrieve values based on given positions. It should be efficient and scalable to handle large datasets efficiently.\nrequirement pool:\n- Implement a function to swap elements at given positions.\n- Develop a function to retrieve the value at a specific position in the permutation.\n- Ensure the application can handle large permutations efficiently.\n- Provide clear and concise output for user queries.\n- Implement error handling and user-friendly interface.\nTo efficiently handle permutations and manage user queries, we will use Python's built-in list data structure to represent the permutation. For managing queries, we will use a simple list to store the queries and process them sequentially. The application will support two types of queries: swapping elements and retrieving values at specific positions. We will ensure that the application is scalable by optimizing the handling of large permutations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'permutation': A sequence of n elements where each number appears exactly once, ranging from 1 to n.\n    Explanation: A permutation is a rearrangement of elements from a set, ensuring no element is repeated.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates a comparison where one quantity is greater than another.\n    'at least as many times': Indicates a minimum frequency of occurrence.\n\n# [degree adverb] \n    'largest': Indicates the maximum value in a set of values.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Read the input values for n, q, and the permutation p.\n    2. Process each query:\n        - For type 1 query (swap elements at positions x and y), swap the elements in the permutation.\n        - For type 2 query (retrieve value at position i), output the value at position i in the permutation.\n    3. Output the results for each type 2 query.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: In this case, the number 2 appears twice, and the number 3 appears three times. The largest number that appears at least as many times as itself is 3.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: The number 2 appears once, the number 3 appears twice, and the number 4 appears three times. No number appears at least as many times as itself, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can handle cases where no integer meets the condition by returning -1.\n\n## Prompt 3:\n[requirement]\nYou are provided with a sequence p consisting of n elements. This sequence is a permutation of numbers from 1 to n, meaning each number appears exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are valid permutations, while [1, 2, 4] and [4, 3, 2, 1, 2] are not. You will receive a series of queries to perform on this permutation. The queries come in two forms:\n\n1. Swap the elements at positions x and y in the permutation.\n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5). The second line contains n integers p_1, p_2, ..., p_n. Each of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query. It is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\nOutput\n\n4\n1\n2\n\nInput\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\nOutput\n\n3\n5\n4\n2\n3\n3\n3\n1\n\n[plan]\nTo efficiently handle permutations and manage user queries, we will use Python's built-in list data structure to represent the permutation. For managing queries, we will use a simple list to store the queries and process them sequentially. The application will support two types of queries: swapping elements and retrieving values at specific positions. We will ensure that the application is scalable by optimizing the handling of large permutations.\n\n## Answer 3:\n\n# [core concept]\n    'permutation': A sequence of n elements where each number appears exactly once, ranging from 1 to n.\n    Explanation: A permutation is a rearrangement of elements from a set, ensuring no element is repeated.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates a comparison where one quantity is greater than another.\n    'at least as many times': Indicates a minimum frequency of occurrence.\n\n# [degree adverb] \n    'largest': Indicates the maximum value in a set of values.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Read the input values for n, q, and the permutation p.\n    2. Process each query:\n        - For type 1 query (swap elements at positions x and y), swap the elements in the permutation.\n        - For type 2 query (retrieve value at position i), output the value at position i in the permutation.\n    3. Output the results for each type 2 query.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: In this case, the number 2 appears twice, and the number 3 appears three times. The largest number that appears at least as many times as itself is 3.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: The number 2 appears once, the number 3 appears twice, and the number 4 appears three times. No number appears at least as many times as itself, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can handle cases where no integer meets the condition by returning -1.\n", "requirement analysis:\nThe requirements involve handling permutations and executing queries on them. The first type of query swaps two elements in the permutation, while the second type calculates the result of repeatedly applying the permutation to an element. The system must be able to handle large inputs efficiently, ensuring fast execution and clear output.\nrequirement pool:\n- Implement the ability to swap elements in a permutation\n- Calculate the result of repeatedly applying a permutation to an element\n- Ensure efficient handling of large permutations and queries\n- Provide clear and concise output for each query\nTo implement the given permutation manipulation tool, we will use Python due to its simplicity and efficiency. The system will handle permutations and execute queries efficiently. We will use a list to represent the permutation and a dictionary to store the cycle decomposition for quick lookups. For query execution, we will use a loop to repeatedly apply the permutation until the desired number of iterations is reached.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'permutation': a bijective function that rearranges a set of objects into a specific order.\n    Explanation: In this problem, a permutation is given as an array of integers from 1 to n, where each integer appears exactly once. The operations involve swapping elements and determining the final position of an element after a certain number of swaps.\n\n# [phrase showing quantity relationship]\n    'more than': means that the value of the integer in the permutation must be greater than the integer itself.\n    Explanation: For example, in the query \"2 3 5\", the integer 3 must appear more than 3 times in the permutation to satisfy the condition.\n\n# [degree adverb] \n    'largest': means that the integer we are looking for should be the greatest among those that meet the condition.\n    Explanation: For instance, in the query \"search([3,3,2,4,4,4])\", the largest integer that appears at least as many times as itself is 4.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Handle the two types of queries: type 1 for swapping elements and type 2 for determining the final position after repeated swaps.\n    2. For type 2 queries, we need to simulate the repeated application of the permutation to find the final position of the element.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: The integer 3 appears more than 3 times in the list, and it is the largest integer that meets this condition.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: No integer appears more than or equal to its value. Therefore, the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can determine if no such integer exists by checking the frequency of each integer.\n\n# [core concept]\n    'permutation manipulation': the process of rearranging elements based on a predefined pattern.\n    Explanation: In this problem, permutations are manipulated through swapping operations, and we need to determine the final position of an element after a specified number of swaps.\n\n# [phrase showing quantity relationship]\n    'at least as many times': means that the frequency of the integer must be greater than or equal to the integer's value.\n    Explanation: For example, in the query \"search([4, 1, 2, 2, 3, 1])\", the integer 2 appears at least as many times as itself (2 times), which is more than its value (2).\n\n# [degree adverb] \n    'largest': means that the integer we are looking for should be the greatest among those that meet the condition.\n    Explanation: For instance, in the query \"search([1, 2, 2, 3, 3, 3, 4, 4, 4])\", the largest integer that appears at least as many times as itself is 3.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Create a frequency dictionary to count the occurrences of each integer.\n    2. Iterate through the list to populate the frequency dictionary.\n    3. Find the largest integer whose frequency is at least as many as its value.\n    4. Return the result or -1 if no such integer exists.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: The integer 3 appears more than 3 times in the list, and it is the largest integer that meets this condition.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: No integer appears more than or equal to its value. Therefore, the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can determine if no such integer exists by checking the frequency of each integer.\n", "requirement analysis:\nThe requirements involve handling permutations and executing queries to swap elements and determine the result of repeated applications of the permutation. The application must be efficient and capable of handling large inputs within reasonable time limits.\nrequirement pool:\n- Implement a function to handle permutation swaps.\n- Develop a function to calculate the result of repeated permutations.\n- Ensure the application can handle large inputs efficiently.\n- Provide clear and user-friendly instructions for swapping and querying.\n- Optimize the application for high performance and scalability.\nTo implement the given requirements, we will use Python, leveraging its simplicity and efficiency. The application will handle permutations and queries efficiently. We will use a list to represent the permutation and provide functions to swap elements and calculate the result of repeated permutations. The application will be designed to handle large inputs within reasonable time limits.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'permutation': a bijective function that rearranges a set of objects into a specific order.\n    Explanation: In this problem, a permutation is represented as an array of integers where each integer from 1 to n appears exactly once. The operations involve swapping elements within the permutation and determining the final position of an element after a series of swaps.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find interger > 0\n    'at least as many times': means that we need to find the interger whose appears times is greater than or equal to its value\n\n# [degree adverb] \n    'largest': means that we need the bigest interger that appears greater or equal to its value\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we will follow these steps:\n    1. Read the input values for n and q.\n    2. Read the permutation array p.\n    3. Process each query:\n        - For type 1 query, swap the elements at positions x and y in the permutation array.\n        - For type 2 query, determine the final position of element i after repeatedly applying the permutation k times.\n    4. Output the result of each type 2 query.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    explanation: number 2 appears one time, number 3 appears two times,number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest interger that meets the need. \n\n# [edge case]\n    search([1, 1, 2, 2, 3]) = 1\n    Explanation: The number 1 appears more than or equal to its value (2 times), and it is the largest number that meets this condition.\n    search([4, 4, 4, 4]) = 4\n    Explanation: All numbers appear more than or equal to their value (4 times), and the largest number is 4.\n    search([2, 2, 3, 3, 3, 4]) = 3\n    Explanation: The number 3 appears more than or equal to its value (3 times), and it is the largest number that meets this condition.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        def search(lst):\n            freq = {}\n            for num in lst:\n                freq[num] = freq.get(num, 0) + 1\n            max_num = -1\n            for num, count in freq.items():\n                if count >= num:\n                    max_num = max(max_num, num)\n            return max_num if max_num != -1 else -1\n", "requirement analysis:\nThe requirements involve handling permutations and executing queries on them. The application needs to be able to swap elements and compute the result of applying the permutation repeatedly. It must be efficient enough to handle large inputs within the given constraints.\nrequirement pool:\n- Implement a function to swap elements in the permutation\n- Implement a function to compute the result of applying the permutation repeatedly\n- Ensure the application can handle large inputs efficiently\n- Provide clear and concise user feedback\nTo implement the required functionality, we will use Python, leveraging its simplicity and efficiency. The application will handle permutations and queries efficiently. We will use a list to represent the permutation and provide functions to swap elements and compute the result of applying the permutation repeatedly. The application will be designed to handle large inputs within the given constraints.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'permutation': a bijective function that rearranges a set of objects into a specific order.\n    Explanation: In this context, a permutation is an array of length n containing each integer from 1 to n exactly once.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan involves handling two types of queries: swapping elements in the permutation and determining the final position after repeatedly applying the permutation. We need to:\n    1. Read the input for the permutation and the number of queries.\n    2. Process each query:\n        - For type 1 query, swap the elements at positions x and y.\n        - For type 2 query, determine the final position of element i after k repetitions of the permutation.\n    3. Output the result of each type 2 query.\n\n# [edge case] \n    Edge case 1:\n    Input: 5 4\n           5 3 4 2 1\n           2 3 1\n           2 1 2\n           1 1 3\n           2 1 2\n    Output: 4\n    Explanation: After the first query, the permutation becomes [5, 4, 3, 2, 1]. After the second query, it becomes [1, 4, 3, 2, 5]. The third query swaps the elements at positions 1 and 3, resulting in [3, 4, 1, 2, 5]. The final query asks for the position of element 1, which is now at position 3.\n\n    Edge case 2:\n    Input: 5 9\n           2 3 5 1 4\n           2 3 5\n           2 5 5\n           2 5 1\n           2 5 3\n           2 5 4\n           1 5 4\n           2 5 3\n           2 2 5\n           2 5 1\n    Output: 3\n    Explanation: The permutation remains the same after the first query. After the second query, the final position of element 5 after 5 repetitions is 5. After the third query, the final position of element 5 after 1 repetition is 4. The fourth query asks for the final position of element 5 after 3 repetitions, which is 2. The fifth query asks for the final position of element 5 after 4 repetitions, which is 3. The sixth query swaps the elements at positions 5 and 4, resulting in [2, 3, 5, 1, 4]. The seventh query asks for the final position of element 5 after 3 repetitions, which remains 2. The eighth query asks for the final position of element 2 after 5 repetitions, which is 5. The ninth query asks for the final position of element 5 after 1 repetition, which is 4.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic is sufficient to handle the permutations and queries correctly.\n", "requirement analysis:\nThe project requires handling permutations and executing queries efficiently. The application must support both swapping elements and determining the final value of an element after a specified number of iterations. The system should be able to handle large inputs and provide quick responses.\nrequirement pool:\n- Implement a function to swap elements in the permutation.\n- Develop a function to determine the final value of an element after a specified number of iterations.\n- Ensure the application can handle large permutations and a high number of queries.\n- Optimize the application for efficiency to handle large inputs.\n- Enhance user interaction with a user-friendly interface.\nTo implement this application, we will use Python due to its simplicity and efficiency. The application will handle permutations and queries efficiently. We will use a list to represent the permutation and a dictionary to store the results of the second-type queries for quick retrieval. For the first-type query, we will directly swap the elements in the list. For the second-type query, we will simulate the iterations to find the final value.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'permutation': A sequence of integers where each integer from 1 to n appears exactly once.\n    Explanation: A permutation is a rearrangement of the elements of a set, where each element appears exactly once. In the context of this problem, we are dealing with permutations of integers from 1 to n.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan involves handling two types of queries:\n    1. Swapping two elements in the permutation.\n    2. Determining the final value of an element after repeatedly applying the permutation.\n\n    Steps to implement:\n    1. Read the input for the permutation and the number of queries.\n    2. For each query:\n        - If it's a type 1 query, swap the elements at positions x and y in the permutation.\n        - If it's a type 2 query, determine the final value of element i after k iterations by simulating the permutation application k times.\n\n# [edge case] \n    Edge case 1:\n    Input: 5 4\n           5 3 4 2 1\n           2 3 1\n           2 1 2\n           1 1 3\n           2 1 2\n    Output: 4\n    Explanation: After the first query, the permutation becomes [5, 4, 3, 2, 1]. After the second query, it becomes [5, 3, 4, 2, 1]. The third query swaps the first and third elements, resulting in [4, 3, 5, 2, 1]. The final query asks for the value at position 1 after 2 iterations, which is 4.\n\n    Edge case 2:\n    Input: 5 9\n           2 3 5 1 4\n           2 3 5\n           2 5 5\n           2 5 1\n           2 5 3\n           2 5 4\n           1 5 4\n           2 5 3\n           2 2 5\n           2 5 1\n    Output: 3\n    Explanation: The permutation remains unchanged after the first query. The second query asks for the value at position 3 after 5 iterations, which is 4. The third query asks for the value at position 5 after 5 iterations, which is 4. The fourth query asks for the value at position 5 after 1 iteration, which is 4. The fifth query asks for the value at position 5 after 3 iterations, which is 4. The sixth query asks for the value at position 5 after 4 iterations, which is 2. The seventh query swaps the fifth and fourth elements, resulting in [2, 3, 5, 1, 4]. The eighth query asks for the value at position 2 after 5 iterations, which is 5. The final query asks for the value at position 5 after 1 iteration, which is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic can handle the edge cases by simulating the permutation application and swapping directly.\n"], "scores": [], "pass_results": [false, false, true, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 65, "examples": "\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.", "mutate_method": "expand_one2two", "parent_index": 69}
