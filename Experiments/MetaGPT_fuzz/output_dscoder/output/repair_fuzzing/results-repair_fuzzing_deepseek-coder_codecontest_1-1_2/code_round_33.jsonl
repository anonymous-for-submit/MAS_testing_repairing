{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "prompt": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger that applies a poison effect dealing 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). The i-th attack is performed at the beginning of the a_i-th second from the battle start; however, if the dragon has already been poisoned, the dagger updates the poison effect, cancelling the current poison effect and applying a new one.\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon. Determine how Monocarp can achieve slaying the dragon efficiently.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "repair_prompt": ["Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger that applies a poison effect dealing 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). The i-th attack is performed at the beginning of the a_i-th second from the battle start; however, if the dragon has already been poisoned, the dagger updates the poison effect, cancelling the current poison effect and applying a new one.\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon. Determine how Monocarp can achieve slaying the dragon efficiently.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].\nWrite a main() function and use input() function to read input from stdin", " Monocarp is engaged in a challenging video game where his character must defeat a dragon. The dragon battle spans an incredibly long duration of 100^{500} seconds. During this time, Monocarp uses a poisoned dagger to inflict damage on the dragon, with the poison effect lasting for k seconds, dealing 1 damage each second it is active, starting from the moment the dagger is plunged into the dragon.\n\nThe dagger can be reapplied at any time, which effectively resets the poison effect and extends its duration. Monocarp notes that the i-th attack occurs at the beginning of the a_\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].\nWrite a main() function and use input() function to read input from stdin", " Monocarp is in a game where he fights a dragon with a poisoned dagger. The dagger applies poison for k seconds each time it hits, dealing 1 damage each second. Monocarp attacks at specific times, and if the poison effect is active, it resets and lasts longer. The goal is to find the smallest k such that Monocarp's total poison damage to the dragon is at least h, allowing him to slay the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].\nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef find_min_k(attacks: List[int], h: int) -> int:\n    def total_damage(k: int) -> int:\n        damage = 0\n        last_poison_end = 0\n        for attack_time in attacks:\n            poison_start = max(attack_time, last_poison_end)\n            poison_end = poison_start + k - 1\n            damage += (poison_end - poison_start + 1)\n            last_poison_end = poison_end + 1\n        return damage\n\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if total_damage(mid) < h:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(attacks, h)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_min_k(attacks: List[int], h: int) -> int:\n    def total_damage(k: int) -> int:\n        damage = 0\n        last_poison_end = 0\n        for attack in attacks:\n            start = attack\n            end = attack + k - 1\n            if start > last_poison_end:\n                damage += k\n            else:\n                damage += max(0, end - last_poison_end)\n            last_poison_end = max(last_poison_end, end)\n        return damage\n\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if total_damage(mid) < h:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Interface\nn, h = map(int, input().split())\nattacks = list(map(int, input().split()))\nresult = find_min_k(attacks, h)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_k(attacks: List[int], h: int) -> int:\n    def total_damage(k: int) -> int:\n        damage = 0\n        poison_start = 0\n        for attack in attacks:\n            if attack > poison_start:\n                damage += k\n                poison_start = attack + k - 1\n            else:\n                poison_start += k\n        return damage\n\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if total_damage(mid) < h:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Interface\nn, h = map(int, input().split())\nattacks = list(map(int, input().split()))\nresult = find_min_k(attacks, h)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef find_minimum_k(n: int, h: int, attacks: List[int]) -> int:\n    def can_deal_damage(k: int) -> bool:\n        total_damage = 0\n        last_attack_end = 0\n        for attack_time in attacks:\n            start_of_effect = attack_time - k\n            end_of_effect = attack_time\n            damage_from_previous_attack = max(0, start_of_effect - last_attack_end)\n            total_damage += damage_from_previous_attack + (k - (end_of_effect - start_of_effect))\n            last_attack_end = end_of_effect\n        return total_damage >= h\n\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if can_deal_damage(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Read input and output results\nt = int(input())\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_minimum_k(n, h, attacks)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_k(attacks: List[int], h: int) -> int:\n    def total_damage(k: int) -> int:\n        damage = 0\n        last_attack_time = 0\n        for attack_time in attacks:\n            if attack_time - last_attack_time <= k:\n                damage += 1\n            else:\n                damage += 2\n            last_attack_time = attack_time\n        return damage\n\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        if total_damage(mid) < h:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(attacks, h)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_k(attacks: List[int], h: int) -> int:\n    def can_achieve_damage(k: int) -> bool:\n        damage = 0\n        last_attack_time = 0\n        for attack_time in attacks:\n            if attack_time - last_attack_time <= k:\n                damage += 1\n            else:\n                damage += 2\n            last_attack_time = attack_time\n        return damage >= h\n\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if can_achieve_damage(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(attacks, h)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_k(n: int, h: int, attacks: List[int]) -> int:\n    def total_damage(k: int) -> int:\n        damage = 0\n        last_time = 0\n        for attack_time in attacks:\n            duration = attack_time - last_time\n            damage += (k - (duration % k)) % k\n            last_time = attack_time\n        return damage\n\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        if total_damage(mid) < h:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(n, h, attacks)\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef find_min_k(n: int, h: int, attacks: List[int]) -> int:\n    def total_damage(k: int) -> int:\n        damage = 0\n        last_attack_time = 0\n        for attack_time in attacks:\n            duration = attack_time - last_attack_time\n            # Calculate the number of times the poison effect resets\n            resets = duration // k\n            damage += resets + 1\n            last_attack_time = attack_time\n        return damage\n\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        if total_damage(mid) < h:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(n, h, attacks)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_k(n: int, h: int, attacks: List[int]) -> int:\n    def total_damage(k: int) -> int:\n        damage = 0\n        last_attack_time = 0\n        for attack_time in attacks:\n            duration = attack_time - last_attack_time\n            damage += (duration // k) + 1\n            last_attack_time = attack_time\n        return damage\n\n    left, right = 1, h\n    while left < right:\n        mid = (left + right) // 2\n        if total_damage(mid) < h:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    result = find_min_k(n, h, attacks)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_k(attacks: List[int], h: int) -> int:\n    def cumulative_damage(k: int) -> int:\n        damage = 0\n        last_attack_time = 0\n        for attack_time in attacks:\n            start = attack_time\n            end = attack_time + k - 1\n            duration = end - last_attack_time\n            damage += duration // k + 1\n            last_attack_time = attack_time\n        return damage\n\n    low, high = 1, max(attacks)\n    while low < high:\n        mid = (low + high) // 2\n        if cumulative_damage(mid) >= h:\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\n# Read input\nn, h = map(int, input().split())\nattacks = list(map(int, input().split()))\n\n# Find and print the result\nresult = find_min_k(attacks, h)\nprint(result)\n"], "plans": ["requirement analysis:\nThe requirements involve creating a game where the player has to strategically attack a dragon to deal damage over time. The challenge lies in determining the minimum duration of the poison effect required to deal at least h damage to the dragon. The game should be designed with user engagement and accessibility in mind, offering a visually appealing interface and smooth gameplay.\nrequirement pool:\n- Implement the game logic for calculating damage based on attack times and poison duration.\n- Ensure the game interface is responsive and user-friendly.\n- Develop a scoring system to track player performance.\n- Include adjustable difficulty levels to cater to different skill sets.\n- Design a minimalist UI with a focus on game mechanics.\nTo solve this problem, we will use a combination of algorithmic thinking and Python's capabilities. The main challenge is to determine the minimum value of k such that the total damage dealt to the dragon is at least h. We will approach this by simulating the damage over time based on the given attack times and updating the poison effect accordingly. We will use a binary search to efficiently find the minimum k.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'poison effect': The effect of the poisoned dagger that deals 1 damage over k consecutive seconds.\n    'binary search': A method to find the minimum value of k by repeatedly dividing the search interval in half.\n\n# [phrase showing quantity relationship]\n    'at least': Indicates that the total damage dealt must be equal to or greater than h.\n\n# [degree adverb] \n    'minimum possible': The goal is to find the smallest value of k that ensures the required damage is dealt.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the input for each test case.\n    2. Use binary search to find the minimum k.\n    3. For each potential k, simulate the attacks and calculate the total damage.\n    4. Return the minimum k that ensures at least h damage is dealt.\n\n# [edge case] \n    Monocarp attacks at the start of each second, and the dragon has 1 hit point.\n    Edge case 1:\n        Input: n = 1, h = 1, attacks = [1]\n        Explanation: Monocarp attacks only once at the start of the first second. Since the dragon has only 1 hit point, k must be 1 to deal at least 1 damage.\n        Expected output: 1\n    Edge case 2:\n        Input: n = 2, h = 3, attacks = [1, 2]\n        Explanation: Monocarp attacks at the start of the 1st and 2nd seconds. The total damage dealt without any poison effect would be 1+1 = 2. To deal at least 3 damage, k must be 3 to cover both attack seconds.\n        Expected output: 3\n    Edge case 3:\n        Input: n = 3, h = 10, attacks = [1, 3, 5]\n        Explanation: Monocarp attacks at the start of the 1st, 3rd, and 5th seconds. The total damage dealt without any poison effect would be 1+1+1 = 3. To deal at least 10 damage, k must be 7 to cover the entire duration from the first attack to the end of the last attack.\n        Expected output: 7\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the number of attacks is small or the required damage is low. The binary search approach ensures that we efficiently find the minimum k without the need for additional complex logic.\n", "requirement analysis:\nThe problem requires finding the minimum value of k such that Monocarp's attacks, when combined with the poison effect, will deal at least h damage to the dragon. The attacks are given in a sequence, and the poison effect lasts for k seconds, dealing 1 damage each time it is active. The poison effect can be reapplied, which resets its duration.\nrequirement pool:\n- Implement a function to calculate the minimum k required to deal at least h damage.\n- Ensure the solution is efficient enough to handle up to 1000 test cases.\n- Optimize the algorithm to minimize the number of iterations needed to find the minimum k.\nTo solve the problem of determining the minimum value of k such that Monocarp's attacks, when combined with the poison effect, will deal at least h damage to the dragon, we can use a binary search approach. This approach will help us efficiently find the minimum k without having to iterate through all possible values of k. We will use Python's built-in binary search function to optimize the search process.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a technique used to find the minimum value of k efficiently by repeatedly dividing the search interval in half.\n\n# [phrase showing quantity relationship]\n    'at least': This phrase indicates that the value of k must be sufficient to ensure that the total damage dealt is at least h.\n\n# [degree adverb] \n    'minimum possible': This suggests that we need to find the smallest value of k that meets the requirement.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the input values for t, n, h, and the list of attack times.\n    2. Define a function to calculate the total damage dealt given a specific k.\n    3. Use binary search to find the minimum k such that the total damage is at least h.\n    4. Output the minimum k for each test case.\n\n# [edge case] \n    Edge case 1:\n    Input: t = 1, n = 2, h = 3, attacks = [1, 5]\n    Explanation: Monocarp has two attacks at seconds 1 and 5. If k = 4, the poison effect will deal damage during seconds 1-4 and 5-8, totaling 4 damage. If k = 5, the poison effect will deal damage during seconds 1-4 and 5-9, totaling 5 damage. Since we need at least 3 damage, the minimum k is 4.\n    Expected output: 4\n\n    Edge case 2:\n    Input: t = 1, n = 3, h = 10, attacks = [1, 3, 5]\n    Explanation: Monocarp has three attacks at seconds 1, 3, and 5. If k = 4, the poison effect will deal damage during seconds 1-4, 3-6, and 5-8, totaling 6 damage. If k = 5, the poison effect will deal damage during seconds 1-4, 3-7, and 5-9, totaling 8 damage. Since we need at least 10 damage, the minimum k is 5.\n    Expected output: 5\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles cases where the attacks are sparse or dense, and the required damage is high or low.\n", "requirement analysis:\nThe problem requires finding the minimum value of k such that Monocarp's attacks, when combined with the poison effect, will deal at least h damage to the dragon. The attacks are given in a sequence, and the poison effect lasts for k seconds, dealing 1 damage each second. The poison effect can be reapplied, updating the previous effect or cancelling it if a new attack occurs during the poison effect.\nrequirement pool:\n- Implement a function to calculate the minimum k required to deal at least h damage.\n- Ensure the solution is efficient enough to handle up to 1000 test cases.\n- Optimize the algorithm to handle large values of h efficiently.\nTo solve this problem, we will use a binary search approach to find the minimum value of k. The binary search will help us efficiently determine the smallest k that ensures Monocarp deals at least h damage to the dragon. We will calculate the total damage dealt by Monocarp's attacks considering the poison effect and adjust the range of k based on whether the total damage is less than or greater than h. The poison effect will be simulated by checking if the attack times overlap with the current poison effect window.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a technique used to find the minimum value of k efficiently by repeatedly dividing the search interval in half.\n\n# [phrase showing quantity relationship]\n    'at least': This phrase indicates that the value we are looking for must be sufficient to meet a minimum requirement.\n\n# [degree adverb] \n    'minimum possible': This suggests that we need to find the smallest value of k that still meets the requirement.\n\n# [code logic]\n    To implement the solution, we will:\n    1. Use binary search to find the minimum k.\n    2. For each potential k, simulate the poison effects and calculate the total damage dealt by Monocarp's attacks.\n    3. Adjust the search range based on whether the total damage is less than or greater than h.\n\n# [edge case] \n    Edge case 1: Monocarp attacks at the same time as the poison effect starts.\n    Expected output: 1\n    Explanation: Since the attack and the poison effect start at the same time, the poison deals 1 damage during the attack.\n\n    Edge case 2: Monocarp attacks at times when the poison effect does not apply.\n    Expected output: 1\n    Explanation: If the attacks are not within the poison effect window, no damage is dealt, and k should be 1.\n\n    Edge case 3: Monocarp attacks at times when the poison effect is already in place, updating the effect.\n    Expected output: The minimum k that ensures the total damage is at least h.\n    Explanation: The poison effect should be updated at each attack, and k should be adjusted accordingly to ensure the total damage meets or exceeds h.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where Monocarp attacks at the same time as the poison effect starts or when the poison effect does not apply.\n    For edge case 1:\n        if any(attack == 1 for attack in attacks):\n            return 1\n    For edge case 2:\n        if any(attack < k for attack in attacks):\n            return k\n    For edge case 3:\n        We need to adjust the binary search range based on the overlap of attack times with the poison effect.\n", "requirement analysis:\nThe requirements specify a problem where Monocarp needs to determine the minimum duration k for the poison effect to ensure he deals at least h damage to the dragon. The attacks occur at specific times, and the poison effect can be reapplied to extend its duration. The solution requires calculating the minimum k such that the total damage over the duration is at least h.\nrequirement pool:\n- Implement a function to calculate the minimum k for each test case\n- Ensure the program can handle up to 1000 test cases efficiently\n- Optimize the algorithm to handle large values of h efficiently\n- Ensure the program is user-friendly and provides clear output\n- Design a simple and responsive user interface\nTo solve this problem, we will use a binary search approach to find the minimum value of k. This approach is efficient and suitable for handling large values of h. We will iterate over possible values of k, checking if the total damage over the duration is at least h. The binary search will help us efficiently narrow down the range of possible values for k.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a technique used to find the minimum or maximum value that satisfies a certain condition. It works by repeatedly dividing the search interval in half and checking the midpoint for the condition.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    No edge case provided in the plan\n\n# [extra code for edge case]\n    No extra code needed for edge cases as the plan does not specify any edge cases.\n\n# [core concept]\n    'poisoned dagger': This refers to a weapon that deals damage over time, with the effect lasting for a certain duration.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    No edge case provided in the plan\n\n# [extra code for edge case]\n    No extra code needed for edge cases as the plan does not specify any edge cases.\n\n# [core concept]\n    'dragon battle duration': This refers to the total time the battle lasts, which is given as 10^500 seconds in the requirement.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    No edge case provided in the plan\n\n# [extra code for edge case]\n    No extra code needed for edge cases as the plan does not specify any edge cases.\n", "requirement analysis:\nThe requirements specify that Monocarp needs to inflict a certain amount of damage to the dragon over a very long duration. The challenge lies in determining the minimum duration of the poison effect (k) that ensures Monocarp deals at least h damage. The attacks are given at specific times, and the poison effect can be reapplied to extend its duration. The solution must be efficient to handle the large possible values of h and the number of attacks.\nrequirement pool:\n- Implement a function to calculate the minimum k for each test case\n- Ensure the solution is efficient and can handle large inputs\n- Provide clear output for each test case\nTo solve this problem, we need to calculate the minimum value of k such that Monocarp's attacks with the poisoned dagger deal at least h damage to the dragon. Given the large possible values of h and the number of attacks, we will use a binary search approach to efficiently find the minimum k.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'poisoned dagger': means the dagger has a poison effect that deals damage over time.\n    'reset poison effect': means reapplying the dagger effectively extends the poison duration.\n    'binary search': a method to find the minimum value of k by repeatedly dividing the search interval in half.\n\n# [phrase showing quantity relationship]\n    'at least': means the total damage must be equal to or greater than h.\n\n# [degree adverb] \n    'minimum': means the smallest value of k that satisfies the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    For each test case:\n    1. Use binary search to find the minimum k.\n    2. For each potential k, calculate the total damage Monocarp can inflict.\n    3. Adjust the search range based on whether the total damage is sufficient or not.\n    4. Return the minimum k found.\n\n# [edge case] \n    test_cases = 1, n = 1, h = 10^18, attacks = [1]\n    expected output = 10^18\n    Explanation:\n    There is only one attack at the start of the 1st second. The minimum k must be at least as large as h to ensure the poison effect lasts long enough to deal the required damage.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the number of attacks is one and the damage needed is very large.\n        if n == 1:\n            return h\n        (other code)\n\n    This ensures that if there's only one attack, the poison duration k must be at least as large as the total damage needed h.\n", "requirement analysis:\nThe main requirement is to determine the minimum value of k such that Monocarp's attacks, with the poison effect lasting for k seconds, will cause at least h damage to the dragon. The attacks occur at specific times, and the poison effect resets with each attack. The challenge is to find the smallest k that ensures the total damage exceeds h.\nrequirement pool:\n- The main code must calculate the minimum k for each test case.\n- The game algorithm must handle the long duration and multiple attacks.\n- Implement a function to read input from standard input.\n- Implement a function to output the result to standard output.\n- Ensure the code is efficient enough to handle the large input values.\nTo solve this problem, we will use a binary search approach to find the minimum value of k. The binary search will be used to efficiently find the smallest value of k that ensures the total damage exceeds h. We will read the input, process each test case, and output the result for each case.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a technique used to find the minimum or maximum value that satisfies a given condition. In this case, we are looking for the minimum value of k that ensures Monocarp causes at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least': This phrase indicates that the value we are looking for must be at least as large as the specified amount.\n\n# [degree adverb] \n    'minimum': This adverb indicates that we are seeking the smallest value that meets the condition.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the number of test cases.\n    2. For each test case:\n        a. Read the number of attacks and the required damage.\n        b. Read the times of the attacks.\n        c. Use binary search to find the minimum value of k.\n        d. Output the result for each test case.\n\n# [edge case] \n    Test case:\n    1\n    1 1\n    1\n    Expected output: 1\n    Explanation: There is only one attack at the first second, and we need to deal at least 1 damage. The minimum k that ensures this is 1, as the poison effect lasts for 1 second and deals 1 damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The binary search approach inherently handles cases where the number of attacks is minimal.\n", "requirement analysis:\nThe problem requires finding the smallest k such that the total poison damage to the dragon is at least h. This involves calculating the time intervals between attacks and determining the minimum k that ensures the total damage is met. The solution should be efficient enough to handle up to 1000 test cases within the given constraints.\nrequirement pool:\n- Implement a function to calculate the minimum k for each test case\n- Ensure the solution is efficient and can handle up to 1000 test cases\n- Provide a clear and user-friendly output format\n- Design a responsive and visually appealing UI\nTo solve this problem, we will use a binary search approach to find the minimum value of k. This method is efficient and suitable for handling the large range of possible values for k. We will calculate the total damage done by Monocarp's attacks considering the poison effect and binary search to find the smallest k that meets the required damage.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'poison damage': The damage is applied over a duration (k seconds) and deals 1 damage each second. If the poison effect is active, it resets and lasts longer.\n    Explanation: Monocarp's attacks with a poisoned dagger apply poison for k seconds each time it hits, dealing 1 damage each second. If the poison effect is active when a new attack occurs, it resets and continues for an additional k seconds.\n\n# [phrase showing quantity relationship]\n    'at least as many times': means the number of times a number appears is greater than or equal to its value.\n    Explanation: In this context, it means that the poison effect must last for at least as many seconds as the attack interval to deal the required damage.\n\n# [degree adverb] \n    'smallest': means the minimum value of k that satisfies the condition.\n    Explanation: We need to find the smallest value of k such that the total poison damage to the dragon is at least h.\n\n# [code logic]\n    To solve this problem, we will use a binary search approach to find the minimum value of k. This method is efficient and suitable for handling the large range of possible values for k. We will calculate the total damage done by Monocarp's attacks considering the poison effect and binary search to find the smallest k that meets the required damage.\n\n# [edge case] \n    Monocarp attacks at times [1, 2, 3, 4, 5], and the required damage h is 10.\n    Expected output: 3\n    Explanation: With k = 3, the total damage would be 3 (for the first attack) + 3 (for the second attack) + 3 (for the third attack) + 2 (for the fourth attack) + 1 (for the fifth attack) = 12, which is more than the required damage of 10.\n\n# [extra code for edge case]\n    We do not need extra code to handle this edge case. The binary search approach will naturally find the smallest k that satisfies the condition.\n", "requirement analysis:\nThe problem requires finding the smallest k such that the total poison damage to the dragon is at least h. This involves calculating the time intervals between attacks and determining the minimum k that ensures the total damage is met. The solution should be efficient enough to handle up to 1000 test cases within the given constraints.\nrequirement pool:\n- Implement a function to calculate the minimum k for each test case\n- Ensure the solution is efficient and can handle up to 1000 test cases\n- Provide a clear and user-friendly output format\n- Design a responsive and visually appealing UI\nTo solve this problem, we will use a binary search approach to find the minimum value of k. This method is efficient and suitable for handling the large range of possible values for k. We will calculate the total damage done by Monocarp's attacks considering the poison effect and binary search to find the smallest k that meets the required damage.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'poison damage': The damage is applied over a duration (k seconds) and deals 1 damage each second. If the poison effect is active, it resets and lasts longer.\n    Explanation: Monocarp's attacks with a poisoned dagger apply poison for k seconds each time it hits, dealing 1 damage each second. If the poison effect is active when a new attack occurs, it resets and continues for an additional k seconds.\n\n# [phrase showing quantity relationship]\n    'at least as many times': means the number of times a poison effect occurs is greater than or equal to the integer itself.\n    Explanation: In this context, 'at least as many times' refers to the number of times the poison effect occurs compared to the integer value, which is the damage dealt by the poison.\n\n# [degree adverb] \n    'smallest': means the smallest value of k that will result in the total poison damage being at least h.\n    Explanation: 'Smallest' refers to the minimum value of k that ensures Monocarp's total poison damage to the dragon is at least h, allowing him to slay the dragon.\n\n# [code logic]\n    To implement the solution, we will use a binary search approach to find the minimum value of k. This involves:\n    1. Calculating the total damage done by Monocarp's attacks considering the poison effect.\n    2. Binary searching for the smallest k that meets the required damage.\n\n# [edge case] \n    Edge Case 1: Monocarp attacks once at time 1, and the required damage h is 1.\n    Expected Output: 1\n    Explanation: Since there's only one attack and it deals 1 damage, the smallest k that will ensure at least 1 damage is 1.\n\n    Edge Case 2: Monocarp attacks at times 1, 2, and 3, and the required damage h is 10.\n    Expected Output: 4\n    Explanation: The total damage from attacks at times 1, 2, and 3 without poison would be 3. To reach at least 10 damage, k must be 4 to ensure the poison effect resets and lasts long enough to deal the required damage.\n\n    Edge Case 3: Monocarp attacks at times 1, 2, ..., 100, and the required damage h is 1000.\n    Expected Output: 10\n    Explanation: The total damage from attacks at times 1 to 100 without poison would be 100 * (100 + 1) / 2 = 5050. To reach at least 1000 damage, k must be 10 to ensure the poison effect resets and lasts long enough to deal the required damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles cases where the total damage is low or where the attacks are spaced far apart. The logic for calculating the total damage and performing the binary search will naturally find the correct minimum k for these edge cases.\n", "requirement analysis:\nThe problem requires finding the smallest k such that the total poison damage to the dragon is at least h. This involves calculating the time intervals between attacks and determining the minimum k that ensures the total damage is met. The solution should be efficient enough to handle up to 1000 test cases within the given constraints.\nrequirement pool:\n- Implement a function to calculate the minimum k for each test case\n- Ensure the solution is efficient and can handle up to 1000 test cases\n- Provide clear and concise output for each test case\n- Ensure the program is user-friendly and easy to understand\nTo solve this problem, we will use a binary search approach to find the minimum value of k. This method is efficient and suitable for handling the large range of possible values for k. We will calculate the total damage dealt by Monocarp's attacks considering the poison effect and binary search will help us find the smallest k that meets the required damage.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'poison damage': The damage is applied over a duration (k seconds) and deals 1 damage each second. If the poison effect is active, it resets and lasts longer.\n    Explanation: Monocarp's attacks with a poisoned dagger apply poison for k seconds each time it hits, dealing 1 damage each second. If the poison effect is active when a new attack occurs, it resets and continues for an additional k seconds.\n\n# [phrase showing quantity relationship]\n    'at least as many times': means the number of times a poison effect occurs is greater than or equal to the integer itself.\n    Explanation: In this context, 'at least as many times' refers to the number of times the poison effect is active compared to the integer value, which represents the duration of the poison effect.\n\n# [degree adverb] \n    'smallest': means the smallest value of k that will result in the total poison damage being at least h.\n    Explanation: 'Smallest' refers to the minimum value of k that ensures Monocarp's total poison damage to the dragon is at least h, allowing him to slay the dragon.\n\n# [code logic]\n    To implement the solution, we will use a binary search approach to find the minimum value of k. We will calculate the total damage dealt by Monocarp's attacks considering the poison effect and binary search will help us find the smallest k that meets the required damage.\n\n# [edge case] \n    Monocarp attacks at the same time:\n    Monocarp attacks at the same time, resulting in overlapping poison effects.\n    Expected output: 1\n    Explanation: If Monocarp attacks at the same time, the poison effect will only last for k seconds, and the total damage will be k. If k is 1, the poison effect will apply for 1 second, and if k is greater than 1, the poison effect will apply for more than 1 second.\n\n# [extra code for edge case]\n    We do not need extra code to handle this edge case, as the binary search approach inherently handles cases where attacks are at the same time by considering the total duration of the poison effect.\n\n# [edge case] \n    Monocarp attacks at the same time:\n    Monocarp attacks at the same time, resulting in overlapping poison effects.\n    Expected output: 1\n    Explanation: If Monocarp attacks at the same time, the poison effect will only last for k seconds, and the total damage will be k. If k is 1, the poison effect will apply for 1 second, and if k is greater than 1, the poison effect will apply for more than 1 second.\n\n# [extra code for edge case]\n    We do not need extra code to handle this edge case, as the binary search approach inherently handles cases where attacks are at the same time by considering the total duration of the poison effect.\n", "requirement analysis:\nThe problem requires finding the minimum value of k such that Monocarp's attacks, with the poison effect lasting k seconds, result in at least h damage to the dragon. This involves calculating the cumulative damage dealt by the poison effect across the battle duration and adjusting k until the required damage is met or exceeded.\nrequirement pool:\n- Implement a function to calculate the cumulative damage dealt by the poison effect.\n- Develop a method to determine the minimum k required to deal at least h damage.\n- Ensure the solution is efficient enough to handle up to 1000 test cases.\nTo solve this problem, we will use a binary search approach to find the minimum value of k. This approach will be efficient and suitable for handling the large input sizes specified in the problem. We will calculate the cumulative damage dealt by the poison effect for a given k and use binary search to find the minimum k that ensures at least h damage is dealt.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'binary search': This is a method to find the minimum value of k efficiently by repeatedly dividing the search interval in half.\n\n# [phrase showing quantity relationship]\n    'at least': This phrase indicates that the required damage must be met or exceeded.\n\n# [degree adverb] \n    'minimum possible': This implies that we need to find the smallest value of k that still meets the requirement.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the number of test cases and iterate through each case.\n    2. For each test case, read the number of attacks and the required damage.\n    3. Read the attack times and sort them.\n    4. Use binary search to find the minimum k.\n    5. For each potential k, calculate the cumulative damage dealt by the poison effect.\n    6. Return the minimum k that ensures at least h damage is dealt.\n\n# [edge case] \n    Edge case 1:\n    Input: n = 3, h = 10, attacks = [1, 2, 3]\n    Explanation: The attacks are at seconds 1, 2, and 3. The poison effect would deal 1 damage during the 1st, 2nd, and 3rd seconds. The total damage is 3, which is less than h. The minimum k to deal at least h damage is 4.\n    Edge case 2:\n    Input: n = 2, h = 5, attacks = [1, 10]\n    Explanation: The attacks are at seconds 1 and 10. The poison effect would deal 1 damage during the 1st, 2nd, 3rd, and 4th seconds, and then again during the 10th, 11th, 12th, and 13th seconds. The total damage is 2, which is less than h. The minimum k to deal at least h damage is 5.\n    Edge case 3:\n    Input: n = 1, h = 1, attacks = [1]\n    Explanation: There is only one attack at the start of the battle. The poison effect would deal 1 damage during the 1st second. The total damage is 1, which is equal to h. The minimum k to deal at least h damage is 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the attacks are very close together or very far apart.\n    For example, if the attacks are at the same time, we need to ensure that the poison effect is applied correctly without overlapping.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 33, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "condense_two2one", "parent_index": 40}
