{"name": "1591_B. Array Eversion", "description": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "tags": ["greedy"], "difficulty": 8, "id": 1591, "sample_io": [{"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}], "test_list": [{"input": "2\n1\n998244353\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 1 1\n", "output": ["1\n3\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 1\n", "output": ["0\n2\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 8 2\n2\n1 1 1 1\n", "output": ["1\n1\n0\n"]}, {"input": "3\n5\n2 8 1 4 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["2\n2\n0\n"]}, {"input": "3\n5\n2 1 1 5 6\n5\n5 3 4 4 1\n2\n0 1 1 1\n", "output": ["0\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n802364611\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 4 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n4 2 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 3 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 1 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n4 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 3 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n68829976\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 3 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 2 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 3 0 2\n", "output": ["0\n2\n"]}, {"input": "2\n1\n998244353\n4\n1 1 0 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 2 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 0 1\n", "output": ["1\n3\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n56749180\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1528037704\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n0 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n37862951\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 4 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n134212618\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n13173955\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n314070686\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n802364611\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n4 1 4 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 1 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 1 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n7 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 3 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n41454457\n4\n4 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 0 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n4 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n176445854\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n381715760\n4\n0 2 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 4\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 4 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n993551853\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n2 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1981447801\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 2 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n3 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 6 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 5 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 0 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 7 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n134212618\n4\n4 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n626625781\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n6643808\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 6 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 0 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 4 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 1 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 7 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n316067198\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 2\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n993551853\n4\n3 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1258355607\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1961051652\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 5 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n75994590\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 0 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n533265820\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n627592454\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n4 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 4 6 6\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n1 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 5 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n134212618\n4\n1 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n7874846\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n3\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 12 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n7680692\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n3713787\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n316067198\n4\n-1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n711911604\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n39720822\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 0 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1258355607\n4\n6 0 2 4\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n6 1 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 0 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n112473576\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 0 3\n", "output": ["0\n0\n"]}], "task_id": "codecontest/46", "prompt": "You have an array a with a size of n.\n\nLet's define the eversion operation where x = a_n and then the array a is partitioned into two parts: left and right, with the left part containing elements of a that are not greater than x (\u2264 x) and the right part containing elements of a that are strictly greater than x (> x). The sequence of elements within each part remains unchanged as before the operation, i.e., the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion progresses as follows: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on it. It can be shown that after a number of eversions the array a will no longer change. Output the smallest number k such that the array remains unchanged after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "repair_prompt": ["You have an array a with a size of n.\n\nLet's define the eversion operation where x = a_n and then the array a is partitioned into two parts: left and right, with the left part containing elements of a that are not greater than x (\u2264 x) and the right part containing elements of a that are strictly greater than x (> x). The sequence of elements within each part remains unchanged as before the operation, i.e., the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion progresses as follows: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on it. It can be shown that after a number of eversions the array a will no longer change. Output the smallest number k such that the array remains unchanged after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin", " You have an array a with a size of n. Let's define the eversion operation where x = a_n and then the array a is partitioned into two parts: left and right, with the left part containing elements of a that are not greater than x (\u2264 x) and the right part containing elements of a that are strictly greater than x (> x). The sequence of elements within each part remains unchanged as before the operation, i.e., the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, \n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin", " We have an array a with a size of n. The eversion operation involves partitioning the array into two parts based on a pivot element x = a_n, where the left part contains elements \u2264 x and the right part contains elements > x. The sequence within each part remains unchanged. After performing eversions on the array, we need to find the smallest number k such that the array remains unchanged after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef find_stable_eversion_count(arr: List[int]) -> int:\n    def partition(arr: List[int], low: int, high: int) -> int:\n        pivot = arr[high]\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\n    def stable_partition(arr: List[int], low: int, high: int) -> int:\n        if low < high:\n            pi = partition(arr, low, high)\n            stable_partition(arr, low, pi - 1)\n            stable_partition(arr, pi + 1, high)\n\n    original_arr = arr.copy()\n    eversion_count = 0\n    while True:\n        max_index = arr.index(max(arr))\n        arr[max_index], arr[-1] = arr[-1], arr[max_index]\n        partition(arr, 0, len(arr) - 1)\n        eversion_count += 1\n        if arr == original_arr:\n            break\n        arr = arr[:-1]\n    return eversion_count\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_stable_eversion_count(arr)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef find_stable_iterations(arr: List[int]) -> int:\n    def partition(arr: List[int], pivot: int) -> (List[int], List[int]):\n        left = []\n        right = []\n        for num in arr:\n            if num <= pivot:\n                left.append(num)\n            else:\n                right.append(num)\n        return left, right\n\n    def eversion(arr: List[int]) -> List[int]:\n        if not arr:\n            return arr\n        pivot = max(arr)\n        left, right = partition(arr, pivot)\n        return left + right\n\n    if not arr:\n        return 0\n\n    iterations = 0\n    while True:\n        new_arr = eversion(arr)\n        iterations += 1\n        if new_arr == arr:\n            break\n        arr = new_arr\n\n    return iterations\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    arr_size = int(input())\n    arr = list(map(int, input().split()))\n    result = find_stable_iterations(arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_stable_k(arr: List[int]) -> int:\n    def partition(arr: List[int], pivot: int) -> (List[int], List[int]):\n        left = [x for x in arr if x <= pivot]\n        right = [x for x in arr if x > pivot]\n        return left, right\n\n    def eversion(arr: List[int]) -> List[int]:\n        if not arr:\n            return arr\n        pivot = max(arr)\n        left, right = partition(arr, pivot)\n        return left + right\n\n    k = 0\n    while True:\n        original_arr = arr.copy()\n        arr = eversion(arr)\n        if arr == original_arr:\n            break\n        k += 1\n    return k\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_stable_k(arr)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef eversion_operation(arr: List[int]) -> List[int]:\n    def stable_partition(arr, low, high, pivot):\n        left = low\n        right = high\n        while left <= right:\n            while left <= right and arr[left] <= pivot:\n                left += 1\n            while left <= right and arr[right] > pivot:\n                right -= 1\n            if left < right:\n                arr[left], arr[right] = arr[right], arr[left]\n        return left\n\n    def eversion_recursive(arr, low, high):\n        if low >= high:\n            return arr\n        pivot = arr[high]\n        partition_index = stable_partition(arr, low, high, pivot)\n        eversion_recursive(arr, low, partition_index - 1)\n        eversion_recursive(arr, partition_index, high)\n        return arr\n\n    return eversion_recursive(arr, 0, len(arr) - 1)\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    _ = input()  # Skip the size of the array\n    arr = list(map(int, input().split()))\n    result = eversion_operation(arr)\n    print(len(result) - 1)  # Print the number of eversions\n", "from typing import List\n## main.py\nimport itertools\n\ndef eversion_operation(arr: list) -> list:\n    def partition(arr, pivot):\n        left = [x for x in arr if x <= pivot]\n        right = [x for x in arr if x > pivot]\n        return left + right\n\n    if len(arr) == 1:\n        return 0\n\n    pivot = max(arr)\n    original_arr = arr[:]\n    k = 0\n\n    while True:\n        arr = partition(arr, pivot)\n        k += 1\n        if arr == original_arr:\n            break\n        original_arr = arr[:]\n\n    return k\n\n# Provide the Interface\nn = int(input())\na = list(map(int, input().split()))\nresult = eversion_operation(a)\nprint(result)\n", "from typing import List\n## main.py\n\nimport sys\n\ndef eversion_operation(arr: list) -> int:\n    def partition(arr: list, pivot: int) -> tuple:\n        left = [x for x in arr if x <= pivot]\n        right = [x for x in arr if x > pivot]\n        return left, right\n\n    def is_stable(arr: list, prev_arr: list) -> bool:\n        return arr == prev_arr\n\n    iterations = 0\n    while True:\n        pivot = arr[0]  # Use the first element as the pivot\n        left, right = partition(arr, pivot)\n        arr = left + right\n        iterations += 1\n        if is_stable(arr, prev_arr=arr):\n            break\n\n    return iterations\n\n# Interface\nt = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    arr = list(map(int, input().strip().split()))\n    result = eversion_operation(arr)\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef find_eversion_count(arr: List[int]) -> int:\n    k = 0\n    while True:\n        pivot = arr[-1]\n        left = [x for x in arr[:-1] if x <= pivot]\n        right = [x for x in arr[:-1] if x > pivot]\n        arr = left + [pivot] + right\n        k += 1\n        if arr == left + [pivot] + right:\n            break\n    return k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = find_eversion_count(a)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef find_stable_eversions(n: int, arr: List[int]) -> int:\n    def partition(arr: List[int], pivot: int) -> List[int]:\n        left = [x for x in arr if x <= pivot]\n        right = [x for x in arr if x > pivot]\n        return left, right\n\n    def is_stable(arr: List[int]) -> bool:\n        return arr == sorted(arr)\n\n    k = 0\n    while not is_stable(arr):\n        pivot = arr[-1]\n        left, right = partition(arr[:-1], pivot)\n        arr = left + [pivot] + right\n        k += 1\n    return k\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        result = find_stable_eversions(n, arr)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\nfrom typing import List\n\ndef find_eversions(arr: List[int]) -> int:\n    def partition(arr, pivot):\n        left = [x for x in arr if x <= pivot]\n        right = [x for x in arr if x > pivot]\n        return left, right\n\n    original_arr = arr[:]\n    pivot = arr[-1]\n    k = 0\n\n    while True:\n        left, right = partition(arr, pivot)\n        arr = left + right\n        k += 1\n        if arr == original_arr:\n            break\n        original_arr = arr[:]\n\n    return k\n\n# Provide the Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_eversions(arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_stable_k(arr: List[int]) -> int:\n    def is_stable(arr: List[int]) -> bool:\n        for i in range(len(arr)):\n            if arr[i] != i + 1:\n                return False\n        return True\n\n    def partition(arr: List[int], pivot: int) -> List[List[int]]:\n        left = []\n        right = []\n        for num in arr:\n            if num <= pivot:\n                left.append(num)\n            else:\n                right.append(num)\n        return [left, right]\n\n    k = 0\n    while not is_stable(arr):\n        pivot = arr[-1]\n        parts = partition(arr, pivot)\n        arr = parts[0] + parts[1]\n        k += 1\n    return k\n\n# Read input\nn = int(input())\nfor _ in range(n):\n    arr = list(map(int, input().split()))\n    k = find_stable_k(arr)\n    print(k)\n"], "plans": ["requirement analysis:\nThe problem requires understanding the eversion operation and how it affects the array. The goal is to find the smallest number of eversions after which the array stops changing. This involves partitioning the array based on a pivot element and then concatenating the partitions. The solution should be efficient and handle large inputs within reasonable time limits.\nrequirement pool:\n- Implement the eversion operation and partitioning logic\n- Ensure the solution is efficient and handles large inputs\n- Output the smallest number of eversions after which the array stops changing\n- Optimize the algorithm for better performance\n- Add user interface elements for better user interaction\nTo solve this problem, we will implement a Python function that simulates the eversion operation on an array. The function will repeatedly partition the array based on a pivot element until the array no longer changes. We will use a stable partition algorithm to ensure the partition remains stable. The function will return the number of eversions after which the array stops changing.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning an array based on a pivot element such that elements less than or equal to the pivot are on one side and elements greater than the pivot are on the other side. The partition is stable, meaning the relative order of elements is preserved within each partition.\n    Explanation: The eversion operation is a key concept as it defines how the array is transformed in each step. The partitioning helps in organizing the array elements based on their relationship with the pivot, which is crucial for determining the number of eversions needed for the array to stabilize.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that the pivot element must be greater than some value.\n    Explanation: In the context of the eversion operation, this phrase is used to define the boundary for partitioning the array. The pivot element must be greater than some value to ensure the array is partitioned correctly.\n\n# [degree adverb] \n    'largest': This adverb indicates that the pivot element should be the largest in the array.\n    Explanation: The largest element is chosen as the pivot to ensure that the array is partitioned in a way that minimizes the number of eversions needed for the array to stabilize.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation, we need to:\n    1. Find the largest element in the array.\n    2. Partition the array based on this largest element.\n    3. Repeat the partitioning process until the array no longer changes.\n    4. Count the number of eversions performed.\n\n# [edge case] \n    Edge case 1: Array with all elements being the same.\n    Edge case 2: Array with a single element.\n    Edge case 3: Array with elements in descending order.\n\n    Edge case 1 = 0\n    Explanation: If the array consists of identical elements, the array will not change after the first eversion since the largest element is the same as all other elements.\n\n    Edge case 2 = 0\n    Explanation: A single-element array will not change after the first eversion since the largest element is the same as itself.\n\n    Edge case 3 = 1\n    Explanation: If the array is in descending order, the first eversion will make the array in ascending order, and the array will not change afterward since the largest element is now the smallest element.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic for partitioning and counting eversions naturally handles these cases without additional code.\n", "requirement analysis:\nThe requirement involves understanding the concept of stable partitioning and eversion operations on an array. The goal is to determine the number of iterations required for the array to become stable after repeated eversion operations. The input size can be large, so the solution must be optimized for performance. The output should be precise and accurate for each test case.\nrequirement pool:\n- Implement the eversion operation and stable partitioning logic.\n- Ensure the solution can handle large inputs efficiently.\n- Develop a clear and concise algorithm to determine the number of iterations.\n- Optimize the code for better performance on large datasets.\n- Include error handling and input validation to ensure robustness.\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The key steps involve implementing the eversion operation, partitioning the array, and determining the number of iterations until the array becomes stable. We will use a stable partitioning algorithm to ensure the array remains sorted correctly after each eversion operation. The main challenge is to optimize the solution to handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning an array based on a pivot element and then concatenating the partitioned parts while maintaining the order within each part. The goal is to find the number of such operations required to stabilize the array.\n    Explanation: The eversion operation splits the array into two parts: one with elements less than or equal to the pivot (left part) and the other with elements greater than the pivot (right part). This operation is repeated until the array no longer changes.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the pivot element must be greater than the elements in the left part and less than the elements in the right part.\n    Explanation: In the requirement, 'more than' is used to define the relationship between the pivot and the elements in the left and right parts of the array.\n\n# [degree adverb] \n    'largest': Indicates that the pivot element should be the largest in the array to ensure the most significant change in the array's structure.\n    Explanation: The 'largest' adverb suggests that the pivot should be chosen as the maximum element in the array to maximize the difference between the left and right parts, leading to more significant changes in the array.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to:\n    1. Iterate through the array to find the largest element as the pivot.\n    2. Partition the array based on the pivot.\n    3. Repeat the partitioning and concatenation until the array no longer changes.\n    4. Count the number of iterations required to stabilize the array.\n\n# [edge case] \n    Edge case 1: [1, 1, 1, 1] = 0\n    Explanation: The array is already stable since all elements are the same. No eversions are needed, so the output is 0.\n    Edge case 2: [5, 4, 3, 2, 1] = 1\n    Explanation: The largest element is 5, and after one eversion, the array becomes [4, 3, 2, 1, 5], which is stable.\n    Edge case 3: [2, 1, 3, 3, 3] = 2\n    Explanation: The largest element is 3. After the first eversion, the array becomes [2, 1, 3, 3, 3] \u2192 [2, 1, 3], [3, 3] \u2192 [2, 1, 3, 3, 3]. After the second eversion, the array becomes [2, 1, 3, 3, 3] \u2192 [2, 1, 3], [3, 3] \u2192 [2, 1, 3, 3, 3], which is stable.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the code logic section is sufficient to handle arrays that are already stable or arrays with a single unique element.\n", "requirement analysis:\nThe problem requires understanding the eversion operation and its effect on the array. The goal is to find the minimum number of eversions after which the array stops changing. This involves partitioning the array based on a pivot element and checking if the array remains stable after each partition. The solution should be efficient enough to handle large inputs within the given constraints.\nrequirement pool:\n- Implement the eversion operation and ensure it is stable.\n- Optimize the algorithm to handle large inputs efficiently.\n- Ensure the solution is easy to understand and implement.\n- Provide a clear and concise output for the number of eversions.\n- Test the solution with various edge cases to ensure robustness.\nTo solve this problem, we will use Python due to its simplicity and efficiency. The eversion operation involves partitioning the array based on a pivot element, which can be efficiently handled using list comprehension and partitioning techniques. We will iterate through the array, performing eversions until the array no longer changes. The key challenge is to ensure the solution is scalable and efficient, especially for large inputs.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element, which can be efficiently handled using list comprehension and partitioning techniques.\n    Explanation: The eversion operation splits the array into two parts based on a chosen pivot element. The left part contains elements less than or equal to the pivot, and the right part contains elements greater than the pivot. This operation is repeated until the array no longer changes.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find elements greater than a certain value.\n    Explanation: In the context of the eversion operation, this phrase is used to define the right part of the array, which contains elements strictly greater than the pivot.\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the largest element in the array to use as the pivot.\n    Explanation: In the eversion operation, the largest element is chosen as the pivot to ensure that the array is partitioned effectively.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation, we need to:\n    1. Find the largest element in the array to use as the pivot.\n    2. Partition the array into two parts based on the pivot.\n    3. Repeat the partitioning process until the array no longer changes.\n\n# [edge case] \n    Edge case 1: [1, 1, 1, 1] = 0\n    Explanation: If the array consists entirely of the same element, the array will not change after the first eversion since the pivot will be the same element.\n    Edge case 2: [2, 2, 3, 3, 3] = 1\n    Explanation: The array will change after the first eversion since the largest element is 3, and the array will be partitioned into [2, 2] and [3, 3, 3].\n    Edge case 3: [5, 5, 4, 4, 4] = 2\n    Explanation: The array will change after the first eversion since the largest element is 5, and the array will be partitioned into [4, 4, 4] and [5, 5]. The second eversion will not change the array since both parts are already sorted.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle arrays with all identical elements and arrays with multiple partitions.\n", "requirement analysis:\nThe requirement involves defining the eversion operation on an array and determining the number of iterations required for the array to stop changing. The input consists of multiple test cases, each with a specified number of elements and their values. The output should provide the number of eversions for each test case.\nrequirement pool:\n- Implement the eversion operation on the array\n- Ensure the array partition is stable\n- Handle multiple test cases efficiently\n- Optimize the solution for large arrays\nTo implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element, which is the last element of the array. This operation is repeated until the array stops changing. We will use a stable partition function to ensure the array remains partitioned correctly.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element, which is the last element of the array. The operation is repeated until the array stops changing. The partitioning is stable, meaning the relative order of elements within each part remains unchanged.\n\n    Explanation: The eversion operation is a way to rearrange the elements of an array based on a pivot. The pivot is the last element of the array. The array is divided into two parts: one with elements less than or equal to the pivot and the other with elements greater than the pivot. This process is repeated iteratively until the array no longer changes.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element, which is the last element of the array. This operation is repeated until the array stops changing. We will use a stable partition function to ensure the array remains partitioned correctly.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Expected output: 0\n    Explanation: The array is already sorted, so no eversions are needed, and the array does not change.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 1\n    Explanation: The array is in reverse order. After one eversion operation, the array becomes [4, 5, 3, 2, 1], which is not sorted.\n\n    Edge case 3: [2, 2, 2, 2, 1]\n    Expected output: 1\n    Explanation: The array has multiple elements equal to the pivot. After one eversion operation, the array becomes [2, 2, 2, 2, 1], which is not sorted.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The core logic of the eversion operation will naturally handle these cases without additional code.\n", "requirement analysis:\nThe requirement involves implementing the eversion operation on an array, which involves partitioning the array based on a pivot element and then concatenating the partitions. The challenge lies in ensuring that the partitioning is stable and the process is efficient, especially with large arrays.\nrequirement pool:\n- Implement the eversion operation with stable partitioning.\n- Ensure the algorithm is efficient and can handle large arrays.\n- Provide visual feedback on the array after each eversion.\n- Include user settings to customize the eversion behavior.\nTo implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element, which can be efficiently handled using list comprehensions and slicing. We will ensure that the partitioning is stable and the process is efficient, especially with large arrays.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'partitioning': The process of dividing a list into two parts based on a pivot element, maintaining the order of elements within each part.\n    Explanation: In the requirement, the eversion operation involves splitting the array into two parts where the left part contains elements not greater than the pivot (\u2264 pivot) and the right part contains elements strictly greater than the pivot (> pivot). This partitioning is crucial for the operation to work correctly.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number of elements in the right part must be greater than the number of elements in the left part.\n    Explanation: The phrase 'strictly greater than' is used to define the elements that belong to the right part of the array. This relationship is essential for the partitioning process.\n\n# [degree adverb] \n    'largest': Indicates that the pivot element should be the largest in the array to ensure the right part contains elements greater than it.\n    Explanation: The phrase 'largest integer' suggests that the pivot should be chosen as the maximum value in the array to maximize the number of elements in the right part.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation efficiently, we can follow these steps:\n    1. Identify the pivot element as the maximum value in the array.\n    2. Partition the array into two parts based on the pivot element.\n    3. Concatenate the left and right parts to form the new array.\n    4. Repeat the process until the array stops changing.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5] = 1\n    Explanation: The array is already sorted in ascending order, so the first partition will result in the array being split into [1] and [2, 3, 4, 5], and the process stops as the array does not change.\n    Edge case 2: [5, 4, 3, 2, 1] = 1\n    Explanation: The array is sorted in descending order, so the first partition will result in the array being split into [5, 4, 3] and [2, 1], and the process stops as the array does not change.\n    Edge case 3: [3, 1, 2, 4, 5] = 2\n    Explanation: The array will undergo two eversion operations before it stops changing. The first operation will split the array into [3, 1, 2] and [4, 5], and the second operation will split the array into [3, 1] and [2], and the array stops changing.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 1:\n            return 0\n        (other code)\n", "requirement analysis:\nThe requirements specify the need for a program that can perform the eversion operation on an array and determine the number of iterations until the array stops changing. The input is provided in a format that allows for multiple test cases, and the output should reflect the number of iterations for each test case. The constraints indicate that the size of the array and the number of test cases are limited, which simplifies the implementation.\nrequirement pool:\n- Implement the eversion operation on an array\n- Determine the number of iterations until the array stops changing\n- Handle multiple test cases efficiently\n- Ensure the program is user-friendly and provides clear output\nTo implement the eversion operation on an array and determine the number of iterations until the array stops changing, we will use Python's built-in sorting capabilities and leverage its efficiency for handling large datasets. The program will read multiple test cases, each containing an array of integers, perform the eversion operation iteratively, and count the number of iterations until the array stops changing. The output will be the number of iterations for each test case.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning an array based on a pivot element, where elements less than or equal to the pivot are placed in one subarray and elements greater than the pivot are placed in another subarray. The subarrays maintain the order of their elements as before the operation.\n    Explanation: The eversion operation is a way to rearrange the elements of an array based on a chosen pivot. This operation is repeated until the array no longer changes, indicating a stable partition.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find integers greater than the pivot.\n    Explanation: In the eversion operation, the pivot element divides the array into two parts: elements greater than the pivot and elements less than or equal to the pivot.\n\n# [degree adverb] \n    'largest': This adverb suggests that we need to find the largest integer in the array to use as the pivot.\n    Explanation: The pivot should be the largest element in the array to ensure that the array is partitioned effectively.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The eversion operation involves partitioning the array based on a pivot and then concatenating the two parts. The process should be repeated until the array stops changing.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Expected output: 1\n    Explanation: In this case, the array is already sorted in ascending order. The first eversion operation will partition the array into [1, 2, 3] and [4, 5], and the array stops changing after the first iteration.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 1\n    Explanation: This array is sorted in descending order. The first eversion operation will partition the array into [5] and [4, 3, 2, 1], and the array stops changing after the first iteration.\n\n    Edge case 3: [3, 1, 2, 4, 5]\n    Expected output: 2\n    Explanation: In this case, the array will undergo two eversion operations. The first operation will partition the array into [1, 2] and [3, 4, 5], and the second operation will partition the array into [1] and [2, 3, 4, 5], stopping the process.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic will work for these cases as the array will either be sorted or will reach a stable partition after a few iterations.\n", "requirement analysis:\nThe problem requires partitioning the array based on a pivot element and counting the number of eversions until the array stops changing. The solution should be efficient and scalable to handle large inputs. The algorithm should be able to determine the number of eversions for each test case efficiently.\nrequirement pool:\n- Implement the eversion operation to partition the array\n- Count the number of eversions until the array stops changing\n- Ensure the solution is optimized for performance\n- Handle edge cases and large inputs effectively\n- Provide clear and concise documentation\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The main challenge is to efficiently partition the array and count the number of eversions until the array stops changing. We will use a simple and efficient approach to achieve this.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'array partitioning': This involves dividing the array into two parts based on a pivot element, where the left part contains elements less than or equal to the pivot, and the right part contains elements greater than the pivot. The sequence within each part remains unchanged.\n    Explanation: This concept is crucial for understanding the eversion operation, which is the main operation in this problem. It helps in determining how the array will be partitioned and how many times the eversion operation will be performed until the array stops changing.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find the smallest number k such that the array remains unchanged after k eversions.\n    Explanation: The phrase \"more than\" is used to specify that we are looking for the smallest number of eversions that will result in the array not changing. This means we need to perform the eversion operation repeatedly until the array no longer changes.\n\n# [degree adverb] \n    'smallest': This adverb indicates that we need to find the smallest number k that satisfies the condition.\n    Explanation: The word \"smallest\" is used to specify that we are looking for the minimum number of eversions required for the array to stop changing. This means we need to find the minimum k such that the array remains unchanged after k eversions.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to follow these steps:\n    1. Read the input from stdin.\n    2. For each test case, perform the eversion operation repeatedly until the array stops changing.\n    3. Count the number of eversions performed.\n    4. Output the count for each test case.\n\n# [edge case] \n    Edge case 1: The array remains unchanged after the first eversion.\n    Edge case 2: The array remains unchanged after multiple eversions.\n    Edge case 3: The array does not change even after a large number of eversions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n    To handle edge cases where the array remains unchanged after a large number of eversions, we can use a loop that continues until the array stops changing. If the array does not change after a certain number of eversions, we can break out of the loop and return the count of eversions performed.\n\n# Main function to read input and perform eversion operations\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        k = 0\n        while True:\n            pivot = a[-1]\n            left = [x for x in a[:-1] if x <= pivot]\n            right = [x for x in a[:-1] if x > pivot]\n            a = left + [pivot] + right\n            k += 1\n            if a == a[:-1] + [pivot]:\n                break\n        \n        results.append(k)\n    \n    for result in results:\n        print(result)\n\n# Call the main function\nmain()\n", "requirement analysis:\nThe requirement involves partitioning an array based on a pivot element and counting the number of eversions until the array remains unchanged. The challenge lies in efficiently handling large inputs and determining the smallest number of eversions required to stabilize the array.\nrequirement pool:\n- Implement the eversion operation to partition the array.\n- Ensure the algorithm is efficient and can handle large inputs.\n- Provide a user-friendly output to indicate the number of eversions.\n- Optimize the algorithm to find the smallest number of eversions.\n- Test the algorithm with various test cases to ensure correctness.\nTo solve this problem, we will use Python due to its efficiency and ease of handling large datasets. The main challenge is to partition the array based on a pivot element and count the number of eversions until the array remains unchanged. We will use a simple and efficient approach to achieve this.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'array partitioning': The process of dividing an array into two parts based on a pivot element, where the left part contains elements less than or equal to the pivot and the right part contains elements greater than the pivot.\n    Explanation: This is a fundamental operation in algorithms, especially in sorting and partitioning problems. It helps in solving problems where elements need to be grouped or sorted based on certain criteria.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number of elements in the right part of the array is greater than the number of elements in the left part.\n    Explanation: This phrase is used to specify the relationship between the sizes of the two partitions of the array.\n\n# [degree adverb] \n    'smallest': Indicates the minimum number of eversions required for the array to remain unchanged.\n    Explanation: This phrase is used to find the minimum value of k, which is the number of eversions after which the array stops changing.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To solve this problem, we need to perform the following steps:\n    1. Read the input from stdin.\n    2. For each test case, read the size of the array and the elements of the array.\n    3. Perform the eversion operation and count the number of eversions until the array remains unchanged.\n    4. Print the result for each test case.\n\n# [edge case] \n    Edge case 1: The array is already sorted.\n    Edge case 2: The array has all elements equal.\n    Edge case 3: The array has a single element.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    For edge case 1: If the array is already sorted, the number of eversions is 0.\n    For edge case 2: If all elements are equal, the number of eversions is 1.\n    For edge case 3: If the array has a single element, the number of eversions is 1.\n\n    def main():\n        t = int(input())\n        for _ in range(t):\n            n = int(input())\n            a = list(map(int, input().split()))\n            # Perform eversion operation and count the number of eversions\n            # ...\n            # Print the result\n            print(k)\n\n    if __name__ == \"__main__\":\n        main()\n", "requirement analysis:\nThe problem requires an efficient way to determine the number of eversions required for an array to remain unchanged. The eversion operation involves partitioning the array into two parts based on a pivot element and sorting each part independently. The solution should be scalable to handle large inputs and efficient in terms of time complexity to handle multiple test cases.\nrequirement pool:\n- Implement an efficient algorithm to determine the number of eversions for the array to remain unchanged.\n- Ensure the solution is scalable to handle large inputs within the given constraints.\n- Optimize the algorithm for performance to handle multiple test cases efficiently.\n- Provide a simple and straightforward approach to solve the problem.\n- Develop a complex solution that may not be efficient for large inputs.\nTo solve this problem efficiently, we will use Python's built-in data structures and functions to handle the array operations. The key steps involve partitioning the array based on the pivot element and checking if the array remains unchanged after each eversion. We will use list slicing and the partitioning logic to achieve this.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'array partitioning': This involves dividing the array into two parts based on a pivot element, where the left part contains elements less than or equal to the pivot and the right part contains elements greater than the pivot. The sequence within each part remains unchanged.\n    Explanation: This concept is crucial for understanding the eversion operation, which is the main task in the problem. By partitioning the array, we can ensure that the array is sorted relative to the pivot, and we can check for the stability of the sorted array.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find the number of elements in the array that are greater than the pivot.\n    Explanation: In the context of the problem, 'more than' is used to specify the condition for elements in the right part of the partitioned array.\n\n# [degree adverb] \n    'smallest': This adverb indicates that we need to find the minimum number of eversions required for the array to stop changing.\n    Explanation: The degree adverb 'smallest' is used to find the minimum value that satisfies the given condition, which in this case is the number of eversions.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the solution, we need to follow these steps:\n    1. For each test case, read the array size and the array elements.\n    2. Perform the eversion operation by partitioning the array based on the pivot element.\n    3. Check if the array remains unchanged after each eversion.\n    4. Return the number of eversions when the array stops changing.\n\n# [edge case] \n    Edge case 1: When the array is already sorted.\n    Edge case 2: When the array has all elements equal.\n    Edge case 3: When the array is in reverse order.\n\n    Edge case 1 = 1\n    Explanation: If the array is already sorted, it will not change after the first eversion.\n    Edge case 2 = 1\n    Explanation: If all elements in the array are equal, the array will not change after the first eversion.\n    Edge case 3 = 1\n    Explanation: If the array is in reverse order, it will not change after the first eversion.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic can handle these cases by checking if the array remains unchanged after the first eversion.\n", "requirement analysis:\nThe problem requires an efficient algorithm to determine the number of eversions for a given array. The solution should be scalable and capable of handling large inputs within the given constraints. The algorithm should be optimized to minimize computational time and resources. The solution should also be robust and capable of handling edge cases effectively.\nrequirement pool:\n- Implement an efficient algorithm to determine the number of eversions for a given array.\n- Ensure the solution is scalable and can handle large inputs within the constraints.\n- Optimize the solution to minimize computational time and resources.\n- Ensure the solution is robust and can handle edge cases effectively.\n- Provide easy validation and testing against various test cases.\nTo solve this problem, we will use Python due to its simplicity and efficiency. The main challenge is to simulate the eversion operation and determine the number of iterations required for the array to become stable. We will use a stable partition algorithm to ensure the array remains stable after each eversion. The process involves repeatedly partitioning the array based on a pivot element until no further changes occur.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element and then concatenating the partitioned parts. The partition is stable, meaning the relative order of elements within each partition remains unchanged.\n    'stable partition': This is crucial as it ensures that the order of elements within each partition is preserved, which is a key aspect of the eversion operation.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find an element in the array that appears more than a certain number of times.\n    'at least as many times': This phrase indicates that the element must appear at least as many times as its value.\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the largest integer that meets the criteria of appearing at least as many times as itself.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the input for each test case.\n    2. For each test case, perform eversion operations until the array no longer changes.\n    3. Count the number of eversions performed.\n    4. Output the count for each test case.\n\n# [edge case] \n    Edge case 1: [1, 1, 1]\n    Expected output: 1\n    Explanation: The array already satisfies the condition where each element appears at least as many times as itself. Therefore, only one eversion is needed.\n\n    Edge case 2: [2, 2, 3, 3, 3]\n    Expected output: 2\n    Explanation: The first eversion will result in [2, 2, 3, 3, 3] -> [2, 2, 3], [3, 3] -> [2, 2, 3, 3, 3]. The second eversion will result in [2, 2, 3, 3, 3] -> [2, 2, 3, 3, 3], [] -> [2, 2, 3, 3, 3]. The array remains unchanged after two eversions.\n\n    Edge case 3: [5, 5, 4, 4, 4]\n    Expected output: 1\n    Explanation: The first eversion will result in [4, 5, 4, 4, 4] -> [4, 4, 4], [5] -> [4, 4, 4, 5]. The second eversion will result in [4, 4, 4, 5] -> [4, 4, 4, 5], [] -> [4, 4, 4, 5]. The array remains unchanged after one eversion.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the provided logic already covers them. The edge cases provided are simple and straightforward, and the logic can be applied directly without additional handling.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 66, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "mutate_method": "rephrase_one", "parent_index": 71}
