{"name": "1591_B. Array Eversion", "description": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "tags": ["greedy"], "difficulty": 8, "id": 1591, "sample_io": [{"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}], "test_list": [{"input": "2\n1\n998244353\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 1 1\n", "output": ["1\n3\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 1\n", "output": ["0\n2\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 8 2\n2\n1 1 1 1\n", "output": ["1\n1\n0\n"]}, {"input": "3\n5\n2 8 1 4 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["2\n2\n0\n"]}, {"input": "3\n5\n2 1 1 5 6\n5\n5 3 4 4 1\n2\n0 1 1 1\n", "output": ["0\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n802364611\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 4 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n4 2 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 3 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 1 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n4 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 3 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n68829976\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 3 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 2 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 3 0 2\n", "output": ["0\n2\n"]}, {"input": "2\n1\n998244353\n4\n1 1 0 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 2 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 0 1\n", "output": ["1\n3\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n56749180\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1528037704\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n0 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n37862951\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 4 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n134212618\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n13173955\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n314070686\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n802364611\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n4 1 4 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 1 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 1 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n7 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 3 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n41454457\n4\n4 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 0 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n4 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n176445854\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n381715760\n4\n0 2 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 4\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 4 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n993551853\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n2 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1981447801\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 2 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n3 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 6 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 5 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 0 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 7 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n134212618\n4\n4 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n626625781\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n6643808\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 6 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 0 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 4 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 1 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 7 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n316067198\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 2\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n993551853\n4\n3 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1258355607\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1961051652\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 5 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n75994590\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 0 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n533265820\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n627592454\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n4 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 4 6 6\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n1 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 5 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n134212618\n4\n1 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n7874846\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n3\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 12 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n7680692\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n3713787\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n316067198\n4\n-1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n711911604\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n39720822\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 0 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1258355607\n4\n6 0 2 4\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n6 1 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 0 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n112473576\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 0 3\n", "output": ["0\n0\n"]}], "task_id": "codecontest/46", "prompt": "You are provided with an array a having a length of n.\n\nLet's define the eversion operation. Let x = a_n, and then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The sequence of elements within each part remains unchanged as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor instance, if the array a is [2, 4, 1, 5, 3], the eversion proceeds as follows: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe begin with the array a and carry out eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "repair_prompt": ["You are provided with an array a having a length of n.\n\nLet's define the eversion operation. Let x = a_n, and then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The sequence of elements within each part remains unchanged as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor instance, if the array a is [2, 4, 1, 5, 3], the eversion proceeds as follows: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe begin with the array a and carry out eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin", " You are given an array a with n elements. The eversion operation is defined as follows: choose the last element x = a_n, then partition the array into two parts, where the left part contains elements not greater than x (\u2264 x) and the right part contains elements strictly greater than x (> x). The sequence of elements within each part remains unchanged. After partitioning, the array is replaced by the concatenation of the left and right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion proceeds as follows: [2, 4\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin", " You are given an array a of length n. Define the eversion operation as follows: select the last element x = a_n, partition the array into two parts\u2014left (elements \u2264 x) and right (elements > x)\u2014and concatenate the left and right parts. Repeat this process until the array stops changing. Determine the minimum number of eversions k required for the array to reach a stable state.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. \nWrite a main() function and use input() function to read input from stdin"], "completions": ["from typing import List\nfrom typing import List\n\ndef find_stable_eversions(arr: List[int]) -> int:\n    def eversion_operation(array: List[int]) -> List[int]:\n        pivot = array[-1]\n        left = [x for x in array if x <= pivot]\n        right = [x for x in array if x > pivot]\n        return left + right\n\n    def is_stable(original: List[int], modified: List[int]) -> bool:\n        return original == modified\n\n    eversion_count = 0\n    while True:\n        original_arr = arr.copy()\n        arr = eversion_operation(arr)\n        eversion_count += 1\n        if is_stable(original_arr, arr):\n            break\n\n    return eversion_count\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    arr_length = int(input())\n    arr = list(map(int, input().split()))\n    result = find_stable_eversions(arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_stable_eversions(arr: List[int]) -> int:\n    def eversion_operation(array: List[int]) -> List[int]:\n        if not array:\n            return array\n        pivot = array[-1]\n        left = [x for x in array if x <= pivot]\n        right = [x for x in array if x > pivot]\n        return left + right\n\n    original_arr = arr[:]\n    eversion_count = 0\n\n    while True:\n        arr = eversion_operation(arr)\n        eversion_count += 1\n        if arr == original_arr:\n            break\n\n    return eversion_count\n\n# Interface\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_stable_eversions(arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef func(test_cases: int) -> None:\n    for _ in range(test_cases):\n        n = int(input())\n        a = list(map(int, input().split()))\n        \n        def eversion_operation(arr):\n            pivot = arr[-1]\n            left = [x for x in arr if x <= pivot]\n            right = [x for x in arr if x > pivot]\n            return left + right\n        \n        iterations = 0\n        while True:\n            new_array = eversion_operation(a)\n            iterations += 1\n            if new_array == a:\n                break\n            a = new_array\n        \n        print(iterations)\n\n# Provide the Interface\ntest_cases = int(input())\nfunc(test_cases)\n", "from typing import List\n## main.py\n\ndef eversion_count(arr: list) -> int:\n    def partition(arr, low, high):\n        pivot = arr[high]\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\n    def quick_sort(arr, low, high):\n        if low < high:\n            pi = partition(arr, low, high)\n            quick_sort(arr, low, pi - 1)\n            quick_sort(arr, pi + 1, high)\n\n    def is_sorted(arr):\n        return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))\n\n    eversion_count = 0\n    while not is_sorted(arr):\n        quick_sort(arr, 0, len(arr) - 1)\n        eversion_count += 1\n\n    return eversion_count\n\n# Provide the Interface\nn = int(input())\nfor _ in range(n):\n    arr = list(map(int, input().split()))\n    result = eversion_count(arr)\n    print(result)\n", "from typing import List\ndef eversion_count(arr: list) -> int:\n    def partition(arr, low, high):\n        pivot = arr[high]\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\n    def quick_sort(arr, low, high):\n        if low < high:\n            pi = partition(arr, low, high)\n            quick_sort(arr, low, pi - 1)\n            quick_sort(arr, pi + 1, high)\n\n    def is_sorted(arr):\n        return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))\n\n    count = 0\n    while not is_sorted(arr):\n        quick_sort(arr, 0, len(arr) - 1)\n        count += 1\n        if is_sorted(arr):\n            break\n        arr = [x for x in arr if x <= arr[0]] + [x for x in arr if x > arr[0]]\n\n    return count\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    arr = list(map(int, input().split()))\n    result = eversion_count(arr)\n    print(result)\n", "from typing import List\n## main.py\n\ndef eversion_count(arr: list) -> int:\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i = left     # Starting index for left subarray\n        j = mid + 1  # Starting index for right subarray\n        k = left     # Starting index to be sorted\n        inv_count = 0\n\n        # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                k += 1\n                i += 1\n            else:\n                # There are mid - i inversions, because all elements left to i in the left subarray\n                # are greater than arr[j]\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                k += 1\n                j += 1\n\n        # Copy the remaining elements of left subarray, if any\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n\n        # Copy the remaining elements of right subarray, if any\n        while j <= right:\n            temp_arr[k] = arr[j]\n            k += 1\n            j += 1\n\n        # Copy the sorted subarray into Original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n\n        return inv_count\n\n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n\n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n        return inv_count\n\n    n = len(arr)\n    temp_arr = [0] * n\n    return merge_sort_and_count(arr, temp_arr, 0, n - 1)\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = eversion_count(arr)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_eversions(arr: List[int]) -> int:\n    def eversion(arr: List[int]) -> List[int]:\n        if len(arr) <= 1:\n            return arr\n        pivot = arr[-1]\n        left = [x for x in arr[:-1] if x <= pivot]\n        right = [x for x in arr[:-1] if x > pivot]\n        return left + [pivot] + right\n\n    def is_stable(arr: List[int], new_arr: List[int]) -> bool:\n        return arr == new_arr\n\n    count = 0\n    while True:\n        new_arr = eversion(arr)\n        if is_stable(arr, new_arr):\n            break\n        arr = new_arr\n        count += 1\n    return count\n\n# Provide the Interface\nn = int(input())\nfor _ in range(n):\n    arr_input = list(map(int, input().split()))\n    result = find_min_eversions(arr_input)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_stable_state(arr: List[int]) -> int:\n    def eversion_operation(array: List[int]) -> List[int]:\n        if len(array) <= 1:\n            return array\n        pivot = array[-1]\n        left = [x for x in array[:-1] if x <= pivot]\n        right = [x for x in array[:-1] if x > pivot]\n        return left + [pivot] + right\n\n    count = 0\n    while True:\n        new_arr = eversion_operation(arr)\n        if new_arr == arr:\n            break\n        arr = new_arr\n        count += 1\n    return count\n\n# Interface\nn = int(input())\nfor _ in range(n):\n    arr_len = int(input())\n    arr = list(map(int, input().split()))\n    result = find_stable_state(arr)\n    print(result)\n", "from typing import List\nfrom typing import List\n\ndef find_min_eversions(n: int, arr: List[int]) -> int:\n    def eversion_operation(arr: List[int]) -> List[int]:\n        if len(arr) <= 1:\n            return arr\n        pivot = arr[-1]\n        left = [x for x in arr[:-1] if x <= pivot]\n        right = [x for x in arr[:-1] if x > pivot]\n        return left + [pivot] + right\n\n    eversion_count = 0\n    while True:\n        new_arr = eversion_operation(arr)\n        if new_arr == arr:\n            break\n        arr = new_arr\n        eversion_count += 1\n    return eversion_count\n\n# Provide the Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_min_eversions(n, arr)\nprint(result)\n", "from typing import List\nfrom typing import List\n\ndef find_stable_state(arr: List[int]) -> int:\n    def partition(arr: List[int], low: int, high: int) -> int:\n        pivot = arr[high]\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\n    def quick_sort(arr: List[int], low: int, high: int) -> None:\n        if low < high:\n            pi = partition(arr, low, high)\n            quick_sort(arr, low, pi - 1)\n            quick_sort(arr, pi + 1, high)\n\n    n = len(arr)\n    if n == 0:\n        return 0\n\n    # Sort the array to find the largest pivot\n    quick_sort(arr, 0, n - 1)\n\n    # Find the largest pivot\n    largest_pivot = arr[-1]\n\n    # Count the number of partitions until the array stops changing\n    count = 0\n    while True:\n        pivot = arr[-1]\n        if pivot == largest_pivot:\n            break\n        largest_pivot = pivot\n        # Partition the array based on the largest pivot\n        partition_index = partition(arr, 0, n - 1)\n        count += 1\n\n    return count\n\n# Interface\nn = int(input())\narr = list(map(int, input().split()))\nresult = find_stable_state(arr)\nprint(result)\n"], "plans": ["requirement analysis:\nThe primary requirement is to determine the number of eversions required to stabilize an array. The array is partitioned based on a pivot element, and the partitioning is stable. The goal is to find the minimum number of eversions after which the array stops changing. This involves repeatedly partitioning the array until no further changes occur. The solution should be efficient enough to handle large arrays within the given constraints.\nrequirement pool:\n- Implement the eversion operation to partition the array.\n- Develop a loop to repeatedly apply the eversion operation until the array stabilizes.\n- Ensure the solution is optimized for performance to handle large inputs efficiently.\n- Include error handling to manage unexpected inputs.\n- Provide user feedback on the number of eversions required.\nTo solve this problem, we will use Python, leveraging its efficient handling of arrays and data structures. The eversion operation involves partitioning the array based on a pivot element, which is a common operation in sorting algorithms. We will implement a function that repeatedly applies this operation until the array stabilizes, meaning no further changes occur. This will involve creating a loop that continues until the array no longer changes after an eversion.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element, which is a common operation in sorting algorithms. The array is split into two parts: one with elements less than or equal to the pivot and the other with elements greater than the pivot.\n    Explanation: The eversion operation is a way to rearrange the elements of an array by selecting a pivot and partitioning the array around it. This operation is repeated until the array no longer changes after an eversion, indicating that the array has stabilized.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find the pivot where the split between the two parts of the array is maximized.\n    Explanation: The phrase 'more than' is used to find the pivot where the split between the two parts of the array is maximized. This helps in determining the point where the array stops changing after an eversion.\n\n# [degree adverb] \n    'minimum': This adverb indicates that we need to find the smallest number of eversions required for the array to stop changing.\n    Explanation: The degree adverb 'minimum' is used to find the smallest number of eversions required for the array to stop changing. This ensures that we find the optimal number of eversions needed to reach a stable state.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the number of test cases.\n    2. For each test case, read the length of the array and the elements of the array.\n    3. Implement the eversion operation to partition the array based on a pivot.\n    4. Repeat the eversion operation until the array stops changing.\n    5. Output the number of eversions required for the array to stop changing.\n\n# [edge case] \n    Edge Case 1: [1, 1, 1, 1] = 0\n    Explanation: The array already consists of identical elements, so no eversions are needed, and the array does not change.\n    Edge Case 2: [2, 1, 3, 4, 5] = 1\n    Explanation: The array requires one eversion to reach the stable state [1, 2, 3, 4, 5].\n    Edge Case 3: [5, 4, 3, 2, 1] = 4\n    Explanation: The array requires four eversions to reach the stable state [1, 2, 3, 4, 5].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic can handle arrays with identical elements and arrays that require a small number of eversions to reach a stable state.\n", "requirement analysis:\nThe problem requires understanding the eversion operation and implementing an algorithm that can determine the number of eversions required for an array to stabilize. The input consists of multiple test cases, each with a different array size and elements. The output should provide the minimum number of eversions for each test case. The solution should be efficient and handle large inputs within the given constraints.\nrequirement pool:\n- Implement the eversion operation and determine the number of eversions for each test case.\n- Ensure the solution is optimized for large inputs and handles edge cases effectively.\n- Provide clear and accurate output for each test case.\n- Test the solution with various test cases to ensure correctness.\nTo solve this problem, we will use a simple and efficient approach that leverages Python's built-in data structures and functions. The eversion operation can be efficiently handled by utilizing list operations and the concept of partitioning the array based on a pivot element. We will iterate through the array, performing the eversion operation until the array no longer changes. The key challenge is to ensure that the solution is optimized to handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array into two parts based on a pivot element (x), where the left part contains elements less than or equal to x, and the right part contains elements greater than x. The array is then reconstructed by concatenating these two parts.\n    Explanation: The eversion operation is a way to rearrange the elements of an array based on a chosen pivot, ensuring that the relative order of elements within each partition is preserved.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find an integer that appears more than its value in the array.\n    Explanation: For example, if we have an array [2, 2, 3, 3, 3], the number 3 appears more than 3 times (it appears 3 times), which satisfies the condition.\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the largest integer that meets the condition of appearing more than its value.\n    Explanation: For example, in the array [2, 2, 3, 3, 3], the number 3 is the largest integer that appears more than 3 times.\n\n# [code logic]\n    To implement the solution, we can follow these steps:\n    1. Iterate through the array to find the largest integer that appears more than its value.\n    2. If no such integer exists, return -1.\n    3. Return the count of eversions required for the array to stop changing.\n\n# [edge case] \n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: In this case, the number 3 appears more than 3 times (it appears 3 times), which satisfies the condition. The largest integer that meets this condition is 3.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    Explanation: In this case, no integer appears more than its value. The number 2 appears once, the number 3 appears twice, and the number 4 appears three times, which does not satisfy the condition. Therefore, the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to determine if there is a valid integer that meets the condition. If no such integer exists, the function will return -1.\n", "requirement analysis:\nThe problem requires understanding the eversion operation and implementing a stable partition algorithm. The input is a series of test cases, each with a specified number of elements and their values. The output is the number of eversions required for the array to stop changing. The challenge lies in efficiently handling large datasets and ensuring the solution is both correct and optimized.\nrequirement pool:\n- Implement the eversion operation and stable partition algorithm.\n- Handle multiple test cases efficiently.\n- Optimize the algorithm for time and space complexity.\n- Ensure the application is user-friendly and handles large inputs well.\n- Provide clear and concise output for the number of eversions.\nTo solve this problem, we will use Python, leveraging its efficient handling of large datasets and ease of implementation. The eversion operation involves partitioning the array based on a pivot element, which is the last element of the array. This partition is stable, meaning that elements equal to the pivot are placed together in the partitioned array. We will implement a function that performs the eversion operation iteratively until the array no longer changes. The number of iterations required to reach a stable state will be the output. We will use a simple and efficient approach to ensure the solution is both correct and optimized.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves partitioning the array based on a pivot element, which is the last element of the array. The partition is stable, meaning elements equal to the pivot are placed together.\n    Explanation: The eversion operation rearranges the array by using the last element as a pivot. The array is split into two parts: one with elements less than or equal to the pivot and the other with elements greater than the pivot. This process is repeated until the array no longer changes.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find elements greater than a certain value.\n    Explanation: In the context of the eversion operation, this phrase is used to identify elements that should be placed in the right part of the partitioned array.\n\n# [degree adverb] \n    'largest': This adverb indicates that we need to find the largest element in the array.\n    Explanation: In the eversion operation, the largest element is used as the pivot to ensure that the array is partitioned efficiently.\n\n# [code logic]\n    To implement the eversion operation, we will follow these steps:\n    1. Identify the pivot element (the last element of the array).\n    2. Partition the array into two parts based on the pivot element.\n    3. Concatenate the two parts to form the new array.\n    4. Repeat the process until the array no longer changes.\n\n# [edge case] \n    Edge case 1: [1, 1, 1, 1] = 0\n    Explanation: The array already consists of identical elements, so no eversion is needed, and the array does not change.\n    Edge case 2: [2, 1, 3, 3, 2] = 1\n    Explanation: The first eversion will result in [1, 2, 3, 3, 2], and the array stops changing after one eversion.\n    Edge case 3: [5, 4, 3, 2, 1] = 1\n    Explanation: The first eversion will result in [1, 4, 3, 2, 5], and the array stops changing after one eversion.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic will work correctly for arrays with identical elements or arrays that stabilize after a single eversion.\n", "requirement analysis:\nThe requirements involve implementing the eversion operation on an array, which involves partitioning the array based on a chosen element and then concatenating the partitions. The challenge lies in efficiently handling large arrays and ensuring the application is user-friendly and responsive.\nrequirement pool:\n- Implement the eversion operation on an array\n- Ensure the application can handle large arrays efficiently\n- Provide a user-friendly interface for easy navigation\n- Optimize performance and scalability\nTo implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a chosen element, which can be efficiently handled using list comprehensions and slicing. We will ensure that the application is optimized for handling large arrays by leveraging Python's performance characteristics and using appropriate data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'array partitioning': The process of dividing an array into two parts based on a chosen element, where the left part contains elements not greater than the chosen element and the right part contains elements strictly greater than the chosen element.\n    Explanation: This concept involves splitting the array into two subarrays based on a pivot element, ensuring that elements in the left subarray are all less than or equal to the pivot, and elements in the right subarray are all greater than the pivot.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the eversion operation efficiently, we will follow these steps:\n    1. Read the input for each test case, including the number of elements and the elements themselves.\n    2. For each test case, perform the eversion operation iteratively until the array stops changing.\n    3. Track the number of iterations (eversions) until the array becomes stable.\n    4. Output the number of eversions for each test case.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Expected output: 1\n    Explanation: The array is already sorted in ascending order, so it does not change after the first eversion.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 1\n    Explanation: The array is sorted in descending order, so it becomes stable after the first eversion.\n\n    Edge case 3: [3, 1, 2, 4, 5]\n    Expected output: 2\n    Explanation: After the first eversion, the array becomes [1, 2, 3, 4, 5], and it becomes stable after the second eversion.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic will correctly handle arrays that are already sorted or sorted in reverse order. For other cases, the array will stabilize after a finite number of eversions.\n", "requirement analysis:\nThe requirements involve understanding the eversion operation on an array, which involves partitioning the array based on a chosen element and rearranging the elements accordingly. The output should reflect the number of iterations after which the array stops changing, indicating a stable state. The system should handle large inputs efficiently, ensuring scalability and performance.\nrequirement pool:\n- Implement the eversion operation on the array\n- Ensure the system can handle large inputs efficiently\n- Provide a user-friendly interface for easy interaction\n- Optimize performance for large datasets\n- Ensure the system is scalable and can handle future growth\nTo implement the eversion operation on an array efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a chosen element, which can be efficiently handled using list comprehensions and slicing. We will iterate through the array, applying the eversion operation until the array stops changing.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'array partitioning': The core concept involves splitting an array into two parts based on a chosen element, where one part contains elements not greater than the chosen element and the other part contains elements strictly greater than the chosen element.\n    Explanation: This operation involves dividing the array into two subarrays based on a pivot element, ensuring that elements in the left subarray are less than or equal to the pivot and elements in the right subarray are greater than the pivot. This process is repeated until the array no longer changes.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the eversion operation efficiently, we can follow these steps:\n    1. Read the input array.\n    2. Apply the eversion operation iteratively until the array stops changing.\n    3. Count the number of iterations required for the array to stabilize.\n    4. Output the count of iterations.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5]\n    Expected output: 1\n    Explanation: The array is already sorted in ascending order, so it does not change after the first eversion operation.\n\n    Edge case 2: [5, 4, 3, 2, 1]\n    Expected output: 5\n    Explanation: The array is sorted in descending order. Each eversion operation will reverse the array until it becomes stable.\n\n    Edge case 3: [3, 1, 2, 4, 5]\n    Expected output: 2\n    Explanation: After the first eversion operation, the array becomes [1, 2, 3, 4, 5], which does not change further.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic will work for these cases as well.\n", "requirement analysis:\nThe requirement involves understanding the eversion operation on an array and determining the number of iterations after which the array stops changing. This requires a balance between processing speed and user experience. The array can be large, so efficiency is crucial.\nrequirement pool:\n- Implement the eversion operation efficiently\n- Ensure the application can handle large arrays\n- Provide detailed output to the user\n- Optimize the user interface for ease of use\nTo implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element, which can be efficiently handled using list comprehensions and slicing. The main challenge is to determine the number of iterations after which the array stops changing, which requires careful handling of the partitioning process.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'array partitioning': involves dividing the array into two parts based on a pivot element, where one part contains elements not greater than the pivot and the other part contains elements strictly greater than the pivot.\n    Explanation: The eversion operation is a process of splitting the array into two parts based on a chosen element (pivot), ensuring that all elements in the left part are less than or equal to the pivot and all elements in the right part are greater than the pivot. This operation is repeated until the array no longer changes.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the pivot element must be greater than the elements in the left part and less than the elements in the right part.\n    Explanation: The phrase 'more than' is used to specify that the pivot element must be strictly greater than the elements in the right part of the array.\n\n# [degree adverb] \n    'strictly greater': means that the pivot element must be greater than all elements in the right part of the array.\n    Explanation: The degree adverb 'strictly greater' is used to emphasize that the pivot element must be greater than all elements in the right part of the array, ensuring a strict separation between the two parts.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the eversion operation efficiently, we will use Python's built-in data structures and algorithms. The eversion operation involves partitioning the array based on a pivot element, which can be efficiently handled using list comprehensions and slicing. The main challenge is to determine the number of iterations after which the array stops changing, which requires careful handling of the partitioning process.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4, 5] = 1\n    Explanation: The array is already sorted in ascending order, so after the first eversion operation, the array will be partitioned into [1, 2, 3] and [4, 5], and no further changes will occur.\n    Edge case 2: [5, 4, 3, 2, 1] = 1\n    Explanation: The array is sorted in descending order, so after the first eversion operation, the array will be partitioned into [5, 4, 3] and [2, 1], and no further changes will occur.\n    Edge case 3: [3, 1, 2, 4, 5] = 2\n    Explanation: After the first eversion operation, the array will be partitioned into [3, 1, 2] and [4, 5]. After the second eversion operation, the array will be partitioned into [1, 2] and [3, 4, 5], and no further changes will occur.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The partitioning logic and the stopping condition are straightforward and do not require additional code to handle specific edge cases.\n", "requirement analysis:\nThe problem requires an algorithm that can partition an array based on a pivot element and repeat this process until the array stops changing. The solution should be efficient enough to handle the upper limits of the input constraints. The output should be accurate and clear for each test case.\nrequirement pool:\n- Implement the eversion operation to partition the array and repeat until stable.\n- Ensure the solution is scalable to handle large inputs.\n- Optimize the algorithm for time and space complexity.\n- Provide clear and concise output for each test case.\n- Support multiple test cases efficiently.\nTo solve this problem, we will implement a function that repeatedly partitions the array based on the last element until the array reaches a stable state. We will use Python's built-in data structures and algorithms to ensure efficiency and scalability.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves selecting the last element of the array, partitioning the array into two parts (elements less than or equal to the last element and elements greater than the last element), and then concatenating these two parts. This process is repeated until the array no longer changes.\n    Explanation: The eversion operation is a recursive process where each step involves partitioning the array based on the last element and then combining the partitions. The goal is to determine the number of steps required for the array to reach a stable state where further eversions do not change the array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we need to follow these steps:\n    1. Read the input for each test case, which includes the length of the array and the array elements.\n    2. Perform the eversion operation repeatedly until the array stops changing.\n    3. Count the number of eversions performed to reach the stable state.\n    4. Output the count for each test case.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 2, 3]\n    Explanation: The array is already in a stable state with no changes possible, so the number of eversions is 0.\n    Edge case 2:\n    Input: [3, 2, 1]\n    Explanation: After the first eversion, the array becomes [2, 1, 3], which is still not stable. After the second eversion, the array becomes [1, 2, 3], which is stable. Therefore, the number of eversions is 2.\n    Edge case 3:\n    Input: [4, 3, 2, 1]\n    Explanation: After the first eversion, the array becomes [2, 1, 3, 4], which is not stable. After the second eversion, the array becomes [1, 2, 3, 4], which is stable. Therefore, the number of eversions is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the logic provided in the plan is sufficient to determine the number of eversions for any given array. The provided edge cases are illustrative of the stable state and the process of reaching it.\n", "requirement analysis:\nThe problem requires determining the number of eversions needed for an array to reach a stable state. The stable state is reached when no more eversions can be performed. The eversion operation involves partitioning the array into two parts based on a pivot element and concatenating them. The solution must be efficient and scalable to handle the upper limits of the input constraints.\nrequirement pool:\n- Implement the eversion operation and determine the stable state.\n- Ensure the solution is optimized for performance and scalability.\n- Handle edge cases and ensure robustness in handling various input scenarios.\n- Provide clear documentation and easy-to-understand code.\n- Test the solution with various inputs to verify correctness and performance.\nTo solve the problem of determining the minimum number of eversions required for an array to reach a stable state, we will use a simple and efficient approach. The eversion operation involves partitioning the array into two parts based on a pivot element and concatenating them. We will implement a function that repeatedly performs this operation until the array stops changing. To ensure scalability, we will use Python's built-in data structures and avoid unnecessary computations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves selecting the last element as a pivot, partitioning the array into two parts (elements \u2264 pivot and elements > pivot), and then concatenating these parts. This process is repeated until the array reaches a stable state where no further changes occur.\n    Explanation: The eversion operation is a recursive process where each step involves partitioning the array and then concatenating the parts. The goal is to reach a state where further eversions do not change the array, indicating a stable state.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. For each test case, read the array length and elements.\n    2. Perform the eversion operation repeatedly until the array stops changing.\n    3. Count the number of eversions required to reach the stable state.\n    4. Output the count for each test case.\n\n# [edge case] \n    Edge Case 1:\n    Input: [1]\n    Explanation: The array already has a single element, so no eversions are needed. The array is stable after 0 eversions.\n    Expected Output: 0\n\n    Edge Case 2:\n    Input: [2, 1]\n    Explanation: The array after the first eversion becomes [1, 2], which is stable. The array is stable after 1 eversion.\n    Expected Output: 1\n\n    Edge Case 3:\n    Input: [3, 1, 2]\n    Explanation: The array after the first eversion becomes [1, 2, 3], which is stable. The array is stable after 1 eversion.\n    Expected Output: 1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the logic provided in the plan is sufficient to handle arrays of size 1 and 2. For larger arrays, the plan ensures that the eversion operation is applied correctly until the array reaches a stable state.\n", "requirement analysis:\nThe problem requires an algorithm that can handle the eversion operation on an array and determine the stable state after a minimum number of operations. The input size can be large, so the solution must be optimized for performance. The output should be accurate and reliable for each test case.\nrequirement pool:\n- Implement the eversion operation and determine the stable state of the array.\n- Ensure the solution is scalable and can handle large inputs efficiently.\n- Optimize the algorithm for minimum number of eversions required.\n- Provide clear and accurate output for each test case.\n- Ensure the solution is easy to understand and implement.\nTo solve this problem, we will use a simple and efficient approach that leverages Python's built-in data structures and operations. The key steps involve repeatedly partitioning the array based on the last element until the array no longer changes. We will use a loop to perform these operations and count the number of iterations until the array stabilizes.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'eversion operation': This involves selecting the last element of the array, partitioning the array into two parts (elements less than or equal to the last element and elements greater than the last element), and then concatenating these two parts. This process is repeated until the array no longer changes.\n    Explanation: The eversion operation is a recursive process where the array is partitioned and concatenated based on the last element until a stable state is reached.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the input for each test case.\n    2. Perform the eversion operation until the array stabilizes.\n    3. Count the number of iterations (eversions) required to reach the stable state.\n    4. Output the count for each test case.\n\n# [edge case] \n    Edge Case 1:\n    Input: [1]\n    Explanation: The array already has a single element, so no eversion is needed. The array does not change, and the number of eversions is 0.\n    Edge Case 2:\n    Input: [2, 1]\n    Explanation: The array is partitioned into [1] (left) and [2] (right), and then concatenated to form [1, 2]. This is the stable state, and the number of eversions is 1.\n    Edge Case 3:\n    Input: [3, 1, 2, 3, 3]\n    Explanation: The array goes through several eversions:\n    - Eversion 1: [1, 2, 3] (left) and [3, 3] (right) -> [1, 2, 3, 3, 3]\n    - Eversion 2: [1, 2] (left) and [3, 3, 3] (right) -> [1, 2, 3, 3, 3]\n    The array stabilizes after 2 eversions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic will correctly handle arrays of any size without the need for additional complexity.\n", "requirement analysis:\nThe primary requirement is to determine the number of eversions required for an array to reach a stable state. This involves repeatedly partitioning the array based on a pivot element and checking if the array changes after each partition. The solution should be efficient and handle large inputs within reasonable time constraints.\nrequirement pool:\n- Implement the eversion operation and determine the stable state of the array.\n- Ensure the solution is scalable and can handle up to 2 * 10^5 elements.\n- Optimize the algorithm to minimize computational overhead.\n- Provide clear and concise instructions for user interaction.\n- Ensure the application is user-friendly and visually appealing.\nTo implement the solution, we will use Python due to its simplicity and efficiency. The main challenge is to repeatedly partition the array based on a pivot element and check if the array changes after each partition. We will use a stable partition algorithm to ensure the partition is stable. The solution will be optimized to handle up to 2 * 10^5 elements efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'array partitioning': The process of dividing an array into two parts based on a pivot element, where the left part contains elements not greater than the pivot and the right part contains elements strictly greater than the pivot. This is crucial for understanding the eversion operation.\n    Explanation: In the eversion operation, the array is partitioned based on a pivot element (x), and the partitioning is stable, meaning the relative order of elements within each part remains unchanged.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the pivot element (x) must be strictly greater than the elements in the left part and less than or equal to the elements in the right part.\n    Explanation: For example, in the array [2, 4, 1, 5, 3], the pivot x = 3 will partition the array into [2, 1, 3] (left part) and [4, 5] (right part).\n\n# [degree adverb] \n    'largest': Refers to the pivot element (x) that results in the most stable partitioning of the array, meaning the array stops changing after the partitioning.\n    Explanation: The largest pivot will lead to the most significant change in the array, and finding this pivot helps determine the number of eversions needed for the array to stop changing.\n\n# [code logic]\n    To implement the solution, we will follow these steps:\n    1. Read the input array.\n    2. Continuously partition the array based on the largest element until the array stops changing.\n    3. Count the number of partitions (eversions) performed.\n    4. Output the count as the result.\n\n# [edge case] \n    Edge case 1: [1, 1, 1, 1] = 0\n    Explanation: The array already consists of identical elements, so no partitioning is needed, and the array does not change. The number of eversions is 0.\n\n    Edge case 2: [5, 4, 3, 2, 1] = 4\n    Explanation: The array is in descending order, so each partitioning step will result in a stable array with one element in the left part and the rest in the right part. The number of eversions required is 4.\n\n    Edge case 3: [2, 1, 3, 3, 2] = 2\n    Explanation: The array has multiple elements, and the partitioning will proceed as usual, with the array stabilizing after a certain number of eversions. The exact number of eversions will depend on the specific pivot chosen.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic can handle arrays with identical elements or arrays in descending order without modification. The partitioning logic will naturally stabilize the array in these cases.\n"], "scores": [], "pass_results": [false, true, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 32, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "mutate_method": "rephrase_one", "parent_index": 33}
