{"task_id": "HumanEval/87", "prompt": "def get_row(lst, x):\t\n'''You receive a two-dimensional dataset formatted as nested lists, which resembles a matrix, but unlike matrices, the number of columns in each row can vary. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", "entry_point": "get_row", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "test": ["def check(get_row):\n\tassert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "def check(get_row):\n\tassert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "def check(get_row):\n\tassert get_row([], 5) == []", "def check(get_row):\n\tassert get_row([[2]], 5) == []", "def check(get_row):\n\tassert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "def check(get_row):\n\tassert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[2]], 3) == []", "def check(get_row):\n\tassert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "def check(get_row):\n\tassert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "def check(get_row):\n\tassert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "def check(get_row):\n\tassert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "def check(get_row):\n\tassert get_row([], 6) == []", "def check(get_row):\n\tassert get_row([], 1) == []", "def check(get_row):\n\tassert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "def check(get_row):\n\tassert get_row([[2]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "def check(get_row):\n\tassert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "def check(get_row):\n\tassert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "def check(get_row):\n\tassert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "def check(get_row):\n\tassert get_row([[5]], 6) == []", "def check(get_row):\n\tassert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "def check(get_row):\n\tassert get_row([[4]], 4) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[4]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 3) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "def check(get_row):\n\tassert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "def check(get_row):\n\tassert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "def check(get_row):\n\tassert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "def check(get_row):\n\tassert get_row([], 2) == []", "def check(get_row):\n\tassert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "def check(get_row):\n\tassert get_row([[1]], 3) == []", "def check(get_row):\n\tassert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "def check(get_row):\n\tassert get_row([[2]], 7) == []", "def check(get_row):\n\tassert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "def check(get_row):\n\tassert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "def check(get_row):\n\tassert get_row([[1]], 2) == []", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "def check(get_row):\n\tassert get_row([], 4) == []", "def check(get_row):\n\tassert get_row([[1]], 6) == []", "def check(get_row):\n\tassert get_row([[6]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "def check(get_row):\n\tassert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "def check(get_row):\n\tassert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "def check(get_row):\n\tassert get_row([[5]], 7) == []", "def check(get_row):\n\tassert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "def check(get_row):\n\tassert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "def check(get_row):\n\tassert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "def check(get_row):\n\tassert get_row([], 3) == []", "def check(get_row):\n\tassert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "def check(get_row):\n\tassert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "def check(get_row):\n\tassert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "def check(get_row):\n\tassert get_row([[1]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "def check(get_row):\n\tassert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[6]], 5) == []", "def check(get_row):\n\tassert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "def check(get_row):\n\tassert get_row([[6]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 6) == []", "def check(get_row):\n\tassert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "test_case_list": ["assert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "assert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "assert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "assert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "assert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "assert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "assert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "assert get_row([], 5) == []", "assert get_row([[2]], 5) == []", "assert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "assert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "assert get_row([[2]], 3) == []", "assert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "assert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "assert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "assert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "assert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "assert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "assert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "assert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "assert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "assert get_row([], 6) == []", "assert get_row([], 1) == []", "assert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "assert get_row([[2]], 4) == []", "assert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "assert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "assert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "assert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "assert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "assert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "assert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "assert get_row([[5]], 6) == []", "assert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "assert get_row([[4]], 4) == [(0, 0)]", "assert get_row([[4]], 3) == []", "assert get_row([[3]], 3) == [(0, 0)]", "assert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "assert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "assert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "assert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "assert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "assert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "assert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "assert get_row([], 2) == []", "assert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "assert get_row([[1]], 3) == []", "assert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "assert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "assert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "assert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "assert get_row([[2]], 7) == []", "assert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "assert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "assert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "assert get_row([[1]], 2) == []", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "assert get_row([], 4) == []", "assert get_row([[1]], 6) == []", "assert get_row([[6]], 4) == []", "assert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "assert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "assert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "assert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "assert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "assert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "assert get_row([[5]], 7) == []", "assert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "assert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "assert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "assert get_row([], 3) == []", "assert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "assert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "assert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "assert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "assert get_row([[1]], 4) == []", "assert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "assert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "assert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "assert get_row([[6]], 5) == []", "assert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "assert get_row([[6]], 3) == []", "assert get_row([[3]], 6) == []", "assert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "assert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "nl": "\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    ", "func": "def get_row(lst, x):", "examples": "Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    ", "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    '''\n    lst: List[List[int]]\n    x: int\n    Returns: List[Tuple[int, int]]\n    '''\n    if not lst:\n        return []\n    \n    coordinates = []\n    \n    for row_index, row in enumerate(lst):\n        for column_index, element in enumerate(row):\n            if element == x:\n                coordinates.append((row_index, column_index))\n    \n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "from typing import List\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    coordinates = []\n    \n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "from typing import List\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    result = []\n    \n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    \n    result.sort(key=lambda item: (item[0], -item[1]))\n    \n    return result\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    '''\n    lst: List[List[int]]\n    x: int\n    Returns: List[Tuple[int, int]]\n    '''\n    coordinates = []\n    \n    for row_index, row in enumerate(lst):\n        for column_index, element in enumerate(row):\n            if element == x:\n                coordinates.append((row_index, column_index))\n    \n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "from typing import List\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    '''\n    Returns a list of tuples representing the coordinates of x in the dataset.\n    The coordinates are sorted by rows in ascending order and then by columns in descending order.\n    '''\n    coordinates = []\n    \n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "from typing import List\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    '''\n    Finds all occurrences of a given integer `x` in a two-dimensional dataset represented as a list of lists.\n    Returns a list of tuples, each tuple is a coordinate (row, column), starting with 0.\n    The coordinates are sorted by rows in ascending order and columns in descending order.\n    '''\n    coordinates = []\n    \n    for row_index, row in enumerate(lst):\n        for column_index, element in enumerate(row):\n            if element == x:\n                coordinates.append((row_index, column_index))\n    \n    # Sort by row index in ascending order, then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "from typing import List\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Finds all occurrences of a given integer `x` in a two-dimensional dataset represented as a list of lists.\n    \n    Args:\n        lst (List[List[int]]): The two-dimensional dataset represented as a list of lists.\n        x (int): The integer to search for in the dataset.\n    \n    Returns:\n        List[Tuple[int, int]]: A list of tuples containing the coordinates of the occurrences of `x`.\n    \"\"\"\n    coordinates = []\n    \n    # Iterate through each row and each element within the row\n    for row_index, row in enumerate(lst):\n        for element_index, element in enumerate(row):\n            if element == x:\n                coordinates.append((row_index, element_index))\n    \n    # Sort the list by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    \n    # Sort the list by columns in descending order within the same row\n    coordinates.sort(key=lambda coord: coord[1], reverse=True)\n    \n    return coordinates\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    '''\n    lst: List[List[int]]\n    x: int\n    Returns: List[Tuple[int, int]]\n    '''\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    \n    # Sort the result by rows (ascending) and columns (descending)\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    '''\n    lst: List[List[int]]\n    x: int\n    Returns: List[Tuple[int, int]]\n    '''\n    coordinates = []\n    \n    for row_index, row in enumerate(lst):\n        for column_index, element in enumerate(row):\n            if element == x:\n                coordinates.append((row_index, column_index))\n    \n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list, x: int) -> list:\n    '''\n    lst: A two-dimensional list where each sublist represents a row and contains integers.\n    x: The integer to search for in the nested list.\n    Returns:\n    A list of tuples, where each tuple represents the coordinates (row, column) of the integer x in the list.\n    The coordinates are sorted by rows in ascending order and then by columns in descending order.\n    '''\n    coordinates = []\n    \n    # Iterate through the nested list to find the specified integer x\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort the coordinates first by rows in ascending order and then by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n"], "plans": ["requirement analysis:\nThe requirement is to find all occurrences of a specific integer x in a two-dimensional dataset represented as a list of lists. The function should return a list of tuples, where each tuple represents the coordinates (row, column) of the integer x in the dataset. The coordinates should be sorted first by rows in ascending order and then by columns in descending order.\nrequirement pool:\n- Implement a function that can handle any nested list structure.\n- Ensure the function can handle large datasets efficiently.\n- Provide a user-friendly interface for specifying the integer to search for.\n- Include options for sorting the results by rows and columns.\n- Optimize the function for performance and memory usage.\nTo implement the function `get_row` efficiently, we will leverage Python's built-in capabilities and utilize the `enumerate` function to keep track of the row and column indices. The function will iterate through each row and each element within the row, checking if the element matches the target integer. If a match is found, the coordinates will be stored in a list of tuples. The final list will be sorted based on the specified criteria: first by rows in ascending order, and then by columns in descending order within each row.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested lists': means a list within a list, used to represent a matrix with varying column sizes.\n    'enumerate': a function that provides both the index and the value for each item in an iterable.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integers greater than a certain value.\n    'at least as many times': means that we need to find the integer whose appears times is greater than or equal to its value.\n\n# [degree adverb] \n    'largest': means that we need the biggest integer that appears greater or equal to its value.\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    get_row([[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]], 1) = [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    Explanation: The function finds all instances of the integer 1 in the nested list and returns their coordinates. The coordinates are sorted first by rows in ascending order and then by columns in descending order within each row.\n    get_row([], 1) = []\n    Explanation: The function returns an empty list because the input list is empty.\n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The function finds the integer 3 at coordinate (2, 2) in the nested list and returns it.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could directly return an empty list if the input list is empty.\n", "requirement analysis:\nThe requirement is to find all occurrences of a specific integer x in a two-dimensional dataset represented as a list of lists. The function should return a list of tuples, where each tuple represents the coordinates (row, column) of the integer x in the dataset. The coordinates should be sorted first by rows in ascending order and then by columns in descending order.\nrequirement pool:\n- Implement a function to find all occurrences of a specific integer x in a two-dimensional dataset.\n- Ensure the function returns a list of tuples representing the coordinates of the integer x.\n- Sort the coordinates by rows in ascending order and by columns in descending order.\n- Handle large datasets efficiently without performance issues.\nTo implement the function `get_row` efficiently, we will utilize Python's built-in data structures and libraries to ensure high performance and reliability. The function will iterate through the nested list, checking for the presence of the target integer x. Upon finding x, it will store the coordinates in a list of tuples. To meet the sorting requirements, we will sort the coordinates first by rows in ascending order and then by columns in descending order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested lists': represents a matrix with varying columns in each row.\n    'coordinates': (row, column) to locate elements within the nested list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    get_row([[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]], 1) = [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    Explanation:\n    - The integer 1 is found at (0, 0), (1, 4), (1, 0), (2, 5), and (2, 0).\n    - The coordinates are sorted by rows in ascending order and then by columns in descending order.\n    get_row([], 1) = []\n    Explanation:\n    - The list is empty, so no coordinates are returned.\n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation:\n    - The integer 3 is found only at (2, 2) in the third row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can handle the case of an empty list by returning an empty list.\n\n# [code logic]\n    Here's a detailed logic to implement the function `get_row`:\n\n    1. Initialize an empty list `coordinates` to store the results.\n    2. Iterate through the nested list `lst` using a nested loop to get both the row and column indices.\n    3. For each occurrence of `x`, append the coordinate (row, column) to the `coordinates` list.\n    4. Sort the `coordinates` list first by rows in ascending order and then by columns in descending order.\n    5. Return the sorted `coordinates` list.\n", "requirement analysis:\nThe requirement involves finding all occurrences of a specific integer in a two-dimensional dataset. The dataset is represented as a list of lists, where each sublist may have a different number of elements. The function should return a list of tuples, where each tuple represents the coordinates of the integer in the dataset. The coordinates should be sorted first by rows in ascending order and then by columns in descending order.\nrequirement pool:\n- Implement a function to find all occurrences of a specific integer in a two-dimensional dataset.\n- Ensure the function can handle datasets with varying numbers of columns.\n- Return a list of tuples representing the coordinates of the integer in the dataset.\n- Sort the coordinates by rows in ascending order.\n- Sort the coordinates within the same row by columns in descending order.\nTo implement the function `get_row` as described, we will use Python's built-in capabilities along with the `itertools` module for efficient iteration. The function will iterate through each row of the dataset, and for each row, it will find the indices of the specified integer. These indices will be stored along with their row number, forming tuples. The tuples will then be sorted first by row index in ascending order and then by column index in descending order. This approach ensures that the function is both efficient and easy to understand.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested lists': means lists within lists, used to represent a matrix with varying column sizes.\n    Explanation: In this requirement, the data structure is a list of lists, where each sublist represents a row in a matrix, and the elements of the sublist represent the columns.\n\n# [phrase showing quantity relationship]\n    'more than': means that the integer we are looking for must appear more than once in the dataset.\n    Explanation: The phrase \"more than\" indicates that we need to find an integer that appears at least twice in the nested list.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that appears more than once.\n    Explanation: The degree adverb \"largest\" suggests that we should return the largest integer that meets the condition of appearing more than once in the nested list.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    To implement the function `get_row`, we need to:\n    1. Iterate through each row of the nested list.\n    2. For each row, find the indices where the specified integer appears.\n    3. Store the row index and the indices found in a list of tuples.\n    4. Sort the list of tuples first by row index in ascending order and then by column index in descending order.\n    5. Return the sorted list of tuples.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: If the list is empty, there are no rows to search, so the expected output is an empty list.\n    get_row([[1,2,3],[4,5,6]], 6) = [(1, 2)]\n    Explanation: The integer 6 appears only once, in the second row and the last column. Since there are no more occurrences, the function returns the coordinate of the single occurrence.\n    get_row([[1,2,3],[1,2,3]], 2) = [(0, 1), (0, 2), (1, 1), (1, 2)]\n    Explanation: The integer 2 appears more than once, in both rows and columns. The function returns all coordinates where 2 appears, sorted as specified.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic can handle cases where the list is empty or where the integer does not appear more than once. The sorting is already designed to handle the cases where there are multiple occurrences within the same row or across different rows.\n", "requirement analysis:\nThe requirement is to find specific integers within a two-dimensional dataset and return their coordinates. The coordinates need to be sorted first by rows in ascending order and then by columns in descending order. This requirement ensures that the user can easily locate specific values within the dataset, making it particularly useful for data analysis and manipulation tasks.\nrequirement pool:\n- Implement a function to find and return coordinates of a specific integer in a nested list.\n- Ensure the coordinates are sorted by rows in ascending order and columns in descending order.\n- Develop the function to handle various data structures commonly used in two-dimensional datasets.\n- Implement user-friendly error handling and feedback mechanisms.\n- Optimize the function for performance and scalability to handle large datasets efficiently.\nTo implement the function `get_row` efficiently and user-friendly, we will utilize Python's built-in data structures and libraries. The function will iterate through the nested list to find the specified integer, and then it will store the coordinates in a list of tuples. These coordinates will be sorted first by rows in ascending order and then by columns in descending order. This approach ensures that the user can easily locate specific values within the dataset.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested lists': These are lists within lists, which can represent a matrix with varying column sizes.\n    Explanation: In the requirement, the function `get_row` takes a two-dimensional dataset (nested lists) and an integer `x`, and it needs to find all occurrences of `x` in the dataset, returning their coordinates.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests iterating through the nested list to find the specified integer, storing the coordinates, and then sorting them. Here's a detailed logic:\n    1. Initialize an empty list to store the coordinates.\n    2. Iterate through each row in the nested list.\n    3. Within each row, iterate through each element to find the specified integer.\n    4. If found, append the coordinate (row index, column index) to the list.\n    5. Sort the list of coordinates first by row index in ascending order, and then by column index in descending order.\n    6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([[1, 2], [3, 4, 5], [6, 7, 8, 9]], 4) = [(1, 1)]\n    Explanation: The integer 4 is found in the second row (index 1) at the second column (index 1), so the expected output is [(1, 1)].\n    get_row([[1, 2, 3], [4, 5], [6, 7, 8, 9, 10]], 5) = [(1, 1)]\n    Explanation: The integer 5 is found in the second row (index 1) at the first column (index 1), so the expected output is [(1, 1)].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle cases where the integer is found in multiple rows or columns.\n", "requirement analysis:\nThe requirement is to find all occurrences of a given integer x in a two-dimensional dataset represented as a list of lists. The function should return a list of tuples, where each tuple represents the coordinates of the integer x in the dataset. The coordinates should be sorted first by rows in ascending order and then by columns in descending order.\nrequirement pool:\n- The main code should correctly find all occurrences of the integer x in the dataset.\n- The function should return a list of tuples representing the coordinates of x.\n- The coordinates should be sorted by rows in ascending order.\n- The coordinates within the same row should be sorted by columns in descending order.\nTo implement the function `get_row` as described, we will use Python's built-in capabilities along with the `itertools` module for efficient iteration. The function will iterate through each row of the list, and for each row, it will find all occurrences of the target integer `x`. It will then store the coordinates (row and column) of these occurrences. Finally, the coordinates will be sorted as specified: first by rows in ascending order, and then by columns in descending order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested lists': a data structure that consists of lists within lists, used to represent a two-dimensional dataset where the number of columns in each row can vary.\n    Explanation: In this requirement, we are dealing with a list of lists, where each sublist represents a row in the dataset. The goal is to find all occurrences of a given integer `x` and return their coordinates.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (1) Iterate through each row in the list.\n    (2) For each row, iterate through its elements to find the target integer `x`.\n    (3) Store the coordinates (row, column) of each occurrence.\n    (4) Sort the coordinates first by rows in ascending order, and then by columns in descending order.\n    (5) Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5) = [(1, 1)]\n    Explanation: The target integer `x` is 5, which is found in the second row (index 1) and second column (index 1). The coordinates are sorted by rows in ascending order and then by columns in descending order, resulting in [(1, 1)].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to find and sort the coordinates correctly.\n", "requirement analysis:\nThe requirement involves finding all occurrences of a given integer x in a two-dimensional dataset represented as a list of lists. The function should return the coordinates of these occurrences, sorted first by rows in ascending order and then by columns in descending order. This requirement ensures that the function is both accurate and user-friendly, providing a clear and organized output.\nrequirement pool:\n- The main code should accurately find and return the coordinates of the integer x in the dataset.\n- The function should sort the coordinates by rows in ascending order and columns in descending order.\n- Ensure the function is efficient in handling large datasets.\n- Include error handling for cases where x is not found in the dataset.\nTo implement the function `get_row` that finds all occurrences of a given integer `x` in a two-dimensional dataset represented as a list of lists, we will use Python's built-in capabilities and the `itertools` library for efficient iteration. The function will iterate through each row and each element within the row to find the target integer. It will then store the coordinates of these occurrences, sort them by rows in ascending order, and columns in descending order. This approach ensures both accuracy and efficiency.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'two-dimensional dataset': means a dataset that has rows and columns, like a matrix but with varying column sizes.\n    'nested lists': lists within lists, used to represent the rows and columns of the dataset.\n    'coordinates': a way to locate a specific element in a dataset, given by (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    get_row([[1, 2], [3, 4, 5], [6, 7, 8, 9]], 4) = [(1, 1)]\n    explanation: The integer 4 is found in the second row (index 1) at the second column (index 1), so the coordinate is (1, 1).\n    get_row([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 10) = []\n    explanation: The integer 10 is not found in the dataset, so the expected output is an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The function can return an empty list if the integer is not found in the dataset.\n", "requirement analysis:\nThe requirement is to find all occurrences of a given integer x in a two-dimensional dataset represented as a list of lists. The function should return a list of tuples, where each tuple represents the coordinates of the integer x in the dataset. The coordinates should be sorted first by rows in ascending order and then by columns in descending order.\nrequirement pool:\n- The main code should correctly find all occurrences of the integer x in the dataset.\n- The function should return a list of tuples representing the coordinates of x.\n- The coordinates should be sorted by rows in ascending order.\n- The coordinates within the same row should be sorted by columns in descending order.\nTo implement the function `get_row` that finds all occurrences of a given integer `x` in a two-dimensional dataset represented as a list of lists, we will use Python's built-in functionalities and the `itertools` library for efficient iteration. The function will iterate through each row and each element within the row to find the target integer. Once found, it will store the coordinates in a list of tuples, ensuring the rows are sorted in ascending order and the columns within the same row are sorted in descending order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'two-dimensional dataset': means a dataset represented as a list of lists where each inner list can have a different length.\n    'nested lists': refers to lists within lists, which is used to represent the matrix-like structure.\n    'coordinates': (row, column) where row is the index of the outer list and column is the index of the element within the inner list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    get_row([[1, 2, 3], [4, 5], [6, 7, 8, 9]], 5) = [(1, 1)]\n    explanation: The integer 5 is found in the second row (index 1) at the second column (index 1), so the coordinate is (1, 1).\n    get_row([[1, 2, 3], [4, 5], [6, 7, 8, 9]], 10) = []\n    explanation: The integer 10 is not found in the dataset, so the expected output is an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The function can return an empty list if the integer is not found in the dataset.\n", "requirement analysis:\nThe requirement is to find all occurrences of a given integer x in a two-dimensional dataset represented as a list of lists. The function should return a list of tuples, where each tuple represents the coordinates of the integer x in the dataset. The coordinates should be sorted first by rows in ascending order and then by columns in descending order.\nrequirement pool:\n- Implement a function to find and return the coordinates of a given integer in a nested list.\n- Ensure the function sorts the coordinates by rows in ascending order and columns in descending order.\n- Test the function with various datasets to ensure it works correctly.\n- Optimize the function for performance and efficiency.\n- Document the function and provide clear examples of usage.\nTo implement the function `get_row` efficiently, we will utilize Python's built-in capabilities and the `itertools` library to handle the nested lists. The function will iterate through the list, find all occurrences of the given integer, and then sort the coordinates as specified. This approach ensures simplicity and efficiency.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested lists': lists within lists, representing a two-dimensional dataset\n    'coordinates': a pair of indices (row, column) that uniquely identify a position in the nested list\n    'sorting': arranging elements in a specific order, here by rows and columns\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests iterating through the list to find all occurrences of the given integer, and then sorting the coordinates. This can be done efficiently using nested loops and list comprehensions.\n\n# [edge case] \n    get_row([[1, 2], [3, 4, 5], [6, 7, 8, 9]], 5) = [(1, 2)]\n    Explanation: The integer 5 is found in the second row at the second column. The coordinates are (1, 2) since indexing starts at 0.\n    get_row([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 10) = []\n    Explanation: The integer 10 is not found in any row of the list, so the expected output is an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic will return an empty list if the integer is not found.\n\n# [core concept]\n    'nested lists': lists within lists, representing a two-dimensional dataset\n    'coordinates': a pair of indices (row, column) that uniquely identify a position in the nested list\n    'sorting': arranging elements in a specific order, here by rows and columns\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests iterating through the list to find all occurrences of the given integer, and then sorting the coordinates. This can be done efficiently using nested loops and list comprehensions.\n\n# [edge case] \n    get_row([[1, 2], [3, 4, 5], [6, 7, 8, 9]], 5) = [(1, 2)]\n    Explanation: The integer 5 is found in the second row at the second column. The coordinates are (1, 2) since indexing starts at 0.\n    get_row([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 10) = []\n    Explanation: The integer 10 is not found in any row of the list, so the expected output is an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic will return an empty list if the integer is not found.\n", "requirement analysis:\nThe requirement is to create a function that can search for a specific integer within a two-dimensional dataset represented as nested lists. The function should return the coordinates of the integer in the dataset, sorted first by rows in ascending order and then by columns in descending order. This requirement ensures that the function is versatile and can handle datasets with varying numbers of columns.\nrequirement pool:\n- Implement a function to search for an integer x in a nested list lst.\n- Ensure the function returns a list of tuples, each representing the coordinates of the integer x.\n- Sort the coordinates by rows in ascending order.\n- Sort the coordinates within each row by columns in descending order.\n- Optimize the function for performance, ensuring it can handle large datasets efficiently.\nTo implement the function `get_row` efficiently, we will utilize Python's built-in data structures and libraries. The function will iterate through the nested list, identify the coordinates of the specified integer, and then sort these coordinates as per the requirements. We will use list comprehensions for clarity and efficiency.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested lists': A nested list is a list that contains other lists as its elements. This is different from a matrix, where all inner lists have the same length.\n    Explanation: In the requirement, we are dealing with a dataset formatted as a nested list, which means each row can have a different number of columns. The goal is to find all occurrences of a given integer `x` and return their coordinates.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the function `get_row`, we will follow these steps:\n    1. Initialize an empty list to store the coordinates.\n    2. Iterate through each row in the nested list.\n    3. Within each row, iterate through each element and check if it matches the target integer `x`.\n    4. If a match is found, append the coordinate (row index, column index) to the coordinates list.\n    5. Sort the coordinates list first by row index in ascending order, and then by column index in descending order.\n    6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([[1, 2, 3], [4, 5], [6, 7, 8, 9]], 5) = [(1, 1)]\n    Explanation: The integer 5 is found in the second row (index 1) at the second column (index 1). The coordinates are sorted by row index first (1) and then by column index (1).\n\n    get_row([[1, 2, 3], [4, 5], [6, 7, 8, 9]], 10) = []\n    Explanation: The integer 10 is not found in the nested list, so the function returns an empty list.\n\n    get_row([[1, 2, 3], [4, 5, 6], [7, 8, 9, 10]], 6) = [(1, 2)]\n    Explanation: The integer 6 is found in the second row (index 1) at the third column (index 2). The coordinates are sorted by row index first (1) and then by column index (2).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle cases where the target integer is not found or the nested list is empty.\n", "requirement analysis:\nThe requirement involves finding specific integers within a nested list structure and returning their coordinates. The coordinates need to be sorted first by rows in ascending order and then by columns in descending order. This requirement ensures that the function is versatile and can handle various data sizes and formats effectively.\nrequirement pool:\n- Implement a function to find and return coordinates of a specific integer in a nested list.\n- Ensure the function sorts the coordinates by rows in ascending order and columns in descending order.\n- Optimize the function to handle large datasets efficiently.\n- Include error handling to manage cases where the integer is not found in the list.\nTo implement the function `get_row` efficiently, we will use Python's built-in data structures and libraries. The function will iterate through the nested list to find the specified integer, and for each occurrence, it will store the coordinates in a list of tuples. The coordinates will be sorted first by rows in ascending order and then by columns in descending order. This approach ensures that the function is both simple and effective, making it suitable for handling various data sizes.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested lists': A nested list is a list that contains other lists as its elements. This concept is crucial for understanding how to handle the two-dimensional dataset represented by `lst`.\n    Explanation: In the requirement, `lst` is described as a two-dimensional dataset formatted as nested lists, which means it is a list of lists where each inner list can have a different length.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that we need to find occurrences of the integer `x` in the nested list.\n    Explanation: The phrase \"find integers `x` in the list\" implies that we need to search for the integer `x` across all rows and columns of the nested list.\n\n# [degree adverb] \n    'largest': Not applicable in this plan as it does not directly relate to the core concept or the steps outlined.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan outlines a clear sequence of steps:\n    1. Iterate through the nested list to find the specified integer `x`.\n    2. Store the coordinates of each occurrence in a list of tuples.\n    3. Sort the coordinates first by rows in ascending order and then by columns in descending order.\n\n# [edge case] \n    get_row([[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]], 1) = [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    Explanation: The edge case involves a nested list with three rows, and the integer `1` appears at multiple positions. The expected output sorts these positions by rows in ascending order and then by columns in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided steps in the plan are sufficient to handle the given examples and ensure the coordinates are sorted correctly.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.5172, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, false, true, true, true], "pass_test_cases_num": [87, 87, 87, 87, 87, 87, 45, 87, 87, 87], "completion": "from typing import List\n## main.py\n\ndef get_row(lst: list, x: int) -> list:\n    '''\n    lst: A two-dimensional list where each sublist represents a row and contains integers.\n    x: The integer to search for in the nested list.\n    Returns:\n    A list of tuples, where each tuple represents the coordinates (row, column) of the integer x in the list.\n    The coordinates are sorted by rows in ascending order and then by columns in descending order.\n    '''\n    coordinates = []\n    \n    # Iterate through the nested list to find the specified integer x\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort the coordinates first by rows in ascending order and then by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "passed": true, "pass": true, "pass_num": 9, "round": 478, "repair_prompt": ["def get_row(lst, x):\t\n'''You receive a two-dimensional dataset formatted as nested lists, which resembles a matrix, but unlike matrices, the number of columns in each row can vary. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", " def get_row(lst, x):\n    '''You receive a two-dimensional dataset formatted as nested lists, which resembles a matrix, but unlike matrices, the number of columns in each row can vary. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\n    Examples:\n        get_row", " def get_row(lst, x):\n    '''You receive a two-dimensional dataset formatted as nested lists, which resembles a matrix, but unlike matrices, the number of columns in each row can vary. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\n    Examples:\n        get_row"], "mutate_method": "rephrase_one", "parent_index": 367}
