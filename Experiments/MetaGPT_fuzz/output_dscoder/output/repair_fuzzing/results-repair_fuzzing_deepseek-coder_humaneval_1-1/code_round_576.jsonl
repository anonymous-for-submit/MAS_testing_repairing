{"task_id": "HumanEval/87", "prompt": "def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, but each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order, and sort coordinates of the row by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", "entry_point": "get_row", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "test": ["def check(get_row):\n\tassert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "def check(get_row):\n\tassert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "def check(get_row):\n\tassert get_row([], 5) == []", "def check(get_row):\n\tassert get_row([[2]], 5) == []", "def check(get_row):\n\tassert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "def check(get_row):\n\tassert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[2]], 3) == []", "def check(get_row):\n\tassert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "def check(get_row):\n\tassert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "def check(get_row):\n\tassert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "def check(get_row):\n\tassert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "def check(get_row):\n\tassert get_row([], 6) == []", "def check(get_row):\n\tassert get_row([], 1) == []", "def check(get_row):\n\tassert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "def check(get_row):\n\tassert get_row([[2]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "def check(get_row):\n\tassert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "def check(get_row):\n\tassert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "def check(get_row):\n\tassert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "def check(get_row):\n\tassert get_row([[5]], 6) == []", "def check(get_row):\n\tassert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "def check(get_row):\n\tassert get_row([[4]], 4) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[4]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 3) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "def check(get_row):\n\tassert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "def check(get_row):\n\tassert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "def check(get_row):\n\tassert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "def check(get_row):\n\tassert get_row([], 2) == []", "def check(get_row):\n\tassert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "def check(get_row):\n\tassert get_row([[1]], 3) == []", "def check(get_row):\n\tassert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "def check(get_row):\n\tassert get_row([[2]], 7) == []", "def check(get_row):\n\tassert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "def check(get_row):\n\tassert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "def check(get_row):\n\tassert get_row([[1]], 2) == []", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "def check(get_row):\n\tassert get_row([], 4) == []", "def check(get_row):\n\tassert get_row([[1]], 6) == []", "def check(get_row):\n\tassert get_row([[6]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "def check(get_row):\n\tassert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "def check(get_row):\n\tassert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "def check(get_row):\n\tassert get_row([[5]], 7) == []", "def check(get_row):\n\tassert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "def check(get_row):\n\tassert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "def check(get_row):\n\tassert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "def check(get_row):\n\tassert get_row([], 3) == []", "def check(get_row):\n\tassert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "def check(get_row):\n\tassert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "def check(get_row):\n\tassert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "def check(get_row):\n\tassert get_row([[1]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "def check(get_row):\n\tassert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[6]], 5) == []", "def check(get_row):\n\tassert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "def check(get_row):\n\tassert get_row([[6]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 6) == []", "def check(get_row):\n\tassert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "test_case_list": ["assert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "assert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "assert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "assert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "assert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "assert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "assert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "assert get_row([], 5) == []", "assert get_row([[2]], 5) == []", "assert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "assert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "assert get_row([[2]], 3) == []", "assert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "assert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "assert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "assert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "assert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "assert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "assert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "assert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "assert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "assert get_row([], 6) == []", "assert get_row([], 1) == []", "assert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "assert get_row([[2]], 4) == []", "assert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "assert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "assert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "assert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "assert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "assert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "assert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "assert get_row([[5]], 6) == []", "assert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "assert get_row([[4]], 4) == [(0, 0)]", "assert get_row([[4]], 3) == []", "assert get_row([[3]], 3) == [(0, 0)]", "assert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "assert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "assert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "assert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "assert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "assert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "assert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "assert get_row([], 2) == []", "assert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "assert get_row([[1]], 3) == []", "assert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "assert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "assert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "assert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "assert get_row([[2]], 7) == []", "assert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "assert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "assert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "assert get_row([[1]], 2) == []", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "assert get_row([], 4) == []", "assert get_row([[1]], 6) == []", "assert get_row([[6]], 4) == []", "assert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "assert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "assert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "assert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "assert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "assert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "assert get_row([[5]], 7) == []", "assert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "assert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "assert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "assert get_row([], 3) == []", "assert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "assert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "assert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "assert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "assert get_row([[1]], 4) == []", "assert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "assert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "assert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "assert get_row([[6]], 5) == []", "assert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "assert get_row([[6]], 3) == []", "assert get_row([[3]], 6) == []", "assert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "assert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "nl": "\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    ", "func": "def get_row(lst, x):", "examples": "Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    ", "completions": ["from typing import List\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    '''\n    Given a 2-dimensional list (similar to a matrix) where each row may have a different number of columns, find all occurrences of the integer x and return their coordinates as a list of tuples (row, column).\n    The coordinates should be sorted by rows in ascending order, and within the same row, by columns in descending order.\n    \n    Args:\n    lst (List[List[int]]): The 2-dimensional list to search.\n    x (int): The integer to find.\n    \n    Returns:\n    List[Tuple[int, int]]: A list of tuples, each containing the row and column index of the found integer.\n    '''\n    coordinates = []\n    \n    for row_index, row in enumerate(lst):\n        for column_index, element in enumerate(row):\n            if element == x:\n                coordinates.append((row_index, column_index))\n    \n    # Sort by row index in ascending order, then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "from typing import List\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    '''\n    Given a 2-dimensional list (which can have varying row lengths) and an integer x, find all occurrences of x and return their coordinates.\n    The coordinates should be sorted by row index in ascending order, and within each row, by column index in descending order.\n    Args:\n        lst (List[List[int]]): The 2-dimensional list containing integers.\n        x (int): The integer to find in the list.\n    Returns:\n        List[Tuple[int, int]]: A list of tuples, each containing the row and column index of the found integer x.\n    '''\n    coordinates = []\n    \n    for row_index, row in enumerate(lst):\n        for column_index, element in enumerate(row):\n            if element == x:\n                coordinates.append((row_index, column_index))\n    \n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    '''\n    lst: List[List[int]]\n    x: int\n    return: List[Tuple[int, int]]\n    '''\n    coordinates = []\n    \n    for row_index, row in enumerate(lst):\n        for col_index, element in enumerate(row):\n            if element == x:\n                coordinates.append((row_index, col_index))\n    \n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst, x):\n    '''\n    lst: List[List[int]]\n    x: int\n    Returns: List[Tuple[int, int]]\n    '''\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort the coordinates by rows in ascending order, and by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Given a 2-dimensional data structure (nested list), find the integer x and return a list of tuples\n    representing the coordinates of x. The coordinates are sorted by rows in ascending order and columns\n    in descending order.\n\n    Args:\n        lst (List[List[int]]): A 2-dimensional list where each row may have a different number of columns.\n        x (int): The integer to find in the nested list.\n\n    Returns:\n        List[Tuple[int, int]]: A list of tuples where each tuple is a coordinate (row, column) of the integer x.\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates\n", "from typing import List\nimport numpy as np\n\ndef get_row(lst, x):\n    '''\n    lst: List[List[int]]\n    x: int\n    Returns: List[Tuple[int, int]]\n    '''\n    # Convert the nested list to a numpy array for efficient operations\n    np_array = np.array(lst)\n    \n    # Find the indices where the value x is found\n    indices = np.where(np_array == x)\n    \n    # Create a list of tuples from the indices\n    coordinates = list(zip(indices[0], indices[1]))\n    \n    # Sort the coordinates by rows in ascending order and columns in descending order\n    sorted_coordinates = sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\n    \n    return sorted_coordinates\n", "from typing import List\nfrom typing import List, Tuple\n\ndef find_occurrences(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Finds all occurrences of a given integer `x` in a 2-dimensional data structure represented as a nested list.\n    \n    Args:\n        lst (List[List[int]]): A 2-dimensional list (matrix) of integers.\n        x (int): The integer to find in the matrix.\n    \n    Returns:\n        List[Tuple[int, int]]: A list of tuples, each containing the row and column indices of the occurrence of `x`.\n    \"\"\"\n    coordinates = []\n    \n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort the coordinates by rows in ascending order and columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "from typing import List\nfrom typing import List, Tuple\n\ndef find_occurrences(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given a 2-dimensional data structure, represented as a nested list, which can be thought of as a matrix where each row may have a different number of columns. Given the list `lst` and an integer `x`, your task is to find all occurrences of `x` in the list and return a list of tuples `[(x1, y1), (x2, y2) ...]` where each tuple represents a coordinate in the matrix - `(row, column)`. The coordinates should be sorted first by rows in ascending order and then by columns in descending order.\n    \n    Examples:\n    ", "from typing import List\nfrom typing import List, Tuple\n\ndef find_occurrences(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Finds all occurrences of a given integer `x` in a 2-dimensional data structure represented as a nested list.\n    \n    Args:\n        lst (List[List[int]]): A 2-dimensional list (matrix) of integers.\n        x (int): The integer to find in the matrix.\n    \n    Returns:\n        List[Tuple[int, int]]: A list of tuples, each containing the row and column indices of the occurrence of `x`.\n    \"\"\"\n    coordinates = []\n    \n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort the coordinates by rows in ascending order and columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "from typing import List\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    This function takes a nested list and an integer, then returns a list of tuples\n    representing the coordinates of the integer in the nested list. The coordinates\n    are sorted by rows in ascending order and then by columns in descending order.\n    \n    Args:\n        lst (List[List[int]]): The nested list to search through.\n        x (int): The integer to find in the nested list.\n        \n    Returns:\n        List[Tuple[int, int]]: A list of tuples representing the coordinates of x.\n    \"\"\"\n    coordinates = []\n    \n    # Iterate through the nested list to find the specified integer\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort the coordinates by rows in ascending order and then by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n"], "plans": ["requirement analysis:\nThe requirement is to find the coordinates of a specific integer in a nested list. The list may contain rows with different lengths, and the coordinates should be returned sorted by rows in ascending order and by columns in descending order. This requirement involves handling irregular data structures and ensuring efficient sorting of results.\nrequirement pool:\n- Implement a function to find the coordinates of a specific integer in a nested list.\n- Ensure the function can handle lists with varying row lengths.\n- Implement sorting of coordinates by rows in ascending order and by columns in descending order.\n- Optimize the function for performance, especially for large datasets.\n- Add documentation and examples to help users understand how to use the function.\nTo implement the function efficiently, we will use Python's built-in data structures and functions to handle the nested list and find the coordinates of the specified integer. We will ensure that the function can handle lists with varying row lengths by iterating through each row and each element within the row. The coordinates will be stored in a list of tuples, and we will sort this list first by rows in ascending order and then by columns in descending order. This approach leverages Python's flexibility and performance for list operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': a list containing other lists as its elements, representing a matrix-like structure where each sublist can have a different length.\n    Explanation: In the requirement, the function `get_row` is designed to search for a specific integer `x` within a nested list `lst`. The goal is to find all occurrences of `x` and return their coordinates, sorted by rows and then by columns.\n\n# [phrase showing quantity relationship]\n    'as many times': means the frequency of the integer `x` in the nested list.\n    Explanation: The phrase 'as many times' is used to indicate that we need to find all instances of `x` and return their positions.\n\n# [degree adverb] \n    'descending': means the order in which columns within the same row are sorted.\n    Explanation: The degree adverb 'descending' is used to specify that the columns within each row should be sorted from the highest to the lowest index.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Iterate through each row of the nested list.\n    - For each row, iterate through each element to find the target integer `x`.\n    - Store the coordinates (row index, column index) of each occurrence.\n    - Sort the list of coordinates first by row index in ascending order, and then by column index in descending order.\n\n# [edge case] \n    get_row([[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]], 1) = [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    Explanation:\n    - The integer 1 appears at (0, 0), (1, 4), (1, 0), (2, 5), and (2, 0).\n    - The coordinates are sorted by rows (0, 1, 2) and then by columns within each row (0, 0, 4, 5).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic already covers the scenario where the nested list is empty or contains empty sublists.\n\n# [core concept]\n    'nested list': a list containing other lists as its elements, representing a matrix-like structure where each sublist can have a different length.\n    Explanation: In the requirement, the function `get_row` is designed to search for a specific integer `x` within a nested list `lst`. The goal is to find all occurrences of `x` and return their coordinates, sorted by rows and then by columns.\n\n# [phrase showing quantity relationship]\n    'as many times': means the frequency of the integer `x` in the nested list.\n    Explanation: The phrase 'as many times' is used to indicate that we need to find all instances of `x` and return their positions.\n\n# [degree adverb] \n    'descending': means the order in which columns within the same row are sorted.\n    Explanation: The degree adverb 'descending' is used to specify that the columns within each row should be sorted from the highest to the lowest index.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Iterate through each row of the nested list.\n    - For each row, iterate through each element to find the target integer `x`.\n    - Store the coordinates (row index, column index) of each occurrence.\n    - Sort the list of coordinates first by row index in ascending order, and then by column index in descending order.\n\n# [edge case] \n    get_row([[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]], 1) = [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    Explanation:\n    - The integer 1 appears at (0, 0), (1, 4), (1, 0), (2, 5), and (2, 0).\n    - The coordinates are sorted by rows (0, 1, 2) and then by columns within each row (0, 0, 4, 5).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic already covers the scenario where the nested list is empty or contains empty sublists.\n", "requirement analysis:\nThe requirement is to find all occurrences of a specific integer x in a nested list (which can have varying row lengths) and return their coordinates. The coordinates should be sorted first by row index in ascending order, and within each row, by column index in descending order. This requirement ensures that the most significant occurrences are listed first, which is useful for visualizations or further data processing.\nrequirement pool:\n- Implement a function to find all occurrences of x in the nested list\n- Ensure the function can handle lists with varying row lengths\n- Sort the coordinates by row index in ascending order and by column index in descending order\n- Optimize the function for performance on large datasets\n- Include detailed documentation and examples in the function description\nTo implement the function `get_row` efficiently, we will use Python's built-in data structures and libraries. The function will iterate through the nested list, keeping track of the coordinates where the specified integer is found. We will use a list to store the coordinates and then sort them according to the specified criteria. This approach ensures simplicity and efficiency, making it suitable for handling large datasets.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': a list containing other lists as its elements.\n    'coordinate': a pair of indices (row, column) that locate an element in a 2D structure.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    get_row([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5) = [(1, 1)]\n    Explanation: The integer 5 is found in the second row, third column. The expected output is a list of tuples containing the coordinate (1, 1).\n    get_row([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 10) = []\n    Explanation: The integer 10 is not found in the list, so the expected output is an empty list.\n    get_row([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1) = [(0, 0), (1, 0), (2, 0)]\n    Explanation: The integer 1 is found in the first element of each row. The expected output is a list of tuples containing the coordinates (0, 0), (1, 0), and (2, 0).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic can handle cases where the list is empty or the integer is not found.\n\n# [code logic]\n    Here's a detailed logic to implement the function `get_row`:\n\n    1. Initialize an empty list `coordinates` to store the coordinates of the integer.\n    2. Iterate through the nested list `lst` using a loop.\n    3. For each row, iterate through the elements using another loop.\n    4. If the current element matches the integer `x`, append the coordinate (current row index, current column index) to the `coordinates` list.\n    5. After finding all coordinates, sort the list first by the row index in ascending order, and then by the column index in descending order.\n    6. Return the sorted `coordinates` list.\n", "requirement analysis:\nThe requirement is to find the coordinates of a specific integer in a nested list. The function should handle different row lengths and return the coordinates sorted by rows in ascending order and columns in descending order. This requirement is clear and specific, focusing on functionality and performance.\nrequirement pool:\n- Implement a function to find the coordinates of a specific integer in a nested list.\n- Ensure the function can handle lists with varying row lengths.\n- Return the coordinates sorted by rows in ascending order and columns in descending order.\n- Optimize the function for performance, especially for large datasets.\n- Provide detailed documentation and examples for the function.\nTo implement the function `get_row` efficiently, we will use Python's built-in data structures and functions to ensure simplicity and performance. The function will iterate through the nested list, checking for the presence of the target integer. Upon finding the integer, it will store the coordinates in a list of tuples. The coordinates will be sorted based on the row index in ascending order and column index in descending order. This approach leverages Python's dynamic typing and list comprehensions for clarity and efficiency.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': a list containing other lists as its elements.\n    Explanation: In this requirement, the data structure is a list of lists, where each sublist represents a row in a matrix-like structure, but the rows can have a varying number of columns.\n\n# [phrase showing quantity relationship]\n    'as many times': means the frequency of the target integer in the nested list.\n\n# [degree adverb] \n    'largest': means the integer with the highest frequency.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Steps:\n    1. Iterate through each row in the nested list.\n    2. For each row, iterate through each element to find the target integer.\n    3. Store the coordinates (row index, column index) of the target integer.\n    4. Sort the list of coordinates first by row index in ascending order, then by column index in descending order.\n    5. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5) = [(1, 1)]\n    Explanation: The target integer 5 is found in the second row and second column. The coordinates are sorted by row index (1) and then by column index (1) in ascending order.\n    get_row([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 10) = []\n    Explanation: The target integer 10 is not found in the nested list, so the function returns an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic will return an empty list if the target integer is not found.\n", "requirement analysis:\nThe primary requirement is to develop a function that can search for a specific integer within a nested list. The function should return a list of tuples representing the coordinates of the integer, sorted by rows in ascending order and columns in descending order. This requirement is crucial as it forms the core functionality of the product.\nrequirement pool:\n- Develop a function to search for an integer in a nested list.\n- Return a list of tuples representing the coordinates of the integer.\n- Sort the coordinates by rows in ascending order and columns in descending order.\n- Optimize the function for large datasets to ensure high performance.\n- Design a user-friendly interface for easy navigation and interaction.\nTo implement the function `get_row` that searches for a specific integer within a nested list, we will use Python's built-in data structures and libraries. The function will iterate through the nested list, identify the coordinates of the specified integer, and then sort these coordinates based on the given criteria. We will ensure efficiency by using list comprehensions and sorting techniques.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': a list containing other lists as its elements.\n    'coordinate': a pair of indices (row, column) that uniquely identifies a position in a 2D structure.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    get_row([[1, 2], [3, 4, 5], [6]], 4) = [(1, 1)]\n    Explanation:\n    The integer 4 is found in the second row (index 1) at the second column (index 1) of the nested list.\n    The expected output is a list of tuples containing the coordinates of the integer 4.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can handle the scenario where the integer is found in a row with varying columns.\n\nPlease provide the requirement and plan for the next prompt, and I will continue with the analysis.\n", "requirement analysis:\nThe primary requirement is to develop a function that can search for a specific integer within a nested list. The function should return a list of tuples representing the coordinates of the integer, sorted by rows in ascending order and columns in descending order. This requirement is crucial for users who need to locate specific data points within complex data structures.\nrequirement pool:\n- Develop a function to search for an integer in a nested list.\n- Return a list of tuples representing the coordinates of the integer.\n- Ensure the function is optimized for large datasets.\n- Implement sorting by rows in ascending order and columns in descending order.\n- Create a user-friendly interface for easy data analysis.\nTo implement the function efficiently, we will utilize Python's built-in data structures and libraries. The function will iterate through the nested list, checking for the presence of the target integer. Upon finding the integer, it will store the coordinates in a list of tuples. To ensure optimal performance, we will use list comprehensions and avoid unnecessary data manipulations. The sorting of coordinates will be handled using Python's sort() method, which is efficient for this purpose.\nPlease read and understand the following inteperation before coding\n ## Prompt 3:\n\n[requirement]\n```python\ndef get_row(lst, x):\n    '''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, but each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order, and sort coordinates of the row by columns in descending order. Examples:\n        get_row([\n            [1, 2, 3],\n            [4, 5],\n            [6, 7, 8, 9]\n        ], 5)\n        # Output: [(1, 1)]\n        \n        get_row([\n            [1, 2, 3],\n            [4, 5],\n            [6, 7, 8, 9]\n        ], 6)\n        # Output: [(2, 0)]\n    '''\n```\n\n[plan]\n```python\n{\n  \"plan\": {\n    \"subproblems\": [\n      \"Identify the presence of the target integer x in the nested list\",\n      \"Store the coordinates of the target integer\",\n      \"Sort the coordinates by rows in ascending order and columns in descending order\"\n    ],\n    \"steps\": [\n      \"Initialize an empty list to store the coordinates\",\n      \"Iterate through the nested list to find the target integer\",\n      \"For each occurrence, append the coordinate (row, column) to the list\",\n      \"Sort the list of coordinates first by row index in ascending order, then by column index in descending order\"\n    ]\n  }\n}\n```\n\n## Answer 3:\n\n# [core concept]\n    'nested list': a list containing other lists as its elements.\n    'coordinate': a pair of indices (row, column) that uniquely identifies an element in a nested list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    ```python\ndef get_row(lst, x):\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates\n    ```\n\n# [edge case]\n    get_row([[1, 2, 3], [4, 5], [6, 7, 8, 9]], 5) = [(1, 1)]\n    Explanation:\n    The target integer 5 is found in the second row (index 1) and the second column (index 1).\n    \n    get_row([[1, 2, 3], [4, 5], [6, 7, 8, 9]], 6) = [(2, 0)]\n    Explanation:\n    The target integer 6 is found in the third row (index 2) and the first column (index 0).\n\n# [extra code for edge case]\n    No extra code is needed for this implementation as it handles the edge cases implicitly by iterating through the entire nested list and sorting the coordinates.\n", "requirement analysis:\nThe requirement is to create a function that searches for a specific integer within a nested list and returns the coordinates of that integer. The function should return the coordinates sorted by rows in ascending order and within each row, columns in descending order. This ensures that the most relevant results are displayed first.\nrequirement pool:\n- Implement a function to search for an integer in a nested list.\n- Ensure the function returns coordinates sorted by rows and columns.\n- Optimize the function for large datasets to improve performance.\n- Develop a user-friendly interface for easy interaction.\n- Design a visually appealing interface to enhance user experience.\nTo implement the function efficiently, we will utilize Python's built-in capabilities and leverage the 'numpy' library for handling the nested lists as matrices. This approach ensures that we can handle large datasets effectively and perform matrix-like operations which are optimized for speed.\nPlease read and understand the following inteperation before coding\n ## Prompt 3:\n\n[requirement]\n```python\ndef get_row(lst, x):\n    '''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, but each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order, and sort coordinates of the row by columns in descending order. Examples:\n        get_row([\n            [1, 2, 3],\n            [4, 5],\n            [6, 7, 8, 9]\n        ], 5)\n        # Output: [(1, 1)]\n        \n        get_row([\n            [1, 2, 3],\n            [4, 5],\n            [6, 7, 8, 9]\n        ], 6)\n        # Output: [(2, 0)]\n    '''\n```\n\n[plan]\n```python\n{\n  \"plan\": {\n    \"subproblems\": [\n      \"Identify the presence of the integer x in the nested list\",\n      \"Record the coordinates of the integer x\",\n      \"Sort the coordinates by rows in ascending order and columns in descending order\"\n    ],\n    \"steps\": [\n      \"Iterate through the nested list to find the coordinates of x\",\n      \"Store the coordinates in a list of tuples\",\n      \"Sort the list of tuples based on the specified criteria\"\n    ]\n  }\n}\n```\n\n## Answer 3:\n\n# [core concept]\n    'nested list': a list containing other lists as its elements.\n    Explanation: In this requirement, the data structure is a list of lists, where each sublist can have a different number of elements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    ```python\ndef get_row(lst, x):\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    sorted_coordinates = sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\n    return sorted_coordinates\n    ```\n\n# [edge case]\n    get_row([[1, 2, 3], [4, 5], [6, 7, 8, 9]], 5) = [(1, 1)]\n    Explanation: The integer 5 is found in the second row (index 1) and the second column (index 1).\n    \n    get_row([[1, 2, 3], [4, 5], [6, 7, 8, 9]], 6) = [(2, 0)]\n    Explanation: The integer 6 is found in the third row (index 2) and the first column (index 0).\n    \n    get_row([[1, 2, 3], [4, 5], [6, 7, 8, 9]], 10) = []\n    Explanation: The integer 10 is not found in the nested list, so the output is an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided code already handles cases where the integer is not found by returning an empty list.\n\n    ```python\ndef get_row(lst, x):\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    if not coordinates:\n        return []\n    sorted_coordinates = sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\n    return sorted_coordinates\n    ```\n", "requirement analysis:\nThe requirement is to find all occurrences of a given integer `x` in a 2-dimensional data structure represented as a nested list. The coordinates of these occurrences need to be returned as a list of tuples, sorted first by rows in ascending order and then by columns in descending order.\nrequirement pool:\n- Implement a function to find all occurrences of `x` in the nested list.\n- Ensure the coordinates are sorted by rows in ascending order and columns in descending order.\nTo implement the function `find_occurrences` that finds all occurrences of a given integer `x` in a 2-dimensional data structure represented as a nested list, we will use a straightforward approach. We will iterate through each row and each element within the row to find the occurrences of `x`. Once found, we will store the coordinates in a list of tuples, ensuring they are sorted by rows in ascending order and columns in descending order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    '2-dimensional data structure': means a data structure that has rows and columns, like a matrix.\n    'nested list': means a list inside another list, which helps in creating a 2D structure.\n    'coordinate': means a position in the matrix, represented by (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Iterate through each row and each element within the row to find the occurrences of `x`.\n    Store the coordinates in a list of tuples, ensuring they are sorted by rows in ascending order and columns in descending order.\n\n# [edge case] \n    find_occurrences([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5) = [(1, 2)]\n    Explanation:\n    The number 5 is found in the second row and second column of the matrix.\n    The coordinates are sorted by rows in ascending order and then by columns in descending order.\n    find_occurrences([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 10) = []\n    Explanation:\n    The number 10 is not found in the matrix, so the expected output is an empty list.\n    find_occurrences([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]], 6) = [(3, 0)]\n    Explanation:\n    The number 6 is found in the fourth row and first column of the matrix.\n    The coordinates are sorted by rows in ascending order and then by columns in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic is sufficient to find the occurrences and sort the coordinates as required.\n", "requirement analysis:\nThe requirement is to find all occurrences of a given integer `x` in a 2-dimensional data structure represented as a nested list. The coordinates of these occurrences need to be returned as a list of tuples, sorted first by rows in ascending order and then by columns in descending order.\nrequirement pool:\n- Implement the function to find all occurrences of `x` in the nested list.\n- Ensure the coordinates are sorted by rows in ascending order and columns in descending order.\nTo implement the function `find_occurrences` that finds all occurrences of a given integer `x` in a 2-dimensional data structure represented as a nested list, we will use a straightforward approach. We will iterate through each row and each element within the row to find the occurrences of `x`. Once found, we will store the coordinates in a list of tuples. Finally, we will sort the list of tuples first by rows in ascending order and then by columns in descending order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    '2-dimensional data structure': means a data structure where elements are arranged in rows and columns, similar to a matrix.\n    'nested list': a list containing other lists as its elements.\n    'coordinate': a pair of values that specify the position of an element in a 2-dimensional space.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Iterate through each row and each element within the row to find the occurrences of `x`.\n    Store the coordinates in a list of tuples.\n    Sort the list of tuples first by rows in ascending order and then by columns in descending order.\n\n# [edge case] \n    find_occurrences([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5) = [(1, 1)]\n    Explanation:\n    The integer 5 is found in the second row and second column of the matrix.\n    The coordinates are sorted by rows in ascending order and then by columns in descending order, resulting in [(1, 1)].\n\n    find_occurrences([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 10) = []\n    Explanation:\n    The integer 10 is not found in the matrix.\n    The function returns an empty list as there are no occurrences of 10.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic is sufficient to return an empty list when the integer is not found.\n", "requirement analysis:\nThe requirement is to find all occurrences of a given integer `x` in a 2-dimensional data structure represented as a nested list. The coordinates of these occurrences need to be returned as a list of tuples, sorted first by rows in ascending order and then by columns in descending order.\nrequirement pool:\n- Implement a function to find all occurrences of `x` in the nested list.\n- Ensure the coordinates are sorted by rows in ascending order and columns in descending order.\nTo implement the function `find_occurrences` that finds all occurrences of a given integer `x` in a 2-dimensional data structure represented as a nested list, we will use a straightforward approach. We will iterate through each row and each element within the row to find the occurrences of `x`. Once found, we will store the coordinates in a list of tuples, ensuring they are sorted by rows in ascending order and columns in descending order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    '2-dimensional data structure': means a data structure that has rows and columns, like a matrix.\n    'nested list': means a list inside another list, which helps in creating a 2D structure.\n    'coordinate': means a position in a matrix, represented by (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Iterate through each row and each element within the row to find the occurrences of `x`.\n    Store the coordinates in a list of tuples, ensuring they are sorted by rows in ascending order and columns in descending order.\n\n# [edge case] \n    find_occurrences([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5) = [(1, 2)]\n    Explanation:\n    The number 5 is found in the second row and second column of the matrix.\n    The coordinates are sorted by rows in ascending order and then by columns in descending order.\n    find_occurrences([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 10) = []\n    Explanation:\n    The number 10 is not found in the matrix, so the expected output is an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic will return an empty list if the number is not found.\n", "requirement analysis:\nThe requirement is to find the coordinates of a specific integer in a nested list. The coordinates should be sorted by rows in ascending order and by columns in descending order. This requirement is crucial for users who need to locate specific elements in a large dataset efficiently.\nrequirement pool:\n- Implement a function to find the coordinates of a specific integer in a nested list.\n- Ensure the coordinates are sorted by rows in ascending order and by columns in descending order.\n- Optimize the function to handle large datasets efficiently.\n- Develop a user-friendly interface for easy interaction.\n- Include error handling to manage unexpected inputs.\nTo implement the function `get_row` efficiently, we will use Python's built-in data structures and libraries. The function will iterate through the nested list to find the specified integer, and then store its coordinates in a list of tuples. These coordinates will be sorted based on the requirements, first by rows in ascending order and then by columns in descending order. We will ensure the function handles edge cases such as empty lists and lists with varying row lengths.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'nested list': a list containing other lists as its elements.\n    Explanation: In this requirement, the data structure is a list of lists, where each sublist represents a row in a matrix-like structure, but the rows can have a different number of columns.\n\n# [phrase showing quantity relationship]\n    'as many times': means the frequency of the integer in the list.\n\n# [degree adverb] \n    'largest': means the maximum integer that meets the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Steps:\n    1. Iterate through the nested list to find the specified integer.\n    2. Store the coordinates of the integer in a list of tuples.\n    3. Sort the coordinates by rows in ascending order and then by columns in descending order.\n\n# [edge case] \n    get_row([[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]], 1) = [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    Explanation:\n    The integer 1 is found at the following coordinates: (0,0), (1,4), (1,0), (2,5), (2,0). These coordinates are sorted by rows (0, 1, 2) in ascending order and then by columns (0, 0, 4, 5) in descending order within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic already covers the edge case of an empty list and lists with varying row lengths.\n\n# [core concept]\n    'sliding window': a technique where you slide a window across a data structure to perform operations on the data.\n\n# [phrase showing quantity relationship]\n    'at least as many times': means the integer appears at least as many times as its value.\n\n# [degree adverb] \n    'largest': means the largest integer that meets the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Steps:\n    1. Create a dictionary to store the frequency of each integer in the list.\n    2. Iterate through the list and update the frequency in the dictionary.\n    3. Iterate through the dictionary to find the largest integer that meets the condition.\n    4. Return the result or -1 if no such integer exists.\n\n# [edge case] \n    search([4, 1, 2, 2, 3, 1]) = 2\n    Explanation:\n    The integer 2 appears twice, which is more than its value (2). The integer 3 appears three times, which is more than its value (3). The largest integer that meets the condition is 3, but since no integer appears as many times as itself, the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic already covers the edge case where no integer meets the condition.\n\n# [core concept]\n    'nested list': a list containing other lists as its elements.\n    Explanation: In this requirement, the data structure is a list of lists, where each sublist represents a row in a matrix-like structure, but the rows can have a different number of columns.\n\n# [phrase showing quantity relationship]\n    'at least as many times': means the integer appears at least as many times as its value.\n\n# [degree adverb] \n    'largest': means the largest integer that meets the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Steps:\n    1. Iterate through the nested list to find the specified integer.\n    2. Store the coordinates of the integer in a list of tuples.\n    3. Sort the coordinates by rows in ascending order and then by columns in descending order.\n\n# [edge case] \n    get_row([[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]], 1) = [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    Explanation:\n    The integer 1 is found at the following coordinates: (0,0), (1,4), (1,0), (2,5), (2,0). These coordinates are sorted by rows (0, 1, 2) in ascending order and then by columns (0, 0, 4, 5) in descending order within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic already covers the edge case of an empty list and lists with varying row lengths.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 0.9195, 0.0, 0.0, 0.0, 1.0], "pass_results": [true, true, true, true, true, false, false, false, false, true], "pass_test_cases_num": [87, 87, 87, 87, 87, 80, 0, 0, 0, 87], "completion": "from typing import List\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    This function takes a nested list and an integer, then returns a list of tuples\n    representing the coordinates of the integer in the nested list. The coordinates\n    are sorted by rows in ascending order and then by columns in descending order.\n    \n    Args:\n        lst (List[List[int]]): The nested list to search through.\n        x (int): The integer to find in the nested list.\n        \n    Returns:\n        List[Tuple[int, int]]: A list of tuples representing the coordinates of x.\n    \"\"\"\n    coordinates = []\n    \n    # Iterate through the nested list to find the specified integer\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort the coordinates by rows in ascending order and then by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n", "passed": true, "pass": true, "pass_num": 6, "round": 576, "repair_prompt": ["def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, but each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order, and sort coordinates of the row by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", " def get_row(lst, x):\n    '''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, but each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order, and sort coordinates of the row by columns in descending order.\n    Examples:\n        get_row([", " You are given a 2-dimensional data structure, represented as a nested list, which can be thought of as a matrix where each row may have a different number of columns. Given the list `lst` and an integer `x`, your task is to find all occurrences of `x` in the list and return a list of tuples `[(x1, y1), (x2, y2) ...]` where each tuple represents a coordinate in the matrix - `(row, column)`. The coordinates should be sorted first by rows in ascending order and then by columns in descending order.\n\nExamples:\n```"], "mutate_method": "condense_two2one", "parent_index": 292}
