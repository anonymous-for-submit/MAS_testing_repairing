{"task_id": "HumanEval/58", "prompt": "def common(l1: list, l2: list):\t\n'''Return ordered unique shared elements for two lists.\n>>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    '''", "entry_point": "common", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "test": ["def check(common):\n\tassert common([6, 5, 7, 10], [8, 4]) == []", "def check(common):\n\tassert common([6, 3, 2, 37, 657, 2, 6], [5, 9, 1, 6, 4, 654, 125]) == [6]", "def check(common):\n\tassert common([1, 6, 5, 9], [1, 6, 1]) == [1, 6]", "def check(common):\n\tassert common([8, 7, 6, 13], [7, 2]) == [7]", "def check(common):\n\tassert common([1, 1, 3, 11], [5, 3, 2]) == [3]", "def check(common):\n\tassert common([7, 8, 6, 11], [4, 5, 9]) == []", "def check(common):\n\tassert common([1, 6, 5, 34, 651, 3, 3], [7, 8, 1, 7, 9, 653, 121]) == [1]", "def check(common):\n\tassert common([6, 6, 4, 12], [3, 1]) == []", "def check(common):\n\tassert common([6, 1, 5, 36, 648, 1, 6], [3, 4, 2, 1, 12, 654, 123]) == [1]", "def check(common):\n\tassert common([6, 3, 7, 6], [3, 5, 7]) == [3, 7]", "def check(common):\n\tassert common([4, 8, 2, 9], [3, 1]) == []", "def check(common):\n\tassert common([3, 5, 5, 8], [7, 6]) == []", "def check(common):\n\tassert common([1, 8, 3, 4], [8, 7, 6]) == [8]", "def check(common):\n\tassert common([5, 2, 6, 30, 650, 7, 3], [7, 10, 2, 4, 4, 651, 126]) == [2, 7]", "def check(common):\n\tassert common([4, 6, 6, 7], [8, 6, 9]) == [6]", "def check(common):\n\tassert common([3, 7, 6, 3], [2, 4, 5]) == []", "def check(common):\n\tassert common([7, 4, 3, 10], [3, 1]) == [3]", "def check(common):\n\tassert common([3, 3, 1, 4], [4, 6, 4]) == [4]", "def check(common):\n\tassert common([4, 5, 2, 5], [1, 7, 5]) == [5]", "def check(common):\n\tassert common([5, 3, 4, 35, 652, 1, 1], [9, 6, 2, 8, 6, 653, 122]) == []", "def check(common):\n\tassert common([3, 1, 6, 11], [6, 6]) == [6]", "def check(common):\n\tassert common([7, 4, 7, 13], [8, 4]) == [4]", "def check(common):\n\tassert common([4, 4, 4, 34, 652, 5, 10], [8, 2, 1, 4, 5, 652, 117]) == [4, 5, 652]", "def check(common):\n\tassert common([2, 8, 3, 29, 650, 1, 7], [3, 6, 2, 3, 7, 652, 116]) == [2, 3, 7]", "def check(common):\n\tassert common([5, 8, 7, 3], [6, 4]) == []", "def check(common):\n\tassert common([2, 2, 1, 29, 650, 4, 2], [3, 10, 6, 2, 11, 651, 119]) == [2]", "def check(common):\n\tassert common([3, 3, 2, 30, 656, 3, 4], [6, 11, 2, 4, 4, 652, 123]) == [2, 4]", "def check(common):\n\tassert common([6, 1, 4, 33, 651, 4, 3], [4, 10, 1, 10, 12, 657, 126]) == [1, 4]", "def check(common):\n\tassert common([6, 6, 4, 5], [3, 3, 8]) == []", "def check(common):\n\tassert common([5, 5, 4, 34, 648, 5, 5], [3, 7, 6, 2, 10, 648, 116]) == [648]", "def check(common):\n\tassert common([2, 1, 7, 9], [6, 3]) == []", "def check(common):\n\tassert common([4, 1, 4, 12], [5, 1, 7]) == [1]", "def check(common):\n\tassert common([7, 6, 3, 9], [6, 5]) == [6]", "def check(common):\n\tassert common([2, 3, 3, 9], [5, 2]) == [2]", "def check(common):\n\tassert common([1, 4, 1, 32, 657, 7, 6], [4, 10, 2, 2, 4, 650, 124]) == [4]", "def check(common):\n\tassert common([8, 3, 4, 10], [8, 7]) == [8]", "def check(common):\n\tassert common([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]", "def check(common):\n\tassert common([5, 2, 2, 30, 654, 5, 1], [3, 3, 2, 10, 6, 657, 126]) == [2]", "def check(common):\n\tassert common([2, 7, 4, 3], [8, 7, 5]) == [7]", "def check(common):\n\tassert common([4, 5, 7, 12], [7, 1]) == [7]", "def check(common):\n\tassert common([9, 3, 7, 4], [4, 2, 4]) == [4]", "def check(common):\n\tassert common([3, 1, 3, 10], [3, 3, 9]) == [3]", "def check(common):\n\tassert common([4, 4, 1, 37, 654, 7, 5], [3, 11, 2, 6, 9, 656, 120]) == []", "def check(common):\n\tassert common([2, 6, 2, 8], [5, 2]) == [2]", "def check(common):\n\tassert common([2, 4, 3, 12], [4, 5, 6]) == [4]", "def check(common):\n\tassert common([4, 4, 7, 8], [4, 4, 9]) == [4]", "def check(common):\n\tassert common([1, 6, 6, 12], [6, 2, 9]) == [6]", "def check(common):\n\tassert common([2, 7, 1, 4], [1, 2, 1]) == [1, 2]", "def check(common):\n\tassert common([2, 5, 6, 32, 649, 3, 9], [8, 6, 1, 4, 4, 658, 117]) == [6]", "def check(common):\n\tassert common([2, 1, 5, 37, 657, 7, 1], [4, 9, 3, 1, 12, 649, 122]) == [1]", "def check(common):\n\tassert common([5, 5, 7, 7], [5, 2]) == [5]", "def check(common):\n\tassert common([5, 3, 2, 8], [3, 2]) == [2, 3]", "def check(common):\n\tassert common([5, 4, 5, 32, 655, 6, 2], [2, 10, 4, 2, 14, 656, 117]) == [2, 4]", "def check(common):\n\tassert common([3, 4, 4, 8], [3, 3, 9]) == [3]", "def check(common):\n\tassert common([5, 2, 1, 3], [8, 3]) == [3]", "def check(common):\n\tassert common([3, 8, 3, 35, 651, 4, 2], [1, 12, 6, 10, 4, 654, 119]) == [4]", "def check(common):\n\tassert common([5, 6, 4, 8], [3, 7, 2]) == []", "def check(common):\n\tassert common([7, 7, 5, 11], [3, 4]) == []", "def check(common):\n\tassert common([4, 3, 2, 8], []) == []", "def check(common):\n\tassert common([7, 7, 7, 3], [2, 4]) == []", "def check(common):\n\tassert common([2, 9, 3, 36, 649, 6, 7], [10, 12, 4, 4, 14, 656, 116]) == []", "def check(common):\n\tassert common([3, 8, 6, 6], [4, 3, 3]) == [3]", "def check(common):\n\tassert common([1, 8, 7, 3], [2, 6]) == []", "def check(common):\n\tassert common([1, 4, 5, 11], [1, 6, 1]) == [1]", "def check(common):\n\tassert common([6, 2, 3, 8], [7, 6, 8]) == [6, 8]", "def check(common):\n\tassert common([1, 7, 4, 30, 653, 1, 1], [6, 9, 2, 2, 13, 650, 120]) == []", "def check(common):\n\tassert common([6, 8, 4, 32, 657, 7, 6], [4, 10, 1, 5, 14, 652, 120]) == [4]", "def check(common):\n\tassert common([2, 7, 7, 32, 650, 5, 6], [7, 2, 4, 3, 13, 654, 117]) == [2, 7]", "def check(common):\n\tassert common([1, 4, 7, 30, 658, 3, 10], [6, 7, 3, 10, 10, 658, 117]) == [3, 7, 10, 658]", "def check(common):\n\tassert common([8, 4, 1, 9], [6, 3]) == []", "def check(common):\n\tassert common([2, 1, 4, 37, 657, 3, 7], [8, 5, 5, 10, 7, 654, 121]) == [7]", "def check(common):\n\tassert common([9, 7, 7, 7], [5, 2]) == []", "def check(common):\n\tassert common([4, 6, 3, 31, 648, 7, 10], [1, 10, 4, 7, 7, 653, 117]) == [4, 7, 10]", "def check(common):\n\tassert common([6, 5, 2, 3], [3, 3, 3]) == [3]", "def check(common):\n\tassert common([4, 4, 1, 8], [1, 5, 7]) == [1]", "def check(common):\n\tassert common([8, 4, 6, 5], [1, 1]) == []", "def check(common):\n\tassert common([4, 5, 3, 10], [7, 5]) == [5]", "def check(common):\n\tassert common([7, 1, 7, 13], [3, 1]) == [1]", "def check(common):\n\tassert common([1, 5, 5, 29, 655, 4, 1], [5, 3, 2, 1, 5, 648, 118]) == [1, 5]", "def check(common):\n\tassert common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]", "def check(common):\n\tassert common([7, 7, 1, 4], [5, 6]) == []", "def check(common):\n\tassert common([5, 4, 2, 36, 648, 7, 10], [6, 8, 1, 5, 11, 649, 126]) == [5]", "def check(common):\n\tassert common([8, 1, 1, 3], [5, 6]) == []", "def check(common):\n\tassert common([6, 3, 6, 3], [8, 5, 8]) == []", "def check(common):\n\tassert common([6, 8, 7, 32, 654, 7, 3], [7, 7, 2, 5, 10, 654, 123]) == [7, 654]", "def check(common):\n\tassert common([2, 2, 6, 11], [5, 6, 1]) == [6]", "def check(common):\n\tassert common([1, 4, 6, 39, 653, 4, 3], [6, 12, 2, 3, 14, 654, 116]) == [3, 6]", "def check(common):\n\tassert common([1, 3, 4, 9], [7, 3]) == [3]", "def check(common):\n\tassert common([9, 6, 6, 7], [7, 7, 1]) == [7]", "def check(common):\n\tassert common([5, 6, 2, 34, 654, 3, 7], [7, 9, 1, 7, 8, 650, 122]) == [7]", "def check(common):\n\tassert common([8, 2, 7, 4], [7, 7, 1]) == [7]", "def check(common):\n\tassert common([3, 2, 1, 37, 654, 7, 6], [2, 3, 2, 6, 4, 649, 123]) == [2, 3, 6]", "def check(common):\n\tassert common([9, 2, 7, 4], [5, 4, 1]) == [4]", "def check(common):\n\tassert common([8, 1, 4, 10], [4, 2]) == [4]", "def check(common):\n\tassert common([2, 8, 5, 10], [8, 4]) == [8]", "def check(common):\n\tassert common([8, 4, 4, 6], [3, 6]) == [6]", "def check(common):\n\tassert common([3, 6, 6, 7], [7, 4, 2]) == [7]", "def check(common):\n\tassert common([3, 4, 3, 11], [4, 1, 7]) == [4]", "def check(common):\n\tassert common([3, 1, 4, 5], [1, 1]) == [1]", "def check(common):\n\tassert common([3, 2, 5, 37, 652, 2, 3], [5, 4, 6, 7, 9, 651, 120]) == [5]"], "test_case_list": ["assert common([6, 5, 7, 10], [8, 4]) == []", "assert common([6, 3, 2, 37, 657, 2, 6], [5, 9, 1, 6, 4, 654, 125]) == [6]", "assert common([1, 6, 5, 9], [1, 6, 1]) == [1, 6]", "assert common([8, 7, 6, 13], [7, 2]) == [7]", "assert common([1, 1, 3, 11], [5, 3, 2]) == [3]", "assert common([7, 8, 6, 11], [4, 5, 9]) == []", "assert common([1, 6, 5, 34, 651, 3, 3], [7, 8, 1, 7, 9, 653, 121]) == [1]", "assert common([6, 6, 4, 12], [3, 1]) == []", "assert common([6, 1, 5, 36, 648, 1, 6], [3, 4, 2, 1, 12, 654, 123]) == [1]", "assert common([6, 3, 7, 6], [3, 5, 7]) == [3, 7]", "assert common([4, 8, 2, 9], [3, 1]) == []", "assert common([3, 5, 5, 8], [7, 6]) == []", "assert common([1, 8, 3, 4], [8, 7, 6]) == [8]", "assert common([5, 2, 6, 30, 650, 7, 3], [7, 10, 2, 4, 4, 651, 126]) == [2, 7]", "assert common([4, 6, 6, 7], [8, 6, 9]) == [6]", "assert common([3, 7, 6, 3], [2, 4, 5]) == []", "assert common([7, 4, 3, 10], [3, 1]) == [3]", "assert common([3, 3, 1, 4], [4, 6, 4]) == [4]", "assert common([4, 5, 2, 5], [1, 7, 5]) == [5]", "assert common([5, 3, 4, 35, 652, 1, 1], [9, 6, 2, 8, 6, 653, 122]) == []", "assert common([3, 1, 6, 11], [6, 6]) == [6]", "assert common([7, 4, 7, 13], [8, 4]) == [4]", "assert common([4, 4, 4, 34, 652, 5, 10], [8, 2, 1, 4, 5, 652, 117]) == [4, 5, 652]", "assert common([2, 8, 3, 29, 650, 1, 7], [3, 6, 2, 3, 7, 652, 116]) == [2, 3, 7]", "assert common([5, 8, 7, 3], [6, 4]) == []", "assert common([2, 2, 1, 29, 650, 4, 2], [3, 10, 6, 2, 11, 651, 119]) == [2]", "assert common([3, 3, 2, 30, 656, 3, 4], [6, 11, 2, 4, 4, 652, 123]) == [2, 4]", "assert common([6, 1, 4, 33, 651, 4, 3], [4, 10, 1, 10, 12, 657, 126]) == [1, 4]", "assert common([6, 6, 4, 5], [3, 3, 8]) == []", "assert common([5, 5, 4, 34, 648, 5, 5], [3, 7, 6, 2, 10, 648, 116]) == [648]", "assert common([2, 1, 7, 9], [6, 3]) == []", "assert common([4, 1, 4, 12], [5, 1, 7]) == [1]", "assert common([7, 6, 3, 9], [6, 5]) == [6]", "assert common([2, 3, 3, 9], [5, 2]) == [2]", "assert common([1, 4, 1, 32, 657, 7, 6], [4, 10, 2, 2, 4, 650, 124]) == [4]", "assert common([8, 3, 4, 10], [8, 7]) == [8]", "assert common([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]", "assert common([5, 2, 2, 30, 654, 5, 1], [3, 3, 2, 10, 6, 657, 126]) == [2]", "assert common([2, 7, 4, 3], [8, 7, 5]) == [7]", "assert common([4, 5, 7, 12], [7, 1]) == [7]", "assert common([9, 3, 7, 4], [4, 2, 4]) == [4]", "assert common([3, 1, 3, 10], [3, 3, 9]) == [3]", "assert common([4, 4, 1, 37, 654, 7, 5], [3, 11, 2, 6, 9, 656, 120]) == []", "assert common([2, 6, 2, 8], [5, 2]) == [2]", "assert common([2, 4, 3, 12], [4, 5, 6]) == [4]", "assert common([4, 4, 7, 8], [4, 4, 9]) == [4]", "assert common([1, 6, 6, 12], [6, 2, 9]) == [6]", "assert common([2, 7, 1, 4], [1, 2, 1]) == [1, 2]", "assert common([2, 5, 6, 32, 649, 3, 9], [8, 6, 1, 4, 4, 658, 117]) == [6]", "assert common([2, 1, 5, 37, 657, 7, 1], [4, 9, 3, 1, 12, 649, 122]) == [1]", "assert common([5, 5, 7, 7], [5, 2]) == [5]", "assert common([5, 3, 2, 8], [3, 2]) == [2, 3]", "assert common([5, 4, 5, 32, 655, 6, 2], [2, 10, 4, 2, 14, 656, 117]) == [2, 4]", "assert common([3, 4, 4, 8], [3, 3, 9]) == [3]", "assert common([5, 2, 1, 3], [8, 3]) == [3]", "assert common([3, 8, 3, 35, 651, 4, 2], [1, 12, 6, 10, 4, 654, 119]) == [4]", "assert common([5, 6, 4, 8], [3, 7, 2]) == []", "assert common([7, 7, 5, 11], [3, 4]) == []", "assert common([4, 3, 2, 8], []) == []", "assert common([7, 7, 7, 3], [2, 4]) == []", "assert common([2, 9, 3, 36, 649, 6, 7], [10, 12, 4, 4, 14, 656, 116]) == []", "assert common([3, 8, 6, 6], [4, 3, 3]) == [3]", "assert common([1, 8, 7, 3], [2, 6]) == []", "assert common([1, 4, 5, 11], [1, 6, 1]) == [1]", "assert common([6, 2, 3, 8], [7, 6, 8]) == [6, 8]", "assert common([1, 7, 4, 30, 653, 1, 1], [6, 9, 2, 2, 13, 650, 120]) == []", "assert common([6, 8, 4, 32, 657, 7, 6], [4, 10, 1, 5, 14, 652, 120]) == [4]", "assert common([2, 7, 7, 32, 650, 5, 6], [7, 2, 4, 3, 13, 654, 117]) == [2, 7]", "assert common([1, 4, 7, 30, 658, 3, 10], [6, 7, 3, 10, 10, 658, 117]) == [3, 7, 10, 658]", "assert common([8, 4, 1, 9], [6, 3]) == []", "assert common([2, 1, 4, 37, 657, 3, 7], [8, 5, 5, 10, 7, 654, 121]) == [7]", "assert common([9, 7, 7, 7], [5, 2]) == []", "assert common([4, 6, 3, 31, 648, 7, 10], [1, 10, 4, 7, 7, 653, 117]) == [4, 7, 10]", "assert common([6, 5, 2, 3], [3, 3, 3]) == [3]", "assert common([4, 4, 1, 8], [1, 5, 7]) == [1]", "assert common([8, 4, 6, 5], [1, 1]) == []", "assert common([4, 5, 3, 10], [7, 5]) == [5]", "assert common([7, 1, 7, 13], [3, 1]) == [1]", "assert common([1, 5, 5, 29, 655, 4, 1], [5, 3, 2, 1, 5, 648, 118]) == [1, 5]", "assert common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]", "assert common([7, 7, 1, 4], [5, 6]) == []", "assert common([5, 4, 2, 36, 648, 7, 10], [6, 8, 1, 5, 11, 649, 126]) == [5]", "assert common([8, 1, 1, 3], [5, 6]) == []", "assert common([6, 3, 6, 3], [8, 5, 8]) == []", "assert common([6, 8, 7, 32, 654, 7, 3], [7, 7, 2, 5, 10, 654, 123]) == [7, 654]", "assert common([2, 2, 6, 11], [5, 6, 1]) == [6]", "assert common([1, 4, 6, 39, 653, 4, 3], [6, 12, 2, 3, 14, 654, 116]) == [3, 6]", "assert common([1, 3, 4, 9], [7, 3]) == [3]", "assert common([9, 6, 6, 7], [7, 7, 1]) == [7]", "assert common([5, 6, 2, 34, 654, 3, 7], [7, 9, 1, 7, 8, 650, 122]) == [7]", "assert common([8, 2, 7, 4], [7, 7, 1]) == [7]", "assert common([3, 2, 1, 37, 654, 7, 6], [2, 3, 2, 6, 4, 649, 123]) == [2, 3, 6]", "assert common([9, 2, 7, 4], [5, 4, 1]) == [4]", "assert common([8, 1, 4, 10], [4, 2]) == [4]", "assert common([2, 8, 5, 10], [8, 4]) == [8]", "assert common([8, 4, 4, 6], [3, 6]) == [6]", "assert common([3, 6, 6, 7], [7, 4, 2]) == [7]", "assert common([3, 4, 3, 11], [4, 1, 7]) == [4]", "assert common([3, 1, 4, 5], [1, 1]) == [1]", "assert common([3, 2, 5, 37, 652, 2, 3], [5, 4, 6, 7, 9, 651, 120]) == [5]"], "nl": "Return sorted unique common elements for two lists.\n    ", "func": "def common(l1: list, l2: list):", "examples": ">>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    ", "completions": ["from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Returns a list of elements that are common to both input lists, maintaining the order of their first appearance.\n    \n    Args:\n        l1 (list): The first list of elements.\n        l2 (list): The second list of elements.\n    \n    Returns:\n        list: A list of elements that are common to both input lists.\n    \"\"\"\n    if not isinstance(l1, list) or not isinstance(l2, list):\n        raise ValueError(\"Both inputs must be lists.\")\n    \n    # Convert lists to sets to remove duplicates and find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set back to a list to maintain order\n    result = [element for element in l1 if element in common_elements]\n    \n    return result\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Returns a list of unique shared elements between two lists, maintaining the order of their first occurrence.\n\n    Args:\n        l1 (list): The first list of elements.\n        l2 (list): The second list of elements.\n\n    Returns:\n        list: A list of unique shared elements, ordered as they first appear in the original lists.\n    \"\"\"\n    # Convert lists to sets to find the intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection result back to a list to maintain order and uniqueness\n    result = list(intersection)\n    \n    return result\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Finds the common elements between two lists, ensuring uniqueness and order.\n\n    Args:\n        l1 (list): The first list of elements.\n        l2 (list): The second list of elements.\n\n    Returns:\n        list: A list of unique, ordered common elements.\n    \"\"\"\n    # Convert both lists to sets to remove duplicates\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of these sets to get the common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the result back to a list to maintain the order\n    result = list(common_elements)\n    \n    return result\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef common(l1: List[int], l2: List[int]) -> List[int]:\n    '''Return ordered unique shared elements for two lists.\n    Args:\n        l1 (List[int]): The first list of elements.\n        l2 (List[int]): The second list of elements.\n    Returns:\n        List[int]: A list of ordered unique shared elements.\n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    '''\n    # Convert lists to sets to find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set of common elements to a sorted list\n    result = sorted(list(common_elements))\n    \n    return result\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    '''Return ordered unique shared elements for two lists.\n    Args:\n        l1 (list): The first list of elements.\n        l2 (list): The second list of elements.\n    Returns:\n        list: A list of ordered unique shared elements.\n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    '''\n    # Convert lists to sets to find the intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection result back to a list to maintain order and remove duplicates\n    result = list(intersection)\n    \n    return result\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef common(l1: List[int], l2: List[int]) -> List[int]:\n    '''Return ordered unique shared elements for two lists.\n    Args:\n        l1 (List[int]): The first list of elements.\n        l2 (List[int]): The second list of elements.\n    Returns:\n        List[int]: A list of unique shared elements in the order they first appear.\n    '''\n    # Convert lists to sets to remove duplicates and enable set operations\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection set back to a list to maintain the order\n    result = [elem for elem in l1 if elem in intersection]\n    \n    return result\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Returns a list of ordered unique shared elements between two lists.\n    \n    Args:\n        l1 (list): The first list of elements.\n        l2 (list): The second list of elements.\n    \n    Returns:\n        list: A list of elements that are present in both lists and appear only once in the combined result, in the order of their first occurrence in the original lists.\n    \"\"\"\n    # Convert both lists to sets to find the intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the sets\n    intersection = set1 & set2\n    \n    # Convert the intersection result to a list to ensure uniqueness and order\n    result = [item for item in l1 if item in intersection]\n    \n    return result\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef common(l1: List[int], l2: List[int]) -> List[int]:\n    '''Return ordered unique shared elements for two lists.\n    Args:\n        l1 (List[int]): The first list of elements.\n        l2 (List[int]): The second list of elements.\n    Returns:\n        List[int]: A list of unique shared elements, ordered.\n    '''\n    # Convert lists to sets to remove duplicates\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection result back to a list and sort it based on the original order in l1\n    result = sorted(list(intersection), key=l1.index)\n    \n    return result\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Returns a list of unique shared elements between two lists, maintaining the order of the first occurrence in each list.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n    \n    Returns:\n        list: A list of unique shared elements, ordered as they first appear in each list.\n    \"\"\"\n    # Convert lists to sets to find the intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection result back to a list to maintain order and uniqueness\n    result = [item for item in l1 if item in intersection]\n    \n    return result\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    '''Return ordered unique shared elements for two lists.\n    Args:\n        l1 (list): The first list of elements.\n        l2 (list): The second list of elements.\n    Returns:\n        list: A list of unique shared elements in the order they appear in the input lists.\n    '''\n    # Convert lists to sets to remove duplicates and facilitate set operations\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Use the intersection operation to find common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the result back to a list to maintain the order of first appearance\n    result = list(common_elements)\n    \n    return result\n"], "plans": ["requirement analysis:\nThe original requirements specify a function that takes two lists and returns a list of common elements. The function should return unique elements and maintain the order of their first appearance in the lists. This aligns with standard practices for set operations in Python, which typically use sets to find common elements and then convert them back to lists if order is required.\nrequirement pool:\n- Implement the function to return unique shared elements from two lists.\n- Ensure the function returns elements in the order they appear in the original lists.\n- Optimize the function for performance to handle large datasets efficiently.\n- Include error handling to manage cases where non-list inputs are provided.\n- Add documentation to explain the function's purpose and usage.\nTo implement the function efficiently and accurately, we will utilize Python's built-in set operations combined with list comprehensions to find common elements. This approach ensures both uniqueness and order preservation. We will also include error handling to manage non-list inputs, ensuring robustness.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'unique shared elements': means that the elements that appear in both lists and should not have duplicates.\n    'ordered': means that the order of elements in the result should be the same as their first appearance in the input lists.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Steps to implement the function:\n    1. Convert both lists to sets to remove duplicates.\n    2. Find the intersection of these sets to get the common elements.\n    3. Convert the result back to a list to maintain order.\n    4. Return the final list of common elements.\n\n# [edge case] \n    common([], [1, 2, 3]) = []\n    explanation: Since the first list is empty, there are no common elements, so the expected output is an empty list.\n    common([1, 2, 3], []) = []\n    explanation: Since the second list is empty, there are no common elements, so the expected output is an empty list.\n    common([1, 2, 3], [4, 5, 6]) = []\n    explanation: There are no common elements between the two lists, so the expected output is an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic will return an empty list for both empty input lists.\n", "requirement analysis:\nThe original requirements specify a function that takes two lists and returns a list of common elements. The function should return unique elements and the order of elements should be maintained. This is a basic requirement for any programming task and aligns with standard list operations.\nrequirement pool:\n- Implement the function to return unique shared elements from two lists.\n- Ensure the function maintains the order of elements in the result.\n- Optimize the function for performance to handle large datasets.\n- Include error handling for non-list inputs.\n- Add documentation and examples to the function.\nTo implement the function efficiently and accurately, we will utilize Python's built-in set operations, which are optimized for performance and easy to use. The function will convert the input lists to sets to find the intersection, then convert the result back to a list to maintain order and ensure uniqueness.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'unique shared elements': means the elements that are present in both lists and should not have duplicates.\n    'ordered': means the result should maintain the order of the first occurrence in the original lists.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Convert both lists to sets to find the intersection.\n    - Convert the intersection result back to a list to maintain order and uniqueness.\n\n# [edge case] \n    common([1, 2, 3], [4, 5, 6]) = []\n    Explanation: There are no common elements between the two lists, so the expected output is an empty list.\n    common([], [1, 2, 3]) = []\n    Explanation: If one of the lists is empty, there can be no common elements, so the expected output is an empty list.\n    common([1, 2, 2, 3], [2, 2, 4, 3]) = [2, 3]\n    Explanation: The common elements are 2 and 3, but since we need unique shared elements and maintain order, the output is [2, 3].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already covers the case where one or both lists are empty, and it will naturally produce an empty result.\n", "requirement analysis:\nThe requirement is to create a function that returns ordered unique shared elements between two lists. This function should be efficient and easy to understand. The function should handle basic list operations and ensure that the results are unique and ordered.\nrequirement pool:\n- The function should return only unique shared elements from the two lists.\n- The function should return the elements in the order they first appear in the lists.\n- The function should be optimized for performance, handling large datasets efficiently.\n- The function should be easy to read and understand, suitable for developers.\n- The function should handle basic list operations without relying on external libraries.\nWe will use Python's built-in data structures and set operations to efficiently find the common elements between two lists. To ensure the uniqueness and order of the results, we will convert the final result to a list and use a set to filter out duplicates. This approach balances simplicity and performance, making it suitable for handling basic list operations.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'unique shared elements': means that the elements that appear in both lists and should not have duplicates.\n    'ordered': means that the final result should maintain the order of the first occurrence in the original lists.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    To implement the function `common(l1, l2)`, we can follow these steps:\n    1. Convert both lists to sets to remove duplicates.\n    2. Find the intersection of these sets to get the common elements.\n    3. Convert the result back to a list to maintain the order.\n    4. Return the final list.\n\n# [edge case] \n    common([1, 2, 3], [4, 5, 6]) = []\n    Explanation: There are no common elements between the two lists, so the expected output is an empty list.\n    common([1, 2, 2, 3], [2, 2, 4, 5]) = [2]\n    Explanation: The number 2 is the only common element, and it should appear in the result as it is the first occurrence in the original lists.\n    common([], [1, 2, 3]) = []\n    Explanation: If one of the lists is empty, there can be no common elements, so the expected output is an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan already covers the case where one or both lists are empty.\n", "requirement analysis:\nThe original requirement is to return ordered unique shared elements for two lists. The current implementation using 'set1' does not directly address the requirement to return ordered unique shared elements. We need to implement the function to achieve this.\nrequirement pool:\n- Implement the function to return ordered unique shared elements for two lists\n- Ensure the function handles edge cases and large lists efficiently\n- Optimize the function for performance\n- Test the function with various inputs to ensure correctness\n- Document the function and provide examples of usage\nTo implement the function that returns ordered unique shared elements for two lists, we will use Python's built-in set operations for efficiency and then convert the result to a list to maintain order. This approach leverages Python's strengths in data manipulation and ensures the function is both efficient and easy to understand.\nPlease read and understand the following inteperation before coding\n It seems like your last prompt was cut off. However, based on the previous examples, I can help you analyze the coding plan and requirement for any given prompt. Please provide the specific requirement and plan you would like analyzed, and I will follow the format you've outlined to give you a detailed analysis.\n", "requirement analysis:\nThe original requirement specifies a function that returns shared elements from two lists, ordered and unique. The function currently only includes a placeholder 'set1', which needs to be replaced with actual logic. The requirement also includes example test cases to demonstrate expected behavior.\nrequirement pool:\n- Implement the function to return ordered unique shared elements for two lists\n- Ensure the function handles edge cases such as empty lists or lists with no common elements\n- Optimize the function for performance, especially for large lists\n- Include detailed documentation and comments for easy understanding and maintenance\n- Test the function with various inputs to ensure correctness and robustness\nTo implement the function that returns ordered unique shared elements for two lists, we will use Python's built-in set operations for efficiency. We will convert the lists to sets to find the intersection, then convert the result back to a list to maintain order and remove duplicates. This approach ensures both uniqueness and order of the shared elements.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'unique shared elements': means that the elements that appear in both lists and should not have duplicates.\n    'ordered': means that the result should maintain the order of the first occurrence in the original lists.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Convert both lists to sets to find the intersection.\n    Convert the intersection result back to a list to maintain order and remove duplicates.\n\n# [edge case] \n    common([1, 2, 3], [4, 5, 6]) = []\n    explanation: There are no common elements between the two lists, so the expected output is an empty list.\n    common([1, 2, 2, 3], [2, 2, 4, 5]) = [2]\n    explanation: The number 2 appears in both lists, but since we need unique shared elements and it appears twice in the first list, only one instance should be included in the result.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic already ensures that duplicates are removed and the order is maintained.\n", "requirement analysis:\nThe original requirement specifies a function that returns shared elements from two lists. The function should return unique elements and maintain the order of their first appearance in the lists. The requirement is clear and straightforward, focusing on functionality and efficiency.\nrequirement pool:\n- Implement the function to return unique shared elements in order\n- Ensure the function works efficiently with large lists\n- Handle edge cases such as duplicates and empty lists\n- Optimize the function for performance\n- Include tests to verify the function's correctness\nTo implement the function efficiently and ensure it returns unique shared elements in order, we will use Python's built-in set operations combined with list comprehensions for clarity and simplicity. This approach leverages Python's performance characteristics and standard library functions to achieve the desired functionality.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'unique shared elements'\n    In the requirement, it means that we need to find elements that are present in both lists and ensure the result contains only unique elements, maintaining the order of their first appearance in either list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests using set operations to find common elements and then converting the result back to a list to maintain order. Here's a detailed logic:\n    1. Convert both lists to sets to remove duplicates and enable set operations.\n    2. Use the intersection operation to find common elements.\n    3. Convert the resulting set back to a list to maintain the order of elements as they appear in either list.\n    4. Return the final list of common elements.\n\n# [edge case] \n    common([1, 2, 3], [4, 5, 6]) = []\n    Explanation: There are no common elements between the two lists, so the expected output is an empty list.\n    common([1, 2, 2, 3], [2, 2, 4, 5]) = [2]\n    Explanation: The number 2 is the only common element, and it should appear once in the result since we need unique shared elements.\n    common([], [1, 2, 3]) = []\n    Explanation: If one of the lists is empty, there can be no common elements, so the expected output is an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic already covers cases where one or both lists are empty, as well as cases with no common elements.\n", "requirement analysis:\nThe requirement is to create a function that returns ordered unique shared elements between two lists. This function should be efficient and easy to use, suitable for both developers and users who need to find common elements in their data.\nrequirement pool:\n- The function should return unique shared elements from two lists.\n- The function should return the elements in an ordered list.\n- The function should be efficient in terms of time and space complexity.\n- The function should handle edge cases such as empty lists or lists with non-hashable elements.\nTo create a function that returns ordered unique shared elements between two lists, we will use Python's built-in set operations for efficiency and simplicity. We will convert the lists to sets to find the intersection, then convert the result back to a list to ensure uniqueness and order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'unique shared elements': means elements that are present in both lists and appear only once in the combined result.\n    'ordered': means the result should maintain the order of the first occurrence in the original lists.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Convert both lists to sets to find the intersection.\n    - Convert the intersection result back to a list to ensure uniqueness and order.\n    - Return the final list of common elements.\n\n# [edge case] \n    common([1, 2, 3], [4, 5, 6]) = []\n    explanation: There are no common elements between the two lists, so the expected output is an empty list.\n    common([1, 2, 2, 3], [2, 2, 4, 5]) = [2]\n    explanation: The number 2 is the only common element, and it appears only once in the combined result.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic will return an empty list if there are no common elements.\n\n# [core concept]\n    'positive': means that all integers in the list are greater than 0.\n    'at least as many times': means the frequency of an integer in the list is greater than or equal to the integer itself.\n\n# [phrase showing quantity relationship]\n    'more than': means we need to find integers greater than 0.\n    'at least as many times': means we need to find integers whose frequency in the list is greater than or equal to the integer itself.\n\n# [degree adverb] \n    'largest': means we need to find the largest integer that meets the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Create a dictionary to store the frequency of each integer in the list.\n    - Iterate through the list and update the frequency in the dictionary.\n    - Iterate through the dictionary to find the largest integer that meets the condition.\n    - Return the result or -1 if no such integer exists.\n\n# [edge case] \n    search([2, 2, 3, 3, 3]) = 3\n    explanation: Both 2 and 3 appear more than or equal to their values, but 3 is the largest number.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their values, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the condition.\n\n# [core concept]\n    'ordered unique shared elements': means elements that are present in both lists, appear only once in the combined result, and the order should be maintained from the original lists.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Convert both lists to sets to find the intersection.\n    - Convert the intersection result back to a list to ensure uniqueness and order.\n    - Return the final list of common elements.\n\n# [edge case] \n    common([1, 2, 3], [4, 5, 6]) = []\n    explanation: There are no common elements between the two lists, so the expected output is an empty list.\n    common([1, 2, 2, 3], [2, 2, 4, 5]) = [2]\n    explanation: The number 2 is the only common element, and it appears only once in the combined result.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic will return an empty list if there are no common elements.\n", "requirement analysis:\nThe original requirements specify a function that takes two lists and returns a list of unique, shared elements from both lists, ordered. This function is essential for scenarios where users need to identify common elements between two lists efficiently.\nrequirement pool:\n- Implement the function to return unique shared elements.\n- Ensure the function returns elements in an ordered list.\n- Optimize the function for performance to handle large datasets.\n- Include options for customizing the order of returned elements.\n- Add functionality to handle edge cases such as empty lists or lists with non-comparable elements.\nTo implement the function efficiently and ensure it returns unique, shared elements from two lists in an ordered manner, we will use Python's built-in data structures and set operations. The function will first convert the lists to sets to eliminate duplicates and then use set intersection to find common elements. Finally, we will convert the result back to a list and sort it to maintain the order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'unique shared elements': means elements that are present in both lists and do not repeat.\n    'ordered': means the result should maintain the original order of the first occurrence in the lists.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Convert both lists to sets to remove duplicates.\n    - Find the intersection of these sets to get common elements.\n    - Convert the intersection result back to a list.\n    - Sort the list to maintain the order of the first occurrence.\n\n# [edge case] \n    common([1, 2, 3], [4, 5, 6]) = []\n    explanation: There are no common elements between the two lists, so the expected output is an empty list.\n    common([1, 2, 2, 3], [2, 2, 4, 5]) = [2]\n    explanation: The number 2 is the only common element, and it should appear in the result as it is the first occurrence in the first list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic will return an empty list when there are no common elements.\n", "requirement analysis:\nThe original requirements specify a function that takes two lists and returns a list of common elements that are unique to both lists. The function should be efficient and handle basic list operations. The requirements are clear and straightforward, focusing on functionality and performance.\nrequirement pool:\n- Implement the function to return unique shared elements from two lists.\n- Ensure the function returns elements in an ordered list.\n- Optimize the function for performance to handle large lists efficiently.\n- Include error handling for non-list inputs.\n- Add documentation and examples to guide users.\nTo implement the function efficiently and ensure it handles basic list operations, we will use Python's built-in data structures and set operations. The function will convert the lists to sets to find the intersection, then convert the result back to a list to maintain order and ensure uniqueness.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'unique shared elements': means the elements that are present in both lists and should not have duplicates.\n    'ordered': means the result should maintain the order of the first occurrence in each list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Convert both lists to sets to find the intersection.\n    - Convert the intersection result back to a list to maintain order and uniqueness.\n\n# [edge case] \n    common([1, 2, 3], [4, 5, 6]) = []\n    Explanation: There are no common elements between the two lists, so the expected output is an empty list.\n    common([], [1, 2, 3]) = []\n    Explanation: If one of the lists is empty, there can be no common elements, so the expected output is an empty list.\n    common([1, 2, 2, 3], [2, 2, 4, 5]) = [2]\n    Explanation: The number 2 is the only common element, and it should appear in the result as it is the first occurrence in the first list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic can handle cases where one or both lists are empty by returning an empty list.\n", "requirement analysis:\nThe original requirements specify a function that takes two lists and returns a list of common elements. The function should return unique elements and the order of elements should be maintained. This aligns with standard practices for list operations in Python.\nrequirement pool:\n- The function should return a list of unique shared elements from two input lists.\n- The function should maintain the order of elements as they appear in the input lists.\n- The function should handle edge cases such as empty lists or lists with non-unique elements.\n- The function should be optimized for performance, especially for large lists.\nWe will use Python's built-in set operations to efficiently find common elements between two lists. To ensure the function returns unique elements and maintains the order, we will convert the result back to a list. This approach leverages Python's strengths in set operations and list handling.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'unique shared elements': means the elements that appear in both lists and no duplicates.\n    'ordered': means the result should maintain the order of first appearance in either of the lists.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship.\n\n# [degree adverb] \n    No degree adverb.\n\n# [code logic]\n    To implement the function `common(l1, l2)`, we can follow these steps:\n    1. Convert both lists to sets to remove duplicates and facilitate set operations.\n    2. Use the intersection operation to find common elements.\n    3. Convert the result back to a list to maintain the order of first appearance.\n    4. Return the resulting list.\n\n# [edge case] \n    common([1, 2, 3], [4, 5, 6]) = []\n    Explanation: There are no common elements between the two lists, so the expected output is an empty list.\n    common([1, 1, 2, 2], [2, 2, 3, 3]) = [2]\n    Explanation: The number 2 is the only common element, and it should appear in the result list once.\n    common([], [1, 2, 3]) = []\n    Explanation: If one of the lists is empty, there can be no common elements, so the expected output is an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic already correctly handles empty lists by returning an empty list immediately.\n"], "scores": [0.75, 0.95, 0.95, 1.0, 0.95, 0.75, 0.75, 0.91, 0.75, 0.95], "pass_results": [false, false, false, true, false, false, false, false, false, false], "pass_test_cases_num": [75, 95, 95, 100, 95, 75, 75, 91, 75, 95], "completion": "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    '''Return ordered unique shared elements for two lists.\n    Args:\n        l1 (list): The first list of elements.\n        l2 (list): The second list of elements.\n    Returns:\n        list: A list of unique shared elements in the order they appear in the input lists.\n    '''\n    # Convert lists to sets to remove duplicates and facilitate set operations\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Use the intersection operation to find common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the result back to a list to maintain the order of first appearance\n    result = list(common_elements)\n    \n    return result\n", "passed": true, "pass": true, "pass_num": 1, "round": 46, "repair_prompt": ["def common(l1: list, l2: list):\t\n'''Return ordered unique shared elements for two lists.\n>>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    '''", " def common(l1: list, l2: list):\n    '''Return ordered unique shared elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    '''\n    set1", " def common(l1: list, l2: list):\n    '''Return ordered unique shared elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    '''\n"], "mutate_method": "rephrase_one", "parent_index": 46}
