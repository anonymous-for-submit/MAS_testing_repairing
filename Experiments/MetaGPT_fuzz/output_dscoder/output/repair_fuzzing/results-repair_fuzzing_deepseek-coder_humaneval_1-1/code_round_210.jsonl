{"task_id": "HumanEval/43", "prompt": "def pairs_sum_to_zero(l):\t\n'''pairs_sum_to_zero receives a list of integers as its input. it returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n>>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    '''", "entry_point": "pairs_sum_to_zero", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "test": ["def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 11, -3, 6, 7, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 7, -4, 1, 1, 11]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 11, 0, 3, 6, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 14, 0, 5, 2, 34]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 2, 3, 7]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 2, 9, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 9, -1, 4, 2, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 14, 1, 8, 6, 36]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 9, 0, 8, 5, 9]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 4, -6, 7, 1, 32]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 8, -2, 3]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-2, 10, 0, 6, 5, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 1, -2, 2]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 2, -1, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 4, -2, 5, 5, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 5, -3, 3]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 3, -4, 5]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-2, 4, -5, 4, 1, 25]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 6, -4, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 5, 2, 4, 1, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 14, 0, 1, 7, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 8, -5, 3, 7, 35]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 9, -9, 2, 7, 11]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 7, -1, 2, 1, 28]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 9, -1, 3, 2, 31]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 6, -7, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 9, 2, 3, 4, 30]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 6, 1, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 1, 3, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 5, 8, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 7, 2, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 8, 10, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 13, -5, 7, 7, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 5, -10, 2, 10, 9]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 3, 1, 8]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 7, 4, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 9, -5, 4, 6, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 6, 2, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 2, 1, 11]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 2, 7, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 5, 2, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 14, -2, 8, 2, 35]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 3, 5, 0]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 8, 4, 3, 7, 29]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 12, 1, 9, 6, 33]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 11, 1, 6, 6, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 11, -3, 8, 7, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 10, -4, 8, 6, 26]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 3, 7, 1]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 1, -4, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-2, 12, -4, 7, 1, 36]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 12, 1, 6, 7, 25]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 11, -3, 6, 2, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 13, -2, 7, 3, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 4, -10, 5, 10, 9]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 1, 3, 7]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 8, 2, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 14, 2, 4, 6, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 5, 1, 12]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 9, -1, 3, 2, 30]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 5, -6, 8, 1, 33]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 3, 7, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 14, -6, 5, 1, 35]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 4, -1, 5, 10, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 13, -2, 4, 4, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 2, 6, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 4, -1, 5, 3, 33]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 3, 1, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([7, 5, -1, 1, 8, 10]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 3, 4, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 7, 3, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 12, -3, 2, 6, 29]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 9, -3, 6, 7, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 7, -9, 5, 4, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 6, 0, 6, 3, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 7, 8, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 4, -1, 8, 8, 12]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 8, 1, 1, 6, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-6, 14, 1, 8, 2, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 6, -5, 7, 7, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 4, -7, 1, 2, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 11, -6, 5, 7, 36]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 14, 0, 5, 1, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 9, -1, 7, 4, 34]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 3, 3, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 10, 2, 9, 3, 33]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 4, 1, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 9, -1, 4, 2, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 3, -2, 1]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 10, -2, 2, 4, 33]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 9, -8, 6, 2, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-6, 7, -4, 4, 2, 32]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 4, 10, 1]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([7, 8, -10, 7, 2, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-6, 8, 0, 4, 5, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-6, 14, -4, 5, 6, 32]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 12, 1, 8, 6, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 12, -6, 6, 7, 29]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 5, 1, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 8, -4, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 2, 1, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 4, 3, 6, 2, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 11, -4, 3, 5, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 9, 2, 1, 6, 34]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 13, -4, 6, 3, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 1, 0, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 5, -2, 3, 1, 32]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 5, -1, 8, 8, 4]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 2, 2, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 8, 1, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 6, 2, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 14, 3, 6, 2, 29]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 13, -2, 8, 7, 35]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 1, 3, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 8, -1, 7, 6, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 12, 0, 1, 7, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 3, 6, 7]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 6, -8, 1, 2, 8]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 8, -3, 9, 5, 29]) == False"], "test_case_list": ["assert pairs_sum_to_zero([1, 11, -3, 6, 7, 30]) == False", "assert pairs_sum_to_zero([3, 7, -4, 1, 1, 11]) == False", "assert pairs_sum_to_zero([-8, 11, 0, 3, 6, 26]) == False", "assert pairs_sum_to_zero([1, 14, 0, 5, 2, 34]) == False", "assert pairs_sum_to_zero([1, 2, 3, 7]) == False", "assert pairs_sum_to_zero([4, 2, 9, 3]) == False", "assert pairs_sum_to_zero([-3, 9, -1, 4, 2, 31]) == False", "assert pairs_sum_to_zero([3]) == False", "assert pairs_sum_to_zero([-1, 14, 1, 8, 6, 36]) == True", "assert pairs_sum_to_zero([3, 9, 0, 8, 5, 9]) == False", "assert pairs_sum_to_zero([1, 4, -6, 7, 1, 32]) == False", "assert pairs_sum_to_zero([2, 8, -2, 3]) == True", "assert pairs_sum_to_zero([-2, 10, 0, 6, 5, 30]) == False", "assert pairs_sum_to_zero([3, 1, -2, 2]) == True", "assert pairs_sum_to_zero([3, 2, -1, 2]) == False", "assert pairs_sum_to_zero([-1, 4, -2, 5, 5, 27]) == False", "assert pairs_sum_to_zero([1]) == False", "assert pairs_sum_to_zero([6, 5, -3, 3]) == True", "assert pairs_sum_to_zero([4, 3, -4, 5]) == True", "assert pairs_sum_to_zero([-2, 4, -5, 4, 1, 25]) == False", "assert pairs_sum_to_zero([2, 6, -4, 5]) == False", "assert pairs_sum_to_zero([-7, 5, 2, 4, 1, 26]) == False", "assert pairs_sum_to_zero([-8, 14, 0, 1, 7, 30]) == False", "assert pairs_sum_to_zero([1, 8, -5, 3, 7, 35]) == False", "assert pairs_sum_to_zero([6, 9, -9, 2, 7, 11]) == True", "assert pairs_sum_to_zero([-8, 7, -1, 2, 1, 28]) == True", "assert pairs_sum_to_zero([-3, 9, -1, 3, 2, 31]) == True", "assert pairs_sum_to_zero([6, 6, -7, 6]) == False", "assert pairs_sum_to_zero([-4, 9, 2, 3, 4, 30]) == True", "assert pairs_sum_to_zero([1, 6, 1, 2]) == False", "assert pairs_sum_to_zero([5, 1, 3, 5]) == False", "assert pairs_sum_to_zero([4, 5, 8, 3]) == False", "assert pairs_sum_to_zero([6, 7, 2, 5]) == False", "assert pairs_sum_to_zero([2, 8, 10, 3]) == False", "assert pairs_sum_to_zero([1, 13, -5, 7, 7, 27]) == False", "assert pairs_sum_to_zero([4, 5, -10, 2, 10, 9]) == True", "assert pairs_sum_to_zero([2, 3, 1, 8]) == False", "assert pairs_sum_to_zero([1, 7, 4, 6]) == False", "assert pairs_sum_to_zero([2, 9, -5, 4, 6, 30]) == False", "assert pairs_sum_to_zero([4, 6, 2, 4]) == False", "assert pairs_sum_to_zero([5, 2, 1, 11]) == False", "assert pairs_sum_to_zero([5, 2, 7, 3]) == False", "assert pairs_sum_to_zero([5, 5, 2, 2]) == False", "assert pairs_sum_to_zero([-8, 14, -2, 8, 2, 35]) == True", "assert pairs_sum_to_zero([1, 3, 5, 0]) == False", "assert pairs_sum_to_zero([-1, 8, 4, 3, 7, 29]) == False", "assert pairs_sum_to_zero([2, 12, 1, 9, 6, 33]) == False", "assert pairs_sum_to_zero([-4, 11, 1, 6, 6, 28]) == False", "assert pairs_sum_to_zero([0, 11, -3, 8, 7, 26]) == False", "assert pairs_sum_to_zero([-8, 10, -4, 8, 6, 26]) == True", "assert pairs_sum_to_zero([2]) == False", "assert pairs_sum_to_zero([2, 3, 7, 1]) == False", "assert pairs_sum_to_zero([6, 1, -4, 6]) == False", "assert pairs_sum_to_zero([-2, 12, -4, 7, 1, 36]) == False", "assert pairs_sum_to_zero([2, 12, 1, 6, 7, 25]) == False", "assert pairs_sum_to_zero([-4, 11, -3, 6, 2, 27]) == False", "assert pairs_sum_to_zero([0, 13, -2, 7, 3, 31]) == False", "assert pairs_sum_to_zero([1, 4, -10, 5, 10, 9]) == True", "assert pairs_sum_to_zero([4, 1, 3, 7]) == False", "assert pairs_sum_to_zero([6, 8, 2, 5]) == False", "assert pairs_sum_to_zero([-7, 14, 2, 4, 6, 30]) == False", "assert pairs_sum_to_zero([1, 5, 1, 12]) == False", "assert pairs_sum_to_zero([-3, 9, -1, 3, 2, 30]) == True", "assert pairs_sum_to_zero([-1, 5, -6, 8, 1, 33]) == True", "assert pairs_sum_to_zero([2, 3, 7, 4]) == False", "assert pairs_sum_to_zero([0, 14, -6, 5, 1, 35]) == False", "assert pairs_sum_to_zero([5, 4, -1, 5, 10, 6]) == False", "assert pairs_sum_to_zero([0, 13, -2, 4, 4, 28]) == False", "assert pairs_sum_to_zero([2, 2, 6, 4]) == False", "assert pairs_sum_to_zero([0, 4, -1, 5, 3, 33]) == False", "assert pairs_sum_to_zero([3, 3, 1, 4]) == False", "assert pairs_sum_to_zero([7, 5, -1, 1, 8, 10]) == True", "assert pairs_sum_to_zero([1, 3, 4, 3]) == False", "assert pairs_sum_to_zero([5, 7, 3, 4]) == False", "assert pairs_sum_to_zero([-7, 12, -3, 2, 6, 29]) == False", "assert pairs_sum_to_zero([-4, 9, -3, 6, 7, 31]) == False", "assert pairs_sum_to_zero([4, 7, -9, 5, 4, 6]) == False", "assert pairs_sum_to_zero([-4, 6, 0, 6, 3, 26]) == False", "assert pairs_sum_to_zero([4]) == False", "assert pairs_sum_to_zero([2, 7, 8, 5]) == False", "assert pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) == True", "assert pairs_sum_to_zero([1, 4, -1, 8, 8, 12]) == True", "assert pairs_sum_to_zero([-3, 8, 1, 1, 6, 31]) == False", "assert pairs_sum_to_zero([-6, 14, 1, 8, 2, 28]) == False", "assert pairs_sum_to_zero([-3, 6, -5, 7, 7, 30]) == False", "assert pairs_sum_to_zero([3, 4, -7, 1, 2, 3]) == False", "assert pairs_sum_to_zero([-8, 11, -6, 5, 7, 36]) == False", "assert pairs_sum_to_zero([-7, 14, 0, 5, 1, 28]) == False", "assert pairs_sum_to_zero([-5, 9, -1, 7, 4, 34]) == False", "assert pairs_sum_to_zero([1, 3, 3, 5]) == False", "assert pairs_sum_to_zero([-5, 10, 2, 9, 3, 33]) == False", "assert pairs_sum_to_zero([2, 4, 1, 2]) == False", "assert pairs_sum_to_zero([-3, 9, -1, 4, 2, 30]) == False", "assert pairs_sum_to_zero([1, 3, -2, 1]) == False", "assert pairs_sum_to_zero([2, 10, -2, 2, 4, 33]) == True", "assert pairs_sum_to_zero([3, 9, -8, 6, 2, 5]) == False", "assert pairs_sum_to_zero([-6, 7, -4, 4, 2, 32]) == True", "assert pairs_sum_to_zero([3, 4, 10, 1]) == False", "assert pairs_sum_to_zero([7, 8, -10, 7, 2, 4]) == False", "assert pairs_sum_to_zero([-6, 8, 0, 4, 5, 27]) == False", "assert pairs_sum_to_zero([-6, 14, -4, 5, 6, 32]) == True", "assert pairs_sum_to_zero([-5, 12, 1, 8, 6, 31]) == False", "assert pairs_sum_to_zero([-3, 12, -6, 6, 7, 29]) == True", "assert pairs_sum_to_zero([1, 5, 1, 3]) == False", "assert pairs_sum_to_zero([5, 8, -4, 5]) == False", "assert pairs_sum_to_zero([3, 2, 1, 6]) == False", "assert pairs_sum_to_zero([-5, 4, 3, 6, 2, 27]) == False", "assert pairs_sum_to_zero([-1, 11, -4, 3, 5, 28]) == False", "assert pairs_sum_to_zero([-7, 9, 2, 1, 6, 34]) == False", "assert pairs_sum_to_zero([-1, 13, -4, 6, 3, 28]) == False", "assert pairs_sum_to_zero([6, 1, 0, 3]) == False", "assert pairs_sum_to_zero([-5, 5, -2, 3, 1, 32]) == True", "assert pairs_sum_to_zero([1, 5, -1, 8, 8, 4]) == True", "assert pairs_sum_to_zero([1, 2, 2, 2]) == False", "assert pairs_sum_to_zero([6]) == False", "assert pairs_sum_to_zero([2, 8, 1, 4]) == False", "assert pairs_sum_to_zero([2, 6, 2, 5]) == False", "assert pairs_sum_to_zero([2, 14, 3, 6, 2, 29]) == False", "assert pairs_sum_to_zero([-5, 13, -2, 8, 7, 35]) == False", "assert pairs_sum_to_zero([6, 1, 3, 2]) == False", "assert pairs_sum_to_zero([5]) == False", "assert pairs_sum_to_zero([-4, 8, -1, 7, 6, 26]) == False", "assert pairs_sum_to_zero([-4, 12, 0, 1, 7, 28]) == False", "assert pairs_sum_to_zero([5, 3, 6, 7]) == False", "assert pairs_sum_to_zero([4, 6, -8, 1, 2, 8]) == True", "assert pairs_sum_to_zero([-4, 8, -3, 9, 5, 29]) == False"], "nl": "\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    ", "func": "def pairs_sum_to_zero(l):", "examples": ">>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    ", "completions": ["from typing import List\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    '''\n    pairs_sum_to_zero receives a list of integers as its input. It returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n        False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n        False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n        False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n        True\n    >>> pairs_sum_to_zero([1])\n        False\n    '''\n    if len(l) < 2:\n        return False\n    \n    seen = set()\n    for num in l:\n        complement = -num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n", "from typing import List\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    '''\n    pairs_sum_to_zero receives a list of integers as its input.\n    It returns True if there are two distinct elements in the list that sum to zero,\n    and False otherwise.\n    '''\n    seen_numbers = set()\n    \n    for number in l:\n        complement = -number\n        if complement in seen_numbers:\n            return True\n        seen_numbers.add(number)\n    \n    return False\n", "from typing import List\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    '''\n    pairs_sum_to_zero receives a list of integers as its input.\n    It returns True if there are two distinct elements in the list that sum to zero,\n    and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n        False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n        False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n        False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n        True\n    >>> pairs_sum_to_zero([1])\n        False\n    '''\n    seen = set()\n    for num in l:\n        complement = -num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n", "from typing import List\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n", "from typing import List\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    '''\n    pairs_sum_to_zero receives a list of integers as its input. It returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n        False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n        True\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n        False\n    '''\n    seen = set()\n    for number in l:\n        complement = 0 - number\n        if complement in seen:\n            return True\n        seen.add(number)\n    return False\n", "from typing import List\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    '''\n    pairs_sum_to_zero receives a list of integers as its input.\n    It returns True if there are two distinct elements in the list that sum to zero,\n    and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n        False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n        True\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n        False\n    '''\n    seen = set()\n    for num in l:\n        complement = -num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n", "from typing import List\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n", "from typing import List\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n", "from typing import List\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n", "from typing import List\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n"], "plans": ["requirement analysis:\nThe requirement is to check if there are two distinct elements in a list that sum to zero. This is a common problem in algorithmic challenges and should be approached with a focus on efficiency and clarity. The function should handle various edge cases, such as lists with a single element or no elements that sum to zero.\nrequirement pool:\n- The function should return False if the list has fewer than two elements.\n- The function should return True if there are two distinct elements that sum to zero.\n- The function should be optimized for performance, especially for large lists.\n- The function should be well-documented and easy to understand.\nTo implement the function efficiently, we will use a set to keep track of the elements we have seen so far. This allows us to check in constant time whether the complement of the current element (i.e., -current_element) exists in the set. This approach ensures that we only traverse the list once, making the function O(n) in time complexity, where n is the number of elements in the list. We will also handle edge cases such as lists with fewer than two elements by returning False immediately.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'sum to zero': means the two numbers in the pair should add up to 0\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (1) Iterate through the list of integers.\n    (2) For each integer, calculate its complement (i.e., -integer).\n    (3) Check if the complement exists in the set of seen integers.\n    (4) If it exists, return True.\n    (5) If the loop completes without finding such a pair, return False.\n\n# [edge case] \n    pairs_sum_to_zero([1]) = False\n    Explanation: The list contains only one element, so it's impossible to find a pair that sums to zero.\n    pairs_sum_to_zero([1, 3, -2, 1]) = False\n    Explanation: Although the list contains negative numbers, there are no two distinct elements that sum to zero.\n    pairs_sum_to_zero([1, 2, 3, 7]) = False\n    Explanation: No two distinct elements in the list sum to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic already correctly handles lists with fewer than two elements by returning False immediately.\n", "requirement analysis:\nThe requirement is to check if there are two distinct elements in the list that sum to zero. This is a straightforward problem that can be solved efficiently using a set to track the complements of each element.\nrequirement pool:\n- The function should return False if the list has fewer than two elements.\n- The function should return True if there are two distinct elements that sum to zero.\n- The function should be optimized for performance, especially for large lists.\n- The function should handle edge cases, such as lists with all elements being the same.\nTo solve the problem of checking if there are two distinct elements in the list that sum to zero, we can use a set to track the complements of each element. This approach ensures that we can check for the existence of the complement in constant time, making the solution efficient. We will iterate through the list, calculate the complement for each element, and check if the complement exists in the set. If it does, we return True. If we finish iterating through the list without finding such a pair, we return False.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'distinct elements': means that the two elements in the list must be different\n    'sum to zero': means the sum of the two elements should be 0\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (1) Iterate through the list of integers.\n    (2) For each integer, calculate its complement (i.e., -integer).\n    (3) Check if the complement exists in the set of seen numbers.\n    (4) If the complement exists, return True.\n    (5) If the iteration completes without finding such a pair, return False.\n\n# [edge case] \n    pairs_sum_to_zero([1]) = False\n    Explanation: There is only one element in the list, so it's impossible to find two distinct elements that sum to zero.\n    pairs_sum_to_zero([1, 3, -2, 1]) = False\n    Explanation: There are no two distinct elements that sum to zero. The pair (1, -1) exists, but they are not distinct.\n    pairs_sum_to_zero([1, 2, 3, 7]) = False\n    Explanation: There are no two distinct elements that sum to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic already correctly handles the case where the list has only one element.\n", "requirement analysis:\nThe original requirements specify a function that checks if there are two distinct elements in a list that sum to zero. This is a straightforward problem that can be solved efficiently using a set to track the complements of each number. The function should handle edge cases such as an empty list, a list with one element, and lists with no pairs summing to zero.\nrequirement pool:\n- The main code should efficiently check for pairs summing to zero.\n- The function should handle edge cases effectively.\n- Ensure the function is easy to understand and maintain.\n- Optimize the function for performance.\n- Consider adding comments and docstrings for better readability.\nWe will use a set to efficiently check for pairs summing to zero. The function will iterate through the list, calculate the complement of each number (i.e., -number), and check if this complement is already in the set. If it is, the function returns True. If the loop completes without finding such a pair, the function returns False. This approach ensures that the function is both efficient and easy to understand.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'distinct pairs summing to zero': means finding two different elements in the list that add up to zero.\n    Explanation: This is a specific requirement where we need to check if there are any two unique elements in the list that sum to zero.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship.\n\n# [degree adverb] \n    No degree adverb.\n\n# [code logic]\n    The plan suggests using a set to efficiently check for pairs summing to zero. The function will iterate through the list, calculate the complement of each number (i.e., -number), and check if this complement is already in the set. If it is, the function returns True. If the loop completes without finding such a pair, the function returns False.\n\n# [edge case] \n    pairs_sum_to_zero([1, 2, -1, -2]) = True\n    Explanation: The list contains the distinct pair (1, -1) and (-2, 2) which both sum to zero.\n    pairs_sum_to_zero([0, 0, 0]) = False\n    Explanation: All elements are zero, so no pair sums to zero.\n    pairs_sum_to_zero([]) = False\n    Explanation: The list is empty, so there are no pairs to sum.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the case of an empty list.\n", "requirement analysis:\nThe original requirements specify a function that checks if there are two distinct elements in a list that sum to zero. This is a straightforward problem that can be solved efficiently using a set to track seen numbers and check for complements.\nrequirement pool:\n- Implement the function pairs_sum_to_zero with a time complexity of O(n).\n- Ensure the function handles edge cases such as empty lists and lists with all identical elements.\n- Optimize the function for readability and maintainability.\nTo implement the function pairs_sum_to_zero efficiently, we will use a set to track the numbers we've seen so far. For each number in the list, we will check if its complement (i.e., the number that, when added to the current number, equals zero) has already been seen. If we find such a pair, we return True. If we finish iterating through the list without finding such a pair, we return False. This approach ensures that we only pass through the list once, achieving a time complexity of O(n).\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'distinct elements': means that the two elements in the list must be different\n    'sum to zero': means that the sum of the two elements must be 0\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Iterate through the list and use a set to track the numbers we've seen so far. For each number, check if its complement (i.e., the number that, when added to the current number, equals zero) has already been seen. If we find such a pair, return True. If we finish iterating through the list without finding such a pair, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0, 0, 0]) = False\n    Explanation: There are no two distinct elements in the list that sum to zero.\n    pairs_sum_to_zero([-1, 1]) = True\n    Explanation: The elements -1 and 1 are distinct and their sum is zero.\n    pairs_sum_to_zero([2, -2, 3, 4]) = True\n    Explanation: The elements -2 and 2 are distinct and their sum is zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic will correctly handle the case where all elements are zero, as it will not find any pair that sums to zero.\n", "requirement analysis:\nThe requirement is to check if there are two distinct elements in a list that sum to zero. This is a basic problem that can be solved using a straightforward approach. The function should return True if such a pair exists and False otherwise.\nrequirement pool:\n- Implement a function that checks for pairs summing to zero\n- Ensure the function works efficiently for all inputs\n- Make the code easy to understand and maintain\n- Test the function with various edge cases\n- Optimize the algorithm for performance\nTo implement the function `pairs_sum_to_zero`, we will use a straightforward approach that leverages the properties of sets to efficiently check for pairs that sum to zero. This method avoids the inefficiencies of nested loops and ensures that the function is both simple and performant.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'distinct elements': means that the two elements in the list should be different\n    'sum to zero': means the sum of the two elements should be 0\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Iterate through the list and use a set to keep track of the elements we have seen so far. For each element, check if the negation of that element (to find a pair that sums to zero) is already in the set. If it is, return True. If the loop completes without finding such a pair, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0, 0, 0]) = False\n    Explanation: There are no two distinct elements in the list that sum to zero.\n    pairs_sum_to_zero([-1, 1]) = True\n    Explanation: The elements -1 and 1 are distinct and their sum is 0.\n    pairs_sum_to_zero([1, 2, 3, 4]) = False\n    Explanation: There are no two distinct elements in the list that sum to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic already correctly handles the case where all elements are zero, as it will not find any distinct pair that sums to zero.\n", "requirement analysis:\nThe requirement is to check if there are any two distinct elements in the list that sum to zero. This is a basic requirement that can be efficiently implemented using a set to track the complements of each element.\nrequirement pool:\n- Implement the function pairs_sum_to_zero with a time complexity of O(n).\n- Ensure the function handles edge cases such as empty lists and lists with all identical elements.\n- Include clear docstrings and comments to explain the code.\n- Optimize the function for performance to handle large lists efficiently.\n- Test the function with various inputs to ensure it works correctly.\nTo implement the function pairs_sum_to_zero efficiently, we will use a set to track the complements of each element. This approach ensures that we can check for pairs in linear time, O(n). We will iterate through the list, calculate the complement of each element (i.e., -element), and check if this complement is already in the set. If it is, we return True. If we finish the iteration without finding such a pair, we return False. This method handles the requirement effectively and optimizes for performance.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'distinct elements': means that the two elements in the list must be different\n    'sum to zero': means the sum of the two elements should be 0\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Iterate through the list and use a set to track the complements of each element.\n    For each element, calculate its complement (i.e., -element) and check if it is already in the set.\n    If a complement is found, return True.\n    If the iteration completes without finding such a pair, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0, 0, 0]) = True\n    Explanation: There are two distinct elements (0 and 0) that sum to zero.\n    pairs_sum_to_zero([1, -1]) = True\n    Explanation: There are two distinct elements (1 and -1) that sum to zero.\n    pairs_sum_to_zero([2, 3, 4]) = False\n    Explanation: There are no two distinct elements in the list that sum to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic will correctly handle the case where all elements are zero or there are no elements that sum to zero.\n", "requirement analysis:\nThe requirement is to check if there are any two distinct elements in the list that sum to zero. This is a basic requirement that can be efficiently implemented using a set to track seen numbers and check for complements.\nrequirement pool:\n- Implement the function pairs_sum_to_zero with a time complexity of O(n).\n- Ensure the function handles edge cases such as empty lists and lists with all identical elements.\n- Make the code readable and maintainable for future enhancements.\nTo implement the function pairs_sum_to_zero efficiently, we will use a set to track the numbers we have seen so far. For each number in the list, we will check if its complement (i.e., the number that, when added to the current number, equals zero) has already been seen. If we find such a pair, we return True. If we finish iterating through the list without finding such a pair, we return False. This approach ensures that we only pass through the list once, achieving a time complexity of O(n).\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'sum to zero': means the two numbers in the pair should add up to 0.\n    'distinct elements': means the two numbers in the pair should be different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Iterate through the list and use a set to keep track of the numbers seen so far. For each number, check if its complement (i.e., -number) is in the set. If it is, return True. If the loop completes without finding such a pair, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0, 0, 0]) = False\n    Explanation: There are no two distinct elements that sum to zero.\n    pairs_sum_to_zero([-1, 1]) = True\n    Explanation: The elements -1 and 1 sum to zero.\n    pairs_sum_to_zero([1, 2, 3, -3, -2]) = True\n    Explanation: The elements -3 and 3 sum to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic will correctly return False for the edge case where all elements are zero.\n", "requirement analysis:\nThe requirement is to check if there are two distinct elements in a list that sum to zero. This is a basic requirement that can be efficiently implemented using a straightforward approach. The function should be able to handle both positive and negative numbers and should be optimized for performance to handle large lists.\nrequirement pool:\n- Implement the function to check for pairs summing to zero\n- Ensure the function is optimized for performance\n- Provide clear documentation and examples\n- Test the function with various edge cases\n- Ensure the function works efficiently with large lists\nTo implement the function `pairs_sum_to_zero`, we will use a straightforward approach that leverages a set to keep track of the numbers we've seen so far. This method allows us to check for the complement of each number in constant time, making the function efficient even for large lists. We will ensure that the function is optimized for performance by avoiding unnecessary computations and leveraging Python's built-in data structures.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'sum to zero': means the two numbers in the list should add up to 0\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    pairs_sum_to_zero([1, -1]) = True\n    Explanation: There are two distinct elements in the list that sum to zero, which are 1 and -1.\n    pairs_sum_to_zero([2, 4, 3, -2]) = False\n    Explanation: No two distinct elements in the list sum to zero.\n    pairs_sum_to_zero([]) = False\n    Explanation: The list is empty, so there are no elements to form a pair that sums to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic will return False for an empty list.\n", "requirement analysis:\nThe requirement is to check if there are any two distinct elements in a list that sum to zero. This is a basic requirement that can be efficiently implemented using a set for quick lookups.\nrequirement pool:\n- Implement the function to check pairs summing to zero\n- Ensure the function is optimized for performance\n- Include clear documentation and examples\n- Ensure the function works correctly for both positive and negative numbers\n- Consider handling edge cases such as empty lists or lists with one element\nTo implement the function `pairs_sum_to_zero`, we will use a set to keep track of the numbers we have seen so far. This will allow us to check in constant time whether the complement of the current number (i.e., the number that, when added to the current number, equals zero) has already been seen. This approach ensures that the function is both simple and efficient.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'sum to zero': means the sum of two numbers in the list equals zero\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Iterate through the list and use a set to keep track of the numbers seen so far. For each number, check if its complement (i.e., -number) is in the set. If it is, return True. If the loop completes without finding such a pair, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0, 0, 0]) = False\n    Explanation: There are no two distinct elements in the list that sum to zero.\n    pairs_sum_to_zero([-1, 1]) = True\n    Explanation: The elements -1 and 1 sum to zero.\n    pairs_sum_to_zero([1, 2, 3, -3, 4, -4]) = True\n    Explanation: The elements -3 and 3, as well as -4 and 4, sum to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic will correctly return False for the edge case where all elements are zero.\n\n# [core concept]\n    'sum to zero': means the sum of two numbers in the list equals zero\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Iterate through the list and use a set to keep track of the numbers seen so far. For each number, check if its complement (i.e., -number) is in the set. If it is, return True. If the loop completes without finding such a pair, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0, 0, 0]) = False\n    Explanation: There are no two distinct elements in the list that sum to zero.\n    pairs_sum_to_zero([-1, 1]) = True\n    Explanation: The elements -1 and 1 sum to zero.\n    pairs_sum_to_zero([1, 2, 3, -3, 4, -4]) = True\n    Explanation: The elements -3 and 3, as well as -4 and 4, sum to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic will correctly return False for the edge case where all elements are zero.\n", "requirement analysis:\nThe requirement is to create a function that checks if there are two distinct elements in a list that sum to zero. The function should handle edge cases such as an empty list, a list with one element, and a list with no pair summing to zero. The function should be efficient and readable.\nrequirement pool:\n- The main code should correctly identify pairs that sum to zero.\n- The function should handle edge cases effectively.\n- The function should be optimized for performance.\n- The code should be well-documented and readable.\n- The function should be tested with various input sizes and edge cases.\nTo implement the function `pairs_sum_to_zero`, we will use a set to keep track of the numbers we have seen so far. This will allow us to check in constant time whether the complement of the current number (i.e., the number that, when added to the current number, equals zero) has already been seen. This approach ensures that the function is both efficient and easy to understand.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'sum to zero': means the two numbers in the list should add up to 0.\n    'distinct elements': means the two numbers should be different in the list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Iterate through the list and use a set to keep track of the numbers seen so far. For each number, check if its complement (i.e., -number) is in the set. If it is, return True. If the loop completes without finding such a pair, return False.\n\n# [edge case] \n    pairs_sum_to_zero([1]) = False\n    Explanation: There is only one number in the list, so it's impossible to find a pair that sums to zero.\n    pairs_sum_to_zero([0, 0]) = False\n    Explanation: The list contains two zeros, and they are not distinct. The sum of a number with itself is not zero.\n    pairs_sum_to_zero([-1, 1]) = True\n    Explanation: The list contains -1 and 1, which are distinct and sum to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic is sufficient to return False for a list with only one element.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [126, 126, 126, 126, 126, 126, 126, 126, 126, 126], "completion": "from typing import List\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n", "passed": true, "pass": true, "pass_num": 10, "round": 210, "repair_prompt": ["def pairs_sum_to_zero(l):\t\n'''pairs_sum_to_zero receives a list of integers as its input. it returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n>>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    '''", " def pairs_sum_to_zero(l):\n    '''pairs_sum_to_zero receives a list of integers as its input. it returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n        False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n        False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n        False\n   ", " def pairs_sum_to_zero(l):\n    '''pairs_sum_to_zero receives a list of integers as its input. it returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n   "], "mutate_method": "rephrase_one", "parent_index": 37}
