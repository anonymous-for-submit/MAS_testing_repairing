{"task_id": "HumanEval/43", "prompt": "def pairs_sum_to_zero(l):\t\n'''pairs_sum_to_zero takes a list of integers as an input. it returns True if there are two unique numbers in the list that add up to zero, and False otherwise.\n>>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    '''", "entry_point": "pairs_sum_to_zero", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "test": ["def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 11, -3, 6, 7, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 7, -4, 1, 1, 11]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 11, 0, 3, 6, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 14, 0, 5, 2, 34]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 2, 3, 7]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 2, 9, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 9, -1, 4, 2, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 14, 1, 8, 6, 36]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 9, 0, 8, 5, 9]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 4, -6, 7, 1, 32]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 8, -2, 3]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-2, 10, 0, 6, 5, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 1, -2, 2]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 2, -1, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 4, -2, 5, 5, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 5, -3, 3]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 3, -4, 5]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-2, 4, -5, 4, 1, 25]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 6, -4, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 5, 2, 4, 1, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 14, 0, 1, 7, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 8, -5, 3, 7, 35]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 9, -9, 2, 7, 11]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 7, -1, 2, 1, 28]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 9, -1, 3, 2, 31]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 6, -7, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 9, 2, 3, 4, 30]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 6, 1, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 1, 3, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 5, 8, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 7, 2, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 8, 10, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 13, -5, 7, 7, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 5, -10, 2, 10, 9]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 3, 1, 8]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 7, 4, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 9, -5, 4, 6, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 6, 2, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 2, 1, 11]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 2, 7, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 5, 2, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 14, -2, 8, 2, 35]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 3, 5, 0]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 8, 4, 3, 7, 29]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 12, 1, 9, 6, 33]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 11, 1, 6, 6, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 11, -3, 8, 7, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 10, -4, 8, 6, 26]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 3, 7, 1]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 1, -4, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-2, 12, -4, 7, 1, 36]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 12, 1, 6, 7, 25]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 11, -3, 6, 2, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 13, -2, 7, 3, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 4, -10, 5, 10, 9]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 1, 3, 7]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 8, 2, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 14, 2, 4, 6, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 5, 1, 12]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 9, -1, 3, 2, 30]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 5, -6, 8, 1, 33]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 3, 7, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 14, -6, 5, 1, 35]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 4, -1, 5, 10, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 13, -2, 4, 4, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 2, 6, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 4, -1, 5, 3, 33]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 3, 1, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([7, 5, -1, 1, 8, 10]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 3, 4, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 7, 3, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 12, -3, 2, 6, 29]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 9, -3, 6, 7, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 7, -9, 5, 4, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 6, 0, 6, 3, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 7, 8, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 4, -1, 8, 8, 12]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 8, 1, 1, 6, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-6, 14, 1, 8, 2, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 6, -5, 7, 7, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 4, -7, 1, 2, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 11, -6, 5, 7, 36]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 14, 0, 5, 1, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 9, -1, 7, 4, 34]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 3, 3, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 10, 2, 9, 3, 33]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 4, 1, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 9, -1, 4, 2, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 3, -2, 1]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 10, -2, 2, 4, 33]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 9, -8, 6, 2, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-6, 7, -4, 4, 2, 32]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 4, 10, 1]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([7, 8, -10, 7, 2, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-6, 8, 0, 4, 5, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-6, 14, -4, 5, 6, 32]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 12, 1, 8, 6, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 12, -6, 6, 7, 29]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 5, 1, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 8, -4, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 2, 1, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 4, 3, 6, 2, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 11, -4, 3, 5, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 9, 2, 1, 6, 34]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 13, -4, 6, 3, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 1, 0, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 5, -2, 3, 1, 32]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 5, -1, 8, 8, 4]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 2, 2, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 8, 1, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 6, 2, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 14, 3, 6, 2, 29]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 13, -2, 8, 7, 35]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 1, 3, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 8, -1, 7, 6, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 12, 0, 1, 7, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 3, 6, 7]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 6, -8, 1, 2, 8]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 8, -3, 9, 5, 29]) == False"], "test_case_list": ["assert pairs_sum_to_zero([1, 11, -3, 6, 7, 30]) == False", "assert pairs_sum_to_zero([3, 7, -4, 1, 1, 11]) == False", "assert pairs_sum_to_zero([-8, 11, 0, 3, 6, 26]) == False", "assert pairs_sum_to_zero([1, 14, 0, 5, 2, 34]) == False", "assert pairs_sum_to_zero([1, 2, 3, 7]) == False", "assert pairs_sum_to_zero([4, 2, 9, 3]) == False", "assert pairs_sum_to_zero([-3, 9, -1, 4, 2, 31]) == False", "assert pairs_sum_to_zero([3]) == False", "assert pairs_sum_to_zero([-1, 14, 1, 8, 6, 36]) == True", "assert pairs_sum_to_zero([3, 9, 0, 8, 5, 9]) == False", "assert pairs_sum_to_zero([1, 4, -6, 7, 1, 32]) == False", "assert pairs_sum_to_zero([2, 8, -2, 3]) == True", "assert pairs_sum_to_zero([-2, 10, 0, 6, 5, 30]) == False", "assert pairs_sum_to_zero([3, 1, -2, 2]) == True", "assert pairs_sum_to_zero([3, 2, -1, 2]) == False", "assert pairs_sum_to_zero([-1, 4, -2, 5, 5, 27]) == False", "assert pairs_sum_to_zero([1]) == False", "assert pairs_sum_to_zero([6, 5, -3, 3]) == True", "assert pairs_sum_to_zero([4, 3, -4, 5]) == True", "assert pairs_sum_to_zero([-2, 4, -5, 4, 1, 25]) == False", "assert pairs_sum_to_zero([2, 6, -4, 5]) == False", "assert pairs_sum_to_zero([-7, 5, 2, 4, 1, 26]) == False", "assert pairs_sum_to_zero([-8, 14, 0, 1, 7, 30]) == False", "assert pairs_sum_to_zero([1, 8, -5, 3, 7, 35]) == False", "assert pairs_sum_to_zero([6, 9, -9, 2, 7, 11]) == True", "assert pairs_sum_to_zero([-8, 7, -1, 2, 1, 28]) == True", "assert pairs_sum_to_zero([-3, 9, -1, 3, 2, 31]) == True", "assert pairs_sum_to_zero([6, 6, -7, 6]) == False", "assert pairs_sum_to_zero([-4, 9, 2, 3, 4, 30]) == True", "assert pairs_sum_to_zero([1, 6, 1, 2]) == False", "assert pairs_sum_to_zero([5, 1, 3, 5]) == False", "assert pairs_sum_to_zero([4, 5, 8, 3]) == False", "assert pairs_sum_to_zero([6, 7, 2, 5]) == False", "assert pairs_sum_to_zero([2, 8, 10, 3]) == False", "assert pairs_sum_to_zero([1, 13, -5, 7, 7, 27]) == False", "assert pairs_sum_to_zero([4, 5, -10, 2, 10, 9]) == True", "assert pairs_sum_to_zero([2, 3, 1, 8]) == False", "assert pairs_sum_to_zero([1, 7, 4, 6]) == False", "assert pairs_sum_to_zero([2, 9, -5, 4, 6, 30]) == False", "assert pairs_sum_to_zero([4, 6, 2, 4]) == False", "assert pairs_sum_to_zero([5, 2, 1, 11]) == False", "assert pairs_sum_to_zero([5, 2, 7, 3]) == False", "assert pairs_sum_to_zero([5, 5, 2, 2]) == False", "assert pairs_sum_to_zero([-8, 14, -2, 8, 2, 35]) == True", "assert pairs_sum_to_zero([1, 3, 5, 0]) == False", "assert pairs_sum_to_zero([-1, 8, 4, 3, 7, 29]) == False", "assert pairs_sum_to_zero([2, 12, 1, 9, 6, 33]) == False", "assert pairs_sum_to_zero([-4, 11, 1, 6, 6, 28]) == False", "assert pairs_sum_to_zero([0, 11, -3, 8, 7, 26]) == False", "assert pairs_sum_to_zero([-8, 10, -4, 8, 6, 26]) == True", "assert pairs_sum_to_zero([2]) == False", "assert pairs_sum_to_zero([2, 3, 7, 1]) == False", "assert pairs_sum_to_zero([6, 1, -4, 6]) == False", "assert pairs_sum_to_zero([-2, 12, -4, 7, 1, 36]) == False", "assert pairs_sum_to_zero([2, 12, 1, 6, 7, 25]) == False", "assert pairs_sum_to_zero([-4, 11, -3, 6, 2, 27]) == False", "assert pairs_sum_to_zero([0, 13, -2, 7, 3, 31]) == False", "assert pairs_sum_to_zero([1, 4, -10, 5, 10, 9]) == True", "assert pairs_sum_to_zero([4, 1, 3, 7]) == False", "assert pairs_sum_to_zero([6, 8, 2, 5]) == False", "assert pairs_sum_to_zero([-7, 14, 2, 4, 6, 30]) == False", "assert pairs_sum_to_zero([1, 5, 1, 12]) == False", "assert pairs_sum_to_zero([-3, 9, -1, 3, 2, 30]) == True", "assert pairs_sum_to_zero([-1, 5, -6, 8, 1, 33]) == True", "assert pairs_sum_to_zero([2, 3, 7, 4]) == False", "assert pairs_sum_to_zero([0, 14, -6, 5, 1, 35]) == False", "assert pairs_sum_to_zero([5, 4, -1, 5, 10, 6]) == False", "assert pairs_sum_to_zero([0, 13, -2, 4, 4, 28]) == False", "assert pairs_sum_to_zero([2, 2, 6, 4]) == False", "assert pairs_sum_to_zero([0, 4, -1, 5, 3, 33]) == False", "assert pairs_sum_to_zero([3, 3, 1, 4]) == False", "assert pairs_sum_to_zero([7, 5, -1, 1, 8, 10]) == True", "assert pairs_sum_to_zero([1, 3, 4, 3]) == False", "assert pairs_sum_to_zero([5, 7, 3, 4]) == False", "assert pairs_sum_to_zero([-7, 12, -3, 2, 6, 29]) == False", "assert pairs_sum_to_zero([-4, 9, -3, 6, 7, 31]) == False", "assert pairs_sum_to_zero([4, 7, -9, 5, 4, 6]) == False", "assert pairs_sum_to_zero([-4, 6, 0, 6, 3, 26]) == False", "assert pairs_sum_to_zero([4]) == False", "assert pairs_sum_to_zero([2, 7, 8, 5]) == False", "assert pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) == True", "assert pairs_sum_to_zero([1, 4, -1, 8, 8, 12]) == True", "assert pairs_sum_to_zero([-3, 8, 1, 1, 6, 31]) == False", "assert pairs_sum_to_zero([-6, 14, 1, 8, 2, 28]) == False", "assert pairs_sum_to_zero([-3, 6, -5, 7, 7, 30]) == False", "assert pairs_sum_to_zero([3, 4, -7, 1, 2, 3]) == False", "assert pairs_sum_to_zero([-8, 11, -6, 5, 7, 36]) == False", "assert pairs_sum_to_zero([-7, 14, 0, 5, 1, 28]) == False", "assert pairs_sum_to_zero([-5, 9, -1, 7, 4, 34]) == False", "assert pairs_sum_to_zero([1, 3, 3, 5]) == False", "assert pairs_sum_to_zero([-5, 10, 2, 9, 3, 33]) == False", "assert pairs_sum_to_zero([2, 4, 1, 2]) == False", "assert pairs_sum_to_zero([-3, 9, -1, 4, 2, 30]) == False", "assert pairs_sum_to_zero([1, 3, -2, 1]) == False", "assert pairs_sum_to_zero([2, 10, -2, 2, 4, 33]) == True", "assert pairs_sum_to_zero([3, 9, -8, 6, 2, 5]) == False", "assert pairs_sum_to_zero([-6, 7, -4, 4, 2, 32]) == True", "assert pairs_sum_to_zero([3, 4, 10, 1]) == False", "assert pairs_sum_to_zero([7, 8, -10, 7, 2, 4]) == False", "assert pairs_sum_to_zero([-6, 8, 0, 4, 5, 27]) == False", "assert pairs_sum_to_zero([-6, 14, -4, 5, 6, 32]) == True", "assert pairs_sum_to_zero([-5, 12, 1, 8, 6, 31]) == False", "assert pairs_sum_to_zero([-3, 12, -6, 6, 7, 29]) == True", "assert pairs_sum_to_zero([1, 5, 1, 3]) == False", "assert pairs_sum_to_zero([5, 8, -4, 5]) == False", "assert pairs_sum_to_zero([3, 2, 1, 6]) == False", "assert pairs_sum_to_zero([-5, 4, 3, 6, 2, 27]) == False", "assert pairs_sum_to_zero([-1, 11, -4, 3, 5, 28]) == False", "assert pairs_sum_to_zero([-7, 9, 2, 1, 6, 34]) == False", "assert pairs_sum_to_zero([-1, 13, -4, 6, 3, 28]) == False", "assert pairs_sum_to_zero([6, 1, 0, 3]) == False", "assert pairs_sum_to_zero([-5, 5, -2, 3, 1, 32]) == True", "assert pairs_sum_to_zero([1, 5, -1, 8, 8, 4]) == True", "assert pairs_sum_to_zero([1, 2, 2, 2]) == False", "assert pairs_sum_to_zero([6]) == False", "assert pairs_sum_to_zero([2, 8, 1, 4]) == False", "assert pairs_sum_to_zero([2, 6, 2, 5]) == False", "assert pairs_sum_to_zero([2, 14, 3, 6, 2, 29]) == False", "assert pairs_sum_to_zero([-5, 13, -2, 8, 7, 35]) == False", "assert pairs_sum_to_zero([6, 1, 3, 2]) == False", "assert pairs_sum_to_zero([5]) == False", "assert pairs_sum_to_zero([-4, 8, -1, 7, 6, 26]) == False", "assert pairs_sum_to_zero([-4, 12, 0, 1, 7, 28]) == False", "assert pairs_sum_to_zero([5, 3, 6, 7]) == False", "assert pairs_sum_to_zero([4, 6, -8, 1, 2, 8]) == True", "assert pairs_sum_to_zero([-4, 8, -3, 9, 5, 29]) == False"], "nl": "\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    ", "func": "def pairs_sum_to_zero(l):", "examples": ">>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    ", "completions": ["from typing import List\n## main.py\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n", "from typing import List\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    '''\n    pairs_sum_to_zero takes a list of integers as an input.\n    It returns True if there are two unique numbers in the list that add up to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n        False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n        False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n        False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n        True\n    >>> pairs_sum_to_zero([1])\n        False\n    '''\n    seen = set()\n    for num in l:\n        complement = -num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n", "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    '''\n    pairs_sum_to_zero takes a list of integers as an input.\n    It returns True if there are two unique numbers in the list that add up to zero,\n    and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n        False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n        True\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n        False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n        True\n    >>> pairs_sum_to_zero([1])\n        False\n    '''\n    seen_numbers = set()\n    for number in l:\n        if -number in seen_numbers:\n            return True\n        seen_numbers.add(number)\n    return False\n", "from typing import List\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    '''\n    pairs_sum_to_zero takes a list of integers as an input.\n    It returns True if there are two unique numbers in the list that add up to zero,\n    and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n        False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n        True\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n        False\n    '''\n    seen = set()\n    for number in l:\n        complement = -number\n        if complement in seen:\n            return True\n        seen.add(number)\n    return False\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n", "from typing import List\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    '''\n    pairs_sum_to_zero takes a list of integers as an input.\n    It returns True if there are two unique numbers in the list that add up to zero,\n    and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n        False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n        True\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n        False\n    '''\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n", "from typing import List\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    '''\n    pairs_sum_to_zero takes a list of integers as an input.\n    It returns True if there are two unique numbers in the list that add up to zero,\n    and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    '''\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n", "from typing import List\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    '''\n    pairs_sum_to_zero takes a list of integers as an input. it returns True if there are two unique numbers in the list that add up to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    '''\n    seen = set()\n    for num in l:\n        complement = -num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n", "from typing import List\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    seen_numbers = set()\n    \n    for number in l:\n        complement = -number\n        if complement in seen_numbers:\n            return True\n        seen_numbers.add(number)\n    \n    return False\n", "from typing import List\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    '''\n    pairs_sum_to_zero takes a list of integers as an input.\n    It returns True if there are two unique numbers in the list that add up to zero,\n    and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n        False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n        False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n        False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n        True\n    >>> pairs_sum_to_zero([1])\n        False\n    '''\n    if len(l) < 2:\n        return False\n    \n    seen = set()\n    for num in l:\n        complement = -num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n"], "plans": ["requirement analysis:\nThe requirement is to check if there are any two unique numbers in a list that sum to zero. This is a straightforward problem that can be solved efficiently using a set to track seen numbers and check for the complement as we iterate through the list.\nrequirement pool:\n- Implement the function pairs_sum_to_zero that takes a list of integers and returns True if there are two unique numbers that sum to zero, and False otherwise.\n- Handle edge cases such as an empty list or a list with a single element.\n- Ensure the function is optimized for time complexity, ideally O(n) for the best performance.\nTo implement the function `pairs_sum_to_zero`, we will use a set to keep track of the numbers we have seen so far. As we iterate through the list, for each number, we will check if its negative counterpart is already in the set. If it is, we return `True`. If we finish iterating through the list without finding such a pair, we return `False`. This approach ensures that we only pass through the list once, achieving an O(n) time complexity.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'pairs sum to zero': means finding two unique numbers in a list that add up to zero.\n    Explanation: This concept involves checking if there are any two distinct numbers in the list whose sum equals zero.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship.\n\n# [degree adverb] \n    No degree adverb.\n\n# [code logic]\n    To implement the function `pairs_sum_to_zero`, we will use a set to keep track of the numbers we have seen so far. As we iterate through the list, for each number, we will check if its negative counterpart is already in the set. If it is, we return `True`. If we finish iterating through the list without finding such a pair, we return `False`. This approach ensures that we only pass through the list once, achieving an O(n) time complexity.\n\n# [edge case] \n    pairs_sum_to_zero([1, 3, 5, 0]) = False\n    Explanation: In this case, no two numbers in the list add up to zero. The sum of any two numbers in the list is either positive or not zero.\n    pairs_sum_to_zero([1, 3, -2, 1]) = False\n    Explanation: Although the list contains a negative number, the sum of any pair of numbers does not equal zero.\n    pairs_sum_to_zero([1, 2, 3, 7]) = False\n    Explanation: Similar to the previous case, no two numbers in the list add up to zero.\n    pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) = True\n    Explanation: Here, the pair of numbers -5 and 5 add up to zero. Therefore, the function should return `True`.\n    pairs_sum_to_zero([1]) = False\n    Explanation: With only one number in the list, it is impossible to find a pair that sums to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the case of a list with only one element.\n", "requirement analysis:\nThe requirement is to check if there are any two unique numbers in a list that sum to zero. This is a straightforward problem that can be solved efficiently using a set to track the complements of each number. The function should handle edge cases like lists with a single element or no such pairs.\nrequirement pool:\n- Implement a function that checks for pairs summing to zero\n- Ensure the function handles edge cases\n- Optimize the function for performance\n- Improve readability and maintainability of the code\n- Add comments and docstrings for better understanding\nTo implement the function `pairs_sum_to_zero`, we will use a set to track the complements of each number in the list. This approach ensures that we can efficiently check for pairs that sum to zero. We will iterate through the list, calculate the complement for each number, and check if it exists in the set. If it does, we return `True`. If we finish iterating through the list without finding such a pair, we return `False`. This method is efficient with a time complexity of O(n), where n is the number of elements in the list.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'sum to zero': means the two numbers in the list should add up to 0\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (1) Iterate through the list of integers.\n    (2) For each integer, calculate its complement (i.e., the negative of the integer).\n    (3) Check if the complement exists in a set that tracks seen numbers.\n    (4) If the complement is found, return `True` because a pair that sums to zero has been found.\n    (5) If the iteration completes without finding such a pair, return `False`.\n\n# [edge case] \n    pairs_sum_to_zero([1, 3, 5, 0]) = False\n    Explanation: No two numbers in the list add up to zero.\n    pairs_sum_to_zero([1, 3, -2, 1]) = False\n    Explanation: No two numbers in the list add up to zero.\n    pairs_sum_to_zero([1, 2, 3, 7]) = False\n    Explanation: No two numbers in the list add up to zero.\n    pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) = True\n    Explanation: The pair (-5, 5) sums to zero.\n    pairs_sum_to_zero([1]) = False\n    Explanation: With only one number in the list, it's impossible to find a pair that sums to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided covers all edge cases, including lists with a single element.\n", "requirement analysis:\nThe requirement is to create a function that checks if there are two unique numbers in a list that sum to zero. The function should handle edge cases such as lists with a single element. The solution should be efficient and easy to understand.\nrequirement pool:\n- The main code should iterate through the list and check pairs of numbers.\n- The function should return False if the list has fewer than two elements.\n- Optimize the function to avoid unnecessary computations.\n- Ensure the code is well-documented and easy to read.\n- Include tests to cover various edge cases.\nWe will use a set to keep track of the numbers we have seen so far. As we iterate through the list, we will check if the negative of the current number exists in the set. If it does, we return True. If we finish iterating through the list without finding such a pair, we return False. This approach ensures that we only pass through the list once, making the function efficient.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'pairs sum to zero': means the sum of two different numbers in the list equals zero.\n    Explanation: This concept involves finding two distinct integers in a list that add up to zero.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship.\n\n# [degree adverb] \n    No degree adverb.\n\n# [code logic]\n    (1) Iterate through the list of integers.\n    (2) For each integer, calculate its negative value.\n    (3) Check if this negative value exists in the set of seen numbers.\n    (4) If it exists, return True as we have found a pair that sums to zero.\n    (5) If the loop completes without finding such a pair, return False.\n\n# [edge case] \n    pairs_sum_to_zero([1]) = False\n    Explanation: With only one number in the list, it's impossible to find a pair that sums to zero.\n    pairs_sum_to_zero([1, 3, 5, 0]) = False\n    Explanation: No two numbers in the list sum to zero.\n    pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) = True\n    Explanation: The pair (-5, 5) sums to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic already correctly handles the case of a single element in the list by immediately returning False.\n", "requirement analysis:\nThe requirement is to check if there are any two unique numbers in the list that add up to zero. This is a straightforward problem that can be solved efficiently using a set to track the complements of each number.\nrequirement pool:\n- Implement a function that checks for pairs summing to zero\n- Ensure the function is optimized for performance\n- Make the code easy to understand and maintain\n- Add test cases to verify the correctness of the function\n- Consider edge cases such as empty lists or lists with fewer than two elements\nTo implement the function `pairs_sum_to_zero`, we will use a set to track the complements of each number in the list. This approach ensures that we can check for pairs summing to zero in linear time, making it efficient. The set will help us quickly determine if the complement of the current number exists in the list, thus avoiding the need for a nested loop, which would be less efficient.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'pairs summing to zero': means finding two unique numbers in the list that add up to zero.\n    Explanation: This concept involves identifying two distinct elements in the list whose sum equals zero.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship.\n\n# [degree adverb] \n    No degree adverb.\n\n# [code logic]\n    To implement the function `pairs_sum_to_zero`, we will use a set to track the complements of each number in the list. This approach ensures that we can check for pairs summing to zero in linear time, making it efficient. The set will help us quickly determine if the complement of the current number exists in the list, thus avoiding the need for a nested loop, which would be less efficient.\n\n# [edge case] \n    pairs_sum_to_zero([1, 2, -1, -2]) = True\n    Explanation: The list contains the numbers 1 and -1, which sum to zero. Therefore, the function should return True.\n    pairs_sum_to_zero([1, 2, 3, 4]) = False\n    Explanation: There are no two unique numbers in the list that add up to zero. Therefore, the function should return False.\n    pairs_sum_to_zero([]) = False\n    Explanation: The list is empty, so there are no pairs to check. Therefore, the function should return False.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle an empty list by immediately returning False.\n", "requirement analysis:\nThe requirement is to check if there are any two unique numbers in a list that sum to zero. This is a basic requirement that can be efficiently implemented using a set to track seen numbers and check for the complement as we iterate through the list.\nrequirement pool:\n- Implement the function pairs_sum_to_zero with a time complexity of O(n).\n- Ensure the function is tested for various edge cases including empty lists, lists with one element, and lists with no pairs summing to zero.\n- Include clear documentation and examples in the function's docstring.\n- Optimize the function for performance, especially for large lists.\n- Consider adding a feature to handle lists with duplicate elements.\nTo implement the function pairs_sum_to_zero efficiently, we will use a set to keep track of the numbers we have seen so far. As we iterate through the list, for each number, we will check if its negative counterpart is already in the set. If it is, we return True. If we finish iterating through the list without finding such a pair, we return False. This approach ensures that we only pass through the list once, resulting in a time complexity of O(n).\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'pairs sum to zero': means that we need to find two unique numbers in the list that add up to zero.\n    Explanation: This concept involves finding two distinct elements in a list whose sum equals zero.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Steps to implement the function:\n    1. Iterate through the list of integers.\n    2. For each integer, check if its negative counterpart exists in the list.\n    3. If such a pair is found, return True.\n    4. If no such pair is found after iterating through the entire list, return False.\n\n# [edge case] \n    pairs_sum_to_zero([1, -1]) = True\n    Explanation: The list contains the pair (1, -1) which sums to zero.\n    pairs_sum_to_zero([2, 3, -2, 1]) = True\n    Explanation: The list contains the pair (2, -2) which sums to zero.\n    pairs_sum_to_zero([5, 6, 7, 8]) = False\n    Explanation: There are no two numbers in the list that sum to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic is sufficient to check for pairs that sum to zero.\n", "requirement analysis:\nThe original requirements specify a simple function that checks if there are any two unique numbers in a list that sum to zero. This is a fundamental problem that can be approached in multiple ways, including brute force and using a set for efficiency. Clarifying the requirement ensures that the solution is both correct and efficient.\nrequirement pool:\n- Implement a function that checks for pairs summing to zero\n- Ensure the function is efficient and handles large lists\n- Make the code easy to read and maintain\n- Include test cases to verify the correctness of the function\n- Optimize the algorithm for performance\nWe will implement the function using a brute force approach to check all possible pairs in the list. This approach is simple and ensures that we check all combinations, which is crucial for handling edge cases where the sum of two unique numbers equals zero. We will use a set to keep track of the numbers we've seen so far, which helps in efficiently checking if the complement (negative of the current number) exists in the list.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'sum to zero': means the addition of two numbers in the list equals zero\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n\n# [edge case] \n    pairs_sum_to_zero([1, -1]) = True\n    Explanation: There are two unique numbers in the list that add up to zero, which are 1 and -1.\n    pairs_sum_to_zero([2, 4, 3, -2, -4]) = True\n    Explanation: There are two unique numbers in the list that add up to zero, which are 4 and -4.\n    pairs_sum_to_zero([0, 0, 0]) = False\n    Explanation: All numbers are zero, so no pair can sum to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The brute force approach will naturally check all pairs, including the case where the list contains multiple zeros.\n", "requirement analysis:\nThe requirement is to check if there are any two unique numbers in the list that add up to zero. This is a straightforward problem that can be solved efficiently using a set to track the complements of each number.\nrequirement pool:\n- Implement a function that checks for pairs summing to zero\n- Ensure the function is optimized for performance\n- Make the code easy to understand and maintain\n- Add test cases to verify the correctness of the function\n- Consider edge cases such as empty lists or lists with one element\nTo implement the function efficiently, we will use a set to track the complements of each number in the list. This approach ensures that we can check for pairs summing to zero in linear time, making it suitable for handling large lists.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'sum to zero': means the sum of two numbers in the list equals zero.\n    'unique pairs': means we need to find pairs that are distinct and not the same number twice.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship.\n\n# [degree adverb] \n    No degree adverb.\n\n# [code logic]\n    To implement the function efficiently, we will use a set to track the complements of each number in the list. This approach ensures that we can check for pairs summing to zero in linear time, making it suitable for handling large lists.\n\n# [edge case] \n    pairs_sum_to_zero([1, -1]) = True\n    Explanation: There are two unique numbers in the list that add up to zero, which are 1 and -1.\n    pairs_sum_to_zero([2, 4, -2, -4]) = True\n    Explanation: There are two unique numbers in the list that add up to zero, which are 2 and -2, and 4 and -4.\n    pairs_sum_to_zero([0, 0, 0]) = False\n    Explanation: Although there are multiple zeros in the list, they do not form a pair that sums to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to check for unique pairs that sum to zero.\n", "requirement analysis:\nThe requirement is to check if there are any two unique numbers in the list that add up to zero. This is a straightforward problem that can be solved efficiently using a set to track the complements of each number.\nrequirement pool:\n- Implement a function that checks for pairs summing to zero\n- Ensure the function is optimized for performance\n- Make the function easy to understand and maintain\nTo implement the function `pairs_sum_to_zero`, we will use a set to track the complements of each number in the list. This approach ensures that we can check for pairs in linear time, making it efficient for large lists. The function will iterate through the list, calculate the complement for each number, and check if it exists in the set. If it does, the function will return `True`. If the loop completes without finding such a pair, the function will return `False`.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'pairs sum to zero': means that we need to find two unique numbers in the list that add up to zero.\n    Explanation: This concept involves finding two distinct elements in a list whose sum equals zero.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Steps to implement the function:\n    1. Iterate through the list of integers.\n    2. For each integer, calculate its complement (i.e., the negative of the integer).\n    3. Check if the complement exists in the set of seen numbers.\n    4. If the complement is found, return `True` as we have found two numbers that sum to zero.\n    5. If the loop completes without finding such a pair, return `False`.\n\n# [edge case] \n    pairs_sum_to_zero([1, -1]) = True\n    Explanation: The list contains the integers 1 and -1, which sum to zero.\n    pairs_sum_to_zero([2, 3, 4]) = False\n    Explanation: No two numbers in the list sum to zero.\n    pairs_sum_to_zero([0, 0, 0]) = True\n    Explanation: The list contains multiple zeros, and two of them (0 and 0) sum to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic already correctly handles lists with multiple zeros.\n", "requirement analysis:\nThe requirement is to check if there are any two unique numbers in a list that sum to zero. This is a basic requirement that can be implemented efficiently. The solution should be simple and clear to understand, ensuring it is easy to maintain and extend if needed.\nrequirement pool:\n- Implement a function that checks if there are two unique numbers in a list that sum to zero.\n- Ensure the code is clean and easy to understand.\n- Optimize the algorithm for performance.\nTo implement the function `pairs_sum_to_zero` efficiently, we will use a set to keep track of the numbers we have seen so far. This allows us to check in constant time whether the complement of the current number (i.e., its negative) exists in the set. This approach ensures that we only pass through the list once, making the solution both simple and performant.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'sum to zero': means the two numbers in the list should add up to 0.\n    'unique numbers': means each number in the list should be considered only once.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Iterate through the list of numbers.\n    - For each number, calculate its complement (i.e., its negative).\n    - Check if the complement exists in the set of seen numbers.\n    - If it does, return True.\n    - If the loop completes without finding such a pair, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0, 0, 0]) = False\n    Explanation: There are no two unique numbers that sum to zero.\n    pairs_sum_to_zero([-1, 1]) = True\n    Explanation: The numbers -1 and 1 are unique and their sum is zero.\n    pairs_sum_to_zero([2, -2, 3, 4]) = True\n    Explanation: The numbers -2 and 2 are unique and their sum is zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic will correctly return False for the edge case where all numbers are zero.\n\n# [core concept]\n    'positive integers': means all numbers in the list are positive.\n\n# [phrase showing quantity relationship]\n    'more than zero': means all numbers in the list are greater than 0.\n    'at least as many times': means the frequency of an integer in the list should be greater than or equal to the integer itself.\n\n# [degree adverb] \n    'largest': means we need to find the largest integer that meets the condition.\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Create a dictionary to store the frequency of each integer.\n    - Iterate through the list and update the frequency in the dictionary.\n    - Iterate through the dictionary to find the largest integer that appears at least as many times as itself.\n    - If no such integer exists, return -1.\n\n# [edge case] \n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their values, but 3 is the largest number.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear at least as many times as their values, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.\n\n# [core concept]\n    'overlapping appearances': means we need to count the substring appearances where the end of one occurrence can be the start of another.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    - Get the input string and substring from the user.\n    - Initialize a counter variable to keep track of the number of occurrences.\n    - Iterate through the original string using a sliding window approach.\n    - Check if the current substring matches the input substring.\n    - If a match is found, increment the counter variable.\n    - Return the final count of occurrences.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('') returns 4.\n\n# [extra code for edge case]\n    Extra code is needed to handle the edge case.\n    - If not string:\n        return 0\n    - elif not substring:\n        return len(string) + 1\n    - (other code)\n", "requirement analysis:\nThe requirement is to check if there are any two unique numbers in a list that sum to zero. This is a straightforward problem that can be solved efficiently using a set to track the complements of each number. The function should handle edge cases like lists with a single element or no such pairs.\nrequirement pool:\n- Implement the function to check for pairs summing to zero\n- Ensure the function handles edge cases\n- Optimize the function for performance\n- Document the function for clarity\n- Test the function with various edge cases\nTo implement the function efficiently, we will use a set to track the complements of each number in the list. This approach ensures that we can check for the existence of pairs in constant time, making the function performant. We will also handle edge cases such as lists with a single element or no pairs summing to zero.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'pairs sum to zero': means that we need to find two unique numbers in the list that add up to zero.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Iterate through the list and use a set to track the complements of each number.\n\n# [edge case] \n    pairs_sum_to_zero([1]) = False\n    Explanation: Since there is only one element in the list, it's impossible to find a pair that sums to zero.\n    pairs_sum_to_zero([1, 3, 5, 0]) = False\n    Explanation: No two numbers in the list sum to zero.\n    pairs_sum_to_zero([1, 3, -2, 1]) = False\n    Explanation: No two numbers in the list sum to zero.\n    pairs_sum_to_zero([1, 2, 3, 7]) = False\n    Explanation: No two numbers in the list sum to zero.\n    pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) = True\n    Explanation: The pair (-5, 5) sums to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can handle the case of a single element in the list by immediately returning False.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [126, 126, 126, 126, 126, 126, 126, 126, 126, 126], "completion": "from typing import List\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    '''\n    pairs_sum_to_zero takes a list of integers as an input.\n    It returns True if there are two unique numbers in the list that add up to zero,\n    and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n        False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n        False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n        False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n        True\n    >>> pairs_sum_to_zero([1])\n        False\n    '''\n    if len(l) < 2:\n        return False\n    \n    seen = set()\n    for num in l:\n        complement = -num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n", "passed": true, "pass": true, "pass_num": 10, "round": 578, "repair_prompt": ["def pairs_sum_to_zero(l):\t\n'''pairs_sum_to_zero takes a list of integers as an input. it returns True if there are two unique numbers in the list that add up to zero, and False otherwise.\n>>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    '''", " def pairs_sum_to_zero(l):\n    '''pairs_sum_to_zero takes a list of integers as an input. it returns True if there are two unique numbers in the list that add up to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n        False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n        False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n        False\n", " def pairs_sum_to_zero(l):\n    '''pairs_sum_to_zero takes a list of integers as an input. it returns True if there are two unique numbers in the list that add up to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n"], "mutate_method": "rephrase_one", "parent_index": 351}
