{"task_id": "HumanEval/21", "prompt": "def rescale_to_unit(numbers: List[float]) -> List[float]:\t\n'''Given a list of numbers containing at least two elements, apply a linear transform to that list, such that the smallest number will transform into 0 and the largest will transform into 1.\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    '''", "entry_point": "rescale_to_unit", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "test": ["def check(rescale_to_unit):\n\tassert rescale_to_unit([99.9, 47.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.2, 51.8]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([100.7, 49.1]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.7, 51.3]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.8, 4.8, 4.5, 1.8, 1.7]) == [0.3548387096774194, 1.0, 0.903225806451613, 0.032258064516129066, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.5, 1.4, 8.1, 4.2, 6.7]) == [0.014925373134328374, 0.0, 1.0, 0.4179104477611941, 0.7910447761194032]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.2, 8.7, 11.8, 16.6, 14.9]) == [0.0, 0.15957446808510625, 0.4893617021276595, 1.0, 0.8191489361702126]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.2, 54.2]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([15.4, 13.2, 13.8, 17.0, 17.9]) == [0.468085106382979, 0.0, 0.12765957446808543, 0.8085106382978726, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([101.4, 46.5]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.0, 6.9, 8.3, 7.9, 6.9]) == [0.0, 0.5757575757575757, 1.0, 0.8787878787878787, 0.5757575757575757]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([104.6, 46.0]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.3, 46.5]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.2, 52.9]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.5, 54.9]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.2, 47.3]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([10.6, 9.8, 13.5, 15.4, 15.5]) == [0.14035087719298228, 0.0, 0.6491228070175438, 0.9824561403508772, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([103.9, 51.6]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([10.3, 9.9, 18.2, 18.6, 15.0]) == [0.04597701149425291, 0.0, 0.9540229885057468, 1.0, 0.586206896551724]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.1, 5.6, 7.5, 4.7, 2.2]) == [0.5471698113207546, 0.6415094339622641, 1.0, 0.4716981132075472, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.2, 49.3]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([99.6, 50.1]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([98.8, 50.6]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([13.5, 11.1, 16.3, 15.7, 14.2]) == [0.4615384615384615, 0.0, 1.0, 0.8846153846153844, 0.5961538461538459]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([11.4, 11.3, 14.4, 18.1, 9.6]) == [0.211764705882353, 0.2000000000000001, 0.5647058823529412, 1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([103.9, 44.1]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.9, 1.1, 1.7, 7.1, 4.6]) == [0.3, 0.0, 0.09999999999999998, 1.0, 0.5833333333333333]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.5, 4.5, 8.2, 6.4, 10.1]) == [0.35714285714285715, 0.0, 0.6607142857142856, 0.33928571428571436, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.5, 5.1, 8.1, 7.0, 8.3]) == [0.0, 0.15789473684210514, 0.9473684210526313, 0.6578947368421051, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.9, 4.1, 7.1, 9.3, 10.0]) == [0.13559322033898316, 0.0, 0.5084745762711864, 0.8813559322033899, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.6, 3.9, 10.6, 3.8, 9.3]) == [0.0, 0.16249999999999998, 1.0, 0.14999999999999997, 0.8375000000000001]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([98.3, 48.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([100.4, 49.3]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.9, 5.9, 10.7, 3.0, 3.1]) == [0.0, 0.38461538461538475, 1.0, 0.012820512820512834, 0.025641025641025668]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.5, 1.1, 2.9, 7.4, 5.1]) == [1.0, 0.0, 0.28124999999999994, 0.9843750000000001, 0.6249999999999999]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.3, 5.8, 7.5, 4.0, 9.7]) == [0.4035087719298246, 0.3157894736842105, 0.6140350877192983, 0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([95.7, 53.0]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.5, 2.9, 6.4, 6.8, 1.0]) == [0.9482758620689655, 0.3275862068965517, 0.9310344827586208, 1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.6, 3.4, 5.5, 9.4, 7.2]) == [0.0, 0.23076923076923073, 0.49999999999999994, 1.0, 0.7179487179487178]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.6, 5.9, 2.8, 5.2, 11.0]) == [0.21951219512195122, 0.378048780487805, 0.0, 0.2926829268292684, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.2, 3.3, 2.1, 1.5, 5.7]) == [1.0, 0.38297872340425526, 0.12765957446808512, 0.0, 0.8936170212765957]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([16.2, 16.6, 16.6, 12.8, 18.2]) == [0.6296296296296295, 0.703703703703704, 0.703703703703704, 0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([100.4, 48.1]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.4, 7.5, 6.4, 5.1, 10.6]) == [0.0, 0.5694444444444444, 0.4166666666666668, 0.2361111111111111, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.7, 1.2, 6.7, 3.4, 8.2]) == [0.3571428571428572, 0.0, 0.7857142857142858, 0.31428571428571433, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.6, 4.5, 5.5, 2.4, 5.1]) == [0.7096774193548386, 0.6774193548387097, 1.0, 0.0, 0.8709677419354838]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([17.5, 17.0, 13.4, 10.5, 15.8]) == [1.0, 0.9285714285714286, 0.4142857142857143, 0.0, 0.7571428571428572]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.8, 6.5, 5.7, 1.4, 9.9]) == [0.5176470588235295, 0.6, 0.5058823529411766, 0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.1, 4.6, 6.9, 5.1, 4.6]) == [1.0, 0.0, 0.9200000000000003, 0.2, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.2, 53.8]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.5, 44.9]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([11.6, 9.7, 12.4, 18.9, 9.4]) == [0.23157894736842102, 0.03157894736842095, 0.31578947368421056, 1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.3, 5.4, 1.8, 4.3, 8.7]) == [0.0, 0.5540540540540542, 0.06756756756756757, 0.40540540540540543, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.7, 2.2, 4.7, 8.7, 7.8]) == [0.5384615384615385, 0.0, 0.3846153846153847, 1.0, 0.8615384615384616]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.6, 1.6, 4.7, 8.8, 6.6]) == [0.0, 0.0, 0.4305555555555555, 1.0, 0.6944444444444443]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.1, 51.4]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.1, 50.2]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([97.0, 52.7]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.1, 3.9, 4.9, 8.0, 3.4]) == [0.0, 0.30508474576271183, 0.4745762711864407, 1.0, 0.22033898305084743]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.8, 52.2]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.9, 2.9, 8.4, 9.6, 6.9]) == [0.4477611940298509, 0.0, 0.8208955223880597, 1.0, 0.5970149253731344]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.0, 49.9]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.3, 7.5, 19.8, 18.8, 12.9]) == [0.0, 0.016000000000000014, 1.0, 0.92, 0.44800000000000006]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.0, 1.6, 9.0, 8.2, 7.2]) == [0.45945945945945943, 0.0, 1.0, 0.8918918918918918, 0.7567567567567567]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.5, 2.8, 8.2, 9.8, 6.8]) == [0.10000000000000002, 0.0, 0.7714285714285712, 1.0, 0.5714285714285714]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([8.0, 9.3, 17.1, 18.5, 10.5]) == [0.0, 0.12380952380952388, 0.8666666666666668, 1.0, 0.23809523809523808]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.6, 1.6, 1.3, 6.9, 2.3]) == [0.9464285714285713, 0.053571428571428575, 0.0, 1.0, 0.17857142857142852]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.4, 45.9]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.3, 2.5, 1.2, 4.0, 8.5]) == [0.4246575342465753, 0.17808219178082194, 0.0, 0.3835616438356164, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.9, 50.7]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.9, 46.2]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.4, 2.6, 2.1, 7.0, 2.4]) == [0.46938775510204084, 0.1020408163265306, 0.0, 1.0, 0.061224489795918324]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([14.6, 6.7, 19.2, 13.8, 13.5]) == [0.632, 0.0, 1.0, 0.5680000000000001, 0.544]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([95.6, 46.0]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.5, 5.5, 10.2, 3.9, 4.4]) == [0.0, 0.38961038961038963, 1.0, 0.18181818181818182, 0.24675324675324684]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([12.4, 8.1, 15.5, 14.4, 15.1]) == [0.5810810810810811, 0.0, 1.0, 0.8513513513513514, 0.9459459459459459]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([105.5, 53.2]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([102.1, 48.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.1, 6.1, 8.0, 6.4, 8.7]) == [0.0, 0.0, 0.7307692307692311, 0.11538461538461567, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([100.0, 49.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([12.2, 12.9, 12.4, 11.6, 16.9]) == [0.11320754716981128, 0.24528301886792472, 0.15094339622641526, 0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([10.9, 13.2, 20.2, 11.2, 11.2]) == [0.0, 0.24731182795698917, 1.0, 0.03225806451612892, 0.03225806451612892]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([96.2, 53.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([95.4, 48.0]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.7, 44.3]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([102.0, 48.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.4, 51.4]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([16.1, 13.0, 15.9, 9.1, 15.3]) == [1.0, 0.557142857142857, 0.9714285714285713, 0.0, 0.8857142857142857]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.5, 2.1, 4.3, 7.7, 9.7]) == [0.05263157894736841, 0.0, 0.28947368421052627, 0.7368421052631579, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.0, 48.4]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.6, 6.9, 7.0, 2.7, 4.9]) == [1.0, 0.8571428571428573, 0.8775510204081634, 0.0, 0.4489795918367348]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.5, 5.6, 3.1, 8.0, 9.4]) == [0.3809523809523809, 0.3968253968253967, 0.0, 0.7777777777777778, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.4, 3.2, 3.7, 8.2, 1.1]) == [0.18309859154929575, 0.295774647887324, 0.36619718309859156, 1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.3, 1.5, 9.5, 4.6, 1.2]) == [0.7349397590361445, 0.03614457831325302, 1.0, 0.40963855421686735, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([105.8, 45.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([9.7, 7.6, 13.7, 8.1, 10.3]) == [0.34426229508196715, 0.0, 1.0, 0.0819672131147541, 0.44262295081967235]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([15.7, 12.5, 16.1, 8.7, 9.6]) == [0.9459459459459457, 0.5135135135135135, 1.0, 0.0, 0.12162162162162163]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([10.1, 14.1, 14.5, 9.1, 9.5]) == [0.18518518518518517, 0.9259259259259258, 1.0, 0.0, 0.07407407407407414]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.7, 47.3]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.9, 4.4, 1.4, 3.4, 2.8]) == [1.0, 0.6666666666666667, 0.0, 0.4444444444444444, 0.3111111111111111]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.1, 6.8, 5.3, 5.4, 5.5]) == [0.0, 1.0, 0.5945945945945945, 0.6216216216216217, 0.6486486486486487]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.1, 51.2]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.0, 3.8, 8.2, 3.9, 1.1]) == [0.5492957746478874, 0.38028169014084506, 1.0, 0.39436619718309857, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.9, 4.8, 3.2, 4.3, 1.4]) == [0.14705882352941177, 1.0, 0.5294117647058825, 0.8529411764705882, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([10.1, 12.6, 10.2, 16.8, 11.1]) == [0.0, 0.3731343283582089, 0.014925373134328302, 1.0, 0.14925373134328357]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.6, 5.7, 10.7, 5.4, 4.4]) == [0.03174603174603164, 0.20634920634920637, 1.0, 0.15873015873015875, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.0, 52.8]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([98.1, 46.8]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.4, 50.9]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.5, 46.2]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.2, 2.1, 1.6, 6.4, 3.7]) == [0.3333333333333333, 0.10416666666666666, 0.0, 1.0, 0.43749999999999994]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.0, 51.8]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([102.9, 44.8]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.3, 4.4, 8.8, 2.9, 1.7]) == [0.22535211267605632, 0.38028169014084506, 1.0, 0.16901408450704222, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([17.6, 14.9, 12.4, 9.6, 14.2]) == [1.0, 0.6625, 0.35000000000000003, 0.0, 0.5749999999999998]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([102.4, 46.0]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([12.3, 14.5, 18.1, 18.3, 10.4]) == [0.24050632911392408, 0.5189873417721518, 0.9746835443037976, 1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([105.8, 45.3]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.4, 1.8, 4.4, 7.7, 2.8]) == [0.6101694915254238, 0.0, 0.44067796610169496, 1.0, 0.16949152542372878]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.7, 3.9, 1.2, 4.6, 7.1]) == [0.42372881355932207, 0.45762711864406785, 0.0, 0.5762711864406779, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([9.7, 13.8, 18.7, 15.3, 14.7]) == [0.0, 0.4555555555555557, 1.0, 0.6222222222222223, 0.5555555555555556]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([17.6, 8.7, 12.8, 9.2, 17.0]) == [1.0, 0.0, 0.46067415730337086, 0.05617977528089886, 0.9325842696629212]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.5, 4.4, 8.0, 3.4, 10.2]) == [0.0, 0.24675324675324684, 0.7142857142857143, 0.11688311688311688, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.3, 3.4, 7.0, 6.8, 4.4]) == [0.0, 0.23404255319148937, 1.0, 0.9574468085106382, 0.44680851063829796]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.3, 4.4, 6.1, 8.4, 1.2]) == [0.43055555555555547, 0.4444444444444445, 0.6805555555555555, 1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.3, 7.4, 16.1, 10.7, 18.0]) == [0.0, 0.009345794392523414, 0.8224299065420562, 0.3177570093457944, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([102.3, 47.4]) == [1.0, 0.0]"], "test_case_list": ["assert rescale_to_unit([99.9, 47.9]) == [1.0, 0.0]", "assert rescale_to_unit([3.2, 51.8]) == [0.0, 1.0]", "assert rescale_to_unit([100.7, 49.1]) == [1.0, 0.0]", "assert rescale_to_unit([4.7, 51.3]) == [0.0, 1.0]", "assert rescale_to_unit([2.8, 4.8, 4.5, 1.8, 1.7]) == [0.3548387096774194, 1.0, 0.903225806451613, 0.032258064516129066, 0.0]", "assert rescale_to_unit([1.5, 1.4, 8.1, 4.2, 6.7]) == [0.014925373134328374, 0.0, 1.0, 0.4179104477611941, 0.7910447761194032]", "assert rescale_to_unit([7.2, 8.7, 11.8, 16.6, 14.9]) == [0.0, 0.15957446808510625, 0.4893617021276595, 1.0, 0.8191489361702126]", "assert rescale_to_unit([4.2, 54.2]) == [0.0, 1.0]", "assert rescale_to_unit([15.4, 13.2, 13.8, 17.0, 17.9]) == [0.468085106382979, 0.0, 0.12765957446808543, 0.8085106382978726, 1.0]", "assert rescale_to_unit([101.4, 46.5]) == [1.0, 0.0]", "assert rescale_to_unit([5.0, 6.9, 8.3, 7.9, 6.9]) == [0.0, 0.5757575757575757, 1.0, 0.8787878787878787, 0.5757575757575757]", "assert rescale_to_unit([104.6, 46.0]) == [1.0, 0.0]", "assert rescale_to_unit([1.3, 46.5]) == [0.0, 1.0]", "assert rescale_to_unit([1.2, 52.9]) == [0.0, 1.0]", "assert rescale_to_unit([2.5, 54.9]) == [0.0, 1.0]", "assert rescale_to_unit([4.2, 47.3]) == [0.0, 1.0]", "assert rescale_to_unit([10.6, 9.8, 13.5, 15.4, 15.5]) == [0.14035087719298228, 0.0, 0.6491228070175438, 0.9824561403508772, 1.0]", "assert rescale_to_unit([103.9, 51.6]) == [1.0, 0.0]", "assert rescale_to_unit([10.3, 9.9, 18.2, 18.6, 15.0]) == [0.04597701149425291, 0.0, 0.9540229885057468, 1.0, 0.586206896551724]", "assert rescale_to_unit([5.1, 5.6, 7.5, 4.7, 2.2]) == [0.5471698113207546, 0.6415094339622641, 1.0, 0.4716981132075472, 0.0]", "assert rescale_to_unit([7.2, 49.3]) == [0.0, 1.0]", "assert rescale_to_unit([99.6, 50.1]) == [1.0, 0.0]", "assert rescale_to_unit([98.8, 50.6]) == [1.0, 0.0]", "assert rescale_to_unit([13.5, 11.1, 16.3, 15.7, 14.2]) == [0.4615384615384615, 0.0, 1.0, 0.8846153846153844, 0.5961538461538459]", "assert rescale_to_unit([11.4, 11.3, 14.4, 18.1, 9.6]) == [0.211764705882353, 0.2000000000000001, 0.5647058823529412, 1.0, 0.0]", "assert rescale_to_unit([103.9, 44.1]) == [1.0, 0.0]", "assert rescale_to_unit([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]", "assert rescale_to_unit([2.9, 1.1, 1.7, 7.1, 4.6]) == [0.3, 0.0, 0.09999999999999998, 1.0, 0.5833333333333333]", "assert rescale_to_unit([6.5, 4.5, 8.2, 6.4, 10.1]) == [0.35714285714285715, 0.0, 0.6607142857142856, 0.33928571428571436, 1.0]", "assert rescale_to_unit([4.5, 5.1, 8.1, 7.0, 8.3]) == [0.0, 0.15789473684210514, 0.9473684210526313, 0.6578947368421051, 1.0]", "assert rescale_to_unit([4.9, 4.1, 7.1, 9.3, 10.0]) == [0.13559322033898316, 0.0, 0.5084745762711864, 0.8813559322033899, 1.0]", "assert rescale_to_unit([2.6, 3.9, 10.6, 3.8, 9.3]) == [0.0, 0.16249999999999998, 1.0, 0.14999999999999997, 0.8375000000000001]", "assert rescale_to_unit([98.3, 48.9]) == [1.0, 0.0]", "assert rescale_to_unit([100.4, 49.3]) == [1.0, 0.0]", "assert rescale_to_unit([2.9, 5.9, 10.7, 3.0, 3.1]) == [0.0, 0.38461538461538475, 1.0, 0.012820512820512834, 0.025641025641025668]", "assert rescale_to_unit([7.5, 1.1, 2.9, 7.4, 5.1]) == [1.0, 0.0, 0.28124999999999994, 0.9843750000000001, 0.6249999999999999]", "assert rescale_to_unit([6.3, 5.8, 7.5, 4.0, 9.7]) == [0.4035087719298246, 0.3157894736842105, 0.6140350877192983, 0.0, 1.0]", "assert rescale_to_unit([95.7, 53.0]) == [1.0, 0.0]", "assert rescale_to_unit([6.5, 2.9, 6.4, 6.8, 1.0]) == [0.9482758620689655, 0.3275862068965517, 0.9310344827586208, 1.0, 0.0]", "assert rescale_to_unit([1.6, 3.4, 5.5, 9.4, 7.2]) == [0.0, 0.23076923076923073, 0.49999999999999994, 1.0, 0.7179487179487178]", "assert rescale_to_unit([4.6, 5.9, 2.8, 5.2, 11.0]) == [0.21951219512195122, 0.378048780487805, 0.0, 0.2926829268292684, 1.0]", "assert rescale_to_unit([6.2, 3.3, 2.1, 1.5, 5.7]) == [1.0, 0.38297872340425526, 0.12765957446808512, 0.0, 0.8936170212765957]", "assert rescale_to_unit([16.2, 16.6, 16.6, 12.8, 18.2]) == [0.6296296296296295, 0.703703703703704, 0.703703703703704, 0.0, 1.0]", "assert rescale_to_unit([100.4, 48.1]) == [1.0, 0.0]", "assert rescale_to_unit([3.4, 7.5, 6.4, 5.1, 10.6]) == [0.0, 0.5694444444444444, 0.4166666666666668, 0.2361111111111111, 1.0]", "assert rescale_to_unit([3.7, 1.2, 6.7, 3.4, 8.2]) == [0.3571428571428572, 0.0, 0.7857142857142858, 0.31428571428571433, 1.0]", "assert rescale_to_unit([4.6, 4.5, 5.5, 2.4, 5.1]) == [0.7096774193548386, 0.6774193548387097, 1.0, 0.0, 0.8709677419354838]", "assert rescale_to_unit([17.5, 17.0, 13.4, 10.5, 15.8]) == [1.0, 0.9285714285714286, 0.4142857142857143, 0.0, 0.7571428571428572]", "assert rescale_to_unit([5.8, 6.5, 5.7, 1.4, 9.9]) == [0.5176470588235295, 0.6, 0.5058823529411766, 0.0, 1.0]", "assert rescale_to_unit([7.1, 4.6, 6.9, 5.1, 4.6]) == [1.0, 0.0, 0.9200000000000003, 0.2, 0.0]", "assert rescale_to_unit([6.2, 53.8]) == [0.0, 1.0]", "assert rescale_to_unit([1.5, 44.9]) == [0.0, 1.0]", "assert rescale_to_unit([11.6, 9.7, 12.4, 18.9, 9.4]) == [0.23157894736842102, 0.03157894736842095, 0.31578947368421056, 1.0, 0.0]", "assert rescale_to_unit([1.3, 5.4, 1.8, 4.3, 8.7]) == [0.0, 0.5540540540540542, 0.06756756756756757, 0.40540540540540543, 1.0]", "assert rescale_to_unit([5.7, 2.2, 4.7, 8.7, 7.8]) == [0.5384615384615385, 0.0, 0.3846153846153847, 1.0, 0.8615384615384616]", "assert rescale_to_unit([1.6, 1.6, 4.7, 8.8, 6.6]) == [0.0, 0.0, 0.4305555555555555, 1.0, 0.6944444444444443]", "assert rescale_to_unit([2.1, 51.4]) == [0.0, 1.0]", "assert rescale_to_unit([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]", "assert rescale_to_unit([6.1, 50.2]) == [0.0, 1.0]", "assert rescale_to_unit([97.0, 52.7]) == [1.0, 0.0]", "assert rescale_to_unit([2.1, 3.9, 4.9, 8.0, 3.4]) == [0.0, 0.30508474576271183, 0.4745762711864407, 1.0, 0.22033898305084743]", "assert rescale_to_unit([7.8, 52.2]) == [0.0, 1.0]", "assert rescale_to_unit([5.9, 2.9, 8.4, 9.6, 6.9]) == [0.4477611940298509, 0.0, 0.8208955223880597, 1.0, 0.5970149253731344]", "assert rescale_to_unit([2.0, 49.9]) == [0.0, 1.0]", "assert rescale_to_unit([7.3, 7.5, 19.8, 18.8, 12.9]) == [0.0, 0.016000000000000014, 1.0, 0.92, 0.44800000000000006]", "assert rescale_to_unit([5.0, 1.6, 9.0, 8.2, 7.2]) == [0.45945945945945943, 0.0, 1.0, 0.8918918918918918, 0.7567567567567567]", "assert rescale_to_unit([3.5, 2.8, 8.2, 9.8, 6.8]) == [0.10000000000000002, 0.0, 0.7714285714285712, 1.0, 0.5714285714285714]", "assert rescale_to_unit([8.0, 9.3, 17.1, 18.5, 10.5]) == [0.0, 0.12380952380952388, 0.8666666666666668, 1.0, 0.23809523809523808]", "assert rescale_to_unit([6.6, 1.6, 1.3, 6.9, 2.3]) == [0.9464285714285713, 0.053571428571428575, 0.0, 1.0, 0.17857142857142852]", "assert rescale_to_unit([7.4, 45.9]) == [0.0, 1.0]", "assert rescale_to_unit([4.3, 2.5, 1.2, 4.0, 8.5]) == [0.4246575342465753, 0.17808219178082194, 0.0, 0.3835616438356164, 1.0]", "assert rescale_to_unit([7.9, 50.7]) == [0.0, 1.0]", "assert rescale_to_unit([4.9, 46.2]) == [0.0, 1.0]", "assert rescale_to_unit([4.4, 2.6, 2.1, 7.0, 2.4]) == [0.46938775510204084, 0.1020408163265306, 0.0, 1.0, 0.061224489795918324]", "assert rescale_to_unit([14.6, 6.7, 19.2, 13.8, 13.5]) == [0.632, 0.0, 1.0, 0.5680000000000001, 0.544]", "assert rescale_to_unit([95.6, 46.0]) == [1.0, 0.0]", "assert rescale_to_unit([2.5, 5.5, 10.2, 3.9, 4.4]) == [0.0, 0.38961038961038963, 1.0, 0.18181818181818182, 0.24675324675324684]", "assert rescale_to_unit([12.4, 8.1, 15.5, 14.4, 15.1]) == [0.5810810810810811, 0.0, 1.0, 0.8513513513513514, 0.9459459459459459]", "assert rescale_to_unit([105.5, 53.2]) == [1.0, 0.0]", "assert rescale_to_unit([102.1, 48.9]) == [1.0, 0.0]", "assert rescale_to_unit([6.1, 6.1, 8.0, 6.4, 8.7]) == [0.0, 0.0, 0.7307692307692311, 0.11538461538461567, 1.0]", "assert rescale_to_unit([100.0, 49.9]) == [1.0, 0.0]", "assert rescale_to_unit([12.2, 12.9, 12.4, 11.6, 16.9]) == [0.11320754716981128, 0.24528301886792472, 0.15094339622641526, 0.0, 1.0]", "assert rescale_to_unit([10.9, 13.2, 20.2, 11.2, 11.2]) == [0.0, 0.24731182795698917, 1.0, 0.03225806451612892, 0.03225806451612892]", "assert rescale_to_unit([96.2, 53.9]) == [1.0, 0.0]", "assert rescale_to_unit([95.4, 48.0]) == [1.0, 0.0]", "assert rescale_to_unit([5.7, 44.3]) == [0.0, 1.0]", "assert rescale_to_unit([102.0, 48.9]) == [1.0, 0.0]", "assert rescale_to_unit([2.4, 51.4]) == [0.0, 1.0]", "assert rescale_to_unit([16.1, 13.0, 15.9, 9.1, 15.3]) == [1.0, 0.557142857142857, 0.9714285714285713, 0.0, 0.8857142857142857]", "assert rescale_to_unit([2.5, 2.1, 4.3, 7.7, 9.7]) == [0.05263157894736841, 0.0, 0.28947368421052627, 0.7368421052631579, 1.0]", "assert rescale_to_unit([1.0, 48.4]) == [0.0, 1.0]", "assert rescale_to_unit([7.6, 6.9, 7.0, 2.7, 4.9]) == [1.0, 0.8571428571428573, 0.8775510204081634, 0.0, 0.4489795918367348]", "assert rescale_to_unit([5.5, 5.6, 3.1, 8.0, 9.4]) == [0.3809523809523809, 0.3968253968253967, 0.0, 0.7777777777777778, 1.0]", "assert rescale_to_unit([2.4, 3.2, 3.7, 8.2, 1.1]) == [0.18309859154929575, 0.295774647887324, 0.36619718309859156, 1.0, 0.0]", "assert rescale_to_unit([7.3, 1.5, 9.5, 4.6, 1.2]) == [0.7349397590361445, 0.03614457831325302, 1.0, 0.40963855421686735, 0.0]", "assert rescale_to_unit([105.8, 45.9]) == [1.0, 0.0]", "assert rescale_to_unit([9.7, 7.6, 13.7, 8.1, 10.3]) == [0.34426229508196715, 0.0, 1.0, 0.0819672131147541, 0.44262295081967235]", "assert rescale_to_unit([15.7, 12.5, 16.1, 8.7, 9.6]) == [0.9459459459459457, 0.5135135135135135, 1.0, 0.0, 0.12162162162162163]", "assert rescale_to_unit([10.1, 14.1, 14.5, 9.1, 9.5]) == [0.18518518518518517, 0.9259259259259258, 1.0, 0.0, 0.07407407407407414]", "assert rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]", "assert rescale_to_unit([6.7, 47.3]) == [0.0, 1.0]", "assert rescale_to_unit([5.9, 4.4, 1.4, 3.4, 2.8]) == [1.0, 0.6666666666666667, 0.0, 0.4444444444444444, 0.3111111111111111]", "assert rescale_to_unit([3.1, 6.8, 5.3, 5.4, 5.5]) == [0.0, 1.0, 0.5945945945945945, 0.6216216216216217, 0.6486486486486487]", "assert rescale_to_unit([4.1, 51.2]) == [0.0, 1.0]", "assert rescale_to_unit([5.0, 3.8, 8.2, 3.9, 1.1]) == [0.5492957746478874, 0.38028169014084506, 1.0, 0.39436619718309857, 0.0]", "assert rescale_to_unit([1.9, 4.8, 3.2, 4.3, 1.4]) == [0.14705882352941177, 1.0, 0.5294117647058825, 0.8529411764705882, 0.0]", "assert rescale_to_unit([10.1, 12.6, 10.2, 16.8, 11.1]) == [0.0, 0.3731343283582089, 0.014925373134328302, 1.0, 0.14925373134328357]", "assert rescale_to_unit([4.6, 5.7, 10.7, 5.4, 4.4]) == [0.03174603174603164, 0.20634920634920637, 1.0, 0.15873015873015875, 0.0]", "assert rescale_to_unit([7.0, 52.8]) == [0.0, 1.0]", "assert rescale_to_unit([98.1, 46.8]) == [1.0, 0.0]", "assert rescale_to_unit([4.4, 50.9]) == [0.0, 1.0]", "assert rescale_to_unit([5.5, 46.2]) == [0.0, 1.0]", "assert rescale_to_unit([3.2, 2.1, 1.6, 6.4, 3.7]) == [0.3333333333333333, 0.10416666666666666, 0.0, 1.0, 0.43749999999999994]", "assert rescale_to_unit([7.0, 51.8]) == [0.0, 1.0]", "assert rescale_to_unit([102.9, 44.8]) == [1.0, 0.0]", "assert rescale_to_unit([3.3, 4.4, 8.8, 2.9, 1.7]) == [0.22535211267605632, 0.38028169014084506, 1.0, 0.16901408450704222, 0.0]", "assert rescale_to_unit([17.6, 14.9, 12.4, 9.6, 14.2]) == [1.0, 0.6625, 0.35000000000000003, 0.0, 0.5749999999999998]", "assert rescale_to_unit([102.4, 46.0]) == [1.0, 0.0]", "assert rescale_to_unit([12.3, 14.5, 18.1, 18.3, 10.4]) == [0.24050632911392408, 0.5189873417721518, 0.9746835443037976, 1.0, 0.0]", "assert rescale_to_unit([105.8, 45.3]) == [1.0, 0.0]", "assert rescale_to_unit([5.4, 1.8, 4.4, 7.7, 2.8]) == [0.6101694915254238, 0.0, 0.44067796610169496, 1.0, 0.16949152542372878]", "assert rescale_to_unit([3.7, 3.9, 1.2, 4.6, 7.1]) == [0.42372881355932207, 0.45762711864406785, 0.0, 0.5762711864406779, 1.0]", "assert rescale_to_unit([9.7, 13.8, 18.7, 15.3, 14.7]) == [0.0, 0.4555555555555557, 1.0, 0.6222222222222223, 0.5555555555555556]", "assert rescale_to_unit([17.6, 8.7, 12.8, 9.2, 17.0]) == [1.0, 0.0, 0.46067415730337086, 0.05617977528089886, 0.9325842696629212]", "assert rescale_to_unit([2.5, 4.4, 8.0, 3.4, 10.2]) == [0.0, 0.24675324675324684, 0.7142857142857143, 0.11688311688311688, 1.0]", "assert rescale_to_unit([2.3, 3.4, 7.0, 6.8, 4.4]) == [0.0, 0.23404255319148937, 1.0, 0.9574468085106382, 0.44680851063829796]", "assert rescale_to_unit([4.3, 4.4, 6.1, 8.4, 1.2]) == [0.43055555555555547, 0.4444444444444445, 0.6805555555555555, 1.0, 0.0]", "assert rescale_to_unit([7.3, 7.4, 16.1, 10.7, 18.0]) == [0.0, 0.009345794392523414, 0.8224299065420562, 0.3177570093457944, 1.0]", "assert rescale_to_unit([102.3, 47.4]) == [1.0, 0.0]"], "nl": " Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    ", "func": "def rescale_to_unit(numbers: List[float]) -> List[float]:", "examples": ">>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    ", "completions": ["from typing import List\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    '''Given a list of numbers containing at least two elements, apply a linear transform to that list, such that the smallest number will transform into 0 and the largest will transform into 1.\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n    Returns:\n        List[float]: A list of floating-point numbers rescaled to the unit range.\n    '''\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    min_value = min(numbers)\n    max_value = max(numbers)\n    \n    if min_value == max_value:\n        return [0.0] * len(numbers)\n    \n    rescaling_factor = 1.0 / (max_value - min_value)\n    \n    rescaled_numbers = [((num - min_value) * rescaling_factor) for num in numbers]\n    \n    return rescaled_numbers\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    if len(numbers) == 0:\n        raise ValueError(\"The input list must contain at least one number.\")\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    if min_val == max_val:\n        raise ValueError(\"All numbers in the input list are the same. Cannot rescale to unit range.\")\n    \n    rescaled_numbers = [(num - min_val) / (max_val - min_val) for num in numbers]\n    return rescaled_numbers\n", "from typing import List\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    '''Given a list of numbers containing at least two elements, apply a linear transform to that list, such that the smallest number will transform into 0 and the largest will transform into 1.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n        [0.0, 0.25, 0.5, 0.75, 1.0]\n    '''\n    if len(numbers) < 2:\n        raise ValueError(\"The input list must contain at least two elements.\")\n    \n    min_value = min(numbers)\n    max_value = max(numbers)\n    \n    if min_value == max_value:\n        raise ValueError(\"All elements in the list are the same, cannot rescale.\")\n    \n    rescaled_numbers = [(x - min_value) / (max_value - min_value) for x in numbers]\n    return rescaled_numbers\n", "from typing import List\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    '''Given a list of numbers containing at least two elements, apply a linear transform to that list, such that the smallest number will transform into 0 and the largest will transform into 1.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n        [0.0, 0.25, 0.5, 0.75, 1.0]\n    '''\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    min_value = min(numbers)\n    max_value = max(numbers)\n    \n    if min_value == max_value:\n        raise ValueError(\"All numbers in the list are the same, cannot rescale.\")\n    \n    rescaled_numbers = [(num - min_value) / (max_value - min_value) for num in numbers]\n    return rescaled_numbers\n", "from typing import List\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    '''Given a list of numbers containing at least two elements, apply a linear transform to that list, such that the smallest number will transform into 0 and the largest will transform into 1.\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n    Returns:\n        List[float]: A list of rescaled floating-point numbers.\n    '''\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    min_value = min(numbers)\n    max_value = max(numbers)\n    \n    if min_value == max_value:\n        raise ValueError(\"All numbers in the list are the same, cannot rescale.\")\n    \n    rescaling_factor = 1 / (max_value - min_value)\n    \n    rescaled_numbers = [(num - min_value) * rescaling_factor for num in numbers]\n    \n    return rescaled_numbers\n", "from typing import List\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Rescales a list of numbers to a unit scale, where the minimum value maps to 0 and the maximum value maps to 1.\n    \n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n        \n    Returns:\n        List[float]: A list of floating-point numbers rescaled to the unit scale.\n        \n    Raises:\n        ValueError: If the input list contains fewer than two elements.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The input list must contain at least two elements.\")\n    \n    min_value = min(numbers)\n    max_value = max(numbers)\n    \n    if min_value == max_value:\n        raise ValueError(\"All numbers in the list are the same, cannot rescale.\")\n    \n    rescaled_numbers = [(num - min_value) / (max_value - min_value) for num in numbers]\n    \n    return rescaled_numbers\n", "from typing import List\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Rescales a list of numbers to a unit scale where the minimum value becomes 0 and the maximum value becomes 1.\n    \n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n    \n    Returns:\n        List[float]: A list of floating-point numbers rescaled to the unit scale.\n    \n    Raises:\n        ValueError: If the input list is empty or contains non-numeric values.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list is empty.\")\n    \n    if any(not isinstance(num, (int, float)) for num in numbers):\n        raise ValueError(\"The input list contains non-numeric values.\")\n    \n    min_value = min(numbers)\n    max_value = max(numbers)\n    \n    if min_value == max_value:\n        raise ValueError(\"All values in the list are the same, cannot rescale.\")\n    \n    rescaled_numbers = [(num - min_value) / (max_value - min_value) for num in numbers]\n    return rescaled_numbers\n", "from typing import List\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    '''\n    Given a list of numbers containing at least two elements, apply a linear transform to that list, such that the smallest number will transform into 0 and the largest will transform into 1.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n        [0.0, 0.25, 0.5, 0.75, 1.0]\n    '''\n    if len(numbers) < 2:\n        raise ValueError(\"The input list must contain at least two elements.\")\n    \n    min_value = min(numbers)\n    max_value = max(numbers)\n    \n    if min_value == max_value:\n        raise ValueError(\"All numbers in the list are the same, cannot rescale.\")\n    \n    rescaled_numbers = [(num - min_value) / (max_value - min_value) for num in numbers]\n    return rescaled_numbers\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Rescales a list of numbers to a unit scale where the minimum value is 0 and the maximum value is 1.\n\n    Args:\n        numbers (List[float]): The list of numbers to be rescaled.\n\n    Returns:\n        List[float]: The rescaled list of numbers.\n    \"\"\"\n    if len(numbers) == 0:\n        raise ValueError(\"The input list must contain at least one number.\")\n    \n    min_value = min(numbers)\n    max_value = max(numbers)\n    \n    if min_value == max_value:\n        raise ValueError(\"All numbers in the input list are the same. Cannot rescale to unit scale.\")\n    \n    rescaled_numbers = [(num - min_value) / (max_value - min_value) for num in numbers]\n    \n    return rescaled_numbers\n", "from typing import List\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    if not numbers:\n        return []\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    \n    rescaled_numbers = [(num - min_val) / (max_val - min_val) for num in numbers]\n    return rescaled_numbers\n"], "plans": ["requirement analysis:\nThe requirement is to rescale a list of numbers such that the smallest number becomes 0 and the largest number becomes 1. This is a common data transformation task and can be useful in various applications including normalization of data for machine learning models.\nrequirement pool:\n- Implement the function to rescale numbers to unit range\n- Ensure the function handles edge cases like negative numbers and zero\n- Include tests to verify the correctness of the rescaling\n- Add documentation to explain the function and its usage\n- Optimize the function for performance, especially for large lists\nTo implement the function `rescale_to_unit` that rescales a list of numbers such that the smallest number becomes 0 and the largest number becomes 1, we will use Python's built-in data structures and libraries. The function will first identify the minimum and maximum values in the list, then transform each number by applying a linear transformation formula.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'linear transformation'\n    In the requirement, it refers to the process of rescaling a list of numbers so that the smallest number becomes 0 and the largest number becomes 1. This is a common operation in data processing and statistics.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests the following steps:\n    1. Identify the minimum and maximum values in the list.\n    2. Apply a linear transformation formula to each number in the list.\n\n# [edge case] \n    rescale_to_unit([1.0, 1.0, 1.0]) = [0.0, 0.0, 0.0]\n    Explanation:\n    All elements in the list are the same, so after transformation, all elements will be 0.0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic will correctly handle the scenario where all elements in the list are the same.\n\n# [core concept]\n    'linear transformation'\n    Explanation: The core concept here is applying a mathematical transformation to a set of data to achieve a specific outcome, in this case, rescaling the numbers to a unit scale.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests the following steps:\n    1. Identify the minimum and maximum values in the list.\n    2. Apply a linear transformation formula to each number in the list.\n\n# [edge case] \n    rescale_to_unit([1.0, 1.0, 1.0]) = [0.0, 0.0, 0.0]\n    Explanation:\n    All elements in the list are the same, so after transformation, all elements will be 0.0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic will correctly handle the scenario where all elements in the list are the same.\n", "requirement analysis:\nThe requirement is to rescale a list of numbers such that the smallest number becomes 0 and the largest number becomes 1. This is a common data preprocessing step in many machine learning and statistical applications. The function should handle lists with at least two elements, and the transformation should be linear.\nrequirement pool:\n- The main code should correctly rescale the list of numbers to the unit interval.\n- The function should handle edge cases, such as lists with identical elements.\n- The function should be efficient, handling large lists without significant performance issues.\n- The function should be robust to floating-point precision issues.\n- The function should include appropriate type checking and error handling.\nTo implement the rescale_to_unit function, we will use Python's built-in libraries to ensure efficiency and simplicity. The function will first identify the minimum and maximum values in the input list. It will then transform each element in the list such that the minimum value becomes 0 and the maximum value becomes 1. This transformation will be linear, ensuring that the relationship between other values in the list is preserved.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'linear transformation'\n    In the requirement, it means applying a formula to each element in the list to change its value such that the smallest number becomes 0 and the largest number becomes 1.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests identifying the minimum and maximum values first, then transforming each element. This can be done in a single pass through the list after determining the min and max.\n\n# [edge case] \n    rescale_to_unit([1, 2]) = [0.0, 1.0]\n    Explanation: With only two elements, the smallest is 1 and the largest is 2. After transformation, 1 becomes 0 and 2 becomes 1.\n    rescale_to_unit([10, 20, 30, 40, 50]) = [0.0, 0.25, 0.5, 0.75, 1.0]\n    Explanation: The smallest number is 10 and the largest is 50. The transformation scales all numbers proportionally.\n    rescale_to_unit([-5, 0, 5]) = [0.0, 0.5, 1.0]\n    Explanation: Including negative numbers, the smallest is -5 and the largest is 5. The transformation includes negative numbers and scales them correctly.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic already covers lists with two or more elements, including cases with negative numbers.\n", "requirement analysis:\nThe requirement is to rescale a list of numbers such that the smallest number becomes 0 and the largest number becomes 1. This is a common data transformation task and can be useful in various applications including normalization of data for machine learning models.\nrequirement pool:\n- Implement the function to rescale numbers to unit range\n- Ensure the function handles edge cases like negative numbers and zero\n- Include tests to verify the correctness of the rescaling\n- Optimize the function for performance\n- Document the function and its usage\nTo implement the function `rescale_to_unit` that rescales a list of numbers such that the smallest number becomes 0 and the largest number becomes 1, we will use Python's built-in libraries and ensure the function is efficient and handles edge cases appropriately. The function will first identify the minimum and maximum values in the list, then apply a linear transformation to each element to achieve the desired range.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'linear transformation'\n    In the requirement, it refers to the process of rescaling a list of numbers so that the smallest number becomes 0 and the largest number becomes 1. This is a common operation in data processing and statistics.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests the following steps:\n    1. Identify the minimum and maximum values in the list.\n    2. Apply a linear transformation to each element in the list using the formula: `(x - min_value) / (max_value - min_value)` where `x` is the original number, `min_value` is the smallest number in the list, and `max_value` is the largest number in the list.\n\n# [edge case] \n    rescale_to_unit([1, 2, 3, 4, 5]) = [0.0, 0.25, 0.5, 0.75, 1.0]\n    Explanation:\n    The input list has a range from 1 to 5. The smallest number is 1 and the largest is 5. Applying the transformation:\n    - For 1: (1 - 1) / (5 - 1) = 0.0\n    - For 2: (2 - 1) / (5 - 1) = 0.25\n    - For 3: (3 - 1) / (5 - 1) = 0.5\n    - For 4: (4 - 1) / (5 - 1) = 0.75\n    - For 5: (5 - 1) / (5 - 1) = 1.0\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic will work correctly for any list of at least two elements.\n", "requirement analysis:\nThe requirement is to rescale a list of numbers such that the smallest number becomes 0 and the largest number becomes 1. This is a common data transformation task and can be useful in various applications including normalization of data for machine learning models.\nrequirement pool:\n- Implement the function to rescale the list of numbers\n- Ensure the function handles edge cases such as negative numbers and zero\n- Optimize the function for performance, especially for large lists\n- Add documentation and tests for the function\n- Integrate the function into a larger application if applicable\nTo implement the function `rescale_to_unit`, we will use Python's built-in libraries to ensure simplicity and efficiency. The function will take a list of floating-point numbers, find the minimum and maximum values, and then rescale each number in the list to a range between 0 and 1. This transformation will ensure that the smallest number in the list becomes 0 and the largest becomes 1.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'linear transformation'\n    In the requirement, it means applying a mathematical transformation to the list of numbers to scale them between a specific range, typically from 0 to 1.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Steps to implement the function `rescale_to_unit`:\n    1. Find the minimum and maximum values in the list.\n    2. Calculate the scaling factor for each number in the list.\n    3. Apply the scaling factor to each number to rescale it to the range [0, 1].\n\n# [edge case] \n    rescale_to_unit([1, 2, 3, 4, 5]) = [0.0, 0.25, 0.5, 0.75, 1.0]\n    Explanation:\n    The smallest number in the list is 1, and the largest is 5. After transformation, 1 becomes 0 and 5 becomes 1. The other numbers are scaled proportionally.\n    rescale_to_unit([5, 5, 4, 4, 4]) = [1.0, 1.0, 0.75, 0.75, 0.75]\n    Explanation:\n    The smallest number is 4, and the largest is 5. After transformation, 4 becomes 0.75 and 5 becomes 1.0. All occurrences of the number 4 are scaled to 0.75.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic already accounts for lists with at least two elements, which ensures that there are both a minimum and a maximum value to scale from.\n", "requirement analysis:\nThe requirement is to rescale a list of numbers such that the smallest number becomes 0 and the largest number becomes 1. This is a common requirement in data processing and analysis to normalize data for comparison or further calculations.\nrequirement pool:\n- Implement the function to rescale numbers to unit range.\n- Ensure the function handles edge cases like negative numbers and zero.\n- Optimize the function for performance, especially with large datasets.\n- Include detailed docstrings and comments for easy understanding.\n- Test the function with various inputs to ensure accuracy.\nTo implement the rescale_to_unit function, we will use Python's built-in data structures and libraries to ensure efficiency and simplicity. The function will take a list of floating-point numbers, find the minimum and maximum values, and then rescale each number in the list to fall within the range [0, 1]. This approach leverages Python's standard library for mathematical operations and list comprehensions, which are both efficient and easy to understand.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'linear transform'\n    In the requirement, it means applying a mathematical transformation to the list of numbers such that the smallest number becomes 0 and the largest number becomes 1.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests finding the minimum and maximum values in the list, which should be considered simultaneously.\n\n# [edge case] \n    rescale_to_unit([1, 2, 3, 4, 5]) = [0.0, 0.25, 0.5, 0.75, 1.0]\n    Explanation:\n    The smallest number in the list is 1, and the largest number is 5. After applying the linear transform, 1 becomes 0 and 5 becomes 1. The numbers in between are scaled proportionally.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided plan already covers the scenario where the list contains at least two elements.\n\n# [core concept]\n    'positive': means that all integers in the list are greater than 0\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find an integer greater than 0\n    'at least as many times': means that we need to find the integer whose occurrences are greater than or equal to its value\n\n# [degree adverb] \n    'largest': means that we need the largest integer that appears more than or equal to its value\n\n# [code logic]\n    provide detailed logic to implement the code\n\n# [edge case] \n    search([2, 2, 3, 3, 3]) = 3\n    Explanation:\n    Both 2 and 3 appear more than or equal to their values, but 3 is the largest number.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    Explanation:\n    Number 2 appears 2 times, number 3 appears 3 times, and number 4 appears 3 times. None of them appear more than or equal to their values, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.\n\n# [core concept]\n    'linear transform'\n    In the requirement, it means applying a mathematical transformation to the list of numbers such that the smallest number becomes 0 and the largest number becomes 1.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests finding the minimum and maximum values in the list, which should be considered simultaneously.\n\n# [edge case] \n    rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) = [0.0, 0.25, 0.5, 0.75, 1.0]\n    Explanation:\n    The smallest number in the list is 1.0, and the largest number is 5.0. After applying the linear transform, 1.0 becomes 0.0 and 5.0 becomes 1.0. The numbers in between are scaled proportionally.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided plan already covers the scenario where the list contains at least two elements.\n", "requirement analysis:\nThe requirement is to rescale a list of numbers such that the smallest number becomes 0 and the largest number becomes 1. This is a common requirement in data processing and analysis where normalization is necessary. The function should handle lists with at least two elements and ensure the transformation is linear.\nrequirement pool:\n- Implement the rescale_to_unit function to handle lists of floats.\n- Ensure the function correctly rescales the numbers to the unit scale.\n- Add error handling for cases where the input list does not contain at least two elements.\n- Optimize the function for performance, especially for large lists.\nTo implement the rescale_to_unit function, we will use Python's built-in libraries to ensure efficiency and simplicity. The function will first check if the input list contains at least two elements. If not, it will raise a ValueError. Then, it will identify the minimum and maximum values in the list, and apply a linear transformation to rescale all numbers such that the minimum value maps to 0 and the maximum value maps to 1. This transformation is achieved by subtracting the minimum value from each number and then dividing by the range (difference between the maximum and minimum values).\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'linear transformation'\n    In the requirement, it refers to the process of rescaling a set of numbers so that they fall within a specific range, typically from 0 to 1.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests the following steps:\n    1. Check if the input list contains at least two elements.\n    2. Identify the minimum and maximum values in the list.\n    3. Apply a linear transformation to rescale all numbers.\n\n# [edge case] \n    rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) = [0.0, 0.25, 0.5, 0.75, 1.0]\n    Explanation:\n    The smallest number (1.0) transforms into 0, and the largest number (5.0) transforms into 1. The other numbers are rescaled proportionally between 0 and 1.\n    rescale_to_unit([5.0, 5.0, 4.0, 4.0, 4.0]) = [1.0, 1.0, 0.75, 0.75, 0.75]\n    Explanation:\n    The smallest number (4.0) transforms into 0, and the largest number (5.0) transforms into 1. All other numbers are rescaled proportionally between 0 and 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic already checks for the minimum and maximum values and applies the linear transformation correctly.\n", "requirement analysis:\nThe requirement is to rescale a list of numbers such that the smallest number becomes 0 and the largest number becomes 1. This is a common data preprocessing step in many machine learning and statistical applications. The function should handle lists with at least two elements, ensuring a linear transformation that preserves the relative distances between numbers.\nrequirement pool:\n- The main code should correctly implement the linear transformation.\n- The function should handle edge cases, such as lists with identical elements.\n- The function should be optimized for performance, especially for large datasets.\n- The function should include error handling for non-numeric data.\n- The function should be documented with examples and usage instructions.\nTo implement the rescale_to_unit function, we will use Python's built-in libraries and ensure the function handles edge cases effectively. The function will first identify the minimum and maximum values in the list, then apply a linear transformation to rescale all numbers such that the minimum value becomes 0 and the maximum value becomes 1. We will also include error handling to manage non-numeric data.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'linear transformation'\n    In the requirement, it refers to the process of rescaling a set of numbers so that they fall within a certain range, typically 0 to 1.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Steps to implement the function:\n    1. Identify the minimum and maximum values in the list.\n    2. Apply the linear transformation formula to each number in the list.\n    3. Return the transformed list.\n\n# [edge case] \n    rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) = [0.0, 0.25, 0.5, 0.75, 1.0]\n    Explanation:\n    The minimum value in the list is 1.0, and the maximum value is 5.0. Applying the linear transformation formula:\n    (number - min) / (max - min)\n    For each number:\n    - 1.0 becomes (1.0 - 1.0) / (5.0 - 1.0) = 0.0\n    - 2.0 becomes (2.0 - 1.0) / (5.0 - 1.0) = 0.25\n    - 3.0 becomes (3.0 - 1.0) / (5.0 - 1.0) = 0.5\n    - 4.0 becomes (4.0 - 1.0) / (5.0 - 1.0) = 0.75\n    - 5.0 becomes (5.0 - 1.0) / (5.0 - 1.0) = 1.0\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic will correctly handle the transformation for a list of at least two elements.\n", "requirement analysis:\nThe requirement is to rescale a list of numbers such that the smallest number becomes 0 and the largest number becomes 1. This is a common data transformation task and can be useful in various applications, including data normalization and scaling.\nrequirement pool:\n- The main code should implement the rescale_to_unit function accurately.\n- The function should handle edge cases such as negative numbers and zero values.\n- The function should be optimized for performance, especially for large lists.\n- The function should include proper error handling for non-numeric inputs.\n- The function should be documented with examples and edge cases.\nTo implement the `rescale_to_unit` function, we will use Python's built-in libraries to ensure simplicity and efficiency. The function will first identify the minimum and maximum values in the input list, then apply a linear transformation to rescale all numbers such that the minimum value maps to 0 and the maximum value maps to 1. This approach leverages Python's ability to handle lists and mathematical operations directly, minimizing the need for external libraries.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'linear transformation'\n    In the requirement, it refers to the process of rescaling a set of numbers so that they fall within a certain range, typically 0 to 1.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests identifying the minimum and maximum values in the input list, which should be considered simultaneously.\n\n# [edge case] \n    rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) = [0.0, 0.25, 0.5, 0.75, 1.0]\n    Explanation: The smallest number is 1.0, which transforms to 0.0, and the largest number is 5.0, which transforms to 1.0. The numbers between are rescaled proportionally.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic directly applies the transformation for any list of at least two elements.\n", "requirement analysis:\nThe requirement is to rescale a list of numbers such that the smallest number becomes 0 and the largest becomes 1. This is a common requirement in data analysis and scaling techniques. The function should handle edge cases like negative numbers and ensure the output is a list of floats.\nrequirement pool:\n- The main code should correctly rescale the numbers to the unit scale.\n- The function should handle edge cases like negative numbers.\n- The output should be a list of floats.\n- The function should be efficient and handle large lists of numbers.\nTo implement the rescale_to_unit function, we will use Python's built-in libraries to ensure efficiency and simplicity. The function will first identify the minimum and maximum values in the input list, then apply a linear transformation to rescale all numbers such that the minimum value maps to 0 and the maximum value maps to 1. This approach leverages Python's ability to handle lists and mathematical operations efficiently.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'linear transformation'\n    In the requirement, it means applying a formula to adjust the range of numbers so that the smallest number becomes 0 and the largest number becomes 1.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (1) Identify the minimum and maximum values in the input list.\n    (2) Apply the linear transformation formula to each number in the list: `(number - min_value) / (max_value - min_value)`\n    (3) Return the transformed list.\n\n# [edge case] \n    rescale_to_unit([1, 2, 3, 4, 5]) = [0.0, 0.25, 0.5, 0.75, 1.0]\n    Explanation: The original list is [1, 2, 3, 4, 5]. The minimum value is 1 and the maximum value is 5. Applying the transformation formula to each number results in [0.0, 0.25, 0.5, 0.75, 1.0].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic will work correctly for lists with at least two elements.\n", "requirement analysis:\nThe requirement is to rescale a list of numbers such that the smallest number becomes 0 and the largest number becomes 1. This is a common data preprocessing step in many machine learning and statistical applications. The function should handle lists with at least two elements, and the transformation should be linear.\nrequirement pool:\n- The main code should correctly rescale the list of numbers to the unit interval.\n- The function should handle edge cases, such as lists with identical elements.\n- The function should be efficient, processing the list in linear time.\nTo implement the rescale_to_unit function, we will use Python's built-in libraries to ensure efficiency and simplicity. The function will first identify the minimum and maximum values in the input list. It will then transform each number in the list such that the minimum value becomes 0 and the maximum value becomes 1. If all elements in the list are identical, the function will return a list with all elements set to 0.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'linear transformation'\n    In the requirement, it refers to the process of rescaling a set of numbers so that they fall within a certain range, typically from 0 to 1.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests identifying the minimum and maximum values in the input list, which should be considered simultaneously.\n\n# [edge case] \n    rescale_to_unit([1, 2, 3, 4, 5]) = [0.0, 0.25, 0.5, 0.75, 1.0]\n    Explanation:\n    The smallest number is 1, which transforms into 0. The largest number is 5, which transforms into 1. The numbers 2, 3, and 4 are rescaled proportionally.\n    rescale_to_unit([5, 5, 5, 5]) = [0.0, 0.0, 0.0, 0.0]\n    Explanation:\n    All elements are identical, so all rescaled values are 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic will correctly handle the scenario where all elements in the list are identical.\n"], "scores": [0.6385, 1.0, 1.0, 1.0, 0.6385, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [false, true, true, true, false, true, true, true, true, true], "pass_test_cases_num": [83, 130, 130, 130, 83, 130, 130, 130, 130, 130], "completion": "from typing import List\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    if not numbers:\n        return []\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    \n    rescaled_numbers = [(num - min_val) / (max_val - min_val) for num in numbers]\n    return rescaled_numbers\n", "passed": true, "pass": true, "pass_num": 8, "round": 933, "repair_prompt": ["def rescale_to_unit(numbers: List[float]) -> List[float]:\t\n'''Given a list of numbers containing at least two elements, apply a linear transform to that list, such that the smallest number will transform into 0 and the largest will transform into 1.\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    '''", " def rescale_to_unit(numbers: List[float]) -> List[float]:\n    '''Given a list of numbers containing at least two elements, apply a linear transform to that list, such that the smallest number will transform into 0 and the largest will transform into 1.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n        [0.0, 0.25, 0.5, 0.75, 1.0]\n    '''\n   ", " def rescale_to_unit(numbers: List[float]) -> List[float]:\n    '''Given a list of numbers containing at least two elements, apply a linear transform to that list, such that the smallest number will transform into 0 and the largest will transform into 1.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n        [0.0, 0.25, 0.5, 0.75, 1.0]\n    '''"], "mutate_method": "rephrase_one", "parent_index": 446}
