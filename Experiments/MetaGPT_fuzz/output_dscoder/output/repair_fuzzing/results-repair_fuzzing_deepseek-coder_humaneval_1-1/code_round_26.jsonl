{"task_id": "HumanEval/30", "prompt": "def get_positive(l: list):\t\n'''Return only positive numbers in the list. Ensure that the output list maintains the original order of the positive numbers.\n>>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    '''", "entry_point": "get_positive", "canonical_solution": "    return [e for e in l if e > 0]\n", "test": ["def check(get_positive):\n\tassert get_positive([-1, -2]) == []", "def check(get_positive):\n\tassert get_positive([2, 0]) == [2]", "def check(get_positive):\n\tassert get_positive([3, -2]) == [3]", "def check(get_positive):\n\tassert get_positive([6, 5, -10, 6, 8, 7, 7, 5, 124, 2, -7]) == [6, 5, 6, 8, 7, 7, 5, 124, 2]", "def check(get_positive):\n\tassert get_positive([]) == []", "def check(get_positive):\n\tassert get_positive([3, 1]) == [3, 1]", "def check(get_positive):\n\tassert get_positive([7, 8, -9, 5, 7, 7, 13, 1, 121, 4, -13]) == [7, 8, 5, 7, 7, 13, 1, 121, 4]", "def check(get_positive):\n\tassert get_positive([3, 0, 9, 9, 1]) == [3, 9, 9, 1]", "def check(get_positive):\n\tassert get_positive([2, 4, -1, 6, 8, 8, 14, 3, 128, 5, -12]) == [2, 4, 6, 8, 8, 14, 3, 128, 5]", "def check(get_positive):\n\tassert get_positive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]", "def check(get_positive):\n\tassert get_positive([-4, -4]) == []", "def check(get_positive):\n\tassert get_positive([-1, -3, 9, 6, 2]) == [9, 6, 2]", "def check(get_positive):\n\tassert get_positive([-2, 3]) == [3]", "def check(get_positive):\n\tassert get_positive([1, 5, -2, 1, 3, 6, 4, 5, 124, 1, -5]) == [1, 5, 1, 3, 6, 4, 5, 124, 1]", "def check(get_positive):\n\tassert get_positive([-2, -3]) == []", "def check(get_positive):\n\tassert get_positive([-6, 1, 6, 9, 10]) == [1, 6, 9, 10]", "def check(get_positive):\n\tassert get_positive([3, 3, 6, 8, 2]) == [3, 3, 6, 8, 2]", "def check(get_positive):\n\tassert get_positive([6, 2, -8, 4, 6, 8, 8, 3, 122, 1, -9]) == [6, 2, 4, 6, 8, 8, 3, 122, 1]", "def check(get_positive):\n\tassert get_positive([3, 4, -2, 5, 3, 8, 6, 2, 128, 2, -13]) == [3, 4, 5, 3, 8, 6, 2, 128, 2]", "def check(get_positive):\n\tassert get_positive([2, 3, -1, 3, 2, 2, 4, 2, 123, 4, -12]) == [2, 3, 3, 2, 2, 4, 2, 123, 4]", "def check(get_positive):\n\tassert get_positive([-5, -5]) == []", "def check(get_positive):\n\tassert get_positive([6, 3, -5, 2, 5, 7, 4, 4, 128, 4, -14]) == [6, 3, 2, 5, 7, 4, 4, 128, 4]", "def check(get_positive):\n\tassert get_positive([1, -6]) == [1]", "def check(get_positive):\n\tassert get_positive([3, -1, 7, 7, 9]) == [3, 7, 7, 9]", "def check(get_positive):\n\tassert get_positive([-3, -1]) == []", "def check(get_positive):\n\tassert get_positive([-1, -6]) == []", "def check(get_positive):\n\tassert get_positive([8, 5, -10, 3, 1, 2, 13, 4, 119, 1, -6]) == [8, 5, 3, 1, 2, 13, 4, 119, 1]", "def check(get_positive):\n\tassert get_positive([2, -7, 8, 3, 10]) == [2, 8, 3, 10]", "def check(get_positive):\n\tassert get_positive([7, 1, -3, 3, 1, 7, 7, 4, 118, 5, -5]) == [7, 1, 3, 1, 7, 7, 4, 118, 5]", "def check(get_positive):\n\tassert get_positive([6, 1, -6, 2, 5, 8, 13, 5, 128, 2, -10]) == [6, 1, 2, 5, 8, 13, 5, 128, 2]", "def check(get_positive):\n\tassert get_positive([-3, -3]) == []", "def check(get_positive):\n\tassert get_positive([2, -4, 5, 4, 10]) == [2, 5, 4, 10]", "def check(get_positive):\n\tassert get_positive([-4, 0, 2, 5, 5]) == [2, 5, 5]", "def check(get_positive):\n\tassert get_positive([3, 0]) == [3]", "def check(get_positive):\n\tassert get_positive([2, 2, -1, 6, 5, 6, 13, 4, 126, 2, -8]) == [2, 2, 6, 5, 6, 13, 4, 126, 2]", "def check(get_positive):\n\tassert get_positive([6, 8, -8, 2, 5, 2, 6, 5, 125, 6, -12]) == [6, 8, 2, 5, 2, 6, 5, 125, 6]", "def check(get_positive):\n\tassert get_positive([-5, -7]) == []", "def check(get_positive):\n\tassert get_positive([-4, 1, 3, 2, 10]) == [1, 3, 2, 10]", "def check(get_positive):\n\tassert get_positive([7, 6, -6, 1, 7, 5, 13, 3, 127, 4, -8]) == [7, 6, 1, 7, 5, 13, 3, 127, 4]", "def check(get_positive):\n\tassert get_positive([1, -4, 9, 3, 9]) == [1, 9, 3, 9]", "def check(get_positive):\n\tassert get_positive([3, 1, 3, 4, 3]) == [3, 1, 3, 4, 3]", "def check(get_positive):\n\tassert get_positive([5, 5, -7, 6, 1, 7, 9, 4, 123, 6, -13]) == [5, 5, 6, 1, 7, 9, 4, 123, 6]", "def check(get_positive):\n\tassert get_positive([9, 3, -10, 4, 4, 3, 12, 5, 122, 2, -7]) == [9, 3, 4, 4, 3, 12, 5, 122, 2]", "def check(get_positive):\n\tassert get_positive([8, 5, -6, 1, 3, 3, 6, 3, 128, 5, -5]) == [8, 5, 1, 3, 3, 6, 3, 128, 5]", "def check(get_positive):\n\tassert get_positive([5, 6, -7, 1, 6, 6, 11, 5, 124, 2, -15]) == [5, 6, 1, 6, 6, 11, 5, 124, 2]", "def check(get_positive):\n\tassert get_positive([1, 3, -9, 5, 5, 3, 4, 1, 124, 2, -12]) == [1, 3, 5, 5, 3, 4, 1, 124, 2]", "def check(get_positive):\n\tassert get_positive([3, 3, 8, 7, 8]) == [3, 3, 8, 7, 8]", "def check(get_positive):\n\tassert get_positive([-4, 2]) == [2]", "def check(get_positive):\n\tassert get_positive([6, 1, -9, 1, 6, 8, 5, 5, 126, 5, -7]) == [6, 1, 1, 6, 8, 5, 5, 126, 5]", "def check(get_positive):\n\tassert get_positive([-4, -2]) == []", "def check(get_positive):\n\tassert get_positive([2, 3, -9, 4, 5, 4, 10, 2, 118, 3, -14]) == [2, 3, 4, 5, 4, 10, 2, 118, 3]", "def check(get_positive):\n\tassert get_positive([1, 5, -6, 1, 8, 2, 10, 3, 122, 2, -15]) == [1, 5, 1, 8, 2, 10, 3, 122, 2]", "def check(get_positive):\n\tassert get_positive([0, -4]) == []", "def check(get_positive):\n\tassert get_positive([-6, -1, 8, 8, 5]) == [8, 8, 5]", "def check(get_positive):\n\tassert get_positive([-2, -4]) == []", "def check(get_positive):\n\tassert get_positive([-6, -3]) == []", "def check(get_positive):\n\tassert get_positive([-3, -2, 3, 9, 4]) == [3, 9, 4]", "def check(get_positive):\n\tassert get_positive([7, 4, -8, 1, 2, 7, 14, 2, 126, 5, -15]) == [7, 4, 1, 2, 7, 14, 2, 126, 5]", "def check(get_positive):\n\tassert get_positive([-3, -1, 5, 2, 6]) == [5, 2, 6]", "def check(get_positive):\n\tassert get_positive([-3, -7, 3, 5, 8]) == [3, 5, 8]", "def check(get_positive):\n\tassert get_positive([0, 1, 5, 7, 5]) == [1, 5, 7, 5]", "def check(get_positive):\n\tassert get_positive([3, -1, 8, 7, 5]) == [3, 8, 7, 5]", "def check(get_positive):\n\tassert get_positive([3, 1, 3, 8, 11]) == [3, 1, 3, 8, 11]", "def check(get_positive):\n\tassert get_positive([4, -4]) == [4]", "def check(get_positive):\n\tassert get_positive([-2, -3, 1, 6, 2]) == [1, 6, 2]", "def check(get_positive):\n\tassert get_positive([1, 2, -9, 4, 3, 4, 5, 2, 127, 5, -14]) == [1, 2, 4, 3, 4, 5, 2, 127, 5]", "def check(get_positive):\n\tassert get_positive([10, 5, -1, 3, 3, 2, 4, 3, 121, 4, -11]) == [10, 5, 3, 3, 2, 4, 3, 121, 4]", "def check(get_positive):\n\tassert get_positive([3, 1, 1, 1, 7]) == [3, 1, 1, 1, 7]", "def check(get_positive):\n\tassert get_positive([4, -2, 3, 2, 11]) == [4, 3, 2, 11]", "def check(get_positive):\n\tassert get_positive([-2, 1, 8, 8, 6]) == [1, 8, 8, 6]", "def check(get_positive):\n\tassert get_positive([-5, 1, 3, 10, 3]) == [1, 3, 10, 3]", "def check(get_positive):\n\tassert get_positive([6, 8, -5, 7, 4, 3, 7, 2, 128, 2, -12]) == [6, 8, 7, 4, 3, 7, 2, 128, 2]", "def check(get_positive):\n\tassert get_positive([-4, -2, 6, 2, 4]) == [6, 2, 4]", "def check(get_positive):\n\tassert get_positive([6, 6, -10, 7, 2, 7, 12, 1, 126, 2, -5]) == [6, 6, 7, 2, 7, 12, 1, 126, 2]", "def check(get_positive):\n\tassert get_positive([5, 3, -10, 6, 7, 7, 4, 1, 124, 5, -14]) == [5, 3, 6, 7, 7, 4, 1, 124, 5]", "def check(get_positive):\n\tassert get_positive([4, -3, 9, 7, 11]) == [4, 9, 7, 11]", "def check(get_positive):\n\tassert get_positive([-2, -2]) == []", "def check(get_positive):\n\tassert get_positive([0, -4, 1, 2, 3]) == [1, 2, 3]", "def check(get_positive):\n\tassert get_positive([-2, -5]) == []", "def check(get_positive):\n\tassert get_positive([-3, -6]) == []", "def check(get_positive):\n\tassert get_positive([-3, 0, 4, 6, 6]) == [4, 6, 6]", "def check(get_positive):\n\tassert get_positive([-1, 2]) == [2]", "def check(get_positive):\n\tassert get_positive([-1, -2, 4, 5, 6]) == [4, 5, 6]", "def check(get_positive):\n\tassert get_positive([1, -2]) == [1]", "def check(get_positive):\n\tassert get_positive([2, 2, 7, 4, 3]) == [2, 2, 7, 4, 3]", "def check(get_positive):\n\tassert get_positive([3, 8, -10, 1, 1, 1, 12, 2, 125, 6, -9]) == [3, 8, 1, 1, 1, 12, 2, 125, 6]", "def check(get_positive):\n\tassert get_positive([1, 1]) == [1, 1]", "def check(get_positive):\n\tassert get_positive([-1, 2, 7, 10, 3]) == [2, 7, 10, 3]", "def check(get_positive):\n\tassert get_positive([4, 8, -8, 1, 6, 1, 14, 4, 122, 3, -7]) == [4, 8, 1, 6, 1, 14, 4, 122, 3]", "def check(get_positive):\n\tassert get_positive([4, -1, 9, 8, 9]) == [4, 9, 8, 9]", "def check(get_positive):\n\tassert get_positive([-3, 0]) == []", "def check(get_positive):\n\tassert get_positive([6, 7, -9, 6, 3, 2, 14, 1, 124, 3, -15]) == [6, 7, 6, 3, 2, 14, 1, 124, 3]", "def check(get_positive):\n\tassert get_positive([7, 6, -8, 4, 3, 5, 7, 4, 128, 2, -13]) == [7, 6, 4, 3, 5, 7, 4, 128, 2]", "def check(get_positive):\n\tassert get_positive([1, 3, 1, 9, 2]) == [1, 3, 1, 9, 2]", "def check(get_positive):\n\tassert get_positive([2, 2]) == [2, 2]", "def check(get_positive):\n\tassert get_positive([1, -5]) == [1]"], "test_case_list": ["assert get_positive([-1, -2]) == []", "assert get_positive([2, 0]) == [2]", "assert get_positive([3, -2]) == [3]", "assert get_positive([6, 5, -10, 6, 8, 7, 7, 5, 124, 2, -7]) == [6, 5, 6, 8, 7, 7, 5, 124, 2]", "assert get_positive([]) == []", "assert get_positive([3, 1]) == [3, 1]", "assert get_positive([7, 8, -9, 5, 7, 7, 13, 1, 121, 4, -13]) == [7, 8, 5, 7, 7, 13, 1, 121, 4]", "assert get_positive([3, 0, 9, 9, 1]) == [3, 9, 9, 1]", "assert get_positive([2, 4, -1, 6, 8, 8, 14, 3, 128, 5, -12]) == [2, 4, 6, 8, 8, 14, 3, 128, 5]", "assert get_positive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]", "assert get_positive([-4, -4]) == []", "assert get_positive([-1, -3, 9, 6, 2]) == [9, 6, 2]", "assert get_positive([-2, 3]) == [3]", "assert get_positive([1, 5, -2, 1, 3, 6, 4, 5, 124, 1, -5]) == [1, 5, 1, 3, 6, 4, 5, 124, 1]", "assert get_positive([-2, -3]) == []", "assert get_positive([-6, 1, 6, 9, 10]) == [1, 6, 9, 10]", "assert get_positive([3, 3, 6, 8, 2]) == [3, 3, 6, 8, 2]", "assert get_positive([6, 2, -8, 4, 6, 8, 8, 3, 122, 1, -9]) == [6, 2, 4, 6, 8, 8, 3, 122, 1]", "assert get_positive([3, 4, -2, 5, 3, 8, 6, 2, 128, 2, -13]) == [3, 4, 5, 3, 8, 6, 2, 128, 2]", "assert get_positive([2, 3, -1, 3, 2, 2, 4, 2, 123, 4, -12]) == [2, 3, 3, 2, 2, 4, 2, 123, 4]", "assert get_positive([-5, -5]) == []", "assert get_positive([6, 3, -5, 2, 5, 7, 4, 4, 128, 4, -14]) == [6, 3, 2, 5, 7, 4, 4, 128, 4]", "assert get_positive([1, -6]) == [1]", "assert get_positive([3, -1, 7, 7, 9]) == [3, 7, 7, 9]", "assert get_positive([-3, -1]) == []", "assert get_positive([-1, -6]) == []", "assert get_positive([8, 5, -10, 3, 1, 2, 13, 4, 119, 1, -6]) == [8, 5, 3, 1, 2, 13, 4, 119, 1]", "assert get_positive([2, -7, 8, 3, 10]) == [2, 8, 3, 10]", "assert get_positive([7, 1, -3, 3, 1, 7, 7, 4, 118, 5, -5]) == [7, 1, 3, 1, 7, 7, 4, 118, 5]", "assert get_positive([6, 1, -6, 2, 5, 8, 13, 5, 128, 2, -10]) == [6, 1, 2, 5, 8, 13, 5, 128, 2]", "assert get_positive([-3, -3]) == []", "assert get_positive([2, -4, 5, 4, 10]) == [2, 5, 4, 10]", "assert get_positive([-4, 0, 2, 5, 5]) == [2, 5, 5]", "assert get_positive([3, 0]) == [3]", "assert get_positive([2, 2, -1, 6, 5, 6, 13, 4, 126, 2, -8]) == [2, 2, 6, 5, 6, 13, 4, 126, 2]", "assert get_positive([6, 8, -8, 2, 5, 2, 6, 5, 125, 6, -12]) == [6, 8, 2, 5, 2, 6, 5, 125, 6]", "assert get_positive([-5, -7]) == []", "assert get_positive([-4, 1, 3, 2, 10]) == [1, 3, 2, 10]", "assert get_positive([7, 6, -6, 1, 7, 5, 13, 3, 127, 4, -8]) == [7, 6, 1, 7, 5, 13, 3, 127, 4]", "assert get_positive([1, -4, 9, 3, 9]) == [1, 9, 3, 9]", "assert get_positive([3, 1, 3, 4, 3]) == [3, 1, 3, 4, 3]", "assert get_positive([5, 5, -7, 6, 1, 7, 9, 4, 123, 6, -13]) == [5, 5, 6, 1, 7, 9, 4, 123, 6]", "assert get_positive([9, 3, -10, 4, 4, 3, 12, 5, 122, 2, -7]) == [9, 3, 4, 4, 3, 12, 5, 122, 2]", "assert get_positive([8, 5, -6, 1, 3, 3, 6, 3, 128, 5, -5]) == [8, 5, 1, 3, 3, 6, 3, 128, 5]", "assert get_positive([5, 6, -7, 1, 6, 6, 11, 5, 124, 2, -15]) == [5, 6, 1, 6, 6, 11, 5, 124, 2]", "assert get_positive([1, 3, -9, 5, 5, 3, 4, 1, 124, 2, -12]) == [1, 3, 5, 5, 3, 4, 1, 124, 2]", "assert get_positive([3, 3, 8, 7, 8]) == [3, 3, 8, 7, 8]", "assert get_positive([-4, 2]) == [2]", "assert get_positive([6, 1, -9, 1, 6, 8, 5, 5, 126, 5, -7]) == [6, 1, 1, 6, 8, 5, 5, 126, 5]", "assert get_positive([-4, -2]) == []", "assert get_positive([2, 3, -9, 4, 5, 4, 10, 2, 118, 3, -14]) == [2, 3, 4, 5, 4, 10, 2, 118, 3]", "assert get_positive([1, 5, -6, 1, 8, 2, 10, 3, 122, 2, -15]) == [1, 5, 1, 8, 2, 10, 3, 122, 2]", "assert get_positive([0, -4]) == []", "assert get_positive([-6, -1, 8, 8, 5]) == [8, 8, 5]", "assert get_positive([-2, -4]) == []", "assert get_positive([-6, -3]) == []", "assert get_positive([-3, -2, 3, 9, 4]) == [3, 9, 4]", "assert get_positive([7, 4, -8, 1, 2, 7, 14, 2, 126, 5, -15]) == [7, 4, 1, 2, 7, 14, 2, 126, 5]", "assert get_positive([-3, -1, 5, 2, 6]) == [5, 2, 6]", "assert get_positive([-3, -7, 3, 5, 8]) == [3, 5, 8]", "assert get_positive([0, 1, 5, 7, 5]) == [1, 5, 7, 5]", "assert get_positive([3, -1, 8, 7, 5]) == [3, 8, 7, 5]", "assert get_positive([3, 1, 3, 8, 11]) == [3, 1, 3, 8, 11]", "assert get_positive([4, -4]) == [4]", "assert get_positive([-2, -3, 1, 6, 2]) == [1, 6, 2]", "assert get_positive([1, 2, -9, 4, 3, 4, 5, 2, 127, 5, -14]) == [1, 2, 4, 3, 4, 5, 2, 127, 5]", "assert get_positive([10, 5, -1, 3, 3, 2, 4, 3, 121, 4, -11]) == [10, 5, 3, 3, 2, 4, 3, 121, 4]", "assert get_positive([3, 1, 1, 1, 7]) == [3, 1, 1, 1, 7]", "assert get_positive([4, -2, 3, 2, 11]) == [4, 3, 2, 11]", "assert get_positive([-2, 1, 8, 8, 6]) == [1, 8, 8, 6]", "assert get_positive([-5, 1, 3, 10, 3]) == [1, 3, 10, 3]", "assert get_positive([6, 8, -5, 7, 4, 3, 7, 2, 128, 2, -12]) == [6, 8, 7, 4, 3, 7, 2, 128, 2]", "assert get_positive([-4, -2, 6, 2, 4]) == [6, 2, 4]", "assert get_positive([6, 6, -10, 7, 2, 7, 12, 1, 126, 2, -5]) == [6, 6, 7, 2, 7, 12, 1, 126, 2]", "assert get_positive([5, 3, -10, 6, 7, 7, 4, 1, 124, 5, -14]) == [5, 3, 6, 7, 7, 4, 1, 124, 5]", "assert get_positive([4, -3, 9, 7, 11]) == [4, 9, 7, 11]", "assert get_positive([-2, -2]) == []", "assert get_positive([0, -4, 1, 2, 3]) == [1, 2, 3]", "assert get_positive([-2, -5]) == []", "assert get_positive([-3, -6]) == []", "assert get_positive([-3, 0, 4, 6, 6]) == [4, 6, 6]", "assert get_positive([-1, 2]) == [2]", "assert get_positive([-1, -2, 4, 5, 6]) == [4, 5, 6]", "assert get_positive([1, -2]) == [1]", "assert get_positive([2, 2, 7, 4, 3]) == [2, 2, 7, 4, 3]", "assert get_positive([3, 8, -10, 1, 1, 1, 12, 2, 125, 6, -9]) == [3, 8, 1, 1, 1, 12, 2, 125, 6]", "assert get_positive([1, 1]) == [1, 1]", "assert get_positive([-1, 2, 7, 10, 3]) == [2, 7, 10, 3]", "assert get_positive([4, 8, -8, 1, 6, 1, 14, 4, 122, 3, -7]) == [4, 8, 1, 6, 1, 14, 4, 122, 3]", "assert get_positive([4, -1, 9, 8, 9]) == [4, 9, 8, 9]", "assert get_positive([-3, 0]) == []", "assert get_positive([6, 7, -9, 6, 3, 2, 14, 1, 124, 3, -15]) == [6, 7, 6, 3, 2, 14, 1, 124, 3]", "assert get_positive([7, 6, -8, 4, 3, 5, 7, 4, 128, 2, -13]) == [7, 6, 4, 3, 5, 7, 4, 128, 2]", "assert get_positive([1, 3, 1, 9, 2]) == [1, 3, 1, 9, 2]", "assert get_positive([2, 2]) == [2, 2]", "assert get_positive([1, -5]) == [1]"], "nl": "Return only positive numbers in the list.\n    ", "func": "def get_positive(l: list):", "examples": ">>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    ", "completions": ["from typing import List\n## main.py\n\ndef get_positive(l: list) -> list:\n    \"\"\"\n    Filters positive numbers from a list while maintaining their original order.\n\n    Args:\n        l (list): A list of numbers.\n\n    Returns:\n        list: A list of positive numbers from the input list.\n    \"\"\"\n    positive_numbers = []\n    for number in l:\n        if number > 0:\n            positive_numbers.append(number)\n    return positive_numbers\n", "from typing import List\n## main.py\n\ndef get_positive(l: list) -> list:\n    \"\"\"\n    Filters positive numbers from the input list while maintaining their original order.\n\n    Args:\n        l (list): A list of integers.\n\n    Returns:\n        list: A list of positive integers from the input list.\n    \"\"\"\n    result = []\n    for num in l:\n        if num > 0:\n            result.append(num)\n    return result\n", "from typing import List\n## main.py\n\ndef get_positive(l: list) -> list:\n    \"\"\"\n    Filters positive numbers from a list while maintaining their original order.\n\n    Args:\n        l (list): The input list of numbers.\n\n    Returns:\n        list: A list containing only the positive numbers from the input list, in the same order.\n    \"\"\"\n    if not isinstance(l, list):\n        raise ValueError(\"Input must be a list\")\n    \n    positive_numbers = []\n    for number in l:\n        if number > 0:\n            positive_numbers.append(number)\n    \n    return positive_numbers\n", "from typing import List\n## main.py\n\ndef get_positive(l: list) -> list:\n    \"\"\"\n    This function takes a list of integers and returns a list of positive integers while maintaining their original order.\n    \n    Args:\n        l (list): A list of integers.\n    \n    Returns:\n        list: A list of positive integers from the input list.\n    \"\"\"\n    return [num for num in l if num > 0]\n", "from typing import List\n## main.py\n\ndef get_positive(l: list) -> list:\n    \"\"\"\n    This function takes a list of integers and returns a list of positive integers.\n    \n    Args:\n        l (list): A list of integers.\n    \n    Returns:\n        list: A list of positive integers from the input list.\n    \"\"\"\n    return [num for num in l if num > 0]\n", "from typing import List\n## main.py\n\ndef get_positive(l: list) -> list:\n    \"\"\"\n    Filters out the positive numbers from the input list while maintaining their order.\n\n    Args:\n        l (list): The input list of numbers.\n\n    Returns:\n        list: A list containing only the positive numbers from the input list, in the same order.\n    \"\"\"\n    positive_numbers = []\n    for number in l:\n        if number > 0:\n            positive_numbers.append(number)\n    return positive_numbers\n", "from typing import List\n## main.py\n\ndef get_positive(l: list) -> list:\n    \"\"\"\n    This function takes a list of integers and returns a list of positive integers.\n    \n    Args:\n        l (list): A list of integers.\n        \n    Returns:\n        list: A list of positive integers from the input list.\n    \"\"\"\n    return [num for num in l if num > 0]\n", "from typing import List\n## main.py\n\ndef get_positive(l: list) -> list:\n    \"\"\"\n    Filters positive numbers from the input list while maintaining their original order.\n\n    Args:\n        l (list): A list of integers.\n\n    Returns:\n        list: A list of positive integers from the input list.\n    \"\"\"\n    return [num for num in l if num > 0]\n\n# Example usage:\n# print(get_positive([-1, -2, -3]))  # Output: []\n# print(get_positive([7, 8, 9, 0, -1, -2]))  # Output: [7, 8, 9]\n# print(get_positive([]))  # Output: []\n", "from typing import List\n## main.py\n\ndef get_positive(l: list) -> list:\n    \"\"\"\n    Filters positive numbers from the input list while maintaining their original order.\n\n    Args:\n        l (list): A list of integers.\n\n    Returns:\n        list: A list of positive integers from the input list.\n    \"\"\"\n    return [num for num in l if num > 0]\n", "from typing import List\n## main.py\n\ndef get_positive(l: list) -> list:\n    \"\"\"\n    Filters positive numbers from a list while maintaining their original order.\n\n    Args:\n        l (list): The input list of numbers.\n\n    Returns:\n        list: A list containing only the positive numbers from the input list, in the same order.\n    \"\"\"\n    positive_numbers = []\n    for number in l:\n        if number > 0:\n            positive_numbers.append(number)\n    return positive_numbers\n"], "plans": ["requirement analysis:\nThe requirement is to filter out only positive numbers from a list while maintaining their original order. This is a straightforward task that requires basic list manipulation and iteration techniques.\nrequirement pool:\n- Implement a function that filters positive numbers from a list\n- Ensure the function maintains the order of positive numbers\n- Optimize the function for efficiency\n- Include error handling for non-list inputs\n- Add support for different data types within the list\nTo implement the function that filters positive numbers from a list while maintaining their original order, we will use Python's built-in capabilities for list manipulation. This approach is efficient and leverages Python's simplicity and readability. We will ensure that the function is optimized for clarity and efficiency, handling basic list operations effectively.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'positive numbers'\n    In the requirement, it means that we are only interested in numbers that are greater than zero.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests iterating through the list and checking each number to see if it is positive. If it is, we add it to a new list. This approach ensures that the order of positive numbers is maintained.\n\n# [edge case] \n    get_positive([-1, -2, -3, 0, 1, 2, 3]) = [1, 2, 3]\n    Explanation: The original list contains negative numbers and a zero, which are not included in the output. The positive numbers maintain their original order.\n    get_positive([-5, -4, -3, -2, -1]) = []\n    Explanation: All numbers in the list are negative, so the output list is empty.\n    get_positive([7, 8, 9, 10]) = [7, 8, 9, 10]\n    Explanation: The list contains only positive numbers, so the output list is the same as the input list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the list and checking for positivity is sufficient to handle all cases.\n", "requirement analysis:\nThe requirement is to filter out only positive numbers from a given list while maintaining the original order of the positive numbers. This is a straightforward task that focuses on list manipulation and iteration.\nrequirement pool:\n- Implement a function to filter positive numbers\n- Ensure the output list maintains the original order of positive numbers\n- Optimize the function for performance\n- Add user documentation and examples\nTo implement the function that filters positive numbers while maintaining their original order, we will use Python's built-in list and filter functions. This approach is straightforward and leverages Python's simplicity and readability.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'positive numbers'\n    In the requirement, it refers to numbers that are greater than zero.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Iterate through the list and check if each number is positive. If it is, add it to a new list.\n\n# [edge case] \n    get_positive([-1, -2, -3]) = []\n    Explanation: Since all numbers in the list are negative, the output list should be empty.\n    get_positive([0, 1, 2, 3]) = [1, 2, 3]\n    Explanation: The only positive number in the list is 1, but since 0 is not considered positive, the output list should only include 1, 2, and 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic of iterating through the list and checking for positivity will naturally result in an empty list when all elements are negative.\n\n# [core concept]\n    'positive'\n    Explanation: The core concept here is to filter out only the positive numbers from the list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Iterate through the list and check if each number is positive. If it is, add it to a new list.\n\n# [edge case] \n    get_positive([-1, -2, -3]) = []\n    Explanation: Since all numbers in the list are negative, the output list should be empty.\n    get_positive([0, 1, 2, 3]) = [1, 2, 3]\n    Explanation: The only positive number in the list is 1, but since 0 is not considered positive, the output list should only include 1, 2, and 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic of iterating through the list and checking for positivity will naturally result in an empty list when all elements are negative.\n", "requirement analysis:\nThe requirement is to filter out only positive numbers from a given list while maintaining the original order of the positive numbers. This is a straightforward task that involves iterating through the list and checking for positive numbers, then collecting them in a new list. The challenge here is to ensure that the order of positive numbers is preserved, which can be achieved by using an ordered collection like a list.\nrequirement pool:\n- Implement a function to filter positive numbers from a list\n- Ensure the output list maintains the original order of positive numbers\n- Optimize the function for performance\n- Add error handling for non-list inputs\nTo implement the function that filters positive numbers from a list while maintaining their original order, we will use Python's built-in list data structure. The function will iterate through the input list, check for positive numbers, and append them to a new list. This approach ensures that the order of positive numbers is preserved. We will also handle potential errors such as non-list inputs by checking the type of the input before processing.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'positive numbers'\n    In the requirement, it means that we are only interested in numbers that are greater than zero.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Iterate through the list and check if each number is greater than zero, then append it to a new list if it is.\n\n# [edge case] \n    get_positive([-1, -2, -3]) = []\n    Explanation: Since all numbers in the list are negative, the output list will be empty.\n    get_positive([0, 1, 2]) = [1, 2]\n    Explanation: The list contains only positive numbers, so the output list will be the same as the input list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic will correctly return an empty list for a list of negative numbers.\n\n# [core concept]\n    'positive numbers'\n    Explanation: The core concept here is to filter out only the positive numbers from the list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    Iterate through the list and check if each number is greater than zero, then append it to a new list if it is.\n\n# [edge case] \n    get_positive([-1, -2, -3]) = []\n    Explanation: Since all numbers in the list are negative, the output list will be empty.\n    get_positive([0, 1, 2]) = [1, 2]\n    Explanation: The list contains only positive numbers, so the output list will be the same as the input list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic will correctly return an empty list for a list of negative numbers.\n", "requirement analysis:\nThe original requirements specify a function that should return only positive numbers from a given list, maintaining the original order. This is a common requirement in data processing tasks, and the function should be efficient and easy to understand. The function should handle various types of input lists, including those with negative, positive, and zero values.\nrequirement pool:\n- The main code should filter out only positive numbers from the list.\n- The function should maintain the original order of positive numbers.\n- The function should handle edge cases, such as empty lists or lists with no positive numbers.\n- The function should be optimized for performance, especially for large lists.\nTo implement the function efficiently and maintain the original order of positive numbers, we will use Python's built-in capabilities. Specifically, we will leverage list comprehensions, which are both concise and performant for this task. The function will iterate through the input list, check for positive numbers, and collect them in a new list, thereby maintaining their original order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'positive numbers'\n    In the requirement, it means that we are only interested in numbers that are greater than zero.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests using list comprehensions to filter out positive numbers while maintaining the original order.\n\n# [edge case] \n    get_positive([-1, -2, -3, 0, 1, 2, 3]) = [1, 2, 3]\n    Explanation: The original list contains negative numbers and zero, which are filtered out, and the positive numbers maintain their original order.\n    get_positive([-5, -4, -3, -2, -1]) = []\n    Explanation: All numbers in the list are negative, so the output list is empty.\n    get_positive([7, 6, 5, 4, 3, 2, 1]) = [7, 6, 5, 4, 3, 2, 1]\n    Explanation: All numbers in the list are positive, so the output list is the same as the input list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The list comprehension will naturally handle cases where the input list contains only negative numbers or only zero.\n", "requirement analysis:\nThe original requirements specify a function that should return only positive numbers from a given list while maintaining the original order of these numbers. This is a common task in programming, and the challenge lies in ensuring that the function is efficient and handles edge cases well, such as lists with a mix of negative and positive numbers, and empty lists.\nrequirement pool:\n- Implement the function to filter positive numbers accurately\n- Ensure the function maintains the order of positive numbers\n- Optimize the function for performance on large lists\n- Add error handling for non-list inputs\n- Include documentation and examples in the function description\nTo implement the function efficiently and maintain the order of positive numbers, we will use Python's built-in capabilities. Specifically, we will leverage list comprehensions, which are both clear and concise for this task. This approach ensures that we filter positive numbers while maintaining their original order without introducing additional overhead.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'positive numbers'\n    In the requirement, it means that we are only interested in numbers that are greater than zero.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests using list comprehensions to filter positive numbers efficiently. This approach ensures that the order of positive numbers is maintained.\n\n# [edge case] \n    get_positive([-1, -2, -3, 0, 1, 2, 3]) = [1, 2, 3]\n    Explanation: The original list contains negative numbers and zeros, which are filtered out, and the remaining positive numbers maintain their original order.\n    get_positive([-5, -4, -3, -2, -1]) = []\n    Explanation: All numbers in the list are negative, so the output list is empty.\n    get_positive([7, 8, 9, 10]) = [7, 8, 9, 10]\n    Explanation: The list contains only positive numbers, so the output list is the same as the input list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The list comprehension already ensures that only positive numbers are included and maintains their order.\n", "requirement analysis:\nThe requirement is to create a function that filters out only positive numbers from a given list while maintaining the original order of the positive numbers. This is a basic requirement that should be straightforward to implement. The function should be efficient and easy to understand, making it accessible for users to apply in their projects.\nrequirement pool:\n- Implement the function to filter positive numbers\n- Ensure the function maintains the order of positive numbers\n- Optimize the function for performance\n- Add documentation and comments for clarity\n- Test the function with various edge cases\nTo implement the function efficiently and maintain the original order of positive numbers, we will use Python's built-in capabilities without relying on third-party libraries. This approach ensures simplicity and readability. We will iterate through the list, check for positive numbers, and append them to a new list while preserving their order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'positive numbers'\n    In the requirement, it means that we are only interested in numbers that are greater than zero.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests iterating through the list and checking for positive numbers. We can use a simple loop to filter out the positive numbers and maintain their order.\n\n# [edge case] \n    get_positive([-1, -2, -3, 0, 1, 2, 3]) = [1, 2, 3]\n    Explanation: The original list contains negative numbers and zero, which are filtered out. The positive numbers maintain their order from the original list.\n    get_positive([-5, -4, -3, -2, -1]) = []\n    Explanation: All numbers in the list are negative, so the output list is empty.\n    get_positive([7, 8, 9, 10]) = [7, 8, 9, 10]\n    Explanation: The list contains only positive numbers, so the output list is the same as the input list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the list and checking for positivity will naturally handle these cases.\n", "requirement analysis:\nThe original requirements specify a function that should return only positive numbers from a given list, maintaining the original order of these numbers. This is a common task in programming, and the challenge lies in ensuring the function is efficient and easy to understand. The function should handle various types of input lists, including negative numbers, zeros, and positive numbers.\nrequirement pool:\n- Implement the function to filter positive numbers\n- Ensure the function maintains the order of positive numbers\n- Optimize the code for readability and performance\n- Test the function with various edge cases\nTo implement the function efficiently and maintain the order of positive numbers, we will use Python's built-in capabilities. Specifically, we will utilize a list comprehension to filter out positive numbers while preserving their order. This approach is both simple and efficient, leveraging Python's readability and performance.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'positive numbers'\n    In the requirement, it refers to numbers that are greater than zero.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests using a list comprehension to filter out positive numbers while maintaining their order. This is a straightforward and efficient approach.\n\n# [edge case] \n    get_positive([-1, -2, -3, 0, 1, 2, 3]) = [1, 2, 3]\n    Explanation: The original list contains negative numbers and zeros, which are filtered out, and the positive numbers maintain their original order.\n    get_positive([-5, -4, -3, -2, -1]) = []\n    Explanation: All numbers in the list are negative, so the output is an empty list.\n    get_positive([7, 8, 9, 10]) = [7, 8, 9, 10]\n    Explanation: The list contains no negative numbers or zeros, so all numbers are included in the output.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The list comprehension will naturally handle cases where the input list contains no positive numbers or only negative numbers.\n", "requirement analysis:\nThe requirement is to create a function that filters out only positive numbers from a given list while maintaining the original order of these numbers. This is a common task in programming, especially when preparing data for further processing. The function should be efficient and easy to understand, making it suitable for both beginners and experienced developers.\nrequirement pool:\n- The function should correctly identify and return only positive numbers from the input list.\n- The function should maintain the order of positive numbers as they appear in the original list.\n- The function should handle edge cases, such as empty lists or lists with no positive numbers.\n- The function should be optimized for performance to handle large lists efficiently.\n- The function should be well-documented and include comments for easy understanding.\nTo create a function that filters positive numbers while maintaining their original order, we will use Python's built-in capabilities. Specifically, we will leverage list comprehension, which is both efficient and straightforward. This approach ensures that the function is easy to understand and maintain. We will also ensure that the function handles edge cases, such as empty lists or lists with no positive numbers, by adding a simple check at the beginning.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'positive numbers'\n    In the requirement, it means that we are only interested in numbers that are greater than zero.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests using list comprehension to filter out positive numbers while maintaining their original order. This is a straightforward and efficient approach.\n\n# [edge case] \n    get_positive([-1, -2, -3]) = []\n    Explanation: Since there are no positive numbers in the list, the expected output is an empty list.\n    get_positive([7, 8, 9, 0, -1, -2]) = [7, 8, 9]\n    Explanation: The function should return only the positive numbers [7, 8, 9] while maintaining their original order.\n    get_positive([]) = []\n    Explanation: If the input list is empty, the expected output is also an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of list comprehension will naturally handle these cases by returning an empty list when there are no positive numbers.\n", "requirement analysis:\nThe requirement is to create a function that filters out only positive numbers from a given list while maintaining the original order of these numbers. This is a common task in programming, and the challenge lies in ensuring the function is efficient and easy to understand. The function should handle various types of input lists, including those with negative numbers, zeros, and positive numbers in different orders.\nrequirement pool:\n- The main code should efficiently filter positive numbers\n- Ensure the function maintains the order of positive numbers\n- Optimize the code for readability\n- Test the function with various edge cases\n- Include comments in the code for better understanding\nTo create a function that filters positive numbers while maintaining their original order, we can utilize Python's built-in capabilities. We will use a list comprehension to iterate through the input list, check for positive numbers, and then return a new list containing only these positive numbers. This approach is efficient and leverages Python's readability and performance.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'positive numbers'\n    In the requirement, it means that we are only interested in numbers that are greater than zero.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    The plan suggests using a list comprehension to filter out positive numbers. This is a straightforward and efficient approach to maintain the original order of positive numbers.\n\n# [edge case] \n    get_positive([-1, -2, -3, 0, 1, 2, 3]) = [1, 2, 3]\n    Explanation: The original list contains negative numbers and zero, which are filtered out, and the remaining positive numbers are returned in their original order.\n    get_positive([-5, -4, -3, -2, -1]) = []\n    Explanation: All numbers in the list are negative, so the output list is empty.\n    get_positive([7, 8, 9, 10]) = [7, 8, 9, 10]\n    Explanation: The list contains only positive numbers, so the output list is the same as the input list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The list comprehension already ensures that only positive numbers are included, and the order is maintained as required.\n", "requirement analysis:\nThe requirement is to filter out only positive numbers from a list while maintaining their original order. This is a straightforward task that requires basic list manipulation and iteration. The challenge lies in ensuring that the order of positive numbers is preserved, which can be achieved using a straightforward approach.\nrequirement pool:\n- Implement a function that filters positive numbers from a list\n- Ensure the order of positive numbers is maintained\n- Optimize the function for efficiency\n- Include error handling for non-list inputs\nTo implement the function that filters positive numbers from a list while maintaining their original order, we will use Python's built-in list manipulation capabilities. This approach is straightforward and leverages Python's simplicity and readability. We will iterate through the list, check for positive numbers, and append them to a new list, thereby preserving their order.\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'positive numbers'\n    In the requirement, it means that we are only interested in numbers that are greater than zero.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    (check if there are steps should be considered simultaneously)\n    Iterate through the list and check if each number is greater than zero, if so, add it to a new list.\n\n# [edge case] \n    get_positive([-1, -2, -3]) = []\n    Explanation: Since all numbers in the list are negative, the output list will be empty.\n    get_positive([0, 1, 2, 3]) = [1, 2, 3]\n    Explanation: The list contains only positive numbers, so the output list will be the same as the input list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic of checking for positive numbers will naturally result in an empty list when all inputs are negative.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [96, 96, 96, 96, 96, 96, 96, 96, 96, 96], "completion": "from typing import List\n## main.py\n\ndef get_positive(l: list) -> list:\n    \"\"\"\n    Filters positive numbers from a list while maintaining their original order.\n\n    Args:\n        l (list): The input list of numbers.\n\n    Returns:\n        list: A list containing only the positive numbers from the input list, in the same order.\n    \"\"\"\n    positive_numbers = []\n    for number in l:\n        if number > 0:\n            positive_numbers.append(number)\n    return positive_numbers\n", "passed": true, "pass": true, "pass_num": 10, "round": 26, "repair_prompt": ["def get_positive(l: list):\t\n'''Return only positive numbers in the list. Ensure that the output list maintains the original order of the positive numbers.\n>>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    '''", " def get_positive(l: list):\t\n'''Return only positive numbers in the list. Ensure that the output list maintains the original order of the positive numbers.\n>>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 12", " def get_positive(l: list):\n    '''Return only positive numbers in the list. Ensure that the output list maintains the original order of the positive numbers.\n    >>> get_positive([-1, 2, -4, 5, 6])\n        [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 1"], "mutate_method": "add_1_sentence_at_end", "parent_index": 26}
